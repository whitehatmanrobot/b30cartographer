tual HRESULT STDMETHODCALLTYPE DefinitionToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIdentityAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIdentityAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIdentityAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIdentityAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceIdentity **ppIReferenceIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity);
        
        END_INTERFACE
    } IIdentityAuthorityVtbl;

    interface IIdentityAuthority
    {
        CONST_VTBL struct IIdentityAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIdentityAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIdentityAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIdentityAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)

#define IIdentityAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)

#define IIdentityAuthority_DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)

#define IIdentityAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)

#define IIdentityAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IIdentityAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IIdentityAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IIdentityAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IIdentityAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IIdentityAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IIdentityAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IIdentityAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);


void __RPC_STUB IIdentityAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceIdentity **ppIReferenceIdentity);


void __RPC_STUB IIdentityAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_DefinitionToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_ReferenceToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pDefinition1,
    /* [in] */ IDefinitionIdentity *pDefinition2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pReference1,
    /* [in] */ IReferenceIdentity *pReference2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesDefinitionMatchReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateDefinitionKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateReferenceKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateReference_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IReferenceIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIdentityAuthority_INTERFACE_DEFINED__ */


#ifndef __IAppIdAuthority_INTERFACE_DEFINED__
#define __IAppIdAuthority_INTERFACE_DEFINED__

/* interface IAppIdAuthority */
/* [local][unique][uuid][object] */ 

/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;
/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;

EXTERN_C const IID IID_IAppIdAuthority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c87810c-2541-4f75-b2d0-9af515488e23")
    IAppIdAuthority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TextToDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextToReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceAppId **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppIdAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppIdAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppIdAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppIdAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IReferenceAppId **ppNewIdentity);
        
        END_INTERFACE
    } IAppIdAuthorityVtbl;

    interface IAppIdAuthority
    {
        CONST_VTBL struct IAppIdAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppIdAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppIdAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppIdAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppIdAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)

#define IAppIdAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)

#define IAppIdAuthority_DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)

#define IAppIdAuthority_ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)

#define IAppIdAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)

#define IAppIdAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)

#define IAppIdAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IAppIdAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IAppIdAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IAppIdAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IAppIdAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IAppIdAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IAppIdAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IAppIdAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionAppId **ppIDefinitionAppId);


void __RPC_STUB IAppIdAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceAppId **ppIReferenceAppId);


void __RPC_STUB IAppIdAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DefinitionToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_ReferenceToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pDefinition1,
    /* [in] */ IDefinitionAppId *pDefinition2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pReference1,
    /* [in] */ IReferenceAppId *pReference2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesDefinitionMatchReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateDefinitionKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateReferenceKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IDefinitionAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateReference_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IReferenceAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppIdAuthority_INTERFACE_DEFINED__ */


/* [local] */ HRESULT __stdcall GetAppIdAuthority( 
    /* [out] */ IAppIdAuthority **ppIAppIdAuthority);

/* [local] */ HRESULT __stdcall GetIdentityAuthority( 
    /* [out] */ IIdentityAuthority **ppIIdentityAuthority);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\kernelspecs.h ===
/*****************************************************************************\
*                                                                             *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See DriverSpecs.h for detailed comments                     *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/*****************************************************************************\
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/

/*****************************************************************************\
* As noted in DriverSpecs.h, this header contains "real" definitions for
* annotations that either never appear in user space, or which are meaningles
* in user space and are #defined to nothing by DriverSpecs.h.
*
* Further commentary appears in DriverSpecs.h.
\*****************************************************************************/

#include "DriverSpecs.h"

#if _MSC_VER > 1000 // [
#pragma once
#endif // ]

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]

	// ---------------------------------------------------------------------
	// The symbolic IRQL values can sometimes end up undefined, so define
	// the usual ones here, for PREfast purposes only.

	#define DISPATCH_LEVEL 2
	#define APC_LEVEL 1
	#define PASSIVE_LEVEL 0

	// ---------------------------------------------------------------------
	// Maintenance of IRQL values
	//
	// __drv_setsIRQL(irql)
	// __drv_raisesIRQL(irql)
	// __drv_requiresIRQL(irql)
	// __drv_maxIRQL(irql)
	// __drv_minIRQL(irql)
	// __drv_savesIRQL
	// __drv_restoresIRQL
	// __drv_savesIRQLGlobal(kind,param)
	// __drv_restoresIRQLGlobal(kind,param)
	// __drv_minFunctionIRQL(irql)
	// __drv_maxFunctionIRQL(irql)
	// __drv_useCancelIRQL
	// __drv_sameIRQL

	// 
	// The funciton exits at IRQL irql
	//
	// ';' inside the parens to keep MIDL happy
	__ANNOTATION(SAL_IRQL(__int64);)
	#undef __drv_setsIRQL
	#define __drv_setsIRQL(irql)											\
		__post __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")

	// 
	// The funciton exits at IRQL irql, but this may only raise the irql.
	//
	#undef __drv_raisesIRQL
	__ANNOTATION(SAL_raiseIRQL(__int64);)
	#define __drv_raisesIRQL(irql)											\
		__post __drv_declspec("SAL_raiseIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The called function must be entered at IRQL level
	//
	#undef __drv_requiresIRQL
	__ANNOTATION(SAL_IRQL(__int64);)
	#define __drv_requiresIRQL(irql)										\
		__pre __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")


	// 
	// The maximum IRQL at which the function may be called.
	//
	#undef __drv_maxIRQL
	__ANNOTATION(SAL_maxIRQL(__int64);)
	#define __drv_maxIRQL(irql)												\
		__pre __drv_declspec("SAL_maxIRQL("SPECSTRINGIZE(irql)")")
	// 
	// The minimum IRQL at which the function may be called.
	//
	#undef __drv_minIRQL
	__ANNOTATION(SAL_minIRQL(__int64);)
	#define __drv_minIRQL(irql)												\
		__pre __drv_declspec("SAL_minIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The current IRQL is saved in the annotated parameter
	//
	#undef __drv_savesIRQL
	__ANNOTATION(SAL_saveIRQL(void);)
	#define __drv_savesIRQL __post __drv_declspec("SAL_saveIRQL")

	// 
	// The current IRQL is saved in the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#undef __drv_savesIRQLGlobal
	__ANNOTATION(SAL_saveIRQLGlobal(__in char *, ...);)
	#define __drv_savesIRQLGlobal(kind,param)								\
		__post __drv_declspec("SAL_saveIRQLGlobal(\"" #kind "\","			\
										   SPECSTRINGIZE(param\t)")")

	// 
	// The current IRQL is restored from the annotated parameter
	//
	#undef __drv_restoresIRQL
	__ANNOTATION(SAL_restoreIRQL(void);)
	#define __drv_restoresIRQL __post __drv_declspec("SAL_restoreIRQL")

	// 
	// The current IRQL is restored from the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#undef __drv_restoresIRQLGlobal
	__ANNOTATION(SAL_restoreIRQLGlobal(__in char *, ...);)
	#define __drv_restoresIRQLGlobal(kind,param)							\
		__post __drv_declspec("SAL_restoreIRQLGlobal(\"" #kind "\","		\
										   SPECSTRINGIZE(param\t)")")

	// The minimum IRQL to which the function can lower itself.	 The IRQL
	// at entry is assumed to be that value unless overridden.
	#undef __drv_minFunctionIRQL
	__ANNOTATION(SAL_minFunctionIrql(__int64);)
	#define __drv_minFunctionIRQL(irql)\
	    __pre __drv_declspec("SAL_minFunctionIrql(" SPECSTRINGIZE(irql) ")") 


	// The maximum IRQL to which the function can raise itself.
	#undef __drv_maxFunctionIRQL
	__ANNOTATION(SAL_maxFunctionIrql(__int64);)
	#define __drv_maxFunctionIRQL(irql)\
	    __pre __drv_declspec("SAL_maxFunctionIrql(" SPECSTRINGIZE(irql) ")") 

	// The function must exit with the same IRQL it was entered with.
	// (It may change it but it must restore it.)
	#undef __drv_sameIRQL
	__ANNOTATION(SAL_sameIRQL(void);)
	#define __drv_sameIRQL\
		__post __drv_declspec("SAL_sameIRQL")

	// The annotated parameter contains the cancelIRQL, which will be restored
	// by the called function.

	#undef __drv_useCancelIRQL
	__ANNOTATION(SAL_UseCancelIrql(void);)
	#define __drv_useCancelIRQL												\
		__post __drv_declspec("SAL_UseCancelIrql") 


#ifdef _PREFAST_ // RC workaround; already #defined to nothing if not needed
	// Passing the cancel Irql to a utility function
	#undef __drv_isCancelIRQL
	#define __drv_isCancelIRQL\
		__drv_useCancelIRQL													\
		__drv_at(return, __drv_innerMustHoldGlobal(CancelSpinLock,)			\
				 __drv_innerReleasesGlobal(CancelSpinLock,)					\
				 __drv_minFunctionIRQL(DISPATCH_LEVEL)						\
				 __drv_requiresIRQL(DISPATCH_LEVEL))
#endif

#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ISysmon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for sysmon.odl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __isysmon_h__
#define __isysmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICounterItem_FWD_DEFINED__
#define __ICounterItem_FWD_DEFINED__
typedef interface ICounterItem ICounterItem;
#endif 	/* __ICounterItem_FWD_DEFINED__ */


#ifndef __ICounterItem2_FWD_DEFINED__
#define __ICounterItem2_FWD_DEFINED__
typedef interface ICounterItem2 ICounterItem2;
#endif 	/* __ICounterItem2_FWD_DEFINED__ */


#ifndef ___ICounterItemUnion_FWD_DEFINED__
#define ___ICounterItemUnion_FWD_DEFINED__
typedef interface _ICounterItemUnion _ICounterItemUnion;
#endif 	/* ___ICounterItemUnion_FWD_DEFINED__ */


#ifndef __DICounterItem_FWD_DEFINED__
#define __DICounterItem_FWD_DEFINED__
typedef interface DICounterItem DICounterItem;
#endif 	/* __DICounterItem_FWD_DEFINED__ */


#ifndef __ICounters_FWD_DEFINED__
#define __ICounters_FWD_DEFINED__
typedef interface ICounters ICounters;
#endif 	/* __ICounters_FWD_DEFINED__ */


#ifndef __ILogFileItem_FWD_DEFINED__
#define __ILogFileItem_FWD_DEFINED__
typedef interface ILogFileItem ILogFileItem;
#endif 	/* __ILogFileItem_FWD_DEFINED__ */


#ifndef __DILogFileItem_FWD_DEFINED__
#define __DILogFileItem_FWD_DEFINED__
typedef interface DILogFileItem DILogFileItem;
#endif 	/* __DILogFileItem_FWD_DEFINED__ */


#ifndef __ILogFiles_FWD_DEFINED__
#define __ILogFiles_FWD_DEFINED__
typedef interface ILogFiles ILogFiles;
#endif 	/* __ILogFiles_FWD_DEFINED__ */


#ifndef __ISystemMonitor_FWD_DEFINED__
#define __ISystemMonitor_FWD_DEFINED__
typedef interface ISystemMonitor ISystemMonitor;
#endif 	/* __ISystemMonitor_FWD_DEFINED__ */


#ifndef __ISystemMonitor2_FWD_DEFINED__
#define __ISystemMonitor2_FWD_DEFINED__
typedef interface ISystemMonitor2 ISystemMonitor2;
#endif 	/* __ISystemMonitor2_FWD_DEFINED__ */


#ifndef ___ISystemMonitorUnion_FWD_DEFINED__
#define ___ISystemMonitorUnion_FWD_DEFINED__
typedef interface _ISystemMonitorUnion _ISystemMonitorUnion;
#endif 	/* ___ISystemMonitorUnion_FWD_DEFINED__ */


#ifndef __DISystemMonitor_FWD_DEFINED__
#define __DISystemMonitor_FWD_DEFINED__
typedef interface DISystemMonitor DISystemMonitor;
#endif 	/* __DISystemMonitor_FWD_DEFINED__ */


#ifndef __DISystemMonitorInternal_FWD_DEFINED__
#define __DISystemMonitorInternal_FWD_DEFINED__
typedef interface DISystemMonitorInternal DISystemMonitorInternal;
#endif 	/* __DISystemMonitorInternal_FWD_DEFINED__ */


#ifndef __ISystemMonitorEvents_FWD_DEFINED__
#define __ISystemMonitorEvents_FWD_DEFINED__
typedef interface ISystemMonitorEvents ISystemMonitorEvents;
#endif 	/* __ISystemMonitorEvents_FWD_DEFINED__ */


#ifndef __DISystemMonitorEvents_FWD_DEFINED__
#define __DISystemMonitorEvents_FWD_DEFINED__
typedef interface DISystemMonitorEvents DISystemMonitorEvents;
#endif 	/* __DISystemMonitorEvents_FWD_DEFINED__ */


#ifndef __SystemMonitor_FWD_DEFINED__
#define __SystemMonitor_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemMonitor SystemMonitor;
#else
typedef struct SystemMonitor SystemMonitor;
#endif /* __cplusplus */

#endif 	/* __SystemMonitor_FWD_DEFINED__ */


#ifndef __CounterItem_FWD_DEFINED__
#define __CounterItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterItem CounterItem;
#else
typedef struct CounterItem CounterItem;
#endif /* __cplusplus */

#endif 	/* __CounterItem_FWD_DEFINED__ */


#ifndef __Counters_FWD_DEFINED__
#define __Counters_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counters Counters;
#else
typedef struct Counters Counters;
#endif /* __cplusplus */

#endif 	/* __Counters_FWD_DEFINED__ */


#ifndef __LogFileItem_FWD_DEFINED__
#define __LogFileItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class LogFileItem LogFileItem;
#else
typedef struct LogFileItem LogFileItem;
#endif /* __cplusplus */

#endif 	/* __LogFileItem_FWD_DEFINED__ */


#ifndef __LogFiles_FWD_DEFINED__
#define __LogFiles_FWD_DEFINED__

#ifdef __cplusplus
typedef class LogFiles LogFiles;
#else
typedef struct LogFiles LogFiles;
#endif /* __cplusplus */

#endif 	/* __LogFiles_FWD_DEFINED__ */


#ifndef __CounterItem2_FWD_DEFINED__
#define __CounterItem2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterItem2 CounterItem2;
#else
typedef struct CounterItem2 CounterItem2;
#endif /* __cplusplus */

#endif 	/* __CounterItem2_FWD_DEFINED__ */


#ifndef __SystemMonitor2_FWD_DEFINED__
#define __SystemMonitor2_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemMonitor2 SystemMonitor2;
#else
typedef struct SystemMonitor2 SystemMonitor2;
#endif /* __cplusplus */

#endif 	/* __SystemMonitor2_FWD_DEFINED__ */


#ifndef __AppearPropPage_FWD_DEFINED__
#define __AppearPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppearPropPage AppearPropPage;
#else
typedef struct AppearPropPage AppearPropPage;
#endif /* __cplusplus */

#endif 	/* __AppearPropPage_FWD_DEFINED__ */


#ifndef __GeneralPropPage_FWD_DEFINED__
#define __GeneralPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GeneralPropPage GeneralPropPage;
#else
typedef struct GeneralPropPage GeneralPropPage;
#endif /* __cplusplus */

#endif 	/* __GeneralPropPage_FWD_DEFINED__ */


#ifndef __GraphPropPage_FWD_DEFINED__
#define __GraphPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GraphPropPage GraphPropPage;
#else
typedef struct GraphPropPage GraphPropPage;
#endif /* __cplusplus */

#endif 	/* __GraphPropPage_FWD_DEFINED__ */


#ifndef __SourcePropPage_FWD_DEFINED__
#define __SourcePropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SourcePropPage SourcePropPage;
#else
typedef struct SourcePropPage SourcePropPage;
#endif /* __cplusplus */

#endif 	/* __SourcePropPage_FWD_DEFINED__ */


#ifndef __CounterPropPage_FWD_DEFINED__
#define __CounterPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterPropPage CounterPropPage;
#else
typedef struct CounterPropPage CounterPropPage;
#endif /* __cplusplus */

#endif 	/* __CounterPropPage_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __SystemMonitor_LIBRARY_DEFINED__
#define __SystemMonitor_LIBRARY_DEFINED__

/* library SystemMonitor */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring] */ 
enum eDisplayTypeConstant
    {	sysmonLineGraph	= 1,
	sysmonHistogram	= 2,
	sysmonReport	= 3,
	sysmonChartArea	= 4,
	sysmonChartStackedArea	= 5
    } 	DisplayTypeConstants;

typedef /* [helpstring] */ 
enum eReportValueTypeConstant
    {	sysmonDefaultValue	= 0,
	sysmonCurrentValue	= 0x1,
	sysmonAverage	= 0x2,
	sysmonMinimum	= 0x3,
	sysmonMaximum	= 0x4
    } 	ReportValueTypeConstants;

typedef /* [helpstring] */ 
enum eDataSourceTypeConstant
    {	sysmonNullDataSource	= 0xffffffff,
	sysmonCurrentActivity	= 0x1,
	sysmonLogFiles	= 0x2,
	sysmonSqlLog	= 0x3
    } 	DataSourceTypeConstants;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0001
    {	sysmonFileHtml	= 1,
	sysmonFileReport	= 2,
	sysmonFileCsv	= 3,
	sysmonFileTsv	= 4,
	sysmonFileBlg	= 5,
	sysmonFileRetiredBlg	= 6,
	sysmonFileGif	= 7
    } 	SysmonFileType;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0002
    {	sysmonDataAvg	= 1,
	sysmonDataMin	= 2,
	sysmonDataMax	= 3,
	sysmonDataTime	= 4,
	sysmonDataCount	= 5
    } 	SysmonDataType;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0003
    {	sysmonBatchNone	= 0,
	sysmonBatchAddFiles	= 1,
	sysmonBatchAddCounters	= 2,
	sysmonBatchAddFilesAutoCounters	= 3
    } 	SysmonBatchReason;


DEFINE_GUID(LIBID_SystemMonitor,0x1B773E42,0x2509,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifndef __ICounterItem_INTERFACE_DEFINED__
#define __ICounterItem_INTERFACE_DEFINED__

/* interface ICounterItem */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounterItem,0x771A9520,0xEE28,0x11ce,0x94,0x1E,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("771A9520-EE28-11ce-941E-008029004347")
    ICounterItem : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pdblValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ INT iWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ INT iLineStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LineStyle( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScaleFactor( 
            /* [in] */ INT iScale) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ScaleFactor( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounterItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounterItem * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in ICounterItem * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICounterItem * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in ICounterItem * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        END_INTERFACE
    } ICounterItemVtbl;

    interface ICounterItem
    {
        CONST_VTBL struct ICounterItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounterItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounterItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounterItem_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define ICounterItem_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define ICounterItem_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define ICounterItem_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define ICounterItem_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define ICounterItem_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define ICounterItem_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define ICounterItem_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define ICounterItem_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define ICounterItem_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define ICounterItem_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define ICounterItem_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounterItem_INTERFACE_DEFINED__ */


#ifndef __ICounterItem2_INTERFACE_DEFINED__
#define __ICounterItem2_INTERFACE_DEFINED__

/* interface ICounterItem2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounterItem2,0xeefcd4e1,0xea1c,0x4435,0xb7,0xf4,0xe3,0x41,0xba,0x03,0xb4,0xf9);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eefcd4e1-ea1c-4435-b7f4-e341ba03b4f9")
    ICounterItem2 : public ICounterItem
    {
    public:
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataAt( 
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounterItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounterItem2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICounterItem2 * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in ICounterItem2 * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataAt )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ICounterItem2Vtbl;

    interface ICounterItem2
    {
        CONST_VTBL struct ICounterItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounterItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounterItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounterItem2_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define ICounterItem2_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define ICounterItem2_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define ICounterItem2_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define ICounterItem2_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define ICounterItem2_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define ICounterItem2_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define ICounterItem2_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define ICounterItem2_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define ICounterItem2_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define ICounterItem2_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define ICounterItem2_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 


#define ICounterItem2_put_Selected(This,bState)	\
    ( (This)->lpVtbl -> put_Selected(This,bState) ) 

#define ICounterItem2_get_Selected(This,pbState)	\
    ( (This)->lpVtbl -> get_Selected(This,pbState) ) 

#define ICounterItem2_put_Visible(This,bState)	\
    ( (This)->lpVtbl -> put_Visible(This,bState) ) 

#define ICounterItem2_get_Visible(This,pbState)	\
    ( (This)->lpVtbl -> get_Visible(This,pbState) ) 

#define ICounterItem2_GetDataAt(This,iIndex,iWhich,pVariant)	\
    ( (This)->lpVtbl -> GetDataAt(This,iIndex,iWhich,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounterItem2_INTERFACE_DEFINED__ */


#ifndef ___ICounterItemUnion_INTERFACE_DEFINED__
#define ___ICounterItemUnion_INTERFACE_DEFINED__

/* interface _ICounterItemUnion */
/* [object][hidden][uuid] */ 


DEFINE_GUID(IID__ICounterItemUnion,0xde1a6b74,0x9182,0x4c41,0x8e,0x2c,0x24,0xc2,0xcd,0x30,0xee,0x83);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("de1a6b74-9182-4c41-8e2c-24c2cd30ee83")
    _ICounterItemUnion : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pdblValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ INT iWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ INT iLineStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LineStyle( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScaleFactor( 
            /* [in] */ INT iScale) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ScaleFactor( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataAt( 
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _ICounterItemUnionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ICounterItemUnion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ICounterItemUnion * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in _ICounterItemUnion * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in _ICounterItemUnion * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataAt )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } _ICounterItemUnionVtbl;

    interface _ICounterItemUnion
    {
        CONST_VTBL struct _ICounterItemUnionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ICounterItemUnion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ICounterItemUnion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ICounterItemUnion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ICounterItemUnion_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define _ICounterItemUnion_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define _ICounterItemUnion_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define _ICounterItemUnion_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define _ICounterItemUnion_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define _ICounterItemUnion_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define _ICounterItemUnion_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define _ICounterItemUnion_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define _ICounterItemUnion_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define _ICounterItemUnion_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define _ICounterItemUnion_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define _ICounterItemUnion_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 

#define _ICounterItemUnion_put_Selected(This,bState)	\
    ( (This)->lpVtbl -> put_Selected(This,bState) ) 

#define _ICounterItemUnion_get_Selected(This,pbState)	\
    ( (This)->lpVtbl -> get_Selected(This,pbState) ) 

#define _ICounterItemUnion_put_Visible(This,bState)	\
    ( (This)->lpVtbl -> put_Visible(This,bState) ) 

#define _ICounterItemUnion_get_Visible(This,pbState)	\
    ( (This)->lpVtbl -> get_Visible(This,pbState) ) 

#define _ICounterItemUnion_GetDataAt(This,iIndex,iWhich,pVariant)	\
    ( (This)->lpVtbl -> GetDataAt(This,iIndex,iWhich,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___ICounterItemUnion_INTERFACE_DEFINED__ */


#ifndef __DICounterItem_DISPINTERFACE_DEFINED__
#define __DICounterItem_DISPINTERFACE_DEFINED__

/* dispinterface DICounterItem */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DICounterItem,0xC08C4FF2,0x0E2E,0x11cf,0x94,0x2C,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C08C4FF2-0E2E-11cf-942C-008029004347")
    DICounterItem : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DICounterItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DICounterItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DICounterItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DICounterItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DICounterItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DICounterItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DICounterItemVtbl;

    interface DICounterItem
    {
        CONST_VTBL struct DICounterItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DICounterItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DICounterItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DICounterItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DICounterItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DICounterItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DICounterItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DICounterItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DICounterItem_DISPINTERFACE_DEFINED__ */


#ifndef __ICounters_INTERFACE_DEFINED__
#define __ICounters_INTERFACE_DEFINED__

/* interface ICounters */
/* [object][hidden][dual][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounters,0x79167962,0x28FC,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79167962-28FC-11cf-942F-008029004347")
    ICounters : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pLong) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ICounters * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ICounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in ICounters * This,
            /* [retval][out] */ __RPC__out long *pLong);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in ICounters * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in ICounters * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in ICounters * This,
            /* [in] */ VARIANT index);
        
        END_INTERFACE
    } ICountersVtbl;

    interface ICounters
    {
        CONST_VTBL struct ICountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICounters_get_Count(This,pLong)	\
    ( (This)->lpVtbl -> get_Count(This,pLong) ) 

#define ICounters_get__NewEnum(This,ppIunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppIunk) ) 

#define ICounters_get_Item(This,index,ppI)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppI) ) 

#define ICounters_Add(This,pathname,ppI)	\
    ( (This)->lpVtbl -> Add(This,pathname,ppI) ) 

#define ICounters_Remove(This,index)	\
    ( (This)->lpVtbl -> Remove(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounters_INTERFACE_DEFINED__ */


#ifndef __ILogFileItem_INTERFACE_DEFINED__
#define __ILogFileItem_INTERFACE_DEFINED__

/* interface ILogFileItem */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ILogFileItem,0xD6B518DD,0x05C7,0x418a,0x89,0xE6,0x4F,0x9C,0xE8,0xC6,0x84,0x1E);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6B518DD-05C7-418a-89E6-4F9CE8C6841E")
    ILogFileItem : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogFileItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILogFileItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILogFileItem * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ILogFileItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        END_INTERFACE
    } ILogFileItemVtbl;

    interface ILogFileItem
    {
        CONST_VTBL struct ILogFileItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogFileItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILogFileItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILogFileItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILogFileItem_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILogFileItem_INTERFACE_DEFINED__ */


#ifndef __DILogFileItem_DISPINTERFACE_DEFINED__
#define __DILogFileItem_DISPINTERFACE_DEFINED__

/* dispinterface DILogFileItem */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DILogFileItem,0x8D093FFC,0xF777,0x4917,0x82,0xD1,0x83,0x3F,0xBC,0x54,0xC5,0x8F);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("8D093FFC-F777-4917-82D1-833FBC54C58F")
    DILogFileItem : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DILogFileItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DILogFileItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DILogFileItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DILogFileItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DILogFileItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DILogFileItemVtbl;

    interface DILogFileItem
    {
        CONST_VTBL struct DILogFileItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DILogFileItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DILogFileItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DILogFileItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DILogFileItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DILogFileItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DILogFileItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DILogFileItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DILogFileItem_DISPINTERFACE_DEFINED__ */


#ifndef __ILogFiles_INTERFACE_DEFINED__
#define __ILogFiles_INTERFACE_DEFINED__

/* interface ILogFiles */
/* [object][hidden][dual][helpstring][uuid] */ 


DEFINE_GUID(IID_ILogFiles,0x6A2A97E6,0x6851,0x41ea,0x87,0xAD,0x2A,0x82,0x25,0x33,0x58,0x65);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A2A97E6-6851-41ea-87AD-2A8225335865")
    ILogFiles : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pLong) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILogFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILogFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILogFiles * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILogFiles * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogFiles * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in ILogFiles * This,
            /* [retval][out] */ __RPC__out long *pLong);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in ILogFiles * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in ILogFiles * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in ILogFiles * This,
            /* [in] */ VARIANT index);
        
        END_INTERFACE
    } ILogFilesVtbl;

    interface ILogFiles
    {
        CONST_VTBL struct ILogFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogFiles_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILogFiles_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILogFiles_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILogFiles_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILogFiles_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILogFiles_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILogFiles_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILogFiles_get_Count(This,pLong)	\
    ( (This)->lpVtbl -> get_Count(This,pLong) ) 

#define ILogFiles_get__NewEnum(This,ppIunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppIunk) ) 

#define ILogFiles_get_Item(This,index,ppI)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppI) ) 

#define ILogFiles_Add(This,pathname,ppI)	\
    ( (This)->lpVtbl -> Add(This,pathname,ppI) ) 

#define ILogFiles_Remove(This,index)	\
    ( (This)->lpVtbl -> Remove(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILogFiles_INTERFACE_DEFINED__ */


#ifndef __ISystemMonitor_INTERFACE_DEFINED__
#define __ISystemMonitor_INTERFACE_DEFINED__

/* interface ISystemMonitor */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitor,0x194EB241,0xC32C,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("194EB241-C32C-11cf-9398-00AA00A3DDEA")
    ISystemMonitor : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ __RPC__out INT *iAppearance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ INT iAppearance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ __RPC__out INT *iBorderStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ INT iBorderStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ __RPC__in_opt IFontDisp *pFont) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Counters( 
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowVerticalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowVerticalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowHorizontalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowHorizontalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowLegend( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowLegend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowScaleLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowScaleLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowValueBar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowValueBar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaximumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaximumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MinimumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MinimumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UpdateInterval( 
            /* [in] */ FLOAT fValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateInterval( 
            /* [retval][out] */ __RPC__out FLOAT *pfValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayType( 
            /* [in] */ DisplayTypeConstants eDisplayType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayType( 
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ManualUpdate( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ManualUpdate( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GraphTitle( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GraphTitle( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_YAxisLabel( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_YAxisLabel( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectSample( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateGraph( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BrowseCounters( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayProperties( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE Counter( 
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AddCounter( 
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE DeleteCounter( 
            /* [in] */ __RPC__in_opt ICounterItem *pCtr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColorCtl( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColorCtl( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogFileName( 
            /* [in] */ __RPC__in BSTR bsFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStart( 
            /* [in] */ DATE StartTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStart( 
            /* [retval][out] */ __RPC__out DATE *StartTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStop( 
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStop( 
            /* [retval][out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GridColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_GridColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeBarColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeBarColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Highlight( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Highlight( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowToolbar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowToolbar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Paste( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReportValueType( 
            /* [in] */ ReportValueTypeConstants eReportValueType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReportValueType( 
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MonitorDuplicateInstances( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MonitorDuplicateInstances( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayFilter( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayFilter( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFiles( 
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataSourceType( 
            /* [in] */ DataSourceTypeConstants eDataSourceType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSourceType( 
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlDsnName( 
            /* [in] */ __RPC__in BSTR bsSqlDsnName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlDsnName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlLogSetName( 
            /* [in] */ __RPC__in BSTR bsSqlLogSetName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlLogSetName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in ISystemMonitor * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        END_INTERFACE
    } ISystemMonitorVtbl;

    interface ISystemMonitor
    {
        CONST_VTBL struct ISystemMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitor_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define ISystemMonitor_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define ISystemMonitor_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define ISystemMonitor_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define ISystemMonitor_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define ISystemMonitor_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define ISystemMonitor_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define ISystemMonitor_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define ISystemMonitor_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define ISystemMonitor_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define ISystemMonitor_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define ISystemMonitor_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define ISystemMonitor_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define ISystemMonitor_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define ISystemMonitor_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define ISystemMonitor_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define ISystemMonitor_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define ISystemMonitor_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define ISystemMonitor_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define ISystemMonitor_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define ISystemMonitor_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define ISystemMonitor_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define ISystemMonitor_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define ISystemMonitor_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define ISystemMonitor_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define ISystemMonitor_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define ISystemMonitor_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define ISystemMonitor_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define ISystemMonitor_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define ISystemMonitor_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define ISystemMonitor_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define ISystemMonitor_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define ISystemMonitor_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define ISystemMonitor_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define ISystemMonitor_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define ISystemMonitor_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define ISystemMonitor_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define ISystemMonitor_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define ISystemMonitor_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define ISystemMonitor_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define ISystemMonitor_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define ISystemMonitor_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define ISystemMonitor_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define ISystemMonitor_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define ISystemMonitor_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define ISystemMonitor_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define ISystemMonitor_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define ISystemMonitor_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define ISystemMonitor_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define ISystemMonitor_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define ISystemMonitor_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define ISystemMonitor_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define ISystemMonitor_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define ISystemMonitor_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define ISystemMonitor_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define ISystemMonitor_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define ISystemMonitor_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define ISystemMonitor_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define ISystemMonitor_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ISystemMonitor_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define ISystemMonitor_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define ISystemMonitor_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define ISystemMonitor_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define ISystemMonitor_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define ISystemMonitor_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define ISystemMonitor_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define ISystemMonitor_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define ISystemMonitor_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define ISystemMonitor_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define ISystemMonitor_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define ISystemMonitor_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define ISystemMonitor_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitor_INTERFACE_DEFINED__ */


#ifndef __ISystemMonitor2_INTERFACE_DEFINED__
#define __ISystemMonitor2_INTERFACE_DEFINED__

/* interface ISystemMonitor2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitor2,0x08e3206a,0x5fd2,0x4fde,0xa8,0xa5,0x8c,0xb3,0xb6,0x3d,0x26,0x77);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08e3206a-5fd2-4fde-a8a5-8cb3b63d2677")
    ISystemMonitor2 : public ISystemMonitor
    {
    public:
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableDigitGrouping( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableDigitGrouping( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableToolTips( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableToolTips( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTimeAxisLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTimeAxisLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ChartScroll( 
            /* [in] */ VARIANT_BOOL bScroll) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChartScroll( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataPointCount( 
            /* [in] */ INT iNewCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataPointCount( 
            /* [retval][out] */ __RPC__out INT *piDataPointCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ScaleToFit( 
            VARIANT_BOOL bSelectedCountersOnly) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Relog( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearData( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStartTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStopTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLogViewRange( 
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetLogViewRange( 
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BatchingLock( 
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadSettings( 
            /* [in] */ __RPC__in BSTR bstrSettingFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableDigitGrouping )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableDigitGrouping )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableToolTips )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableToolTips )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTimeAxisLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTimeAxisLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ChartScroll )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bScroll);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChartScroll )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataPointCount )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iNewCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataPointCount )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piDataPointCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ScaleToFit )( 
            __RPC__in ISystemMonitor2 * This,
            VARIANT_BOOL bSelectedCountersOnly);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            __RPC__in ISystemMonitor2 * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Relog )( 
            __RPC__in ISystemMonitor2 * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClearData )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStartTime )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStopTime )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLogViewRange )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetLogViewRange )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BatchingLock )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadSettings )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bstrSettingFileName);
        
        END_INTERFACE
    } ISystemMonitor2Vtbl;

    interface ISystemMonitor2
    {
        CONST_VTBL struct ISystemMonitor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitor2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitor2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitor2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitor2_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define ISystemMonitor2_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define ISystemMonitor2_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define ISystemMonitor2_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define ISystemMonitor2_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor2_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor2_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define ISystemMonitor2_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define ISystemMonitor2_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define ISystemMonitor2_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define ISystemMonitor2_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define ISystemMonitor2_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define ISystemMonitor2_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define ISystemMonitor2_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define ISystemMonitor2_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define ISystemMonitor2_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define ISystemMonitor2_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define ISystemMonitor2_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define ISystemMonitor2_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define ISystemMonitor2_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define ISystemMonitor2_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define ISystemMonitor2_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define ISystemMonitor2_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define ISystemMonitor2_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define ISystemMonitor2_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define ISystemMonitor2_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define ISystemMonitor2_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define ISystemMonitor2_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define ISystemMonitor2_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define ISystemMonitor2_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define ISystemMonitor2_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define ISystemMonitor2_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define ISystemMonitor2_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define ISystemMonitor2_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define ISystemMonitor2_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define ISystemMonitor2_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define ISystemMonitor2_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define ISystemMonitor2_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define ISystemMonitor2_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define ISystemMonitor2_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define ISystemMonitor2_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define ISystemMonitor2_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define ISystemMonitor2_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define ISystemMonitor2_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define ISystemMonitor2_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define ISystemMonitor2_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define ISystemMonitor2_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define ISystemMonitor2_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define ISystemMonitor2_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define ISystemMonitor2_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define ISystemMonitor2_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define ISystemMonitor2_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define ISystemMonitor2_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define ISystemMonitor2_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define ISystemMonitor2_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define ISystemMonitor2_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define ISystemMonitor2_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define ISystemMonitor2_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define ISystemMonitor2_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define ISystemMonitor2_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define ISystemMonitor2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ISystemMonitor2_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define ISystemMonitor2_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define ISystemMonitor2_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define ISystemMonitor2_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define ISystemMonitor2_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define ISystemMonitor2_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define ISystemMonitor2_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define ISystemMonitor2_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define ISystemMonitor2_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define ISystemMonitor2_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define ISystemMonitor2_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define ISystemMonitor2_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor2_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor2_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define ISystemMonitor2_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 


#define ISystemMonitor2_put_EnableDigitGrouping(This,bState)	\
    ( (This)->lpVtbl -> put_EnableDigitGrouping(This,bState) ) 

#define ISystemMonitor2_get_EnableDigitGrouping(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableDigitGrouping(This,pbState) ) 

#define ISystemMonitor2_put_EnableToolTips(This,bState)	\
    ( (This)->lpVtbl -> put_EnableToolTips(This,bState) ) 

#define ISystemMonitor2_get_EnableToolTips(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableToolTips(This,pbState) ) 

#define ISystemMonitor2_put_ShowTimeAxisLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowTimeAxisLabels(This,bState) ) 

#define ISystemMonitor2_get_ShowTimeAxisLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowTimeAxisLabels(This,pbState) ) 

#define ISystemMonitor2_put_ChartScroll(This,bScroll)	\
    ( (This)->lpVtbl -> put_ChartScroll(This,bScroll) ) 

#define ISystemMonitor2_get_ChartScroll(This,pbScroll)	\
    ( (This)->lpVtbl -> get_ChartScroll(This,pbScroll) ) 

#define ISystemMonitor2_put_DataPointCount(This,iNewCount)	\
    ( (This)->lpVtbl -> put_DataPointCount(This,iNewCount) ) 

#define ISystemMonitor2_get_DataPointCount(This,piDataPointCount)	\
    ( (This)->lpVtbl -> get_DataPointCount(This,piDataPointCount) ) 

#define ISystemMonitor2_ScaleToFit(This,bSelectedCountersOnly)	\
    ( (This)->lpVtbl -> ScaleToFit(This,bSelectedCountersOnly) ) 

#define ISystemMonitor2_SaveAs(This,bstrFileName,eSysmonFileType)	\
    ( (This)->lpVtbl -> SaveAs(This,bstrFileName,eSysmonFileType) ) 

#define ISystemMonitor2_Relog(This,bstrFileName,eSysmonFileType,iFilter)	\
    ( (This)->lpVtbl -> Relog(This,bstrFileName,eSysmonFileType,iFilter) ) 

#define ISystemMonitor2_ClearData(This)	\
    ( (This)->lpVtbl -> ClearData(This) ) 

#define ISystemMonitor2_get_LogSourceStartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStartTime(This,pDate) ) 

#define ISystemMonitor2_get_LogSourceStopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStopTime(This,pDate) ) 

#define ISystemMonitor2_SetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> SetLogViewRange(This,StartTime,StopTime) ) 

#define ISystemMonitor2_GetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> GetLogViewRange(This,StartTime,StopTime) ) 

#define ISystemMonitor2_BatchingLock(This,fLock,eBatchReason)	\
    ( (This)->lpVtbl -> BatchingLock(This,fLock,eBatchReason) ) 

#define ISystemMonitor2_LoadSettings(This,bstrSettingFileName)	\
    ( (This)->lpVtbl -> LoadSettings(This,bstrSettingFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitor2_INTERFACE_DEFINED__ */


#ifndef ___ISystemMonitorUnion_INTERFACE_DEFINED__
#define ___ISystemMonitorUnion_INTERFACE_DEFINED__

/* interface _ISystemMonitorUnion */
/* [object][hidden][uuid] */ 


DEFINE_GUID(IID__ISystemMonitorUnion,0xc8a77338,0x265f,0x4de5,0xaa,0x25,0xc7,0xda,0x1c,0xe5,0xa8,0xf4);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8a77338-265f-4de5-aa25-c7da1ce5a8f4")
    _ISystemMonitorUnion : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ __RPC__out INT *iAppearance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ INT iAppearance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ __RPC__out INT *iBorderStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ INT iBorderStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ __RPC__in_opt IFontDisp *pFont) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Counters( 
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowVerticalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowVerticalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowHorizontalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowHorizontalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowLegend( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowLegend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowScaleLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowScaleLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowValueBar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowValueBar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaximumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaximumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MinimumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MinimumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UpdateInterval( 
            /* [in] */ FLOAT fValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateInterval( 
            /* [retval][out] */ __RPC__out FLOAT *pfValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayType( 
            /* [in] */ DisplayTypeConstants eDisplayType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayType( 
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ManualUpdate( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ManualUpdate( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GraphTitle( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GraphTitle( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_YAxisLabel( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_YAxisLabel( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectSample( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateGraph( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BrowseCounters( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayProperties( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE Counter( 
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AddCounter( 
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE DeleteCounter( 
            /* [in] */ __RPC__in_opt ICounterItem *pCtr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColorCtl( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColorCtl( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogFileName( 
            /* [in] */ __RPC__in BSTR bsFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStart( 
            /* [in] */ DATE StartTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStart( 
            /* [retval][out] */ __RPC__out DATE *StartTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStop( 
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStop( 
            /* [retval][out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GridColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_GridColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeBarColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeBarColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Highlight( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Highlight( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowToolbar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowToolbar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Paste( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReportValueType( 
            /* [in] */ ReportValueTypeConstants eReportValueType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReportValueType( 
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MonitorDuplicateInstances( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MonitorDuplicateInstances( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayFilter( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayFilter( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFiles( 
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataSourceType( 
            /* [in] */ DataSourceTypeConstants eDataSourceType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSourceType( 
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlDsnName( 
            /* [in] */ __RPC__in BSTR bsSqlDsnName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlDsnName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlLogSetName( 
            /* [in] */ __RPC__in BSTR bsSqlLogSetName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlLogSetName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableDigitGrouping( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableDigitGrouping( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableToolTips( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableToolTips( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTimeAxisLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTimeAxisLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ChartScroll( 
            /* [in] */ VARIANT_BOOL bScroll) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChartScroll( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataPointCount( 
            /* [in] */ INT iNewCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataPointCount( 
            /* [retval][out] */ __RPC__out INT *piDataPointCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ScaleToFit( 
            VARIANT_BOOL bSelectedCountersOnly) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Relog( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearData( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStartTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStopTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLogViewRange( 
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetLogViewRange( 
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BatchingLock( 
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadSettings( 
            /* [in] */ __RPC__in BSTR bstrSettingFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _ISystemMonitorUnionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableDigitGrouping )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableDigitGrouping )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableToolTips )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableToolTips )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTimeAxisLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTimeAxisLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ChartScroll )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bScroll);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChartScroll )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataPointCount )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iNewCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataPointCount )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piDataPointCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ScaleToFit )( 
            __RPC__in _ISystemMonitorUnion * This,
            VARIANT_BOOL bSelectedCountersOnly);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            __RPC__in _ISystemMonitorUnion * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Relog )( 
            __RPC__in _ISystemMonitorUnion * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClearData )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStartTime )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStopTime )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLogViewRange )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetLogViewRange )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BatchingLock )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadSettings )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bstrSettingFileName);
        
        END_INTERFACE
    } _ISystemMonitorUnionVtbl;

    interface _ISystemMonitorUnion
    {
        CONST_VTBL struct _ISystemMonitorUnionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISystemMonitorUnion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ISystemMonitorUnion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ISystemMonitorUnion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ISystemMonitorUnion_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define _ISystemMonitorUnion_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define _ISystemMonitorUnion_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define _ISystemMonitorUnion_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define _ISystemMonitorUnion_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define _ISystemMonitorUnion_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define _ISystemMonitorUnion_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define _ISystemMonitorUnion_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define _ISystemMonitorUnion_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define _ISystemMonitorUnion_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define _ISystemMonitorUnion_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define _ISystemMonitorUnion_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define _ISystemMonitorUnion_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define _ISystemMonitorUnion_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define _ISystemMonitorUnion_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define _ISystemMonitorUnion_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define _ISystemMonitorUnion_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define _ISystemMonitorUnion_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define _ISystemMonitorUnion_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define _ISystemMonitorUnion_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define _ISystemMonitorUnion_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define _ISystemMonitorUnion_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define _ISystemMonitorUnion_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define _ISystemMonitorUnion_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define _ISystemMonitorUnion_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define _ISystemMonitorUnion_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define _ISystemMonitorUnion_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define _ISystemMonitorUnion_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define _ISystemMonitorUnion_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define _ISystemMonitorUnion_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define _ISystemMonitorUnion_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define _ISystemMonitorUnion_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define _ISystemMonitorUnion_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define _ISystemMonitorUnion_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define _ISystemMonitorUnion_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define _ISystemMonitorUnion_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define _ISystemMonitorUnion_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define _ISystemMonitorUnion_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define _ISystemMonitorUnion_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define _ISystemMonitorUnion_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define _ISystemMonitorUnion_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define _ISystemMonitorUnion_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define _ISystemMonitorUnion_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define _ISystemMonitorUnion_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define _ISystemMonitorUnion_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define _ISystemMonitorUnion_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define _ISystemMonitorUnion_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define _ISystemMonitorUnion_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define _ISystemMonitorUnion_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define _ISystemMonitorUnion_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define _ISystemMonitorUnion_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define _ISystemMonitorUnion_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define _ISystemMonitorUnion_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define _ISystemMonitorUnion_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define _ISystemMonitorUnion_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define _ISystemMonitorUnion_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define _ISystemMonitorUnion_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define _ISystemMonitorUnion_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define _ISystemMonitorUnion_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define _ISystemMonitorUnion_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define _ISystemMonitorUnion_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 

#define _ISystemMonitorUnion_put_EnableDigitGrouping(This,bState)	\
    ( (This)->lpVtbl -> put_EnableDigitGrouping(This,bState) ) 

#define _ISystemMonitorUnion_get_EnableDigitGrouping(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableDigitGrouping(This,pbState) ) 

#define _ISystemMonitorUnion_put_EnableToolTips(This,bState)	\
    ( (This)->lpVtbl -> put_EnableToolTips(This,bState) ) 

#define _ISystemMonitorUnion_get_EnableToolTips(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableToolTips(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowTimeAxisLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowTimeAxisLabels(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowTimeAxisLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowTimeAxisLabels(This,pbState) ) 

#define _ISystemMonitorUnion_put_ChartScroll(This,bScroll)	\
    ( (This)->lpVtbl -> put_ChartScroll(This,bScroll) ) 

#define _ISystemMonitorUnion_get_ChartScroll(This,pbScroll)	\
    ( (This)->lpVtbl -> get_ChartScroll(This,pbScroll) ) 

#define _ISystemMonitorUnion_put_DataPointCount(This,iNewCount)	\
    ( (This)->lpVtbl -> put_DataPointCount(This,iNewCount) ) 

#define _ISystemMonitorUnion_get_DataPointCount(This,piDataPointCount)	\
    ( (This)->lpVtbl -> get_DataPointCount(This,piDataPointCount) ) 

#define _ISystemMonitorUnion_ScaleToFit(This,bSelectedCountersOnly)	\
    ( (This)->lpVtbl -> ScaleToFit(This,bSelectedCountersOnly) ) 

#define _ISystemMonitorUnion_SaveAs(This,bstrFileName,eSysmonFileType)	\
    ( (This)->lpVtbl -> SaveAs(This,bstrFileName,eSysmonFileType) ) 

#define _ISystemMonitorUnion_Relog(This,bstrFileName,eSysmonFileType,iFilter)	\
    ( (This)->lpVtbl -> Relog(This,bstrFileName,eSysmonFileType,iFilter) ) 

#define _ISystemMonitorUnion_ClearData(This)	\
    ( (This)->lpVtbl -> ClearData(This) ) 

#define _ISystemMonitorUnion_get_LogSourceStartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStartTime(This,pDate) ) 

#define _ISystemMonitorUnion_get_LogSourceStopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStopTime(This,pDate) ) 

#define _ISystemMonitorUnion_SetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> SetLogViewRange(This,StartTime,StopTime) ) 

#define _ISystemMonitorUnion_GetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> GetLogViewRange(This,StartTime,StopTime) ) 

#define _ISystemMonitorUnion_BatchingLock(This,fLock,eBatchReason)	\
    ( (This)->lpVtbl -> BatchingLock(This,fLock,eBatchReason) ) 

#define _ISystemMonitorUnion_LoadSettings(This,bstrSettingFileName)	\
    ( (This)->lpVtbl -> LoadSettings(This,bstrSettingFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___ISystemMonitorUnion_INTERFACE_DEFINED__ */


#ifndef __DISystemMonitor_DISPINTERFACE_DEFINED__
#define __DISystemMonitor_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitor */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitor,0x13D73D81,0xC32E,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("13D73D81-C32E-11cf-9398-00AA00A3DDEA")
    DISystemMonitor : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorVtbl;

    interface DISystemMonitor
    {
        CONST_VTBL struct DISystemMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitor_DISPINTERFACE_DEFINED__ */


#ifndef __DISystemMonitorInternal_DISPINTERFACE_DEFINED__
#define __DISystemMonitorInternal_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitorInternal */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitorInternal,0x194EB242,0xC32C,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("194EB242-C32C-11cf-9398-00AA00A3DDEA")
    DISystemMonitorInternal : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitorInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitorInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitorInternal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorInternalVtbl;

    interface DISystemMonitorInternal
    {
        CONST_VTBL struct DISystemMonitorInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitorInternal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitorInternal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitorInternal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitorInternal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitorInternal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitorInternal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitorInternal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitorInternal_DISPINTERFACE_DEFINED__ */


#ifndef __ISystemMonitorEvents_INTERFACE_DEFINED__
#define __ISystemMonitorEvents_INTERFACE_DEFINED__

/* interface ISystemMonitorEvents */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitorEvents,0xEE660EA0,0x4ABD,0x11cf,0x94,0x3A,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE660EA0-4ABD-11cf-943A-008029004347")
    ISystemMonitorEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterSelected( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterAdded( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterDeleted( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnSampleCollected( void) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnDblClick( 
            /* [in] */ INT Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitorEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitorEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitorEvents * This);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterSelected )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterAdded )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterDeleted )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnSampleCollected )( 
            __RPC__in ISystemMonitorEvents * This);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnDblClick )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        END_INTERFACE
    } ISystemMonitorEventsVtbl;

    interface ISystemMonitorEvents
    {
        CONST_VTBL struct ISystemMonitorEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitorEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitorEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitorEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitorEvents_OnCounterSelected(This,Index)	\
    ( (This)->lpVtbl -> OnCounterSelected(This,Index) ) 

#define ISystemMonitorEvents_OnCounterAdded(This,Index)	\
    ( (This)->lpVtbl -> OnCounterAdded(This,Index) ) 

#define ISystemMonitorEvents_OnCounterDeleted(This,Index)	\
    ( (This)->lpVtbl -> OnCounterDeleted(This,Index) ) 

#define ISystemMonitorEvents_OnSampleCollected(This)	\
    ( (This)->lpVtbl -> OnSampleCollected(This) ) 

#define ISystemMonitorEvents_OnDblClick(This,Index)	\
    ( (This)->lpVtbl -> OnDblClick(This,Index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitorEvents_INTERFACE_DEFINED__ */


#ifndef __DISystemMonitorEvents_DISPINTERFACE_DEFINED__
#define __DISystemMonitorEvents_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitorEvents */
/* [helpstring][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitorEvents,0x84979930,0x4AB3,0x11cf,0x94,0x3A,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("84979930-4AB3-11cf-943A-008029004347")
    DISystemMonitorEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitorEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitorEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitorEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorEventsVtbl;

    interface DISystemMonitorEvents
    {
        CONST_VTBL struct DISystemMonitorEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitorEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitorEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitorEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitorEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitorEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitorEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitorEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitorEvents_DISPINTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_SystemMonitor,0xC4D2D8E0,0xD1DD,0x11ce,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C4D2D8E0-D1DD-11ce-940F-008029004347")
SystemMonitor;
#endif

DEFINE_GUID(CLSID_CounterItem,0xC4D2D8E0,0xD1DD,0x11ce,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x48);

#ifdef __cplusplus

class DECLSPEC_UUID("C4D2D8E0-D1DD-11ce-940F-008029004348")
CounterItem;
#endif

DEFINE_GUID(CLSID_Counters,0xB2B066D2,0x2AAC,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("B2B066D2-2AAC-11cf-942F-008029004347")
Counters;
#endif

DEFINE_GUID(CLSID_LogFileItem,0x16EC5BE8,0xDF93,0x4237,0x94,0xE4,0x9E,0xE9,0x18,0x11,0x1D,0x71);

#ifdef __cplusplus

class DECLSPEC_UUID("16EC5BE8-DF93-4237-94E4-9EE918111D71")
LogFileItem;
#endif

DEFINE_GUID(CLSID_LogFiles,0x2735D9FD,0xF6B9,0x4f19,0xA5,0xD9,0xE2,0xD0,0x68,0x58,0x4B,0xC5);

#ifdef __cplusplus

class DECLSPEC_UUID("2735D9FD-F6B9-4f19-A5D9-E2D068584BC5")
LogFiles;
#endif

DEFINE_GUID(CLSID_CounterItem2,0x43196c62,0xc31f,0x4ce3,0xa0,0x2e,0x79,0xef,0xe0,0xf6,0xa5,0x25);

#ifdef __cplusplus

class DECLSPEC_UUID("43196c62-c31f-4ce3-a02e-79efe0f6a525")
CounterItem2;
#endif

DEFINE_GUID(CLSID_SystemMonitor2,0x7f30578c,0x5f38,0x4612,0xac,0xfe,0x6e,0xd0,0x4c,0x7b,0x7a,0xf8);

#ifdef __cplusplus

class DECLSPEC_UUID("7f30578c-5f38-4612-acfe-6ed04c7b7af8")
SystemMonitor2;
#endif

DEFINE_GUID(CLSID_AppearPropPage,0xe49741e9,0x93a8,0x4ab1,0x8e,0x96,0xbf,0x44,0x82,0x28,0x2e,0x9c);

#ifdef __cplusplus

class DECLSPEC_UUID("e49741e9-93a8-4ab1-8e96-bf4482282e9c")
AppearPropPage;
#endif

DEFINE_GUID(CLSID_GeneralPropPage,0xC3E5D3D2,0x1A03,0x11CF,0x94,0x2D,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C3E5D3D2-1A03-11CF-942D-008029004347")
GeneralPropPage;
#endif

DEFINE_GUID(CLSID_GraphPropPage,0xC3E5D3D3,0x1A03,0x11CF,0x94,0x2D,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C3E5D3D3-1A03-11CF-942D-008029004347")
GraphPropPage;
#endif

DEFINE_GUID(CLSID_SourcePropPage,0x0CF32AA1,0x7571,0x11D0,0x93,0xC4,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#ifdef __cplusplus

class DECLSPEC_UUID("0CF32AA1-7571-11D0-93C4-00AA00A3DDEA")
SourcePropPage;
#endif

DEFINE_GUID(CLSID_CounterPropPage,0xCF948561,0xEDE8,0x11CE,0x94,0x1E,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("CF948561-EDE8-11CE-941E-008029004347")
CounterPropPage;
#endif
#endif /* __SystemMonitor_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\iscsierr.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iscsierr.h

Abstract:

    Constant definitions for the IScsi discover error codes

Revision History:

--*/

#ifndef _ISCSIERR_
#define _ISCSIERR_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Error status code for ISCSI discovery apis. Error codes can be a 
// standard Windows error code as defined in Winerror.h or one of the
// iscsi discovery specific error codes defined below.
//
#ifndef MOFCOMP_PASS
typedef ULONG ISDSC_STATUS;
#endif

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ISDSC_NON_SPECIFIC_ERROR
//
// MessageText:
//
// A non specific error occurred.
//
#define ISDSC_NON_SPECIFIC_ERROR         ((ISDSC_STATUS)0xEFFF0001L)

//
// MessageId: ISDSC_LOGIN_FAILED
//
// MessageText:
//
// Login Failed.
//
#define ISDSC_LOGIN_FAILED               ((ISDSC_STATUS)0xEFFF0002L)

//
// MessageId: ISDSC_CONNECTION_FAILED
//
// MessageText:
//
// Connection Failed.
//
#define ISDSC_CONNECTION_FAILED          ((ISDSC_STATUS)0xEFFF0003L)

//
// MessageId: ISDSC_INITIATOR_NODE_ALREADY_EXISTS
//
// MessageText:
//
// Initiator Node Already Exists.
//
#define ISDSC_INITIATOR_NODE_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0004L)

//
// MessageId: ISDSC_INITIATOR_NODE_NOT_FOUND
//
// MessageText:
//
// Initiator Node Does Not Exist.
//
#define ISDSC_INITIATOR_NODE_NOT_FOUND   ((ISDSC_STATUS)0xEFFF0005L)

//
// MessageId: ISDSC_TARGET_MOVED_TEMPORARILY
//
// MessageText:
//
// Target Moved Temporarily.
//
#define ISDSC_TARGET_MOVED_TEMPORARILY   ((ISDSC_STATUS)0xEFFF0006L)

//
// MessageId: ISDSC_TARGET_MOVED_PERMANENTLY
//
// MessageText:
//
// Target Moved Permanently.
//
#define ISDSC_TARGET_MOVED_PERMANENTLY   ((ISDSC_STATUS)0xEFFF0007L)

//
// MessageId: ISDSC_INITIATOR_ERROR
//
// MessageText:
//
// Initiator Error.
//
#define ISDSC_INITIATOR_ERROR            ((ISDSC_STATUS)0xEFFF0008L)

//
// MessageId: ISDSC_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Authentication Failure.
//
#define ISDSC_AUTHENTICATION_FAILURE     ((ISDSC_STATUS)0xEFFF0009L)

//
// MessageId: ISDSC_AUTHORIZATION_FAILURE
//
// MessageText:
//
// Authorization Failure.
//
#define ISDSC_AUTHORIZATION_FAILURE      ((ISDSC_STATUS)0xEFFF000AL)

//
// MessageId: ISDSC_NOT_FOUND
//
// MessageText:
//
// Not Found.
//
#define ISDSC_NOT_FOUND                  ((ISDSC_STATUS)0xEFFF000BL)

//
// MessageId: ISDSC_TARGET_REMOVED
//
// MessageText:
//
// Target Removed.
//
#define ISDSC_TARGET_REMOVED             ((ISDSC_STATUS)0xEFFF000CL)

//
// MessageId: ISDSC_UNSUPPORTED_VERSION
//
// MessageText:
//
// Unsupported Version.
//
#define ISDSC_UNSUPPORTED_VERSION        ((ISDSC_STATUS)0xEFFF000DL)

//
// MessageId: ISDSC_TOO_MANY_CONNECTIONS
//
// MessageText:
//
// Too many Connections.
//
#define ISDSC_TOO_MANY_CONNECTIONS       ((ISDSC_STATUS)0xEFFF000EL)

//
// MessageId: ISDSC_MISSING_PARAMETER
//
// MessageText:
//
// Missing Parameter.
//
#define ISDSC_MISSING_PARAMETER          ((ISDSC_STATUS)0xEFFF000FL)

//
// MessageId: ISDSC_CANT_INCLUDE_IN_SESSION
//
// MessageText:
//
// Can not include in session.
//
#define ISDSC_CANT_INCLUDE_IN_SESSION    ((ISDSC_STATUS)0xEFFF0010L)

//
// MessageId: ISDSC_SESSION_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// Session type not supported.
//
#define ISDSC_SESSION_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0011L)

//
// MessageId: ISDSC_TARGET_ERROR
//
// MessageText:
//
// Target Error.
//
#define ISDSC_TARGET_ERROR               ((ISDSC_STATUS)0xEFFF0012L)

//
// MessageId: ISDSC_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Service Unavailable.
//
#define ISDSC_SERVICE_UNAVAILABLE        ((ISDSC_STATUS)0xEFFF0013L)

//
// MessageId: ISDSC_OUT_OF_RESOURCES
//
// MessageText:
//
// Out of Resources.
//
#define ISDSC_OUT_OF_RESOURCES           ((ISDSC_STATUS)0xEFFF0014L)

//
// MessageId: ISDSC_CONNECTION_ALREADY_EXISTS
//
// MessageText:
//
// Connections already exist on initiator node.
//
#define ISDSC_CONNECTION_ALREADY_EXISTS  ((ISDSC_STATUS)0xEFFF0015L)

//
// MessageId: ISDSC_SESSION_ALREADY_EXISTS
//
// MessageText:
//
// Session Already Exists.
//
#define ISDSC_SESSION_ALREADY_EXISTS     ((ISDSC_STATUS)0xEFFF0016L)

//
// MessageId: ISDSC_INITIATOR_INSTANCE_NOT_FOUND
//
// MessageText:
//
// Initiator Instance Does Not Exist.
//
#define ISDSC_INITIATOR_INSTANCE_NOT_FOUND ((ISDSC_STATUS)0xEFFF0017L)

//
// MessageId: ISDSC_TARGET_ALREADY_EXISTS
//
// MessageText:
//
// Target Already Exists.
//
#define ISDSC_TARGET_ALREADY_EXISTS      ((ISDSC_STATUS)0xEFFF0018L)

//
// MessageId: ISDSC_DRIVER_BUG
//
// MessageText:
//
// The iscsi driver implementation did not complete an operation correctly.
//
#define ISDSC_DRIVER_BUG                 ((ISDSC_STATUS)0xEFFF0019L)

//
// MessageId: ISDSC_INVALID_TEXT_KEY
//
// MessageText:
//
// An invalid key text was encountered.
//
#define ISDSC_INVALID_TEXT_KEY           ((ISDSC_STATUS)0xEFFF001AL)

//
// MessageId: ISDSC_INVALID_SENDTARGETS_TEXT
//
// MessageText:
//
// Invalid SendTargets response text was encountered.
//
#define ISDSC_INVALID_SENDTARGETS_TEXT   ((ISDSC_STATUS)0xEFFF001BL)

//
// MessageId: ISDSC_INVALID_SESSION_ID
//
// MessageText:
//
// Invalid Session Id.
//
#define ISDSC_INVALID_SESSION_ID         ((ISDSC_STATUS)0xEFFF001CL)

//
// MessageId: ISDSC_SCSI_REQUEST_FAILED
//
// MessageText:
//
// The scsi request failed.
//
#define ISDSC_SCSI_REQUEST_FAILED        ((ISDSC_STATUS)0xEFFF001DL)

//
// MessageId: ISDSC_TOO_MANY_SESSIONS
//
// MessageText:
//
// Exceeded max sessions for this initiator.
//
#define ISDSC_TOO_MANY_SESSIONS          ((ISDSC_STATUS)0xEFFF001EL)

//
// MessageId: ISDSC_SESSION_BUSY
//
// MessageText:
//
// Session is busy since a request is already in progress.
//
#define ISDSC_SESSION_BUSY               ((ISDSC_STATUS)0xEFFF001FL)

//
// MessageId: ISDSC_TARGET_MAPPING_UNAVAILABLE
//
// MessageText:
//
// The target mapping requested is not available.
//
#define ISDSC_TARGET_MAPPING_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0020L)

//
// MessageId: ISDSC_ADDRESS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The Target Address type given is not supported.
//
#define ISDSC_ADDRESS_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0021L)

//
// MessageId: ISDSC_LOGON_FAILED
//
// MessageText:
//
// Logon Failed.
//
#define ISDSC_LOGON_FAILED               ((ISDSC_STATUS)0xEFFF0022L)

//
// MessageId: ISDSC_SEND_FAILED
//
// MessageText:
//
// TCP Send Failed.
//
#define ISDSC_SEND_FAILED                ((ISDSC_STATUS)0xEFFF0023L)

//
// MessageId: ISDSC_TRANSPORT_ERROR
//
// MessageText:
//
// TCP Transport Error
//
#define ISDSC_TRANSPORT_ERROR            ((ISDSC_STATUS)0xEFFF0024L)

//
// MessageId: ISDSC_VERSION_MISMATCH
//
// MessageText:
//
// iSCSI Version Mismatch
//
#define ISDSC_VERSION_MISMATCH           ((ISDSC_STATUS)0xEFFF0025L)

//
// MessageId: ISDSC_TARGET_MAPPING_OUT_OF_RANGE
//
// MessageText:
//
// The Target Mapping Address passed is out of range for the adapter configuration.
//
#define ISDSC_TARGET_MAPPING_OUT_OF_RANGE ((ISDSC_STATUS)0xEFFF0026L)

//
// MessageId: ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE
//
// MessageText:
//
// The preshared key for the target or IKE identification payload is not available.
//
#define ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0027L)

//
// MessageId: ISDSC_TARGET_AUTHINFO_UNAVAILABLE
//
// MessageText:
//
// The authentication information for the target is not available.
//
#define ISDSC_TARGET_AUTHINFO_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0028L)

//
// MessageId: ISDSC_TARGET_NOT_FOUND
//
// MessageText:
//
// The target name is not found or is marked as hidden from login.
//
#define ISDSC_TARGET_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0029L)

//
// MessageId: ISDSC_LOGIN_USER_INFO_BAD
//
// MessageText:
//
// One or more parameters specified in LoginTargetIN structure is invalid.
//
#define ISDSC_LOGIN_USER_INFO_BAD        ((ISDSC_STATUS)0xEFFF002AL)

//
// MessageId: ISDSC_TARGET_MAPPING_EXISTS
//
// MessageText:
//
// Given target mapping already exists.
//
#define ISDSC_TARGET_MAPPING_EXISTS      ((ISDSC_STATUS)0xEFFF002BL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_FULL
//
// MessageText:
//
// The HBA security information cache is full.
//
#define ISDSC_HBA_SECURITY_CACHE_FULL    ((ISDSC_STATUS)0xEFFF002CL)

//
// MessageId: ISDSC_INVALID_PORT_NUMBER
//
// MessageText:
//
// The port number passed is not valid for the initiator.
//
#define ISDSC_INVALID_PORT_NUMBER        ((ISDSC_STATUS)0xEFFF002DL)

//
// MessageId: ISDSC_OPERATION_NOT_ALL_SUCCESS
//
// MessageText:
//
// The operation was not successful for all initiators or discovery methods.
//
#define ISDSC_OPERATION_NOT_ALL_SUCCESS  ((ISDSC_STATUS)0xAFFF002EL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED
//
// MessageText:
//
// The HBA security information cache is not supported by this adapter.
//
#define ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF002FL)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The IKE id payload type specified is not supported.
//
#define ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0030L)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE
//
// MessageText:
//
// The IKE id payload size specified is not correct.
//
#define ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE ((ISDSC_STATUS)0xEFFF0031L)

//
// MessageId: ISDSC_TARGET_PORTAL_ALREADY_EXISTS
//
// MessageText:
//
// Target Portal Structure Already Exists.
//
#define ISDSC_TARGET_PORTAL_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0032L)

//
// MessageId: ISDSC_TARGET_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
// Target Address Structure Already Exists.
//
#define ISDSC_TARGET_ADDRESS_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0033L)

//
// MessageId: ISDSC_NO_AUTH_INFO_AVAILABLE
//
// MessageText:
//
// There is no IKE authentication information available.
//
#define ISDSC_NO_AUTH_INFO_AVAILABLE     ((ISDSC_STATUS)0xEFFF0034L)

//
// MessageId: ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS
//
// MessageText:
//
// There is no tunnel mode outer address specified.
//
#define ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS ((ISDSC_STATUS)0xEFFF0035L)

//
// MessageId: ISDSC_CACHE_CORRUPTED
//
// MessageText:
//
// Authentication or tunnel address cache is corrupted.
//
#define ISDSC_CACHE_CORRUPTED            ((ISDSC_STATUS)0xEFFF0036L)

//
// MessageId: ISDSC_REQUEST_NOT_SUPPORTED
//
// MessageText:
//
// The request or operation is not supported.
//
#define ISDSC_REQUEST_NOT_SUPPORTED      ((ISDSC_STATUS)0xEFFF0037L)

//
// MessageId: ISDSC_TARGET_OUT_OF_RESORCES
//
// MessageText:
//
// The target does not have enough resources to process the given request.
//
#define ISDSC_TARGET_OUT_OF_RESORCES     ((ISDSC_STATUS)0xEFFF0038L)

//
// MessageId: ISDSC_SERVICE_DID_NOT_RESPOND
//
// MessageText:
//
// The initiator service did not respond to the request sent by the driver.
//
#define ISDSC_SERVICE_DID_NOT_RESPOND    ((ISDSC_STATUS)0xEFFF0039L)

//
// MessageId: ISDSC_ISNS_SERVER_NOT_FOUND
//
// MessageText:
//
// The Internet Storage Name Server (iSNS) server was not found or is unavailable.
//
#define ISDSC_ISNS_SERVER_NOT_FOUND      ((ISDSC_STATUS)0xEFFF003AL)

//
// MessageId: ISDSC_OPERATION_REQUIRES_REBOOT
//
// MessageText:
//
// The operation was successful but requires a driver reload or reboot to become effective.
//
#define ISDSC_OPERATION_REQUIRES_REBOOT  ((ISDSC_STATUS)0xAFFF003BL)

//
// MessageId: ISDSC_NO_PORTAL_SPECIFIED
//
// MessageText:
//
// There is no target portal available to complete the login.
//
#define ISDSC_NO_PORTAL_SPECIFIED        ((ISDSC_STATUS)0xEFFF003CL)

//
// MessageId: ISDSC_CANT_REMOVE_LAST_CONNECTION
//
// MessageText:
//
// Cannot remove the last connection for a session.
//
#define ISDSC_CANT_REMOVE_LAST_CONNECTION ((ISDSC_STATUS)0xEFFF003DL)

//
// MessageId: ISDSC_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Microsoft iSCSI initiator service has not been started.
//
#define ISDSC_SERVICE_NOT_RUNNING        ((ISDSC_STATUS)0xEFFF003EL)

//
// MessageId: ISDSC_TARGET_ALREADY_LOGGED_IN
//
// MessageText:
//
// The target has already been logged in via an iSCSI session.
//
#define ISDSC_TARGET_ALREADY_LOGGED_IN   ((ISDSC_STATUS)0xEFFF003FL)

//
// MessageId: ISDSC_DEVICE_BUSY_ON_SESSION
//
// MessageText:
//
// The session cannot be logged out since a device on that session is currently being used.
//
#define ISDSC_DEVICE_BUSY_ON_SESSION     ((ISDSC_STATUS)0xEFFF0040L)

//
// MessageId: ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to save persistent login information.
//
#define ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0041L)

//
// MessageId: ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to remove persistent login information.
//
#define ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0042L)

//
// MessageId: ISDSC_PORTAL_NOT_FOUND
//
// MessageText:
//
// The specified portal was not found.
//
#define ISDSC_PORTAL_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0043L)

//
// MessageId: ISDSC_INITIATOR_NOT_FOUND
//
// MessageText:
//
// The specified initiator name was not found.
//
#define ISDSC_INITIATOR_NOT_FOUND        ((ISDSC_STATUS)0xEFFF0044L)

//
// MessageId: ISDSC_DISCOVERY_MECHANISM_NOT_FOUND
//
// MessageText:
//
// The specified discovery mechanism was not found.
//
#define ISDSC_DISCOVERY_MECHANISM_NOT_FOUND ((ISDSC_STATUS)0xEFFF0045L)

//
// MessageId: ISDSC_IPSEC_NOT_SUPPORTED_ON_OS
//
// MessageText:
//
// iSCSI does not support IPSEC for this version of the OS.
//
#define ISDSC_IPSEC_NOT_SUPPORTED_ON_OS  ((ISDSC_STATUS)0xEFFF0046L)

//
// MessageId: ISDSC_PERSISTENT_LOGIN_TIMEOUT
//
// MessageText:
//
// The iSCSI service timed out waiting for all persistent logins to complete.
//
#define ISDSC_PERSISTENT_LOGIN_TIMEOUT   ((ISDSC_STATUS)0xEFFF0047L)

//
// MessageId: ISDSC_SHORT_CHAP_SECRET
//
// MessageText:
//
// The specified CHAP secret is less than 96 bits and will not be usable for authenticating over non ipsec connections.
//
#define ISDSC_SHORT_CHAP_SECRET          ((ISDSC_STATUS)0xAFFF0048L)

//
// MessageId: ISDSC_EVALUATION_PEROID_EXPIRED
//
// MessageText:
//
// The evaluation period for the iSCSI initiator service has expired.
//
#define ISDSC_EVALUATION_PEROID_EXPIRED  ((ISDSC_STATUS)0xEFFF0049L)

//
// MessageId: ISDSC_INVALID_CHAP_SECRET
//
// MessageText:
//
// CHAP secret given does not conform to the standard. Please see system event log for more information.
//
#define ISDSC_INVALID_CHAP_SECRET        ((ISDSC_STATUS)0xEFFF004AL)

//
// MessageId: ISDSC_INVALID_TARGET_CHAP_SECRET
//
// MessageText:
//
// Target CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_TARGET_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004BL)

//
// MessageId: ISDSC_INVALID_INITIATOR_CHAP_SECRET
//
// MessageText:
//
// Initiator CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_INITIATOR_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004CL)

//
// MessageId: ISDSC_INVALID_CHAP_USER_NAME
//
// MessageText:
//
// CHAP Username given is invalid.
//
#define ISDSC_INVALID_CHAP_USER_NAME     ((ISDSC_STATUS)0xEFFF004DL)

//
// MessageId: ISDSC_INVALID_LOGON_AUTH_TYPE
//
// MessageText:
//
// Logon Authentication type given is invalid.
//
#define ISDSC_INVALID_LOGON_AUTH_TYPE    ((ISDSC_STATUS)0xEFFF004EL)

//
// MessageId: ISDSC_INVALID_TARGET_MAPPING
//
// MessageText:
//
// Target Mapping information given is invalid.
//
#define ISDSC_INVALID_TARGET_MAPPING     ((ISDSC_STATUS)0xEFFF004FL)

//
// MessageId: ISDSC_INVALID_TARGET_ID
//
// MessageText:
//
// Target Id given in Target Mapping is invalid.
//
#define ISDSC_INVALID_TARGET_ID          ((ISDSC_STATUS)0xEFFF0050L)

//
// MessageId: ISDSC_INVALID_ISCSI_NAME
//
// MessageText:
//
// The iSCSI name specified contains invalid characters or is too long.
//
#define ISDSC_INVALID_ISCSI_NAME         ((ISDSC_STATUS)0xEFFF0051L)

//
// MessageId: ISDSC_INCOMPATIBLE_ISNS_VERSION
//
// MessageText:
//
// The version number returned from the Internet Storage Name Server (iSNS) server is not compatible with this version of the iSNS client.
//
#define ISDSC_INCOMPATIBLE_ISNS_VERSION  ((ISDSC_STATUS)0xEFFF0052L)

//
// MessageId: ISDSC_FAILED_TO_CONFIGURE_IPSEC
//
// MessageText:
//
// Initiator failed to configure IPSec for the given connection. This could be because of low resources.
//
#define ISDSC_FAILED_TO_CONFIGURE_IPSEC  ((ISDSC_STATUS)0xEFFF0053L)

//
// MessageId: ISDSC_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer given for processing the request is too small.
//
#define ISDSC_BUFFER_TOO_SMALL           ((ISDSC_STATUS)0xEFFF0054L)

//
// MessageId: ISDSC_INVALID_LOAD_BALANCE_POLICY
//
// MessageText:
//
// The given Load Balance policy is not recognized by iScsi initiator.
//
#define ISDSC_INVALID_LOAD_BALANCE_POLICY ((ISDSC_STATUS)0xEFFF0055L)

//
// MessageId: ISDSC_INVALID_PARAMETER
//
// MessageText:
//
// One or more paramaters specified is not valid.
//
#define ISDSC_INVALID_PARAMETER          ((ISDSC_STATUS)0xEFFF0056L)

//
// MessageId: ISDSC_DUPLICATE_PATH_SPECIFIED
//
// MessageText:
//
// Duplicate PathIds were specified in the call to set Load Balance Policy.
//
#define ISDSC_DUPLICATE_PATH_SPECIFIED   ((ISDSC_STATUS)0xEFFF0057L)

//
// MessageId: ISDSC_PATH_COUNT_MISMATCH
//
// MessageText:
//
// Number of paths specified in Set Load Balance Policy does not match the number of paths to the target.
//
#define ISDSC_PATH_COUNT_MISMATCH        ((ISDSC_STATUS)0xEFFF0058L)

//
// MessageId: ISDSC_INVALID_PATH_ID
//
// MessageText:
//
// Path Id specified in the call to set Load Balance Policy is not valid
//
#define ISDSC_INVALID_PATH_ID            ((ISDSC_STATUS)0xEFFF0059L)

//
// MessageId: ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED
//
// MessageText:
//
// Multiple primary paths specified when only one primary path is expected.
//
#define ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED ((ISDSC_STATUS)0xEFFF005AL)

//
// MessageId: ISDSC_NO_PRIMARY_PATH_SPECIFIED
//
// MessageText:
//
// No primary path specified when at least one is expected.
//
#define ISDSC_NO_PRIMARY_PATH_SPECIFIED  ((ISDSC_STATUS)0xEFFF005BL)

//
// MessageId: ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND
//
// MessageText:
//
// Device is already a persistently bound device.
//
#define ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND ((ISDSC_STATUS)0xEFFF005CL)

//
// MessageId: ISDSC_DEVICE_NOT_FOUND
//
// MessageText:
//
// Device was not found.
//
#define ISDSC_DEVICE_NOT_FOUND           ((ISDSC_STATUS)0xEFFF005DL)

//
// MessageId: ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT
//
// MessageText:
//
// The device specified does not originate from an iSCSI disk or a persistent iSCSI login.
//
#define ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT ((ISDSC_STATUS)0xEFFF005EL)

//
// MessageId: ISDSC_DNS_NAME_UNRESOLVED
//
// MessageText:
//
// The DNS name specified was not resolved.
//
#define ISDSC_DNS_NAME_UNRESOLVED        ((ISDSC_STATUS)0xEFFF005FL)

//
// MessageId: ISDSC_NO_CONNECTION_AVAILABLE
//
// MessageText:
//
// There is no connection available in the iSCSI session to process the request.
//
#define ISDSC_NO_CONNECTION_AVAILABLE    ((ISDSC_STATUS)0xEFFF0060L)

//
// MessageId: ISDSC_LB_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// The given Load Balance policy is not supported.
//
#define ISDSC_LB_POLICY_NOT_SUPPORTED    ((ISDSC_STATUS)0xEFFF0061L)

//
// MessageId: ISDSC_REMOVE_CONNECTION_IN_PROGRESS
//
// MessageText:
//
// A remove connection request is already in progress for this session.
//
#define ISDSC_REMOVE_CONNECTION_IN_PROGRESS ((ISDSC_STATUS)0xEFFF0062L)

//
// MessageId: ISDSC_INVALID_CONNECTION_ID
//
// MessageText:
//
// Given connection was not found in the session.
//
#define ISDSC_INVALID_CONNECTION_ID      ((ISDSC_STATUS)0xEFFF0063L)

//
// MessageId: ISDSC_CANNOT_REMOVE_LEADING_CONNECTION
//
// MessageText:
//
// The leading connection in the session cannot be removed.
//
#define ISDSC_CANNOT_REMOVE_LEADING_CONNECTION ((ISDSC_STATUS)0xEFFF0064L)

//
// MessageId: ISDSC_RESTRICTED_BY_GROUP_POLICY
//
// MessageText:
//
// The operation cannot be performed since it does not conform with the group policy assigned to this computer.
//
#define ISDSC_RESTRICTED_BY_GROUP_POLICY ((ISDSC_STATUS)0xEFFF0065L)

//
// MessageId: ISDSC_ISNS_FIREWALL_BLOCKED
//
// MessageText:
//
// The operation cannot be performed since the Internet Storage Name Server (iSNS) firewall exception has not been enabled.
//
#define ISDSC_ISNS_FIREWALL_BLOCKED      ((ISDSC_STATUS)0xEFFF0066L)

//
// MessageId: ISDSC_FAILURE_TO_PERSIST_LB_POLICY
//
// MessageText:
//
// Failed to persist load balancing policy parameters.
//
#define ISDSC_FAILURE_TO_PERSIST_LB_POLICY ((ISDSC_STATUS)0xEFFF0067L)

//
// MessageId: ISDSC_INVALID_HOST
//
// MessageText:
//
// The name could not be resolved to an IP Address.
//
#define ISDSC_INVALID_HOST               ((ISDSC_STATUS)0xEFFF0068L)

#endif /* _ISCSIERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ivalidator.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivalidator_h__
#define __ivalidator_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IValidator_FWD_DEFINED__
#define __IValidator_FWD_DEFINED__
typedef interface IValidator IValidator;
#endif 	/* __IValidator_FWD_DEFINED__ */


#ifndef __ICLRValidator_FWD_DEFINED__
#define __ICLRValidator_FWD_DEFINED__
typedef interface ICLRValidator ICLRValidator;
#endif 	/* __ICLRValidator_FWD_DEFINED__ */


/* header files for imported files */
#include "ivehandler.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ivalidator_0000 */
/* [local] */ 




enum ValidatorFlags
    {	VALIDATOR_EXTRA_VERBOSE	= 0x1,
	VALIDATOR_SHOW_SOURCE_LINES	= 0x2,
	VALIDATOR_CHECK_ILONLY	= 0x4,
	VALIDATOR_CHECK_PEFORMAT_ONLY	= 0x8,
	VALIDATOR_NOCHECK_PEFORMAT	= 0x10
    } ;


extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_s_ifspec;

#ifndef __IValidator_INTERFACE_DEFINED__
#define __IValidator_INTERFACE_DEFINED__

/* interface IValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FAC")
    IValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValidator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IValidator * This,
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            IValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa);
        
        END_INTERFACE
    } IValidatorVtbl;

    interface IValidator
    {
        CONST_VTBL struct IValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValidator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IValidator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IValidator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IValidator_Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    (This)->lpVtbl -> Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)

#define IValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IValidator_Validate_Proxy( 
    IValidator * This,
    /* [in] */ IVEHandler *veh,
    /* [in] */ IUnknown *pAppDomain,
    /* [in] */ unsigned long ulFlags,
    /* [in] */ unsigned long ulMaxError,
    /* [in] */ unsigned long token,
    /* [in] */ LPWSTR fileName,
    /* [size_is][in] */ BYTE *pe,
    /* [in] */ unsigned long ulSize);


void __RPC_STUB IValidator_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IValidator_FormatEventInfo_Proxy( 
    IValidator * This,
    /* [in] */ HRESULT hVECode,
    /* [in] */ VEContext Context,
    /* [out][in] */ LPWSTR msg,
    /* [in] */ unsigned long ulMaxLength,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB IValidator_FormatEventInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IValidator_INTERFACE_DEFINED__ */


#ifndef __ICLRValidator_INTERFACE_DEFINED__
#define __ICLRValidator_INTERFACE_DEFINED__

/* interface ICLRValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FDD")
    ICLRValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRValidator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            ICLRValidator * This,
            /* [in] */ IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            ICLRValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa);
        
        END_INTERFACE
    } ICLRValidatorVtbl;

    interface ICLRValidator
    {
        CONST_VTBL struct ICLRValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRValidator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRValidator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRValidator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRValidator_Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    (This)->lpVtbl -> Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize)

#define ICLRValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRValidator_Validate_Proxy( 
    ICLRValidator * This,
    /* [in] */ IVEHandler *veh,
    /* [in] */ unsigned long ulAppDomainId,
    /* [in] */ unsigned long ulFlags,
    /* [in] */ unsigned long ulMaxError,
    /* [in] */ unsigned long token,
    /* [in] */ LPWSTR fileName,
    /* [size_is][in] */ BYTE *pe,
    /* [in] */ unsigned long ulSize);


void __RPC_STUB ICLRValidator_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRValidator_FormatEventInfo_Proxy( 
    ICLRValidator * This,
    /* [in] */ HRESULT hVECode,
    /* [in] */ VEContext Context,
    /* [out][in] */ LPWSTR msg,
    /* [in] */ unsigned long ulMaxLength,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB ICLRValidator_FormatEventInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRValidator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\iscsidsc.h ===
//***************************************************************************
//
//  iscsidsc.h
// 
//  Module: Public iScsi Discovery header
//
//  Purpose: 
//
//  Copyright (c) 2002 Microsoft Corporation
//
//***************************************************************************

#ifndef _ISCSI_ISCSIDSC_
#define _ISCSI_ISCSIDSC_

#ifndef MIDL_PASS
#ifndef MOFCOMP_PASS
#include <ntddscsi.h>
#include <winioctl.h>
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif
    
//
// Maxiumum length of a Initiator Name
//
#define MAX_ISCSI_HBANAME_LEN 256


//
// Maximum length of an iscsi name
//
#define MAX_ISCSI_NAME_LEN  223
#define MAX_ISCSI_ALIAS_LEN  255


//
// Maxiumum length of a portal names
//
#define MAX_ISCSI_PORTAL_NAME_LEN 256
#define MAX_ISCSI_PORTAL_ALIAS_LEN 256

//
// Maximum length of a text address
//
#define MAX_ISCSI_TEXT_ADDRESS_LEN 256

//
// Maxiumum length of a text port address. It can be a DNS name or a .
// name
//
#define MAX_ISCSI_PORTAL_ADDRESS_LEN MAX_ISCSI_TEXT_ADDRESS_LEN

//
// Maximum length of a discovery domain name
//
#define MAX_ISCSI_DISCOVERY_DOMAIN_LEN 256


//
// For apis that take a port number, this specifies that any port can
// be used
//
#define ISCSI_ANY_INITIATOR_PORT         ((ULONG)-1)

//
// For apis that take a port number this specifies that all ports
// should be used
//
#define ISCSI_ALL_INITIATOR_PORTS        ((ULONG)-1)

//
// Maximum length of a RADIUS server address +
// two terminating characters
//
#define MAX_RADIUS_ADDRESS_LEN 41


#ifdef MOFCOMP_PASS
//
// Definitions for iscsi security flags. These flags provide
// information about the security expectations of a target portal and
// are needed to insure a successful IKE/IPSEC negotiation. Note that
// the flags and values are taken directly from the iSNS spec
//
#define ISCSI_SECURITY_FLAGS uint64

    // 1 = Tunnel Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    "0x00000040"

    // 1 = Transport Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED "0x00000020"
                
    // 1 = PFS Enabled; 0 = PFS Disabled
#define ISCSI_SECURITY_FLAG_PFS_ENABLED              "0x00000010"
                
    // 1 = Aggressive Mode Enabled; 0 = Disabled
#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  "0x00000008"
                
    // 1 = Main Mode Enabled; 0 = MM Disabled
#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        "0x00000004"
                
    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled
#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        "0x00000002"

    // If set then all other ISCSI_SECURITY_FLAGS are valid             
#define ISCSI_SECURITY_FLAG_VALID                    "0x00000001"

#define SECURITY_FLAG_QUALIFIERS \
     description("Security flags") : amended, \
     BitMap{ \
            ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED, \
            ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED, \
            ISCSI_SECURITY_FLAG_PFS_ENABLED, \
            ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED, \
            ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED, \
            ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED, \
            ISCSI_SECURITY_FLAG_VALID \
           }, \
     BitValues{ \
            "Tunnel mode preferred", \
            "Transport mode preferred", \
            "PFS Enabled", \
            "Aggressive mode enabled", \
            "Main Mode Enabled", \
            "IKE/IPSec Enabled", \
            "ISCSI_SECURITY_FLAGS are valid" \
              } : amended
                                

#define ISCSI_SECURITY_FLAGS_CPPQUOTE \
"//\n" \
"// Definitions for iscsi security flags. These flags provide\n" \
"// information about the security expectations of a target portal and\n" \
"// are needed to insure a successful IKE/IPSEC negotiation. Note that\n" \
"// the flags and values are taken directly from the iSNS spec\n" \
"//\n" \
"\n" \
"    // 1 = Tunnel Mode Preferred; 0 = No Preference\n" \
"#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    0x00000040\n" \
"\n" \
"    // 1 = Transport Mode Preferred; 0 = No Preference\n" \
"#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED 0x00000020\n" \
"               \n" \
"    // 1 = PFS Enabled; 0 = PFS Disabled\n" \
"#define ISCSI_SECURITY_FLAG_PFS_ENABLED              0x00000010\n" \
"               \n" \
"    // 1 = Aggressive Mode Enabled; 0 = Disabled\n" \
"#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  0x00000008\n" \
"               \n" \
"    // 1 = Main Mode Enabled; 0 = MM Disabled\n" \
"#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        0x00000004\n" \
"               \n" \
"    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled\n" \
"#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        0x00000002\n" \
"\n" \
"    // If set then all other ISCSI_SECURITY_FLAGS are valid                \n" \
"#define ISCSI_SECURITY_FLAG_VALID                    0x00000001                \n" \
"\n"

//
// definitions for ISCSI_LOGIN_OPTIONS. This structure is used to pass
// information that affects the login negotiation of session
//

#define ISCSI_DIGEST_TYPE_NONE    "0"
#define ISCSI_DIGEST_TYPE_CRC32C  "1"

#define ISCSI_DIGEST_CPPQUOTE \
"#ifndef _ISCSI_ISCSIDSC_\n" \
"typedef enum\n" \
"{\n" \
"   ISCSI_DIGEST_TYPE_NONE = 0,\n" \
"   ISCSI_DIGEST_TYPE_CRC32C = 1\n" \
"} ISCSI_DIGEST_TYPES, *PISCSI_DIGEST_TYPES;\n" \
"\n" \
"typedef enum\n" \
"{\n" \
"   ISCSI_NO_AUTH_TYPE = 0,\n" \
"   ISCSI_CHAP_AUTH_TYPE = 1,\n" \
"   ISCSI_MUTUAL_CHAP_AUTH_TYPE = 2 \n" \
"} ISCSI_AUTH_TYPES, *PISCSI_AUTH_TYPES;\n" \
"#endif\n"   

#define ISCSI_LOGIN_FLAGS_CPPQUOTE \
"//\n" \
"// bit flags for ISCSI_LOGIN_FLAGS\n" \
"//\n" \
"#ifndef _ISCSI_ISCSIDSC_\n" \
"#define ISCSI_LOGIN_FLAGS ULONG\n\n" \
"#define ISCSI_LOGIN_FLAG_REQUIRE_IPSEC                0x00000001\n" \
"#define ISCSI_LOGIN_FLAG_MULTIPATH_ENABLED            0x00000002\n" \
"#define ISCSI_LOGIN_FLAG_RESERVED1                    0x00000004\n" \
"#define ISCSI_LOGIN_FLAG_ALLOW_PORTAL_HOPPING         0x00000008\n" \
"#define ISCSI_LOGIN_FLAG_USE_RADIUS_RESPONSE          0x00000010\n" \
"#define ISCSI_LOGIN_FLAG_USE_RADIUS_VERIFICATION          0x00000020\n" \
"\n" \
"#endif\n"   

#define ISCSI_LOGIN_FLAGS_QUALIFIERS \
    BitValues{"Require IPSEC", "Multipath Enabled", "Reserved1", "Allow Portal Hopping"}, \
    BitMap{ "0x00000001", "0x00000002", "0x00000004", "0x00000008" }

#define ISCSI_LOGIN_FLAGS uint32

#define ISCSI_AUTH_TYPES_QUALIFIERS \
    Values{"No Authentication", \
           "CHAP", \
           "Mutual CHAP" \
          } : amended, \
    ValueMap{"0", "1", "2"}

#define ISCSI_AUTH_TYPES_CPPQUOTE \

#define ISCSI_AUTH_TYPES uint32

//
// Login options flags
//
#define ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED uint32

#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               "0x00000001"
#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 "0x00000002"
#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         "0x00000004"
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         "0x00000008"
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       "0x00000010"
#define ISCSI_LOGIN_OPTIONS_USERNAME                    "0x00000020"
#define ISCSI_LOGIN_OPTIONS_PASSWORD                    "0x00000040"
#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   "0x00000080"

#define ISCSI_LOGIN_OPTIONS_INFO_CPPQUOTE \
"//\n" \
"// Bit flags for InformationSpecifies\n" \
"//\n" \
"#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               0x00000001\n" \
"#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 0x00000002\n" \
"#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         0x00000004\n" \
"#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         0x00000008\n" \
"#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       0x00000010\n" \
"#define ISCSI_LOGIN_OPTIONS_USERNAME                    0x00000020\n" \
"#define ISCSI_LOGIN_OPTIONS_PASSWORD                    0x00000040\n" \
"#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   0x00000080\n" \
"\n"

#define ISCSI_LOGIN_OPTIONS_INFO_QUALIFIERS \
     BitMap{ ISCSI_LOGIN_OPTIONS_HEADER_DIGEST, \
             ISCSI_LOGIN_OPTIONS_DATA_DIGEST, \
             ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS, \
             ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT, \
             ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN \
           }, \
     BitValues{"HeaderDigest", "DataDigest", "MaxConnections", \
               "DefaultTime2Wait", "DefaultTime2Retain" } : amended


//
// IKE Identification payload types
//
#define       ID_IPV4_ADDR                        "1"
#define       ID_FQDN                             "2"
#define       ID_USER_FQDN                        "3"
#define       ID_IPV6_ADDR                        "5"

#define IKE_IDENTIFICATION_TYPE_QUALIFIERS \
             ValueMap{ ID_IPV4_ADDR, \
                       ID_FQDN, \
                       ID_USER_FQDN, \
                       ID_IPV6_ADDR \
                       }, \
              Values{  "ID_IPV4_ADDR", \
                       "ID_FQDN", \
                       "ID_USER_FQDN", \
                       "ID_IPV6_ADDR" \
                        }

#define IKE_AUTHENTICATION_PAYLOAD_TYPE_CPPQUOTE \
"//\n" \
"// IKE Identification payload types (from RFC 2407)\n" \
"//\n" \
"#define       ID_IPV4_ADDR                        1\n" \
"#define       ID_FQDN                             2\n" \
"#define       ID_USER_FQDN                        3\n" \
"#define       ID_IPV6_ADDR                        5\n" \
"\n"
                   
    
#else

//
// Definitions for iscsi security flags. These flags provide
// information about the security expectations of a target portal and
// are needed to insure a successful IKE/IPSEC negotiation. Note that
// the flags and values are taken directly from the iSNS spec
//
typedef ULONGLONG ISCSI_SECURITY_FLAGS;
typedef ISCSI_SECURITY_FLAGS *PISCSI_SECURITY_FLAGS;


    // 1 = Tunnel Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    0x00000040

    // 1 = Transport Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED 0x00000020
                
    // 1 = PFS Enabled; 0 = PFS Disabled
#define ISCSI_SECURITY_FLAG_PFS_ENABLED              0x00000010
                
    // 1 = Aggressive Mode Enabled; 0 = Disabled
#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  0x00000008
                
    // 1 = Main Mode Enabled; 0 = MM Disabled
#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        0x00000004
                
    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled
#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        0x00000002

    // If set then all other ISCSI_SECURITY_FLAGS are valid             
#define ISCSI_SECURITY_FLAG_VALID                    0x00000001             

//
// definitions for ISCSI_LOGIN_OPTIONS. This structure is used to pass
// information that affects the login negotiation of session
//

typedef enum
{
    ISCSI_DIGEST_TYPE_NONE = 0,
    ISCSI_DIGEST_TYPE_CRC32C = 1
} ISCSI_DIGEST_TYPES, *PISCSI_DIGEST_TYPES;

//
// bit flags for ISCSI_LOGIN_FLAGS
//
typedef ULONG ISCSI_LOGIN_FLAGS, *PISCSI_LOGIN_FLAGS;

#define ISCSI_LOGIN_FLAG_REQUIRE_IPSEC                0x00000001
#define ISCSI_LOGIN_FLAG_MULTIPATH_ENABLED            0x00000002
#define ISCSI_LOGIN_FLAG_RESERVED1                    0x00000004
#define ISCSI_LOGIN_FLAG_ALLOW_PORTAL_HOPPING         0x00000008
#define ISCSI_LOGIN_FLAG_USE_RADIUS_RESPONSE          0x00000010
#define ISCSI_LOGIN_FLAG_USE_RADIUS_VERIFICATION          0x00000020


//
// Bit flags for InformationSpecifies
//

typedef ULONG ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED;
typedef ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED *PISCSI_LOGIN_OPTIONS_INFO_SPECIFIED;

#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               0x00000001
#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 0x00000002
#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         0x00000004
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         0x00000008
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       0x00000010
#define ISCSI_LOGIN_OPTIONS_USERNAME                    0x00000020
#define ISCSI_LOGIN_OPTIONS_PASSWORD                    0x00000040
#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   0x00000080


#define ISCSI_LOGIN_OPTIONS_VERSION 0

typedef enum
{
    ISCSI_NO_AUTH_TYPE = 0,
    ISCSI_CHAP_AUTH_TYPE = 1,
    ISCSI_MUTUAL_CHAP_AUTH_TYPE = 2
} ISCSI_AUTH_TYPES, *PISCSI_AUTH_TYPES;

typedef struct
{
    ULONG Version;                    // ISCSI_LOGIN_OPTIONS_VERSION

                       // Bit field indicating which information is specified   
    ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED InformationSpecified;

    ISCSI_LOGIN_FLAGS LoginFlags;

    ISCSI_AUTH_TYPES AuthType;
    
    ISCSI_DIGEST_TYPES HeaderDigest;
    ISCSI_DIGEST_TYPES DataDigest;
    ULONG MaximumConnections;
    ULONG DefaultTime2Wait;
    ULONG DefaultTime2Retain;

    //
    // Username and passwords are used for iscsi authentication and are
    // defined as defined as binary blobs. They have different meanings
    // based upon the different iSCSI authentication method used.
    //     For CHAP the username is the CHAP Name (CHAP_N) 
    //     and the password is the shared secret of the target. If the
    //     Username is not specified then the service will use the
    //     initiator node name as the CHAP Name
    //
    // If they are strings then they are expected
    // to be ANSI strings. 
    //
    ULONG UsernameLength;
    ULONG PasswordLength;
#ifdef MIDL_PASS
    [size_is(UsernameLength)]
#endif
    PUCHAR Username;
#ifdef MIDL_PASS
    [size_is(PasswordLength)]
#endif
    PUCHAR Password;
} ISCSI_LOGIN_OPTIONS, *PISCSI_LOGIN_OPTIONS;


//
// This defines flags that affect how a target is managed and its
// information stored
//
typedef ULONG ISCSI_TARGET_FLAGS;
typedef ISCSI_TARGET_FLAGS *PISCSI_TARGET_FLAGS;

//
// if this flag is set then the target will never be reported unless it
// is also discovered dynamically.
//
#define ISCSI_TARGET_FLAG_HIDE_STATIC_TARGET            0x00000002

//
// If this flag is set then the target information passed will be
// merged with any target information already statically configured for
// the target
//
#define ISCSI_TARGET_FLAG_MERGE_TARGET_INFORMATION       0x00000004


//
// IKE Identification payload types (from RFC 2407)
//
typedef UCHAR IKE_IDENTIFICATION_PAYLOAD_TYPE, *PIKE_IDENTIFICATION_PAYLOAD_TYPE;

#define       ID_IPV4_ADDR                        1
#define       ID_FQDN                             2
#define       ID_USER_FQDN                        3
#define       ID_IPV6_ADDR                        5



//
// Methods and data structures for those methods that can be used
// for IKE authentication in the SetIScsiIKEInfo api
//
typedef enum
{
    IKE_AUTHENTICATION_PRESHARED_KEY_METHOD = 1
} IKE_AUTHENTICATION_METHOD, *PIKE_AUTHENTICATION_METHOD;

typedef struct
{
    ISCSI_SECURITY_FLAGS SecurityFlags;
    IKE_IDENTIFICATION_PAYLOAD_TYPE IdType;
    ULONG IdLengthInBytes;
    PUCHAR Id;
    ULONG KeyLengthInBytes;
    PUCHAR Key;
} IKE_AUTHENTICATION_PRESHARED_KEY, *PIKE_AUTHENTICATION_PRESHARED_KEY;

typedef struct
{
    IKE_AUTHENTICATION_METHOD AuthMethod;
    union
    {
        IKE_AUTHENTICATION_PRESHARED_KEY PsKey;
    };
} IKE_AUTHENTICATION_INFORMATION, *PIKE_AUTHENTICATION_INFORMATION;

#endif

#ifndef MOFCOMP_PASS

#ifdef _ISDSCP_
#define ISDSC_API WINAPI
#else
#define ISDSC_API DECLSPEC_IMPORT WINAPI
#endif


//
// Each iscsi session and connection has a unique session or connection
// id that is used to reference the session. It it not related to the
// actual ISID
//
typedef struct _ISCSI_UNIQUE_SESSION_ID
{   
   ULONGLONG AdapterUnique;
   ULONGLONG AdapterSpecific;
} ISCSI_UNIQUE_SESSION_ID, *PISCSI_UNIQUE_SESSION_ID,
  ISCSI_UNIQUE_CONNECTION_ID, *PISCSI_UNIQUE_CONNECTION_ID;

//
// This specifies a mapping from a target LUN to a OS LUN
//

typedef struct
{
    ULONG OSLUN;
    ULONGLONG TargetLUN;
} SCSI_LUN_LIST, *PSCSI_LUN_LIST;

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    WCHAR OSDeviceName[MAX_PATH]; /* \device\ScsiPort3 */
    ISCSI_UNIQUE_SESSION_ID SessionId;
    ULONG OSBusNumber;
    ULONG OSTargetNumber;
    ULONG LUNCount;
#ifdef MIDL_PASS
    [size_is(LUNCount)]
#endif
    PSCSI_LUN_LIST LUNList;
} ISCSI_TARGET_MAPPINGW, *PISCSI_TARGET_MAPPINGW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    CHAR OSDeviceName[MAX_PATH]; /* \device\ScsiPort3 */
    ISCSI_UNIQUE_SESSION_ID SessionId;
    ULONG OSBusNumber;
    ULONG OSTargetNumber;
    ULONG LUNCount;
#ifdef MIDL_PASS
    [size_is(LUNCount)]
#endif
    PSCSI_LUN_LIST LUNList;
} ISCSI_TARGET_MAPPINGA, *PISCSI_TARGET_MAPPINGA;

#ifdef UNICODE
typedef ISCSI_TARGET_MAPPINGW  ISCSI_TARGET_MAPPING;
typedef PISCSI_TARGET_MAPPINGW  PISCSI_TARGET_MAPPING;
#else
typedef ISCSI_TARGET_MAPPINGA  ISCSI_TARGET_MAPPING;
typedef PISCSI_TARGET_MAPPINGA  PISCSI_TARGET_MAPPING;
#endif // UNICODE
                   
typedef struct
{
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTALW, *PISCSI_TARGET_PORTALW;

typedef struct
{
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTALA, *PISCSI_TARGET_PORTALA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTALW  ISCSI_TARGET_PORTAL;
typedef PISCSI_TARGET_PORTALW  PISCSI_TARGET_PORTAL;
#else
typedef ISCSI_TARGET_PORTALA  ISCSI_TARGET_PORTAL;
typedef PISCSI_TARGET_PORTALA  PISCSI_TARGET_PORTAL;
#endif // UNICODE

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTAL_INFOW, *PISCSI_TARGET_PORTAL_INFOW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTAL_INFOA, *PISCSI_TARGET_PORTAL_INFOA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_INFOW  ISCSI_TARGET_PORTAL_INFO;
typedef PISCSI_TARGET_PORTAL_INFOW  PISCSI_TARGET_PORTAL_INFO;
#else
typedef ISCSI_TARGET_PORTAL_INFOA  ISCSI_TARGET_PORTAL_INFO;
typedef PISCSI_TARGET_PORTAL_INFOA  PISCSI_TARGET_PORTAL_INFO;
#endif // UNICODE

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} ISCSI_TARGET_PORTAL_INFO_EXW, *PISCSI_TARGET_PORTAL_INFO_EXW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} ISCSI_TARGET_PORTAL_INFO_EXA, *PISCSI_TARGET_PORTAL_INFO_EXA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_INFO_EXW  ISCSI_TARGET_PORTAL_INFO_EX;
typedef PISCSI_TARGET_PORTAL_INFO_EXW  PISCSI_TARGET_PORTAL_INFO_EX;
#else
typedef ISCSI_TARGET_PORTAL_INFO_EXA  ISCSI_TARGET_PORTAL_INFO_EX;
typedef PISCSI_TARGET_PORTAL_INFO_EXA  PISCSI_TARGET_PORTAL_INFO_EX;
#endif // UNICODE

typedef struct
{
    ULONG Count;
    ISCSI_TARGET_PORTALW Portals[1];
} ISCSI_TARGET_PORTAL_GROUPW, *PISCSI_TARGET_PORTAL_GROUPW;

typedef struct
{
    ULONG Count;
    ISCSI_TARGET_PORTALA Portals[1];
} ISCSI_TARGET_PORTAL_GROUPA, *PISCSI_TARGET_PORTAL_GROUPA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_GROUPW ISCSI_TARGET_PORTAL_GROUP;
typedef PISCSI_TARGET_PORTAL_GROUPW PISCSI_TARGET_PORTAL_GROUP;
#else
typedef ISCSI_TARGET_PORTAL_GROUPA ISCSI_TARGET_PORTAL_GROUP;
typedef PISCSI_TARGET_PORTAL_GROUPA PISCSI_TARGET_PORTAL_GROUP;
#endif // UNICODE


typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;  // TODO: add connectionid to mof
    PWCHAR InitiatorAddress;
    PWCHAR TargetAddress;
    USHORT InitiatorSocket;
    USHORT TargetSocket;
    UCHAR CID[2];
} ISCSI_CONNECTION_INFOW, *PISCSI_CONNECTION_INFOW;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    PWCHAR InitiatorName;
    PWCHAR TargetNodeName;
    PWCHAR TargetName;
    UCHAR ISID[6];
    UCHAR TSID[2];
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFOW Connections;    
} ISCSI_SESSION_INFOW, *PISCSI_SESSION_INFOW;


typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;  // TODO: add connectionid to mof
    PCHAR InitiatorAddress;
    PCHAR TargetAddress;
    USHORT InitiatorSocket;
    USHORT TargetSocket;
    UCHAR CID[2];
} ISCSI_CONNECTION_INFOA, *PISCSI_CONNECTION_INFOA;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    PCHAR InitiatorName;
    PCHAR TargetNodeName;
    PCHAR TargetName;
    UCHAR ISID[6];
    UCHAR TSID[2];
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFOA Connections;    
} ISCSI_SESSION_INFOA, *PISCSI_SESSION_INFOA;


#ifdef UNICODE
typedef ISCSI_SESSION_INFOW ISCSI_SESSION_INFO;
typedef PISCSI_SESSION_INFOW PISCSI_SESSION_INFO;

typedef ISCSI_CONNECTION_INFOW ISCSI_CONNECTION_INFO;
typedef PISCSI_CONNECTION_INFOW PISCSI_CONNECTION_INFO;
#else
typedef ISCSI_SESSION_INFOA ISCSI_SESSION_INFO;
typedef PISCSI_SESSION_INFOA PISCSI_SESSION_INFO;

typedef ISCSI_CONNECTION_INFOA ISCSI_CONNECTION_INFO;
typedef PISCSI_CONNECTION_INFOA PISCSI_CONNECTION_INFO;
#endif

typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;
    UCHAR State;
    UCHAR Protocol;
    UCHAR HeaderDigest;
    UCHAR DataDigest;
    ULONG MaxRecvDataSegmentLength;
    ISCSI_AUTH_TYPES AuthType;
    ULONGLONG EstimatedThroughput;
    ULONG MaxDatagramSize;
} ISCSI_CONNECTION_INFO_EX, *PISCSI_CONNECTION_INFO_EX;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    BOOLEAN InitialR2t;
    BOOLEAN ImmediateData;
    UCHAR Type;
    BOOLEAN DataSequenceInOrder;
    BOOLEAN DataPduInOrder;
    UCHAR ErrorRecoveryLevel;
    ULONG MaxOutstandingR2t;
    ULONG FirstBurstLength;
    ULONG MaxBurstLength;
    ULONG MaximumConnections;
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFO_EX Connections;
} ISCSI_SESSION_INFO_EX, *PISCSI_SESSION_INFO_EX;

#ifndef MIDL_PASS
typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    SCSI_ADDRESS ScsiAddress;
    GUID DeviceInterfaceType;
    WCHAR DeviceInterfaceName[MAX_PATH];
    WCHAR LegacyName[MAX_PATH];
    STORAGE_DEVICE_NUMBER StorageDeviceNumber;
    DWORD /* DEVINST */ DeviceInstance;
} ISCSI_DEVICE_ON_SESSIONW, *PISCSI_DEVICE_ON_SESSIONW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    SCSI_ADDRESS ScsiAddress;
    GUID DeviceInterfaceType;
    CHAR DeviceInterfaceName[MAX_PATH];
    CHAR LegacyName[MAX_PATH];
    STORAGE_DEVICE_NUMBER StorageDeviceNumber;
    DWORD /* DEVINST */ DeviceInstance;
} ISCSI_DEVICE_ON_SESSIONA, *PISCSI_DEVICE_ON_SESSIONA;

#ifdef UNICODE
typedef ISCSI_DEVICE_ON_SESSIONW ISCSI_DEVICE_ON_SESSION;
typedef PISCSI_DEVICE_ON_SESSIONW PISCSI_DEVICE_ON_SESSION;
#else
typedef ISCSI_DEVICE_ON_SESSIONA ISCSI_DEVICE_ON_SESSION;
typedef PISCSI_DEVICE_ON_SESSIONA PISCSI_DEVICE_ON_SESSION;
#endif

#endif

typedef struct
{
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    BOOLEAN IsInformationalSession;
    WCHAR InitiatorInstance[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    ISCSI_TARGET_PORTALW TargetPortal;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    PISCSI_TARGET_MAPPINGW Mappings;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} PERSISTENT_ISCSI_LOGIN_INFOW, *PPERSISTENT_ISCSI_LOGIN_INFOW;

typedef struct
{
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    BOOLEAN IsInformationalSession;
    CHAR InitiatorInstance[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    ISCSI_TARGET_PORTALA TargetPortal;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    PISCSI_TARGET_MAPPINGA Mappings;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} PERSISTENT_ISCSI_LOGIN_INFOA, *PPERSISTENT_ISCSI_LOGIN_INFOA;

#ifdef UNICODE
typedef PERSISTENT_ISCSI_LOGIN_INFOW PERSISTENT_ISCSI_LOGIN_INFO;
typedef PPERSISTENT_ISCSI_LOGIN_INFOW PPERSISTENT_ISCSI_LOGIN_INFO;
#else
typedef PERSISTENT_ISCSI_LOGIN_INFOA PERSISTENT_ISCSI_LOGIN_INFO;
typedef PPERSISTENT_ISCSI_LOGIN_INFOA PPERSISTENT_ISCSI_LOGIN_INFO;
#endif


//
// definitions of information that can be queried and set via the
// GetIScsiTargetInformation and SetIScsiTargetInformation apis
//
typedef enum
{
    ISCSI_TCP_PROTOCOL_TYPE
} TARGETPROTOCOLTYPE, *PTARGETPROTOCOLTYPE;

typedef enum
{
                        // Requires DiscoveryMechansim parameter
    ProtocolType,       // Protocol used to communicate with TARGET - TARGETPROTOCOLTYPE

                        // Requires DiscoveryMechansim parameter
    TargetAlias,        // Alias Name - WCHAR Alias[MAX_ISCSI_TARGET_ALIAS_LEN]

                        // 
    DiscoveryMechanisms, // Discovery mechanisms - strings

                        // Requires DiscoveryMechansim parameter
    PortalGroups,       // Portal Groups - array of portal groups, preceeded by a ULONG count. Each Portal Group must be aliagned on a 4 byte boundry

                        // Requires DiscoveryMechansim parameter
                        // ISCSI_TARGET_MAPPING
    PersistentTargetMappings,
    
                        // Requires DiscoveryMechansim parameter
    InitiatorName,      // Name of initiator that can connect to target
    
                        // Requires DiscoveryMechansim parameter
    TargetFlags,        // TargetFlags

    LoginOptions        // Requires DiscoveryMechansim parameter
                        // ISCSI_LOGIN_OPTIONS
               
} TARGET_INFORMATION_CLASS, *PTARGET_INFORMATION_CLASS;


typedef struct
{
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG BuildNumber;
} ISCSI_VERSION_INFO, *PISCSI_VERSION_INFO;



#if ! (defined(MIDL_PASS))

ISDSC_STATUS ISDSC_API GetIScsiVersionInformation(
    PISCSI_VERSION_INFO VersionInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiTargetInformationW(
    IN __in PWCHAR TargetName,
    IN __in_opt PWCHAR DiscoveryMechanism,
    IN TARGET_INFORMATION_CLASS InfoClass,
    IN OUT PULONG BufferSize,
    OUT PVOID Buffer
    );

ISDSC_STATUS ISDSC_API GetIScsiTargetInformationA(
    IN __in PCHAR TargetName,
    IN __in_opt PCHAR DiscoveryMechanism,
    IN TARGET_INFORMATION_CLASS InfoClass,
    IN OUT PULONG BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define GetIScsiTargetInformation GetIScsiTargetInformationW
#else
#define GetIScsiTargetInformation GetIScsiTargetInformationA
#endif // UNICODE

ISDSC_STATUS ISDSC_API AddIScsiConnectionW(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PVOID Reserved,
    IN ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    OUT OPTIONAL PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );
    
ISDSC_STATUS ISDSC_API AddIScsiConnectionA(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PVOID Reserved,
    IN ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    OUT OPTIONAL PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );
    
#ifdef UNICODE
#define AddIScsiConnection AddIScsiConnectionW
#else
#define AddIScsiConnection AddIScsiConnectionA
#endif // UNICODE


ISDSC_STATUS ISDSC_API RemoveIScsiConnection(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetsW(
    IN BOOLEAN ForceUpdate,
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetsA(
    IN BOOLEAN ForceUpdate,
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PCHAR Buffer
    );

#ifdef UNICODE
#define ReportIScsiTargets ReportIScsiTargetsW
#else
#define ReportIScsiTargets ReportIScsiTargetsA
#endif


ISDSC_STATUS ISDSC_API AddIScsiStaticTargetW(
    IN __in PWCHAR TargetName,
    IN OPTIONAL __in_opt PWCHAR TargetAlias,
    IN ISCSI_TARGET_FLAGS TargetFlags,
    IN BOOLEAN Persist,
    IN OPTIONAL PISCSI_TARGET_MAPPINGW Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL PISCSI_TARGET_PORTAL_GROUPW PortalGroup
    );

ISDSC_STATUS ISDSC_API AddIScsiStaticTargetA(
    IN __in PCHAR TargetName,
    IN OPTIONAL __in_opt PCHAR TargetAlias,
    IN ISCSI_TARGET_FLAGS TargetFlags,
    IN BOOLEAN Persist,
    IN OPTIONAL PISCSI_TARGET_MAPPINGA Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL PISCSI_TARGET_PORTAL_GROUPA PortalGroup
    );

#ifdef UNICODE
#define AddIScsiStaticTarget AddIScsiStaticTargetW
#else
#define AddIScsiStaticTarget AddIScsiStaticTargetA
#endif

ISDSC_STATUS ISDSC_API RemoveIScsiStaticTargetW(
    IN __in PWCHAR TargetName
    );

ISDSC_STATUS ISDSC_API RemoveIScsiStaticTargetA(
    IN __in PCHAR TargetName
    );

#ifdef UNICODE
#define RemoveIScsiStaticTarget RemoveIScsiStaticTargetW
#else
#define RemoveIScsiStaticTarget RemoveIScsiStaticTargetA
#endif

ISDSC_STATUS ISDSC_API AddIScsiSendTargetPortalW(
    IN OPTIONAL __in_opt PWCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags, 
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API AddIScsiSendTargetPortalA(
    IN OPTIONAL __in_opt PCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags, 
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define AddIScsiSendTargetPortal AddIScsiSendTargetPortalW
#else
#define AddIScsiSendTargetPortal AddIScsiSendTargetPortalA
#endif

ISDSC_STATUS ISDSC_API RemoveIScsiSendTargetPortalW(
    IN OPTIONAL PWCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RemoveIScsiSendTargetPortalA(
    IN OPTIONAL PCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RemoveIScsiSendTargetPortal RemoveIScsiSendTargetPortalW
#else
#define RemoveIScsiSendTargetPortal RemoveIScsiSendTargetPortalA
#endif

ISDSC_STATUS ISDSC_API RefreshIScsiSendTargetPortalW(
    IN OPTIONAL PWCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RefreshIScsiSendTargetPortalA(
    IN OPTIONAL PCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RefreshIScsiSendTargetPortal RefreshIScsiSendTargetPortalW
#else
#define RefreshIScsiSendTargetPortal RefreshIScsiSendTargetPortalA
#endif


ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsW(
    IN OUT PULONG PortalCount,
    IN OUT PISCSI_TARGET_PORTAL_INFOW PortalInfo
    );

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsA(
    IN OUT PULONG PortalCount,
    IN OUT PISCSI_TARGET_PORTAL_INFOA PortalInfo
    );
#ifdef UNICODE
#define ReportIScsiSendTargetPortals ReportIScsiSendTargetPortalsW
#else
#define ReportIScsiSendTargetPortals ReportIScsiSendTargetPortalsA
#endif

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsExW(
    OUT PULONG PortalCount,
    IN OUT PULONG PortalInfoSize,
    IN OUT PISCSI_TARGET_PORTAL_INFO_EXW PortalInfo
    );

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsExA(
    OUT PULONG PortalCount,
    IN OUT PULONG PortalInfoSize,
    IN OUT PISCSI_TARGET_PORTAL_INFO_EXA PortalInfo
    );
#ifdef UNICODE
#define ReportIScsiSendTargetPortalsEx ReportIScsiSendTargetPortalsExW
#else
#define ReportIScsiSendTargetPortalsEx ReportIScsiSendTargetPortalsExA
#endif


ISDSC_STATUS ISDSC_API LoginIScsiTargetW(
    IN __in PWCHAR TargetName,
    IN BOOLEAN IsInformationalSession,
    IN OPTIONAL __in_opt PWCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_TARGET_PORTALW TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_TARGET_MAPPINGW Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    IN BOOLEAN IsPersistent,
    OUT PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PISCSI_UNIQUE_CONNECTION_ID UniqueConnectionId
    );

ISDSC_STATUS ISDSC_API LoginIScsiTargetA(
    IN PCHAR __in TargetName,
    IN BOOLEAN IsInformationalSession,
    IN OPTIONAL __in_opt PCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_TARGET_PORTALA TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_TARGET_MAPPINGA Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    IN BOOLEAN IsPersistent,
    OUT PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PISCSI_UNIQUE_CONNECTION_ID UniqueConnectionId
    );

#ifdef UNICODE
#define LoginIScsiTarget LoginIScsiTargetW
#else
#define LoginIScsiTarget LoginIScsiTargetA
#endif


ISDSC_STATUS ISDSC_API ReportIScsiPersistentLoginsW(
    OUT ULONG *Count,
    IN OUT PPERSISTENT_ISCSI_LOGIN_INFOW PersistentLoginInfo,
    IN OUT PULONG BufferSizeInBytes
    );

ISDSC_STATUS ISDSC_API ReportIScsiPersistentLoginsA(
    OUT ULONG *Count,
    IN OUT PPERSISTENT_ISCSI_LOGIN_INFOA PersistentLoginInfo,
    IN OUT PULONG BufferSizeInBytes
    );

#ifdef UNICODE
#define ReportIScsiPersistentLogins ReportIScsiPersistentLoginsW
#else
#define ReportIScsiPersistentLogins ReportIScsiPersistentLoginsA
#endif


                                    
ISDSC_STATUS ISDSC_API LogoutIScsiTarget(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId
    );

ISDSC_STATUS ISDSC_API RemoveIScsiPersistentTargetW(
    IN PWCHAR __in InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PWCHAR __in TargetName,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RemoveIScsiPersistentTargetA(
    IN PCHAR __in InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PCHAR __in TargetName,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RemoveIScsiPersistentTarget RemoveIScsiPersistentTargetW
#else
#define RemoveIScsiPersistentTarget RemoveIScsiPersistentTargetA
#endif

ISDSC_STATUS ISDSC_API SendScsiInquiry(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN ULONGLONG Lun,
    IN UCHAR EvpdCmddt,
    IN UCHAR PageCode,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API SendScsiReadCapacity(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN ULONGLONG Lun,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API SendScsiReportLuns(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiInitiatorListW(
    IN OUT ULONG *BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiInitiatorListA(
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PCHAR Buffer
    );

#ifdef UNICODE
#define ReportIScsiInitiatorList ReportIScsiInitiatorListW
#else
#define ReportIScsiInitiatorList ReportIScsiInitiatorListA
#endif


ISDSC_STATUS ISDSC_API ReportActiveIScsiTargetMappingsW(
    IN OUT PULONG BufferSize,
    OUT PULONG MappingCount,
    OUT PISCSI_TARGET_MAPPINGW Mappings
    );

ISDSC_STATUS ISDSC_API ReportActiveIScsiTargetMappingsA(
    IN OUT PULONG BufferSize,
    OUT PULONG MappingCount,
    OUT PISCSI_TARGET_MAPPINGA Mappings
    );

#ifdef UNICODE
#define ReportActiveIScsiTargetMappings ReportActiveIScsiTargetMappingsW
#else
#define ReportActiveIScsiTargetMappings ReportActiveIScsiTargetMappingsA
#endif

ISDSC_STATUS ISDSC_API SetIScsiTunnelModeOuterAddressW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PWCHAR __in_opt DestinationAddress,
    IN PWCHAR __in_opt OuterModeAddress,
    IN BOOLEAN Persist
    );
    
ISDSC_STATUS ISDSC_API SetIScsiTunnelModeOuterAddressA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PCHAR __in_opt DestinationAddress,
    IN PCHAR __in_opt OuterModeAddress,
    IN BOOLEAN Persist
    );

#ifdef UNICODE
#define SetIScsiTunnelModeOuterAddress SetIScsiTunnelModeOuterAddressW
#else
#define SetIScsiTunnelModeOuterAddress SetIScsiTunnelModeOuterAddressA
#endif


ISDSC_STATUS ISDSC_API SetIScsiIKEInfoW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PIKE_AUTHENTICATION_INFORMATION AuthInfo,
    IN BOOLEAN Persist
    );

ISDSC_STATUS ISDSC_API SetIScsiIKEInfoA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PIKE_AUTHENTICATION_INFORMATION AuthInfo,
    IN BOOLEAN Persist
    );

#ifdef UNICODE
#define SetIScsiIKEInfo SetIScsiIKEInfoW
#else
#define SetIScsiIKEInfo SetIScsiIKEInfoA
#endif

ISDSC_STATUS ISDSC_API GetIScsiIKEInfoW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PULONG Reserved,                                        
    IN OUT PIKE_AUTHENTICATION_INFORMATION AuthInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiIKEInfoA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PULONG Reserved,                                        
    IN OUT PIKE_AUTHENTICATION_INFORMATION AuthInfo
    );

#ifdef UNICODE
#define GetIScsiIKEInfo GetIScsiIKEInfoW
#else
#define GetIScsiIKEInfo GetIScsiIKEInfoA
#endif

ISDSC_STATUS ISDSC_API SetIScsiGroupPresharedKey(
    IN ULONG KeyLength,
    IN PUCHAR Key,
    BOOLEAN Persist
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorCHAPSharedSecret(
    IN ULONG SharedSecretLength,
    IN PUCHAR SharedSecret
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorRADIUSSharedSecret(
    IN ULONG SharedSecretLength,
    IN PUCHAR SharedSecret
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorNodeNameW(
    IN OPTIONAL __in_opt PWCHAR InitiatorNodeName
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorNodeNameA(
    IN OPTIONAL __in_opt PCHAR InitiatorNodeName
    );

#ifdef UNICODE
#define SetIScsiInitiatorNodeName SetIScsiInitiatorNodeNameW
#else
#define SetIScsiInitiatorNodeName SetIScsiInitiatorNodeNameA
#endif

ISDSC_STATUS ISDSC_API GetIScsiInitiatorNodeNameW(
     __out_ecount(MAX_ISCSI_NAME_LEN+1) PWCHAR  InitiatorNodeName
    );

ISDSC_STATUS ISDSC_API GetIScsiInitiatorNodeNameA(
     __out_ecount(MAX_ISCSI_NAME_LEN+1) PCHAR  InitiatorNodeName
    );

#ifdef UNICODE
#define GetIScsiInitiatorNodeName GetIScsiInitiatorNodeNameW
#else
#define GetIScsiInitiatorNodeName GetIScsiInitiatorNodeNameA
#endif

ISDSC_STATUS ISDSC_API AddISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API AddISNSServerA(
    IN __in PCHAR Address
    );

#ifdef UNICODE
#define AddISNSServer AddISNSServerW
#else
#define AddISNSServer AddISNSServerA
#endif


ISDSC_STATUS ISDSC_API RemoveISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RemoveISNSServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RemoveISNSServer RemoveISNSServerW
#else
#define RemoveISNSServer RemoveISNSServerA
#endif

ISDSC_STATUS ISDSC_API RefreshISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RefreshISNSServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RefreshISNSServer RefreshISNSServerW
#else
#define RefreshISNSServer RefreshISNSServerA
#endif

ISDSC_STATUS ISDSC_API ReportISNSServerListW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportISNSServerListA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
    );
#ifdef UNICODE
#define ReportISNSServerList ReportISNSServerListW
#else
#define ReportISNSServerList ReportISNSServerListA
#endif



ISDSC_STATUS ISDSC_API GetIScsiSessionListW(
    IN OUT ULONG *BufferSize,
    OUT ULONG *SessionCount,
    OUT OPTIONAL PISCSI_SESSION_INFOW SessionInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiSessionListA(
    IN OUT ULONG *BufferSize,
    OUT ULONG *SessionCount,
    OUT OPTIONAL PISCSI_SESSION_INFOA SessionInfo
    );
#ifdef UNICODE
#define GetIScsiSessionList GetIScsiSessionListW
#else
#define GetIScsiSessionList GetIScsiSessionListA
#endif

ISDSC_STATUS ISDSC_API GetIScsiSessionListEx (
    IN OUT ULONG  *BufferSize,
    OUT ULONG  *SessionCountPtr,
    OUT OPTIONAL PISCSI_SESSION_INFO_EX  SessionInfo
);

ISDSC_STATUS ISDSC_API GetDevicesForIScsiSessionW(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN OUT ULONG *DeviceCount,
    OUT PISCSI_DEVICE_ON_SESSIONW Devices
);

ISDSC_STATUS ISDSC_API GetDevicesForIScsiSessionA(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN OUT ULONG *DeviceCount,
    OUT PISCSI_DEVICE_ON_SESSIONA Devices
);

#ifdef UNICODE
#define GetDevicesForIScsiSession GetDevicesForIScsiSessionW
#else
#define GetDevicesForIScsiSession GetDevicesForIScsiSessionA
#endif

ISDSC_STATUS ISDSC_API SetupPersistentIScsiVolumes(
    );

ISDSC_STATUS ISDSC_API SetupPersistentIScsiDevices(
    );

ISDSC_STATUS ISDSC_API AddPersistentIScsiDeviceW(
    IN __in PWCHAR DevicePath
);

ISDSC_STATUS ISDSC_API AddPersistentIScsiDeviceA(
    IN __in PCHAR DevicePath
);

#ifdef UNICODE
#define AddPersistentIScsiDevice AddPersistentIScsiDeviceW
#else
#define AddPersistentIScsiDevice AddPersistentIScsiDeviceA
#endif

ISDSC_STATUS ISDSC_API RemovePersistentIScsiDeviceW(
    IN __in PWCHAR DevicePath
);

ISDSC_STATUS ISDSC_API RemovePersistentIScsiDeviceA(
    IN __in PCHAR DevicePath
);

#ifdef UNICODE
#define RemovePersistentIScsiDevice RemovePersistentIScsiDeviceW
#else
#define RemovePersistentIScsiDevice RemovePersistentIScsiDeviceA
#endif

ISDSC_STATUS ISDSC_API ClearPersistentIScsiDevices(
);

ISDSC_STATUS ISDSC_API ReportPersistentIScsiDevicesW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
);

ISDSC_STATUS ISDSC_API ReportPersistentIScsiDevicesA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
);

#ifdef UNICODE
#define ReportPersistentIScsiDevices ReportPersistentIScsiDevicesW
#else
#define ReportPersistentIScsiDevices ReportPersistentIScsiDevicesA
#endif

ISDSC_STATUS ISDSC_API ReportIScsiTargetPortalsW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN PWCHAR __in TargetName,
    IN OPTIONAL PUSHORT TargetPortalTag,
    IN OUT PULONG ElementCount,
    OUT PISCSI_TARGET_PORTALW Portals
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetPortalsA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN PCHAR __in TargetName,
    IN OPTIONAL PUSHORT TargetPortalTag,
    IN OUT PULONG ElementCount,
    OUT PISCSI_TARGET_PORTALA Portals
    );

#ifdef UNICODE
#define ReportIScsiTargetPortals ReportIScsiTargetPortalsW
#else
#define ReportIScsiTargetPortals ReportIScsiTargetPortalsA
#endif

ISDSC_STATUS ISDSC_API AddRadiusServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API AddRadiusServerA(
    IN __in PCHAR Address
    );

#ifdef UNICODE
#define AddRadiusServer AddRadiusServerW
#else
#define AddRadiusServer AddRadiusServerA
#endif


ISDSC_STATUS ISDSC_API RemoveRadiusServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RemoveRadiusServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RemoveRadiusServer RemoveRadiusServerW
#else
#define RemoveRadiusServer RemoveRadiusServerA
#endif


ISDSC_STATUS ISDSC_API ReportRadiusServerListW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportRadiusServerListA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
    );
#ifdef UNICODE
#define ReportRadiusServerList ReportRadiusServerListW
#else
#define ReportRadiusServerList ReportRadiusServerListA
#endif

#endif // MIDL_PASS

#endif // ! MOFCOMP_PASS

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\KsGuid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksguid.h

Abstract:

    Define guids for non-C++.

--*/

#define INITGUID
#include <guiddef.h>

#if defined( DEFINE_GUIDEX )
    #undef DEFINE_GUIDEX
#endif
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID __declspec(selectany) name = { STATICGUIDOF(name) }

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\journal.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for journal.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __journal_h__
#define __journal_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IJournalReader_FWD_DEFINED__
#define __IJournalReader_FWD_DEFINED__
typedef interface IJournalReader IJournalReader;
#endif 	/* __IJournalReader_FWD_DEFINED__ */


#ifndef __JournalReader_FWD_DEFINED__
#define __JournalReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class JournalReader JournalReader;
#else
typedef struct JournalReader JournalReader;
#endif /* __cplusplus */

#endif 	/* __JournalReader_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __JournalLib_LIBRARY_DEFINED__
#define __JournalLib_LIBRARY_DEFINED__

/* library JournalLib */
/* [helpstring][version][uuid] */ 

#define GUID_STROKE_TIMESTAMP                    L"{04EA66C4-F33A-461B-B8FE-68070D9C7575}"
#define GUID_STROKE_TIMEID                       L"{050B6BC8-3B7D-4816-8C61-BC7E905B2132}"
#define GUID_HIGHLIGHTER                         L"{9B6267B8-3968-4048-AB74-F490406A2DFA}"
#define GUID_INK_STYLE_BOLD                      L"{E02FB5C1-9693-4312-A434-00DE7F3AD493}"
#define GUID_INK_STYLE_ITALICS                   L"{05253b51-49C6-4A04-8993-64DD9ABD842A}"

EXTERN_C const IID LIBID_JournalLib;

#ifndef __IJournalReader_INTERFACE_DEFINED__
#define __IJournalReader_INTERFACE_DEFINED__

/* interface IJournalReader */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IJournalReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26213A0B-5A6C-4472-923D-9F29EFF608B2")
    IJournalReader : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReadFromStream( 
            /* [in] */ __RPC__in_opt IStream *pJntFile,
            /* [retval][out] */ __RPC__deref_out_opt IStream **ppJntXml) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJournalReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IJournalReader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IJournalReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IJournalReader * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadFromStream )( 
            __RPC__in IJournalReader * This,
            /* [in] */ __RPC__in_opt IStream *pJntFile,
            /* [retval][out] */ __RPC__deref_out_opt IStream **ppJntXml);
        
        END_INTERFACE
    } IJournalReaderVtbl;

    interface IJournalReader
    {
        CONST_VTBL struct IJournalReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJournalReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IJournalReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IJournalReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IJournalReader_ReadFromStream(This,pJntFile,ppJntXml)	\
    ( (This)->lpVtbl -> ReadFromStream(This,pJntFile,ppJntXml) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IJournalReader_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_JournalReader;

#ifdef __cplusplus

class DECLSPEC_UUID("B4124623-FC0E-47CE-BCA9-126A6104ADA1")
JournalReader;
#endif
#endif /* __JournalLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Iwamreg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wamreg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iwamreg_h__
#define __iwamreg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWamAdmin_FWD_DEFINED__
#define __IWamAdmin_FWD_DEFINED__
typedef interface IWamAdmin IWamAdmin;
#endif 	/* __IWamAdmin_FWD_DEFINED__ */


#ifndef __IWamAdmin2_FWD_DEFINED__
#define __IWamAdmin2_FWD_DEFINED__
typedef interface IWamAdmin2 IWamAdmin2;
#endif 	/* __IWamAdmin2_FWD_DEFINED__ */


#ifndef __IIISApplicationAdmin_FWD_DEFINED__
#define __IIISApplicationAdmin_FWD_DEFINED__
typedef interface IIISApplicationAdmin IIISApplicationAdmin;
#endif 	/* __IIISApplicationAdmin_FWD_DEFINED__ */


#ifndef __WamAdmin_FWD_DEFINED__
#define __WamAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class WamAdmin WamAdmin;
#else
typedef struct WamAdmin WamAdmin;
#endif /* __cplusplus */

#endif 	/* __WamAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wamreg_0000_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1997-2001 Microsoft Corporation
                                                                                
Module Name: iwamreg.h
                                                                                
    WAM (Web Application Manager) Interfaces
                                                                                
--*/
#ifndef __WAMREG_IADM__IID
#define __WAMREG_IADM__IID
DEFINE_GUID(IID_IWamAdmin, 0x29822AB7, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(IID_IWamAdmin2, 0x29822AB8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(IID_IIISApplicationAdmin, 0x7C4E1804, 0xE342, 0x483D, 0xA4, 0x3E, 0xA8, 0x50, 0xCF, 0xCC, 0x8D, 0x18);
DEFINE_GUID(IID_IIISApplicationAdmin2, 0xd643717a, 0xfc87, 0x4260, 0x88, 0xac, 0x6c, 0xe3, 0x5f, 0x0e, 0xc1, 0x4e);
DEFINE_GUID(LIBID_WAMREGLib, 0x29822AA8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(CLSID_WamAdmin, 0x61738644, 0xF196, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
#endif //__WAMREG_IADM__IID
#define APPSTATUS_STOPPED	0
#define APPSTATUS_RUNNING	1
#define APPSTATUS_NOTDEFINED	2
typedef /* [public] */ 
enum __MIDL___MIDL_itf_wamreg_0000_0000_0001
    {	eAppRunInProc	= 0,
	eAppRunOutProcIsolated	= ( eAppRunInProc + 1 ) ,
	eAppRunOutProcInDefaultPool	= ( eAppRunOutProcIsolated + 1 ) 
    } 	EAppMode;



extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_0000_v0_0_s_ifspec;

#ifndef __IWamAdmin_INTERFACE_DEFINED__
#define __IWamAdmin_INTERFACE_DEFINED__

/* interface IWamAdmin */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB7-F302-11D0-9953-00C04FD919C1")
    IWamAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDelete( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppUnLoad( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppGetStatus( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDeleteRecoverable( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppRecover( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        END_INTERFACE
    } IWamAdminVtbl;

    interface IWamAdmin
    {
        CONST_VTBL struct IWamAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWamAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWamAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWamAdmin_AppCreate(This,szMDPath,fInProc)	\
    ( (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc) ) 

#define IWamAdmin_AppDelete(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppUnLoad(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    ( (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus) ) 

#define IWamAdmin_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppRecover(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWamAdmin_INTERFACE_DEFINED__ */


#ifndef __IWamAdmin2_INTERFACE_DEFINED__
#define __IWamAdmin2_INTERFACE_DEFINED__

/* interface IWamAdmin2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB8-F302-11D0-9953-00C04FD919C1")
    IWamAdmin2 : public IWamAdmin
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate2( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdmin2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate2 )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode);
        
        END_INTERFACE
    } IWamAdmin2Vtbl;

    interface IWamAdmin2
    {
        CONST_VTBL struct IWamAdmin2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWamAdmin2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWamAdmin2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWamAdmin2_AppCreate(This,szMDPath,fInProc)	\
    ( (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc) ) 

#define IWamAdmin2_AppDelete(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppUnLoad(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    ( (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus) ) 

#define IWamAdmin2_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppRecover(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive) ) 


#define IWamAdmin2_AppCreate2(This,szMDPath,dwAppMode)	\
    ( (This)->lpVtbl -> AppCreate2(This,szMDPath,dwAppMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWamAdmin2_INTERFACE_DEFINED__ */


#ifndef __IIISApplicationAdmin_INTERFACE_DEFINED__
#define __IIISApplicationAdmin_INTERFACE_DEFINED__

/* interface IIISApplicationAdmin */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IIISApplicationAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C4E1804-E342-483D-A43E-A850CFCC8D18")
    IIISApplicationAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode,
            /* [string][unique][in] */ LPCWSTR szAppPoolId,
            /* [in] */ BOOL fCreatePool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteApplication( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumerateApplicationsInPool( 
            /* [string][unique][in] */ LPCWSTR szPool,
            /* [out] */ BSTR *bstrBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RecycleApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessMode( 
            /* [out] */ DWORD *pdwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIISApplicationAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIISApplicationAdmin * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIISApplicationAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIISApplicationAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateApplication )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode,
            /* [string][unique][in] */ LPCWSTR szAppPoolId,
            /* [in] */ BOOL fCreatePool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteApplication )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumerateApplicationsInPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool,
            /* [out] */ BSTR *bstrBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RecycleApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessMode )( 
            IIISApplicationAdmin * This,
            /* [out] */ DWORD *pdwMode);
        
        END_INTERFACE
    } IIISApplicationAdminVtbl;

    interface IIISApplicationAdmin
    {
        CONST_VTBL struct IIISApplicationAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIISApplicationAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIISApplicationAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIISApplicationAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIISApplicationAdmin_CreateApplication(This,szMDPath,dwAppMode,szAppPoolId,fCreatePool)	\
    ( (This)->lpVtbl -> CreateApplication(This,szMDPath,dwAppMode,szAppPoolId,fCreatePool) ) 

#define IIISApplicationAdmin_DeleteApplication(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> DeleteApplication(This,szMDPath,fRecursive) ) 

#define IIISApplicationAdmin_CreateApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> CreateApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_DeleteApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> DeleteApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_EnumerateApplicationsInPool(This,szPool,bstrBuffer)	\
    ( (This)->lpVtbl -> EnumerateApplicationsInPool(This,szPool,bstrBuffer) ) 

#define IIISApplicationAdmin_RecycleApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> RecycleApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_GetProcessMode(This,pdwMode)	\
    ( (This)->lpVtbl -> GetProcessMode(This,pdwMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIISApplicationAdmin_INTERFACE_DEFINED__ */



#ifndef __WAMREGLib_LIBRARY_DEFINED__
#define __WAMREGLib_LIBRARY_DEFINED__

/* library WAMREGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WAMREGLib;

EXTERN_C const CLSID CLSID_WamAdmin;

#ifdef __cplusplus

class DECLSPEC_UUID("61738644-F196-11D0-9953-00C04FD919C1")
WamAdmin;
#endif
#endif /* __WAMREGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ktmtypes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmtypes.h

Abstract:

    Common types for KTM exposed at both the Nt- and Win32-layer.

Revision History:

--*/

// begin_wdm begin_winnt
#ifndef _KTMTYPES_
#define _KTMTYPES_


#ifdef __cplusplus
extern "C" {
#endif


typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

//
// Define the TransactionManager option values
//

#define TRANSACTION_MANAGER_VOLATILE              0x00000001
#define TRANSACTION_MANAGER_COMMIT_DEFAULT        0x00000000
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME  0x00000002
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES   0x00000004
#define TRANSACTION_MANAGER_COMMIT_LOWEST         0x00000008
#define TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY  0x00000010
#define TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS  0x00000020
#define TRANSACTION_MANAGER_MAXIMUM_OPTION        0x0000003F


//
// Define the Transaction option values
//

#define TRANSACTION_DO_NOT_PROMOTE        0x00000001
#define TRANSACTION_MAXIMUM_OPTION        0x00000001


//
// Define the ResourceManager option values
//

#define RESOURCE_MANAGER_VOLATILE            0x00000001
#define RESOURCE_MANAGER_COMMUNICATION       0x00000002
#define RESOURCE_MANAGER_MAXIMUM_OPTION      0x00000003


//
// Define the RegisterProtocol option values
//

#define CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY      0x00000001
#define CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO       0x00000002
#define CRM_PROTOCOL_MAXIMUM_OPTION             0x00000003


//
// Define the Enlistment option values
//

#define ENLISTMENT_SUPERIOR                  0x00000001
#define ENLISTMENT_MAXIMUM_OPTION            0x00000001


typedef ULONG NOTIFICATION_MASK;
#define TRANSACTION_NOTIFY_MASK                 0x3FFFFFFF
#define TRANSACTION_NOTIFY_PREPREPARE           0x00000001
#define TRANSACTION_NOTIFY_PREPARE              0x00000002
#define TRANSACTION_NOTIFY_COMMIT               0x00000004
#define TRANSACTION_NOTIFY_ROLLBACK             0x00000008
#define TRANSACTION_NOTIFY_PREPREPARE_COMPLETE  0x00000010
#define TRANSACTION_NOTIFY_PREPARE_COMPLETE     0x00000020
#define TRANSACTION_NOTIFY_COMMIT_COMPLETE      0x00000040
#define TRANSACTION_NOTIFY_ROLLBACK_COMPLETE    0x00000080
#define TRANSACTION_NOTIFY_RECOVER              0x00000100
#define TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT  0x00000200
#define TRANSACTION_NOTIFY_DELEGATE_COMMIT      0x00000400
#define TRANSACTION_NOTIFY_RECOVER_QUERY        0x00000800
#define TRANSACTION_NOTIFY_ENLIST_PREPREPARE    0x00001000
#define TRANSACTION_NOTIFY_LAST_RECOVER         0x00002000
#define TRANSACTION_NOTIFY_INDOUBT              0x00004000
#define TRANSACTION_NOTIFY_PROPAGATE_PULL       0x00008000
#define TRANSACTION_NOTIFY_PROPAGATE_PUSH       0x00010000
#define TRANSACTION_NOTIFY_MARSHAL              0x00020000
#define TRANSACTION_NOTIFY_ENLIST_MASK          0x00040000
#define TRANSACTION_NOTIFY_RM_DISCONNECTED      0x01000000
#define TRANSACTION_NOTIFY_TM_ONLINE            0x02000000
#define TRANSACTION_NOTIFY_COMMIT_REQUEST       0x04000000
#define TRANSACTION_NOTIFY_PROMOTE              0x08000000
#define TRANSACTION_NOTIFY_PROMOTE_NEW          0x10000000
#define TRANSACTION_NOTIFY_REQUEST_OUTCOME      0x20000000
//
//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.
//  The reason being that KTM does not understand this flag yet. This
//  flag is strictly for the use of filter manager. In fact we mask it
//  out before enlisting in any transaction.
//
#define TRANSACTION_NOTIFY_COMMIT_FINALIZE      0x40000000 

//
// Path to the transaction manager objects in the NT
// object namespace.
//
#define TRANSACTIONMANAGER_OBJECT_PATH  L"\\TransactionManager\\"
#define TRANSACTION_OBJECT_PATH         L"\\Transaction\\"
#define ENLISTMENT_OBJECT_PATH          L"\\Enlistment\\"
#define RESOURCE_MANAGER_OBJECT_PATH    L"\\ResourceManager\\"

//
// The following three defines are here to ease the allocation
// of string buffers which are to contain a fully qualified 
// transaction manager object name, e.g., \Transaction\{GUID}
//
#define TRANSACTIONMANAGER_OBJECT_NAME_LENGTH_IN_BYTES      (sizeof(TRANSACTIONMANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define TRANSACTION_OBJECT_NAME_LENGTH_IN_BYTES      (sizeof(TRANSACTION_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define ENLISTMENT_OBJECT_NAME_LENGTH_IN_BYTES       (sizeof(ENLISTMENT_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define RESOURCE_MANAGER_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(RESOURCE_MANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))

// TODO: warning, duplicated def in tm.h.
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID         TransactionKey;
    ULONG         TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG         ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID   EnlistmentId;
    UOW    UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;

#define TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED 0x1

typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID  UOW;
    GUID  TmIdentity;
    ULONG BufferLength;
    // Bufferlength bytes of Buffer follow
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID  UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;

#define KTM_MARSHAL_BLOB_VERSION_MAJOR 1
#define KTM_MARSHAL_BLOB_VERSION_MINOR 1

#define MAX_TRANSACTION_DESCRIPTION_LENGTH  64
#define MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH  64

typedef struct _KCRM_MARSHAL_HEADER {
    ULONG              VersionMajor;
    ULONG              VersionMinor;
    ULONG              NumProtocols;
    ULONG              Unused;        // for alignment purposes
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, *RESTRICTED_POINTER PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW                UOW;
    GUID               TmIdentity;
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    ULONG              Timeout;
    WCHAR              Description[MAX_TRANSACTION_DESCRIPTION_LENGTH];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, *RESTRICTED_POINTER PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID    ProtocolId;
    __in_range (0,ULONG_MAX/2) ULONG StaticInfoLength;
    ULONG              TransactionIdInfoLength; //??? ProtocolDynamicInfoLength;
    ULONG              Unused1;        // for alignment purposes
    ULONG              Unused2;        // for alignment purposes
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, *RESTRICTED_POINTER PRKCRM_PROTOCOL_BLOB;

#ifdef __cplusplus
}
#endif

#endif // _KTMTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ktmw32.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmw32.h

Abstract:

    Public API include file for the TM subcomponent of the NTOS project

Author:

    Jon Cargille (jcargill) 5-Jun-2001

Revision History:

--*/

#ifndef _KTMUSER_
#define _KTMUSER_


#ifdef __cplusplus
extern "C" {
#endif


//
// Win32-level transaction manager API calls
//

HANDLE
APIENTRY
CreateTransaction (
    IN LPSECURITY_ATTRIBUTES lpTransactionAttributes OPTIONAL,
    IN LPGUID UOW OPTIONAL,
    IN DWORD CreateOptions OPTIONAL,
    IN DWORD IsolationLevel OPTIONAL,
    IN DWORD IsolationFlags OPTIONAL,
    IN DWORD Timeout OPTIONAL,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
OpenTransaction (
    IN DWORD dwDesiredAccess,
    IN LPGUID TransactionId
    );

BOOL
APIENTRY
CommitTransaction (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
CommitTransactionAsync (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
RollbackTransaction (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
RollbackTransactionAsync (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
GetTransactionId (
    IN HANDLE TransactionHandle,
    OUT LPGUID TransactionId
    );


BOOL
APIENTRY
GetTransactionInformation (
    IN HANDLE TransactionHandle,
    OUT PDWORD Outcome OPTIONAL,
    OUT PDWORD IsolationLevel OPTIONAL,
    OUT PDWORD IsolationFlags OPTIONAL,
    OUT PDWORD Timeout OPTIONAL,
    __in DWORD BufferLength,
    __out_ecount_part_opt(BufferLength, return + 1) LPWSTR Description
    );

BOOL
APIENTRY
SetTransactionInformation (
    IN HANDLE TransactionHandle,
    IN DWORD IsolationLevel OPTIONAL,
    IN DWORD IsolationFlags OPTIONAL,
    IN DWORD Timeout OPTIONAL,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
CreateTransactionManager (
    IN LPSECURITY_ATTRIBUTES lpTransactionAttributes OPTIONAL,
    __in LPWSTR LogFileName,
    IN ULONG CreateOptions OPTIONAL,
    IN ULONG CommitStrength OPTIONAL
    );

HANDLE
APIENTRY
OpenTransactionManager (
    __in LPWSTR LogFileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions OPTIONAL
    );

HANDLE
APIENTRY
OpenTransactionManagerById (
    __in LPGUID TransactionManagerId,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions OPTIONAL
    );

BOOL
APIENTRY
RenameTransactionManager (
    __in LPWSTR LogFileName,
    IN LPGUID ExistingTransactionManagerGuid
    );

BOOL
APIENTRY
RollforwardTransactionManager (
    IN HANDLE TransactionManagerHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
RecoverTransactionManager (
    IN HANDLE TransactionManagerHandle
    );

BOOL
GetCurrentClockTransactionManager(
    IN HANDLE TransactionManagerHandle,
    OUT PLARGE_INTEGER TmVirtualClock
    );

BOOL
GetTransactionManagerId(
    IN HANDLE TransactionManagerHandle,
    OUT LPGUID TransactionManagerId
    );

HANDLE
APIENTRY
CreateResourceManager (
    IN LPSECURITY_ATTRIBUTES lpResourceManagerAttributes OPTIONAL,
    IN LPGUID ResourceManagerId,
    IN DWORD CreateOptions OPTIONAL,
    IN HANDLE TmHandle,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
OpenResourceManager (
    IN DWORD dwDesiredAccess,
    IN HANDLE TmHandle,
    IN LPGUID ResourceManagerId
    );

BOOL
APIENTRY
RecoverResourceManager (
    IN HANDLE ResourceManagerHandle
    );

BOOL
APIENTRY
GetNotificationResourceManager (
    IN  HANDLE                          ResourceManagerHandle,
    OUT PTRANSACTION_NOTIFICATION       TransactionNotification,
    IN  ULONG                           NotificationLength,
    IN  DWORD                           dwMilliseconds OPTIONAL,
    OUT PULONG                          ReturnLength OPTIONAL
    );

BOOL
APIENTRY
GetNotificationResourceManagerAsync (
    IN  HANDLE                        ResourceManagerHandle,
    OUT PTRANSACTION_NOTIFICATION     TransactionNotification,
    IN  ULONG                         TransactionNotificationLength,
    OUT PULONG                        ReturnLength,
    IN  LPOVERLAPPED                  lpOverlapped
    );
    
BOOL
APIENTRY
SetResourceManagerCompletionPort(
    IN HANDLE    ResourceManagerHandle,
    IN HANDLE    IoCompletionPortHandle,
    IN ULONG_PTR CompletionKey
    );

HANDLE
APIENTRY
CreateEnlistment (
    IN LPSECURITY_ATTRIBUTES lpEnlistmentAttributes OPTIONAL,
    IN HANDLE            ResourceManagerHandle,
    IN HANDLE            TransactionHandle,
    IN NOTIFICATION_MASK NotificationMask,
    IN DWORD             CreateOptions OPTIONAL,
    IN PVOID             EnlistmentKey OPTIONAL
    );

HANDLE
APIENTRY
OpenEnlistment (
    IN DWORD              dwDesiredAccess,
    IN HANDLE             ResourceManagerHandle,
    IN LPGUID             EnlistmentId
    );


BOOL
APIENTRY
RecoverEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PVOID EnlistmentKey OPTIONAL
    );


BOOL
APIENTRY
GetEnlistmentRecoveryInformation (
    IN  HANDLE EnlistmentHandle,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG BufferUsed OPTIONAL
    );

BOOL
APIENTRY
GetEnlistmentId (
    IN HANDLE EnlistmentHandle,
    OUT LPGUID EnlistmentId
    );

BOOL
APIENTRY
SetEnlistmentRecoveryInformation (
    IN HANDLE EnlistmentHandle,
    IN ULONG  BufferSize,
    IN PVOID  Buffer
    );

BOOL
APIENTRY
PrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
PrePrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
CommitEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
RollbackEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
PrePrepareComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
PrepareComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
ReadOnlyEnlistment (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
CommitComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
RollbackComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
SinglePhaseReject (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

#ifdef __cplusplus
}
#endif


#endif // _KTMUSER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\KnownFolders.h ===
#pragma once

#ifdef DEFINE_KNOWN_FOLDER
#undef DEFINE_KNOWN_FOLDER
#endif


#ifdef INITGUID
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name
#endif // INITGUID

// legacy CSIDL value: CSIDL_NETWORK
// display name: "Network"
// legacy display name: "My Network Places"
// default path: 
// {D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}
DEFINE_KNOWN_FOLDER(FOLDERID_NetworkFolder, 0xD20BEEC4, 0x5CA8, 0x4905, 0xAE, 0x3B, 0xBF, 0x25, 0x1E, 0xA0, 0x9B, 0x53);

// {0AC0837C-BBF8-452A-850D-79D08E667CA7}
DEFINE_KNOWN_FOLDER(FOLDERID_ComputerFolder,   0x0AC0837C, 0xBBF8, 0x452A, 0x85, 0x0D, 0x79, 0xD0, 0x8E, 0x66, 0x7C, 0xA7);

// {4D9F7874-4E0C-4904-967B-40B0D20C3E4B}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetFolder,      0x4D9F7874, 0x4E0C, 0x4904, 0x96, 0x7B, 0x40, 0xB0, 0xD2, 0x0C, 0x3E, 0x4B);

// {82A74AEB-AEB4-465C-A014-D097EE346D63}
DEFINE_KNOWN_FOLDER(FOLDERID_ControlPanelFolder,  0x82A74AEB, 0xAEB4, 0x465C, 0xA0, 0x14, 0xD0, 0x97, 0xEE, 0x34, 0x6D, 0x63);

// {76FC4E2D-D6AD-4519-A663-37BD56068185}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintersFolder,      0x76FC4E2D, 0xD6AD, 0x4519, 0xA6, 0x63, 0x37, 0xBD, 0x56, 0x06, 0x81, 0x85);

// {43668BF8-C14E-49B2-97C9-747784D784B7}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncManagerFolder,       0x43668BF8, 0xC14E, 0x49B2, 0x97, 0xC9, 0x74, 0x77, 0x84, 0xD7, 0x84, 0xB7);

// {0F214138-B1D3-4a90-BBA9-27CBC0C5389A}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncSetupFolder, 0xf214138, 0xb1d3, 0x4a90, 0xbb, 0xa9, 0x27, 0xcb, 0xc0, 0xc5, 0x38, 0x9a);

// {4bfefb45-347d-4006-a5be-ac0cb0567192}
DEFINE_KNOWN_FOLDER(FOLDERID_ConflictFolder,      0x4bfefb45, 0x347d, 0x4006, 0xa5, 0xbe, 0xac, 0x0c, 0xb0, 0x56, 0x71, 0x92);

// {289a9a43-be44-4057-a41b-587a76d7e7f9}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncResultsFolder,     0x289a9a43, 0xbe44, 0x4057, 0xa4, 0x1b, 0x58, 0x7a, 0x76, 0xd7, 0xe7, 0xf9);

// {B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}
DEFINE_KNOWN_FOLDER(FOLDERID_RecycleBinFolder,    0xB7534046, 0x3ECB, 0x4C18, 0xBE, 0x4E, 0x64, 0xCD, 0x4C, 0xB7, 0xD6, 0xAC);

// {6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}
DEFINE_KNOWN_FOLDER(FOLDERID_ConnectionsFolder,   0x6F0CD92B, 0x2E97, 0x45D1, 0x88, 0xFF, 0xB0, 0xD1, 0x86, 0xB8, 0xDE, 0xDD);

// {FD228CB7-AE11-4AE3-864C-16F3910AB8FE}
DEFINE_KNOWN_FOLDER(FOLDERID_Fonts,               0xFD228CB7, 0xAE11, 0x4AE3, 0x86, 0x4C, 0x16, 0xF3, 0x91, 0x0A, 0xB8, 0xFE);

// display name:        "Desktop"
// default path:        "C:\Users\<UserName>\Desktop"
// legacy default path: "C:\Documents and Settings\<userName>\Desktop"
// legacy CSIDL value:  CSIDL_DESKTOP
// {B4BFCC3A-DB2C-424C-B029-7FE99A87C641}
DEFINE_KNOWN_FOLDER(FOLDERID_Desktop,             0xB4BFCC3A, 0xDB2C, 0x424C, 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41);

// {B97D20BB-F46A-4C97-BA10-5E3608430854}
DEFINE_KNOWN_FOLDER(FOLDERID_Startup,             0xB97D20BB, 0xF46A, 0x4C97, 0xBA, 0x10, 0x5E, 0x36, 0x08, 0x43, 0x08, 0x54);

// {A77F5D77-2E2B-44C3-A6A2-ABA601054A51}
DEFINE_KNOWN_FOLDER(FOLDERID_Programs,            0xA77F5D77, 0x2E2B, 0x44C3, 0xA6, 0xA2, 0xAB, 0xA6, 0x01, 0x05, 0x4A, 0x51);

// {625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}
DEFINE_KNOWN_FOLDER(FOLDERID_StartMenu,           0x625B53C3, 0xAB48, 0x4EC1, 0xBA, 0x1F, 0xA1, 0xEF, 0x41, 0x46, 0xFC, 0x19);

// {AE50C081-EBD2-438A-8655-8A092E34987A}
DEFINE_KNOWN_FOLDER(FOLDERID_Recent,              0xAE50C081, 0xEBD2, 0x438A, 0x86, 0x55, 0x8A, 0x09, 0x2E, 0x34, 0x98, 0x7A);

// {8983036C-27C0-404B-8F08-102D10DCFD74}
DEFINE_KNOWN_FOLDER(FOLDERID_SendTo,              0x8983036C, 0x27C0, 0x404B, 0x8F, 0x08, 0x10, 0x2D, 0x10, 0xDC, 0xFD, 0x74);

// {FDD39AD0-238F-46AF-ADB4-6C85480369C7}
DEFINE_KNOWN_FOLDER(FOLDERID_Documents,           0xFDD39AD0, 0x238F, 0x46AF, 0xAD, 0xB4, 0x6C, 0x85, 0x48, 0x03, 0x69, 0xC7);

// {1777F761-68AD-4D8A-87BD-30B759FA33DD}
DEFINE_KNOWN_FOLDER(FOLDERID_Favorites,           0x1777F761, 0x68AD, 0x4D8A, 0x87, 0xBD, 0x30, 0xB7, 0x59, 0xFA, 0x33, 0xDD);

// {C5ABBF53-E17F-4121-8900-86626FC2C973}
DEFINE_KNOWN_FOLDER(FOLDERID_NetHood,             0xC5ABBF53, 0xE17F, 0x4121, 0x89, 0x00, 0x86, 0x62, 0x6F, 0xC2, 0xC9, 0x73);

// {9274BD8D-CFD1-41C3-B35E-B13F55A758F4}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintHood,           0x9274BD8D, 0xCFD1, 0x41C3, 0xB3, 0x5E, 0xB1, 0x3F, 0x55, 0xA7, 0x58, 0xF4);

// {A63293E8-664E-48DB-A079-DF759E0509F7}
DEFINE_KNOWN_FOLDER(FOLDERID_Templates,           0xA63293E8, 0x664E, 0x48DB, 0xA0, 0x79, 0xDF, 0x75, 0x9E, 0x05, 0x09, 0xF7);

// {82A5EA35-D9CD-47C5-9629-E15D2F714E6E}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartup,       0x82A5EA35, 0xD9CD, 0x47C5, 0x96, 0x29, 0xE1, 0x5D, 0x2F, 0x71, 0x4E, 0x6E);

// {0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonPrograms,      0x0139D44E, 0x6AFE, 0x49F2, 0x86, 0x90, 0x3D, 0xAF, 0xCA, 0xE6, 0xFF, 0xB8);

// {A4115719-D62E-491D-AA7C-E74B8BE3B067}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartMenu,     0xA4115719, 0xD62E, 0x491D, 0xAA, 0x7C, 0xE7, 0x4B, 0x8B, 0xE3, 0xB0, 0x67);

// {C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDesktop,       0xC4AA340D, 0xF20F, 0x4863, 0xAF, 0xEF, 0xF8, 0x7E, 0xF2, 0xE6, 0xBA, 0x25);

// {62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramData,         0x62AB5D82, 0xFDC1, 0x4DC3, 0xA9, 0xDD, 0x07, 0x0D, 0x1D, 0x49, 0x5D, 0x97);

// {B94237E7-57AC-4347-9151-B08C6C32D1F7}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonTemplates,     0xB94237E7, 0x57AC, 0x4347, 0x91, 0x51, 0xB0, 0x8C, 0x6C, 0x32, 0xD1, 0xF7);

// {ED4824AF-DCE4-45A8-81E2-FC7965083634}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDocuments,     0xED4824AF, 0xDCE4, 0x45A8, 0x81, 0xE2, 0xFC, 0x79, 0x65, 0x08, 0x36, 0x34);

// {3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}
DEFINE_KNOWN_FOLDER(FOLDERID_RoamingAppData,      0x3EB685DB, 0x65F9, 0x4CF6, 0xA0, 0x3A, 0xE3, 0xEF, 0x65, 0x72, 0x9F, 0x3D);

// {F1B32785-6FBA-4FCF-9D55-7B8E7F157091}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppData,        0xF1B32785, 0x6FBA, 0x4FCF, 0x9D, 0x55, 0x7B, 0x8E, 0x7F, 0x15, 0x70, 0x91);

// {A520A1A4-1780-4FF6-BD18-167343C5AF16}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppDataLow,     0xA520A1A4, 0x1780, 0x4FF6, 0xBD, 0x18, 0x16, 0x73, 0x43, 0xC5, 0xAF, 0x16);

// {352481E8-33BE-4251-BA85-6007CAEDCF9D}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetCache,       0x352481E8, 0x33BE, 0x4251, 0xBA, 0x85, 0x60, 0x07, 0xCA, 0xED, 0xCF, 0x9D);

// {2B0F765D-C0E9-4171-908E-08A611B84FF6}
DEFINE_KNOWN_FOLDER(FOLDERID_Cookies,             0x2B0F765D, 0xC0E9, 0x4171, 0x90, 0x8E, 0x08, 0xA6, 0x11, 0xB8, 0x4F, 0xF6);

// {D9DC8A3B-B784-432E-A781-5A1130A75963}
DEFINE_KNOWN_FOLDER(FOLDERID_History,             0xD9DC8A3B, 0xB784, 0x432E, 0xA7, 0x81, 0x5A, 0x11, 0x30, 0xA7, 0x59, 0x63);

// {1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}
DEFINE_KNOWN_FOLDER(FOLDERID_System,              0x1AC14E77, 0x02E7, 0x4E5D, 0xB7, 0x44, 0x2E, 0xB1, 0xAE, 0x51, 0x98, 0xB7);

// {D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}
DEFINE_KNOWN_FOLDER(FOLDERID_SystemX86,           0xD65231B0, 0xB2F1, 0x4857, 0xA4, 0xCE, 0xA8, 0xE7, 0xC6, 0xEA, 0x7D, 0x27);

// {F38BF404-1D43-42F2-9305-67DE0B28FC23}
DEFINE_KNOWN_FOLDER(FOLDERID_Windows,             0xF38BF404, 0x1D43, 0x42F2, 0x93, 0x05, 0x67, 0xDE, 0x0B, 0x28, 0xFC, 0x23);

// {5E6C858F-0E22-4760-9AFE-EA3317B67173}
DEFINE_KNOWN_FOLDER(FOLDERID_Profile,             0x5E6C858F, 0x0E22, 0x4760, 0x9A, 0xFE, 0xEA, 0x33, 0x17, 0xB6, 0x71, 0x73);

// {33E28130-4E1E-4676-835A-98395C3BC3BB}
DEFINE_KNOWN_FOLDER(FOLDERID_Pictures,            0x33E28130, 0x4E1E, 0x4676, 0x83, 0x5A, 0x98, 0x39, 0x5C, 0x3B, 0xC3, 0xBB);

// {7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX86,     0x7C5A40EF, 0xA0FB, 0x4BFC, 0x87, 0x4A, 0xC0, 0xF2, 0xE0, 0xB9, 0xFA, 0x8E);

// {DE974D24-D9C6-4D3E-BF91-F4455120B917}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX86, 0xDE974D24, 0xD9C6, 0x4D3E, 0xBF, 0x91, 0xF4, 0x45, 0x51, 0x20, 0xB9, 0x17);

// {6D809377-6AF0-444b-8957-A3773F02200E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX64,     0x6d809377, 0x6af0, 0x444b, 0x89, 0x57, 0xa3, 0x77, 0x3f, 0x02, 0x20, 0x0e );

// {6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX64, 0x6365d5a7, 0xf0d, 0x45e5, 0x87, 0xf6, 0xd, 0xa5, 0x6b, 0x6a, 0x4f, 0x7d );

// {905e63b6-c1bf-494e-b29c-65b732d3d21a}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFiles,        0x905e63b6, 0xc1bf, 0x494e, 0xb2, 0x9c, 0x65, 0xb7, 0x32, 0xd3, 0xd2, 0x1a);

// {F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommon,  0xF7F1ED05, 0x9F6D, 0x47A2, 0xAA, 0xAE, 0x29, 0xD3, 0x17, 0xC6, 0xF0, 0x66);

// {5cd7aee2-2219-4a67-b85d-6c9ce15660cb}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProgramFiles,    0x5cd7aee2, 0x2219, 0x4a67, 0xb8, 0x5d, 0x6c, 0x9c, 0xe1, 0x56, 0x60, 0xcb);

// {bcbd3057-ca5c-4622-b42d-bc56db0ae516}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProgramFilesCommon, 0xbcbd3057, 0xca5c, 0x4622, 0xb4, 0x2d, 0xbc, 0x56, 0xdb, 0x0a, 0xe5, 0x16);

// {724EF170-A42D-4FEF-9F26-B60E846FBA4F}
DEFINE_KNOWN_FOLDER(FOLDERID_AdminTools,          0x724EF170, 0xA42D, 0x4FEF, 0x9F, 0x26, 0xB6, 0x0E, 0x84, 0x6F, 0xBA, 0x4F);

// {D0384E7D-BAC3-4797-8F14-CBA229B392B5}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonAdminTools,    0xD0384E7D, 0xBAC3, 0x4797, 0x8F, 0x14, 0xCB, 0xA2, 0x29, 0xB3, 0x92, 0xB5);

// {4BD8D571-6D19-48D3-BE97-422220080E43}
DEFINE_KNOWN_FOLDER(FOLDERID_Music,               0x4BD8D571, 0x6D19, 0x48D3, 0xBE, 0x97, 0x42, 0x22, 0x20, 0x08, 0x0E, 0x43);

// {18989B1D-99B5-455B-841C-AB7C74E4DDFC}
DEFINE_KNOWN_FOLDER(FOLDERID_Videos,              0x18989B1D, 0x99B5, 0x455B, 0x84, 0x1C, 0xAB, 0x7C, 0x74, 0xE4, 0xDD, 0xFC);

// {C870044B-F49E-4126-A9C3-B52A1FF411E8}
DEFINE_KNOWN_FOLDER(FOLDERID_Ringtones,           0xC870044B, 0xF49E, 0x4126, 0xA9, 0xC3, 0xB5, 0x2A, 0x1F, 0xF4, 0x11, 0xE8);

// {B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicPictures,      0xB6EBFB86, 0x6907, 0x413C, 0x9A, 0xF7, 0x4F, 0xC2, 0xAB, 0xF0, 0x7C, 0xC5);

// {3214FAB5-9757-4298-BB61-92A9DEAA44FF}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicMusic,         0x3214FAB5, 0x9757, 0x4298, 0xBB, 0x61, 0x92, 0xA9, 0xDE, 0xAA, 0x44, 0xFF);

// {2400183A-6185-49FB-A2D8-4A392A602BA3}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicVideos,        0x2400183A, 0x6185, 0x49FB, 0xA2, 0xD8, 0x4A, 0x39, 0x2A, 0x60, 0x2B, 0xA3);

// {E555AB60-153B-4D17-9F04-A5FE99FC15EC}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicRingtones,     0xE555AB60, 0x153B, 0x4D17, 0x9F, 0x04, 0xA5, 0xFE, 0x99, 0xFC, 0x15, 0xEC);

// {8AD10C31-2ADB-4296-A8F7-E4701232C972}
DEFINE_KNOWN_FOLDER(FOLDERID_ResourceDir,         0x8AD10C31, 0x2ADB, 0x4296, 0xA8, 0xF7, 0xE4, 0x70, 0x12, 0x32, 0xC9, 0x72);

// {2A00375E-224C-49DE-B8D1-440DF7EF3DDC}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalizedResourcesDir, 0x2A00375E, 0x224C, 0x49DE, 0xB8, 0xD1, 0x44, 0x0D, 0xF7, 0xEF, 0x3D, 0xDC);

// {C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonOEMLinks,      0xC1BAE2D0, 0x10DF, 0x4334, 0xBE, 0xDD, 0x7A, 0xA2, 0x0B, 0x22, 0x7A, 0x9D);

// {9E52AB10-F80D-49DF-ACB8-4330F5687855}
DEFINE_KNOWN_FOLDER(FOLDERID_CDBurning,           0x9E52AB10, 0xF80D, 0x49DF, 0xAC, 0xB8, 0x43, 0x30, 0xF5, 0x68, 0x78, 0x55);

// {0762D272-C50A-4BB0-A382-697DCD729B80}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProfiles,        0x0762D272, 0xC50A, 0x4BB0, 0xA3, 0x82, 0x69, 0x7D, 0xCD, 0x72, 0x9B, 0x80);

// {DE92C1C7-837F-4F69-A3BB-86E631204A23}
DEFINE_KNOWN_FOLDER(FOLDERID_Playlists,           0xDE92C1C7, 0x837F, 0x4F69, 0xA3, 0xBB, 0x86, 0xE6, 0x31, 0x20, 0x4A, 0x23);

// {15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePlaylists,     0x15CA69B3, 0x30EE, 0x49C1, 0xAC, 0xE1, 0x6B, 0x5E, 0xC3, 0x72, 0xAF, 0xB5);

// {B250C668-F57D-4EE1-A63C-290EE7D1AA1F}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleMusic,         0xB250C668, 0xF57D, 0x4EE1, 0xA6, 0x3C, 0x29, 0x0E, 0xE7, 0xD1, 0xAA, 0x1F);

// {C4900540-2379-4C75-844B-64E6FAF8716B}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePictures,      0xC4900540, 0x2379, 0x4C75, 0x84, 0x4B, 0x64, 0xE6, 0xFA, 0xF8, 0x71, 0x6B);

// {859EAD94-2E85-48AD-A71A-0969CB56A6CD}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleVideos,        0x859EAD94, 0x2E85, 0x48AD, 0xA7, 0x1A, 0x09, 0x69, 0xCB, 0x56, 0xA6, 0xCD);

// {69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}
DEFINE_KNOWN_FOLDER(FOLDERID_PhotoAlbums,         0x69D2CF90, 0xFC33, 0x4FB7, 0x9A, 0x0C, 0xEB, 0xB0, 0xF0, 0xFC, 0xB4, 0x3C);

// {DFDF76A2-C82A-4D63-906A-5644AC457385}
DEFINE_KNOWN_FOLDER(FOLDERID_Public,              0xDFDF76A2, 0xC82A, 0x4D63, 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85);

// {df7266ac-9274-4867-8d55-3bd661de872d}
DEFINE_KNOWN_FOLDER(FOLDERID_ChangeRemovePrograms,0xdf7266ac, 0x9274, 0x4867, 0x8d, 0x55, 0x3b, 0xd6, 0x61, 0xde, 0x87, 0x2d);

// {a305ce99-f527-492b-8b1a-7e76fa98d6e4}
DEFINE_KNOWN_FOLDER(FOLDERID_AppUpdates,          0xa305ce99, 0xf527, 0x492b, 0x8b, 0x1a, 0x7e, 0x76, 0xfa, 0x98, 0xd6, 0xe4);

// {de61d971-5ebc-4f02-a3a9-6c82895e5c04}
DEFINE_KNOWN_FOLDER(FOLDERID_AddNewPrograms,      0xde61d971, 0x5ebc, 0x4f02, 0xa3, 0xa9, 0x6c, 0x82, 0x89, 0x5e, 0x5c, 0x04);

// {374DE290-123F-4565-9164-39C4925E467B}
DEFINE_KNOWN_FOLDER(FOLDERID_Downloads,           0x374de290, 0x123f, 0x4565, 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b);

// {3D644C9B-1FB8-4f30-9B45-F670235F79C0}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDownloads,     0x3d644c9b, 0x1fb8, 0x4f30, 0x9b, 0x45, 0xf6, 0x70, 0x23, 0x5f, 0x79, 0xc0);

// {7d1d3a04-debb-4115-95cf-2f29da2920da}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedSearches,       0x7d1d3a04, 0xdebb, 0x4115, 0x95, 0xcf, 0x2f, 0x29, 0xda, 0x29, 0x20, 0xda);

// {52a4f021-7b75-48a9-9f6b-4b87a210bc8f}
DEFINE_KNOWN_FOLDER(FOLDERID_QuickLaunch,         0x52a4f021, 0x7b75, 0x48a9, 0x9f, 0x6b, 0x4b, 0x87, 0xa2, 0x10, 0xbc, 0x8f);

// {56784854-C6CB-462b-8169-88E350ACB882}
DEFINE_KNOWN_FOLDER(FOLDERID_Contacts,            0x56784854, 0xc6cb, 0x462b, 0x81, 0x69, 0x88, 0xe3, 0x50, 0xac, 0xb8, 0x82);

// {A75D362E-50FC-4fb7-AC2C-A8BEAA314493}
DEFINE_GUID(FOLDERID_SidebarParts,                0xa75d362e, 0x50fc, 0x4fb7, 0xac, 0x2c, 0xa8, 0xbe, 0xaa, 0x31, 0x44, 0x93);

// {7B396E54-9EC5-4300-BE0A-2482EBAE1A26}
DEFINE_GUID(FOLDERID_SidebarDefaultParts,         0x7b396e54, 0x9ec5, 0x4300, 0xbe, 0xa, 0x24, 0x82, 0xeb, 0xae, 0x1a, 0x26);

// {DEBF2536-E1A8-4c59-B6A2-414586476AEA}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicGameTasks,     0xdebf2536, 0xe1a8, 0x4c59, 0xb6, 0xa2, 0x41, 0x45, 0x86, 0x47, 0x6a, 0xea);

// {054FAE61-4DD8-4787-80B6-090220C4B700}
DEFINE_KNOWN_FOLDER(FOLDERID_GameTasks,           0x54fae61, 0x4dd8, 0x4787, 0x80, 0xb6, 0x9, 0x2, 0x20, 0xc4, 0xb7, 0x0);

// {4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedGames,          0x4c5c32ff, 0xbb9d, 0x43b0, 0xb5, 0xb4, 0x2d, 0x72, 0xe5, 0x4e, 0xaa, 0xa4);

// {CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}
DEFINE_KNOWN_FOLDER(FOLDERID_Games,               0xcac52c1a, 0xb53d, 0x4edc, 0x92, 0xd7, 0x6b, 0x2e, 0x8a, 0xc1, 0x94, 0x34);

// {98ec0e18-2098-4d44-8644-66979315a281}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_MAPI,         0x98ec0e18, 0x2098, 0x4d44, 0x86, 0x44, 0x66, 0x97, 0x93, 0x15, 0xa2, 0x81);

// {ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_CSC,          0xee32e446, 0x31ca, 0x4aba, 0x81, 0x4f, 0xa5, 0xeb, 0xd2, 0xfd, 0x6d, 0x5e);

// {bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}
DEFINE_KNOWN_FOLDER(FOLDERID_Links,               0xbfb9d5e0, 0xc6a9, 0x404c, 0xb2, 0xb2, 0xae, 0x6d, 0xb6, 0xaf, 0x49, 0x68);

// {f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}
DEFINE_KNOWN_FOLDER(FOLDERID_UsersFiles,          0xf3ce0f7c, 0x4901, 0x4acc, 0x86, 0x48, 0xd5, 0xd4, 0x4b, 0x04, 0xef, 0x8f);

// {A302545D-DEFF-464b-ABE8-61C8648D939B}
DEFINE_KNOWN_FOLDER(FOLDERID_UsersLibraries,      0xa302545d, 0xdeff, 0x464b, 0xab, 0xe8, 0x61, 0xc8, 0x64, 0x8d, 0x93, 0x9b);

// {190337d1-b8ca-4121-a639-6d472d16972a}
DEFINE_KNOWN_FOLDER(FOLDERID_SearchHome,          0x190337d1, 0xb8ca, 0x4121, 0xa6, 0x39, 0x6d, 0x47, 0x2d, 0x16, 0x97, 0x2a);

// {2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}
DEFINE_KNOWN_FOLDER(FOLDERID_OriginalImages,      0x2C36C0AA, 0x5812, 0x4b87, 0xbf, 0xd0, 0x4c, 0xd0, 0xdf, 0xb1, 0x9b, 0x39);

// {7b0db17d-9cd2-4a93-9733-46cc89022e7c}
DEFINE_KNOWN_FOLDER(FOLDERID_DocumentsLibrary,    0x7b0db17d, 0x9cd2, 0x4a93, 0x97, 0x33, 0x46, 0xcc, 0x89, 0x02, 0x2e, 0x7c);

// {2112AB0A-C86A-4ffe-A368-0DE96E47012E}
DEFINE_KNOWN_FOLDER(FOLDERID_MusicLibrary,        0x2112ab0a, 0xc86a, 0x4ffe, 0xa3, 0x68, 0xd, 0xe9, 0x6e, 0x47, 0x1, 0x2e);

// {A990AE9F-A03B-4e80-94BC-9912D7504104}
DEFINE_KNOWN_FOLDER(FOLDERID_PicturesLibrary,     0xa990ae9f, 0xa03b, 0x4e80, 0x94, 0xbc, 0x99, 0x12, 0xd7, 0x50, 0x41, 0x4);

// {491E922F-5643-4af4-A7EB-4E7A138D8174}
DEFINE_KNOWN_FOLDER(FOLDERID_VideosLibrary,       0x491e922f, 0x5643, 0x4af4, 0xa7, 0xeb, 0x4e, 0x7a, 0x13, 0x8d, 0x81, 0x74);

// {1A6FDBA2-F42D-4358-A798-B74D745926C5}
DEFINE_KNOWN_FOLDER(FOLDERID_RecordedTVLibrary,   0x1a6fdba2, 0xf42d, 0x4358, 0xa7, 0x98, 0xb7, 0x4d, 0x74, 0x59, 0x26, 0xc5);

// {52528A6B-B9E3-4add-B60D-588C2DBA842D}
DEFINE_KNOWN_FOLDER(FOLDERID_HomeGroup,           0x52528a6b, 0xb9e3, 0x4add, 0xb6, 0xd, 0x58, 0x8c, 0x2d, 0xba, 0x84, 0x2d);

// {5CE4A5E9-E4EB-479D-B89F-130C02886155}
DEFINE_KNOWN_FOLDER(FOLDERID_DeviceMetadataStore, 0x5ce4a5e9, 0xe4eb, 0x479d, 0xb8, 0x9f, 0x13, 0x0c, 0x02, 0x88, 0x61, 0x55);

// {1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}
DEFINE_KNOWN_FOLDER(FOLDERID_Libraries,           0x1b3ea5dc, 0xb587, 0x4786, 0xb4, 0xef, 0xbd, 0x1d, 0xc3, 0x32, 0xae, 0xae);

// {48daf80b-e6cf-4f4e-b800-0e69d84ee384}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicLibraries,     0x48daf80b, 0xe6cf, 0x4f4e, 0xb8, 0x00, 0x0e, 0x69, 0xd8, 0x4e, 0xe3, 0x84);

// {9e3995ab-1f9c-4f13-b827-48b24b6c7174}
DEFINE_KNOWN_FOLDER(FOLDERID_UserPinned,          0x9e3995ab, 0x1f9c, 0x4f13, 0xb8, 0x27, 0x48, 0xb2, 0x4b, 0x6c, 0x71, 0x74);

// {bcb5256f-79f6-4cee-b725-dc34e402fd46}
DEFINE_KNOWN_FOLDER(FOLDERID_ImplicitAppShortcuts,0xbcb5256f, 0x79f6, 0x4cee, 0xb7, 0x25, 0xdc, 0x34, 0xe4, 0x2, 0xfd, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ksopmapi.h ===
//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media Foundation
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// ksopmapi.h - definitions for kernel mode code OPM communication
//
//*@@@---@@@@******************************************************************

#ifndef _KSOPMAPI_
#define _KSOPMAPI_

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif


#if (WINVER >= _WIN32_WINNT_WIN7)

//=============================================================================
// Description:
//
//  Ks Property set to use with AVStram drivers
// KSPROPSETID_OPMVideoOutput {06F414BB-F43A-4fe2-A566-774B4C81F0DB}
#ifdef DEFINE_GUIDSTRUCT
#define STATIC_KSPROPSETID_OPMVideoOutput \
0x6f414bb, 0xf43a, 0x4fe2, 0xa5, 0x66, 0x77, 0x4b, 0x4c, 0x81, 0xf0, 0xdb                         
DEFINE_GUIDSTRUCT("06F414BB-F43A-4fe2-A566-774B4C81F0DB", KSPROPSETID_OPMVideoOutput);          
#define KSPROPSETID_OPMVideoOutput DEFINE_GUIDNAMED(KSPROPSETID_OPMVideoOutput)                   
#endif
                                                                                                  
typedef enum
{                                                                                    
    //  Output is OPM_RANDOM_NUMBER followed by certifiate                                        
    KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION = 0,                                              
                                                                                                  
    //  Input OPM_ENCRYPTED_INITIALIZATION_PARAMETERS                                             
    //  Output OPM_STANDARD_INFORMATION                                                           
    KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION = 1,                                             
                                                                                                  
    //  Input is OPM_GET_INFO_PARAMETERS, output is OPM_REQUESTED_INFORMATION                     
    //  Use KsMethod - both input and output in the buffer (not after the KSMETHOD structure)     
    KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION = 2                                                    
} KSMETHOD_OPMVIDEOOUTPUT;              

//  Currently on this GetInformation call is supported
DEFINE_GUID( OPM_GET_CODEC_INFO, 0x4f374491, 0x8f5f, 0x4445, 0x9d, 0xba, 0x95, 0x58, 0x8f, 0x6b, 0x58, 0xb4);

typedef struct _OPM_RANDOM_NUMBER
{
    BYTE abRandomNumber[ 16 ];
}OPM_RANDOM_NUMBER, *POPM_RANDOM_NUMBER;

enum
{
    OPM_OMAC_SIZE                                  = 16,
    OPM_128_BIT_RANDOM_NUMBER_SIZE                 = 16,
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE   = 256,
    OPM_CONFIGURE_SETTING_DATA_SIZE                = 4056,
    OPM_GET_INFORMATION_PARAMETERS_SIZE            = 4056,
    OPM_REQUESTED_INFORMATION_SIZE                 = 4076,
    OPM_HDCP_KEY_SELECTION_VECTOR_SIZE             = 5,
    OPM_PROTECTION_TYPE_SIZE                       = 4,
    OPM_BUS_TYPE_MASK                              = 0xFFFF,
    OPM_BUS_IMPLEMENTATION_MODIFIER_MASK           = 0x7FFF,
};

typedef struct _OPM_OMAC
{
    BYTE abOMAC[OPM_OMAC_SIZE];  

} OPM_OMAC;

typedef struct _OPM_GET_INFO_PARAMETERS
{
    OPM_OMAC omac;  
    OPM_RANDOM_NUMBER rnRandomNumber;
    GUID guidInformation;
    ULONG ulSequenceNumber;
    ULONG cbParametersSize;
    BYTE abParameters[OPM_GET_INFORMATION_PARAMETERS_SIZE];

} OPM_GET_INFO_PARAMETERS;

typedef struct _OPM_REQUESTED_INFORMATION
{
    OPM_OMAC omac;  
    ULONG cbRequestedInformationSize;
    BYTE abRequestedInformation[OPM_REQUESTED_INFORMATION_SIZE];

} OPM_REQUESTED_INFORMATION;

typedef struct _OPM_ENCRYPTED_INITIALIZATION_PARAMETERS
{
    BYTE abEncryptedInitializationParameters[OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE];

} OPM_ENCRYPTED_INITIALIZATION_PARAMETERS;

typedef struct _OPM_STANDARD_INFORMATION
{
    OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulInformation;
    ULONG ulReserved;
    ULONG ulReserved2;

} OPM_STANDARD_INFORMATION;

typedef struct _OPM_GET_CODEC_INFO_PARAMETERS
{
    DWORD  cbVerifier;
    BYTE   Verifier[OPM_GET_INFORMATION_PARAMETERS_SIZE - 4];  // Class ID of MFT or symbolic link for AVStream 
                          // drivers
} OPM_GET_CODEC_INFO_PARAMETERS;

typedef struct _OPM_GET_CODEC_INFO_INFORMATION
{
    OPM_RANDOM_NUMBER rnRandomNumber;
    DWORD Merit;   // Merit assigned to the codec
} OPM_GET_CODEC_INFO_INFORMATION;

#endif // (WINVER >= _WIN32_WINNT_WIN7)

#endif//_KSOPMAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ksamd64.inc ===
include kxamd64.inc

;
;  Pointer size in bytes
;

SizeofPointer equ 00008H

;
;  Process State Enumerated Type Values
;

ProcessInMemory equ 00000H
ProcessOutOfMemory equ 00001H
ProcessInTransition equ 00002H

;
;  Thread State Enumerated Type Values
;

Initialized equ 00000H
Ready equ 00001H
Running equ 00002H
Standby equ 00003H
Terminated equ 00004H
Waiting equ 00005H

;
;  Processor Mode Definitions
;

KernelMode equ 00000H
UserMode equ 00001H

;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H
WrDispatchInt equ 0001FH
WaitAny equ 00001H
WaitAll equ 00000H

;
;  Apc State Structure Offset Definitions
;

AsApcListHead equ 00000H
AsProcess equ 00020H
AsKernelApcInProgress equ 00028H
AsKernelApcPending equ 00029H
AsUserApcPending equ 0002AH

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
KERNEL_APC_PENDING_DURING_EXIT equ 00020H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH
HARDWARE_INTERRUPT_STORM equ 000F2H
RECURSIVE_MACHINE_CHECK equ 000FBH
RECURSIVE_NMI equ 00111H

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H
STATUS_ASSERTION_FAILURE equ 0C0000420H

;
;  Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00000H
CidUniqueThread equ 00008H

;
;  Critical Section Structure Offset Definitions
;

CsDebugInfo equ 00000H
CsLockCount equ 00008H
CsRecursionCount equ 0000CH
CsOwningThread equ 00010H
CsLockSemaphore equ 00018H
CsSpinCount equ 00020H

;
;  Critical Section Debug Information Structure Offset Definitions
;

CsType equ 00000H
CsCreatorBackTraceIndex equ 00002H
CsCriticalSection equ 00008H
CsProcessLocksList equ 00010H
CsEntryCount equ 00020H
CsContentionCount equ 00024H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 00010H
ErNumberParameters equ 00018H
ErExceptionInformation equ 00020H
ExceptionRecordLength equ 000A0H

;
;  Fast Mutex Structure Offset Definitions
;

FmCount equ 00000H
FmOwner equ 00008H
FmContention equ 00010H
FmOldIrql equ 00030H

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
CLOCK_LEVEL equ 0000DH
IPI_LEVEL equ 0000EH
POWER_LEVEL equ 0000EH
PROFILE_LEVEL equ 0000FH
HIGH_LEVEL equ 0000FH
ifdef NT_UP
SYNCH_LEVEL equ 00002H
else
SYNCH_LEVEL equ 0000CH
endif

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00008H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00008H

;
;  User Shared Data Structure Offset Definitions
;

UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H
UsTimeZoneBias equ 00020H
UsImageNumberLow equ 0002CH
UsImageNumberHigh equ 0002EH
UsNtSystemRoot equ 00030H
UsMaxStackTraceDepth equ 00238H
UsCryptoExponent equ 0023CH
UsTimeZoneId equ 00240H
UsLargePageMinimum equ 00244H
UsReserved2 equ 00248H
UsNtProductType equ 00264H
UsProductTypeIsValid equ 00268H
UsNtMajorVersion equ 0026CH
UsNtMinorVersion equ 00270H
UsProcessorFeatures equ 00274H
UsReserved1 equ 002B4H
UsReserved3 equ 002B8H
UsTimeSlip equ 002BCH
UsAlternativeArchitecture equ 002C0H
UsSystemExpirationDate equ 002C8H
UsSuiteMask equ 002D0H
UsKdDebuggerEnabled equ 002D4H
UsActiveConsoleId equ 002D8H
UsDismountCount equ 002DCH
UsComPlusPackage equ 002E0H
UsLastSystemRITEventTickCount equ 002E4H
UsNumberOfPhysicalPages equ 002E8H
UsSafeBootMode equ 002ECH
UsTscQpcData equ 002EDH
UsTestRetInstruction equ 002F8H
UsSystemCall equ 00300H
UsSystemCallReturn equ 00304H
UsSystemCallPad equ 00308H
UsTickCount equ 00320H
UsTickCountQuad equ 00320H
UsWow64SharedInformation equ 00340H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  Thread Switch Counter Offset Definitions
;

TwFindAny equ 00000H
TwFindIdeal equ 00004H
TwFindLast equ 00008H
TwIdleAny equ 0000CH
TwIdleCurrent equ 00010H
TwIdleIdeal equ 00014H
TwIdleLast equ 00018H
TwPreemptAny equ 0001CH
TwPreemptCurrent equ 00020H
TwPreemptLast equ 00024H
TwSwitchToIdle equ 00028H

;
;  Status Code Definitions
;

STATUS_ACCESS_VIOLATION equ 0C0000005H
STATUS_ARRAY_BOUNDS_EXCEEDED equ 0C000008CH
STATUS_BAD_COMPRESSION_BUFFER equ 0C0000242H
STATUS_BREAKPOINT equ 080000003H
STATUS_CALLBACK_POP_STACK equ 0C0000423H
STATUS_DATATYPE_MISALIGNMENT equ 080000002H
STATUS_FLOAT_DENORMAL_OPERAND equ 0C000008DH
STATUS_FLOAT_DIVIDE_BY_ZERO equ 0C000008EH
STATUS_FLOAT_INEXACT_RESULT equ 0C000008FH
STATUS_FLOAT_INVALID_OPERATION equ 0C0000090H
STATUS_FLOAT_OVERFLOW equ 0C0000091H
STATUS_FLOAT_STACK_CHECK equ 0C0000092H
STATUS_FLOAT_UNDERFLOW equ 0C0000093H
STATUS_FLOAT_MULTIPLE_FAULTS equ 0C00002B4H
STATUS_FLOAT_MULTIPLE_TRAPS equ 0C00002B5H
STATUS_GUARD_PAGE_VIOLATION equ 080000001H
STATUS_ILLEGAL_FLOAT_CONTEXT equ 0C000014AH
STATUS_ILLEGAL_INSTRUCTION equ 0C000001DH
STATUS_INSTRUCTION_MISALIGNMENT equ 0C00000AAH
STATUS_INVALID_HANDLE equ 0C0000008H
STATUS_INVALID_LOCK_SEQUENCE equ 0C000001EH
STATUS_INVALID_OWNER equ 0C000005AH
STATUS_INVALID_PARAMETER equ 0C000000DH
STATUS_INVALID_PARAMETER_1 equ 0C00000EFH
STATUS_INVALID_SYSTEM_SERVICE equ 0C000001CH
STATUS_INVALID_THREAD equ 0C000071CH
STATUS_INTEGER_DIVIDE_BY_ZERO equ 0C0000094H
STATUS_INTEGER_OVERFLOW equ 0C0000095H
STATUS_IN_PAGE_ERROR equ 0C0000006H
STATUS_KERNEL_APC equ 00100H
STATUS_LONGJUMP equ 080000026H
STATUS_NO_CALLBACK_ACTIVE equ 0C0000258H
STATUS_NO_EVENT_PAIR equ 0C000014EH
STATUS_PRIVILEGED_INSTRUCTION equ 0C0000096H
STATUS_SINGLE_STEP equ 080000004H
STATUS_STACK_BUFFER_OVERRUN equ 0C0000409H
STATUS_STACK_OVERFLOW equ 0C00000FDH
STATUS_SUCCESS equ 00000H
STATUS_THREAD_IS_TERMINATING equ 0C000004BH
STATUS_TIMEOUT equ 00102H
STATUS_UNWIND equ 0C0000027H
STATUS_UNWIND_CONSOLIDATE equ 080000029H
STATUS_USER_APC equ 000C0H
STATUS_WAKE_SYSTEM_DEBUGGER equ 080000007H

;
;  APC Object Structure Offset Definitions
;

ApType equ 00000H
ApSize equ 00002H
ApThread equ 00008H
ApApcListEntry equ 00010H
ApKernelRoutine equ 00020H
ApRundownRoutine equ 00028H
ApNormalRoutine equ 00030H
ApNormalContext equ 00038H
ApSystemArgument1 equ 00040H
ApSystemArgument2 equ 00048H
ApApcStateIndex equ 00050H
ApApcMode equ 00051H
ApInserted equ 00052H
ApcObjectLength equ 00058H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpNumber equ 00002H
DpImportance equ 00001H
DpDpcListEntry equ 00008H
DpDeferredRoutine equ 00018H
DpDeferredContext equ 00020H
DpSystemArgument1 equ 00028H
DpSystemArgument2 equ 00030H
DpDpcData equ 00038H
DpcObjectLength equ 00040H

KI_DPC_ALL_FLAGS equ 0003FH

;
;  Device Queue Object Structure Offset Definitions
;

DvType equ 00000H
DvSize equ 00002H
DvDeviceListHead equ 00008H
DvSpinLock equ 00018H
DvBusy equ 00020H
DeviceQueueObjectLength equ 00028H

;
;  Device Queue Entry Structure Offset Definitions
;

DeDeviceListEntry equ 00000H
DeSortKey equ 00010H
DeInserted equ 00014H
DeviceQueueEntryLength equ 00018H

;
;  Event Object Structure Offset Definitions
;

EvType equ 00000H
EvSize equ 00002H
EvSignalState equ 00004H
EvWaitListHead equ 00008H
EventObjectLength equ 00018H

;
;  Event Pair Object Structure Offset Definitions
;

EpType equ 00000H
EpSize equ 00002H
EpEventLow equ 00008H
EpEventHigh equ 00020H

;
;  Interrupt Object Structure Offset Definitions
;

InLevelSensitive equ 00000H
InLatched equ 00001H

InType equ 00000H
InSize equ 00002H
InInterruptListEntry equ 00008H
InServiceRoutine equ 00018H
InServiceContext equ 00030H
InSpinLock equ 00038H
InTickCount equ 00040H
InActualLock equ 00048H
InDispatchAddress equ 00050H
InVector equ 00058H
InIrql equ 0005CH
InSynchronizeIrql equ 0005DH
InFloatingSave equ 0005EH
InConnected equ 0005FH
InNumber equ 00060H
InShareVector equ 00064H
InMode equ 00068H
InServiceCount equ 00070H
InDispatchCount equ 00074H
InTrapFrame equ 00080H
InDispatchCode equ 00090H
InterruptObjectLength equ 000A0H

;
;  Process Object Structure Offset Definitions
;

PrType equ 00000H
PrSize equ 00002H
PrSignalState equ 00004H
PrProfileListHead equ 00018H
PrDirectoryTableBase equ 00028H
PrThreadListHead equ 00030H
PrAffinity equ 00048H
PrReadyListHead equ 00070H
PrSwapListEntry equ 00080H
PrActiveProcessors equ 00088H
PrProcessFlags equ 000B0H
PrBasePriority equ 000B4H
PrQuantumReset equ 000B5H
PrCycleTime equ 000F0H
PrKernelTime equ 000F8H
PrUserTime equ 000FCH
PrInstrumentationCallback equ 00100H
KernelProcessObjectLength equ 00160H
ExecutiveProcessObjectLength equ 004D0H

;
;  Profile Object Structure Offset Definitions
;

PfType equ 00000H
PfSize equ 00002H
PfProfileListEntry equ 00008H
PfProcess equ 00018H
PfRangeBase equ 00020H
PfRangeLimit equ 00028H
PfBucketShift equ 00030H
PfBuffer equ 00038H
PfSegment equ 00040H
PfAffinity equ 00048H
PfSource equ 00070H
PfStarted equ 00072H
ProfileObjectLength equ 00078H

;
;  Queue Object Structure Offset Definitions
;

QuSignalState equ 00004H
QuEntryListHead equ 00018H
QuCurrentCount equ 00028H
QuMaximumCount equ 0002CH
QuThreadListHead equ 00030H
QueueObjectLength equ 00040H

;
;  Thread Object Structure Offset Definitions
;

EeKernelEventPair equ 00000H
EtCid equ 003B0H

;
;  User Mode Scheduling Definitions
;

ThUcb equ 001B8H

ThType equ 00000H
ThSize equ 00002H
ThLock equ 00000H
THREAD_FLAGS_CYCLE_PROFILING equ 00002H
THREAD_FLAGS_CYCLE_PROFILING_LOCK_BIT equ 00011H
THREAD_FLAGS_CYCLE_PROFILING_LOCK equ 020000H
THREAD_FLAGS_COUNTER_PROFILING equ 00004H
THREAD_FLAGS_COUNTER_PROFILING_LOCK_BIT equ 00012H
THREAD_FLAGS_COUNTER_PROFILING_LOCK equ 040000H
ThDebugActive equ 00003H
ThThreadControlFlags equ 00002H
THREAD_FLAGS_CPU_THROTTLED equ 00001H
THREAD_FLAGS_CPU_THROTTLED_BIT equ 00000H
THREAD_FLAGS_ACCOUNTING_ANY equ 00005H
ThSignalState equ 00004H
ThCycleTime equ 00018H
ThInitialStack equ 00028H
ThStackLimit equ 00030H
ThKernelStack equ 00038H
ThThreadLock equ 00040H
ThApcState equ 00050H
ThNextProcessor equ 0007CH
ThDeferredProcessor equ 00080H
ThAdjustReason equ 001F4H
ThAdjustIncrement equ 001F5H
ThWaitStatus equ 00090H
ThWaitBlockList equ 00098H
ThWaitReason equ 0026BH
ThPriority equ 0007BH
ThRunning equ 00049H
ThAlerted equ 0004AH
ThWaitListEntry equ 000A0H
ThSwapListEntry equ 000A0H
ThQueue equ 000B0H
ThTeb equ 000B8H
ThTimer equ 000C0H

KTHREAD_AUTO_ALIGNMENT_BIT equ 00000H
KTHREAD_GUI_THREAD_MASK equ 00080H
DEBUG_ACTIVE_PRIMARY_THREAD equ 00080H
DEBUG_ACTIVE_PRIMARY_THREAD_BIT equ 00007H
DEBUG_ACTIVE_PRIMARY_THREAD_LOCK_BIT equ 0001FH
DEBUG_ACTIVE_SCHEDULED_THREAD equ 00040H
DEBUG_ACTIVE_SCHEDULED_THREAD_BIT equ 00006H
DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK_BIT equ 0001EH
DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK equ 040000000H

KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT equ 0000BH
KTHREAD_UMS_PERFORMING_SYSCALL_BIT equ 00008H

ThMiscFlags equ 0004CH
ThThreadFlags equ 00100H
ThWaitBlock equ 00108H
ThPreviousMode equ 001F6H
ThResourceIndex equ 00281H
ThLargeStack equ 002D3H
ThContextSwitches equ 00134H
ThState equ 00164H
ThNpxState equ 00165H
ThWaitIrql equ 00166H
ThWaitMode equ 00167H
ThWaitTime equ 00194H
ThCombinedApcDisable equ 001C4H
ThKernelApcDisable equ 001C4H
ThSpecialApcDisable equ 001C6H
ThQueueListEntry equ 001C8H
ThTrapFrame equ 001D8H
ThFirstArgument equ 001E0H
ThCallbackStack equ 001E8H
ThCallbackDepth equ 001E8H
ThApcStateIndex equ 001F0H
ThIdealProcessor equ 00228H
ThBasePriority equ 001F1H
ThPriorityDecrement equ 001F2H
ThSaturation equ 001F7H
ThSystemCallNumber equ 001F8H
ThUserAffinity equ 00200H
ThProcess equ 00210H
ThAffinity equ 00218H
ThApcStatePointer equ 00230H
ThSavedApcState equ 00240H
ThFreezeCount equ 001FCH
ThSuspendCount equ 0026CH
ThUserIdealProcessor equ 0022CH
ThCodePatchInProgress equ 0026EH
ThWin32Thread equ 00270H
ThStackBase equ 00278H
ThSuspendApc equ 00280H
ThKernelTime equ 00284H
ThLegoData equ 002C8H
ThUserTime equ 002D4H
ThSuspendSemaphore equ 002D8H
ThSListFaultCount equ 002F4H
ThMutantListHead equ 00308H
ThThreadListEntry equ 002F8H
ThSListFaultAddress equ 00318H

KI_SLIST_FAULT_COUNT_MAXIMUM equ 00400H

KernelThreadObjectLength equ 00360H
ExecutiveThreadObjectLength equ 00498H


;
;  Timer object Structure Offset Definitions
;

TiType equ 00000H
TiSize equ 00002H
TiSignalState equ 00004H
TiDueTime equ 00018H
TiTimerListEntry equ 00020H
TiDpc equ 00030H
TiPeriod equ 0003CH
TimerObjectLength equ 00040H


;
;  Wait Block Structure Offset Definitions
;

WbWaitListEntry equ 00000H
WbThread equ 00010H
WbObject equ 00018H
WbNextWaitBlock equ 00020H
WbWaitKey equ 00028H
WbWaitType equ 0002AH

;
;  Fiber Structure Offset Definitions
;

FbFiberData equ 00000H
FbExceptionList equ 00008H
FbStackBase equ 00010H
FbStackLimit equ 00018H
FbDeallocationStack equ 00020H
FbFiberContext equ 00030H
FbWx86Tib equ 00500H
FbActivationContextStackPointer equ 00508H
FbFlsData equ 00510H
FbGuaranteedStackBytes equ 00518H
FbTebFlags equ 0051CH

;
;  UMS Context Structure Definitions
;

UcTeb equ 004E0H
UcContext equ 00010H
UcFlags equ 004F0H
UcLink equ 00000H
UcContextLock equ 004F8H
UcPrimaryUmsContext equ 00520H
UMSCTX_SCHEDULED_THREAD_MASK equ 00001H
UMSCTX_SCHEDULED_THREAD_BIT equ 00000H
UMSCTX_VOLATILE_CONTEXT_MASK equ 00020H
UMSCTX_VOLATILE_CONTEXT_BIT equ 00005H
UMSCTX_TERMINATED_MASK equ 00040H
UMSCTX_TERMINATED_BIT equ 00006H
UMSCTX_SUSPENDED_MASK equ 00010H
UMSCTX_SUSPENDED_BIT equ 00004H
UMSCTX_DEBUG_ACTIVE_MASK equ 00080H
UMSCTX_DEBUG_ACTIVE_BIT equ 00007H
UMSCTX_DENY_RUNNING_ON_SELF_THREAD_MASK equ 00200H
UMSCTX_DENY_RUNNING_ON_SELF_THREAD_BIT equ 00009H


;
;  RTL_UMS_SCHEDULER_REASON Enum Definitions
;

UmsSchedulerStartup equ 00000H
UmsSchedulerThreadBlocked equ 00001H
UmsSchedulerThreadYield equ 00002H


;
;  Process Environment Block Structure Offset Definitions
;

PeBeingDebugged equ 00002H
PeProcessParameters equ 00020H
PeKernelCallbackTable equ 00058H
ProcessEnvironmentBlockLength equ 00380H

;
;  Process Parameters Block Structure Offset Definitions
;

PpFlags equ 00008H
USER_CALLBACK_FILTER equ 080000H

;
;  System Service Descriptor Table Structure Definitions
;

NUMBER_SERVICE_TABLES equ 00002H
SERVICE_NUMBER_MASK equ 00FFFH
SERVICE_TABLE_SHIFT equ 00007H
SERVICE_TABLE_MASK equ 00020H
SERVICE_TABLE_TEST equ 00020H

ThBase equ 00000H
ThLimit equ 00008H
SdBase equ 00000H
SdCount equ 00008H
SdLimit equ 00010H
SdNumber equ 00018H
SdLength equ 00020H

;
;  Thread Environment Block Structure Offset Definitions
;

TeCmTeb equ 00000H
TeStackBase equ 00008H
TeStackLimit equ 00010H
TeFiberData equ 00020H
TeSelf equ 00030H
TeEnvironmentPointer equ 00038H
TeClientId equ 00040H
TeActiveRpcHandle equ 00050H
TeThreadLocalStoragePointer equ 00058H
TeCountOfOwnedCriticalSections equ 0006CH
TePeb equ 00060H
TeCsrClientThread equ 00070H
TeWOW32Reserved equ 00100H
TeSoftFpcr equ 0010CH
TeExceptionCode equ 002C0H
TeActivationContextStackPointer equ 002C8H
TeGdiClientPID equ 007F0H
TeGdiClientTID equ 007F4H
TeGdiThreadLocalInfo equ 007F8H
TeglDispatchTable equ 009F0H
TeglReserved1 equ 01138H
TeglReserved2 equ 01220H
TeglSectionInfo equ 01228H
TeglSection equ 01230H
TeglTable equ 01238H
TeglCurrentRC equ 01240H
TeglContext equ 01248H
TeDeallocationStack equ 01478H
TeTlsSlots equ 01480H
TeTlsExpansionSlots equ 01780H
TeLastErrorValue equ 00068H
TeVdm equ 01690H
TeInstrumentation equ 016B8H
TeGdiBatchCount equ 01740H
TeGuaranteedStackBytes equ 01748H
TeFlsData equ 017C8H
ThreadEnvironmentBlockLength equ 01818H
CmThreadEnvironmentBlockOffset equ 02000H
TLS_MINIMUM_AVAILABLE equ 00040H
TLS_EXPANSION_SLOTS equ 00400H
UMS_TLS_THREAD_CONTEXT equ 00004H

;
;  Lock Queue Structure Offset Definitions
;

LOCK_QUEUE_WAIT equ 00001H
LOCK_QUEUE_OWNER equ 00002H
LOCK_QUEUE_HEADER_SIZE equ 00010H


LqNext equ 00000H
LqLock equ 00008H

LqhNext equ 00000H
LqhLock equ 00008H
LqhOldIrql equ 00010H

;
;  Kernel Stack Control Structure Offset (relative to initial stack pointer) Definitions
;

KcPreviousBase equ 00028H
KcPreviousLimit equ 00030H
KcPreviousKernel equ 00038H
KcPreviousInitial equ 00040H

KERNEL_STACK_CONTROL_LARGE_STACK equ 00001H

;
;  Performance Definitions
;

PERF_CONTEXTSWAP_OFFSET equ 00004H
PERF_CONTEXTSWAP_FLAG equ 00004H
PERF_INTERRUPT_OFFSET equ 00004H
PERF_INTERRUPT_FLAG equ 04000H
PERF_PROFILE_OFFSET equ 00004H
PERF_PROFILE_FLAG equ 00002H
PERF_SYSCALL_OFFSET equ 00008H
PERF_SYSCALL_FLAG equ 00040H
PERF_SPINLOCK_OFFSET equ 00004H
PERF_SPINLOCK_FLAG equ 010000H
NTOS_YIELD_MACRO equ 00001H

;
;  ETW Definitions
;

ETW_SPINLOCK_BASIC equ 00000H
ETW_SPINLOCK_QUEUED equ 00001H

;
;  Hal enlightenment structure definitions
;

HeEnlightenments equ 00000H
HeHypervisorConnected equ 00004H
HeEndOfInterrupt equ 00008H
HeApicWriteIcr equ 00010H
HeSpinCountMask equ 0001CH
HeLongSpinWait equ 00020H

;
;  XState context structure offset definitions
;

XctxMask equ 00000H
XctxLength equ 00008H
XctxArea equ 00010H

;
;  GETSETCONTEXT structure offset definitions
;

GetSetCtxContextPtr equ 00078H
XSAVE_ALIGN equ 00040H

;
;  XSAVE_AREA structure offset definitions
;

XsaHeader equ 00200H
XsaHeaderLength equ 00040H
XSTATE_MASK_LEGACY_FLOATING_POINT equ 00001H
XSTATE_MASK_LEGACY_SSE equ 00002H
XSTATE_MASK_LEGACY equ 00003H
XSTATE_MASK_GSSE equ 00004H

;
;  Extended context structure offset definitions
;

CxxAllOffset equ 00000H
CxxAllLength equ 00004H
CxxLegacyOffset equ 00008H
CxxLegacyLength equ 0000CH
CxxXStateOffset equ 00010H
CxxXStateLength equ 00014H

;
;  KAFFINITY_EX offsets
;

AfCount equ 00000H
AfBitmap equ 00008H

;
;  Register Argument Home Address Offset Definitions
;

P1Home equ 00008H
P2Home equ 00010H
P3Home equ 00018H
P4Home equ 00020H

;
;  Apc Record Structure Offset Definitions
;

ArNormalRoutine equ 00000H
ArNormalContext equ 00008H
ArSystemArgument1 equ 00010H
ArSystemArgument2 equ 00018H
ApcRecordLength equ 00020H


;
;  Special Register Structure Offset Definition
;

SrKernelDr0 equ 00020H
SrKernelDr1 equ 00028H
SrKernelDr2 equ 00030H
SrKernelDr3 equ 00038H
SrKernelDr6 equ 00040H
SrKernelDr7 equ 00048H
SrGdtr equ 00050H
SrIdtr equ 00060H
SrTr equ 00070H
SrMxCsr equ 00074H
SrMsrGsBase equ 000A8H
SrMsrGsSwap equ 000B0H
SrMsrStar equ 000B8H
SrMsrLStar equ 000C0H
SrMsrCStar equ 000C8H
SrMsrSyscallMask equ 000D0H

;
;  Processor Control Region Structure Offset Definitions
;

PcGdt equ 00000H
PcTss equ 00008H
PcUserRsp equ 00010H
PcSelf equ 00018H
PcCurrentPrcb equ 00020H
PcLockArray equ 00028H
PcTeb equ 00030H
PcIdt equ 00038H
PcIrql equ 00050H
PcStallScaleFactor equ 00064H
PcHalReserved equ 000C0H
PcPrcb equ 00180H
PcMxCsr equ 00180H
PcInterruptRequest equ 00186H
PcIdleHalt equ 00187H
PcCurrentThread equ 00188H
PcNextThread equ 00190H
PcIdleThread equ 00198H
PcIpiFrozen equ 02284H
PcNestingLevel equ 001A0H
PcNumber equ 001A4H
PcRspBase equ 001A8H
PcPrcbLock equ 001B0H
PcGroup equ 007D8H
PcGroupSetMember equ 007E0H
PcCr0 equ 001C0H
PcCr2 equ 001C8H
PcCr3 equ 001D0H
PcCr4 equ 001D8H
PcKernelDr0 equ 001E0H
PcKernelDr1 equ 001E8H
PcKernelDr2 equ 001F0H
PcKernelDr3 equ 001F8H
PcKernelDr7 equ 00208H
PcGdtrLimit equ 00216H
PcGdtrBase equ 00218H
PcIdtrLimit equ 00226H
PcIdtrBase equ 00228H
PcTr equ 00230H
PcLdtr equ 00232H
PcDebugControl equ 00238H
PcLastBranchToRip equ 00240H
PcLastBranchFromRip equ 00248H
PcLastExceptionToRip equ 00250H
PcLastExceptionFromRip equ 00258H
PcCr8 equ 00260H
PcCpuType equ 00770H
PcCpuID equ 00771H
PcCpuStep equ 00772H
PcCpuVendor equ 007BDH
PcVirtualApicAssist equ 04BA8H
PcFeatureBits equ 04D48H
PcNmiActive equ 045E6H
CPU_AMD equ 00001H
CPU_INTEL equ 00002H
CPU_VIA equ 00003H
PcCFlushSize equ 007C4H
PcDeferredReadyListHead equ 02208H
PcSystemCalls equ 02238H
PcDpcRoutineActive equ 0235AH
PcInterruptCount equ 04880H
PcDebuggerSavedIRQL equ 04898H
PcTickOffset equ 045F0H
PcStartCycles equ 048C0H
ProcessorControlRegisterLength equ 08E40H

;
;  Defines for user shared data
;

USER_SHARED_DATA equ 0FFFFF78000000000H
MM_SHARED_USER_DATA_VA equ 07FFE0000H
PF_COMPARE_EXCHANGE128 equ 0000EH
UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H
UsTestRetInstruction equ 002F8H
UsProcessorFeatures equ 00274H

;
;  Tss Structure Offset Definitions
;

TssRsp0 equ 00004H
TssRsp1 equ 0000CH
TssRsp2 equ 00014H
TssPanicStack equ 00024H
TssMcaStack equ 0002CH
TssNmiStack equ 00034H
TssIoMapBase equ 00066H
TssLength equ 00068H

;
;  Gdt Descriptor Offset Definitions
;

KGDT64_NULL equ 00000H
KGDT64_R0_CODE equ 00010H
KGDT64_R0_DATA equ 00018H
KGDT64_R3_CMCODE equ 00020H
KGDT64_R3_DATA equ 00028H
KGDT64_R3_CODE equ 00030H
KGDT64_SYS_TSS equ 00040H
KGDT64_R3_CMTEB equ 00050H
KGDT64_R0_LDT equ 00070H

;
;  GDT Entry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMiddle equ 00004H
KgdtBaseHigh equ 00007H
KgdtBaseUpper equ 00008H
KgdtLimitHigh equ 00006H
KgdtLimitLow equ 00000H
KGDT_LIMIT_ENCODE_MASK equ 03C00H


;
;  Processor Block Structure Offset Definitions
;

PbMxCsr equ 00000H
PbInterruptRequest equ 00006H
PbIdleHalt equ 00007H
PbCurrentThread equ 00008H
PbNextThread equ 00010H
PbIdleThread equ 00018H
PbNestingLevel equ 00020H
PbNumber equ 00024H
PbRspBase equ 00028H
PbPrcbLock equ 00030H
PbGroupSetMember equ 00660H
PbProcessorState equ 00040H
PbCpuType equ 005F0H
PbCpuID equ 005F1H
PbCpuStep equ 005F2H
PbHalReserved equ 005F8H
PbMinorVersion equ 00638H
PbMajorVersion equ 0063AH
PbBuildType equ 0063CH
PbCpuVendor equ 0063DH
PbCoresPerPhysicalProcessor equ 0063EH
PbLogicalProcessorsPerCore equ 0063FH
PbApicMask equ 00640H
PbCFlushSize equ 00644H
PbAcpiReserved equ 00648H
PbInitialApicId equ 00650H
PbStride equ 00654H
PbLockQueue equ 00670H
PbPPLookasideList equ 00780H
PbPPNPagedLookasideList equ 00880H
PbPPPagedLookasideList equ 01480H
PbPacketBarrier equ 02080H
PbDeferredReadyListHead equ 02088H
PbLookasideIrpFloat equ 020D8H
PbSystemCalls equ 020B8H
PbReadOperationCount equ 020DCH
PbWriteOperationCount equ 020E0H
PbOtherOperationCount equ 020E4H
PbReadTransferCount equ 020E8H
PbWriteTransferCount equ 020F0H
PbOtherTransferCount equ 020F8H
PbContextSwitches equ 020BCH
PbTargetCount equ 02100H
PbIpiFrozen equ 02104H
PbRequestMailbox equ 04C80H
PbMailbox equ 04C00H
PbDpcListHead equ 02180H
PbDpcLock equ 02190H
PbDpcCount equ 0219CH
PbDpcStack equ 021C0H
PbMaximumDpcQueueDepth equ 021C8H
PbDpcRequestRate equ 021CCH
PbMinimumDpcRate equ 021D0H
PbDpcRoutineActive equ 021DAH
PbNormalDpcState equ 021DCH
PbTickOffset equ 04470H
PbDpcLastCount equ 021D4H
PbQuantumEnd equ 021D9H
PbIdleSchedule equ 021DBH
PbReadySummary equ 04498H
PbDispatcherReadyListHead equ 04500H
PbInterruptCount equ 04700H
PbKernelTime equ 04704H
PbUserTime equ 04708H
PbDpcTime equ 0470CH
PbInterruptTime equ 04710H
PbAdjustDpcThreshold equ 04714H
PbParentNode equ 04738H
PbStartCycles equ 04740H
PbPageColor equ 04764H
PbNodeColor equ 04768H
PbNodeShiftedColor equ 0476CH
PbSecondaryColorMask equ 04770H
PbCycleTime equ 04778H
PbFastReadNoWait equ 020C0H
PbFastReadWait equ 020C4H
PbFastReadNotPossible equ 020C8H
PbCopyReadNoWait equ 020CCH
PbCopyReadWait equ 020D0H
PbCopyReadNoWaitMiss equ 020D4H
PbAlignmentFixupCount equ 04910H
PbExceptionDispatchCount equ 04734H
PbVendorString equ 04BB8H
ProcessorBlockLength equ 04D00H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  Define constants for system IRQL and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H
RPL_MASK equ 00003H
MODE_BIT equ 00000H
MODE_MASK equ 00001H
LDT_MASK equ 00004H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H
CR4_XSAVE equ 040000H

;
;  Legacy Floating Status Bit Masks
;

FSW_INVALID_OPERATION equ 00001H
FSW_DENORMAL equ 00002H
FSW_ZERO_DIVIDE equ 00004H
FSW_OVERFLOW equ 00008H
FSW_UNDERFLOW equ 00010H
FSW_PRECISION equ 00020H
FSW_STACK_FAULT equ 00040H
FSW_ERROR_SUMMARY equ 00080H
FSW_CONDITION_CODE_0 equ 00100H
FSW_CONDITION_CODE_1 equ 00200H
FSW_CONDITION_CODE_2 equ 00400H
FSW_CONDITION_CODE_3 equ 04000H
FSW_ERROR_MASK equ 0003FH

;
;  MXCSR Floating Control/Status Bit Masks
;

XSW_INVALID_OPERATION equ 00001H
XSW_DENORMAL equ 00002H
XSW_ZERO_DIVIDE equ 00004H
XSW_OVERFLOW equ 00008H
XSW_UNDERFLOW equ 00010H
XSW_PRECISION equ 00020H
XSW_ERROR_MASK equ 0003FH
XSW_ERROR_SHIFT equ 00007H
XCW_INVALID_OPERATION equ 00080H
XCW_DENORMAL equ 00100H
XCW_ZERO_DIVIDE equ 00200H
XCW_OVERFLOW equ 00400H
XCW_UNDERFLOW equ 00800H
XCW_PRECISION equ 01000H
XCW_ROUND_CONTROL equ 06000H
XCW_FLUSH_ZERO equ 08000H
INITIAL_FPCSR equ 0027FH
INITIAL_MXCSR equ 01F80H

;
;  Machine Specific Register Numbers
;

MSR_EFER equ 0C0000080H
MSR_STAR equ 0C0000081H
MSR_LSTAR equ 0C0000082H
MSR_CSTAR equ 0C0000083H
MSR_SYSCALL_MASK equ 0C0000084H
MSR_FS_BASE equ 0C0000100H
MSR_GS_BASE equ 0C0000101H
MSR_GS_SWAP equ 0C0000102H
MSR_MCG_STATUS equ 0017AH
MSR_AMD_ACCESS equ 09C5A203AH

;
;  Flags within MSR_EFER
;

MSR_LMA equ 00400H
MSR_LME equ 00100H
MSR_SCE equ 00001H
MSR_NXE equ 00800H
MSR_PAT equ 00277H
MSR_DEBUG_CTL equ 001D9H

;
;  Flags within MSR_DEGUG_CTL
;

MSR_DEBUG_CTL_LBR equ 00001H
MSR_DEBUG_CTL_BTF equ 00002H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00040H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H
SPIN_LOCK_ALREADY_OWNED equ 0000FH
SPIN_LOCK_NOT_OWNED equ 00010H
Executive equ 00000H
FALSE equ 00000H
TRUE equ 00001H
KERNEL_MCA_EXCEPTION_STACK_SIZE equ 02000H
NMI_STACK_SIZE equ 02000H
EXCEPTION_EXECUTE_FAULT equ 00008H
KCACHE_ERRATA_MONITOR_FLAGS equ 00003H
BASE_PRIORITY_THRESHOLD equ 00008H
EVENT_PAIR_INCREMENT equ 00001H
LOW_REALTIME_PRIORITY equ 00010H
BlackHole equ 0FFFFA000H
KERNEL_LARGE_STACK_COMMIT equ 06000H
KERNEL_LARGE_STACK_SIZE equ 012000H
KERNEL_STACK_SIZE equ 06000H
DOUBLE_FAULT_STACK_SIZE equ 02000H
BREAKPOINT_BREAK equ 00000H
BREAKPOINT_COMMAND_STRING equ 00005H
BREAKPOINT_PRINT equ 00001H
BREAKPOINT_PROMPT equ 00002H
BREAKPOINT_LOAD_SYMBOLS equ 00003H
BREAKPOINT_UNLOAD_SYMBOLS equ 00004H
CLOCK_QUANTUM_DECREMENT equ 00003H
READY_SKIP_QUANTUM equ 00002H
THREAD_QUANTUM equ 00006H
WAIT_QUANTUM_DECREMENT equ 00001H
ROUND_TRIP_DECREMENT_COUNT equ 00010H
KI_EXCEPTION_GP_FAULT equ 010000001H
KI_EXCEPTION_INVALID_OP equ 010000002H
KI_EXCEPTION_INTEGER_DIVIDE_BY_ZERO equ 010000003H
KI_EXCEPTION_ACCESS_VIOLATION equ 010000004H
TARGET_FREEZE equ 00005H
KI_DPC_INTERRUPT_FLAGS equ 0002FH

;
;  Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO equ 00000H
EXCEPTION_DEBUG equ 00001H
EXCEPTION_NMI equ 00002H
EXCEPTION_INT3 equ 00003H
EXCEPTION_BOUND_CHECK equ 00005H
EXCEPTION_INVALID_OPCODE equ 00006H
EXCEPTION_NPX_NOT_AVAILABLE equ 00007H
EXCEPTION_DOUBLE_FAULT equ 00008H
EXCEPTION_NPX_OVERRUN equ 00009H
EXCEPTION_INVALID_TSS equ 0000AH
EXCEPTION_SEGMENT_NOT_PRESENT equ 0000BH
EXCEPTION_STACK_FAULT equ 0000CH
EXCEPTION_GP_FAULT equ 0000DH
EXCEPTION_RESERVED_TRAP equ 0000FH
EXCEPTION_NPX_ERROR equ 00010H
EXCEPTION_ALIGNMENT_CHECK equ 00011H

;
;  Exception Frame Offset Definitions and Length
;

ExP1Home equ 00000H
ExP2Home equ 00008H
ExP3Home equ 00010H
ExP4Home equ 00018H
ExP5 equ 00020H
ExXmm6 equ 00030H
ExXmm7 equ 00040H
ExXmm8 equ 00050H
ExXmm9 equ 00060H
ExXmm10 equ 00070H
ExXmm11 equ 00080H
ExXmm12 equ 00090H
ExXmm13 equ 000A0H
ExXmm14 equ 000B0H
ExXmm15 equ 000C0H
ExMxCsr equ 000F0H
ExRbp equ 000F8H
ExRbx equ 00100H
ExRdi equ 00108H
ExRsi equ 00110H
ExR12 equ 00118H
ExR13 equ 00120H
ExR14 equ 00128H
ExR15 equ 00130H
ExReturn equ 00138H

KEXCEPTION_FRAME_LENGTH equ 00140H
EXCEPTION_RECORD_LENGTH equ 000A0H


;
;  Ums Context Header definitions and length
;

UcbUmsTeb equ 00080H
UchStackTop equ 00020H
UchStackSize equ 00028H
UchRspOffset equ 00030H
UchRip equ 00038H
UchTrapFrame equ 00050H
UchExceptionFrame equ 00058H
UchFltSave equ 00040H
UchFlags equ 00048H
KUMS_UCH_VOLATILE_BIT equ 00000H
KUMS_UCH_VOLATILE_MASK equ 00001H
KUMS_CONTEXT_HEADER_LENGTH equ 00070H


;
;  Jump Offset Definitions and Length
;

JbFrame equ 00000H
JbRbx equ 00008H
JbRsp equ 00010H
JbRbp equ 00018H
JbRsi equ 00020H
JbRdi equ 00028H
JbR12 equ 00030H
JbR13 equ 00038H
JbR14 equ 00040H
JbR15 equ 00048H
JbRip equ 00050H
JbMxCsr equ 00058H
JbFpCsr equ 0005CH
JbXmm6 equ 00060H
JbXmm7 equ 00070H
JbXmm8 equ 00080H
JbXmm9 equ 00090H
JbXmm10 equ 000A0H
JbXmm11 equ 000B0H
JbXmm12 equ 000C0H
JbXmm13 equ 000D0H
JbXmm14 equ 000E0H
JbXmm15 equ 000F0H

;
;  Switch Frame Offset Definitions and Length
;

SwP5Home equ 00020H
SwApcBypass equ 00028H
SwRbp equ 00030H
SwReturn equ 00038H

KSWITCH_FRAME_LENGTH equ 00040H

;
;  Start System Thread Frame Offset Definitions and Length
;

SfP1Home equ 00000H
SfP2Home equ 00008H
SfP3Home equ 00010H
SfP4Home equ 00018H
SfReturn equ 00028H

KSTART_FRAME_LENGTH equ 00030H

;
;  Trap Frame Offset and EFLAG Definitions and Length
;

EFLAGS_TF_MASK equ 00100H
EFLAGS_TF_SHIFT equ 00008H
EFLAGS_ID_MASK equ 0200000H
EFLAGS_IF_MASK equ 00200H
EFLAGS_IF_SHIFT equ 00009H

TrP1Home equ 0FFFFFF80H
TrP2Home equ 0FFFFFF88H
TrP3Home equ 0FFFFFF90H
TrP4Home equ 0FFFFFF98H
TrP5 equ 0FFFFFFA0H
TrPreviousMode equ 0FFFFFFA8H
TrPreviousIrql equ 0FFFFFFA9H
TrFaultIndicator equ 0FFFFFFAAH
TrExceptionActive equ 0FFFFFFABH
TrMxCsr equ 0FFFFFFACH
TrRax equ 0FFFFFFB0H
TrRcx equ 0FFFFFFB8H
TrRdx equ 0FFFFFFC0H
TrR8 equ 0FFFFFFC8H
TrR9 equ 0FFFFFFD0H
TrR10 equ 0FFFFFFD8H
TrR11 equ 0FFFFFFE0H
TrGsBase equ 0FFFFFFE8H
TrGsSwap equ 0FFFFFFE8H
TrXmm0 equ 0FFFFFFF0H
TrXmm1 equ 00000H
TrXmm2 equ 00010H
TrXmm3 equ 00020H
TrXmm4 equ 00030H
TrXmm5 equ 00040H
TrFaultAddress equ 00050H
TrTimeStampCKCL equ 00050H
TrDr0 equ 00058H
TrDr1 equ 00060H
TrDr2 equ 00068H
TrDr3 equ 00070H
TrDr6 equ 00078H
TrDr7 equ 00080H
TrDebugControl equ 00088H
TrLastBranchToRip equ 00090H
TrLastBranchFromRip equ 00098H
TrLastExceptionToRip equ 000A0H
TrLastExceptionFromRip equ 000A8H
TrLastBranchControl equ 00088H
TrLastBranchMSR equ 00090H
TrSegDs equ 000B0H
TrSegEs equ 000B2H
TrSegFs equ 000B4H
TrSegGs equ 000B6H
TrTrapFrame equ 000B8H
TrRbx equ 000C0H
TrRdi equ 000C8H
TrRsi equ 000D0H
TrRbp equ 000D8H
TrErrorCode equ 000E0H
TrTimeStampKlog equ 000E0H
TrRip equ 000E8H
TrSegCs equ 000F0H
TrLogging equ 000F3H
TrEFlags equ 000F8H
TrRsp equ 00100H
TrSegSs equ 00108H
TrCodePatchCycle equ 0010CH

KTRAP_FRAME_LENGTH equ 00190H

;
;  CPU information structure offset definitions
;

CpuEax equ 00000H
CpuEbx equ 00004H
CpuEcx equ 00008H
CpuEdx equ 0000CH

;
;  Usermode Callout User Frame Definitions
;

CkBuffer equ 00020H
CkLength equ 00028H
CkApiNumber equ 0002CH
CkRsp equ 00048H
CkRip equ 00030H
CalloutFrameLength equ 00058H

;
;  Machine Frame Offset Definitions
;

MfRip equ 00000H
MfSegCs equ 00008H
MfEFlags equ 00010H
MfRsp equ 00018H
MfSegSs equ 00020H
MachineFrameLength equ 00028H

;
;  DPC Stack Frame Defintions
;

DpRsp equ 00040H
DpRip equ 00028H

;
;  LPC Structure Offset Definitions
;

PmLength equ 00000H
PmZeroInit equ 00004H
PmClientId equ 00008H
PmProcess equ 00008H
PmThread equ 00010H
PmMessageId equ 00018H
PmClientViewSize equ 00020H
PortMessageLength equ 00028H

;
;  Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00000H
CidUniqueThread equ 00008H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010000BH
CONTEXT_CONTROL equ 0100001H
CONTEXT_INTEGER equ 0100002H
CONTEXT_SEGMENTS equ 0100004H
CONTEXT_FLOATING_POINT equ 0100008H
CONTEXT_DEBUG_REGISTERS equ 0100010H
CONTEXT_XSTATE equ 0100020H

CxP1Home equ 00000H
CxP2Home equ 00008H
CxP3Home equ 00010H
CxP4Home equ 00018H
CxP5Home equ 00020H
CxP6Home equ 00028H
CxContextFlags equ 00030H
CxMxCsr equ 00034H
CxSegCs equ 00038H
CxSegDs equ 0003AH
CxSegEs equ 0003CH
CxSegFs equ 0003EH
CxSegGs equ 00040H
CxSegSs equ 00042H
CxEFlags equ 00044H
CxDr0 equ 00048H
CxDr1 equ 00050H
CxDr2 equ 00058H
CxDr3 equ 00060H
CxDr6 equ 00068H
CxDr7 equ 00070H
CxRax equ 00078H
CxRcx equ 00080H
CxRdx equ 00088H
CxRbx equ 00090H
CxRsp equ 00098H
CxRbp equ 000A0H
CxRsi equ 000A8H
CxRdi equ 000B0H
CxR8 equ 000B8H
CxR9 equ 000C0H
CxR10 equ 000C8H
CxR11 equ 000D0H
CxR12 equ 000D8H
CxR13 equ 000E0H
CxR14 equ 000E8H
CxR15 equ 000F0H
CxRip equ 000F8H
CxFltSave equ 00100H
CxXmm0 equ 001A0H
CxXmm1 equ 001B0H
CxXmm2 equ 001C0H
CxXmm3 equ 001D0H
CxXmm4 equ 001E0H
CxXmm5 equ 001F0H
CxXmm6 equ 00200H
CxXmm7 equ 00210H
CxXmm8 equ 00220H
CxXmm9 equ 00230H
CxXmm10 equ 00240H
CxXmm11 equ 00250H
CxXmm12 equ 00260H
CxXmm13 equ 00270H
CxXmm14 equ 00280H
CxXmm15 equ 00290H
CxDebugControl equ 004A8H
CxLastBranchToRip equ 004B0H
CxLastBranchFromRip equ 004B8H
CxLastExceptionToRip equ 004C0H
CxLastExceptionFromRip equ 004C8H
CxVectorControl equ 004A0H
CxVectorRegister equ 00300H
CONTEXT_FRAME_LENGTH equ 004D0H
CONTEXT_EX_LENGTH equ 00020H

;
;  Debug Control Register Masks
;

DR7_LEGAL equ 0FFFF0355H
DR7_ACTIVE equ 00355H
DR7_TRACE_BRANCH equ 00200H
DR7_LAST_BRANCH equ 00100H
DEBUG_ACTIVE_DR7 equ 00001H
DEBUG_ACTIVE_INSTRUMENTED equ 00002H
DEBUG_ACTIVE_DBG_INSTRUMENTED equ 00003H

;
;  Dispatcher Context Structure Offset Definitions
;

DcControlPc equ 00000H
DcImageBase equ 00008H
DcFunctionEntry equ 00010H
DcEstablisherFrame equ 00018H
DcTargetIp equ 00020H
DcContextRecord equ 00028H
DcLanguageHandler equ 00030H
DcHandlerData equ 00038H
DcHistoryTable equ 00040H
DcScopeIndex equ 00048H

;
;  Legacy Floating Save Area Structure Offset definitions
;

LfControlWord equ 00000H
LfStatusWord equ 00002H
LfTagWord equ 00004H
LfErrorOpcode equ 00006H
LfErrorOffset equ 00008H
LfErrorSelector equ 0000CH
LfDataOffset equ 00010H
LfDataSelector equ 00014H
LfMxCsr equ 00018H
LfMxCsr_Mask equ 0001CH
LfFloatRegisters equ 00020H


;
;  Kernel Stack Control Structure Offset (relative to initial stack pointer) Definitions
;

KcCurrentBase equ 00000H
KcCurrentLimit equ 00008H
KcActualLimit equ 00020H

;
;  Kernel stack area field offset definitions
;

SaNpxFrame equ 00050H
SaStackControl equ 00000H


;
;  Processor State Frame Offset Definitions
;

PsSpecialRegisters equ 00000H
PsCr0 equ 00000H
PsCr2 equ 00008H
PsCr3 equ 00010H
PsCr4 equ 00018H
PsKernelDr0 equ 00020H
PsKernelDr1 equ 00028H
PsKernelDr2 equ 00030H
PsKernelDr3 equ 00038H
PsKernelDr6 equ 00040H
PsKernelDr7 equ 00048H
PsGdtr equ 00056H
PsIdtr equ 00066H
PsTr equ 00070H
PsLdtr equ 00072H
PsMxCsr equ 00074H
PsContextFrame equ 000E0H
PsDebugControl equ 00078H
PsLastBranchToRip equ 00080H
PsLastBranchFromRip equ 00088H
PsLastExceptionToRip equ 00090H
PsLastExceptionFromRip equ 00098H
PsCr8 equ 000A0H
ProcessorStateLength equ 005B0H

;
;  Processor Start Block Offset Definitions
;

PsbCompletionFlag equ 00004H
PsbGdt32 equ 00008H
PsbIdt32 equ 0000EH
PsbGdt equ 00018H
PsbTiledCr3 equ 00058H
PsbPmTarget equ 00060H
PsbLmTarget equ 00070H
PsbLmIdentityTarget equ 00066H
PsbSelfMap equ 00078H
PsbMsrPat equ 00080H
PsbMsrEFER equ 00088H
PsbProcessorState equ 00090H
ProcessorStartBlockLength equ 00640H

;
;  KTHREAD
;

ThTebMappedLowVa equ 001B0H

;
;  KPROCESS
;

PrLdtSystemDescriptor equ 00108H
PrLdtBaseAddress equ 00118H

;
;  EPROCESS
;

EpDebugPort equ 001F0H

;
;  Machine type definitions (Temporarily)
;

MACHINE_TYPE_ISA equ 00000H
MACHINE_TYPE_EISA equ 00001H
MACHINE_TYPE_MCA equ 00002H

;
;  KeFeatureBits defines
;

KF_RDTSC equ 00002H
KF_CR4 equ 00004H
KF_GLOBAL_PAGE equ 00010H
KF_LARGE_PAGE equ 00020H
KF_CMPXCHG8B equ 00080H
KF_FAST_SYSCALL equ 01000H
KF_BRANCH equ 020000H
KF_XSTATE equ 0800000H

;
;  LoaderParameterBlock offsets relative to base
;

LpbLoadOrderListHead equ 00010H
LpbMemoryDescriptorListHead equ 00020H
LpbKernelStack equ 00040H
LpbPrcb equ 00048H
LpbProcess equ 00050H
LpbThread equ 00058H
LpbI386 equ 000C0H
LpbRegistryLength equ 00060H
LpbRegistryBase equ 00068H
LpbConfigurationRoot equ 00070H
LpbArcBootDeviceName equ 00078H
LpbArcHalDeviceName equ 00080H
LpbLoadOptions equ 00098H
PAGE_SIZE equ 01000H

;
;  Kernel Mode Callout Frame Definitions
;

CuInitialStack equ 00028H
CuTrapFrame equ 000D0H
CuCallbackStack equ 000D8H
CuOutputBuffer equ 000E0H
CuOutputLength equ 000E8H

;
;  Hypervisor Enlightenment Definitions
;

HV_MMU_USE_HYPERCALL_FOR_ADDRESS_SWITCH equ 00001H
HV_MMU_USE_HYPERCALL_FOR_LOCAL_FLUSH equ 00002H
HV_MMU_USE_HYPERCALL_FOR_REMOTE_FLUSH equ 00004H
HV_X64_MSR_EOI equ 040000070H
HV_APIC_ENLIGHTENED equ 00010H
HV_KE_USE_HYPERCALL_FOR_LONG_SPIN_WAIT equ 00040H
HV_VIRTUAL_APIC_NO_EOI_REQUIRED equ 00000H
HvApicFlags equ 00000H

;
;  IO Status Block Offset Definitions
;

IoStatus equ 00000H
IoPointer equ 00000H
IoInformation equ 00008H

;
;  Kernel Node Offset Definitions
;

KnRight equ 00078H
KnLeft equ 0007CH
KnColor equ 00059H
KnSeed equ 0005CH
KnNodeNumber equ 00054H
KnFlags equ 0005AH
knMmShiftedColor equ 00060H
KnFreeCount equ 00068H
KNODE_SIZE equ 000C0H

;
;  KAFFINITY_EX size
;

AffinityExLength equ 00028H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\l2cmn.h ===
/*++

Copyright (c) 2004 Microsoft Corporation

Module Name:

    l2cmn.h

Abstract:

    Definitions and data strcutures for common layer 2

Environment:

    User mode only

--*/

#ifndef _L2CMN_H
#define _L2CMN_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// Profile name max length, in characters
#define L2_PROFILE_MAX_NAME_LENGTH     256

// If a notification needs to be private that is only consumed by internal components 
// then it should be part of l2cmnpriv.h 


// the types of notification
// This signifies what kind of notification is to be passed on , the 
// 0X0000FFFF  signifies all public notifications , so all notfications that need to be public 
// should be in this range and have a single bit set as these flags can be combined.
#define L2_NOTIFICATION_SOURCE_NONE                   0
#define L2_NOTIFICATION_SOURCE_DOT3_AUTO_CONFIG       0X00000001
#define L2_NOTIFICATION_SOURCE_SECURITY  		    0X00000002
#define L2_NOTIFICATION_SOURCE_ONEX                   0X00000004	
#define L2_NOTIFICATION_SOURCE_WLAN_ACM          0X00000008
#define L2_NOTIFICATION_SOURCE_WLAN_MSM          0X00000010
#define L2_NOTIFICATION_SOURCE_WLAN_SECURITY     0X00000020
#define L2_NOTIFICATION_SOURCE_WLAN_IHV          0X00000040
#define L2_NOTIFICATION_SOURCE_WLAN_HNWK         0X00000080

#define L2_NOTIFICATION_SOURCE_ALL          				0X0000FFFF
#define L2_NOTIFICATION_CODE_PUBLIC_BEGIN         0X00000000
#define L2_NOTIFICATION_CODE_GROUP_SIZE           0x00001000
#define L2_NOTIFICATION_CODE_V2_BEGIN             (L2_NOTIFICATION_CODE_PUBLIC_BEGIN+L2_NOTIFICATION_CODE_GROUP_SIZE)

// L2 reason code 
// reason code bases
#define L2_REASON_CODE_GROUP_SIZE             0x10000
#define L2_REASON_CODE_GEN_BASE               0x10000
#define L2_REASON_CODE_DOT11_AC_BASE          (L2_REASON_CODE_GEN_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_MSM_BASE         (L2_REASON_CODE_DOT11_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_SECURITY_BASE    (L2_REASON_CODE_DOT11_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_ONEX_BASE              (L2_REASON_CODE_DOT11_SECURITY_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_AC_BASE           (L2_REASON_CODE_ONEX_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_MSM_BASE          (L2_REASON_CODE_DOT3_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_PROFILE_BASE           (L2_REASON_CODE_DOT3_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_IHV_BASE               (L2_REASON_CODE_PROFILE_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_WIMAX_BASE             (L2_REASON_CODE_IHV_BASE+L2_REASON_CODE_GROUP_SIZE)

// the common reason codes
#define L2_REASON_CODE_SUCCESS			      0

// general reason code
#define L2_REASON_CODE_UNKNOWN                  (L2_REASON_CODE_GEN_BASE+1)

// common profile section missing
#define L2_REASON_CODE_PROFILE_MISSING          0x00000001

// This structure is the notification structure which needs to be filled in by each component 
// The interface guid is filled in only by the AC 
// The NotificationSource signifies the type above 
// and NotificationCode is one of the enum values 
typedef struct _L2_NOTIFICATION_DATA {
    DWORD NotificationSource;
    DWORD NotificationCode;
    GUID InterfaceGuid;
    DWORD dwDataSize;
    
#ifdef __midl
    [unique, size_is(dwDataSize)] PBYTE pData;
#else
    __field_bcount(dwDataSize) PVOID pData;
#endif

} L2_NOTIFICATION_DATA, *PL2_NOTIFICATION_DATA;

#ifdef __cplusplus
}
#endif

#endif  // _L2CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LM.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lm.h

Abstract:

    This is the top level include file that includes all the files
    necessary for writing Lan Manager Application.

[Environment:]

    User Mode - Win32

--*/

#ifndef _LM_
#define _LM_

#if _MSC_VER > 1000
#pragma once
#endif

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <lmaccess.h>   // Access, Domain, Group and User classes
#include <lmalert.h>    // Alerter
#include <lmshare.h>    // Connection, File, Session and Share classes
#include <lmmsg.h>      // Message class
#include <lmremutl.h>   // Remote Utility class
#include <lmrepl.h>     // Replicator class
#include <lmserver.h>   // Server class
#include <lmsvc.h>      // Service class
#include <lmuse.h>      // Use class
#include <lmwksta.h>    // Workstation class
#include <lmapibuf.h>   // NetApiBuffer class
#include <lmerrlog.h>   // NetErrorLog class
#include <lmconfig.h>   // NetConfig class
#include <lmstats.h>    // NetStats class
#include <lmaudit.h>    // NetAudit class
#include <lmjoin.h>     // NetJoinDomain class

#endif // _LM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\KsMedia.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_KS_)
#error KS.H must be included before KSMEDIA.H
#endif // !defined(_KS_)

#if !defined(_KSMEDIA_)
#define _KSMEDIA_

#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

typedef struct {
    KSPROPERTY      Property;
    KSMULTIPLE_ITEM MultipleItem;
} KSMULTIPLE_DATA_PROP, *PKSMULTIPLE_DATA_PROP;

#define STATIC_KSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", KSMEDIUMSETID_MidiBus);
#define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)

#define STATIC_KSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", KSMEDIUMSETID_VPBus);
#define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)

#define STATIC_KSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", KSINTERFACESETID_Media);
#define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)

typedef enum {
    KSINTERFACE_MEDIA_MUSIC,                    //Reserved for system use
    KSINTERFACE_MEDIA_WAVE_BUFFERED,            //Reserved for system use
    KSINTERFACE_MEDIA_WAVE_QUEUED
} KSINTERFACE_MEDIA;


#if (NTDDI_VERSION >= NTDDI_WINXP)

#if !defined(INIT_USBAUDIO_MID)
// {4e1cecd2-1679-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_MID(guid, id)\
{\
    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);\
    (guid)->Data2 = 0x1679;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_MID(guid)\
    (USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)\
    0x4e1cecd2+(USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define INIT_EXBUS_MANUFACTURER_ID INIT_USBAUDIO_MID

#define IS_COMPATIBLE_USBAUDIO_MID(guid)\
    (((guid)->Data1 >= 0x4e1cecd2) &&\
    ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&\
    ((guid)->Data2 == 0x1679) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_MID)

#if !defined(INIT_USBAUDIO_PID)
// {abcc5a5e-c263-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_PID(guid, id)\
{\
    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);\
    (guid)->Data2 = 0xc263;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_PID(guid)\
    (USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)\
    0xabcc5a5e+(USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define INIT_EXBUS_PRODUCT_ID INIT_USBAUDIO_PID

#define IS_COMPATIBLE_USBAUDIO_PID(guid)\
    (((guid)->Data1 >= 0xabcc5a5e) &&\
    ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&\
    ((guid)->Data2 == 0xc263) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_PID)

#if !defined(INIT_USBAUDIO_PRODUCT_NAME)
// {FC575048-2E08-463B-A72F-A5BF64C86EBA}
#define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)\
{\
    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);\
    (guid)->Data2 = 0x2E08     + (USHORT)(pid);\
    (guid)->Data3 = 0x463B     + (USHORT)(strIndex);\
    (guid)->Data4[0] = 0xA7;\
    (guid)->Data4[1] = 0x2F;\
    (guid)->Data4[2] = 0xA5;\
    (guid)->Data4[3] = 0xBF;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xC8;\
    (guid)->Data4[6] = 0x6E;\
    (guid)->Data4[7] = 0xBA;\
}
#define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)\
    0xFC575048+(USHORT)(vid), 0x2E08+(USHORT)(pid), 0x463B+(USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
#endif // !defined(INIT_USBAUDIO_PRODUCT_NAME)

#define INIT_EXBUS_PRODUCT_NAME INIT_USBAUDIO_PRODUCT_NAME

// USB Component ID
#define STATIC_KSCOMPONENTID_USBAUDIO \
    0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", KSCOMPONENTID_USBAUDIO);
#define KSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(KSCOMPONENTID_USBAUDIO)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_KSNODETYPE_INPUT_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0200)
DEFINE_GUIDSTRUCT("DFF21BE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_INPUT_UNDEFINED);
#define KSNODETYPE_INPUT_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_INPUT_UNDEFINED)

#define STATIC_KSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE);
#define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)

#define STATIC_KSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_MICROPHONE);
#define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_KSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PERSONAL_MICROPHONE);
#define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE_ARRAY);
#define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR \
    0x830a44f2, 0xa32d, 0x476b,  0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_OUTPUT_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0300)
DEFINE_GUIDSTRUCT("DFF21CE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OUTPUT_UNDEFINED);
#define KSNODETYPE_OUTPUT_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_OUTPUT_UNDEFINED)

#define STATIC_KSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKER);
#define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)

#define STATIC_KSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADPHONES);
#define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)

#define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_KSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_SPEAKER);
#define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_KSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ROOM_SPEAKER);
#define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)

#define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_COMMUNICATION_SPEAKER);
#define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_KSNODETYPE_BIDIRECTIONAL_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0400)
DEFINE_GUIDSTRUCT("DFF21DE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_BIDIRECTIONAL_UNDEFINED);
#define KSNODETYPE_BIDIRECTIONAL_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_BIDIRECTIONAL_UNDEFINED)

#define STATIC_KSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HANDSET);
#define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)

#define KSNODETYPE_HEADSET_MICROPHONE   KSNODETYPE_PERSONAL_MICROPHONE
#define KSNODETYPE_HEADSET_SPEAKERS     KSNODETYPE_COMMUNICATION_SPEAKER

#define STATIC_KSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADSET);
#define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)

#define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_TELEPHONY_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0500)
DEFINE_GUIDSTRUCT("DFF21EE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONY_UNDEFINED);
#define KSNODETYPE_TELEPHONY_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONY_UNDEFINED)

#define STATIC_KSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONE_LINE);
#define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)

#define STATIC_KSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONE);
#define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)

#define STATIC_KSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DOWN_LINE_PHONE);
#define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_KSNODETYPE_EXTERNAL_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0600)
DEFINE_GUIDSTRUCT("DFF21FE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EXTERNAL_UNDEFINED);
#define KSNODETYPE_EXTERNAL_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_EXTERNAL_UNDEFINED)

#define STATIC_KSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_CONNECTOR);
#define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_KSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LINE_CONNECTOR);
#define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)

#define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_KSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPDIF_INTERFACE);
#define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)

#define STATIC_KSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DA_STREAM);
#define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)

#define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_KSNODETYPE_EMBEDDED_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0700)
DEFINE_GUIDSTRUCT("DFF220E0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EMBEDDED_UNDEFINED);
#define KSNODETYPE_EMBEDDED_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_EMBEDDED_UNDEFINED)

#define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_KSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EQUALIZATION_NOISE);
#define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_KSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CD_PLAYER);
#define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)

#define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_KSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MINIDISK);
#define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)

#define STATIC_KSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_TAPE);
#define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)

#define STATIC_KSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONOGRAPH);
#define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)

#define STATIC_KSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VCR_AUDIO);
#define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)

#define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_DISC_AUDIO);
#define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_KSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DVD_AUDIO);
#define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)

#define STATIC_KSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TV_TUNER_AUDIO);
#define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CABLE_TUNER_AUDIO);
#define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_KSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DSS_AUDIO);
#define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)

#define STATIC_KSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_RECEIVER);
#define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)

#define STATIC_KSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_TRANSMITTER);
#define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_KSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MULTITRACK_RECORDER);
#define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_KSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SYNTHESIZER);
#define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)

#define STATIC_KSNODETYPE_HDMI_INTERFACE\
    0xd1b9cc2a, 0xf519, 0x417f, 0x91, 0xc9, 0x55, 0xfa, 0x65, 0x48, 0x10, 0x01
DEFINE_GUIDSTRUCT("D1B9CC2A-F519-417f-91C9-55FA65481001", KSNODETYPE_HDMI_INTERFACE);
#define KSNODETYPE_HDMI_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_HDMI_INTERFACE)

#define STATIC_KSNODETYPE_DISPLAYPORT_INTERFACE\
    0xe47e4031, 0x3ea6, 0x418d, 0x8f, 0x9b, 0xb7, 0x38, 0x43, 0xcc, 0xba, 0x97
DEFINE_GUIDSTRUCT("E47E4031-3EA6-418d-8F9B-B73843CCBA97", KSNODETYPE_DISPLAYPORT_INTERFACE);
#define KSNODETYPE_DISPLAYPORT_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DISPLAYPORT_INTERFACE)

// USB MIDI Nodes
#define STATIC_KSNODETYPE_MIDI_JACK\
    0x265e0c3f, 0xfa39, 0x4df3, 0xab, 0x04, 0xbe, 0x01, 0xb9, 0x1e, 0x29, 0x9a
DEFINE_GUIDSTRUCT("265E0C3F-FA39-4df3-AB04-BE01B91E299A", KSNODETYPE_MIDI_JACK);
#define KSNODETYPE_MIDI_JACK DEFINE_GUIDNAMED(KSNODETYPE_MIDI_JACK)

#define STATIC_KSNODETYPE_MIDI_ELEMENT\
    0x01c6fe66, 0x6e48, 0x4c65, 0xac, 0x9b, 0x52, 0xdb, 0x5d, 0x65, 0x6c, 0x7e
DEFINE_GUIDSTRUCT("01C6FE66-6E48-4c65-AC9B-52DB5D656C7E", KSNODETYPE_MIDI_ELEMENT);
#define KSNODETYPE_MIDI_ELEMENT DEFINE_GUIDNAMED(KSNODETYPE_MIDI_ELEMENT)


// GUID for Spdif Out pin name
#define STATIC_PINNAME_SPDIF_OUT\
    0x3a264481, 0xe52c, 0x4b82, 0x8e, 0x7a, 0xc8, 0xe2, 0xf9, 0x1d, 0xc3, 0x80
DEFINE_GUIDSTRUCT("3A264481-E52C-4b82-8E7A-C8E2F91DC380", PINNAME_SPDIF_OUT);
#define PINNAME_SPDIF_OUT DEFINE_GUIDNAMED(PINNAME_SPDIF_OUT)

// GUID for Spdif In pin name
#define STATIC_PINNAME_SPDIF_IN\
    0x15dc9025, 0x22ad, 0x41b3, 0x88, 0x75, 0xf4, 0xce, 0xb0, 0x29, 0x9e, 0x20
DEFINE_GUIDSTRUCT("15DC9025-22AD-41b3-8875-F4CEB0299E20", PINNAME_SPDIF_IN);
#define PINNAME_SPDIF_IN DEFINE_GUIDNAMED(PINNAME_SPDIF_IN)

// GUID for HDMI Out pin name
#define STATIC_PINNAME_HDMI_OUT\
    0x387bfc03, 0xe7ef, 0x4901, 0x86, 0xe0, 0x35, 0xb7, 0xc3, 0x2b, 0x0, 0xef
DEFINE_GUIDSTRUCT("387BFC03-E7EF-4901-86E0-35B7C32B00EF", PINNAME_HDMI_OUT);
#define PINNAME_HDMI_OUT DEFINE_GUIDNAMED(PINNAME_HDMI_OUT)

// GUID for Display Port Out pin name
#define STATIC_PINNAME_DISPLAYPORT_OUT\
    0x21fbb329, 0x1a4a, 0x48da, 0xa0, 0x76, 0x23, 0x18, 0xa3, 0xc5, 0x9b, 0x26
DEFINE_GUIDSTRUCT("21FBB329-1A4A-48da-A076-2318A3C59B26", PINNAME_DISPLAYPORT_OUT);
#define PINNAME_DISPLAYPORT_OUT DEFINE_GUIDNAMED(PINNAME_DISPLAYPORT_OUT)

#if (NTDDI_VERSION < NTDDI_VISTA)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_KSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", KSNODETYPE_SWSYNTH);
#define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_KSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", KSNODETYPE_SWMIDI);
#define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", KSNODETYPE_DRM_DESCRAMBLE);
#define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// General categories
#define STATIC_KSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_AUDIO);
#define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)

#define STATIC_KSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_VIDEO);
#define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define STATIC_KSCATEGORY_REALTIME \
    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", KSCATEGORY_REALTIME);
#define KSCATEGORY_REALTIME DEFINE_GUIDNAMED(KSCATEGORY_REALTIME)
#endif

#define STATIC_KSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_TEXT);
#define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)

#define STATIC_KSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", KSCATEGORY_NETWORK);
#define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)

#define STATIC_KSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", KSCATEGORY_TOPOLOGY);
#define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)

#define STATIC_KSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", KSCATEGORY_VIRTUAL);
#define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)

#define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#if (NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", KSCATEGORY_SYSAUDIO);
#define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)

#define STATIC_KSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", KSCATEGORY_WDMAUD);
#define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", KSCATEGORY_AUDIO_GFX);
#define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", KSCATEGORY_AUDIO_SPLITTER);
#define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_SYNTHESIZER STATIC_KSNODETYPE_SYNTHESIZER
#define KSCATEGORY_SYNTHESIZER KSNODETYPE_SYNTHESIZER

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSCATEGORY_DRM_DESCRAMBLE STATIC_KSNODETYPE_DRM_DESCRAMBLE
#define KSCATEGORY_DRM_DESCRAMBLE KSNODETYPE_DRM_DESCRAMBLE

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", KSCATEGORY_AUDIO_DEVICE);
#define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

// Special pin category for wdmaud

#define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", KSCATEGORY_WDMAUD_USE_PIN_NAME);
#define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_KSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_VIDEO);
#define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_KSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_AUDIO);
#define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)

// 'txts' == MEDIATYPE_Text
#define STATIC_KSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_TEXT);
#define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX )
#define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)
#endif

#if !defined( INIT_WAVEFORMATEX_GUID )
#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}
#endif

#if !defined( EXTRACT_WAVEFORMATEX_ID )
#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)
#endif

#if !defined( IS_VALID_WAVEFORMATEX_GUID )
#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))
#endif

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", KSDATAFORMAT_SUBTYPE_ANALOG);
#define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)

#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_PCM )
#define STATIC_KSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_PCM);
#define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)
#endif

#if defined(_INC_MMREG)
#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT )
#define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DRM);
#define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ALAW);
#define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MULAW);
#define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ADPCM);
#define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MPEG);
#define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
#endif // defined(_INC_MMREG)

#define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", KSDATAFORMAT_SPECIFIER_VC_ID);
#define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", KSDATAFORMAT_SPECIFIER_DSOUND);
#define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    KSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} KSDATAFORMAT_WAVEFORMATEX, *PKSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#ifndef _WAVEFORMATEXTENSIBLE_IEC61937_
#define _WAVEFORMATEXTENSIBLE_IEC61937_
typedef struct {
    WAVEFORMATEXTENSIBLE  FormatExt;    /* Format of encoded data as it is */
                                        /* intended to be streamed over the link */
    DWORD   dwEncodedSamplesPerSec;     /* Sampling rate of the post-decode audio. */
    DWORD   dwEncodedChannelCount;      /* Channel count of the post-decode audio. */
    DWORD   dwAverageBytesPerSec;       /* Byte rate of the content, can be 0. */
} WAVEFORMATEXTENSIBLE_IEC61937, *PWAVEFORMATEXTENSIBLE_IEC61937;
#endif // !_WAVEFORMATEXTENSIBLE_IEC61937_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC, *PKSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    KSDATAFORMAT        DataFormat;
    KSDSOUND_BUFFERDESC BufferDesc;
} KSDATAFORMAT_DSOUND, *PKSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define KSDSOUND_BUFFER_PRIMARY             0x00000001
#define KSDSOUND_BUFFER_STATIC              0x00000002
#define KSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define KSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define KSDSOUND_BUFFER_CTRL_3D             0x00000001
#define KSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define KSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define KSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} KSAUDIO_POSITION, *PKSAUDIO_POSITION;

//===========================================================================
// Microphone array pin descriptor

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum {
    KSMICARRAY_MICTYPE_OMNIDIRECTIONAL,
    KSMICARRAY_MICTYPE_SUBCARDIOID,
    KSMICARRAY_MICTYPE_CARDIOID,
    KSMICARRAY_MICTYPE_SUPERCARDIOID,
    KSMICARRAY_MICTYPE_HYPERCARDIOID,
    KSMICARRAY_MICTYPE_8SHAPED,
    KSMICARRAY_MICTYPE_VENDORDEFINED = 0x0F
} KSMICARRAY_MICTYPE;

typedef struct {
        USHORT usType;           // Type of Microphone
        SHORT  wXCoord;          // X Coordinate of Mic
        SHORT  wYCoord;          // Y Coordinate of Mic
        SHORT  wZCoord;          // Z Coordinate of Mic
        SHORT  wVerticalAngle;   // MRA Vertical Angle
        SHORT  wHorizontalAngle; // MRA Horizontal Angle
} KSAUDIO_MICROPHONE_COORDINATES, *PKSAUDIO_MICROPHONE_COORDINATES;

typedef enum {
    KSMICARRAY_MICARRAYTYPE_LINEAR,
    KSMICARRAY_MICARRAYTYPE_PLANAR,
    KSMICARRAY_MICARRAYTYPE_3D
} KSMICARRAY_MICARRAYTYPE;

typedef struct {
        USHORT usVersion;             // Version of Mic array specification (0x0100)
        USHORT usMicArrayType;        // Type of Mic Array
        SHORT  wVerticalAngleBegin;   // Work Volume Vertical Angle Begin
        SHORT  wVerticalAngleEnd;     // Work Volume Vertical Angle End
        SHORT  wHorizontalAngleBegin; // Work Volume HorizontalAngle Begin
        SHORT  wHorizontalAngleEnd;   // Work Volume HorizontalAngle End
        USHORT usFrequencyBandLo;     // Low end of Freq Range
        USHORT usFrequencyBandHi;     // High end of Freq Range
        
        USHORT usNumberOfMicrophones;  // Count of microphone 
                                   // coordinate structures 
                                   // to follow.

        KSAUDIO_MICROPHONE_COORDINATES KsMicCoord[1]; // Array of Microphone 
                                                  // Coordinate structures
} KSAUDIO_MIC_ARRAY_GEOMETRY, *PKSAUDIO_MIC_ARRAY_GEOMETRY;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// KSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DListener);
#define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)

typedef enum {
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} KSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} KSDS3D_LISTENER_ALL, *PKSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} KSDS3D_LISTENER_ORIENTATION, *PKSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// KSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DBuffer);
#define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)


typedef enum {
    KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} KSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} KSDS3D_BUFFER_ALL, *PKSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} KSDS3D_BUFFER_CONE_ANGLES, *PKSDS3D_BUFFER_CONE_ANGLES;

#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define KSDSOUND_3D_MODE_NORMAL          0x00000000
#define KSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define KSDSOUND_3D_MODE_DISABLE         0x00000002

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define KSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} KSDS3D_HRTF_PARAMS_MSG, *PKSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    KSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} KSDS3D_HRTF_INIT_MSG, *PKSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    KSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_KSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
    KSPROPERTY_HRTF3D_PARAMS = 0,
    KSPROPERTY_HRTF3D_INITIALIZE,
    KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} KSDS3D_ITD_PARAMS, *PKSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    KSDS3D_ITD_PARAMS     LeftParams;
    KSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} KSDS3D_ITD_PARAMS_MSG, *PKSDS3D_ITD_PARAMS_MSG;

#define STATIC_KSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
    KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;


typedef struct {
   KSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFF);
#define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", KSPROPSETID_Bibliographic);
#define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} KSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_KSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", KSPROPSETID_TopologyNode);
#define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)

typedef enum {
    KSPROPERTY_TOPOLOGYNODE_ENABLE = 1
#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KSPROPERTY_TOPOLOGYNODE_RESET
#endif // (NTDDI_VERSION >= NTDDI_WINXP)
} KSPROPERTY_TOPOLOGYNODE;

//===========================================================================

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)
typedef NTSTATUS (CALLBACK *PRTAUDIOGETPOSITION)(__in PFILE_OBJECT PinFileObject,
                                                 __out PUCHAR *ppPlayPosition,
                                                 __out PLONG plOffset);
#endif // defined(_NTDDK_)

#define STATIC_KSPROPSETID_RtAudio\
    0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", KSPROPSETID_RtAudio);
#define KSPROPSETID_RtAudio DEFINE_GUIDNAMED(KSPROPSETID_RtAudio)

typedef enum {
    KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
#if (NTDDI_VERSION >= NTDDI_VISTA)
    KSPROPERTY_RTAUDIO_BUFFER,
    KSPROPERTY_RTAUDIO_HWLATENCY,
    KSPROPERTY_RTAUDIO_POSITIONREGISTER,
    KSPROPERTY_RTAUDIO_CLOCKREGISTER,
    KSPROPERTY_RTAUDIO_BUFFER_WITH_NOTIFICATION,
    KSPROPERTY_RTAUDIO_REGISTER_NOTIFICATION_EVENT,
    KSPROPERTY_RTAUDIO_UNREGISTER_NOTIFICATION_EVENT,
#endif
#if (NTDDI_VERSION >= NTDDI_WIN7)
    KSPROPERTY_RTAUDIO_QUERY_NOTIFICATION_SUPPORT
#endif    
} KSPROPERTY_RTAUDIO;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
} KSRTAUDIO_BUFFER_PROPERTY, *PKSRTAUDIO_BUFFER_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
    ULONG       RequestedBufferSize;
} KSRTAUDIO_BUFFER_PROPERTY32, *PKSRTAUDIO_BUFFER_PROPERTY32;

typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
    ULONG       NotificationCount;
} KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION, *PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
    ULONG       RequestedBufferSize;
    ULONG       NotificationCount;
} KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32, *PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32;

typedef struct {
    PVOID   BufferAddress;
    ULONG   ActualBufferSize;
    BOOL    CallMemoryBarrier;
} KSRTAUDIO_BUFFER, *PKSRTAUDIO_BUFFER;

typedef struct {
    ULONG   BufferAddress;
    ULONG   ActualBufferSize;
    BOOL    CallMemoryBarrier;
} KSRTAUDIO_BUFFER32, *PKSRTAUDIO_BUFFER32;

typedef struct {
    ULONG   FifoSize;
    ULONG   ChipsetDelay;
    ULONG   CodecDelay;
} KSRTAUDIO_HWLATENCY, *PKSRTAUDIO_HWLATENCY;

typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
} KSRTAUDIO_HWREGISTER_PROPERTY, *PKSRTAUDIO_HWREGISTER_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
} KSRTAUDIO_HWREGISTER_PROPERTY32, *PKSRTAUDIO_HWREGISTER_PROPERTY32;

typedef struct {
    PVOID       Register;
    ULONG       Width;
    ULONGLONG   Numerator;
    ULONGLONG   Denominator;
    ULONG       Accuracy;
} KSRTAUDIO_HWREGISTER, *PKSRTAUDIO_HWREGISTER;

typedef struct {
    ULONG       Register;
    ULONG       Width;
    ULONGLONG   Numerator;
    ULONGLONG   Denominator;
    ULONG       Accuracy;
} KSRTAUDIO_HWREGISTER32, *PKSRTAUDIO_HWREGISTER32;

typedef struct {
    KSPROPERTY  Property;
    HANDLE      NotificationEvent;
} KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY, *PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       NotificationEvent;
} KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32, *PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
//===========================================================================
#define STATIC_KSPROPSETID_BtAudio\
    0x7FA06C40, 0xB8F6, 0x4C7E, 0x85, 0x56, 0xE8, 0xC3, 0x3A, 0x12, 0xE5, 0x4D
DEFINE_GUIDSTRUCT("7FA06C40-B8F6-4C7E-8556-E8C33A12E54D", KSPROPSETID_BtAudio);
#define KSPROPSETID_BtAudio DEFINE_GUIDNAMED(KSPROPSETID_BtAudio)

typedef enum {
    KSPROPERTY_ONESHOT_RECONNECT
};
#endif

//===========================================================================
#define STATIC_KSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", KSPROPSETID_DrmAudioStream);
#define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)

typedef enum {
    KSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} KSPROPERTY_DRMAUDIOSTREAM;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================
#define STATIC_KSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", KSPROPSETID_Audio);
#define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)

typedef enum {
    KSPROPERTY_AUDIO_LATENCY = 1,
    KSPROPERTY_AUDIO_COPY_PROTECTION,
    KSPROPERTY_AUDIO_CHANNEL_CONFIG,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_AUDIO_POSITION,
    KSPROPERTY_AUDIO_DYNAMIC_RANGE,
    KSPROPERTY_AUDIO_QUALITY,
    KSPROPERTY_AUDIO_SAMPLING_RATE,
    KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_AUDIO_BASS,
    KSPROPERTY_AUDIO_MID,
    KSPROPERTY_AUDIO_TREBLE,
    KSPROPERTY_AUDIO_BASS_BOOST,
    KSPROPERTY_AUDIO_EQ_LEVEL,
    KSPROPERTY_AUDIO_NUM_EQ_BANDS,
    KSPROPERTY_AUDIO_EQ_BANDS,
    KSPROPERTY_AUDIO_AGC,
    KSPROPERTY_AUDIO_DELAY,
    KSPROPERTY_AUDIO_LOUDNESS,
    KSPROPERTY_AUDIO_WIDE_MODE,                 //Reserved for system use
    KSPROPERTY_AUDIO_WIDENESS,
    KSPROPERTY_AUDIO_REVERB_LEVEL,
    KSPROPERTY_AUDIO_CHORUS_LEVEL,
    KSPROPERTY_AUDIO_DEV_SPECIFIC,
    KSPROPERTY_AUDIO_DEMUX_DEST,
    KSPROPERTY_AUDIO_STEREO_ENHANCE,            //Reserved for system use
    KSPROPERTY_AUDIO_MANUFACTURE_GUID,          //Reserved for system use
    KSPROPERTY_AUDIO_PRODUCT_GUID,              //Reserved for system use
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    KSPROPERTY_AUDIO_SURROUND_ENCODE,
    KSPROPERTY_AUDIO_3D_INTERFACE

#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KSPROPERTY_AUDIO_PEAKMETER
    , KSPROPERTY_AUDIO_ALGORITHM_INSTANCE
    , KSPROPERTY_AUDIO_FILTER_STATE
    , KSPROPERTY_AUDIO_PREFERRED_STATUS
    
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
    , KSPROPERTY_AUDIO_PEQ_MAX_BANDS
    , KSPROPERTY_AUDIO_PEQ_NUM_BANDS
    , KSPROPERTY_AUDIO_PEQ_BAND_CENTER_FREQ
    , KSPROPERTY_AUDIO_PEQ_BAND_Q_FACTOR
    , KSPROPERTY_AUDIO_PEQ_BAND_LEVEL
    , KSPROPERTY_AUDIO_CHORUS_MODULATION_RATE
    , KSPROPERTY_AUDIO_CHORUS_MODULATION_DEPTH
    , KSPROPERTY_AUDIO_REVERB_TIME
    , KSPROPERTY_AUDIO_REVERB_DELAY_FEEDBACK
    , KSPROPERTY_AUDIO_POSITIONEX
    , KSPROPERTY_AUDIO_MIC_ARRAY_GEOMETRY
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

} KSPROPERTY_AUDIO;

// Audio quality constants
#define KSAUDIO_QUALITY_WORST               0x0
#define KSAUDIO_QUALITY_PC                  0x1
#define KSAUDIO_QUALITY_BASIC               0x2
#define KSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define KSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} KSAUDIO_COPY_PROTECTION, *PKSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} KSAUDIO_CHANNEL_CONFIG, *PKSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KSAUDIO_SPEAKER_DIRECTOUT       0
#endif
#define KSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define KSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define KSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define KSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define KSAUDIO_SPEAKER_5POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_SIDE_LEFT  | SPEAKER_SIDE_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)
// The following are obsolete 5.1 and 7.1 settings (they lack side speakers).  Note this means
// that the default 5.1 and 7.1 settings (KSAUDIO_SPEAKER_5POINT1 and KSAUDIO_SPEAKER_7POINT1 are
// similarly obsolete but are unchanged for compatibility reasons).
#define KSAUDIO_SPEAKER_5POINT1_BACK     KSAUDIO_SPEAKER_5POINT1
#define KSAUDIO_SPEAKER_7POINT1_WIDE     KSAUDIO_SPEAKER_7POINT1

#endif // XP SP2 and later (chronologically)

// DVD Speaker Positions
#define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define KSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define KSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define KSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} KSAUDIO_DYNAMIC_RANGE, *PKSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} KSAUDIO_MIXLEVEL, *PKSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    union {
        LONG    Reset;
        LONG    Resolution;
    };
} KSAUDIO_MIX_CAPS, *PKSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    KSAUDIO_MIX_CAPS    Capabilities[1];
} KSAUDIO_MIXCAP_TABLE, *PKSAUDIO_MIXCAP_TABLE;

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef enum {              // preferred device index
    KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    BOOL                             Enable;
    KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
    ULONG                            Flags;
    ULONG                            Reserved;
} KSAUDIO_PREFERRED_STATUS, *PKSAUDIO_PREFERRED_STATUS;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct {
    LARGE_INTEGER       TimerFrequency;
    LARGE_INTEGER       TimeStamp1;
    KSAUDIO_POSITION    Position;
    LARGE_INTEGER       TimeStamp2;
} KSAUDIO_POSITIONEX, *PKSAUDIO_POSITIONEX;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//===========================================================================
// Topology Node Type GUIDs

#define STATIC_KSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DAC);
#define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)

#define STATIC_KSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_ADC);
#define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)

#define STATIC_KSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SRC);
#define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)

#define STATIC_KSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUPERMIX);
#define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)

#define STATIC_KSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUX);
#define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)

#define STATIC_KSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", KSNODETYPE_DEMUX);
#define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)

#define STATIC_KSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUM);
#define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)

#define STATIC_KSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUTE);
#define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)

#define STATIC_KSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_VOLUME);
#define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)

#define STATIC_KSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_TONE);
#define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)

#define STATIC_KSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_EQUALIZER);
#define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)

#define STATIC_KSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_AGC);
#define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", KSNODETYPE_NOISE_SUPPRESS);
#define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DELAY);
#define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)

#define STATIC_KSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_LOUDNESS);
#define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)

#define STATIC_KSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_PROLOGIC_DECODER);
#define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)

#define STATIC_KSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_STEREO_WIDE);
#define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)

#define STATIC_KSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_REVERB);
#define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)

#define STATIC_KSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_CHORUS);
#define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)

#define STATIC_KSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_3D_EFFECTS);
#define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)

#define STATIC_KSNODETYPE_PARAMETRIC_EQUALIZER\
    0x19bb3a6a, 0xce2b, 0x4442, 0x87, 0xec, 0x67, 0x27, 0xc3, 0xca, 0xb4, 0x77
DEFINE_GUIDSTRUCT("19BB3A6A-CE2B-4442-87EC-6727C3CAB477", KSNODETYPE_PARAMETRIC_EQUALIZER);
#define KSNODETYPE_PARAMETRIC_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_PARAMETRIC_EQUALIZER)

#define STATIC_KSNODETYPE_UPDOWN_MIX\
    0xb7edc5cf, 0x7b63, 0x4ee2, 0xa1, 0x0, 0x29, 0xee, 0x2c, 0xb6, 0xb2, 0xde
DEFINE_GUIDSTRUCT("B7EDC5CF-7B63-4ee2-A100-29EE2CB6B2DE", KSNODETYPE_UPDOWN_MIX);
#define KSNODETYPE_UPDOWN_MIX DEFINE_GUIDNAMED(KSNODETYPE_UPDOWN_MIX)

#define STATIC_KSNODETYPE_DYN_RANGE_COMPRESSOR\
    0x8c8a6a8, 0x601f, 0x4af8, 0x87, 0x93, 0xd9, 0x5, 0xff, 0x4c, 0xa9, 0x7d
DEFINE_GUIDSTRUCT("08C8A6A8-601F-4af8-8793-D905FF4CA97D", KSNODETYPE_DYN_RANGE_COMPRESSOR);
#define KSNODETYPE_DYN_RANGE_COMPRESSOR DEFINE_GUIDNAMED(KSNODETYPE_DYN_RANGE_COMPRESSOR)

#define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL\
    0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS\
    0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_AGC\
    0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", KSALGORITHMINSTANCE_SYSTEM_AGC);
#define KSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR\
    0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DEV_SPECIFIC);
#define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_PROLOGIC_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_PROLOGIC_ENCODER);
#define KSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_ENCODER)
#define KSNODETYPE_SURROUND_ENCODER KSNODETYPE_PROLOGIC_ENCODER

#define STATIC_KSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", KSNODETYPE_PEAKMETER);
#define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)

#define STATIC_KSNODETYPE_SURROUND_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_SURROUND_ENCODER);
#define KSNODETYPE_SURROUND_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_SURROUND_ENCODER)

#endif // (NTDDI_VERSION < NTDDI_WINXP)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_KSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_BASS);
#define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)

#define STATIC_KSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_TREBLE);
#define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)

#define STATIC_KSAUDFNAME_MIDRANGE\
    0xA2CBE478, 0xAE84, 0x49A1, 0x8B, 0x72, 0x4A, 0xD0, 0x9B, 0x78, 0xED, 0x34
DEFINE_GUIDSTRUCT("A2CBE478-AE84-49A1-8B72-4AD09B78ED34", KSAUDFNAME_MIDRANGE);
#define KSAUDFNAME_MIDRANGE DEFINE_GUIDNAMED(KSAUDFNAME_MIDRANGE)

#define STATIC_KSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_3D_STEREO);
#define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)

#define STATIC_KSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_VOLUME);
#define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)

#define STATIC_KSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_MUTE);
#define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)

#define STATIC_KSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_VOLUME);
#define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_MUTE);
#define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)

#define STATIC_KSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_VOLUME);
#define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)

#define STATIC_KSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_MUTE);
#define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)

#define STATIC_KSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_VOLUME);
#define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)

#define STATIC_KSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_MUTE);
#define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)

#define STATIC_KSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_VOLUME);
#define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)

#define STATIC_KSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_MUTE);
#define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)

#define STATIC_KSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_VOLUME);
#define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)

#define STATIC_KSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_MUTE);
#define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)

#define STATIC_KSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_SOURCE);
#define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)

#define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_VOLUME);
#define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_MUTE);
#define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_KSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_IN_VOLUME);
#define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_KSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_IN_VOLUME);
#define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)

#define STATIC_KSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN_VOLUME);
#define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_KSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_IN_VOLUME);
#define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_IN_VOLUME);
#define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_KSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_VOLUME_CONTROL);
#define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)

#define STATIC_KSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI);
#define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)

#define STATIC_KSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN);
#define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)

#define STATIC_KSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_CONTROL);
#define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)

#define STATIC_KSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_AUDIO);
#define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)

#define STATIC_KSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_VOLUME);
#define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)

#define STATIC_KSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_MUTE);
#define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)

#define STATIC_KSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX);
#define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)

#define STATIC_KSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER);
#define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)

#define STATIC_KSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_OUT_MIX);
#define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT);
#define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)

#define STATIC_KSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX);
#define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)

#define STATIC_KSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX);
#define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_VOLUME);
#define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_KSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_MUTE);
#define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_VOLUME);
#define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_MUTE);
#define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_VOLUME);
#define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_MUTE);
#define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MICROPHONE_BOOST);
#define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_ALTERNATE_MICROPHONE);
#define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_KSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_DEPTH);
#define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)

#define STATIC_KSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_CENTER);
#define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)

#define STATIC_KSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_VOLUME);
#define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)

#define STATIC_KSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_MUTE);
#define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)

#define STATIC_KSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", KSAUDFNAME_VIDEO);
#define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", KSAUDFNAME_PEAKMETER);
#define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)


// Internal topology node pin definitions

#define KSNODEPIN_STANDARD_IN       1
#define KSNODEPIN_STANDARD_OUT      0

#define KSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define KSNODEPIN_SUM_MUX_OUT       0

#define KSNODEPIN_DEMUX_IN          0
#define KSNODEPIN_DEMUX_OUT         1   // can be >= 1

#if (NTDDI_VERSION < NTDDI_VISTA)

#define KSNODEPIN_AEC_RENDER_IN     1
#define KSNODEPIN_AEC_RENDER_OUT    0
#define KSNODEPIN_AEC_CAPTURE_IN    2
#define KSNODEPIN_AEC_CAPTURE_OUT   3

#endif // (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
//===========================================================================

#define STATIC_KSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", KSMETHODSETID_Wavetable);
#define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)

typedef enum {
    KSMETHOD_WAVETABLE_WAVE_ALLOC,
    KSMETHOD_WAVETABLE_WAVE_FREE,
    KSMETHOD_WAVETABLE_WAVE_FIND,
    KSMETHOD_WAVETABLE_WAVE_WRITE
} KSMETHOD_WAVETABLE;

typedef struct {
    KSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    KSDATAFORMAT        Format;                         // wave format
} KSWAVETABLE_WAVE_DESC, *PKSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)
#define STATIC_KSPROPSETID_Acoustic_Echo_Cancel\
    0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", KSPROPSETID_Acoustic_Echo_Cancel);
#define KSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(KSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
    KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
    KSPROPERTY_AEC_STATUS,
    KSPROPERTY_AEC_MODE
} KSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED             0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED    0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED       0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED               0x8

#define AEC_MODE_PASS_THROUGH           0x0
#define AEC_MODE_HALF_DUPLEX            0x1
#define AEC_MODE_FULL_DUPLEX            0x2

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
//===========================================================================
#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Wave_Queued\
    0x16a15b10L, 0x16f0, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("16a15b10-16f0-11d0-a195-0020afd156e4", KSPROPSETID_Wave_Queued);
#define KSPROPSETID_Wave_Queued DEFINE_GUIDNAMED(KSPROPSETID_Wave_Queued)

#define KSPROPERTY_WAVE_QUEUED_POSITION                 0x00000001

#define STATIC_KSMETHODSETID_Wave_Queued\
    0x7432c160L, 0x8827, 0x11cf, 0xa1, 0x02, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("7432c160-8827-11cf-a102-0020afd156e4", KSMETHODSETID_Wave_Queued);
#define KSMETHODSETID_Wave_Queued DEFINE_GUIDNAMED(KSMETHODSETID_Wave_Queued)

#define KSMETHOD_WAVE_QUEUED_BREAKLOOP                  0x00000001

#endif // (NTDDI_VERSION < NTDDI_WS03)


#define STATIC_KSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", KSPROPSETID_Wave);
#define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)

typedef enum {
    KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    KSPROPERTY_WAVE_INPUT_CAPABILITIES,
    KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    KSPROPERTY_WAVE_BUFFER,
    KSPROPERTY_WAVE_FREQUENCY,
    KSPROPERTY_WAVE_VOLUME,
    KSPROPERTY_WAVE_PAN
} KSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} KSWAVE_COMPATCAPS, *PKSWAVE_COMPATCAPS;

#define KSWAVE_COMPATCAPS_INPUT                 0x00000000
#define KSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} KSWAVE_INPUT_CAPABILITIES, *PKSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} KSWAVE_OUTPUT_CAPABILITIES, *PKSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} KSWAVE_VOLUME, *PKSWAVE_VOLUME;

#define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define KSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} KSWAVE_BUFFER, *PKSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_KSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_PORT);
#define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)

#define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_SQSYNTH);
#define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_FMSYNTH);
#define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_WAVETABLE);
#define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", KSMUSIC_TECHNOLOGY_SWSYNTH);
#define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_WaveTable\
    0x8539E660L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8539E660-62E9-11CF-A5D6-28DB04C10000", KSPROPSETID_WaveTable);
#define KSPROPSETID_WaveTable DEFINE_GUIDNAMED(KSPROPSETID_WaveTable)

typedef enum {
    KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_MEMORY,
    KSPROPERTY_WAVETABLE_VERSION
} KSPROPERTY_WAVETABLE;

#endif // (NTDDI_VERSION < NTDDI_WS03)

typedef struct {
   KSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} KSDATARANGE_MUSIC, *PKSDATARANGE_MUSIC;

//===========================================================================

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", KSEVENTSETID_Cyclic);
#define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)

typedef enum {
    KSEVENT_CYCLIC_TIME_INTERVAL,
} KSEVENT_CYCLIC_TIME;

#endif // (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Cyclic\
    0x3FFEAEA0L, 0x2BEE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000", KSPROPSETID_Cyclic);
#define KSPROPSETID_Cyclic DEFINE_GUIDNAMED(KSPROPSETID_Cyclic)

typedef enum {
    KSPROPERTY_CYCLIC_POSITION,
} KSPROPERTY_CYCLIC;

//===========================================================================
#define STATIC_KSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", KSEVENTSETID_AudioControlChange);
#define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)

typedef enum {
    KSEVENT_CONTROL_CHANGE,
} KSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================

#define STATIC_KSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", KSEVENTSETID_LoopedStreaming);
#define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)

typedef enum {
    KSEVENT_LOOPEDSTREAMING_POSITION,
} KSEVENT_LOOPEDSTREAMING;

typedef struct {
    KSEVENTDATA KsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;

#if (NTDDI_VERSION <= NTDDI_WINXP)

#define STATIC_KSEVENTSETID_Sysaudio \
    0x04800320L, 0x4491, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("04800320-4491-11D1-A050-405705C10000", KSEVENTSETID_Sysaudio);
#define KSEVENTSETID_Sysaudio DEFINE_GUIDNAMED(KSEVENTSETID_Sysaudio)

typedef enum {
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE
#if (NTDDI_VERSION == NTDDI_WINXP)
    , KSEVENT_SYSAUDIO_CHANGE_DEVICE
#endif
} KSEVENT_SYSAUDIO;

#endif // (NTDDI_VERSION <= NTDDI_WINXP)


#if (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
#define STATIC_KSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio);
#define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
    KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16,
} KSPROPERTY_SYSAUDIO;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
    KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK,
    KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES,
    KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
    KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE
} KSPROPERTY_SYSAUDIO;

#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)


#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG Index;            // KSPROPERTY_SYSAUDIO_DEFAULT_TYPE
} SYSAUDIO_PREFERRED_DEVICE, *PSYSAUDIO_PREFERRED_DEVICE;

#define SYSAUDIO_FLAGS_CLEAR_PREFERRED          0x00000002
#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)


#define STATIC_KSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio_Pin);
#define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef enum {
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1,
} KSPROPERTY_SYSAUDIO_PIN;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)

typedef enum {
    KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE
} KSPROPERTY_SYSAUDIO_PIN;

#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
typedef struct {
    KSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} KSNODEPROPERTY, *PKSNODEPROPERTY;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} KSNODEPROPERTY_AUDIO_CHANNEL, *PKSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} KSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_3D_LISTENER, *PKSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_PROPERTY, *PKSNODEPROPERTY_AUDIO_PROPERTY;

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
// {79A9312E-59AE-43b0-A350-8B05284CAB24}
#define STATIC_KSPROPSETID_AudioGfx\
    0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", KSPROPSETID_AudioGfx);
#define KSPROPSETID_AudioGfx DEFINE_GUIDNAMED(KSPROPSETID_AudioGfx)

typedef enum {
    KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
    KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} KSPROPERTY_AUDIOGFX;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Linear\
    0x5A2FFE80L, 0x16B9, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("5A2FFE80-16B9-11D0-A5D6-28DB04C10000", KSPROPSETID_Linear);
#define KSPROPSETID_Linear DEFINE_GUIDNAMED(KSPROPSETID_Linear)

typedef enum {
    KSPROPERTY_LINEAR_POSITION,
} KSPROPERTY_LINEAR;

#endif // (NTDDI_VERSION < NTDDI_WS03)

//===========================================================================


//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_KSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", KSDATAFORMAT_TYPE_MUSIC);
#define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_KSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_MIDI);
#define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI);
#define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    KSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicKS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the KSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} KSMUSICFORMAT, *PKSMUSICFORMAT;

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new KS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with KS_MPEGVIDEOINFO2 defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with KS_MPEGAUDIOINFO defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Video);
#define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PES);
#define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_KSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", KSPROPSETID_Mpeg2Vid);
#define  KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( KSPROPSETID_Mpeg2Vid )


typedef enum {
    KSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    KSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    KSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    KSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    KSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} KSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define KSMPEGVIDMODE_PANSCAN   0x0001
#define KSMPEGVIDMODE_LTRBOX    0x0002
#define KSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _KSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} KSMPEGVID_RECT, *PKSMPEGVID_RECT;

//
// Params for pan / scan
//


//
// MPEG2 Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_KSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", KSPROPSETID_AC3);
#define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)

typedef enum {
    KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    KSPROPERTY_AC3_ALTERNATE_AUDIO,
    KSPROPERTY_AC3_DOWNMIX,
    KSPROPERTY_AC3_BIT_STREAM_MODE,
    KSPROPERTY_AC3_DIALOGUE_LEVEL,
    KSPROPERTY_AC3_LANGUAGE_CODE,
    KSPROPERTY_AC3_ROOM_TYPE
} KSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} KSAC3_ERROR_CONCEALMENT, *PKSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} KSAC3_ALTERNATE_AUDIO, *PKSAC3_ALTERNATE_AUDIO;

#define KSAC3_ALTERNATE_AUDIO_1     1
#define KSAC3_ALTERNATE_AUDIO_2     2
#define KSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} KSAC3_DOWNMIX, *PKSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} KSAC3_BIT_STREAM_MODE, *PKSAC3_BIT_STREAM_MODE;

#define KSAC3_SERVICE_MAIN_AUDIO            0
#define KSAC3_SERVICE_NO_DIALOG             1
#define KSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define KSAC3_SERVICE_HEARING_IMPAIRED      3
#define KSAC3_SERVICE_DIALOG_ONLY           4
#define KSAC3_SERVICE_COMMENTARY            5
#define KSAC3_SERVICE_EMERGENCY_FLASH       6
#define KSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} KSAC3_DIALOGUE_LEVEL, *PKSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} KSAC3_ROOM_TYPE, *PKSAC3_ROOM_TYPE;

// New formats enabled by CEA 861 specifciation
#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DOLBY_AC3_SPDIF)
DEFINE_GUIDSTRUCT("00000092-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_WMASPDIF)
DEFINE_GUIDSTRUCT("00000164-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO);
#define KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DTS\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DTS)
DEFINE_GUIDSTRUCT("00000008-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DTS);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1 \
    0x00000003L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000003-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2 \
    0x00000004L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000004-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3 \
    0x00000005L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000005-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_AAC \
    0x00000006L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000006-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_AAC);
#define KSDATAFORMAT_SUBTYPE_IEC61937_AAC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_AAC)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC \
    0x00000008L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000008-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC);
#define KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO \
    0x00000009L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000009-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO);
#define KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS \
    0x0000000aL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000a-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD \
    0x0000000bL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000b-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP \
    0x0000000cL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000c-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DST \
    0x0000000dL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000d-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DST);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DST DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DST)


#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
// audio decoder output properties
//

#define STATIC_KSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", KSPROPSETID_AudioDecoderOut);
#define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)

typedef enum {
    KSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    KSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} KSPROPERTY_AUDDECOUT;

#define KSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define KSAUDDECOUTMODE_PCM_51          0x0002
#define KSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_KSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", KSPROPSETID_DvdSubPic);
#define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)

typedef enum {
    KSPROPERTY_DVDSUBPIC_PALETTE,
    KSPROPERTY_DVDSUBPIC_HLI,
    KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} KSPROPERTY_DVDSUBPIC;

typedef struct _KS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} KS_DVD_YCrCb, *PKS_DVD_YCrCb;

/* The KS_DVD_YUV structure is now superseded by KS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _KS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} KS_DVD_YUV, *PKS_DVD_YUV;

typedef struct _KSPROPERTY_SPPAL {
    KS_DVD_YUV sppal[16];
} KSPROPERTY_SPPAL, *PKSPROPERTY_SPPAL;

typedef struct _KS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} KS_COLCON, *PKS_COLCON;

typedef struct _KSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    KS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} KSPROPERTY_SPHLI, *PKSPROPERTY_SPHLI;

typedef BOOL KSPROPERTY_COMPOSIT_ON, *PKSPROPERTY_COMPOSIT_ON;

#define STATIC_KSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", KSPROPSETID_CopyProt);
#define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)

typedef enum {

    KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    KSPROPERTY_DVDCOPY_DVD_KEY1,
    KSPROPERTY_DVDCOPY_DEC_KEY2,
    KSPROPERTY_DVDCOPY_TITLE_KEY,
    KSPROPERTY_COPY_MACROVISION,
    KSPROPERTY_DVDCOPY_REGION,
    KSPROPERTY_DVDCOPY_SET_COPY_STATE,
    KSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} KSPROPERTY_COPYPROT;

typedef struct _KS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} KS_DVDCOPY_CHLGKEY, *PKS_DVDCOPY_CHLGKEY;

typedef struct _KS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} KS_DVDCOPY_BUSKEY, *PKS_DVDCOPY_BUSKEY;


typedef struct _KS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} KS_DVDCOPY_DISCKEY, *PKS_DVDCOPY_DISCKEY;

typedef struct _KS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} KS_DVDCOPY_REGION, *PKS_DVDCOPY_REGION;

typedef struct _KS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} KS_DVDCOPY_TITLEKEY, *PKS_DVDCOPY_TITLEKEY;

typedef struct _KS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} KS_COPY_MACROVISION, *PKS_COPY_MACROVISION;

typedef struct _KS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} KS_DVDCOPY_SET_COPY_STATE, *PKS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    KS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    KS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    KS_DVDCOPYSTATE_DONE,
} KS_DVDCOPYSTATE;

typedef enum {
    KS_MACROVISION_DISABLED,
    KS_MACROVISION_LEVEL1,
    KS_MACROVISION_LEVEL2,
    KS_MACROVISION_LEVEL3
} KS_COPY_MACROVISION_LEVEL, *PKS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define KS_DVD_CGMS_RESERVED_MASK      0x00000078

#define KS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define KS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define KS_DVD_CGMS_COPY_ONCE          0x00000010
#define KS_DVD_CGMS_NO_COPY            0x00000018

#define KS_DVD_COPYRIGHT_MASK          0x00000040
#define KS_DVD_NOT_COPYRIGHTED         0x00000000
#define KS_DVD_COPYRIGHTED             0x00000040

#define KS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define KS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define KS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_KSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVTUNER);
#define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)

#define STATIC_KSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_CROSSBAR);
#define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)

#define STATIC_KSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVAUDIO);
#define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)

#define STATIC_KSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_VPMUX);
#define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)

#define STATIC_KSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", KSCATEGORY_VBICODEC);
#define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)

// SUBTYPE_VPVideo
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVideo);
#define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)

// SUBTYPE_VPVBI
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVBI);
#define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)


// FORMAT_VideoInfo
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGVIDEO);
#define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

// MEDIATYPE_AnalogAudio
#define STATIC_KSDATAFORMAT_TYPE_ANALOGAUDIO \
    0x0482dee1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGAUDIO);
#define KSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGAUDIO)

#endif // XP SP2 and later (chronologically)

// FORMAT_VBI
#define STATIC_KSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VBI);
#define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_KSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_TYPE_VBI);
#define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_KSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", KSDATAFORMAT_SUBTYPE_RAW8);
#define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// MEDIASUBTYPE_CC
#define STATIC_KSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", KSDATAFORMAT_SUBTYPE_CC);
#define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// MEDIASUBTYPE_NABTS
#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_NABTS);
#define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_TELETEXT);
#define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define KS_BI_RGB        0L
#define KS_BI_RLE8       1L
#define KS_BI_RLE4       2L
#define KS_BI_BITFIELDS  3L

typedef struct tagKS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} KS_RGBQUAD, *PKS_RGBQUAD;

/* constants for palettes */
#define KS_iPALETTE_COLORS 256     // Maximum colours in palette
#define KS_iEGA_COLORS 16          // Number colours in EGA palette
#define KS_iMASK_COLORS 3          // Maximum three components
#define KS_iTRUECOLOR 16           // Minimum true colour device
#define KS_iRED 0                  // Index position for RED mask
#define KS_iGREEN 1                // Index position for GREEN mask
#define KS_iBLUE 2                 // Index position for BLUE mask
#define KS_iPALETTE 8              // Maximum colour depth using a palette
#define KS_iMAXBITS 8              // Maximum bits per colour component
#define KS_SIZE_EGA_PALETTE (KS_iEGA_COLORS * sizeof(KS_RGBQUAD))
#define KS_SIZE_PALETTE (KS_iPALETTE_COLORS * sizeof(KS_RGBQUAD))

typedef struct tagKS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} KS_BITMAPINFOHEADER, *PKS_BITMAPINFOHEADER;

// Used for true colour images that also have a palette

typedef struct tag_KS_TRUECOLORINFO {
    DWORD   dwBitMasks[KS_iMASK_COLORS];
    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
} KS_TRUECOLORINFO, *PKS_TRUECOLORINFO;


#define KS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define KS_DIBWIDTHBYTES(bi) (DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define KS__DIBSIZE(bi) (KS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define KS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagKS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

} KS_VIDEOINFOHEADER, *PKS_VIDEOINFOHEADER;

// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagKS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

    union {
        KS_RGBQUAD          bmiColors[KS_iPALETTE_COLORS];     // Colour palette
        DWORD               dwBitMasks[KS_iMASK_COLORS];       // True colour masks
        KS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} KS_VIDEOINFO, *PKS_VIDEOINFO;


#define KS_SIZE_MASKS (KS_iMASK_COLORS * sizeof(DWORD))
#define KS_SIZE_PREHEADER (FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define KS_SIZE_VIDEOHEADER (sizeof(KS_BITMAPINFOHEADER) + KS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define KS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast, WST
typedef struct tagKS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // KS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} KS_VBIINFOHEADER, *PKS_VBIINFOHEADER;

#if (NTDDI_VERSION >= NTDDI_WINXP)

// VBI Sampling Rates
#define KS_VBIDATARATE_NABTS            (5727272L)
#define KS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define KS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER (KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagKS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} KS_ANALOGVIDEOINFO, *PKS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define KS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define KS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagKS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // KS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // KS_AnalogVideoStandard
   DWORD                    dwChannel;
} KS_TVTUNER_CHANGE_INFO, *PKS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format blocks
//===========================================================================

typedef enum {
    KS_MPEG2Level_Low,
    KS_MPEG2Level_Main,
    KS_MPEG2Level_High1440,
    KS_MPEG2Level_High
} KS_MPEG2Level;

typedef enum {
    KS_MPEG2Profile_Simple,
    KS_MPEG2Profile_Main,
    KS_MPEG2Profile_SNRScalable,
    KS_MPEG2Profile_SpatiallyScalable,
    KS_MPEG2Profile_High
} KS_MPEG2Profile;

#define KS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define KS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define KS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define KS_INTERLACE_UNUSED                  0x00000008  //
#define KS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define KS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define KS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define KS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define KS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define KS_INTERLACE_DisplayModeMask         0x000000c0
#define KS_INTERLACE_DisplayModeBobOnly      0x00000000
#define KS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define KS_INTERLACE_DisplayModeBobOrWeave   0x00000080

#define KS_COPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define KS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define KS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define KS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define KS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define KS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define KS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define KS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define KS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define KS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define KS_MPEG2_WidescreenAnalogOut 0x00000200  //if set and this stream is sent to an analog output, it should
                        //  be in widescreen format (4x3 content should be centered on a 16x9 output).
                        //  Streams sent to VGA should be widescreened only by renderers.

#define KS_AMCONTROL_USED              0x00000001 // Used to test if these flags are supported.  Set and test for AcceptMediaType.
                                                // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1)
#define KS_AMCONTROL_PAD_TO_4x3        0x00000002 // if set means display the image in a 4x3 area
#define KS_AMCONTROL_PAD_TO_16x9       0x00000004 // if set means display the image in a 16x9 area
#define KS_AMCONTROL_COLORINFO_PRESENT 0x00000080 // if set, indicates DXVA color info is present in the upper (24) bits of the dwControlFlags

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct tagKS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use KS_COPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD dwControlFlags;               // use KS_AMCONTROL_* defines, use this from now on
        DWORD dwReserved1;                  // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    };
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER2, *PKS_VIDEOINFOHEADER2;

typedef struct tagKS_MPEG1VIDEOINFO {
    KS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} KS_MPEG1VIDEOINFO, *PKS_MPEG1VIDEOINFO;

#define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define KS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(KS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagKS_MPEGVIDEOINFO2 {
    KS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} KS_MPEGVIDEOINFO2, *PKS_MPEGVIDEOINFO2;


#define KS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(KS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format blocks
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define KS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagKS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use KS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} KS_MPEGAUDIOINFO, *PKS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER      VideoInfoHeader;
} KS_DATAFORMAT_VIDEOINFOHEADER, *PKS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2 {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER2     VideoInfoHeader2;
} KS_DATAFORMAT_VIDEOINFOHEADER2, *PKS_DATAFORMAT_VIDEOINFOHEADER2;

typedef struct tagKS_DATAFORMAT_MPEGVIDEOINFO2 {
    KSDATAFORMAT            DataFormat;
    KS_MPEGVIDEOINFO2       MpegVideoInfoHeader2;
} KS_DATAFORMAT_MPEGVIDEOINFO2, *PKS_DATAFORMAT_MPEGVIDEOINFO2;

typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFO            VideoInfo;
} KS_DATAFORMAT_VIDEOINFO_PALETTE, *PKS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagKS_DATAFORMAT_VBIINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_DATAFORMAT_VBIINFOHEADER, *PKS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _KS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} KS_VIDEO_STREAM_CONFIG_CAPS, *PKS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagKS_DATARANGE_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO, *PKS_DATARANGE_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO2 {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO2, *PKS_DATARANGE_VIDEO2;

typedef struct tagKS_DATARANGE_MPEG1_VIDEO {
    KSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // KS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // KS_VIDEO_ALLOC_*
    KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    KS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} KS_DATARANGE_MPEG1_VIDEO, *PKS_DATARANGE_MPEG1_VIDEO;

typedef struct tagKS_DATARANGE_MPEG2_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} KS_DATARANGE_MPEG2_VIDEO, *PKS_DATARANGE_MPEG2_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO_PALETTE {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFO                 VideoInfo;              // default format
} KS_DATARANGE_VIDEO_PALETTE, *PKS_DATARANGE_VIDEO_PALETTE;

typedef struct tagKS_DATARANGE_VIDEO_VBI {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VBIINFOHEADER             VBIInfoHeader;          // default format
} KS_DATARANGE_VIDEO_VBI, *PKS_DATARANGE_VIDEO_VBI;

typedef struct tagKS_DATARANGE_ANALOGVIDEO {
   KSDATARANGE                  DataRange;
   KS_ANALOGVIDEOINFO           AnalogVideoInfo;
} KS_DATARANGE_ANALOGVIDEO, *PKS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define KS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define KS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define KS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define KS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define KS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define KS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define KS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define KS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define KS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define KS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define KS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define KS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory

#if (NTDDI_VERSION >= NTDDI_WINXP)

//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_KSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", KSPROPSETID_VBICAP_PROPERTIES);
#define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} KSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define KS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define KS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define KS_VBICAP_PROTECTION_MV_DETECTED    0x0004L

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networks in network television data
#define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_KSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_TYPE_NABTS);
#define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_KSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", KSPROPSETID_VBICodecFiltering);
#define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)

typedef enum {
    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_STATISTICS,
} KSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see KS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

// These KS_CC_SUBSTREAM_* bitmasks are used with VBICODECFILTERING_CC_SUBSTREAMS
#define KS_CC_SUBSTREAM_ODD               0x0001L // Unfiltered Field 1 Data
#define KS_CC_SUBSTREAM_EVEN              0x0002L // Unfiltered Field 2 Data

#if (NTDDI_VERSION >= NTDDI_WINXP)

// The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
#define KS_CC_SUBSTREAM_FIELD1_MASK       0x00F0L
#define KS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define KS_CC_SUBSTREAM_SERVICE_CC2       0x0020L
#define KS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define KS_CC_SUBSTREAM_SERVICE_T2        0x0080L

// The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
#define KS_CC_SUBSTREAM_FIELD2_MASK       0x1F00L
#define KS_CC_SUBSTREAM_SERVICE_CC3       0x0100L
#define KS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define KS_CC_SUBSTREAM_SERVICE_T3        0x0400L
#define KS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define KS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

// Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
// If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // KS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

//////////////////////////////////////////////////////////////
// WST Codec Teletext Media Sample Format
//////////////////////////////////////////////////////////////

#define WST_TVTUNER_CHANGE_BEGIN_TUNE    0x1000L  // Starting a tuning operation
#define WST_TVTUNER_CHANGE_END_TUNE      0x2000L  // Ending a tuning operation

#define MAX_WST_VBI_LINES_PER_FIELD   17
#define WST_BYTES_PER_LINE            42

typedef struct _WST_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE, *PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
    VBICODECFILTERING_SCANLINES        ScanlinesRequested;
    WST_BUFFER_LINE                    WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER, *PWST_BUFFER;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received KS_TVTUNER_CHANGE_BEGIN_TUNE and KS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received KS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// Codec-specific statistics - Teletext
//

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_TELETEXT, *PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN, *PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on KSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} KSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)

// KSPROPSETID_VIDMEM_TRANSPORT related guids, structs and enums
//===========================================================================

//
// Capture MemoryAllocationFlags
//
typedef enum {
        KS_CAPTURE_ALLOC_INVALID                = 0,
        KS_CAPTURE_ALLOC_SYSTEM                 = 0x0001,  // surface in system memory
        KS_CAPTURE_ALLOC_VRAM                   = 0x0002,  // surface in display memory
        KS_CAPTURE_ALLOC_SYSTEM_AGP             = 0x0004,  // surface in system memory tagged as AGP accessible
        KS_CAPTURE_ALLOC_VRAM_MAPPED    = 0x0008   // surface in system memory mapped into VRAM address space
}CAPTURE_MEMORY_ALLOCATION_FLAGS, *PCAPTURE_MEMORY_ALLOCATION_FLAGS;

//
//Video memory capture KSPROPSETID
//
#define STATIC_KSPROPSETID_VramCapture\
    0xe73face3, 0x2880, 0x4902, 0xb7, 0x99, 0x88, 0xd0, 0xcd, 0x63, 0x4e, 0xf
DEFINE_GUIDSTRUCT("E73FACE3-2880-4902-B799-88D0CD634E0F", KSPROPSETID_VramCapture);
#define KSPROPSETID_VramCapture DEFINE_GUIDNAMED(KSPROPSETID_VramCapture)

typedef enum { 
    //
    // enum value '0' means an invalid KSPROPERTY request. 
    // Drivers should return an error.
    //
    KSPROPERTY_DISPLAY_ADAPTER_GUID = 1,                        //Returns the Adapter GUID. 
    KSPROPERTY_PREFERRED_CAPTURE_SURFACE,                       //Returns the memory surface preferred by that pin
    KSPROPERTY_CURRENT_CAPTURE_SURFACE,                         //Sets/Gets currently selected capture surface
    KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS       //Maps VRAM surface handle to VRAM physical address
} KSPROPERTY_VIDMEM_TRANSPORT;

#define DEFINE_KSPROPERTY_ITEM_DISPLAY_ADAPTER_GUID(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_DISPLAY_ADAPTER_GUID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        NULL,\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_PREFERRED_CAPTURE_SURFACE(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PREFERRED_CAPTURE_SURFACE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(CAPTURE_MEMORY_ALLOCATION_FLAGS),\
        NULL,\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_CURRENT_CAPTURE_SURFACE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CURRENT_CAPTURE_SURFACE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(CAPTURE_MEMORY_ALLOCATION_FLAGS),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS,\
        (GetHandler),\
        sizeof(VRAM_SURFACE_INFO_PROPERTY_S),\
        sizeof(DWORD),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//
//Surface info passed on to the mini driver. 
//
typedef struct {
    UINT_PTR hSurface;
    LONGLONG VramPhysicalAddress;
    DWORD cbCaptured;
    DWORD dwWidth; 
    DWORD dwHeight;
    DWORD dwLinearSize;
    LONG  lPitch;  
    ULONGLONG ullReserved[16];
} VRAM_SURFACE_INFO, *PVRAM_SURFACE_INFO;

typedef struct {
        KSPROPERTY Property;
        PVRAM_SURFACE_INFO pVramSurfaceInfo;
}VRAM_SURFACE_INFO_PROPERTY_S, *PVRAM_SURFACE_INFO_PROPERTY_S;


#define STATIC_KSPROPSETID_MPEG4_MediaType_Attributes\
    0xff6c4bfa, 0x7a9, 0x4c7b, 0xa2, 0x37, 0x67, 0x2f, 0x9d, 0x68, 0x6, 0x5f
DEFINE_GUIDSTRUCT("FF6C4BFA-07A9-4c7b-A237-672F9D68065F", KSPROPSETID_MPEG4_MediaType_Attributes);
#define KSPROPSETID_MPEG4_MediaType_Attributes DEFINE_GUIDNAMED(KSPROPSETID_MPEG4_MediaType_Attributes)

typedef enum {
    KSPROPERTY_MPEG4_MEDIATYPE_SD_BOX = 1
}KSPROPERTY_MPEG4_MEDIATYPE_ATTRIBUTES;

#define STATIC_KSEVENTSETID_DynamicFormatChange\
    0x162ac456, 0x83d7, 0x4239, 0x96, 0xdf, 0xc7, 0x5f, 0xfa, 0x13, 0x8b, 0xc6
DEFINE_GUIDSTRUCT("162AC456-83D7-4239-96DF-C75FFA138BC6", KSEVENTSETID_DynamicFormatChange);
#define KSEVENTSETID_DynamicFormatChange DEFINE_GUIDNAMED(KSEVENTSETID_DynamicFormatChange)

typedef enum {
	KSEVENT_DYNAMIC_FORMAT_CHANGE = 0
};

//===========================================================================
// KSSTREAM_HEADER extensions for digital video
//===========================================================================

#define KS_VIDEO_FLAG_FIELD_MASK   0x0003L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FRAME        0x0000L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FIELD1       0x0001L
#define KS_VIDEO_FLAG_FIELD2       0x0002L
#define KS_VIDEO_FLAG_FIELD1FIRST  0x0004L
#define KS_VIDEO_FLAG_WEAVE        0x0008L

#define KS_VIDEO_FLAG_IPB_MASK     0x0030L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_I_FRAME      0x0000L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_P_FRAME      0x0010L
#define KS_VIDEO_FLAG_B_FRAME      0x0020L
#define KS_VIDEO_FLAG_REPEAT_FIELD 0x0040L


typedef struct tagKS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    union {
    	LONG                    lSurfacePitch;
  // Contains surface pitch a.k.a stride
        DWORD                   Reserved1;
    };
    // Reserved fields, never reference these
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} KS_FRAME_INFO, *PKS_FRAME_INFO;

//===========================================================================
// KSSTREAM_HEADER extensions for VBI
//===========================================================================

#if (NTDDI_VERSION < NTDDI_WINXP)
#define KS_VBI_FLAG_FRAME                0x0000L // Frame or Field (default is frame)
#endif
#define KS_VBI_FLAG_FIELD1               0x0001L
#define KS_VBI_FLAG_FIELD2               0x0002L

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KS_VBI_FLAG_MV_PRESENT           0x0100L
#define KS_VBI_FLAG_MV_HARDWARE          0x0200L
#define KS_VBI_FLAG_MV_DETECTED          0x0400L
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define KS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagKS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    KS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    KS_VBIINFOHEADER        VBIInfoHeader;
    //
    //The following are for VRAM surface transport to support LDDM Capture
    //
        //VRAM_SURFACE_INFO             VramSurfaceInfo;    
} KS_VBI_FRAME_INFO, *PKS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================

typedef enum
{
    KS_AnalogVideo_None     = 0x00000000,  // This is a digital sensor
    KS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    KS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    KS_AnalogVideo_NTSC_433 = 0x00000004,

    KS_AnalogVideo_PAL_B    = 0x00000010,
    KS_AnalogVideo_PAL_D    = 0x00000020,
    KS_AnalogVideo_PAL_G    = 0x00000040,
    KS_AnalogVideo_PAL_H    = 0x00000080,
    KS_AnalogVideo_PAL_I    = 0x00000100,
    KS_AnalogVideo_PAL_M    = 0x00000200,
    KS_AnalogVideo_PAL_N    = 0x00000400,

    KS_AnalogVideo_PAL_60   = 0x00000800,

    KS_AnalogVideo_SECAM_B  = 0x00001000,
    KS_AnalogVideo_SECAM_D  = 0x00002000,
    KS_AnalogVideo_SECAM_G  = 0x00004000,
    KS_AnalogVideo_SECAM_H  = 0x00008000,
    KS_AnalogVideo_SECAM_K  = 0x00010000,
    KS_AnalogVideo_SECAM_K1 = 0x00020000,
    KS_AnalogVideo_SECAM_L  = 0x00040000,
    KS_AnalogVideo_SECAM_L1 = 0x00080000

#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KS_AnalogVideoStandard;

#define KS_AnalogVideo_NTSC_Mask  0x00000007
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KS_AnalogVideo_PAL_Mask   0x00100FF0
#else
#define KS_AnalogVideo_PAL_Mask   0x00000FF0
#endif
#define KS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE      // R O (return 2 DWORDs specifying surface size)

#if (NTDDI_VERSION >= NTDDI_WINXP)

    // W I (informn a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS
 
    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KSPROPERTY_ALLOCATOR_CONTROL;

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct {
    //KSPROPERTY Property;
    ULONG       CX;
        ULONG   CY;
} KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S; 
 
typedef struct {
    //KSPROPERTY Property;
    ULONG       InterleavedCapSupported;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

 
typedef struct {
    //KSPROPERTY Property;
    ULONG       InterleavedCapPossible;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_CONTRAST,                   // RW O
    KSPROPERTY_VIDEOPROCAMP_HUE,                        // RW O
    KSPROPERTY_VIDEOPROCAMP_SATURATION,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_SHARPNESS,                  // RW O
    KSPROPERTY_VIDEOPROCAMP_GAMMA,                      // RW O
    KSPROPERTY_VIDEOPROCAMP_COLORENABLE,                // RW O
    KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,               // RW O
    KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION      // RW O

#if (NTDDI_VERSION >= NTDDI_WINXP)

    , KSPROPERTY_VIDEOPROCAMP_GAIN                      // RW O

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER        // RW O
    , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER_LIMIT  // RW O
    , KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE_COMPONENT    // RW O
    , KSPROPERTY_VIDEOPROCAMP_POWERLINE_FREQUENCY       // RW O    

#endif // XP SP2 and later (chronologically)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    KSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_S, *PKSPROPERTY_VIDEOPROCAMP_S;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // Value to set or get
    ULONG Flags;                        // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG Capabilities;                 // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_NODE_S, *PKSPROPERTY_VIDEOPROCAMP_NODE_S;

typedef struct {
    KSPROPERTY Property;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_S2, *PKSPROPERTY_VIDEOPROCAMP_S2;

typedef struct {
    KSP_NODE NodeProperty;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_NODE_S2, *PKSPROPERTY_VIDEOPROCAMP_NODE_S2;

#endif // XP SP2 and later (chronologically)

#define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_PROPSETID_VIDCAP_SELECTOR \
    0x1ABDAECA, 0x68B6, 0x4F83, 0x93, 0x71, 0xB4, 0x13, 0x90, 0x7C, 0x7B, 0x9F
DEFINE_GUIDSTRUCT("1ABDAECA-68B6-4F83-9371-B413907C7B9F", PROPSETID_VIDCAP_SELECTOR);
#define PROPSETID_VIDCAP_SELECTOR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_SELECTOR)

typedef enum {
    KSPROPERTY_SELECTOR_SOURCE_NODE_ID,              // RW
    KSPROPERTY_SELECTOR_NUM_SOURCES                  // R
} KSPROPERTY_VIDCAP_SELECTOR, *PKSPROPERTY_VIDCAP_SELECTOR;

typedef struct {
    KSPROPERTY Property;
    LONG  Value;                        // Value to set or get
    ULONG Flags;                        
    ULONG Capabilities;                 
} KSPROPERTY_SELECTOR_S, *PKSPROPERTY_SELECTOR_S;

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // Value to set or get
    ULONG Flags;
    ULONG Capabilities;
} KSPROPERTY_SELECTOR_NODE_S, *PKSPROPERTY_SELECTOR_NODE_S;

#endif // XP SP2 and later (chronologically)

//===========================================================================


#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    KSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    KSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    KSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    KSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    KSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    KSPROPERTY_TUNER_INPUT,             // RW -select an input
    KSPROPERTY_TUNER_STATUS,            // R  -tuning status
    KSPROPERTY_TUNER_IF_MEDIUM,         // R O-Medium for IF or Transport Pin
    KSPROPERTY_TUNER_SCAN_CAPS,         // R  -overall device capabilities for scanning
    KSPROPERTY_TUNER_SCAN_STATUS,       // R  -status of scan
    KSPROPERTY_TUNER_STANDARD_MODE,     // RW -autodetect mode for signal standard
    KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS // R -network type specific tuner capabilities
} KSPROPERTY_TUNER;


//
// Tuning support definitions and interfaces
//

// Definitions

typedef enum {
    KSPROPERTY_TUNER_MODE_TV            = 0X0001,
    KSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    KSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    KSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    KSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} KSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in KSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    KS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    KS_TUNER_TUNING_FINE,             // Fine grained search
    KS_TUNER_TUNING_COARSE,           // Coarse search
}KS_TUNER_TUNING_FLAGS;

typedef enum {
    KS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    KS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}KS_TUNER_STRATEGY;


// Tuning operations

typedef struct {
    KSPROPERTY Property;
    ULONG  ModesSupported;              // KS_PROPERTY_TUNER_MODES_*
    KSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_CAPS_S, *PKSPROPERTY_TUNER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_IF_MEDIUM_S, *PKSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // KS_TUNER_STRATEGY
} KSPROPERTY_TUNER_MODE_CAPS_S, *PKSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
} KSPROPERTY_TUNER_MODE_S, *PKSPROPERTY_TUNER_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // KS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} KSPROPERTY_TUNER_FREQUENCY_S, *PKSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Standard;                    // KS_AnalogVideo_*
} KSPROPERTY_TUNER_STANDARD_S, *PKSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    KSPROPERTY Property;
    BOOL AutoDetect;                 // RW - specifies whether the driver is in auto-detect mode for the signal standard
} KSPROPERTY_TUNER_STANDARD_MODE_S, *PKSPROPERTY_TUNER_STANDARD_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} KSPROPERTY_TUNER_INPUT_S, *PKSPROPERTY_TUNER_INPUT_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} KSPROPERTY_TUNER_STATUS_S, *PKSPROPERTY_TUNER_STATUS_S;


//
// Exhaustive Scanning tuner support definitions and interfaces
//

// Definitions

typedef enum _TunerDecoderLockType {
    Tuner_LockType_None                      = 0x00,   // Not locked on a signal. Can be returned at end of scan.
    Tuner_LockType_Within_Scan_Sensing_Range = 0x01,   // Signal is near by, not able to report exact frequency. Can be returned at end of scan.
    Tuner_LockType_Locked                    = 0x02    // Fine tune signal lock established. Can be returned at end of scan.
} TunerLockType;

// Data structures returned for KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S operations

typedef struct {
    ULONG  Mode;                        // IN -KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (defined in KS_AnalogVideoStandard)
    ULONG  MinFrequency;                // R -Hz
    ULONG  MaxFrequency;                // R -Hz
    ULONG  TuningGranularity;           // R -Hz
    ULONG  SettlingTime;                // R -milliSeconds
    ULONG  ScanSensingRange;            // R -max range (Hz) in which tuner can detect presence of a signal
    ULONG  FineTuneSensingRange;        // R -max range (Hz) in which tuner can detect actual frequency of a signal
}TUNER_ANALOG_CAPS_S, *PTUNER_ANALOG_CAPS_S;

// ... 
// More to come if new structures are needed for different network types.

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    KSEVENT_TUNER_CHANGED,
    KSEVENT_TUNER_INITIATE_SCAN    // initiate frequency scan 
} KSEVENT_TUNER;


// Exhaustive Scanning operations

// Determine if ES is possible with device
typedef struct {
    KSPROPERTY Property;
    BOOL fSupportsHardwareAssistedScanning; // R 
    ULONG SupportedBroadcastStandards;      // R 
    PVOID GUIDBucket;                       // RW
    ULONG lengthofBucket;                   // R   
} KSPROPERTY_TUNER_SCAN_CAPS_S, *PKSPROPERTY_TUNER_SCAN_CAPS_S;

// Get specific network type capabilities structure (such as TUNER_ANALOG_CAPS_S for example)
typedef struct {
    KSPROPERTY Property;
    GUID   NetworkType;               // R  -one of the interested GUIDs returned in KSPROPERTY_TUNER_SCAN_CAPS_S 
    ULONG  BufferSize;                // R  -size of the buffer;
    PVOID  NetworkTunerCapabilities;  // RW -Buffer
}KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S, *PKSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S;

// Obtain current scan operation status
typedef struct {
    KSPROPERTY Property;
    TunerLockType LockStatus; // R -none, within scan sensing range, or locked
    ULONG CurrentFrequency;   // R -current frequency
} KSPROPERTY_TUNER_SCAN_STATUS_S, *PKSPROPERTY_TUNER_SCAN_STATUS_S;

// Start a scan
typedef struct {
    KSEVENTDATA EventData;
    ULONG StartFrequency;          // W -initial frequency for the scan
    ULONG EndFrequency;            // W -final frequency for the scan
} KSEVENT_TUNER_INITIATE_SCAN_S, *PKSEVENT_TUNER_INITIATE_SCAN_S;



//
// Kernel Streaming Video node type definitions
//

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

//===========================================================================
// USB Video Class Definitions

#define STATIC_KSNODETYPE_VIDEO_STREAMING \
    0xDFF229E1L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 
DEFINE_GUIDSTRUCT("DFF229E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_STREAMING);
#define KSNODETYPE_VIDEO_STREAMING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_STREAMING)

#define STATIC_KSNODETYPE_VIDEO_INPUT_TERMINAL \
    0xDFF229E2L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_TERMINAL);
#define KSNODETYPE_VIDEO_INPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_TERMINAL \
    0xDFF229E3L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_TERMINAL);
#define KSNODETYPE_VIDEO_OUTPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_SELECTOR \
    0xDFF229E4L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_SELECTOR);
#define KSNODETYPE_VIDEO_SELECTOR DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_SELECTOR)

#define STATIC_KSNODETYPE_VIDEO_PROCESSING \
    0xDFF229E5L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_PROCESSING);
#define KSNODETYPE_VIDEO_PROCESSING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_PROCESSING)

#define STATIC_KSNODETYPE_VIDEO_CAMERA_TERMINAL \
    0xDFF229E6L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_CAMERA_TERMINAL);
#define KSNODETYPE_VIDEO_CAMERA_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_CAMERA_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_INPUT_MTT \
    0xDFF229E7L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_MTT);
#define KSNODETYPE_VIDEO_INPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_MTT)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_MTT \
    0xDFF229E8L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_MTT);
#define KSNODETYPE_VIDEO_OUTPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_MTT)

#endif // XP SP2 and later (chronologically)

//===========================================================================


#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    KSPROPERTY_VIDEOENCODER_CAPS,                       // R
    KSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    KSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    KSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} KSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} KSPROPERTY_VIDEOENCODER_S, *PKSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    KSPROPERTY_VIDEODECODER_CAPS,                       // R
    KSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    KSPROPERTY_VIDEODECODER_STATUS,                     // R
    KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    KSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
    KSPROPERTY_VIDEODECODER_STATUS2                     // R
} KSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}KS_VIDEODECODER_FLAGS;

typedef struct {
    KSPROPERTY Property;
    ULONG      StandardsSupported;      // KS_AnalogVideo_*
    ULONG      Capabilities;            // KS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} KSPROPERTY_VIDEODECODER_CAPS_S, *PKSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} KSPROPERTY_VIDEODECODER_STATUS_S, *PKSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;       // R - 525 or 625 lines detected
    ULONG      SignalLocked;        // R - TRUE if signal is locked
    ULONG      ChromaLock;          // R - TRUE if a chroma signal is present
} KSPROPERTY_VIDEODECODER_STATUS2_S, *PKSPROPERTY_VIDEODECODER_STATUS2_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} KSPROPERTY_VIDEODECODER_S, *PKSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    KSEVENT_VIDEODECODER_CHANGED
} KSEVENT_VIDEODECODER;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    KSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    KSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    KSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    KSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    KSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    KSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    KSPROPERTY_CAMERACONTROL_FOCUS                      // RW O

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    , KSPROPERTY_CAMERACONTROL_SCANMODE                 // RW O
    , KSPROPERTY_CAMERACONTROL_PRIVACY                  // RW O
    , KSPROPERTY_CAMERACONTROL_PANTILT                  // RW O
    , KSPROPERTY_CAMERACONTROL_PAN_RELATIVE             // RW O
    , KSPROPERTY_CAMERACONTROL_TILT_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_ROLL_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_ZOOM_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_EXPOSURE_RELATIVE        // RW O
    , KSPROPERTY_CAMERACONTROL_IRIS_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_FOCUS_RELATIVE           // RW O
    , KSPROPERTY_CAMERACONTROL_PANTILT_RELATIVE         // RW O
    , KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH             // R  O    
    , KSPROPERTY_CAMERACONTROL_AUTO_EXPOSURE_PRIORITY   // RW O

#endif // XP SP2 and later (chronologically)

} KSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_S, *PKSPROPERTY_CAMERACONTROL_S;

#define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L

#define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // value to get or set
    ULONG Flags;                        // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG Capabilities;                 // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_NODE_S, PKSPROPERTY_CAMERACONTROL_NODE_S;

typedef struct {
    KSPROPERTY Property;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_CAMERACONTROL_S2, *PKSPROPERTY_CAMERACONTROL_S2;

typedef struct {
    KSP_NODE NodeProperty;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_CAMERACONTROL_NODE_S2, *PKSPROPERTY_CAMERACONTROL_NODE_S2;

typedef struct {
    KSPROPERTY Property;
    LONG lOcularFocalLength;
    LONG lObjectiveFocalLengthMin;
    LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S, *PKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG lOcularFocalLength;
    LONG lObjectiveFocalLengthMin;
    LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S, *PKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S;

#ifndef __EDevCtrl__
#define __EDevCtrl__
//===========================================================================

#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)

typedef enum {
    KSPROPERTY_EXTDEVICE_ID,                // R
    KSPROPERTY_EXTDEVICE_VERSION,           // R
    KSPROPERTY_EXTDEVICE_POWER_STATE,       // RW
    KSPROPERTY_EXTDEVICE_PORT,              // R
    KSPROPERTY_EXTDEVICE_CAPABILITIES       // R
} KSPROPERTY_EXTDEVICE;

typedef struct tagDEVCAPS{
    LONG CanRecord;
    LONG CanRecordStrobe;
    LONG HasAudio;
    LONG HasVideo;
    LONG UsesFiles;
    LONG CanSave;
    LONG DeviceType;
    LONG TCRead;
    LONG TCWrite;
    LONG CTLRead;
    LONG IndexRead;
    LONG Preroll;
    LONG Postroll;
    LONG SyncAcc;
    LONG NormRate;
    LONG CanPreview;
    LONG CanMonitorSrc;
    LONG CanTest;
    LONG VideoIn;
    LONG AudioIn;
    LONG Calibrate;
    LONG SeekType;
    LONG SimulatedHardware;        
} DEVCAPS, *PDEVCAPS;

typedef struct {
    KSPROPERTY Property;
    union {
        DEVCAPS  Capabilities;          // Device capabilities
        ULONG    DevPort;               // 1394, USB, etc.
        ULONG    PowerState;            // On, standby or off
        WCHAR    pawchString[MAX_PATH]; // Version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;
} KSPROPERTY_EXTDEVICE_S, *PKSPROPERTY_EXTDEVICE_S;

//===========================================================================

#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)

typedef enum {
    KSPROPERTY_EXTXPORT_CAPABILITIES,       // (R)  Transport specific capability 
    KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // (RW) Input signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // (RW) Output signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    KSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // (RW) Eject, open tray, close tray
    KSPROPERTY_EXTXPORT_MEDIUM_INFO,        // (R)  Cassettte type, tape grade and write protection
    KSPROPERTY_EXTXPORT_STATE,              // (RW) Current transport mode and state
    KSPROPERTY_EXTXPORT_STATE_NOTIFY,       // (RW) Notify of transport mode and state change
    KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // (W)  Search to a specific timecode on a tape
    KSPROPERTY_EXTXPORT_ATN_SEARCH,         // (W)  Search to a specific absolute track number (ATN) on a tape
    KSPROPERTY_EXTXPORT_RTC_SEARCH,         // (W)  Search to a specific relative time counter (RTC) on a tape
    KSPROPERTY_RAW_AVC_CMD                  // (RW) Issue a raw AVC commnad
} KSPROPERTY_EXTXPORT;

typedef struct tagTRANSPORTSTATUS{
    LONG Mode;
    LONG LastError;
    LONG RecordInhibit;
    LONG ServoLock;
    LONG MediaPresent;
    LONG MediaLength;
    LONG MediaSize;
    LONG MediaTrackCount;
    LONG MediaTrackLength;
    LONG MediaTrackSide;
    LONG MediaType;
    LONG LinkMode;
    LONG NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

typedef struct tagTRANSPORTBASICPARMS{
    LONG TimeFormat;
    LONG TimeReference;
    LONG Superimpose;
    LONG EndStopAction;
    LONG RecordFormat;
    LONG StepFrames;
    LONG SetpField;
    LONG Preroll;
    LONG RecPreroll;
    LONG Postroll;
    LONG EditDelay;
    LONG PlayTCDelay;
    LONG RecTCDelay;
    LONG EditField;
    LONG FrameServo;
    LONG ColorFrameServo;
    LONG ServoRef;
    LONG WarnGenlock;
    LONG SetTracking;
    TCHAR VolumeName[40];
    LONG Ballistic[20];
    LONG Speed;
    LONG CounterFormat;
    LONG TunerChannel;
    LONG TunerNumber;
    LONG TimerEvent;
    LONG TimerStartDay;
    LONG TimerStartTime;
    LONG TimerStopDay;
    LONG TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

typedef struct tagTRANSPORTVIDEOPARMS{
    LONG OutputMode;
    LONG Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

typedef struct tagTRANSPORTAUDIOPARMS{
    LONG EnableOutput;
    LONG EnableRecord;
    LONG EnableSelsync;
    LONG Input;
    LONG MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;

typedef struct {
    BOOL  MediaPresent;      
    ULONG MediaType;         
    BOOL  RecordInhibit;    
} MEDIUM_INFO, *PMEDIUM_INFO;

typedef struct {
    ULONG Mode;              
    ULONG State;
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    KSPROPERTY Property;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} KSPROPERTY_EXTXPORT_S, *PKSPROPERTY_EXTXPORT_S;

typedef struct {
    KSP_NODE NodeProperty;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} KSPROPERTY_EXTXPORT_NODE_S, *PKSPROPERTY_EXTXPORT_NODE_S;

//===========================================================================

#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)

typedef enum {
    KSPROPERTY_TIMECODE_READER,  // (R) Timecode for the current tape position
    KSPROPERTY_ATN_READER,       // (R) Absolute track number for the current tape position
    KSPROPERTY_RTC_READER        // (R) Relative time counter for the current tape position
} KSPROPERTY_TIMECODE;

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
    struct {
        WORD   wFrameRate;
        WORD   wFrameFract;
        DWORD  dwFrames;
        };
    DWORDLONG  qw;
} TIMECODE;
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
} TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

typedef struct {
    KSPROPERTY Property;
    TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_S, *PKSPROPERTY_TIMECODE_S;

typedef struct {
    KSP_NODE NodeProperty;
    TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_NODE_S, *PKSPROPERTY_TIMECODE_NODE_S;

//===========================================================================

#define STATIC_KSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", KSEVENTSETID_EXTDEV_Command);
#define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)

typedef enum {
    KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,     // Final response is ready for notify command 
    KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,    // Final response is ready for control command.
    KSEVENT_EXTDEV_COMMAND_BUSRESET,                 // A bus reset has occured.
    KSEVENT_EXTDEV_TIMECODE_UPDATE,                  // Timecode has changed.
    KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,            // Operting mode (VCR,Camera, etc.) has changed.
    KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,           // Transport state has changed.
    KSEVENT_EXTDEV_NOTIFY_REMOVAL,                   // Device was surprise removal.
    KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE              // Tape medium is removed or added.
} KSEVENT_DEVCMD;

#endif // __EDevCtrl__

#endif // XP SP2 and later (chronologically)

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    KSPROPERTY_CROSSBAR_CAPS,                     // R
    KSPROPERTY_CROSSBAR_PININFO,                  // R
    KSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    KSPROPERTY_CROSSBAR_ROUTE,                    // RW
    KSPROPERTY_CROSSBAR_INPUT_ACTIVE              // R
} KSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    KSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} KSPROPERTY_CROSSBAR_CAPS_S, *PKSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_DATAFLOW Direction;     // KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // KS_PhysConn_Video_* or KS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    KSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} KSPROPERTY_CROSSBAR_PININFO_S, *PKSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} KSPROPERTY_CROSSBAR_ROUTE_S, *PKSPROPERTY_CROSSBAR_ROUTE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // W - Zero based index of the input pin
    ULONG  Active;               // R - returns whether an active signal is present on the given input
} KSPROPERTY_CROSSBAR_ACTIVE_S, *PKSPROPERTY_CROSSBAR_ACTIVE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    KSEVENT_CROSSBAR_CHANGED
} KSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    KS_PhysConn_Video_Tuner = 1,
    KS_PhysConn_Video_Composite,
    KS_PhysConn_Video_SVideo,
    KS_PhysConn_Video_RGB,
    KS_PhysConn_Video_YRYBY,
    KS_PhysConn_Video_SerialDigital,
    KS_PhysConn_Video_ParallelDigital,
    KS_PhysConn_Video_SCSI,
    KS_PhysConn_Video_AUX,
    KS_PhysConn_Video_1394,
    KS_PhysConn_Video_USB,
    KS_PhysConn_Video_VideoDecoder,
    KS_PhysConn_Video_VideoEncoder,
    KS_PhysConn_Video_SCART,

    KS_PhysConn_Audio_Tuner = 4096,
    KS_PhysConn_Audio_Line,
    KS_PhysConn_Audio_Mic,
    KS_PhysConn_Audio_AESDigital,
    KS_PhysConn_Audio_SPDIFDigital,
    KS_PhysConn_Audio_SCSI,
    KS_PhysConn_Audio_AUX,
    KS_PhysConn_Audio_1394,
    KS_PhysConn_Audio_USB,
    KS_PhysConn_Audio_AudioDecoder
} KS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSPROPERTY_TVAUDIO_CAPS,                            // R
    KSPROPERTY_TVAUDIO_MODE,                            // RW
    KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} KSPROPERTY_VIDCAP_TVAUDIO;

#define KS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define KS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define KS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define KS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define KS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define KS_TVAUDIO_PRESET_STEREO       0x0200          // if present, stereo
#define KS_TVAUDIO_PRESET_LANG_A       0x1000          // if present, Language A
#define KS_TVAUDIO_PRESET_LANG_B       0x2000          // if present, Language B
#define KS_TVAUDIO_PRESET_LANG_C       0x4000          // if present, Language C
#endif // (NTDDI_VERSION >= NTDDI_VISTA

typedef struct {
    KSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of KS_TVAUDIO_MODE_*
    KSPIN_MEDIUM InputMedium;
    KSPIN_MEDIUM OutputMedium;
} KSPROPERTY_TVAUDIO_CAPS_S, *PKSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Mode;                     // KS_TVAUDIO_MODE_*
} KSPROPERTY_TVAUDIO_S, *PKSPROPERTY_TVAUDIO_S;


#define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", KSEVENTSETID_VIDCAP_TVAUDIO);
#define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSEVENT_TVAUDIO_CHANGED,
} KSEVENT_TVAUDIO;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    KSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    KSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE            // RW
} KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    KS_CompressionCaps_CanQuality = 1,
    KS_CompressionCaps_CanCrunch = 2,
    KS_CompressionCaps_CanKeyFrame = 4,
    KS_CompressionCaps_CanBFrame = 8,
    KS_CompressionCaps_CanWindow = 0x10
} KS_CompressionCaps;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef enum {
    KS_StreamingHint_FrameInterval = 0x0100,
    KS_StreamingHint_KeyFrameRate = 0x0200,
    KS_StreamingHint_PFrameRate = 0x0400,
    KS_StreamingHint_CompQuality = 0x0800,
    KS_StreamingHint_CompWindowSize = 0x1000
} KS_VideoStreamingHints;

#endif // XP SP2 and later (chronologically)

typedef struct {
    KSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // KS_CompressionCaps_*
} KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} KSPROPERTY_VIDEOCOMPRESSION_S, *PKSPROPERTY_VIDEOCOMPRESSION_S;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSPROPERTY  Property;
    ULONG       StreamIndex;             // zero based index of stream
    LONG        Value;                   // value to get or set
    ULONG       Flags;
} KSPROPERTY_VIDEOCOMPRESSION_S1, *PKSPROPERTY_VIDEOCOMPRESSION_S1;

#endif // XP SP2 and later (chronologically)

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_OVERLAY);
#define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_KSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", KSPROPSETID_OverlayUpdate);
#define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)

typedef enum {
    KSPROPERTY_OVERLAYUPDATE_INTERESTS,
    KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} KSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} KSDISPLAYCHANGE, *PKSDISPLAYCHANGE;

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(KSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    KSPROPERTY_VIDEOCONTROL_CAPS,               // R
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    KSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    KSPROPERTY_VIDEOCONTROL_MODE                // RWO
} KSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    KS_VideoControlFlag_FlipHorizontal        = 0x0001,
    KS_VideoControlFlag_FlipVertical          = 0x0002,
    KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,    // ***WARNING *** Flag msimatch with DSHOW.
    KS_Obsolete_VideoControlFlag_Trigger               = 0x0020,  // ***WARNING *** Flag msimatch with DSHOW.
    KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
    KS_VideoControlFlag_Trigger                      = 0x0008
} KS_VideoControlFlags;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_CAPS_S, *PKSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_MODE_S, *PKSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// KSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    KSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} KSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    KSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} KSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_KSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", KSPROPSETID_VPConfig);
#define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)

#define STATIC_KSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", KSPROPSETID_VPVBIConfig);
#define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    KSPROPERTY_VPCONFIG_GETCONNECTINFO,
    KSPROPERTY_VPCONFIG_SETCONNECTINFO,
    KSPROPERTY_VPCONFIG_VPDATAINFO,
    KSPROPERTY_VPCONFIG_MAXPIXELRATE,
    KSPROPERTY_VPCONFIG_INFORMVPINPUT,
    KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_INVERTPOLARITY,
    KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_DDRAWHANDLE,
    KSPROPERTY_VPCONFIG_VIDEOPORTID,
    KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    KSPROPERTY_VPCONFIG_SURFACEPARAMS
} KSPROPERTY_VPCONFIG;

#if (NTDDI_VERSION >= NTDDI_WINXP)
//=========================
// IBasicAudio
//
#define STATIC_CLSID_KsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_KsIBasicAudioInterfaceHandler);
#define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    AMVPSIZE        Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;  // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    KS_PixAspectRatio_NTSC4x3,
    KS_PixAspectRatio_NTSC16x9,
    KS_PixAspectRatio_PAL4x3,
    KS_PixAspectRatio_PAL16x9
} KS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    KS_AMVP_DO_NOT_CARE,
    KS_AMVP_BEST_BANDWIDTH,
    KS_AMVP_INPUT_SAME_AS_OUTPUT
} KS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    KS_AMVP_MODE_WEAVE,
    KS_AMVP_MODE_BOBINTERLEAVED,
    KS_AMVP_MODE_BOBNONINTERLEAVED,
    KS_AMVP_MODE_SKIPEVEN,
    KS_AMVP_MODE_SKIPODD
} KS_AMVP_MODE ;

typedef struct tagKS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} KS_AMVPDIMINFO, *PKS_AMVPDIMINFO ;

typedef struct tagKS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    KS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} KS_AMVPDATAINFO, *PKS_AMVPDATAINFO;

typedef struct tagKS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} KS_AMVPSIZE, *PKS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    KS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    KS_AMVPSIZE     Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_KSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", KSEVENTSETID_VPNotify);
#define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)

typedef enum {
    KSEVENT_VPNOTIFY_FORMATCHANGE
} KSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_KSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", KSEVENTSETID_VIDCAPTOSTI);
#define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    KSEVENT_VIDCAPTOSTI_EXT_TRIGGER
#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
    , KSEVENT_VIDCAP_AUTO_UPDATE
    , KSEVENT_VIDCAP_SEARCH
#endif // XP SP2 and later (chronologically)
} KSEVENT_VIDCAPTOSTI;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

//
// Extension Unit Properties
//
typedef enum {
    KSPROPERTY_EXTENSION_UNIT_INFO,                  // (R)
    KSPROPERTY_EXTENSION_UNIT_CONTROL,               // (RW) 
    KSPROPERTY_EXTENSION_UNIT_PASS_THROUGH = 0xffff  // (RW) 
} KSPROPERTY_EXTENSION_UNIT, *PKSPROPERTY_EXTENSION_UNIT;

#endif // XP SP2 and later (chronologically)

//
//  IVPVBINotify event notification
//
#define STATIC_KSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", KSEVENTSETID_VPVBINotify);
#define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)

typedef enum {
    KSEVENT_VPVBINOTIFY_FORMATCHANGE
} KSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", KSDATAFORMAT_TYPE_AUXLine21Data);
#define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _KSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} KSGOP_USERDATA, *PKSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define KS_AM_UseNewCSSKey              0x0001L
// -----------------------------------------------------------------------
// KS_AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_KSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", KSPROPSETID_TSRateChange);
#define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)
typedef enum {
    KS_AM_RATE_SimpleRateChange=1,  // rw, use KS_AM_SimpleRateChange
    KS_AM_RATE_ExactRateChange=2,   // rw, use KS_AM_ExactRateChange
    KS_AM_RATE_MaxFullDataRate=3,   // r, use KS_AM_MaxFullDataRate
    KS_AM_RATE_Step=4               // w, use KS_AM_Step
} KS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_SimpleRateChange, *PKS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_ExactRateChange, *PKS_AM_ExactRateChange;

typedef LONG KS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD KS_AM_Step; // number of frame to step

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)

//===========================================================================
//ENCODER API DEFINITIONS
//===========================================================================

#define STATIC_KSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)

#define STATIC_KSCATEGORY_MULTIPLEXER \
    0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", KSCATEGORY_MULTIPLEXER);
#define KSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE \
    0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE \
    0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE \
    0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_CODECAPI_CHANGELISTS \
    0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d
DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D", CODECAPI_CHANGELISTS );
#define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS )

#define STATIC_CODECAPI_VIDEO_ENCODER \
    0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01
DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301", CODECAPI_VIDEO_ENCODER );
#define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER )

#define STATIC_CODECAPI_AUDIO_ENCODER \
    0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d
DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D", CODECAPI_AUDIO_ENCODER );
#define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER )

#define STATIC_CODECAPI_SETALLDEFAULTS \
    0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b
DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B", CODECAPI_SETALLDEFAULTS );
#define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS )

#define STATIC_CODECAPI_ALLSETTINGS \
    0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1
DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1", CODECAPI_ALLSETTINGS );
#define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS )

#define STATIC_CODECAPI_SUPPORTSEVENTS \
    0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 
DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1", CODECAPI_SUPPORTSEVENTS );
#define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS )

#define STATIC_CODECAPI_CURRENTCHANGELIST \
    0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d 
DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D", CODECAPI_CURRENTCHANGELIST );
#define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST )

#endif // XP SP2 and later (chronologically)

#endif // __ENCODER_API_GUIDS__

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__

typedef enum {

    //
    // Bit rate used for encoding is constant
    //
    ConstantBitRate = 0,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as a guaranteed average over a specified window.  The default window 
    // size is considered to be 5 minutes.
    //
    VariableBitRateAverage,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as an average with a peak not to exceed the specified peak bitrate over 
    // a specified window.  The default window size is considered to be 500ms 
    // (classically one GOP).
    //
    VariableBitRatePeak

} VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__

//===========================================================================
// JACK DESCRIPTION DEFINITIONS
//===========================================================================
#define STATIC_KSPROPSETID_Jack\
    0x4509f757, 0x2d46, 0x4637, 0x8e, 0x62, 0xce, 0x7d, 0xb9, 0x44, 0xf5, 0x7b
DEFINE_GUIDSTRUCT("4509F757-2D46-4637-8E62-CE7DB944F57B", KSPROPSETID_Jack);
#define KSPROPSETID_Jack DEFINE_GUIDNAMED(KSPROPSETID_Jack)

// define new property id 
typedef enum {
    KSPROPERTY_JACK_DESCRIPTION = 1,
    KSPROPERTY_JACK_DESCRIPTION2,
    KSPROPERTY_JACK_SINK_INFO
} KSPROPERTY_JACK;

// Enums used in KSPROPERTY_JACK_INFO_STRUCT

typedef enum
{
    eConnTypeUnknown,
    eConnType3Point5mm,
    eConnTypeQuarter,
    eConnTypeAtapiInternal,
    eConnTypeRCA,
    eConnTypeOptical,
    eConnTypeOtherDigital,
    eConnTypeOtherAnalog,
    eConnTypeMultichannelAnalogDIN,
    eConnTypeXlrProfessional,
    eConnTypeRJ11Modem,
    eConnTypeCombination
} EPcxConnectionType;

typedef enum
{
    eGeoLocRear = 0x1,
    eGeoLocFront,
    eGeoLocLeft,
    eGeoLocRight,
    eGeoLocTop,
    eGeoLocBottom,
    eGeoLocRearPanel,
    eGeoLocRiser,
    eGeoLocInsideMobileLid,
    eGeoLocDrivebay,
    eGeoLocHDMI,
    eGeoLocOutsideMobileLid,
    eGeoLocATAPI,
    eGeoLocReserved5,
    eGeoLocReserved6,
    EPcxGeoLocation_enum_count
} EPcxGeoLocation;

typedef enum
{
    eGenLocPrimaryBox = 0,
    eGenLocInternal,
    eGenLocSeparate,
    eGenLocOther,
    EPcxGenLocation_enum_count
} EPcxGenLocation;

typedef enum
{
    ePortConnJack = 0,
    ePortConnIntegratedDevice,
    ePortConnBothIntegratedAndJack,
    ePortConnUnknown
} EPxcPortConnection;

// structure for KSPROPERTY_JACK_DESCRIPTION pin property
typedef struct 
{
    DWORD                 ChannelMapping;
    COLORREF              Color;   // use RGB() macro to generate these
    EPcxConnectionType    ConnectionType;
    EPcxGeoLocation       GeoLocation;
    EPcxGenLocation       GenLocation;
    EPxcPortConnection    PortConnection;
    BOOL                  IsConnected;
} KSJACK_DESCRIPTION, *PKSJACK_DESCRIPTION;

typedef enum 
{
    KSJACK_SINK_CONNECTIONTYPE_HDMI = 0,            // HDMI
    KSJACK_SINK_CONNECTIONTYPE_DISPLAYPORT,         // DisplayPort
} KSJACK_SINK_CONNECTIONTYPE;

#define MAX_SINK_DESCRIPTION_NAME_LENGTH 32
typedef struct _tagKSJACK_SINK_INFORMATION
{
  KSJACK_SINK_CONNECTIONTYPE ConnType;              // Connection Type
  WORD  ManufacturerId;                             // Sink manufacturer ID
  WORD  ProductId;                                  // Sink product ID
  WORD  AudioLatency;                                    // Sink audio latency
  BOOL  HDCPCapable;                                // HDCP Support
  BOOL  AICapable;                                  // ACP Packet, ISRC1, and ISRC2 Support
  UCHAR SinkDescriptionLength;                      // Monitor/Sink name length
  WCHAR SinkDescription[MAX_SINK_DESCRIPTION_NAME_LENGTH];   // Monitor/Sink name
  LUID  PortId;                                     // Video port identifier
}  KSJACK_SINK_INFORMATION, *PKSJACK_SINK_INFORMATION;

#define JACKDESC2_PRESENCE_DETECT_CAPABILITY       0x00000001 
#define JACKDESC2_DYNAMIC_FORMAT_CHANGE_CAPABILITY 0x00000002

typedef struct _tagKSJACK_DESCRIPTION2
{
  DWORD              DeviceStateInfo; // Top 16 bits: Report current device state, active, streaming, idle, or hardware not ready
                                      // Bottom 16 bits: detailed reason to further explain state in top 16 bits
  DWORD              JackCapabilities; // Report jack capabilities such as jack presence detection capability 
                                       // or dynamic format changing capability         
} KSJACK_DESCRIPTION2, *PKSJACK_DESCRIPTION2;

#endif // (NTDDI_VERSION >= NTDDI_WINXPSP1)

//===========================================================================
// Audio Buffer Duration
#define STATIC_KSPROPSETID_AudioBufferDuration\
    0x4e73c07f, 0x23cc, 0x4955, 0xa7, 0xea, 0x3d, 0xa5, 0x2, 0x49, 0x62, 0x90 
DEFINE_GUIDSTRUCT("4E73C07F-23CC-4955-A7EA-3DA502496290", KSPROPSETID_AudioBufferDuration);
#define KSPROPSETID_AudioBufferDuration DEFINE_GUIDNAMED(KSPROPSETID_AudioBufferDuration)

// define new property id 
#define KSPROPERTY_AUDIO_BUFFER_DURATION 1

#endif // !defined(_KSMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Ks.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ks.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core definitions.

--*/

#if !defined(_KS_)
#define _KS_

#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#if defined(__TCS__)
#define _KS_NO_ANONYMOUS_STRUCTURES_ 1
#endif

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif // !defined(DEFINE_GUIDEX)

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif // !defined(STATICGUIDOF)
#endif // !defined(_NTRTL_)

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

#if defined(__cplusplus) && _MSC_VER >= 1100
#define DEFINE_GUIDSTRUCT(g, n) struct __declspec(uuid(g)) n
#define DEFINE_GUIDNAMED(n) __uuidof(struct n)
#else // !defined(__cplusplus)
#define DEFINE_GUIDSTRUCT(g, n) DEFINE_GUIDEX(n)
#define DEFINE_GUIDNAMED(n) n
#endif // !defined(__cplusplus)

//===========================================================================

#define STATIC_GUID_NULL \
    0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000", GUID_NULL);
#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)

//===========================================================================

#define IOCTL_KS_PROPERTY              CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_ENABLE_EVENT          CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_DISABLE_EVENT         CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_METHOD                CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_WRITE_STREAM          CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_KS_READ_STREAM           CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
#define IOCTL_KS_RESET_STATE           CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)

//===========================================================================

typedef enum {
    KSRESET_BEGIN,
    KSRESET_END
} KSRESET;

typedef enum {
    KSSTATE_STOP,
    KSSTATE_ACQUIRE,
    KSSTATE_PAUSE,
    KSSTATE_RUN
} KSSTATE, *PKSSTATE;

#define KSPRIORITY_LOW        0x00000001
#define KSPRIORITY_NORMAL     0x40000000
#define KSPRIORITY_HIGH       0x80000000
#define KSPRIORITY_EXCLUSIVE  0xFFFFFFFF

typedef struct {
    ULONG   PriorityClass;
    ULONG   PrioritySubClass;
} KSPRIORITY, *PKSPRIORITY;

typedef struct {
    union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
        struct _IDENTIFIER {
#else        
        struct {
#endif        
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSMETHOD_TYPE_TOPOLOGY 0x10000000

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSPROPERTY      Property;
    ULONG           NodeId;
    ULONG           Reserved;
} KSP_NODE, *PKSP_NODE;

typedef struct {
    KSMETHOD        Method;
    ULONG           NodeId;
    ULONG           Reserved;
} KSM_NODE, *PKSM_NODE;

typedef struct {
    KSEVENT         Event;
    ULONG           NodeId;
    ULONG           Reserved;
} KSE_NODE, *PKSE_NODE;

#define STATIC_KSPROPTYPESETID_General \
    0x97E99BA0L, 0xBDEA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000", KSPROPTYPESETID_General);
#define KSPROPTYPESETID_General DEFINE_GUIDNAMED(KSPROPTYPESETID_General)

#if defined(_NTDDK_) && !defined(__wtypes_h__)
enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT  = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};
#endif // _NTDDK_ && !__wtypes_h__

typedef struct {
    ULONG    Size;
    ULONG    Count;
} KSMULTIPLE_ITEM, *PKSMULTIPLE_ITEM;

typedef struct {
    ULONG           AccessFlags;
    ULONG           DescriptionSize;
    KSIDENTIFIER    PropTypeSet;
    ULONG           MembersListCount;
    ULONG           Reserved;
} KSPROPERTY_DESCRIPTION, *PKSPROPERTY_DESCRIPTION;

#define KSPROPERTY_MEMBER_RANGES            0x00000001
#define KSPROPERTY_MEMBER_STEPPEDRANGES     0x00000002
#define KSPROPERTY_MEMBER_VALUES            0x00000003

#define KSPROPERTY_MEMBER_FLAG_DEFAULT                      0x00000001
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL    0x00000002
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM         0x00000004
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct {
    ULONG   MembersFlags;
    ULONG   MembersSize;
    ULONG   MembersCount;
    ULONG   Flags;
} KSPROPERTY_MEMBERSHEADER, *PKSPROPERTY_MEMBERSHEADER;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED {
#else
    struct {
#endif    
        LONG    SignedMinimum;
        LONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED {
#else
    struct {
#endif    
        ULONG   UnsignedMinimum;
        ULONG   UnsignedMaximum;
    };
} KSPROPERTY_BOUNDS_LONG, *PKSPROPERTY_BOUNDS_LONG;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED64 {
#else
    struct {
#endif    
        LONGLONG    SignedMinimum;
        LONGLONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED64 {
#else
    struct {
#endif    
#if defined(_NTDDK_)
        ULONGLONG   UnsignedMinimum;
        ULONGLONG   UnsignedMaximum;
#else // !_NTDDK_
        DWORDLONG   UnsignedMinimum;
        DWORDLONG   UnsignedMaximum;
#endif // !_NTDDK_
    };
} KSPROPERTY_BOUNDS_LONGLONG, *PKSPROPERTY_BOUNDS_LONGLONG;

typedef struct {
    ULONG                       SteppingDelta;
    ULONG                       Reserved;
    KSPROPERTY_BOUNDS_LONG      Bounds;
} KSPROPERTY_STEPPING_LONG, *PKSPROPERTY_STEPPING_LONG;

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG                   SteppingDelta;
#else // !_NTDDK_
    DWORDLONG                   SteppingDelta;
#endif // !_NTDDK_
    KSPROPERTY_BOUNDS_LONGLONG  Bounds;
} KSPROPERTY_STEPPING_LONGLONG, *PKSPROPERTY_STEPPING_LONGLONG;

//===========================================================================
#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)
//
// Structure forward declarations.
//
typedef struct _KSDEVICE_DESCRIPTOR
KSDEVICE_DESCRIPTOR, *PKSDEVICE_DESCRIPTOR;
typedef struct _KSDEVICE_DISPATCH
KSDEVICE_DISPATCH, *PKSDEVICE_DISPATCH;
typedef struct _KSDEVICE 
KSDEVICE, *PKSDEVICE;
typedef struct _KSFILTERFACTORY 
KSFILTERFACTORY, *PKSFILTERFACTORY;
typedef struct _KSFILTER_DESCRIPTOR
KSFILTER_DESCRIPTOR, *PKSFILTER_DESCRIPTOR;
typedef struct _KSFILTER_DISPATCH
KSFILTER_DISPATCH, *PKSFILTER_DISPATCH;
typedef struct _KSFILTER 
KSFILTER, *PKSFILTER;
typedef struct _KSPIN_DESCRIPTOR_EX
KSPIN_DESCRIPTOR_EX, *PKSPIN_DESCRIPTOR_EX;
typedef struct _KSPIN_DISPATCH
KSPIN_DISPATCH, *PKSPIN_DISPATCH;
typedef struct _KSCLOCK_DISPATCH
KSCLOCK_DISPATCH, *PKSCLOCK_DISPATCH;
typedef struct _KSALLOCATOR_DISPATCH
KSALLOCATOR_DISPATCH, *PKSALLOCATOR_DISPATCH;
typedef struct _KSPIN 
KSPIN, *PKSPIN;
typedef struct _KSNODE_DESCRIPTOR
KSNODE_DESCRIPTOR, *PKSNODE_DESCRIPTOR;
typedef struct _KSSTREAM_POINTER_OFFSET
KSSTREAM_POINTER_OFFSET, *PKSSTREAM_POINTER_OFFSET;
typedef struct _KSSTREAM_POINTER
KSSTREAM_POINTER, *PKSSTREAM_POINTER;
typedef struct _KSMAPPING
KSMAPPING, *PKSMAPPING;
typedef struct _KSPROCESSPIN
KSPROCESSPIN, *PKSPROCESSPIN;
typedef struct _KSPROCESSPIN_INDEXENTRY
KSPROCESSPIN_INDEXENTRY, *PKSPROCESSPIN_INDEXENTRY;
#endif // _NTDDK_

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID PKSWORKER;

typedef struct {
    ULONG       NotificationType;
    union {
        struct {
            HANDLE              Event;
            ULONG_PTR           Reserved[2];
        } EventHandle;
        struct {
            HANDLE              Semaphore;
            ULONG               Reserved;
            LONG                Adjustment;
        } SemaphoreHandle;
#if defined(_NTDDK_)
        struct {
            PVOID               Event;
            KPRIORITY           Increment;
            ULONG_PTR           Reserved;
        } EventObject;
        struct {
            PVOID               Semaphore;
            KPRIORITY           Increment;
            LONG                Adjustment;
        } SemaphoreObject;
        struct {
            PKDPC               Dpc;
            ULONG               ReferenceCount;
            ULONG_PTR           Reserved;
        } Dpc;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            WORK_QUEUE_TYPE     WorkQueueType;
            ULONG_PTR           Reserved;
        } WorkItem;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            PKSWORKER           KsWorkerObject;
            ULONG_PTR           Reserved;
        } KsWorkItem;
#endif // defined(_NTDDK_)
        struct {
            PVOID               Unused;
            LONG_PTR            Alignment[2];
        } Alignment;
    };
} KSEVENTDATA, *PKSEVENTDATA;

#define KSEVENTF_EVENT_HANDLE       0x00000001
#define KSEVENTF_SEMAPHORE_HANDLE   0x00000002
#if defined(_NTDDK_)
#define KSEVENTF_EVENT_OBJECT       0x00000004
#define KSEVENTF_SEMAPHORE_OBJECT   0x00000008
#define KSEVENTF_DPC                0x00000010
#define KSEVENTF_WORKITEM           0x00000020
#define KSEVENTF_KSWORKITEM         0x00000080
#endif // defined(_NTDDK_)

#define KSEVENT_TYPE_ENABLE         0x00000001
#define KSEVENT_TYPE_ONESHOT        0x00000002
#define KSEVENT_TYPE_ENABLEBUFFERED 0x00000004
#define KSEVENT_TYPE_SETSUPPORT     0x00000100
#define KSEVENT_TYPE_BASICSUPPORT   0x00000200
#define KSEVENT_TYPE_QUERYBUFFER    0x00000400

#define KSEVENT_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSEVENT         Event;
    PKSEVENTDATA    EventData;
    PVOID           Reserved;
} KSQUERYBUFFER, *PKSQUERYBUFFER;

typedef struct {
    ULONG Size;
    ULONG Flags;
    union {
        HANDLE ObjectHandle;
        PVOID ObjectPointer;
    };
    PVOID Reserved;
    KSEVENT Event;
    KSEVENTDATA EventData;
} KSRELATIVEEVENT;

#define KSRELATIVEEVENT_FLAG_HANDLE 0x00000001
#define KSRELATIVEEVENT_FLAG_POINTER 0x00000002

//===========================================================================

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        MarkTime;
} KSEVENT_TIME_MARK, *PKSEVENT_TIME_MARK;

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSEVENT_TIME_INTERVAL, *PKSEVENT_TIME_INTERVAL;

typedef struct {
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSINTERVAL, *PKSINTERVAL;

//===========================================================================

#define STATIC_KSPROPSETID_General\
    0x1464EDA5L, 0x6A8F, 0x11D1, 0x9A, 0xA7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196", KSPROPSETID_General);
#define KSPROPSETID_General DEFINE_GUIDNAMED(KSPROPSETID_General)

typedef enum {
    KSPROPERTY_GENERAL_COMPONENTID
} KSPROPERTY_GENERAL;

typedef struct {
    GUID    Manufacturer;
    GUID    Product;
    GUID    Component;
    GUID    Name;
    ULONG   Version;
    ULONG   Revision;
} KSCOMPONENTID, *PKSCOMPONENTID;

#define DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_GENERAL_COMPONENTID,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCOMPONENTID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_KSMETHODSETID_StreamIo\
    0x65D003CAL, 0x1523, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196", KSMETHODSETID_StreamIo);
#define KSMETHODSETID_StreamIo DEFINE_GUIDNAMED(KSMETHODSETID_StreamIo)

typedef enum {
    KSMETHOD_STREAMIO_READ,
    KSMETHOD_STREAMIO_WRITE
} KSMETHOD_STREAMIO;

#define DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_READ,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_WRITE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define STATIC_KSPROPSETID_MediaSeeking\
    0xEE904F0CL, 0xD09B, 0x11D0, 0xAB, 0xE9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196", KSPROPSETID_MediaSeeking);
#define KSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(KSPROPSETID_MediaSeeking)

typedef enum {
    KSPROPERTY_MEDIASEEKING_CAPABILITIES,
    KSPROPERTY_MEDIASEEKING_FORMATS,
    KSPROPERTY_MEDIASEEKING_TIMEFORMAT,
    KSPROPERTY_MEDIASEEKING_POSITION,
    KSPROPERTY_MEDIASEEKING_STOPPOSITION,
    KSPROPERTY_MEDIASEEKING_POSITIONS,
    KSPROPERTY_MEDIASEEKING_DURATION,
    KSPROPERTY_MEDIASEEKING_AVAILABLE,
    KSPROPERTY_MEDIASEEKING_PREROLL,
    KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
} KSPROPERTY_MEDIASEEKING;

typedef enum {
    KS_SEEKING_NoPositioning,
    KS_SEEKING_AbsolutePositioning,
    KS_SEEKING_RelativePositioning,
    KS_SEEKING_IncrementalPositioning,
    KS_SEEKING_PositioningBitsMask = 0x3,
    KS_SEEKING_SeekToKeyFrame,
    KS_SEEKING_ReturnTime = 0x8
} KS_SEEKING_FLAGS;

typedef enum {
    KS_SEEKING_CanSeekAbsolute = 0x1,
    KS_SEEKING_CanSeekForwards = 0x2,
    KS_SEEKING_CanSeekBackwards = 0x4,
    KS_SEEKING_CanGetCurrentPos = 0x8,
    KS_SEEKING_CanGetStopPos = 0x10,
    KS_SEEKING_CanGetDuration = 0x20,
    KS_SEEKING_CanPlayBackwards = 0x40
} KS_SEEKING_CAPABILITIES;

typedef struct {
    LONGLONG            Current;
    LONGLONG            Stop;
    KS_SEEKING_FLAGS    CurrentFlags;
    KS_SEEKING_FLAGS    StopFlags;
} KSPROPERTY_POSITIONS, *PKSPROPERTY_POSITIONS;

typedef struct {
    LONGLONG    Earliest;
    LONGLONG    Latest;
} KSPROPERTY_MEDIAAVAILABLE, *PKSPROPERTY_MEDIAAVAILABLE;

typedef struct {
    KSPROPERTY  Property;
    GUID        SourceFormat;
    GUID        TargetFormat;
    LONGLONG    Time;
} KSP_TIMEFORMAT, *PKSP_TIMEFORMAT;

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CAPABILITIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KS_SEEKING_CAPABILITIES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_FORMATS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_TIMEFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_STOPPOSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITIONS,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_POSITIONS),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_DURATION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_AVAILABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_MEDIAAVAILABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_PREROLL,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT,\
        (Handler),\
        sizeof(KSP_TIMEFORMAT),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Topology\
    0x720D4AC0L, 0x7533, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000", KSPROPSETID_Topology);
#define KSPROPSETID_Topology DEFINE_GUIDNAMED(KSPROPSETID_Topology)

typedef enum {
    KSPROPERTY_TOPOLOGY_CATEGORIES,
    KSPROPERTY_TOPOLOGY_NODES,
    KSPROPERTY_TOPOLOGY_CONNECTIONS,
    KSPROPERTY_TOPOLOGY_NAME
} KSPROPERTY_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CATEGORIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NODES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CONNECTIONS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NAME,\
        (Handler),\
        sizeof(KSP_NODE),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_TOPOLOGYSET(TopologySet, Handler)\
DEFINE_KSPROPERTY_TABLE(TopologySet) {\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
}

//=============================================================================

//
// properties used by graph manager to talk to particular filters
//
#if defined(_NTDDK_)

#define STATIC_KSPROPSETID_GM \
    0xAF627536L, 0xE719, 0x11D2, 0x8A, 0x1D, 0x00, 0x60, 0x97, 0xD2, 0xDF, 0x5D    
DEFINE_GUIDSTRUCT("AF627536-E719-11D2-8A1D-006097D2DF5D", KSPROPSETID_GM);
#define KSPROPSETID_GM DEFINE_GUIDNAMED(KSPROPSETID_GM)

typedef VOID (*PFNKSGRAPHMANAGER_NOTIFY)(__in PFILE_OBJECT GraphManager,
                                         __in ULONG EventId,
                                         __in PVOID Filter,
                                         __in PVOID Pin,
                                         __in PVOID Frame,
                                         __in ULONG Duration);

typedef struct KSGRAPHMANAGER_FUNCTIONTABLE {
    PFNKSGRAPHMANAGER_NOTIFY NotifyEvent;
} KSGRAPHMANAGER_FUNCTIONTABLE, PKSGRAPHMANAGER_FUNCTIONTABLE;

typedef struct _KSPROPERTY_GRAPHMANAGER_INTERFACE {
    PFILE_OBJECT                 GraphManager;
    KSGRAPHMANAGER_FUNCTIONTABLE FunctionTable;
} KSPROPERTY_GRAPHMANAGER_INTERFACE, *PKSPROPERTY_GRAPHMANAGER_INTERFACE;


//
// Commands
//
typedef enum {
    KSPROPERTY_GM_GRAPHMANAGER,    
    KSPROPERTY_GM_TIMESTAMP_CLOCK, 
    KSPROPERTY_GM_RATEMATCH,       
    KSPROPERTY_GM_RENDER_CLOCK,    
} KSPROPERTY_GM;

#endif

//===========================================================================


#define STATIC_KSCATEGORY_BRIDGE \
    0x085AFF00L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000", KSCATEGORY_BRIDGE);
#define KSCATEGORY_BRIDGE DEFINE_GUIDNAMED(KSCATEGORY_BRIDGE)

#define STATIC_KSCATEGORY_CAPTURE \
    0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_CAPTURE);
#define KSCATEGORY_CAPTURE DEFINE_GUIDNAMED(KSCATEGORY_CAPTURE)

#define STATIC_KSCATEGORY_RENDER \
    0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_RENDER);
#define KSCATEGORY_RENDER DEFINE_GUIDNAMED(KSCATEGORY_RENDER)

#define STATIC_KSCATEGORY_MIXER \
    0xAD809C00L, 0x7B88, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000", KSCATEGORY_MIXER);
#define KSCATEGORY_MIXER DEFINE_GUIDNAMED(KSCATEGORY_MIXER)

#define STATIC_KSCATEGORY_SPLITTER \
    0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_SPLITTER);
#define KSCATEGORY_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_SPLITTER)

#define STATIC_KSCATEGORY_DATACOMPRESSOR \
    0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATACOMPRESSOR);
#define KSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATACOMPRESSOR)

#define STATIC_KSCATEGORY_DATADECOMPRESSOR \
    0x2721AE20L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATADECOMPRESSOR);
#define KSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATADECOMPRESSOR)

#define STATIC_KSCATEGORY_DATATRANSFORM \
    0x2EB07EA0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATATRANSFORM);
#define KSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_DATATRANSFORM)

//
// KSMFT_CATEGORY_XXX are MF Transform category guids redefined in ks.h 
// to facilitate KS Mini drivers to register KS Filters under MF Transform categories. 
//
#define STATIC_KSMFT_CATEGORY_VIDEO_DECODER \
	0xd6c02d4b, 0x6833, 0x45b4, 0x97, 0x1a, 0x05, 0xa4, 0xb0, 0x4b, 0xab, 0x91
DEFINE_GUIDSTRUCT("d6c02d4b-6833-45b4-971a-05a4b04bab91", KSMFT_CATEGORY_VIDEO_DECODER);
#define KSMFT_CATEGORY_VIDEO_DECODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_DECODER)

#define STATIC_KSMFT_CATEGORY_VIDEO_ENCODER \
	0xf79eac7d, 0xe545, 0x4387, 0xbd, 0xee, 0xd6, 0x47, 0xd7, 0xbd, 0xe4, 0x2a
DEFINE_GUIDSTRUCT("f79eac7d-e545-4387-bdee-d647d7bde42a", KSMFT_CATEGORY_VIDEO_ENCODER);
#define KSMFT_CATEGORY_VIDEO_ENCODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_ENCODER)

#define STATIC_KSMFT_CATEGORY_VIDEO_EFFECT \
	0x12e17c21, 0x532c, 0x4a6e, 0x8a, 0x1c, 0x40, 0x82, 0x5a, 0x73, 0x63, 0x97
DEFINE_GUIDSTRUCT("12e17c21-532c-4a6e-8a1c-40825a736397", KSMFT_CATEGORY_VIDEO_EFFECT);
#define KSMFT_CATEGORY_VIDEO_EFFECT DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_EFFECT)

#define STATIC_KSMFT_CATEGORY_MULTIPLEXER \
	0x059c561e, 0x05ae, 0x4b61, 0xb6, 0x9d, 0x55, 0xb6, 0x1e, 0xe5, 0x4a, 0x7b
DEFINE_GUIDSTRUCT("059c561e-05ae-4b61-b69d-55b61ee54a7b", KSMFT_CATEGORY_MULTIPLEXER);
#define KSMFT_CATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSMFT_CATEGORY_MULTIPLEXER)

#define STATIC_KSMFT_CATEGORY_DEMULTIPLEXER \
	0xa8700a7a, 0x939b, 0x44c5, 0x99, 0xd7, 0x76, 0x22, 0x6b, 0x23, 0xb3, 0xf1
DEFINE_GUIDSTRUCT("a8700a7a-939b-44c5-99d7-76226b23b3f1", KSMFT_CATEGORY_DEMULTIPLEXER);
#define KSMFT_CATEGORY_DEMULTIPLEXER DEFINE_GUIDNAMED(KSMFT_CATEGORY_DEMULTIPLEXER)

#define STATIC_KSMFT_CATEGORY_AUDIO_DECODER \
	0x9ea73fb4, 0xef7a, 0x4559, 0x8d, 0x5d, 0x71, 0x9d, 0x8f, 0x04, 0x26, 0xc7
DEFINE_GUIDSTRUCT("9ea73fb4-ef7a-4559-8d5d-719d8f0426c7", KSMFT_CATEGORY_AUDIO_DECODER);
#define KSMFT_CATEGORY_AUDIO_DECODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_DECODER)

#define STATIC_KSMFT_CATEGORY_AUDIO_ENCODER \
	0x91c64bd0, 0xf91e, 0x4d8c, 0x92, 0x76, 0xdb, 0x24, 0x82, 0x79, 0xd9, 0x75
DEFINE_GUIDSTRUCT("91c64bd0-f91e-4d8c-9276-db248279d975", KSMFT_CATEGORY_AUDIO_ENCODER);
#define KSMFT_CATEGORY_AUDIO_ENCODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_ENCODER)

#define STATIC_KSMFT_CATEGORY_AUDIO_EFFECT \
	0x11064c48, 0x3648, 0x4ed0, 0x93, 0x2e, 0x05, 0xce, 0x8a, 0xc8, 0x11, 0xb7
DEFINE_GUIDSTRUCT("11064c48-3648-4ed0-932e-05ce8ac811b7", KSMFT_CATEGORY_AUDIO_EFFECT);
#define KSMFT_CATEGORY_AUDIO_EFFECT DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_EFFECT)

#define STATIC_KSMFT_CATEGORY_VIDEO_PROCESSOR \
	0x302ea3fc, 0xaa5f, 0x47f9, 0x9f, 0x7a, 0xc2, 0x18, 0x8b, 0xb1, 0x63, 0x2
DEFINE_GUIDSTRUCT("302ea3fc-aa5f-47f9-9f7a-c2188bb16302", KSMFT_CATEGORY_VIDEO_PROCESSOR);
#define KSMFT_CATEGORY_VIDEO_PROCESSOR DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_PROCESSOR)

#define STATIC_KSMFT_CATEGORY_OTHER \
	0x90175d57, 0xb7ea, 0x4901, 0xae, 0xb3, 0x93, 0x3a, 0x87, 0x47, 0x75, 0x6f
DEFINE_GUIDSTRUCT("90175d57-b7ea-4901-aeb3-933a8747756f", KSMFT_CATEGORY_OTHER);
#define KSMFT_CATEGORY_OTHER DEFINE_GUIDNAMED(KSMFT_CATEGORY_OTHER)

#define STATIC_KSCATEGORY_COMMUNICATIONSTRANSFORM \
    0xCF1DDA2CL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_COMMUNICATIONSTRANSFORM);
#define KSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_COMMUNICATIONSTRANSFORM)

#define STATIC_KSCATEGORY_INTERFACETRANSFORM \
    0xCF1DDA2DL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_INTERFACETRANSFORM);
#define KSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_INTERFACETRANSFORM)

#define STATIC_KSCATEGORY_MEDIUMTRANSFORM \
    0xCF1DDA2EL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_MEDIUMTRANSFORM);
#define KSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_MEDIUMTRANSFORM)

#define STATIC_KSCATEGORY_FILESYSTEM \
    0x760FED5EL, 0x9357, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196", KSCATEGORY_FILESYSTEM);
#define KSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(KSCATEGORY_FILESYSTEM)

// KSNAME_Clock
#define STATIC_KSCATEGORY_CLOCK \
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSCATEGORY_CLOCK);
#define KSCATEGORY_CLOCK DEFINE_GUIDNAMED(KSCATEGORY_CLOCK)

#define STATIC_KSCATEGORY_PROXY \
    0x97EBAACAL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_PROXY);
#define KSCATEGORY_PROXY DEFINE_GUIDNAMED(KSCATEGORY_PROXY)

#define STATIC_KSCATEGORY_QUALITY \
    0x97EBAACBL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_QUALITY);
#define KSCATEGORY_QUALITY DEFINE_GUIDNAMED(KSCATEGORY_QUALITY)

typedef struct {
    ULONG   FromNode;
    ULONG   FromNodePin;
    ULONG   ToNode;
    ULONG   ToNodePin;
} KSTOPOLOGY_CONNECTION, *PKSTOPOLOGY_CONNECTION;

typedef struct {
    ULONG                           CategoriesCount;
    __field_ecount(CategoriesCount)
    const GUID*                     Categories;
    ULONG                           TopologyNodesCount;
    __field_ecount(TopologyNodesCount)
    const GUID*                     TopologyNodes;
    ULONG                           TopologyConnectionsCount;
    __field_ecount(TopologyConnectionsCount)
    const KSTOPOLOGY_CONNECTION*    TopologyConnections;
    __field_ecount(TopologyNodesCount)
    const GUID*                     TopologyNodesNames;
    ULONG                           Reserved;
} KSTOPOLOGY, *PKSTOPOLOGY;

#define KSFILTER_NODE   ((ULONG)-1)
#define KSALL_NODES     ((ULONG)-1)

typedef struct {
    ULONG       CreateFlags;
    ULONG       Node;
} KSNODE_CREATE, *PKSNODE_CREATE;

//===========================================================================

// TIME_FORMAT_NONE
#define STATIC_KSTIME_FORMAT_NONE       STATIC_GUID_NULL
#define KSTIME_FORMAT_NONE              GUID_NULL

// TIME_FORMAT_FRAME
#define STATIC_KSTIME_FORMAT_FRAME\
    0x7b785570L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FRAME);
#define KSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(KSTIME_FORMAT_FRAME)

// TIME_FORMAT_BYTE             
#define STATIC_KSTIME_FORMAT_BYTE\
    0x7b785571L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_BYTE);
#define KSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(KSTIME_FORMAT_BYTE)

// TIME_FORMAT_SAMPLE
#define STATIC_KSTIME_FORMAT_SAMPLE\
    0x7b785572L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_SAMPLE);
#define KSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(KSTIME_FORMAT_SAMPLE)

// TIME_FORMAT_FIELD
#define STATIC_KSTIME_FORMAT_FIELD\
    0x7b785573L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FIELD);
#define KSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(KSTIME_FORMAT_FIELD)

// TIME_FORMAT_MEDIA_TIME
#define STATIC_KSTIME_FORMAT_MEDIA_TIME\
    0x7b785574L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_MEDIA_TIME);
#define KSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(KSTIME_FORMAT_MEDIA_TIME)

//===========================================================================

typedef KSIDENTIFIER KSPIN_INTERFACE, *PKSPIN_INTERFACE;

#define STATIC_KSINTERFACESETID_Standard \
    0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000", KSINTERFACESETID_Standard);
#define KSINTERFACESETID_Standard DEFINE_GUIDNAMED(KSINTERFACESETID_Standard)

typedef enum {
    KSINTERFACE_STANDARD_STREAMING,
    KSINTERFACE_STANDARD_LOOPED_STREAMING,
    KSINTERFACE_STANDARD_CONTROL		//Reserved for system use
} KSINTERFACE_STANDARD;

#define STATIC_KSINTERFACESETID_FileIo \
    0x8C6F932CL, 0xE771, 0x11D0, 0xB8, 0xFF, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196", KSINTERFACESETID_FileIo);
#define KSINTERFACESETID_FileIo DEFINE_GUIDNAMED(KSINTERFACESETID_FileIo)

typedef enum {
    KSINTERFACE_FILEIO_STREAMING
} KSINTERFACE_FILEIO;

//===========================================================================

#define KSMEDIUM_TYPE_ANYINSTANCE       0

#define STATIC_KSMEDIUMSETID_Standard \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000", KSMEDIUMSETID_Standard);
#define KSMEDIUMSETID_Standard DEFINE_GUIDNAMED(KSMEDIUMSETID_Standard)

//For compatibility only
#define KSMEDIUM_STANDARD_DEVIO     KSMEDIUM_TYPE_ANYINSTANCE

//===========================================================================

#define STATIC_KSPROPSETID_Pin\
    0x8C134960L, 0x51AD, 0x11CF, 0x87, 0x8A, 0x94, 0xF8, 0x01, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000", KSPROPSETID_Pin);
#define KSPROPSETID_Pin DEFINE_GUIDNAMED(KSPROPSETID_Pin)

typedef enum {
    KSPROPERTY_PIN_CINSTANCES,
    KSPROPERTY_PIN_CTYPES,
    KSPROPERTY_PIN_DATAFLOW,
    KSPROPERTY_PIN_DATARANGES,
    KSPROPERTY_PIN_DATAINTERSECTION,
    KSPROPERTY_PIN_INTERFACES,
    KSPROPERTY_PIN_MEDIUMS,
    KSPROPERTY_PIN_COMMUNICATION,
    KSPROPERTY_PIN_GLOBALCINSTANCES,
    KSPROPERTY_PIN_NECESSARYINSTANCES,
    KSPROPERTY_PIN_PHYSICALCONNECTION,
    KSPROPERTY_PIN_CATEGORY,
    KSPROPERTY_PIN_NAME,
    KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
    KSPROPERTY_PIN_PROPOSEDATAFORMAT
} KSPROPERTY_PIN;

typedef struct {
    KSPROPERTY      Property;
    ULONG           PinId;
    ULONG           Reserved;
} KSP_PIN, *PKSP_PIN;

typedef struct {
    KSEVENT         Event;
    ULONG           PinId;
    ULONG           Reserved;
} KSE_PIN, *PKSE_PIN;

#define KSINSTANCE_INDETERMINATE    ((ULONG)-1)

typedef struct {
    ULONG  PossibleCount;
    ULONG  CurrentCount;
} KSPIN_CINSTANCES, *PKSPIN_CINSTANCES;

typedef enum {
    KSPIN_DATAFLOW_IN = 1,
    KSPIN_DATAFLOW_OUT
} KSPIN_DATAFLOW, *PKSPIN_DATAFLOW;

#define KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION   0
#define KSDATAFORMAT_TEMPORAL_COMPRESSION       (1 << KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
#define KSDATAFORMAT_BIT_ATTRIBUTES 1
#define KSDATAFORMAT_ATTRIBUTES (1 << KSDATAFORMAT_BIT_ATTRIBUTES)

#define KSDATARANGE_BIT_ATTRIBUTES 1
#define KSDATARANGE_ATTRIBUTES (1 << KSDATARANGE_BIT_ATTRIBUTES)
#define KSDATARANGE_BIT_REQUIRED_ATTRIBUTES 2
#define KSDATARANGE_REQUIRED_ATTRIBUTES (1 << KSDATARANGE_BIT_REQUIRED_ATTRIBUTES)

#if !defined( _MSC_VER ) 
typedef struct {
    ULONG   FormatSize;
    ULONG   Flags;
    ULONG   SampleSize;
    ULONG   Reserved;
    GUID    MajorFormat;
    GUID    SubFormat;
    GUID    Specifier;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#else
typedef union {
    struct {
        ULONG   FormatSize;
        ULONG   Flags;
        ULONG   SampleSize;
        ULONG   Reserved;
        GUID    MajorFormat;
        GUID    SubFormat;
        GUID    Specifier;
    };
    LONGLONG    Alignment;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#endif

#define KSATTRIBUTE_REQUIRED 0x00000001

typedef struct {
    ULONG Size;
    ULONG Flags;
    GUID Attribute;
} KSATTRIBUTE, *PKSATTRIBUTE;

#if defined(_NTDDK_)
typedef struct {
    ULONG Count;
    __field_ecount(Count) PKSATTRIBUTE* Attributes;
} KSATTRIBUTE_LIST, *PKSATTRIBUTE_LIST;
#endif // _NTDDK_

typedef enum {
    KSPIN_COMMUNICATION_NONE,
    KSPIN_COMMUNICATION_SINK,
    KSPIN_COMMUNICATION_SOURCE,
    KSPIN_COMMUNICATION_BOTH,
    KSPIN_COMMUNICATION_BRIDGE
} KSPIN_COMMUNICATION, *PKSPIN_COMMUNICATION;

typedef KSIDENTIFIER KSPIN_MEDIUM, *PKSPIN_MEDIUM;

typedef struct {
    KSPIN_INTERFACE Interface;
    KSPIN_MEDIUM    Medium;
    ULONG           PinId;
    HANDLE          PinToHandle;
    KSPRIORITY      Priority;
} KSPIN_CONNECT, *PKSPIN_CONNECT;

typedef struct {
    ULONG   Size;
    ULONG   Pin;
    WCHAR   SymbolicLinkName[1];
} KSPIN_PHYSICALCONNECTION, *PKSPIN_PHYSICALCONNECTION;

#if defined(_NTDDK_)
__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLER)(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __in PKSDATARANGE DataRange,
    __out_opt PVOID Data
    );
__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLEREX)(
    __in PVOID Context,
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __in PKSDATARANGE DataRange,
    __in PKSDATARANGE MatchingDataRange,
    __in ULONG DataBufferSize,
    __out_bcount_part_opt(DataBufferSize, *DataSize) PVOID Data,
    __out PULONG DataSize
    );
#endif // _NTDDK_

#define DEFINE_KSPIN_INTERFACE_TABLE(tablename)\
    const KSPIN_INTERFACE tablename[] =

#define DEFINE_KSPIN_INTERFACE_ITEM(guid, interface)\
    {\
        STATICGUIDOF(guid),\
        (interface),\
        0\
    }

#define DEFINE_KSPIN_MEDIUM_TABLE( tablename )\
    const KSPIN_MEDIUM tablename[] =

#define DEFINE_KSPIN_MEDIUM_ITEM(guid, medium)\
    DEFINE_KSPIN_INTERFACE_ITEM(guid, medium)

#define DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CTYPES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAFLOW,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_DATAFLOW),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAINTERSECTION,\
        (Handler),\
        sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_INTERFACES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_MEDIUMS,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_COMMUNICATION,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_COMMUNICATION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_GLOBALCINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NECESSARYINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PHYSICALCONNECTION,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CATEGORY,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NAME,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSP_PIN),\
        sizeof(KSDATAFORMAT),\
        (Handler), NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_PINSET(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral)\
}

#define DEFINE_KSPROPERTY_PINSETCONSTRAINED(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)\
}

#define STATIC_KSEVENTSETID_PinCapsChange \
    0xDD4F192E, 0x3B78, 0x49AD, 0xA5, 0x34, 0x2C, 0x31, 0x5b, 0x82, 0x20, 0x00
DEFINE_GUIDSTRUCT("DD4F192E-3B78-49AD-A534-2C315B822000", KSEVENTSETID_PinCapsChange);
#define KSEVENTSETID_PinCapsChange DEFINE_GUIDNAMED(KSEVENTSETID_PinCapsChange)

typedef enum {
    KSEVENT_PINCAPS_FORMATCHANGE,
    KSEVENT_PINCAPS_JACKINFOCHANGE
} KSEVENT_PINCAPS_CHANGENOTIFICATIONS;

#define STATIC_KSNAME_Filter\
    0x9b365890L, 0x165f, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_Filter);
#define KSNAME_Filter DEFINE_GUIDNAMED(KSNAME_Filter)

#define KSSTRING_Filter L"{9B365890-165F-11D0-A195-0020AFD156E4}"

#define STATIC_KSNAME_Pin\
    0x146F1A80L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000", KSNAME_Pin);
#define KSNAME_Pin DEFINE_GUIDNAMED(KSNAME_Pin)

#define KSSTRING_Pin L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Clock\
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSNAME_Clock);
#define KSNAME_Clock DEFINE_GUIDNAMED(KSNAME_Clock)

#define KSSTRING_Clock L"{53172480-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Allocator\
    0x642F5D00L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000", KSNAME_Allocator);
#define KSNAME_Allocator DEFINE_GUIDNAMED(KSNAME_Allocator)

#define KSSTRING_Allocator L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"

#define KSSTRING_AllocatorEx L"{091BB63B-603F-11D1-B067-00A0C9062802}"

#define STATIC_KSNAME_TopologyNode\
    0x0621061AL, 0xEE75, 0x11D0, 0xB9, 0x15, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196", KSNAME_TopologyNode);
#define KSNAME_TopologyNode DEFINE_GUIDNAMED(KSNAME_TopologyNode)

#define KSSTRING_TopologyNode L"{0621061A-EE75-11D0-B915-00A0C9223196}"

#if defined(_NTDDK_)

typedef struct {
    ULONG                   InterfacesCount;
    __field_ecount(InterfacesCount)
    const KSPIN_INTERFACE*  Interfaces;
    ULONG                   MediumsCount;
    __field_ecount(MediumsCount)
    const KSPIN_MEDIUM*     Mediums;
    ULONG                   DataRangesCount;
    __field_ecount(DataRangesCount)
    const PKSDATARANGE*     DataRanges;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    const GUID*             Category;
    const GUID*             Name;
    union {
        LONGLONG            Reserved;
        struct {
            ULONG           ConstrainedDataRangesCount;
            __field_ecount(ConstrainedDataRangesCount)
            PKSDATARANGE*   ConstrainedDataRanges;
        };
    };
} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;
typedef const KSPIN_DESCRIPTOR *PCKSPIN_DESCRIPTOR;

#define DEFINE_KSPIN_DESCRIPTOR_TABLE(tablename)\
    const KSPIN_DESCRIPTOR tablename[] =

#define DEFINE_KSPIN_DESCRIPTOR_ITEM(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    NULL, NULL, 0\
}
#define DEFINE_KSPIN_DESCRIPTOR_ITEMEX(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication,\
    Category, Name)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    Category, Name, 0\
}

#endif // defined(_NTDDK_)

//===========================================================================

// MEDIATYPE_NULL
#define STATIC_KSDATAFORMAT_TYPE_WILDCARD       STATIC_GUID_NULL
#define KSDATAFORMAT_TYPE_WILDCARD              GUID_NULL

// MEDIASUBTYPE_NULL
#define STATIC_KSDATAFORMAT_SUBTYPE_WILDCARD    STATIC_GUID_NULL
#define KSDATAFORMAT_SUBTYPE_WILDCARD           GUID_NULL

// MEDIATYPE_Stream
#define STATIC_KSDATAFORMAT_TYPE_STREAM\
    0xE436EB83L, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_TYPE_STREAM);
#define KSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STREAM)

// MEDIASUBTYPE_None
#define STATIC_KSDATAFORMAT_SUBTYPE_NONE\
    0xE436EB8EL, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_SUBTYPE_NONE);
#define KSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NONE)

#define STATIC_KSDATAFORMAT_SPECIFIER_WILDCARD  STATIC_GUID_NULL
#define KSDATAFORMAT_SPECIFIER_WILDCARD         GUID_NULL

#define STATIC_KSDATAFORMAT_SPECIFIER_FILENAME\
    0xAA797B40L, 0xE974, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SPECIFIER_FILENAME);
#define KSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILENAME)

#define STATIC_KSDATAFORMAT_SPECIFIER_FILEHANDLE\
    0x65E8773CL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196", KSDATAFORMAT_SPECIFIER_FILEHANDLE);
#define KSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILEHANDLE)

// FORMAT_None
#define STATIC_KSDATAFORMAT_SPECIFIER_NONE\
    0x0F6417D6L, 0xC318, 0x11D0, 0xA4, 0x3F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196", KSDATAFORMAT_SPECIFIER_NONE);
#define KSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_NONE)

//===========================================================================

#define STATIC_KSPROPSETID_Quality \
    0xD16AD380L, 0xAC1A, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000", KSPROPSETID_Quality);
#define KSPROPSETID_Quality DEFINE_GUIDNAMED(KSPROPSETID_Quality)

typedef enum {
    KSPROPERTY_QUALITY_REPORT,
    KSPROPERTY_QUALITY_ERROR
} KSPROPERTY_QUALITY;

#define DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_REPORT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_ERROR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSERROR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Connection \
    0x1D58C920L, 0xAC9B, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000", KSPROPSETID_Connection);
#define KSPROPSETID_Connection DEFINE_GUIDNAMED(KSPROPSETID_Connection)

typedef enum {
    KSPROPERTY_CONNECTION_STATE,
    KSPROPERTY_CONNECTION_PRIORITY,
    KSPROPERTY_CONNECTION_DATAFORMAT,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
    KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
    KSPROPERTY_CONNECTION_ACQUIREORDERING,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
    KSPROPERTY_CONNECTION_STARTAT
} KSPROPERTY_CONNECTION;

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PRIORITY,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPRIORITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_DATAFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSALLOCATOR_FRAMING),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDATAFORMAT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ACQUIREORDERING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(int),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STARTAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSRELATIVEEVENT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
//VRAM transport related propset
//===========================================================================

#define STATIC_KSPROPSETID_MemoryTransport \
    0xa3d1c5d, 0x5243, 0x4819, 0x9e, 0xd0, 0xae, 0xe8, 0x4, 0x4c, 0xee, 0x2b
DEFINE_GUIDSTRUCT("0A3D1C5D-5243-4819-9ED0-AEE8044CEE2B", KSPROPSETID_MemoryTransport);
#define KSPROPSETID_MemoryTransport DEFINE_GUIDNAMED(KSPROPSETID_MemoryTransport)
enum {
    // a value of zero is ignored
    KSPROPERTY_MEMORY_TRANSPORT = 1 //Sets pin's memory transport mechanism e.g. VRAM or SYSMEM
};

#define DEFINE_KSPROPERTY_ITEM_MEMORY_TRANSPORT(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEMORY_TRANSPORT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
//
// pins flags
//
#define KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER   0x00000001
#define KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY      0x00000002
#define KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY    0x00000004
#define KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE      0x00000008
#define KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY   0x80000000

#define KSALLOCATOR_OPTIONF_COMPATIBLE              0x00000001
#define KSALLOCATOR_OPTIONF_SYSTEM_MEMORY           0x00000002
#define KSALLOCATOR_OPTIONF_VALID                   0x00000003
// 
// pins extended framing flags
//
#define KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT       0x00000010
#define KSALLOCATOR_FLAG_DEVICE_SPECIFIC            0x00000020
#define KSALLOCATOR_FLAG_CAN_ALLOCATE               0x00000040
#define KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO  0x00000080
//
// allocator pipes flags
//
// there is at least one data modification in a pipe
#define KSALLOCATOR_FLAG_NO_FRAME_INTEGRITY         0x00000100
#define KSALLOCATOR_FLAG_MULTIPLE_OUTPUT            0x00000200
#define KSALLOCATOR_FLAG_CYCLE                      0x00000400
#define KSALLOCATOR_FLAG_ALLOCATOR_EXISTS           0x00000800
// there is no framing dependency between neighbouring pipes.
#define KSALLOCATOR_FLAG_INDEPENDENT_RANGES         0x00001000
#define KSALLOCATOR_FLAG_ATTENTION_STEPPING         0x00002000


//
// old Framing structure
//
typedef struct {
    union {
        ULONG       OptionsFlags;       // allocator options (create)
        ULONG       RequirementsFlags;  // allocation requirements (query)
    };
#if defined(_NTDDK_)
    POOL_TYPE   PoolType;
#else // !_NTDDK_
    ULONG       PoolType;
#endif // !_NTDDK_
    ULONG       Frames;     // total number of allowable outstanding frames
    ULONG       FrameSize;  // total size of frame
    ULONG       FileAlignment;
    ULONG       Reserved;
} KSALLOCATOR_FRAMING, *PKSALLOCATOR_FRAMING;

#if defined(_NTDDK_)
typedef
PVOID
(*PFNKSDEFAULTALLOCATE)(
    __in PVOID Context
    );

typedef
VOID
(*PFNKSDEFAULTFREE)(
    __in PVOID Context,
    __in PVOID Buffer
    );

typedef
NTSTATUS
(*PFNKSINITIALIZEALLOCATOR)(
    __in PVOID InitialContext,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __deref_out PVOID* Context
    );

typedef
VOID
(*PFNKSDELETEALLOCATOR)(
    __in PVOID Context
    );
#endif // !_NTDDK_

//
// new Framing structure, eventually will replace KSALLOCATOR_FRAMING.
// 
typedef struct {
    ULONG   MinFrameSize;
    ULONG   MaxFrameSize;
    ULONG   Stepping;
} KS_FRAMING_RANGE, *PKS_FRAMING_RANGE;


typedef struct {
    KS_FRAMING_RANGE  Range;
    ULONG             InPlaceWeight;
    ULONG             NotInPlaceWeight;
} KS_FRAMING_RANGE_WEIGHTED, *PKS_FRAMING_RANGE_WEIGHTED;


typedef struct {
    ULONG   RatioNumerator;      // compression/expansion ratio
    ULONG   RatioDenominator; 
    ULONG   RatioConstantMargin;
} KS_COMPRESSION, *PKS_COMPRESSION;


//
// Memory Types and Buses are repeated in each entry.
// Easiest to use but takes a little more memory than the varsize layout Pin\Memories\Buses\Ranges.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       MemoryFlags;
    ULONG                       BusFlags;   
    ULONG                       Flags;   
    ULONG                       Frames;              // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    ULONG                       MemoryTypeWeight;    // this memory type Weight pin-wide
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   FramingRange; 
} KS_FRAMING_ITEM, *PKS_FRAMING_ITEM;


typedef struct {
    ULONG               CountItems;         // count of FramingItem-s below.
    ULONG               PinFlags;
    KS_COMPRESSION      OutputCompression;
    ULONG               PinWeight;          // this pin framing's Weight graph-wide
    KS_FRAMING_ITEM     FramingItem[1]; 
} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;



//
// define memory type GUIDs
//
#define KSMEMORY_TYPE_WILDCARD          GUID_NULL
#define STATIC_KSMEMORY_TYPE_WILDCARD   STATIC_GUID_NULL

#define KSMEMORY_TYPE_DONT_CARE         GUID_NULL
#define STATIC_KSMEMORY_TYPE_DONT_CARE  STATIC_GUID_NULL

#define KS_TYPE_DONT_CARE           GUID_NULL
#define STATIC_KS_TYPE_DONT_CARE    STATIC_GUID_NULL
     
#define STATIC_KSMEMORY_TYPE_SYSTEM \
    0x091bb638L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_SYSTEM);
#define KSMEMORY_TYPE_SYSTEM  DEFINE_GUIDNAMED(KSMEMORY_TYPE_SYSTEM)

#define STATIC_KSMEMORY_TYPE_USER \
    0x8cb0fc28L, 0x7893, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802", KSMEMORY_TYPE_USER);
#define KSMEMORY_TYPE_USER  DEFINE_GUIDNAMED(KSMEMORY_TYPE_USER)

#define STATIC_KSMEMORY_TYPE_KERNEL_PAGED \
    0xd833f8f8L, 0x7894, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_PAGED);
#define KSMEMORY_TYPE_KERNEL_PAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_PAGED)

#define STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED \
    0x4a6d5fc4L, 0x7895, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_NONPAGED);
#define KSMEMORY_TYPE_KERNEL_NONPAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_NONPAGED)

// old KS clients did not specify the device memory type
#define STATIC_KSMEMORY_TYPE_DEVICE_UNKNOWN \
    0x091bb639L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_DEVICE_UNKNOWN);
#define KSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(KSMEMORY_TYPE_DEVICE_UNKNOWN)

//
// Helper framing macros.
//
#define DECLARE_SIMPLE_FRAMING_EX(FramingExName, MemoryType, Flags, Frames, Alignment, MinFrameSize, MaxFrameSize) \
    const KSALLOCATOR_FRAMING_EX FramingExName = \
    {\
        1, \
        0, \
        {\
            1, \
            1, \
            0 \
        }, \
        0, \
        {\
            {\
                MemoryType, \
                STATIC_KS_TYPE_DONT_CARE, \
                0, \
                0, \
                Flags, \
                Frames, \
                Alignment, \
                0, \
                {\
                    0, \
                    (ULONG)-1, \
                    1 \
                }, \
                {\
                    {\
                        MinFrameSize, \
                        MaxFrameSize, \
                        1 \
                    }, \
                    0, \
                    0  \
                }\
            }\
        }\
    }

#define SetDefaultKsCompression(KsCompressionPointer) \
{\
    KsCompressionPointer->RatioNumerator = 1;\
    KsCompressionPointer->RatioDenominator = 1;\
    KsCompressionPointer->RatioConstantMargin = 0;\
}

#define SetDontCareKsFramingRange(KsFramingRangePointer) \
{\
    KsFramingRangePointer->MinFrameSize = 0;\
    KsFramingRangePointer->MaxFrameSize = (ULONG) -1;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRange(KsFramingRangePointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KsFramingRangePointer->MinFrameSize = P_MinFrameSize;\
    KsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRangeWeighted(KsFramingRangeWeightedPointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_FRAMING_RANGE *KsFramingRange = &KsFramingRangeWeightedPointer->Range;\
    SetKsFramingRange(KsFramingRange, P_MinFrameSize, P_MaxFrameSize);\
    KsFramingRangeWeightedPointer->InPlaceWeight = 0;\
    KsFramingRangeWeightedPointer->NotInPlaceWeight = 0;\
}

#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer, P_MemoryType, P_Flags, P_Frames, P_Alignment, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_COMPRESSION *KsCompression = &FramingExPointer->OutputCompression;\
    KS_FRAMING_RANGE *KsFramingRange = &FramingExPointer->FramingItem[0].PhysicalRange;\
    KS_FRAMING_RANGE_WEIGHTED *KsFramingRangeWeighted = &FramingExPointer->FramingItem[0].FramingRange;\
    FramingExPointer->CountItems = 1;\
    FramingExPointer->PinFlags = 0;\
    SetDefaultKsCompression(KsCompression);\
    FramingExPointer->PinWeight = 0;\
    FramingExPointer->FramingItem[0].MemoryType = P_MemoryType;\
    FramingExPointer->FramingItem[0].BusType = KS_TYPE_DONT_CARE;\
    FramingExPointer->FramingItem[0].MemoryFlags = 0;\
    FramingExPointer->FramingItem[0].BusFlags = 0;\
    FramingExPointer->FramingItem[0].Flags = P_Flags;\
    FramingExPointer->FramingItem[0].Frames = P_Frames;\
    FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;\
    FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;\
    SetDontCareKsFramingRange(KsFramingRange);\
    SetKsFramingRangeWeighted(KsFramingRangeWeighted, P_MinFrameSize, P_MaxFrameSize);\
}



// KSEVENTSETID_StreamAllocator: {75D95571-073C-11d0-A161-0020AFD156E4}

#define STATIC_KSEVENTSETID_StreamAllocator\
    0x75d95571L, 0x073c, 0x11d0, 0xa1, 0x61, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4", KSEVENTSETID_StreamAllocator);
#define KSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(KSEVENTSETID_StreamAllocator)

typedef enum {
    KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
    KSEVENT_STREAMALLOCATOR_FREEFRAME
} KSEVENT_STREAMALLOCATOR;

#define STATIC_KSMETHODSETID_StreamAllocator\
    0xcf6e4341L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4", KSMETHODSETID_StreamAllocator);
#define KSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(KSMETHODSETID_StreamAllocator)

typedef enum {
    KSMETHOD_STREAMALLOCATOR_ALLOC,
    KSMETHOD_STREAMALLOCATOR_FREE
} KSMETHOD_STREAMALLOCATOR;

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_ALLOC,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_FREE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ALLOCATORSET(AllocatorSet, MethodAlloc, MethodFree)\
DEFINE_KSMETHOD_TABLE(AllocatorSet) {\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)\
}

#define STATIC_KSPROPSETID_StreamAllocator\
    0xcf6e4342L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4", KSPROPSETID_StreamAllocator);
#define KSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(KSPROPSETID_StreamAllocator)

#if defined(_NTDDK_)
typedef enum {
    KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
    KSPROPERTY_STREAMALLOCATOR_STATUS
} KSPROPERTY_STREAMALLOCATOR;

#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_STATUS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_STATUS),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ALLOCATORSET(AllocatorSet, PropFunctionTable, PropStatus)\
DEFINE_KSPROPERTY_TABLE(AllocatorSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable)\
}

typedef
NTSTATUS
(*PFNALLOCATOR_ALLOCATEFRAME)(
    __in PFILE_OBJECT FileObject,
    __deref_out PVOID *Frame
    );

typedef
VOID
(*PFNALLOCATOR_FREEFRAME)(
    __in PFILE_OBJECT FileObject,
    __in PVOID Frame
    );

typedef struct {
    PFNALLOCATOR_ALLOCATEFRAME  AllocateFrame;
    PFNALLOCATOR_FREEFRAME      FreeFrame;
} KSSTREAMALLOCATOR_FUNCTIONTABLE, *PKSSTREAMALLOCATOR_FUNCTIONTABLE;
#endif // defined(_NTDDK_)

typedef struct {
    KSALLOCATOR_FRAMING Framing;
    ULONG               AllocatedFrames;
    ULONG               Reserved;
} KSSTREAMALLOCATOR_STATUS, *PKSSTREAMALLOCATOR_STATUS;

typedef struct {
    KSALLOCATOR_FRAMING_EX Framing;
    ULONG                  AllocatedFrames;
    ULONG                  Reserved;
} KSSTREAMALLOCATOR_STATUS_EX, *PKSSTREAMALLOCATOR_STATUS_EX;


#define KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT        0x00000001
#define KSSTREAM_HEADER_OPTIONSF_PREROLL            0x00000002
#define KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY  0x00000004
#define KSSTREAM_HEADER_OPTIONSF_TYPECHANGED        0x00000008
#define KSSTREAM_HEADER_OPTIONSF_TIMEVALID          0x00000010
#define KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY  0x00000040
#define KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE       0x00000080
#define KSSTREAM_HEADER_OPTIONSF_DURATIONVALID      0x00000100
#define KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM        0x00000200
#define KSSTREAM_HEADER_OPTIONSF_BUFFEREDTRANSFER   0x00000400
#define KSSTREAM_HEADER_OPTIONSF_VRAM_DATA_TRANSFER 0x00000800
#define KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA         0x80000000

typedef struct {
    LONGLONG    Time;
    ULONG       Numerator;
    ULONG       Denominator;
} KSTIME, *PKSTIME;

typedef struct {
    ULONG       Size;
    ULONG       TypeSpecificFlags;
    KSTIME      PresentationTime;
    LONGLONG    Duration;
    ULONG       FrameExtent;
    ULONG       DataUsed;
    __field_bcount(FrameExtent)
    PVOID       Data;
    ULONG       OptionsFlags;
#if _WIN64
    ULONG       Reserved;
#endif
} KSSTREAM_HEADER, *PKSSTREAM_HEADER;

#define STATIC_KSPROPSETID_StreamInterface\
    0x1fdd8ee1L, 0x9cd3, 0x11d0, 0x82, 0xaa, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a", KSPROPSETID_StreamInterface);
#define KSPROPSETID_StreamInterface DEFINE_GUIDNAMED(KSPROPSETID_StreamInterface)

typedef enum {
    KSPROPERTY_STREAMINTERFACE_HEADERSIZE
} KSPROPERTY_STREAMINTERFACE;

#define DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( GetHandler )\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMINTERFACE_HEADERSIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet,\
    HeaderSizeHandler)\
DEFINE_KSPROPERTY_TABLE(StreamInterfaceSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( HeaderSizeHandler )\
}

#define STATIC_KSPROPSETID_Stream\
    0x65aaba60L, 0x98ae, 0x11cf, 0xa1, 0x0d, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4", KSPROPSETID_Stream);
#define KSPROPSETID_Stream DEFINE_GUIDNAMED(KSPROPSETID_Stream)

typedef enum {
    KSPROPERTY_STREAM_ALLOCATOR,
    KSPROPERTY_STREAM_QUALITY,
    KSPROPERTY_STREAM_DEGRADATION,
    KSPROPERTY_STREAM_MASTERCLOCK,
    KSPROPERTY_STREAM_TIMEFORMAT,
    KSPROPERTY_STREAM_PRESENTATIONTIME,
    KSPROPERTY_STREAM_PRESENTATIONEXTENT,
    KSPROPERTY_STREAM_FRAMETIME,
    KSPROPERTY_STREAM_RATECAPABILITY,
    KSPROPERTY_STREAM_RATE,
    KSPROPERTY_STREAM_PIPE_ID
} KSPROPERTY_STREAM;

#define DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_ALLOCATOR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_QUALITY,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY_MANAGER),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_DEGRADATION,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_MASTERCLOCK,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_TIMEFORMAT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONTIME,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSTIME),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONEXTENT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_FRAMETIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSFRAMETIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATECAPABILITY,\
        (Handler),\
        sizeof(KSRATE_CAPABILITY),\
        sizeof(KSRATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PIPE_ID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

typedef struct {
    HANDLE      QualityManager;
    PVOID       Context;
} KSQUALITY_MANAGER, *PKSQUALITY_MANAGER;

typedef struct {
    LONGLONG    Duration;
    ULONG       FrameFlags;
    ULONG       Reserved;
} KSFRAMETIME, *PKSFRAMETIME;

#define KSFRAMETIME_VARIABLESIZE    0x00000001

typedef struct {
    LONGLONG        PresentationStart;
    LONGLONG        Duration;
    KSPIN_INTERFACE Interface;
    LONG            Rate;
    ULONG           Flags;
} KSRATE, *PKSRATE;

#define KSRATE_NOPRESENTATIONSTART      0x00000001
#define KSRATE_NOPRESENTATIONDURATION   0x00000002

typedef struct {
    KSPROPERTY      Property;
    KSRATE          Rate;
} KSRATE_CAPABILITY, *PKSRATE_CAPABILITY;

#define STATIC_KSPROPSETID_Clock \
    0xDF12A4C0L, 0xAC17, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000", KSPROPSETID_Clock);
#define KSPROPSETID_Clock DEFINE_GUIDNAMED(KSPROPSETID_Clock)

//
// Performs a x*y/z operation on 64 bit quantities by splitting the operation. The equation
// is simplified with respect to adding in the remainder for the upper 32 bits.
//
// (xh * 10000000 / Frequency) * 2^32 + ((((xh * 10000000) % Frequency) * 2^32 + (xl * 10000000)) / Frequency)
//
#define NANOSECONDS 10000000
#define KSCONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))

typedef struct {
    ULONG       CreateFlags;
} KSCLOCK_CREATE, *PKSCLOCK_CREATE;

typedef struct {
    LONGLONG    Time;
    LONGLONG    SystemTime;
} KSCORRELATED_TIME, *PKSCORRELATED_TIME;

typedef struct {
    LONGLONG    Granularity;
    LONGLONG    Error;
} KSRESOLUTION, *PKSRESOLUTION;

typedef enum {
    KSPROPERTY_CLOCK_TIME,
    KSPROPERTY_CLOCK_PHYSICALTIME,
    KSPROPERTY_CLOCK_CORRELATEDTIME,
    KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
    KSPROPERTY_CLOCK_RESOLUTION,
    KSPROPERTY_CLOCK_STATE,
#if defined(_NTDDK_)
    KSPROPERTY_CLOCK_FUNCTIONTABLE
#endif // defined(_NTDDK_)
} KSPROPERTY_CLOCK;

#if defined(_NTDDK_)

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_GETTIME)(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_CORRELATEDTIME)(
    __in PFILE_OBJECT FileObject,
    __out PLONGLONG SystemTime);

typedef struct {
    PFNKSCLOCK_GETTIME GetTime;
    PFNKSCLOCK_GETTIME GetPhysicalTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
} KSCLOCK_FUNCTIONTABLE, *PKSCLOCK_FUNCTIONTABLE;

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSSETTIMER)(
    __in PVOID Context,
    __in PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in PKDPC Dpc
    );

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSCANCELTIMER)(
    __in PVOID Context,
    __in PKTIMER Timer
    );

typedef
LONGLONG
(FASTCALL *PFNKSCORRELATEDTIME)(
    __in PVOID Context,
    __out  PLONGLONG SystemTime);

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID   PKSDEFAULTCLOCK;

#define DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_TIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_PHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_RESOLUTION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRESOLUTION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_STATE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCLOCK_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_CLOCKSET(ClockSet,\
    PropTime, PropPhysicalTime,\
    PropCorrelatedTime, PropCorrelatedPhysicalTime,\
    PropResolution, PropState, PropFunctionTable)\
DEFINE_KSPROPERTY_TABLE(ClockSet) {\
    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(PropTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(PropState),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable)\
}

#endif // defined(_NTDDK_)

#define STATIC_KSEVENTSETID_Clock \
    0x364D8E20L, 0x62C7, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000", KSEVENTSETID_Clock);
#define KSEVENTSETID_Clock DEFINE_GUIDNAMED(KSEVENTSETID_Clock)

typedef enum {
    KSEVENT_CLOCK_INTERVAL_MARK,
    KSEVENT_CLOCK_POSITION_MARK
} KSEVENT_CLOCK_POSITION;

#define STATIC_KSEVENTSETID_Connection\
    0x7f4bcbe0L, 0x9ea5, 0x11cf, 0xa5, 0xd6, 0x28, 0xdb, 0x04, 0xc1, 0x00, 0x00
DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000", KSEVENTSETID_Connection);
#define KSEVENTSETID_Connection DEFINE_GUIDNAMED(KSEVENTSETID_Connection)

typedef enum {
    KSEVENT_CONNECTION_POSITIONUPDATE,
    KSEVENT_CONNECTION_DATADISCONTINUITY,
    KSEVENT_CONNECTION_TIMEDISCONTINUITY,
    KSEVENT_CONNECTION_PRIORITY,
    KSEVENT_CONNECTION_ENDOFSTREAM
} KSEVENT_CONNECTION;

typedef struct {
    PVOID       Context;
    ULONG       Proportion;
    LONGLONG    DeltaTime;
} KSQUALITY, *PKSQUALITY;

typedef struct {
    PVOID       Context;
    ULONG       Status;
} KSERROR, *PKSERROR;

typedef KSIDENTIFIER KSDEGRADE, *PKSDEGRADE;

#define STATIC_KSDEGRADESETID_Standard\
    0x9F564180L, 0x704C, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("9F564180-704C-11D0-A5D6-28DB04C10000", KSDEGRADESETID_Standard);
#define KSDEGRADESETID_Standard DEFINE_GUIDNAMED(KSDEGRADESETID_Standard)

typedef enum {
    KSDEGRADE_STANDARD_SAMPLE,
    KSDEGRADE_STANDARD_QUALITY,
    KSDEGRADE_STANDARD_COMPUTATION,
    KSDEGRADE_STANDARD_SKIP
} KSDEGRADE_STANDARD;

#if defined(_NTDDK_)

#define KSPROBE_STREAMREAD      0x00000000
#define KSPROBE_STREAMWRITE     0x00000001
#define KSPROBE_ALLOCATEMDL     0x00000010
#define KSPROBE_PROBEANDLOCK    0x00000020
#define KSPROBE_SYSTEMADDRESS   0x00000040
#define KSPROBE_MODIFY          0x00000200
#define KSPROBE_STREAMWRITEMODIFY (KSPROBE_MODIFY | KSPROBE_STREAMWRITE)
#define KSPROBE_ALLOWFORMATCHANGE   0x00000080

#define KSSTREAM_READ           KSPROBE_STREAMREAD
#define KSSTREAM_WRITE          KSPROBE_STREAMWRITE
#define KSSTREAM_PAGED_DATA     0x00000000
#define KSSTREAM_NONPAGED_DATA  0x00000100
#define KSSTREAM_SYNCHRONOUS    0x00001000
#define KSSTREAM_FAILUREEXCEPTION 0x00002000

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSCONTEXT_DISPATCH)(
    __in PVOID Context,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSHANDLER)(
    __in PIRP Irp,
    __in PKSIDENTIFIER Request,
    __inout PVOID Data
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
BOOLEAN
(*PFNKSFASTHANDLER)(
    __in PFILE_OBJECT FileObject,
    __in_bcount(RequestLength) PKSIDENTIFIER Request,
    __in ULONG RequestLength,
    __inout_bcount(DataLength) PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSALLOCATOR)(
    __in PIRP Irp,
    __in ULONG BufferSize,
    __in BOOLEAN InputOperation
    );

typedef struct {
    KSPROPERTY_MEMBERSHEADER    MembersHeader;
    const VOID*                 Members;
} KSPROPERTY_MEMBERSLIST, *PKSPROPERTY_MEMBERSLIST;

typedef struct {
    KSIDENTIFIER                    PropTypeSet;
    ULONG                           MembersListCount;
    __field_ecount(MembersListCount)
    const KSPROPERTY_MEMBERSLIST*   MembersList;
} KSPROPERTY_VALUES, *PKSPROPERTY_VALUES;

#define DEFINE_KSPROPERTY_TABLE(tablename)\
    const KSPROPERTY_ITEM tablename[] =

#define DEFINE_KSPROPERTY_ITEM(PropertyId, GetHandler,\
                               MinProperty,\
                               MinData,\
                               SetHandler,\
                               Values, RelationsCount, Relations, SupportHandler,\
                               SerializedSize)\
{\
    PropertyId, (PFNKSHANDLER)GetHandler, MinProperty, MinData,\
    (PFNKSHANDLER)SetHandler,\
    (PKSPROPERTY_VALUES)Values, RelationsCount, (PKSPROPERTY)Relations,\
    (PFNKSHANDLER)SupportHandler, (ULONG)SerializedSize\
}

typedef struct {
    ULONG                   PropertyId;
    union {
        PFNKSHANDLER            GetPropertyHandler;
        BOOLEAN                 GetSupported;
    };
    ULONG                   MinProperty;
    ULONG                   MinData;
    union {
        PFNKSHANDLER            SetPropertyHandler;
        BOOLEAN                 SetSupported;
    };
    const KSPROPERTY_VALUES*Values;
    ULONG                   RelationsCount;
    __field_ecount(RelationsCount)
    const KSPROPERTY*       Relations;
    PFNKSHANDLER            SupportHandler;
    ULONG                   SerializedSize;
} KSPROPERTY_ITEM, *PKSPROPERTY_ITEM;

#define DEFINE_KSFASTPROPERTY_ITEM(PropertyId, GetHandler, SetHandler)\
{\
    PropertyId, (PFNKSFASTHANDLER)GetHandler, (PFNKSFASTHANDLER)SetHandler, 0\
}

typedef struct {
    ULONG                       PropertyId;
    union {
        PFNKSFASTHANDLER            GetPropertyHandler;
        BOOLEAN                     GetSupported;
    };
    union {
        PFNKSFASTHANDLER            SetPropertyHandler;
        BOOLEAN                     SetSupported;
    };
    ULONG                       Reserved;
} KSFASTPROPERTY_ITEM, *PKSFASTPROPERTY_ITEM;

#define DEFINE_KSPROPERTY_SET(Set,\
                              PropertiesCount,\
                              PropertyItem,\
                              FastIoCount,\
                              FastIoTable)\
{\
    Set,\
    PropertiesCount,\
    PropertyItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSPROPERTY_SET_TABLE(tablename)\
    const KSPROPERTY_SET tablename[] =

typedef struct {
    const GUID*                 Set;
    ULONG                       PropertiesCount;
    __field_ecount(PropertiesCount)
    const KSPROPERTY_ITEM*      PropertyItem;
    ULONG                       FastIoCount;
    const KSFASTPROPERTY_ITEM*  FastIoTable;
} KSPROPERTY_SET, *PKSPROPERTY_SET;

#define DEFINE_KSMETHOD_TABLE(tablename)\
    const KSMETHOD_ITEM tablename[] =

#define DEFINE_KSMETHOD_ITEM(MethodId, Flags,\
                             MethodHandler,\
                             MinMethod, MinData, SupportHandler)\
{\
    MethodId, (PFNKSHANDLER)MethodHandler, MinMethod, MinData,\
    SupportHandler, Flags\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSHANDLER            MethodHandler;
        BOOLEAN                 MethodSupported;
    };
    ULONG                   MinMethod;
    ULONG                   MinData;
    PFNKSHANDLER            SupportHandler;
    ULONG                   Flags;
} KSMETHOD_ITEM, *PKSMETHOD_ITEM;

#define DEFINE_KSFASTMETHOD_ITEM(MethodId, MethodHandler)\
{\
    MethodId, (PFNKSFASTHANDLER)MethodHandler\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSFASTHANDLER        MethodHandler;
        BOOLEAN                 MethodSupported;
    };
} KSFASTMETHOD_ITEM, *PKSFASTMETHOD_ITEM;

#define DEFINE_KSMETHOD_SET(Set,\
                            MethodsCount,\
                            MethodItem,\
                            FastIoCount,\
                            FastIoTable)\
{\
    Set,\
    MethodsCount,\
    MethodItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSMETHOD_SET_TABLE(tablename)\
    const KSMETHOD_SET tablename[] =

typedef struct {
    const GUID*             Set;
    ULONG                   MethodsCount;
    __field_ecount(MethodsCount)
    const KSMETHOD_ITEM*    MethodItem;
    ULONG                   FastIoCount;
    __field_ecount(FastIoCount) const KSFASTMETHOD_ITEM*FastIoTable;
} KSMETHOD_SET, *PKSMETHOD_SET;

typedef struct _KSEVENT_ENTRY
KSEVENT_ENTRY, *PKSEVENT_ENTRY;

typedef
NTSTATUS
(*PFNKSADDEVENT)(
    __in PIRP Irp,
    __in PKSEVENTDATA EventData,
    __in struct _KSEVENT_ENTRY* EventEntry
    );

typedef
VOID
(*PFNKSREMOVEEVENT)(
    __in PFILE_OBJECT FileObject,
    __in struct _KSEVENT_ENTRY* EventEntry
    );
    
#define DEFINE_KSEVENT_TABLE(tablename)\
    const KSEVENT_ITEM tablename[] =

#define DEFINE_KSEVENT_ITEM(EventId, DataInput, ExtraEntryData,\
                            AddHandler, RemoveHandler, SupportHandler)\
{\
    EventId,\
    DataInput,\
    ExtraEntryData,\
    AddHandler,\
    RemoveHandler,\
    SupportHandler\
}

typedef struct {
    ULONG               EventId;
    ULONG               DataInput;
    ULONG               ExtraEntryData;
    PFNKSADDEVENT       AddHandler;
    PFNKSREMOVEEVENT    RemoveHandler;
    PFNKSHANDLER        SupportHandler;
} KSEVENT_ITEM, *PKSEVENT_ITEM;

#define DEFINE_KSEVENT_SET(Set,\
                           EventsCount,\
                           EventItem)\
{\
    Set, EventsCount, EventItem\
}

#define DEFINE_KSEVENT_SET_TABLE(tablename)\
    const KSEVENT_SET tablename[] =

typedef struct {
    const GUID*         Set;
    ULONG               EventsCount;
    __field_ecount(EventsCount) const KSEVENT_ITEM* EventItem;
} KSEVENT_SET, *PKSEVENT_SET;

typedef struct {
    KDPC            Dpc;
    ULONG           ReferenceCount;
    KSPIN_LOCK      AccessLock;
} KSDPC_ITEM, *PKSDPC_ITEM;

typedef struct {
    KSDPC_ITEM          DpcItem;
    LIST_ENTRY          BufferList;
} KSBUFFER_ITEM, *PKSBUFFER_ITEM;

#define KSEVENT_ENTRY_DELETED   1
#define KSEVENT_ENTRY_ONESHOT   2
#define KSEVENT_ENTRY_BUFFERED  4

struct _KSEVENT_ENTRY {
    LIST_ENTRY      ListEntry;
    PVOID           Object;
    union {
        PKSDPC_ITEM         DpcItem;
        PKSBUFFER_ITEM      BufferItem;
    };
    PKSEVENTDATA        EventData;
    ULONG               NotificationType;
    const KSEVENT_SET*  EventSet;
    const KSEVENT_ITEM* EventItem;
    PFILE_OBJECT        FileObject;
    ULONG               SemaphoreAdjustment;
    ULONG               Reserved;
    ULONG               Flags;
};

typedef enum {
    KSEVENTS_NONE,
    KSEVENTS_SPINLOCK,
    KSEVENTS_MUTEX,
    KSEVENTS_FMUTEX,
    KSEVENTS_FMUTEXUNSAFE,
    KSEVENTS_INTERRUPT,
    KSEVENTS_ERESOURCE
} KSEVENTS_LOCKTYPE;

#define KSDISPATCH_FASTIO       0x80000000

typedef struct {
    PDRIVER_DISPATCH        Create;
    PVOID                   Context;
    UNICODE_STRING          ObjectClass;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    ULONG                   Flags;
} KSOBJECT_CREATE_ITEM, *PKSOBJECT_CREATE_ITEM;

typedef
VOID
(*PFNKSITEMFREECALLBACK)(
    __in PKSOBJECT_CREATE_ITEM CreateItem
    );

#define KSCREATE_ITEM_SECURITYCHANGED       0x00000001
#define KSCREATE_ITEM_WILDCARD              0x00000002
#define KSCREATE_ITEM_NOPARAMETERS          0x00000004
#define KSCREATE_ITEM_FREEONSTOP            0x00000008

#define DEFINE_KSCREATE_DISPATCH_TABLE( tablename )\
    KSOBJECT_CREATE_ITEM tablename[] =

#define DEFINE_KSCREATE_ITEM(DispatchCreate, TypeName, Context)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, 0\
}

#define DEFINE_KSCREATE_ITEMEX(DispatchCreate, TypeName, Context, Flags)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, (Flags)\
}

#define DEFINE_KSCREATE_ITEMNULL( DispatchCreate, Context )\
{\
    DispatchCreate,\
    Context,\
    {\
        0,\
        0,\
        NULL,\
    },\
    NULL, 0\
}

typedef struct {
    ULONG                    CreateItemsCount;
    __field_ecount(CreateItemsCount) PKSOBJECT_CREATE_ITEM    CreateItemsList;
} KSOBJECT_CREATE, *PKSOBJECT_CREATE;

typedef struct {
    PDRIVER_DISPATCH        DeviceIoControl;
    PDRIVER_DISPATCH        Read;
    PDRIVER_DISPATCH        Write;
    PDRIVER_DISPATCH        Flush;
    PDRIVER_DISPATCH        Close;
    PDRIVER_DISPATCH        QuerySecurity;
    PDRIVER_DISPATCH        SetSecurity;
    PFAST_IO_DEVICE_CONTROL FastDeviceIoControl;
    PFAST_IO_READ           FastRead;
    PFAST_IO_WRITE          FastWrite;
} KSDISPATCH_TABLE, *PKSDISPATCH_TABLE;

#define DEFINE_KSDISPATCH_TABLE( tablename, DeviceIoControl, Read, Write,\
                                 Flush, Close, QuerySecurity, SetSecurity,\
                                 FastDeviceIoControl, FastRead, FastWrite  )\
    const KSDISPATCH_TABLE tablename = \
    {\
        DeviceIoControl,        \
        Read,                   \
        Write,                  \
        Flush,                  \
        Close,                  \
        QuerySecurity,          \
        SetSecurity,            \
        FastDeviceIoControl,    \
        FastRead,               \
        FastWrite,              \
    }

#define KSCREATE_ITEM_IRP_STORAGE(Irp)      (*(PKSOBJECT_CREATE_ITEM*)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_SET_IRP_STORAGE(Irp)        (*(const KSEVENT_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_ITEM_IRP_STORAGE(Irp)       (*(const KSEVENT_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSEVENT_ENTRY_IRP_STORAGE(Irp)      (*(PKSEVENT_ENTRY*)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_SET_IRP_STORAGE(Irp)       (*(const KSMETHOD_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_ITEM_IRP_STORAGE(Irp)      (*(const KSMETHOD_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSMETHOD_TYPE_IRP_STORAGE(Irp)      (*(ULONG_PTR*)(&(Irp)->Tail.Overlay.DriverContext[2]))
#define KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)   (*(PKSPIN_LOCK*)&(Irp)->Tail.Overlay.DriverContext[1])
#define KSPROPERTY_SET_IRP_STORAGE(Irp)     (*(const KSPROPERTY_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSPROPERTY_ITEM_IRP_STORAGE(Irp)    (*(const KSPROPERTY_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp) (*(PKSATTRIBUTE_LIST*)&(Irp)->Tail.Overlay.DriverContext[2])

typedef PVOID   KSDEVICE_HEADER, KSOBJECT_HEADER;

typedef enum {
    KsInvokeOnSuccess = 1,
    KsInvokeOnError = 2,
    KsInvokeOnCancel = 4
} KSCOMPLETION_INVOCATION;

typedef enum {
    KsListEntryTail,
    KsListEntryHead
} KSLIST_ENTRY_LOCATION;

typedef enum {
    KsAcquireOnly,
    KsAcquireAndRemove,
    KsAcquireOnlySingleItem,
    KsAcquireAndRemoveOnlySingleItem
} KSIRP_REMOVAL_OPERATION;

typedef enum {
    KsStackCopyToNewLocation,
    KsStackReuseCurrentLocation,
    KsStackUseNewLocation
} KSSTACK_USE;

typedef enum {
    KSTARGET_STATE_DISABLED,
    KSTARGET_STATE_ENABLED
} KSTARGET_STATE;

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
NTSTATUS
(*PFNKSIRPLISTCALLBACK)(
    __in PIRP Irp,
    __in PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef 
VOID 
(*PFNREFERENCEDEVICEOBJECT)( 
    __in PVOID Context
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
typedef 
VOID 
(*PFNDEREFERENCEDEVICEOBJECT)( 
    __in PVOID Context
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNQUERYREFERENCESTRING)( 
    __in PVOID Context,
    __inout PWCHAR *String
    );

#define BUS_INTERFACE_REFERENCE_VERSION    0x100
    
typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Standard bus interfaces
    //
    
    PFNREFERENCEDEVICEOBJECT    ReferenceDeviceObject;
    PFNDEREFERENCEDEVICEOBJECT  DereferenceDeviceObject;
    PFNQUERYREFERENCESTRING     QueryReferenceString;
    
} BUS_INTERFACE_REFERENCE, *PBUS_INTERFACE_REFERENCE;

#define STATIC_REFERENCE_BUS_INTERFACE STATIC_KSMEDIUMSETID_Standard
#define REFERENCE_BUS_INTERFACE KSMEDIUMSETID_Standard

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNQUERYMEDIUMSLIST)( 
    __in PVOID Context,
    __out ULONG* MediumsCount,
    __out_ecount(MediumsCount) PKSPIN_MEDIUM* MediumList
    );

typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Interface definition
    //
    
    PFNQUERYMEDIUMSLIST         QueryMediumsList;
    
} BUS_INTERFACE_MEDIUMS, *PBUS_INTERFACE_MEDIUMS;

#define STATIC_GUID_BUS_INTERFACE_MEDIUMS \
    0x4EC35C3EL, 0x201B, 0x11D2, 0x87, 0x45, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4EC35C3E-201B-11D2-8745-00A0C9223196", GUID_BUS_INTERFACE_MEDIUMS);
#define GUID_BUS_INTERFACE_MEDIUMS DEFINE_GUIDNAMED(GUID_BUS_INTERFACE_MEDIUMS)

#endif // defined(_NTDDK_)

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif

typedef struct {
    GUID            PropertySet;
    ULONG           Count;
} KSPROPERTY_SERIALHDR, *PKSPROPERTY_SERIALHDR;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

typedef struct {
    KSIDENTIFIER    PropTypeSet;
    ULONG           Id;
    ULONG           PropertyLength;
} KSPROPERTY_SERIAL, *PKSPROPERTY_SERIAL;

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)

#define IOCTL_KS_HANDSHAKE             CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct {
    GUID ProtocolId;
    PVOID Argument1;
    PVOID Argument2;
} KSHANDSHAKE, *PKSHANDSHAKE;

typedef struct _KSGATE
KSGATE, *PKSGATE;

struct _KSGATE {
    LONG Count;
    PKSGATE NextGate;
};

#ifndef _NTOS_

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTurnInputOn(
    __in_opt PKSGATE Gate
    )
{
    while (Gate && (InterlockedIncrement(&Gate->Count) == 1)) {
        Gate = Gate->NextGate;
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTurnInputOff(
    __in_opt PKSGATE Gate
    )
{
    while (Gate && (InterlockedDecrement(&Gate->Count) == 0)) {
        Gate = Gate->NextGate;
    }
}

__drv_maxIRQL(HIGH_LEVEL)
BOOLEAN __inline
KsGateGetStateUnsafe(
    __in PKSGATE Gate
    )
{
    ASSERT(Gate);
    return((BOOLEAN)(Gate->Count > 0));
}

__drv_maxIRQL(HIGH_LEVEL)
BOOLEAN __inline
KsGateCaptureThreshold(
    __in PKSGATE Gate
    )
{
    BOOLEAN captured;

    ASSERT(Gate);

    captured = (BOOLEAN)(InterlockedCompareExchange(&Gate->Count,0,1) == 1);
    
    //
    // If we made a transition, it must be propagated.
    //
    if (captured) {
        KsGateTurnInputOff(Gate->NextGate);
    }

    //
    // We return whatever the state was prior to the compare/exchange.  If
    // the state was on, the state is now off.
    //
    return captured;
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitialize(
    __in PKSGATE Gate,
    __in LONG InitialCount,
    __in_opt PKSGATE NextGate,
    __in BOOLEAN StateToPropagate // __in BOOLEAN NextGateIsAnOrGate
    )
{
    ASSERT(Gate);
    Gate->Count = InitialCount;
    Gate->NextGate = NextGate;

    if (NextGate) {
        if (InitialCount > 0) {
            if (StateToPropagate) {
                KsGateTurnInputOn(NextGate);
            }
        } else {
            if (! StateToPropagate) {
                KsGateTurnInputOff(NextGate);
            }
        }
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitializeAnd(
    __in PKSGATE AndGate,
    __in_opt PKSGATE NextOrGate
    )
{
    KsGateInitialize(AndGate,1,NextOrGate,TRUE);
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitializeOr(
    __in PKSGATE OrGate,
    __in_opt PKSGATE NextAndGate
    )
{
    KsGateInitialize(OrGate,0,NextAndGate,FALSE);
}

__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOnInputToAnd(__in PKSGATE AndGate) { UNREFERENCED_PARAMETER (AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOffInputToAnd(__in PKSGATE AndGate) { KsGateTurnInputOff(AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOnInputFromAnd(__in PKSGATE AndGate) { UNREFERENCED_PARAMETER (AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOffInputFromAnd(__in PKSGATE AndGate) { KsGateTurnInputOn(AndGate); }

__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOnInputToOr(__in PKSGATE OrGate) { KsGateTurnInputOn(OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOffInputToOr(__in PKSGATE OrGate) { UNREFERENCED_PARAMETER (OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOnInputFromOr(__in PKSGATE OrGate) { KsGateTurnInputOff(OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOffInputFromOr(__in PKSGATE OrGate) { UNREFERENCED_PARAMETER (OrGate); }

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTerminateAnd(
    __in PKSGATE AndGate
    )
{
    ASSERT(AndGate);
    if (KsGateGetStateUnsafe(AndGate)) {
        KsGateRemoveOnInputFromOr(AndGate->NextGate);
    } else {
        KsGateRemoveOffInputFromOr(AndGate->NextGate);
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTerminateOr(
    __in PKSGATE OrGate
    )
{
    ASSERT(OrGate);
    if (KsGateGetStateUnsafe(OrGate)) {
        KsGateRemoveOnInputFromAnd(OrGate->NextGate);
    } else {
        KsGateRemoveOffInputFromAnd(OrGate->NextGate);
    }
}

#endif // !_NTOS_

typedef PVOID KSOBJECT_BAG;

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSGENERATEEVENTCALLBACK)(
    __in PVOID Context,
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICECREATE)(
    __in PKSDEVICE Device
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEPNPSTART)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in_opt PCM_RESOURCE_LIST TranslatedResourceList,
    __in_opt PCM_RESOURCE_LIST UntranslatedResourceList
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICE)(
    __in PKSDEVICE Device
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEIRP)(
    __in PKSDEVICE Device,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSDEVICEIRPVOID)(
    __in PKSDEVICE Device,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEQUERYCAPABILITIES)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __inout PDEVICE_CAPABILITIES Capabilities
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEQUERYPOWER)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in DEVICE_POWER_STATE DeviceTo,
    __in DEVICE_POWER_STATE DeviceFrom,
    __in SYSTEM_POWER_STATE SystemTo,
    __in SYSTEM_POWER_STATE SystemFrom,
    __in POWER_ACTION Action
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSDEVICESETPOWER)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in DEVICE_POWER_STATE To,
    __in DEVICE_POWER_STATE From
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERFACTORYVOID)(
    __in PKSFILTERFACTORY FilterFactory
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSFILTERFACTORYPOWER)(
    __in PKSFILTERFACTORY FilterFactory,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERIRP)(
    __in PKSFILTER Filter,
    __in PIRP Irp
    );
typedef
NTSTATUS
(*PFNKSFILTERPROCESS)(
    __in PKSFILTER Filter,
    __in PKSPROCESSPIN_INDEXENTRY Index
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERVOID)(
    __in PKSFILTER Filter
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSFILTERPOWER)(
    __in PKSFILTER Filter,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINIRP)(
    __in PKSPIN Pin,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINSETDEVICESTATE)(
    __in PKSPIN Pin,
    __in KSSTATE ToState,
    __in KSSTATE FromState
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINSETDATAFORMAT)(
    __in PKSPIN Pin,
    __in_opt PKSDATAFORMAT OldFormat,
    __in_opt PKSMULTIPLE_ITEM OldAttributeList,
    __in const KSDATARANGE* DataRange,
    __in_opt const KSATTRIBUTE_LIST* AttributeRange
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINHANDSHAKE)(
    __in PKSPIN Pin,
    __in PKSHANDSHAKE In,
    __in PKSHANDSHAKE Out
    );
typedef
NTSTATUS
(*PFNKSPIN)(
    __in PKSPIN Pin
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSPINVOID)(
    __in PKSPIN Pin
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSPINPOWER)(
    __in PKSPIN Pin,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSPINSETTIMER)(
    __in PKSPIN Pin,
    __in PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in PKDPC Dpc
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSPINCANCELTIMER)(
    __in PKSPIN Pin,
    __in PKTIMER Timer
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSPINCORRELATEDTIME)(
    __in PKSPIN Pin,
    __out PLONGLONG SystemTime
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSPINRESOLUTION)(
    __in PKSPIN Pin,
    __out PKSRESOLUTION Resolution
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPININITIALIZEALLOCATOR)(
    __in PKSPIN Pin,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PVOID* Context
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSSTREAMPOINTER)(
    __in PKSSTREAM_POINTER StreamPointer
    );

typedef struct KSAUTOMATION_TABLE_ 
KSAUTOMATION_TABLE, *PKSAUTOMATION_TABLE;
struct KSAUTOMATION_TABLE_ {
    ULONG PropertySetsCount;
    ULONG PropertyItemSize;
    __field_bcount(PropertySetsCount * PropertyItemSize) const KSPROPERTY_SET* PropertySets;
    ULONG MethodSetsCount;
    ULONG MethodItemSize;
    __field_bcount(MethodSetsCount * MethodItemSize) const KSMETHOD_SET* MethodSets;
    ULONG EventSetsCount;
    ULONG EventItemSize;
    __field_bcount(EventSetsCount * EventItemSize) const KSEVENT_SET* EventSets;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#define DEFINE_KSAUTOMATION_TABLE(table)\
    const KSAUTOMATION_TABLE table =

#define DEFINE_KSAUTOMATION_PROPERTIES(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSPROPERTY_ITEM),\
    table

#define DEFINE_KSAUTOMATION_METHODS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSMETHOD_ITEM),\
    table

#define DEFINE_KSAUTOMATION_EVENTS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSEVENT_ITEM),\
    table

#define DEFINE_KSAUTOMATION_PROPERTIES_NULL\
    0,\
    sizeof(KSPROPERTY_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_METHODS_NULL\
    0,\
    sizeof(KSMETHOD_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_EVENTS_NULL\
    0,\
    sizeof(KSEVENT_ITEM),\
    NULL

#define MIN_DEV_VER_FOR_QI (0x100)

struct _KSDEVICE_DISPATCH {
    PFNKSDEVICECREATE Add;
    PFNKSDEVICEPNPSTART Start;
    PFNKSDEVICE PostStart;
    PFNKSDEVICEIRP QueryStop;
    PFNKSDEVICEIRPVOID CancelStop;
    PFNKSDEVICEIRPVOID Stop;
    PFNKSDEVICEIRP QueryRemove;
    PFNKSDEVICEIRPVOID CancelRemove;
    PFNKSDEVICEIRPVOID Remove;
    PFNKSDEVICEQUERYCAPABILITIES QueryCapabilities;
    PFNKSDEVICEIRPVOID SurpriseRemoval;
    PFNKSDEVICEQUERYPOWER QueryPower;
    PFNKSDEVICESETPOWER SetPower;
    PFNKSDEVICEIRP QueryInterface;  // added in version 0x100
};

struct _KSFILTER_DISPATCH {
    PFNKSFILTERIRP Create;
    PFNKSFILTERIRP Close;
    PFNKSFILTERPROCESS Process;
    PFNKSFILTERVOID Reset;
};

struct _KSPIN_DISPATCH {
    PFNKSPINIRP Create;
    PFNKSPINIRP Close;
    PFNKSPIN Process;
    PFNKSPINVOID Reset;
    PFNKSPINSETDATAFORMAT SetDataFormat;
    PFNKSPINSETDEVICESTATE SetDeviceState;
    PFNKSPIN Connect;
    PFNKSPINVOID Disconnect;
    const KSCLOCK_DISPATCH* Clock;
    const KSALLOCATOR_DISPATCH* Allocator;
};

struct _KSCLOCK_DISPATCH {
    PFNKSPINSETTIMER SetTimer;
    PFNKSPINCANCELTIMER CancelTimer;
    PFNKSPINCORRELATEDTIME CorrelatedTime;
    PFNKSPINRESOLUTION Resolution;
};

struct _KSALLOCATOR_DISPATCH {
    PFNKSPININITIALIZEALLOCATOR InitializeAllocator;
    PFNKSDELETEALLOCATOR DeleteAllocator;
    PFNKSDEFAULTALLOCATE Allocate;
    PFNKSDEFAULTFREE Free;
};

//
// VERSION indicates support of the following:
//
//     - QueryInterface dispatch of KSDEVICE_DISPATCH
//
#define KSDEVICE_DESCRIPTOR_VERSION (0x100)

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// VERSION_2 indicates support of the following:
//
//     - Flags field of KSDEVICE_DESCRIPTOR
//           - Loading a VERSION_2 descriptor on earlier versions of AVStream
//             will work; however, all flags will be considered to be zero.
//           - Using an earlier version descriptor on later versions of
//             AVStream causes no flags to be specificed.
//
#define KSDEVICE_DESCRIPTOR_VERSION_2 (0x110)

#define MIN_DEV_VER_FOR_FLAGS (0x110)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

struct _KSDEVICE_DESCRIPTOR {
    const KSDEVICE_DISPATCH* Dispatch;
    ULONG FilterDescriptorsCount;
    __field_ecount(FilterDescriptorsCount) const KSFILTER_DESCRIPTOR*const* FilterDescriptors;
    ULONG Version; // this is 0 for pre-version 100 driver

#if (NTDDI_VERSION >= NTDDI_VISTA)

    ULONG Flags; 
#define KSDEVICE_FLAG_ENABLE_REMOTE_WAKEUP	0x00000001
#define KSDEVICE_FLAG_LOWPOWER_PASSTHROUGH 	0x00000002

#if !defined(_WIN64)
    PVOID Alignment;
#endif //!defined(_WIN64)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

};

struct _KSFILTER_DESCRIPTOR {
    const KSFILTER_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    ULONG Version;
#define KSFILTER_DESCRIPTOR_VERSION ((ULONG)-1)
    ULONG Flags;
#define KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING 0x00000001
#define KSFILTER_FLAG_CRITICAL_PROCESSING 0x00000002
#define KSFILTER_FLAG_HYPERCRITICAL_PROCESSING 0x00000004
#define KSFILTER_FLAG_RECEIVE_ZERO_LENGTH_SAMPLES 0x00000008
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define KSFILTER_FLAG_DENY_USERMODE_ACCESS 0x80000000
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)
    const GUID* ReferenceGuid;
    ULONG PinDescriptorsCount;
    ULONG PinDescriptorSize;
    __field_bcount(PinDescriptorsCount * PinDescriptorSize) const KSPIN_DESCRIPTOR_EX* PinDescriptors;
    ULONG CategoriesCount;
    __field_ecount(CategoriesCount)
    const GUID* Categories;
    ULONG NodeDescriptorsCount;
    ULONG NodeDescriptorSize;
    __field_bcount(NodeDescriptorsCount * NodeDescriptorSize) const KSNODE_DESCRIPTOR* NodeDescriptors;
    ULONG ConnectionsCount;
    __field_ecount(ConnectionsCount) const KSTOPOLOGY_CONNECTION* Connections;
    const KSCOMPONENTID* ComponentId;
};

#define DEFINE_KSFILTER_DESCRIPTOR(descriptor)\
    const KSFILTER_DESCRIPTOR descriptor =

#define DEFINE_KSFILTER_PIN_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_CATEGORIES(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_CATEGORY(category)\
    1,\
    &(category)

#define DEFINE_KSFILTER_CATEGORIES_NULL\
    0,\
    NULL

#define DEFINE_KSFILTER_NODE_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL\
    0,\
    sizeof(KSNODE_DESCRIPTOR),\
    NULL

#define DEFINE_KSFILTER_CONNECTIONS(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_DEFAULT_CONNECTIONS\
    0,\
    NULL

#define DEFINE_KSFILTER_DESCRIPTOR_TABLE(table)\
    const KSFILTER_DESCRIPTOR*const table[] =

struct _KSPIN_DESCRIPTOR_EX {
    const KSPIN_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    KSPIN_DESCRIPTOR PinDescriptor;
    ULONG Flags;
#define KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING
#define KSPIN_FLAG_CRITICAL_PROCESSING KSFILTER_FLAG_CRITICAL_PROCESSING
#define KSPIN_FLAG_HYPERCRITICAL_PROCESSING KSFILTER_FLAG_HYPERCRITICAL_PROCESSING
#define KSPIN_FLAG_ASYNCHRONOUS_PROCESSING 0x00000008
#define KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING 0x00000010
#define KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL 0x00000020
#define KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING 0x00000040
#define KSPIN_FLAG_ENFORCE_FIFO 0x00000080

#define KSPIN_FLAG_GENERATE_MAPPINGS 0x00000100
#define KSPIN_FLAG_DISTINCT_TRAILING_EDGE 0x00000200

#define KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY 0x00010000
#define KSPIN_FLAG_SPLITTER 0x00020000
#define KSPIN_FLAG_USE_STANDARD_TRANSPORT 0x00040000
#define KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT 0x00080000
#define KSPIN_FLAG_FIXED_FORMAT 0x00100000
#define KSPIN_FLAG_GENERATE_EOS_EVENTS 0x00200000
#define KSPIN_FLAG_RENDERER (KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY|KSPIN_FLAG_GENERATE_EOS_EVENTS)
#define KSPIN_FLAG_IMPLEMENT_CLOCK 0x00400000
#define KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING 0x00800000
#define KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE 0x01000000
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define KSPIN_FLAG_DENY_USERMODE_ACCESS 0x80000000
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)
    ULONG InstancesPossible;
    ULONG InstancesNecessary;
    const KSALLOCATOR_FRAMING_EX* AllocatorFraming;
    PFNKSINTERSECTHANDLEREX IntersectHandler;
};

#define DEFINE_KSPIN_DEFAULT_INTERFACES\
    0,\
    NULL

#define DEFINE_KSPIN_DEFAULT_MEDIUMS\
    0,\
    NULL

struct _KSNODE_DESCRIPTOR {
    const KSAUTOMATION_TABLE* AutomationTable;
    const GUID* Type;
    const GUID* Name;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#if !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name), NULL }
#else // !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name) }
#endif // !defined(_WIN64)

struct _KSDEVICE {
    const KSDEVICE_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT NextDeviceObject;
    BOOLEAN Started;
    SYSTEM_POWER_STATE SystemPowerState;
    DEVICE_POWER_STATE DevicePowerState;
};

struct _KSFILTERFACTORY {
    const KSFILTER_DESCRIPTOR* FilterDescriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSFILTER {
    const KSFILTER_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSPIN {
    const KSPIN_DESCRIPTOR_EX* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    ULONG Id;
    KSPIN_COMMUNICATION Communication;
    BOOLEAN ConnectionIsExternal;
    KSPIN_INTERFACE ConnectionInterface;
    KSPIN_MEDIUM ConnectionMedium;
    KSPRIORITY ConnectionPriority;
    PKSDATAFORMAT ConnectionFormat;
    PKSMULTIPLE_ITEM AttributeList;
    ULONG StreamHeaderSize;
    KSPIN_DATAFLOW DataFlow;
    KSSTATE DeviceState;
    KSRESET ResetState;
    KSSTATE ClientState;
};

struct _KSMAPPING {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG ByteCount;
    ULONG Alignment;
};

struct _KSSTREAM_POINTER_OFFSET
{
#if defined(_NTDDK_)
    union {
        PUCHAR Data;
        PKSMAPPING Mappings;
    };
#else // !defined(_NTDDK_)
    PUCHAR Data;
#endif // !defined(_NTDDK_)
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
    ULONG Count;
    ULONG Remaining;
};

struct _KSSTREAM_POINTER
{
    PVOID Context;
    PKSPIN Pin;
    PKSSTREAM_HEADER StreamHeader;
    PKSSTREAM_POINTER_OFFSET Offset;
    KSSTREAM_POINTER_OFFSET OffsetIn;
    KSSTREAM_POINTER_OFFSET OffsetOut;
};

struct _KSPROCESSPIN {
    PKSPIN Pin;
    PKSSTREAM_POINTER StreamPointer;
    PKSPROCESSPIN InPlaceCounterpart;
    PKSPROCESSPIN DelegateBranch;
    PKSPROCESSPIN CopySource;
    __field_bcount(BytesAvailable) PVOID Data;
    ULONG BytesAvailable;
    ULONG BytesUsed;
    ULONG Flags;
    BOOLEAN Terminate;
};

struct _KSPROCESSPIN_INDEXENTRY {
    __field_ecount(Count) PKSPROCESSPIN *Pins;
    ULONG Count;
};

typedef enum {
    KsObjectTypeDevice,
    KsObjectTypeFilterFactory,
    KsObjectTypeFilter,
    KsObjectTypePin
} KSOBJECTTYPE;

typedef
void
(*PFNKSFREE)(
    __in PVOID Data
    );

typedef
void
(*PFNKSPINFRAMERETURN)(
    __in PKSPIN Pin,
    __in_bcount_opt(Size) PVOID Data,
    __in ULONG Size OPTIONAL,
    __in_opt PMDL Mdl,
    __in_opt PVOID Context,
    __in NTSTATUS Status
    );

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSPINIRPCOMPLETION)(
    __in PKSPIN Pin,
    __in PIRP Irp
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
#if !defined(_IKsControl_)
#define _IKsControl_

typedef interface IKsControl* PIKSCONTROL;

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_                   \
        __in REFIID InterfaceId,                                     \
        __deref_out PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(NTSTATUS, KsProperty)(THIS_
        __in_bcount(PropertyLength) PKSPROPERTY Property,
        __in ULONG PropertyLength,
        __inout_bcount(DataLength) PVOID PropertyData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsMethod)(THIS_
        __in_bcount(MethodLength) PKSMETHOD Method,
        __in ULONG MethodLength,
        __inout_bcount(DataLength) PVOID MethodData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsEvent)(THIS_
        __in_bcount_opt(EventLength) PKSEVENT Event,
        __in ULONG EventLength,
        __inout_bcount(DataLength) PVOID EventData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
};

typedef interface IKsReferenceClock* PIKSREFERENCECLOCK;

#undef INTERFACE
#define INTERFACE IKsReferenceClock
DECLARE_INTERFACE_(IKsReferenceClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(LONGLONG,GetTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetPhysicalTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedTime)(THIS_
        __out PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedPhysicalTime)(THIS_
        __out PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(NTSTATUS, GetResolution)(THIS_
        __out PKSRESOLUTION Resolution
        ) PURE;
    STDMETHOD_(NTSTATUS, GetState)(THIS_
        __out PKSSTATE State
        ) PURE;
};
#undef INTERFACE

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

#define INTERFACE IKsDeviceFunctions
DECLARE_INTERFACE_(IKsDeviceFunctions, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C
    
    STDMETHOD_(NTSTATUS, RegisterAdapterObjectEx)(THIS_
        __in PADAPTER_OBJECT AdapterObject,
        __in PDEVICE_DESCRIPTION DeviceDescription,
        __in ULONG NumberOfMapRegisters,
        __in ULONG MaxMappingsByteCount,
        __in ULONG MappingTableStride
        ) PURE;
};

#undef INTERFACE

#endif // (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_IID_IKsControl \
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUID(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("28F54685-06FD-11D2-B27A-00A0C9223196")) IKsControl;
#endif

#define STATIC_IID_IKsFastClock \
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e
DEFINE_GUID(IID_IKsFastClock,
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("C9902485-C180-11d2-8473-D42394459E5E")) IKsFastClock;
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_IID_IKsDeviceFunctions \
0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd
DEFINE_GUID(IID_IKsDeviceFunctions,
0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("E234F2E2-BD69-4F8C-B3F2-7CD79ED466BD")) IKsDeviceFunctions;
#endif

#endif // (NTDDI_VERSION >= NTDDI_WS03SP1)

#endif // !defined(_IKsControl_)
#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

#endif // defined(_NTDDK_)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

//
// exported prototypes
//

#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#if defined(_NTDDK_)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsEnableEvent(
    __in PIRP Irp,
    __in ULONG EventSetsCount,
    __in_ecount(EventSetsCount) const KSEVENT_SET* EventSet,
    __inout_opt PLIST_ENTRY EventsList,
    __in_opt KSEVENTS_LOCKTYPE EventsFlags,
    __in_opt PVOID EventsLock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsEnableEventWithAllocator(
    __in PIRP Irp,
    __in ULONG EventSetsCount,
    __in_ecount(EventSetsCount) const KSEVENT_SET* EventSet,
    __inout_opt PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    __in_opt PVOID EventsLock,
    __in_opt PFNKSALLOCATOR Allocator,
    __in_opt ULONG EventItemSize
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDisableEvent(
    __in PIRP Irp,
    __inout PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsDiscardEvent(
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeEventList(
    __in PFILE_OBJECT FileObject,
    __inout PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateEvent(
    __in PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateDataEvent(
    __in PKSEVENT_ENTRY EventEntry,
    __in ULONG DataSize,
    __in_bcount(DataSize) PVOID Data
    );

KSDDKAPI
VOID
NTAPI
KsGenerateEventList(
    __in_opt GUID* Set,
    __in ULONG EventId,
    __in PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

// property.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandler(
    __in PIRP Irp,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandlerWithAllocator(
    __in PIRP Irp,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet,
    __in_opt PFNKSALLOCATOR Allocator,
    __in ULONG PropertyItemSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsFastPropertyHandler(
    __in PFILE_OBJECT FileObject,
    __in_bcount(PropertyLength) PKSPROPERTY Property,
    __in ULONG PropertyLength,
    __in_bcount(DataLength)PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet
    );

// method.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandler(
    __in PIRP Irp,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandlerWithAllocator(
    __in PIRP Irp,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet,
    __in_opt PFNKSALLOCATOR Allocator,
    __in ULONG MethodItemSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsFastMethodHandler(
    __in PFILE_OBJECT FileObject,
    __in_bcount(MethodLength) PKSMETHOD Method,
    __in ULONG MethodLength,
    __inout_bcount(DataLength) PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet
    );

// alloc.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocator(
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocatorEx(
    __in PIRP Irp,
    __in_opt PVOID InitializeContext,
    __in_opt PFNKSDEFAULTALLOCATE DefaultAllocate,
    __in_opt PFNKSDEFAULTFREE DefaultFree,
    __in_opt PFNKSINITIALIZEALLOCATOR InitializeAllocator,
    __in_opt PFNKSDELETEALLOCATOR DeleteAllocator
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateAllocator(
    __in HANDLE ConnectionHandle,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PHANDLE AllocatorHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorCreateRequest(
    __in PIRP Irp,
    __out PKSALLOCATOR_FRAMING* AllocatorFraming
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorFramingEx(
    __in PKSALLOCATOR_FRAMING_EX Framing,
    __in ULONG BufferSize,
    __in const KSALLOCATOR_FRAMING_EX *PinFraming
    );

// clock.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClock(
    __out PKSDEFAULTCLOCK* DefaultClock
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClockEx(
    __out PKSDEFAULTCLOCK* DefaultClock,
    __in_opt PVOID Context,
    __in_opt PFNKSSETTIMER SetTimer,
    __in_opt PFNKSCANCELTIMER CancelTimer,
    __in_opt PFNKSCORRELATEDTIME CorrelatedTime,
    __in_opt const KSRESOLUTION* Resolution,
    __in ULONG Flags
    );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeDefaultClock(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultClock(
    __in PIRP Irp,
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateClock(
    __in HANDLE ConnectionHandle,
    __in PKSCLOCK_CREATE ClockCreate,
    __out PHANDLE ClockHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateClockCreateRequest(
    __in PIRP Irp,
    __deref_out PKSCLOCK_CREATE* ClockCreate
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSSTATE
NTAPI
KsGetDefaultClockState(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDefaultClockState(
    __in PKSDEFAULTCLOCK DefaultClock,
    __in KSSTATE State
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
LONGLONG
NTAPI
KsGetDefaultClockTime(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDefaultClockTime(
    __in PKSDEFAULTCLOCK DefaultClock,
    __in LONGLONG Time
    );

// connect.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreatePin(
    __in HANDLE FilterHandle,
    __in PKSPIN_CONNECT Connect,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE ConnectionHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateConnectRequest(
    __in PIRP Irp,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor,
    __out PKSPIN_CONNECT* Connect
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinPropertyHandler(
    __in PIRP Irp,
    __in PKSPROPERTY Property,
    __inout PVOID Data,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersection(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __out_opt PVOID Data,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor,
    __in PFNKSINTERSECTHANDLER IntersectHandler
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersectionEx(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __out PVOID Data,
    __in ULONG DescriptorsCount,
    __in_bcount(DescriptorsCount * DescriptorSize) const KSPIN_DESCRIPTOR* Descriptor,
    __in ULONG DescriptorSize,
    __in_opt PFNKSINTERSECTHANDLEREX IntersectHandler,
    __in_opt PVOID HandlerContext
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsHandleSizedListQuery(
    __in PIRP Irp,
    __in ULONG DataItemsCount,
    __in ULONG DataItemSize,
    __in_bcount(DataItemsCount * DataItemSize) const VOID* DataItems
    );

// image.c:

#if (!defined( MAKEINTRESOURCE )) 
#define MAKEINTRESOURCE( res ) ((ULONG_PTR) (USHORT) res)
#endif

#if (!defined( RT_STRING ))
#define RT_STRING           MAKEINTRESOURCE( 6 )
#define RT_RCDATA           MAKEINTRESOURCE( 10 ) 
#endif

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsLoadResource(
    __in PVOID ImageBase,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR ResourceName,
    __in ULONG ResourceType,
    __deref_out_bcount(ResourceSize) PVOID *Resource,
    __out_opt PULONG ResourceSize            
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsGetImageNameAndResourceId(
    __in HANDLE RegKey,
    __out PUNICODE_STRING ImageName,                
    __out PULONG_PTR ResourceId,
    __out PULONG ValueType
);

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMapModuleName(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PUNICODE_STRING ModuleName,
    __out PUNICODE_STRING ImageName,                
    __out PULONG_PTR ResourceId,
    __out PULONG ValueType
    );
    
// irp.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsReferenceBusObject(
    __in KSDEVICE_HEADER  Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsDereferenceBusObject(
    __in KSDEVICE_HEADER  Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchQuerySecurity(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSetSecurity(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificProperty(
    __in PIRP Irp,
    __in PFNKSHANDLER Handler
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificMethod(
    __in PIRP Irp,
    __in PFNKSHANDLER Handler
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsReadFile(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in ULONG Key OPTIONAL,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsWriteFile(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in ULONG Key OPTIONAL,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsQueryInformationFile(
    __in PFILE_OBJECT FileObject,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSetInformationFile(
    __in PFILE_OBJECT FileObject,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamIo(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __in_opt PIO_COMPLETION_ROUTINE CompletionRoutine,
    __in_opt PVOID CompletionContext,
    __in KSCOMPLETION_INVOCATION CompletionInvocationFlags OPTIONAL,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __inout_bcount(Length) PVOID StreamHeaders,
    __in ULONG Length,
    __in ULONG Flags,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsProbeStreamIrp(
    __inout PIRP Irp,
    __in ULONG ProbeFlags,
    __in ULONG HeaderSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateExtraData(
    __inout PIRP Irp,
    __in ULONG ExtraSize,
    __out PVOID* ExtraBuffer
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsNullDriverUnload(
    __in PDRIVER_OBJECT DriverObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSetMajorFunctionHandler(
    __in PDRIVER_OBJECT DriverObject,
    __in ULONG MajorFunction
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchInvalidDeviceRequest(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDeviceIoCompletion(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchIrp(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastIoDeviceControlFailure(
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN Wait,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __in ULONG IoControlCode,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastReadFailure(
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __out PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );

#define KsDispatchFastWriteFailure KsDispatchFastReadFailure

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
DRIVER_CANCEL KsCancelRoutine;

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsCancelIo(   
    __inout PLIST_ENTRY  QueueHead,
    __in PKSPIN_LOCK SpinLock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsReleaseIrpOnCancelableQueue(
    __in PIRP Irp,
    __in_opt PDRIVER_CANCEL DriverCancel
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PIRP
NTAPI
KsRemoveIrpFromCancelableQueue(
    __inout PLIST_ENTRY QueueHead,
    __in PKSPIN_LOCK SpinLock,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in KSIRP_REMOVAL_OPERATION RemovalOperation
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMoveIrpsOnCancelableQueue(
    __inout PLIST_ENTRY SourceList,
    __in PKSPIN_LOCK SourceLock,
    __inout PLIST_ENTRY DestinationList,
    __in_opt PKSPIN_LOCK DestinationLock,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in PFNKSIRPLISTCALLBACK ListCallback,
    __in PVOID Context
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsRemoveSpecificIrpFromCancelableQueue(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsAddIrpToCancelableQueue(
    __inout PLIST_ENTRY QueueHead,
    __in PKSPIN_LOCK SpinLock,
    __in PIRP Irp,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in_opt PDRIVER_CANCEL DriverCancel
    );

// api.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAcquireResetValue(
    __in PIRP Irp,
    __out KSRESET* ResetValue
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsTopologyPropertyHandler(
    __in PIRP Irp,
    __in PKSPROPERTY Property,
    __inout PVOID Data,
    __in const KSTOPOLOGY* Topology
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsAcquireDeviceSecurityLock(
    __in KSDEVICE_HEADER Header,
    __in BOOLEAN Exclusive
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsReleaseDeviceSecurityLock(
    __in KSDEVICE_HEADER Header
    );
    
KSDDKAPI
__drv_dispatchType(IRP_MJ_PNP) DRIVER_DISPATCH KsDefaultDispatchPnp;

KSDDKAPI
__drv_dispatchType(IRP_MJ_POWER) DRIVER_DISPATCH KsDefaultDispatchPower;
    
KSDDKAPI
__drv_dispatchType(IRP_MJ_SYSTEM_CONTROL) 
__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH KsDefaultForwardIrp;

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDevicePnpAndBaseObject(
    __in KSDEVICE_HEADER Header,
    __in PDEVICE_OBJECT PnpDeviceObject,
    __in PDEVICE_OBJECT BaseObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsQueryDevicePnpObject(
    __in KSDEVICE_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ACCESS_MASK
NTAPI
KsQueryObjectAccessMask(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsRecalculateStackDepth(
    __in KSDEVICE_HEADER Header,
    __in BOOLEAN ReuseStackLocation
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetTargetState(
    __in KSOBJECT_HEADER Header,
    __in KSTARGET_STATE TargetState
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetTargetDeviceObject(
    __in KSOBJECT_HEADER Header,
    __in_opt PDEVICE_OBJECT TargetDevice
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetPowerDispatch(
    __in KSOBJECT_HEADER Header,
    __in_opt PFNKSCONTEXT_DISPATCH PowerDispatch,
    __in_opt PVOID PowerContext
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSOBJECT_CREATE_ITEM
NTAPI
KsQueryObjectCreateItem(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDeviceHeader(
    __out KSDEVICE_HEADER* Header,
    __in ULONG ItemsCount,
    __in_ecount_opt(ItemsCount) PKSOBJECT_CREATE_ITEM ItemsList
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeDeviceHeader(
    __in KSDEVICE_HEADER Header
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectHeader(
    __out KSOBJECT_HEADER* Header,
    __in ULONG ItemsCount,
    __in_ecount_opt(ItemsCount) PKSOBJECT_CREATE_ITEM ItemsList,
    __in PIRP Irp,
    __in const KSDISPATCH_TABLE* Table
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeObjectHeader(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToDeviceHeader(
    __in KSDEVICE_HEADER Header,
    __in PDRIVER_DISPATCH Create,
    __in PVOID Context,
    __in PWSTR ObjectClass,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToObjectHeader(
    __in KSOBJECT_HEADER Header,
    __in PDRIVER_DISPATCH Create,
    __in PVOID Context,
    __in PWSTR ObjectClass,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectCreateItem(
    __in KSDEVICE_HEADER Header,
    __in PKSOBJECT_CREATE_ITEM CreateItem,
    __in BOOLEAN AllocateEntry,
    __in_opt PFNKSITEMFREECALLBACK ItemFreeCallback
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItem(
    __in KSDEVICE_HEADER Header,
    __in PUNICODE_STRING CreateItem
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItemsByContext(
    __in KSDEVICE_HEADER Header,
    __in PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultSecurity(
    __in_opt PSECURITY_DESCRIPTOR ParentSecurity,
    __out PSECURITY_DESCRIPTOR* DefaultSecurity
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsForwardIrp(
    __in PIRP Irp,
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN ReuseStackLocation
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsForwardAndCatchIrp(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in PFILE_OBJECT FileObject,
    __in KSSTACK_USE StackUse
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSynchronousIoControlDevice(
    __in PFILE_OBJECT FileObject,
    __in KPROCESSOR_MODE RequestorMode,
    __in ULONG IoControl,
    __in_bcount(InSize) PVOID InBuffer,
    __in ULONG InSize,
    __out_bcount_part(OutSize, *BytesReturned) PVOID OutBuffer,
    __in ULONG OutSize,
    __out PULONG BytesReturned
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsUnserializeObjectPropertiesFromRegistry(
    __in PFILE_OBJECT FileObject,
    __in_opt HANDLE ParentKey,
    __in_opt PUNICODE_STRING RegistryPath
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCacheMedium(
    __in PUNICODE_STRING SymbolicLink,
    __in PKSPIN_MEDIUM Medium,
    __in ULONG PinDirection
    );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// thread.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterWorker(
    __in WORK_QUEUE_TYPE WorkQueueType,
    __out PKSWORKER* Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterCountedWorker(
    __in WORK_QUEUE_TYPE WorkQueueType,
    __in PWORK_QUEUE_ITEM CountedWorkItem,
    __out PKSWORKER* Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsUnregisterWorker(
    __in PKSWORKER Worker
    );
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsQueueWorkItem(
    __in PKSWORKER Worker,
    __in PWORK_QUEUE_ITEM WorkItem
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsIncrementCountedWorker(
    __in PKSWORKER Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDecrementCountedWorker(
    __in PKSWORKER Worker
    );

// topology.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateTopologyNode(
    __in HANDLE ParentHandle,
    __in PKSNODE_CREATE NodeCreate,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE NodeHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateTopologyNodeCreateRequest(
    __in PIRP Irp,
    __in PKSTOPOLOGY Topology,
    __out PKSNODE_CREATE* NodeCreate
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMergeAutomationTables(
    __out PKSAUTOMATION_TABLE* AutomationTableAB,
    __in_opt PKSAUTOMATION_TABLE AutomationTableA,
    __in_opt PKSAUTOMATION_TABLE AutomationTableB,
    __in_opt KSOBJECT_BAG Bag
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDriver(
    __in PDRIVER_OBJECT DriverObject,
    __in PUNICODE_STRING RegistryPathName,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddDevice(
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDevice(
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor,
    __in ULONG ExtensionSize,
    __out_opt PKSDEVICE* Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDevice(
    __in PDEVICE_OBJECT FunctionalDeviceObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PDEVICE_OBJECT NextDeviceObject,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsTerminateDevice(
    __in PDEVICE_OBJECT DeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSDEVICE
NTAPI
KsGetDeviceForDeviceObject(
    __in PDEVICE_OBJECT FunctionalDeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAcquireDevice(
    __in PKSDEVICE Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsReleaseDevice(
    __in PKSDEVICE Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsDeviceRegisterAdapterObject(
    __in PKSDEVICE Device,
    __in PADAPTER_OBJECT AdapterObject,
    __in ULONG MaxMappingsByteCount,
    __in ULONG MappingTableStride
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDeviceGetBusData(
    __in PKSDEVICE Device,
    __in ULONG DataType,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDeviceSetBusData(
    __in PKSDEVICE Device,
    __in ULONG DataType,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateFilterFactory(
    __in PDEVICE_OBJECT DeviceObject,
    __in const KSFILTER_DESCRIPTOR *Descriptor,
    __in_opt PWSTR RefString,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG CreateItemFlags,
    __in_opt PFNKSFILTERFACTORYPOWER SleepCallback,
    __in_opt PFNKSFILTERFACTORYPOWER WakeCallback,
    __out_opt PKSFILTERFACTORY *FilterFactory
    );

#define KsDeleteFilterFactory(FilterFactory) \
    KsFreeObjectCreateItemsByContext(\
        *(KSDEVICE_HEADER *)(\
            KsFilterFactoryGetParentDevice(FilterFactory)->FunctionalDeviceObject->\
                DeviceExtension),\
        FilterFactory)

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryUpdateCacheData(
    __in PKSFILTERFACTORY FilterFactory,
    __in_opt const KSFILTER_DESCRIPTOR *FilterDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryAddCreateItem(
    __in PKSFILTERFACTORY FilterFactory,
    __in PWSTR RefString,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG CreateItemFlags
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactorySetDeviceClassesState(
    __in PKSFILTERFACTORY FilterFactory,
    __in BOOLEAN NewState
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNICODE_STRING
NTAPI
KsFilterFactoryGetSymbolicLink(
    __in PKSFILTERFACTORY FilterFactory
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAddEvent(
    __in PVOID Object,
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
void _inline
KsFilterAddEvent(
    __in PKSFILTER Filter,
    __in PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Filter,EventEntry);
}

__drv_maxIRQL(PASSIVE_LEVEL)
void _inline
KsPinAddEvent(
    __in PKSPIN Pin,
    __in PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Pin,EventEntry);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS    
NTAPI
KsDefaultAddEventHandler(
    __in PIRP Irp,
    __in PKSEVENTDATA EventData,
    __inout PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsGenerateEvents(
    __in PVOID Object,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount_opt(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    );

__drv_maxIRQL(DISPATCH_LEVEL)
void _inline
KsFilterGenerateEvents(
    __in PKSFILTER Filter,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    )
{
    KsGenerateEvents(
        Filter,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

__drv_maxIRQL(DISPATCH_LEVEL)
void _inline
KsPinGenerateEvents(
    __in PKSPIN Pin,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount_opt(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    )
{
    KsGenerateEvents(
        Pin,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

typedef enum {
    KSSTREAM_POINTER_STATE_UNLOCKED = 0,
    KSSTREAM_POINTER_STATE_LOCKED
} KSSTREAM_POINTER_STATE;

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetAvailableByteCount(
    __in PKSPIN Pin,
    __out_opt PLONG InputDataBytes,
    __out_opt PLONG OutputBufferBytes
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetLeadingEdgeStreamPointer(
    __in PKSPIN Pin,
    __in KSSTREAM_POINTER_STATE State
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetTrailingEdgeStreamPointer(
    __in PKSPIN Pin,
    __in KSSTREAM_POINTER_STATE State
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerSetStatusCode(
    __in PKSSTREAM_POINTER StreamPointer,
    __in NTSTATUS Status
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerLock(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerUnlock(
    __in PKSSTREAM_POINTER StreamPointer,
    __in BOOLEAN Eject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerAdvanceOffsetsAndUnlock(
    __in PKSSTREAM_POINTER StreamPointer,
    __in ULONG InUsed,
    __in ULONG OutUsed,
    __in BOOLEAN Eject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerDelete(
    __in PKSSTREAM_POINTER StreamPointer
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerClone(
    __in PKSSTREAM_POINTER StreamPointer,
    __in_opt PFNKSSTREAMPOINTER CancelCallback,
    __in ULONG ContextSize,
    __out PKSSTREAM_POINTER* CloneStreamPointer
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvanceOffsets(
    __in PKSSTREAM_POINTER StreamPointer,
    __in ULONG InUsed,
    __in ULONG OutUsed,
    __in BOOLEAN Eject
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvance(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PMDL
NTAPI
KsStreamPointerGetMdl(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PIRP
NTAPI
KsStreamPointerGetIrp(
    __in PKSSTREAM_POINTER StreamPointer,
    __out_opt PBOOLEAN FirstFrameInIrp,
    __out_opt PBOOLEAN LastFrameInIrp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerScheduleTimeout(
    __in PKSSTREAM_POINTER StreamPointer,
    __in PFNKSSTREAMPOINTER Callback,
    __in ULONGLONG Interval
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerCancelTimeout(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetFirstCloneStreamPointer(
    __in PKSPIN Pin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsStreamPointerGetNextClone(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinHandshake(
    __in PKSPIN Pin,
    __in PKSHANDSHAKE In,
    __out PKSHANDSHAKE Out
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsCompletePendingRequest(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetObjectFromFileObject(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromFileObject(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
PKSFILTER __inline
KsGetFilterFromFileObject(
    __in PFILE_OBJECT FileObject
    )
{
    return (PKSFILTER) KsGetObjectFromFileObject(FileObject);
}

__drv_maxIRQL(DISPATCH_LEVEL)
PKSPIN __inline
KsGetPinFromFileObject(
    __in PFILE_OBJECT FileObject
    )
{
    return (PKSPIN) KsGetObjectFromFileObject(FileObject);
}    

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSGATE
NTAPI
KsFilterGetAndGate(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterAcquireProcessingMutex(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterReleaseProcessingMutex(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterAttemptProcessing(
    __in PKSFILTER Filter,
    __in BOOLEAN Asynchronous
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSGATE
NTAPI
KsPinGetAndGate(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttachAndGate(
    __in PKSPIN Pin,
    __in_opt PKSGATE AndGate
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttachOrGate(
    __in PKSPIN Pin,
    __in_opt PKSGATE OrGate
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAcquireProcessingMutex(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinReleaseProcessingMutex(
    __in PKSPIN Pin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsProcessPinUpdate(
    __in PKSPROCESSPIN ProcessPin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsPinGetCopyRelationships(
    __in PKSPIN Pin,
    __out PKSPIN* CopySource,
    __out PKSPIN* DelegateBranch
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttemptProcessing(
    __in PKSPIN Pin,
    __in BOOLEAN Asynchronous
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetParent(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterFactoryGetParentDevice(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSDEVICE) KsGetParent((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsFilterGetParentFilterFactory(
    __in PKSFILTER Filter
    )
{
    return (PKSFILTERFACTORY) KsGetParent((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSFILTER 
NTAPI
KsPinGetParentFilter(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetFirstChild(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsDeviceGetFirstChildFilterFactory(
    __in PKSDEVICE Device
    )
{
    return (PKSFILTERFACTORY) KsGetFirstChild((PVOID) Device);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTER __inline
KsFilterFactoryGetFirstChildFilter(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTER) KsGetFirstChild((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsFilterGetChildPinCount(
    __in PKSFILTER Filter,
    __in ULONG PinId
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSPIN
NTAPI
KsFilterGetFirstChildPin(
    __in PKSFILTER Filter,
    __in ULONG PinId
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetNextSibling(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSPIN 
NTAPI
KsPinGetNextSiblingPin(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsFilterFactoryGetNextSiblingFilterFactory(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTERFACTORY) KsGetNextSibling((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTER __inline
KsFilterGetNextSiblingFilter(
    __in PKSFILTER Filter
    )
{
    return (PKSFILTER) KsGetNextSibling((PVOID) Filter);
}


__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSDEVICE
NTAPI
KsGetDevice(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterFactoryGetDevice(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetDevice((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterGetDevice(
    __in PKSFILTER Filter
    )
{
    return KsGetDevice((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsPinGetDevice(
    __in PKSPIN Pin
    )
{
    return KsGetDevice((PVOID) Pin);
}

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSFILTER
NTAPI
KsGetFilterFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSPIN
NTAPI
KsGetPinFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsGetNodeIdFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAcquireControl(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsReleaseControl(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsFilterAcquireControl(
    __in PKSFILTER Filter
    )
{
    KsAcquireControl((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsFilterReleaseControl(
    __in PKSFILTER Filter
    )
{
    KsReleaseControl((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsPinAcquireControl(
    __in PKSPIN Pin
    )
{
    KsAcquireControl((PVOID) Pin);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsPinReleaseControl(
    __in PKSPIN Pin
    )
{
    KsReleaseControl((PVOID) Pin);
}

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddItemToObjectBag(
    __in KSOBJECT_BAG ObjectBag,
    __in __drv_aliasesMem PVOID Item,
    __in_opt PFNKSFREE Free
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsRemoveItemFromObjectBag(
    __in KSOBJECT_BAG ObjectBag,
    __in PVOID Item,
    __in BOOLEAN Free
    );

#define KsDiscard(Object,Pointer)\
    KsRemoveItemFromObjectBag(\
        (Object)->Bag,\
        (PVOID)(Pointer),\
        TRUE)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectBag(
    __in PKSDEVICE Device,
    __out KSOBJECT_BAG* ObjectBag
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFreeObjectBag(
    __in KSOBJECT_BAG ObjectBag
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCopyObjectBagItems(
    __in KSOBJECT_BAG ObjectBagDestination,
    __in KSOBJECT_BAG ObjectBagSource
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
_KsEdit(
    __in KSOBJECT_BAG ObjectBag,
    __inout PVOID* PointerToPointerToItem,
    __in ULONG NewSize,
    __in ULONG OldSize,
    __in ULONG Tag
    );

#define KsEdit(Object,PointerToPointer,Tag)\
    _KsEdit(\
        (Object)->Bag,\
        (PVOID*)(PointerToPointer),\
        sizeof(**(PointerToPointer)),\
        sizeof(**(PointerToPointer)),\
        (Tag))
#define KsEditSized(Object,PointerToPointer,NewSize,OldSize,Tag)\
    _KsEdit((Object)->Bag,(PVOID*)(PointerToPointer),(NewSize),(OldSize),(Tag))

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterFilterWithNoKSPins(
                                      __in PDEVICE_OBJECT DeviceObject,
                                      __in const GUID * InterfaceClassGUID,
                                      __in ULONG PinCount,
                                      __in_ecount(PinCount) BOOL * PinDirection,
                                      __in_ecount(PinCount) KSPIN_MEDIUM * MediumList,
                                      __in_ecount_opt(PinCount) GUID * CategoryList
);

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreatePinFactory (
    __in PKSFILTER Filter,
    __in const KSPIN_DESCRIPTOR_EX *const PinDescriptor,
    __out PULONG PinID
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreateNode (
    __in PKSFILTER Filter,
    __in const KSNODE_DESCRIPTOR *const NodeDescriptor,
    __out PULONG NodeID
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterAddTopologyConnections (
    __in PKSFILTER Filter,
    __in ULONG NewConnectionsCount,
    __in_ecount(NewConnectionsCount) const KSTOPOLOGY_CONNECTION *const NewTopologyConnections
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedPinInterface(
    __in PKSPIN Pin,
    __in const GUID* InterfaceId,
    __out PVOID* Interface
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PFILE_OBJECT
NTAPI
KsPinGetConnectedPinFileObject(
    __in PKSPIN Pin
    );

KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsPinGetConnectedPinDeviceObject(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedFilterInterface(
    __in PKSPIN Pin,
    __in const GUID* InterfaceId,
    __out PVOID* Interface
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetReferenceClockInterface(
    __in PKSPIN Pin,
    __out PIKSREFERENCECLOCK* Interface
    );

#endif //defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsPinSetPinClockTime(
    __in PKSPIN Pin,
    __in LONGLONG Time
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrame(
    __in PKSPIN Pin,
    __in_bcount_opt(Size) PVOID Data,
    __in ULONG Size OPTIONAL,
    __in_opt PKSSTREAM_HEADER StreamHeader,
    __in_opt PVOID Context
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrameMdl(
    __in PKSPIN Pin,
    __in_opt PMDL Mdl,
    __in_opt PKSSTREAM_HEADER StreamHeader,
    __in_opt PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterFrameReturnCallback(
    __in PKSPIN Pin,
    __in PFNKSPINFRAMERETURN FrameReturn
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterIrpCompletionCallback(
    __in PKSPIN Pin,
    __in PFNKSPINIRPCOMPLETION IrpCompletion
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterHandshakeCallback(
    __in PKSPIN Pin,
    __in PFNKSPINHANDSHAKE Handshake
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterRegisterPowerCallbacks(
    __in PKSFILTER Filter,
    __in_opt PFNKSFILTERPOWER Sleep,
    __in_opt PFNKSFILTERPOWER Wake
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterPowerCallbacks(
    __in PKSPIN Pin,
    __in_opt PFNKSPINPOWER Sleep,
    __in_opt PFNKSPINPOWER Wake
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNKNOWN
NTAPI
KsRegisterAggregatedClientUnknown(
    __in PVOID Object,
    __in PUNKNOWN ClientUnknown 
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNKNOWN
NTAPI
KsGetOuterUnknown(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsDeviceRegisterAggregatedClientUnknown(
    __in PKSDEVICE Device,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Device,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsDeviceGetOuterUnknown(
    __in PKSDEVICE Device
    )
{
    return KsGetOuterUnknown((PVOID) Device);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsFilterFactoryRegisterAggregatedClientUnknown(
    __in PKSFILTERFACTORY FilterFactory,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) FilterFactory,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsFilterFactoryGetOuterUnknown(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetOuterUnknown((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsFilterRegisterAggregatedClientUnknown(
    __in PKSFILTER Filter,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Filter,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsFilterGetOuterUnknown(
    __in PKSFILTER Filter
    )
{
    return KsGetOuterUnknown((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsPinRegisterAggregatedClientUnknown(
    __in PKSPIN Pin,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Pin,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsPinGetOuterUnknown(
    __in PKSPIN Pin
    )
{
    return KsGetOuterUnknown((PVOID) Pin);
}

#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#else // !defined(_NTDDK_)

#if !defined( KS_NO_CREATE_FUNCTIONS )

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreateAllocator(
    __in HANDLE ConnectionHandle,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PHANDLE AllocatorHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
NTAPI
KsCreateClock(
    __in HANDLE ConnectionHandle,
    __in PKSCLOCK_CREATE ClockCreate,
    __out PHANDLE ClockHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreatePin(
    __in HANDLE FilterHandle,
    __in PKSPIN_CONNECT Connect,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE ConnectionHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreateTopologyNode(
    __in HANDLE ParentHandle,
    __in PKSNODE_CREATE NodeCreate,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE NodeHandle
    );
    
#endif

#endif // !defined(_NTDDK_)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)


#define DENY_USERMODE_ACCESS( pIrp, CompleteRequest ) \
if ( pIrp->RequestorMode != KernelMode ) { \
    pIrp->IoStatus.Information = 0; \
    pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; \
    if ( CompleteRequest ) IoCompleteRequest ( pIrp, IO_NO_INCREMENT ); \
    return STATUS_INVALID_DEVICE_REQUEST; \
}


#endif // !_KS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\KsProxy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksproxy.h

Abstract:

    Interface definitions for WDM-CSA proxy filters.

--*/

#ifndef __KSPROXY__
#define __KSPROXY__

#ifdef __cplusplus
extern "C" {
#endif

#undef KSDDKAPI
#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#define STATIC_IID_IKsObject\
    0x423c13a2L, 0x2070, 0x11d0, 0x9e, 0xf7, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsPinEx\
    0x7bb38260L, 0xd19c, 0x11d2, 0xb3, 0x8a, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e

#define STATIC_IID_IKsPin\
    0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1
    
#define STATIC_IID_IKsPinPipe\
    0xe539cd90L, 0xa8b4, 0x11d1, 0x81, 0x89, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02

#define STATIC_IID_IKsDataTypeHandler\
    0x5ffbaa02L, 0x49a3, 0x11d0, 0x9f, 0x36, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsDataTypeCompletion\
    0x827D1A0EL, 0x0F73, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsInterfaceHandler\
    0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsClockPropertySet\
    0x5C5CBD84L, 0xE755, 0x11D0, 0xAC, 0x18, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsAllocator\
    0x8da64899L, 0xc0d9, 0x11d0, 0x84, 0x13, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
    
#define STATIC_IID_IKsAllocatorEx\
    0x091bb63aL, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
    

#ifndef STATIC_IID_IKsPropertySet
#define STATIC_IID_IKsPropertySet\
    0x31EFAC30L, 0x515C, 0x11d0, 0xA9, 0xAA, 0x00, 0xAA, 0x00, 0x61, 0xBE, 0x93
#endif // STATIC_IID_IKsPropertySet

#define STATIC_IID_IKsTopology\
    0x28F54683L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif // STATIC_IID_IKsControl

#define STATIC_IID_IKsAggregateControl\
    0x7F40EAC0L, 0x3947, 0x11D2, 0x87, 0x4E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_CLSID_Proxy \
    0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifdef _KS_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsObject);

DEFINE_GUIDEX(IID_IKsPin);

DEFINE_GUIDEX(IID_IKsPinEx);

DEFINE_GUIDEX(IID_IKsPinPipe);

DEFINE_GUIDEX(IID_IKsDataTypeHandler);

DEFINE_GUIDEX(IID_IKsDataTypeCompletion);

DEFINE_GUIDEX(IID_IKsInterfaceHandler);

DEFINE_GUIDEX(IID_IKsClockPropertySet);

DEFINE_GUIDEX(IID_IKsAllocator);

DEFINE_GUIDEX(IID_IKsAllocatorEx);

#define IID_IKsQualityForwarder KSCATEGORY_QUALITY
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#define STATIC_IID_IKsQualityForwarder STATIC_KSCATEGORY_QUALITY

typedef enum {
    KsAllocatorMode_User,
    KsAllocatorMode_Kernel
} KSALLOCATORMODE;


typedef enum {
    FramingProp_Uninitialized,
    FramingProp_None,
    FramingProp_Old,
    FramingProp_Ex
} FRAMING_PROP;

typedef FRAMING_PROP *PFRAMING_PROP;


typedef enum {
    Framing_Cache_Update,     // request to bypass cache when read/write
    Framing_Cache_ReadLast,
    Framing_Cache_ReadOrig,
    Framing_Cache_Write
} FRAMING_CACHE_OPS;


typedef struct {
    LONGLONG     MinTotalNominator;  
    LONGLONG     MaxTotalNominator;
    LONGLONG     TotalDenominator;
} OPTIMAL_WEIGHT_TOTALS;

// forward declaration
typedef struct IPin IPin;
typedef struct IKsPin IKsPin;
typedef struct IKsAllocator IKsAllocator;
typedef struct IKsAllocatorEx IKsAllocatorEx;

                      
//
// allocators strategy is defined by graph manager
//
#define AllocatorStrategy_DontCare                      0

//
// what to optimize
//
#define AllocatorStrategy_MinimizeNumberOfFrames        0x00000001
#define AllocatorStrategy_MinimizeFrameSize             0x00000002
#define AllocatorStrategy_MinimizeNumberOfAllocators    0x00000004
#define AllocatorStrategy_MaximizeSpeed                 0x00000008 

//
// factors (flags) defining the Pipes properties
//
#define PipeFactor_None                   0
#define PipeFactor_UserModeUpstream       0x00000001
#define PipeFactor_UserModeDownstream     0x00000002
#define PipeFactor_MemoryTypes            0x00000004
#define PipeFactor_Flags                  0x00000008
#define PipeFactor_PhysicalRanges         0x00000010
#define PipeFactor_OptimalRanges          0x00000020
#define PipeFactor_FixedCompression       0x00000040
#define PipeFactor_UnknownCompression     0x00000080

#define PipeFactor_Buffers                0x00000100
#define PipeFactor_Align                  0x00000200

#define PipeFactor_PhysicalEnd            0x00000400
#define PipeFactor_LogicalEnd             0x00000800



typedef enum {
    PipeState_DontCare,
    PipeState_RangeNotFixed,
    PipeState_RangeFixed,
    PipeState_CompressionUnknown,
    PipeState_Finalized
} PIPE_STATE;


//
// pipe dimensions relative to BeginPin.
//

typedef struct _PIPE_DIMENSIONS {
    KS_COMPRESSION    AllocatorPin;
    KS_COMPRESSION    MaxExpansionPin;
    KS_COMPRESSION    EndPin;
} PIPE_DIMENSIONS, *PPIPE_DIMENSIONS;


typedef enum {
    Pipe_Allocator_None,
    Pipe_Allocator_FirstPin,
    Pipe_Allocator_LastPin,
    Pipe_Allocator_MiddlePin
} PIPE_ALLOCATOR_PLACE;

typedef PIPE_ALLOCATOR_PLACE  *PPIPE_ALLOCATOR_PLACE;


typedef enum {
    KS_MemoryTypeDontCare = 0,
    KS_MemoryTypeKernelPaged,
    KS_MemoryTypeKernelNonPaged,
    KS_MemoryTypeDeviceHostMapped,
    KS_MemoryTypeDeviceSpecific,
    KS_MemoryTypeUser,
    KS_MemoryTypeAnyHost
} KS_LogicalMemoryType;

typedef KS_LogicalMemoryType  *PKS_LogicalMemoryType;



typedef struct _PIPE_TERMINATION {
    ULONG                       Flags;
    ULONG                       OutsideFactors;
    ULONG                       Weigth;            // outside weight
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange;      
    KS_COMPRESSION              Compression;       // relative to the connected pin on a neighboring filter.
} PIPE_TERMINATION;


//
// extended allocator properties 
//
typedef struct _ALLOCATOR_PROPERTIES_EX
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
// new part
    GUID                       MemoryType;         
    GUID                       BusType;            // one of the buses this pipe is using
    PIPE_STATE                 State;                        
    PIPE_TERMINATION           Input;                        
    PIPE_TERMINATION           Output;                       
    ULONG                      Strategy;
    ULONG                      Flags;              
    ULONG                      Weight;
    KS_LogicalMemoryType       LogicalMemoryType;
    PIPE_ALLOCATOR_PLACE       AllocatorPlace;
    PIPE_DIMENSIONS            Dimensions;
    KS_FRAMING_RANGE           PhysicalRange;      // on allocator pin
    IKsAllocatorEx*            PrevSegment;        // doubly-linked list of KS allocators
    ULONG                      CountNextSegments;  // possible multiple dependent pipes
    IKsAllocatorEx**           NextSegments;
    ULONG                      InsideFactors;      // existing factors (different from "don't care")
    ULONG                      NumberPins;                   
} ALLOCATOR_PROPERTIES_EX;

typedef ALLOCATOR_PROPERTIES_EX *PALLOCATOR_PROPERTIES_EX;


#ifdef __STREAMS__

struct DECLSPEC_UUID("5C5CBD84-E755-11D0-AC18-00A0C9223196") IKsClockPropertySet;
#undef INTERFACE
#define INTERFACE IKsClockPropertySet
DECLARE_INTERFACE_(IKsClockPropertySet, IUnknown)
{
    STDMETHOD(KsGetTime)(
        THIS_
        __out LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetTime)(
        THIS_
        __in LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetPhysicalTime)(
        THIS_
        __out LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetPhysicalTime)(
        THIS_
        __in LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetCorrelatedTime)(
        THIS_
        __out KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedTime)(
        THIS_
        __in KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetCorrelatedPhysicalTime)(
        THIS_
        __out KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedPhysicalTime)(
        THIS_
        __in KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetResolution)(
        THIS_
        __out KSRESOLUTION* Resolution
    ) PURE;
    STDMETHOD(KsGetState)(
        THIS_
        __out KSSTATE* State
    ) PURE;
};


interface DECLSPEC_UUID("8da64899-c0d9-11d0-8413-0000f822fe8a") IKsAllocator;
#undef INTERFACE
#define INTERFACE IKsAllocator
DECLARE_INTERFACE_(IKsAllocator, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetAllocatorHandle)(
        THIS
    ) PURE;
    STDMETHOD_(KSALLOCATORMODE, KsGetAllocatorMode)(
        THIS
    ) PURE;
    STDMETHOD(KsGetAllocatorStatus)(
        THIS_
        __out PKSSTREAMALLOCATOR_STATUS AllocatorStatus
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorMode)(
        THIS_
        __in KSALLOCATORMODE Mode
    ) PURE;
};

interface DECLSPEC_UUID("091bb63a-603f-11d1-b067-00a0c9062802") IKsAllocatorEx;
#undef INTERFACE
#define INTERFACE IKsAllocatorEx
DECLARE_INTERFACE_(IKsAllocatorEx, IKsAllocator)
{
    STDMETHOD_(PALLOCATOR_PROPERTIES_EX, KsGetProperties)(
        THIS
    ) PURE;
    STDMETHOD_(VOID, KsSetProperties)(
        THIS_
        __in PALLOCATOR_PROPERTIES_EX 
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorHandle)(
        THIS_
        __in HANDLE AllocatorHandle
    ) PURE;
    STDMETHOD_(HANDLE, KsCreateAllocatorAndGetHandle)(
        THIS_
        __in IKsPin*   KsPin
    ) PURE;
};  

typedef enum {
    KsPeekOperation_PeekOnly,
    KsPeekOperation_AddRef
} KSPEEKOPERATION;

typedef struct _KSSTREAM_SEGMENT *PKSSTREAM_SEGMENT;

interface DECLSPEC_UUID("b61178d1-a2d9-11cf-9e53-00aa00a216a1") IKsPin;

#undef INTERFACE
#define INTERFACE IKsPin
DECLARE_INTERFACE_(IKsPin, IUnknown)
{
    STDMETHOD(KsQueryMediums)(
        THIS_
        __deref_out PKSMULTIPLE_ITEM* MediumList
    ) PURE;
    STDMETHOD(KsQueryInterfaces)(
        THIS_
        __deref_out PKSMULTIPLE_ITEM* InterfaceList
    ) PURE;
    STDMETHOD(KsCreateSinkPinHandle)(
        THIS_
        __in KSPIN_INTERFACE& Interface,
        __in KSPIN_MEDIUM& Medium
    ) PURE;
    STDMETHOD(KsGetCurrentCommunication)(
        THIS_
        __out_opt KSPIN_COMMUNICATION *Communication,
        __out_opt KSPIN_INTERFACE *Interface,
        __out_opt KSPIN_MEDIUM *Medium
    ) PURE;
    STDMETHOD(KsPropagateAcquire)(
        THIS
    ) PURE;
    STDMETHOD(KsDeliver)(
        THIS_
        __in IMediaSample* Sample,
        __in ULONG Flags
    ) PURE;
    STDMETHOD(KsMediaSamplesCompleted)(
        THIS_
        __in PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
    STDMETHOD_(IMemAllocator *, KsPeekAllocator)(
        THIS_
        __in KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsReceiveAllocator)(
        THIS_
        __in_opt IMemAllocator *MemAllocator
    ) PURE;
    STDMETHOD(KsRenegotiateAllocator)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsIncrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsDecrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD(KsQualityNotify)(
        THIS_
        __in ULONG Proportion,
        __in REFERENCE_TIME TimeDelta
    ) PURE;
};

interface DECLSPEC_UUID("7bb38260-d19c-11d2-b38a-00a0c95ec22e") IKsPinEx;
#undef INTERFACE
#define INTERFACE IKsPinEx
DECLARE_INTERFACE_(IKsPinEx, IKsPin)
{
    STDMETHOD_(VOID, KsNotifyError)(
        THIS_
        __in IMediaSample* Sample,
        __in HRESULT hr
    ) PURE;        
};
                         
interface DECLSPEC_UUID("e539cd90-a8b4-11d1-8189-00a0c9062802") IKsPinPipe;
#undef INTERFACE
#define INTERFACE IKsPinPipe
DECLARE_INTERFACE_(IKsPinPipe, IUnknown)
{
    STDMETHOD(KsGetPinFramingCache)(
        THIS_
        __out PKSALLOCATOR_FRAMING_EX *FramingEx,
        __out PFRAMING_PROP FramingProp,
        __in FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD(KsSetPinFramingCache)(
        THIS_
        __in PKSALLOCATOR_FRAMING_EX FramingEx,
        __in PFRAMING_PROP FramingProp,
        __in FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD_(IPin*, KsGetConnectedPin)(
        THIS
    ) PURE;
    STDMETHOD_(IKsAllocatorEx*, KsGetPipe)(
        THIS_
        __in KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsSetPipe)(
        THIS_
        __in IKsAllocatorEx *KsAllocator
    ) PURE;
    STDMETHOD_(ULONG, KsGetPipeAllocatorFlag)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPipeAllocatorFlag)(
        THIS_
        __in ULONG Flag
    ) PURE;
    STDMETHOD_(GUID, KsGetPinBusCache)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPinBusCache)(
        THIS_
        __in GUID Bus
    ) PURE;
//
// very useful methods for tracing.
//
    STDMETHOD_(PWCHAR, KsGetPinName)(
        THIS
    ) PURE;
    STDMETHOD_(PWCHAR, KsGetFilterName)(
        THIS
    ) PURE;
};


interface DECLSPEC_UUID("CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196") IKsPinFactory;
#undef INTERFACE
#define INTERFACE IKsPinFactory
DECLARE_INTERFACE_(IKsPinFactory, IUnknown)
{
    STDMETHOD(KsPinFactory)(
        THIS_
        __out ULONG* PinFactory
    ) PURE;
};

typedef enum {
    KsIoOperation_Write,
    KsIoOperation_Read
} KSIOOPERATION;

interface DECLSPEC_UUID("5ffbaa02-49a3-11d0-9f36-00aa00a216a1") IKsDataTypeHandler;
#undef INTERFACE
#define INTERFACE IKsDataTypeHandler
DECLARE_INTERFACE_(IKsDataTypeHandler, IUnknown)
{
    STDMETHOD(KsCompleteIoOperation)(
        THIS_
        __inout IMediaSample *Sample,
        __inout PVOID StreamHeader,
        __in KSIOOPERATION IoOperation,
        __in BOOL Cancelled
    ) PURE;
    STDMETHOD(KsIsMediaTypeInRanges)(
        THIS_
        __in PVOID DataRanges
        ) PURE;
    STDMETHOD(KsPrepareIoOperation)(
        THIS_
        __inout IMediaSample *Sample,
        __inout PVOID StreamHeader,
        __in KSIOOPERATION IoOperation
    ) PURE;
    STDMETHOD(KsQueryExtendedSize)(
        THIS_
        __out ULONG* ExtendedSize
    ) PURE;
    STDMETHOD(KsSetMediaType)(
        THIS_
        __in const AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("827D1A0E-0F73-11D2-B27A-00A0C9223196") IKsDataTypeCompletion;
#undef INTERFACE
#define INTERFACE IKsDataTypeCompletion
DECLARE_INTERFACE_(IKsDataTypeCompletion, IUnknown)
{
    STDMETHOD(KsCompleteMediaType)(
        THIS_
        __in HANDLE FilterHandle,
        __in ULONG PinFactoryId,
        __inout AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("D3ABC7E0-9A61-11d0-A40D-00A0C9223196") IKsInterfaceHandler;
#undef INTERFACE
#define INTERFACE IKsInterfaceHandler
DECLARE_INTERFACE_(IKsInterfaceHandler, IUnknown)
{
    STDMETHOD(KsSetPin)(
        THIS_
        __in IKsPin *KsPin
    ) PURE;
    STDMETHOD(KsProcessMediaSamples)(
        THIS_
        __in IKsDataTypeHandler *KsDataTypeHandler,
        __in_ecount(SampleCount) IMediaSample** SampleList,
        __inout PLONG SampleCount,
        __in KSIOOPERATION IoOperation,
        __out PKSSTREAM_SEGMENT *StreamSegment
    ) PURE;
    STDMETHOD(KsCompleteIo)(
        THIS_
        __inout PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
};


//
// This structure definition is the common header required by the proxy to 
// dispatch the stream segment to the interface handler.  Interface handlers 
// will create extended structures to include other information such as 
// media samples, extended header size and so on.
//

typedef struct _KSSTREAM_SEGMENT {
    IKsInterfaceHandler     *KsInterfaceHandler;
    IKsDataTypeHandler      *KsDataTypeHandler;
    KSIOOPERATION           IoOperation;
    HANDLE                  CompletionEvent;
    
} KSSTREAM_SEGMENT;

interface DECLSPEC_UUID("423c13a2-2070-11d0-9ef7-00aa00a216a1") IKsObject;
#undef INTERFACE
#define INTERFACE IKsObject
DECLARE_INTERFACE_(IKsObject, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetObjectHandle)(
        THIS
    ) PURE;
};

interface DECLSPEC_UUID("97ebaacb-95bd-11d0-a3ea-00a0c9223196") IKsQualityForwarder;
#undef INTERFACE
#define INTERFACE IKsQualityForwarder
DECLARE_INTERFACE_(IKsQualityForwarder, IKsObject)
{
    STDMETHOD_(VOID, KsFlushClient)(
        THIS_
        __in IKsPin* Pin
    ) PURE;
};

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

interface DECLSPEC_UUID("412bd695-f84b-46c1-ac73-54196dbc8fa7") IKsNotifyEvent;
#undef INTERFACE
#define INTERFACE IKsNotifyEvent
DECLARE_INTERFACE_(IKsNotifyEvent, IUnknown)
{
    STDMETHOD(KsNotifyEvent)(
        THIS_
        __in ULONG Event,
        __in ULONG_PTR lParam1,
        __in ULONG_PTR lParam2
    ) PURE;
};

#endif

KSDDKAPI
HRESULT
WINAPI
KsResolveRequiredAttributes(
    __in PKSDATARANGE DataRange,
    __in_opt PKSMULTIPLE_ITEM Attributes
    );

KSDDKAPI
HRESULT
WINAPI
KsOpenDefaultDevice(
    __in REFGUID Category,
    __in ACCESS_MASK Access,
    __out PHANDLE DeviceHandle
    );
KSDDKAPI
HRESULT
WINAPI
KsSynchronousDeviceControl(
    __in HANDLE      Handle,
    __in ULONG       IoControl,
    __in_bcount_opt(InLength) PVOID   InBuffer,
    __in ULONG       InLength,
    __out_bcount_opt(OutLength) PVOID  OutBuffer,
    __in ULONG       OutLength,
    __inout_opt PULONG BytesReturned
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMultiplePinFactoryItems(
    __in HANDLE  FilterHandle,
    __in ULONG   PinFactoryId,
    __in ULONG   PropertyId,
    __deref_out PVOID*  Items
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaTypeCount(
    __in HANDLE      FilterHandle,
    __in ULONG       PinFactoryId,
    __out ULONG*      MediaTypeCount
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaType(
    __in int         Position,
    __out AM_MEDIA_TYPE* AmMediaType,
    __in HANDLE      FilterHandle,
    __in ULONG       PinFactoryId
    );

#endif // __STREAMS__

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#ifndef _IKsControl_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsControl_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsAggregateControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#ifndef _IKsTopology_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsTopology);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsTopology_

DEFINE_GUIDSTRUCT("17CCA71B-ECD7-11D0-B908-00A0C9223196", CLSID_Proxy);
#define CLSID_Proxy DEFINE_GUIDNAMED(CLSID_Proxy)

#else // !_KS_

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(IID_IKsPropertySet, STATIC_IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(CLSID_Proxy, STATIC_CLSID_Proxy);
#else  // defined(__cplusplus) && _MSC_VER >= 1100
DECLSPEC_UUID("17CCA71B-ECD7-11D0-B908-00A0C9223196") CLSID_Proxy;
#endif  // defined(__cplusplus) && _MSC_VER >= 1100

#endif // !_KS_

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#define KSPROPERTY_SUPPORT_GET 1
#define KSPROPERTY_SUPPORT_SET 2

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("31EFAC30-515C-11d0-A9AA-00aa0061be93") IKsPropertySet;
#undef INTERFACE
#define INTERFACE IKsPropertySet
DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    STDMETHOD(Set)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __in_bcount(InstanceLength) LPVOID InstanceData,
        __in ULONG InstanceLength,
        __in_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength
    ) PURE;

    STDMETHOD(Get)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __in_bcount(InstanceLength) LPVOID InstanceData,
        __in ULONG InstanceLength,
        __out_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
    ) PURE;

    STDMETHOD(QuerySupported)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __out ULONG* TypeSupport
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsPropertySet_

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54685-06FD-11D2-B27A-00A0C9223196") IKsControl;
#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
    STDMETHOD(KsProperty)(
        THIS_
        __in_bcount(PropertyLength) PKSPROPERTY Property,
        __in ULONG PropertyLength,
        __inout_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        __in_bcount(MethodLength) PKSMETHOD Method,
        __in ULONG MethodLength,
        __inout_bcount(DataLength) LPVOID MethodData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        __in_bcount_opt(EventLength) PKSEVENT Event,
        __in ULONG EventLength,
        __inout_bcount(DataLength) LPVOID EventData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsControl_


#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("7F40EAC0-3947-11D2-874E-00A0C9223196") IKsAggregateControl;
#undef INTERFACE
#define INTERFACE IKsAggregateControl
DECLARE_INTERFACE_(IKsAggregateControl, IUnknown)
{
    STDMETHOD(KsAddAggregate)(
        THIS_
        __in REFGUID AggregateClass
    ) PURE;
    STDMETHOD(KsRemoveAggregate)(
        THIS_
        __in REFGUID AggregateClass
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#ifndef _IKsTopology_
#define _IKsTopology_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54683-06FD-11D2-B27A-00A0C9223196") IKsTopology;
#undef INTERFACE
#define INTERFACE IKsTopology
DECLARE_INTERFACE_(IKsTopology, IUnknown)
{
    STDMETHOD(CreateNodeInstance)(
        THIS_
        __in ULONG NodeId,
        __in ULONG Flags,
        __in ACCESS_MASK DesiredAccess,
        __in_opt IUnknown* UnkOuter,
        __in REFGUID InterfaceId,
        __out LPVOID* Interface
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsTopology_

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KSPROXY__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMalert.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    alert.h

Abstract:

    This file contains structures for communication with the Alerter
    service.

Environment:

    User Mode - Win32

Notes:

    You must include LmCons.H before this file, since this file depends
    on values defined in LmCons.H.

    ALERT.H includes ALERTMSG.H which defines the alert message numbers


--*/


#ifndef _ALERT_
#define _ALERT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    __in LPCWSTR AlertType,
    __in LPVOID  Buffer,
    __in DWORD   BufferSize
    );

NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    __in LPCWSTR AlertType,
    __in LPVOID  VariableInfo,
    __in DWORD   VariableInfoSize,
    __in LPCWSTR ServiceName
    );


//
//  Data Structures
//

typedef struct _STD_ALERT {
    DWORD  alrt_timestamp;
    WCHAR  alrt_eventname[EVLEN + 1];
    WCHAR  alrt_servicename[SNLEN + 1];
}STD_ALERT, *PSTD_ALERT, *LPSTD_ALERT;

typedef struct _ADMIN_OTHER_INFO {
    DWORD  alrtad_errcode;
    DWORD  alrtad_numstrings;
}ADMIN_OTHER_INFO, *PADMIN_OTHER_INFO, *LPADMIN_OTHER_INFO;

typedef struct _ERRLOG_OTHER_INFO {
    DWORD  alrter_errcode;
    DWORD  alrter_offset;
}ERRLOG_OTHER_INFO, *PERRLOG_OTHER_INFO, *LPERRLOG_OTHER_INFO;

typedef struct _PRINT_OTHER_INFO {
    DWORD  alrtpr_jobid;
    DWORD  alrtpr_status;
    DWORD  alrtpr_submitted;
    DWORD  alrtpr_size;
}PRINT_OTHER_INFO, *PPRINT_OTHER_INFO, *LPPRINT_OTHER_INFO;

typedef struct _USER_OTHER_INFO {
    DWORD  alrtus_errcode;
    DWORD  alrtus_numstrings;
}USER_OTHER_INFO, *PUSER_OTHER_INFO, *LPUSER_OTHER_INFO;

//
// Special Values and Constants
//

//
// Name of mailslot to send alert notifications
//
#define ALERTER_MAILSLOT          L"\\\\.\\MAILSLOT\\Alerter"

//
// The following macro gives a pointer to the other_info data.
// It takes an alert structure and returns a pointer to structure
// beyond the standard portion.
//

#define ALERT_OTHER_INFO(x)    ((LPBYTE)(x) + sizeof(STD_ALERT))

//
// The following macro gives a pointer to the variable-length data.
// It takes a pointer to one of the other-info structs and returns a
// pointer to the variable data portion.
//

#define ALERT_VAR_DATA(p)      ((LPBYTE)(p) + sizeof(*p))

//
//      Names of standard Microsoft-defined alert events.
//

#define ALERT_PRINT_EVENT           L"PRINTING"
#define ALERT_MESSAGE_EVENT         L"MESSAGE"
#define ALERT_ERRORLOG_EVENT        L"ERRORLOG"
#define ALERT_ADMIN_EVENT           L"ADMIN"
#define ALERT_USER_EVENT            L"USER"

//
//      Bitmap masks for prjob_status field of PRINTJOB.
//

// 2-7 bits also used in device status

#define PRJOB_QSTATUS       0x3         // Bits 0,1
#define PRJOB_DEVSTATUS     0x1fc       // 2-8 bits
#define PRJOB_COMPLETE      0x4         // Bit 2
#define PRJOB_INTERV        0x8         // Bit 3
#define PRJOB_ERROR         0x10        // Bit 4
#define PRJOB_DESTOFFLINE   0x20        // Bit 5
#define PRJOB_DESTPAUSED    0x40        // Bit 6
#define PRJOB_NOTIFY        0x80        // BIT 7
#define PRJOB_DESTNOPAPER   0x100       // BIT 8
#define PRJOB_DELETED       0x8000      // BIT 15

//
//      Values of PRJOB_QSTATUS bits in prjob_status field of PRINTJOB.
//

#define PRJOB_QS_QUEUED                 0
#define PRJOB_QS_PAUSED                 1
#define PRJOB_QS_SPOOLING               2
#define PRJOB_QS_PRINTING               3


#ifdef __cplusplus
}
#endif

#endif // _ALERT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    lmat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the schedule service API-s.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

--*/

#ifndef _LMAT_
#define _LMAT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following bits are used with Flags field in structures below.
//

//
//  Do we exec programs for this job periodically (/EVERY switch)
//  or one time (/NEXT switch).
//
#define JOB_RUN_PERIODICALLY            0x01    //  set if EVERY


//
//  Was there an error last time we tried to exec a program on behalf of
//  this job.
//  This flag is meaningfull on output only!
//
#define JOB_EXEC_ERROR                  0x02    //  set if error

//
//  Will this job run today or tomorrow.
//  This flag is meaningfull on output only!
//
#define JOB_RUNS_TODAY                  0x04    //  set if today

//
//  Add current day of the month to DaysOfMonth input.
//  This flag is meaningfull on input only!
//
#define JOB_ADD_CURRENT_DATE            0x08    // set if to add current date


//
//  Will this job be run interactively or not.  Windows NT 3.1 do not
//  know about this bit, i.e. they submit interactive jobs only.
//
#define JOB_NONINTERACTIVE              0x10    // set for noninteractive


#define JOB_INPUT_FLAGS     (   JOB_RUN_PERIODICALLY        |   \
                                JOB_ADD_CURRENT_DATE        |   \
                                JOB_NONINTERACTIVE  )

#define JOB_OUTPUT_FLAGS    (   JOB_RUN_PERIODICALLY        |   \
                                JOB_EXEC_ERROR              |   \
                                JOB_RUNS_TODAY              |   \
                                JOB_NONINTERACTIVE  )



typedef struct _AT_INFO {
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_INFO, *PAT_INFO, *LPAT_INFO;

typedef struct _AT_ENUM {
    DWORD   JobId;
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_ENUM, *PAT_ENUM, *LPAT_ENUM;

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAdd(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobDel(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnum(
    IN      LPCWSTR         Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfo(
    IN      LPCWSTR         Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMAPIbuf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmapibuf.h

Abstract:

    This file contains information about NetApiBuffer APIs.

Environment:

    User Mode - Win32

Notes:

    You must include LMCONS.H before this file, since this file depends
    on values defined in LMCONS.H.

--*/

#ifndef _LMAPIBUF_
#define _LMAPIBUF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    );


//
// The following private function will go away eventually.
// Call NetApiBufferAllocate instead.
//
NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (                 // Internal Function
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAPIBUF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\kxamd64.inc ===
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Module:
;
;   kxamd64.w
;
; Astract:
;
;   Contains AMD64 architecture constants and assembly macros.
;
;
;--

include macamd64.inc

;
; Define macro to clear legacy floating exceptions.
;

clfpex  macro

        db      0dbh, 0e2h

        endm

;
; Define macro to perform an enlightened yield.
;
; Arguments:
;
;   None.
;
; N.B. This macro is restricted to only freely using the register specified by
;      the 'Register' parameter and rcx. 'Register' should be nonvolatile.
;

EnlightenedYield macro Register

        local skip

ifnb <Register>

        inc     Register                ; increment counter and test
        test    HvlLongSpinCountMask, Register
        jnz     short skip              ; max count not hit, yield
        test    HvlEnlightenments, HV_KE_USE_HYPERCALL_FOR_LONG_SPIN_WAIT
        jz      short skip              ; long spin not enlightened, yield
        mov     ecx, Register           ; prepare argument
        call    HvlNotifyLongSpinWait   ; issue the hypercall

endif

skip:   Yield

        endm

;
; Define macro to acquire spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro is restricted to only freely using the register specified by
;      the 'Register' parameter and rcx. 'Register' should be nonvolatile.
;
; N.B. If 'Register' is specified, 'Address' must be nonvolatile or global.
;

AcquireSpinLock macro Address, Register

        local exit, spin

ifndef NT_UP

   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jnc     short exit              ; if nc, spin lock acquired

ifnb <Register>

        xor     Register, Register      ; initialize spin count

endif

spin:   EnlightenedYield <Register>     ; yield execution
        test    qword ptr Address, 1    ; check if lock currently owned
        jnz     short spin              ; if nz, spin lock owned
   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jc      short spin              ; if c, spin lock owned

exit:                                   ; continue

endif

        endm

;
; Define macro to acquire spin lock and mask interrupts.
;
; Arguments:
;
;   None.
;
; Note:
;
;   rsp is assumed to point to pushed EFLAGS
;
; N.B. This macro uses no registers.
;

AcquireSpinLockDisable macro Address

        local exit, spin, spin1

        cli                             ; disable interrupts

ifndef NT_UP

   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jnc     short exit              ; if nc, spin lock acquired
spin:   test    dword ptr [rsp], EFLAGS_IF_MASK ; test if interrupts enabled
        jz      short spin1             ; if z, interrupts disabled
        sti                             ; enable interrupts

spin1:  Yield                           ; yield execution

        test    qword ptr Address, 1    ; check if lock currently owned
        jnz     short spin1             ; if nz, spin lock owned
        cli                             ; lock is (was) clear, disable ints
   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jc      short spin              ; if c, spin lock owned
exit:                                   ; continue

endif

        endm

;
; Define macro to release spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro uses no registers.
;

ReleaseSpinLock macro Address

ifndef NT_UP

   lock and     qword ptr Address, 0    ; release spin lock

endif

        endm

;
; Define macro to release spin lock and restore the interrupt flag.
;
; Arguments:
;
;   None.
;
; Note:
;
;   rsp is assumed to point to pushd EFLAGS
;
; N.B. This macro uses no registers.
;

ReleaseSpinLockEnable macro Address

        local exit

ifndef NT_UP

   lock and     qword ptr Address, 0    ; release spin lock

endif

        test    dword ptr [rsp], EFLAGS_IF_MASK ; test if interrupts enabled
        jz      short exit              ; if z, interrupts not enabled
        sti                             ; enable interrupts
exit:                                   ; continue

        endm

;
; Define macro to try to acquire spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro uses no registers.
;

TryToAcquireSpinLock macro Address

ifndef NT_UP

        lock bts qword ptr Address, 0   ; attempt to acquire spin lock

endif

        endm

;
; Define macro to perform the equivalent of reading cr8.
;
; Arguments:
;
;   None
;
; The equivalent of the contents of cr8 is returned in rax
;
; N.B. This macro is restricted to using only rax.
;

ReadCr8 macro

        mov     rax, cr8                ; read IRQL

        endm

;
; Define macro to perform the equivalent of writing cr8.
;
; Arguments:
;
;   rcx - The desired value of cr8.
;

WriteCr8 macro

        mov     cr8, rcx                ; write IRQL

        endm

;
; Define macro to get current IRQL.
;
; Arguments:
;
;   None.
;
; The previous IRQL is returned in rax.
;

CurrentIrql macro

        ReadCr8                         ; get current IRQL

        endm

;
; Define macro to lower IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; N.B. The register rax is destroyed.
;
; N.B. This macro is restricted to using only rcx and rdx.
;

LowerIrql macro

        local   exit

if DBG

        mov     rdx, rax                ; preserve rax
        ReadCr8                         ; get current IRQL
        cmp     eax, ecx                ; check new IRQL
        jge     short exit              ; if ge, new IRQL okay
        int     3                       ; break into debugger
exit:   mov     rax, rdx

endif

        WriteCr8                        ; set new IRQL

        endm

;
; Define macro to raise IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; The previous IRQL is returned in rax.
;
; N.B. This macro is restricted to using only rax and rcx.
;

RaiseIrql macro

        local   exit

        ReadCr8                         ; get current IRQL

if DBG

        cmp     eax, ecx                ; check new IRQL
        jle     short exit              ; if le, new IRQL okay
        int     3                       ; break into debugger

endif

exit:   WriteCr8                        ; set new IRQL

        endm

;
; Define macro to set IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; N.B. This macro is restricted to using only rcx.
;

SetIrql macro

        WriteCr8                        ; set new IRQL

        endm

;
; Define macro to swap IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; The previous IRQL is returned in rax.
;
; N.B. This macro is restricted to using only rax and rcx.
;

SwapIrql macro

        ReadCr8                         ; get current IRQL
        WriteCr8                        ; set new IRQL

        endm

;
; Define end system interrupt macro.
;
; Arguments:
;
;   None.
;
; N.B. Any violatile registers used in this routine must be preserved. This
;      macro is used by APC/DPC interrupt handler which may not save the
;      machine state. HalPerformEndOfInterrupt is responsible for preserving
;      all the violatile registers it uses.
;

EndSystemInterrupt macro

        push    rcx
        mov     rcx, __imp_HalPerformEndOfInterrupt
        call    qword ptr [rcx]
        pop     rcx

        endm

;
; Define restore exception state macro.
;
;   This macro restores the nonvolatile state.
;
; Arguments:
;
;   Flag - If blank, then nonvolatile floating and integer registers are
;       restored. If nonblank and identical to "Rbp", then rbp is restored
;       in addition to the nonvolatile floating and integer registers. If
;       nonblank and identical to "NoFp", then only the nonvolatile integer
;       registers are restored.
;
; Implicit arguments:
;
;   rsp - Supplies the address of the exception frame.
;

RESTORE_EXCEPTION_STATE macro Flag

        lea     rcx, 100h[rsp]          ; set frame display pointer

ifdif <Flag>, <NoFp>

        movaps  xmm6, ExXmm6[rsp]       ; restore nonvolatile xmm registers
        movaps  xmm7, ExXmm7[rsp]       ;
        movaps  xmm8, ExXmm8[rsp]       ;
        movaps  xmm9, ExXmm9[rsp]       ;
        movaps  xmm10, ExXmm10[rsp]     ;
        movaps  xmm11, (ExXmm11 - 100h)[rcx] ;
        movaps  xmm12, (ExXmm12 - 100h)[rcx] ;
        movaps  xmm13, (ExXmm13 - 100h)[rcx] ;
        movaps  xmm14, (ExXmm14 - 100h)[rcx] ;
        movaps  xmm15, (ExXmm15 - 100h)[rcx] ;

endif

        mov     rbx, (ExRbx - 100h)[rcx] ; restore nonvolatile integer registers
        mov     rdi, (ExRdi - 100h)[rcx] ;
        mov     rsi, (ExRsi - 100h)[rcx] ;
        mov     r12, (ExR12 - 100h)[rcx] ;
        mov     r13, (ExR13 - 100h)[rcx] ;
        mov     r14, (ExR14 - 100h)[rcx] ;
        mov     r15, (ExR15 - 100h)[rcx] ;

ifdif <Flag>, <NoPop>

ifidn <Flag>, <Rbp>

        mov     rbp, (ExRbp - 100h)[rcx]  ; restore nonvolatile integer register

endif

        add     rsp, KEXCEPTION_FRAME_LENGTH - (1 * 8) ; deallocate frame

endif

        endm

;
; Define generate exception frame macro.
;
;   This macro allocates an exception frame and saves the nonvolatile state.
;
; Arguments:
;
;   Flag - If blank, then nonvolatile floating and integer registers are
;       saved. If nonblank and identical to "Rbp", then rbp is saved in
;       addition to the nonvolatile floating and integer registers. If
;       nonblank and identical to "NoFp", then only the nonvolatile integer
;       registers are saved. If nonblank and identical to "NoPop", then
;       allocate an exception record in addition to an exception frame.
;
; Implicit arguments:
;
;   The top of the stack is assumed to contain a return address.
;

GENERATE_EXCEPTION_FRAME macro Flag


ifidn <Flag>, <NoPop>

        alloc_stack (EXCEPTION_RECORD_LENGTH + KEXCEPTION_FRAME_LENGTH - (1 * 8)) ; allocate frame

else

        alloc_stack (KEXCEPTION_FRAME_LENGTH - (1 * 8)) ; allocate frame

endif

        lea     rax, 100h[rsp]          ; set frame display pointer

ifdif <Flag>, <NoFp>

        save_xmm128 xmm6, ExXmm6        ; save xmm nonvolatile registers
        save_xmm128 xmm7, ExXmm7        ;
        save_xmm128 xmm8, ExXmm8        ;
        save_xmm128 xmm9, ExXmm9        ;
        save_xmm128 xmm10, ExXmm10      ;

        movaps  (ExXmm11 - 100h)[rax], xmm11 ;
        .savexmm128 xmm11, ExXmm11      ;

        movaps  (ExXmm12 - 100h)[rax], xmm12 ;
        .savexmm128 xmm12, ExXmm12      ;

        movaps  (ExXmm13 - 100h)[rax], xmm13 ;
        .savexmm128 xmm13, ExXmm13      ;

        movaps  (ExXmm14 - 100h)[rax], xmm14 ;
        .savexmm128 xmm14, ExXmm14      ;

        movaps  (ExXmm15 - 100h)[rax], xmm15 ;
        .savexmm128 xmm15, ExXmm15      ;

endif

ifidn <Flag>, <Rbp>

        mov     (ExRbp - 100h)[rax], rbp  ; save nonvolatile integer register
        .savereg rbp, ExRbp             ;
        set_frame rbp, 0                ; set frame pointer

endif

        mov     (ExRbx - 100h)[rax], rbx  ;
        .savereg rbx, ExRbx             ;

        mov     (ExRdi - 100h)[rax], rdi  ;
        .savereg rdi, ExRdi             ;

        mov     (ExRsi - 100h)[rax], rsi  ;
        .savereg rsi, ExRsi             ;

        mov     (ExR12 - 100h)[rax], r12  ;
        .savereg r12, ExR12             ;

        mov     (ExR13 - 100h)[rax], r13  ;
        .savereg r13, ExR13             ;

        mov     (ExR14 - 100h)[rax], r14  ;
        .savereg r14, ExR14             ;

        mov     (ExR15 - 100h)[rax], r15  ;
        .savereg r15, ExR15             ;

        END_PROLOGUE

        endm

;
; Define the instrumentation return macro.
;
;   This macro determines whether an instrumentation callback is enabled for this
;   thread's process.  If it is, then the return address in the trap frame is
;   replaced with the instrumentation callback address, and r10 is used to
;   indicate the actual return address.
;
; Arguments:
;
;   None
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame
;

SETUP_FOR_INSTRUMENTATION_RETURN macro

        local   exit

        mov     rax, gs:[PcCurrentThread]           ; get current thread address
        mov     rax, ThApcState + AsProcess[rax]    ; get current process
        mov     rax, PrInstrumentationCallback[rax] ; get callback address
        or      rax, rax                            ; check if non-null
        jz      exit                                ; if z, it is null

        cmp     word ptr TrSegCs[rbp], (KGDT64_R3_CODE or RPL_MASK) ; check for 64-bit mode
        jne     exit

        mov     r10, TrRip[rbp]                     ; r10 = original address
        mov     TrRip[rbp], rax                     ; return to callback address
exit:

        endm

;
; Define restore trap state macro.
;
;   This macro restores the volatile state, and if necessary, restores the
;   user debug state, deallocats the trap frame, and exits the trap.
;
;   N.B. This macro must preserve eax in case it is not reloaded from the
;        trap frame.
;
; Arguments:
;
;   State - Determines what state is restored and what tests are made. Valid
;       values are:
;
;           Service - restore state for a service executed from user mode.
;           Kernel - restore state for a service executed from kernel mode.
;           Volatile - restore state for a trap or interrupt.
;
;   Disable - If blank, then disable interrupts.
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame.
;

RESTORE_TRAP_STATE macro State, Disable, NmiFlag, LBranch

        local   first, second, third, fourth

ifb <Disable>

        cli                             ; disable interrupts

endif

ifdif <State>, <Kernel>

;
; State is either <Volatile> or <Service>
;

ifidn <State>, <Volatile>

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      fourth                  ; if z, previous mode not user

endif

ifdif <NmiFlag>, <Nmi>

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThApcState + AsUserApcPending[rcx], 0 ; APC pending?
        je      short first             ; if e, no user APC pending

endif

ifidn <State>, <Service>

        mov     TrRax[rbp], rax         ; save service status
        xor     eax, eax                ; scrub volatile integer registers in the trap frame
        mov     TrRcx[rbp], rax         ;
        mov     TrRdx[rbp], rax         ;
        mov     TrR8[rbp], rax          ;
        mov     TrR9[rbp], rax          ;
        mov     TrR10[rbp], rax         ;
        mov     TrR11[rbp], rax         ;
        pxor    xmm0, xmm0              ; scrub volatile floating registers in the trap frame
        movaps  TrXmm0[rbp], xmm0       ;
        movaps  TrXmm1[rbp], xmm0       ;
        movaps  TrXmm2[rbp], xmm0       ;
        movaps  TrXmm3[rbp], xmm0       ;
        movaps  TrXmm4[rbp], xmm0       ;
        movaps  TrXmm5[rbp], xmm0       ;

endif

ifdif <NmiFlag>, <Nmi>

        mov     ecx, APC_LEVEL          ; get APC level

        SetIrql                         ; set IRQL to APC level

        sti                             ; allow interrupts
        call    KiInitiateUserApc       ; initiate APC execution
        cli                             ; disable interrupts
        mov     ecx, PASSIVE_LEVEL      ; get PASSIVE level

        SetIrql                         ; set IRQL to PASSIVE level

endif

ifidn <State>, <Service>

        mov     rax, TrRax[rbp]         ; restore service status

endif

first:

;
; Check if the thread is a Scheduled UMS Thread or profiling is active.
;

ifdif <NmiFlag>, <Nmi>
        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        test    dword ptr ThLock[rcx], DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK or THREAD_FLAGS_CYCLE_PROFILING_LOCK
        jz      short second            ; if z, profiling and UMS are not enabled

ifidn <State>, <Service>
        mov     TrRax[rbp], rax         ; save service status
endif

        test    byte ptr ThThreadControlFlags[rcx], THREAD_FLAGS_CYCLE_PROFILING ; check for profiling
        jz      short @f                ; if z, profiling is not enabled
        call    KiCopyCounters
        mov     rcx, gs:[PcCurrentThread] ; reload current thread address
@@:
        test    byte ptr ThDebugActive[rcx], DEBUG_ACTIVE_SCHEDULED_THREAD    ; Is thread a KT/UMS thread?
        jz      short @f                ; if z, thread is not ums scheduled thread.
        lea     rsp, (-128)[rbp]        ; set the stack to top of returning trap frame

ifidn <State>, <Service>

        xor     rcx, rcx

else

        .errnz  (KUMS_UCH_VOLATILE_MASK AND 0FFFFFFFFFFFFFF00h)

        mov     cl, KUMS_UCH_VOLATILE_MASK
endif
        call    KiUmsExit
@@:

ifidn <State>, <Service>

        mov     rax, TrRax[rbp]         ; restore service status

endif

second:

endif

        ldmxcsr TrMxCsr[rbp]            ; restore XMM control/status

ifidn <State>, <Service>

        xor     r10, r10                ; scrub volatile integer register

endif

        cmp     word ptr TrDr7[rbp],  0 ; test if debug active
        jz      short third             ; if z, debug not active

ifidn <State>, <Service>

        mov     TrRax[rbp], rax         ; save service status

endif

        call    KiRestoreDebugRegisterState ; restore user debug register state

ifidn <State>, <Service>

        SETUP_FOR_INSTRUMENTATION_RETURN

        mov     rax, TrRax[rbp]         ; restore service status
endif

third:                                  ;

;
; At this point it is known that the return will be to user mode.
;

ifidn <State>, <Volatile>

        movaps  xmm0, TrXmm0[rbp]       ; restore volatile XMM registers
        movaps  xmm1, TrXmm1[rbp]       ;
        movaps  xmm2, TrXmm2[rbp]       ;
        movaps  xmm3, TrXmm3[rbp]       ;
        movaps  xmm4, TrXmm4[rbp]       ;
        movaps  xmm5, TrXmm5[rbp]       ;

        mov     r11, TrR11[rbp]         ; restore volatile integer state
        mov     r10, TrR10[rbp]         ;
        mov     r9, TrR9[rbp]           ;
        mov     r8, TrR8[rbp]           ;

ifnb <LBranch>

        mov     ecx, TrLastBranchMSR[rbp] ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        mov     eax, TrLastBranchControl[rbp] ; write last branch control register
        mov     edx, TrLastBranchControl + 4[rbp] ;
        wrmsr                           ;
@@:                                     ;

endif

        mov     rdx, TrRdx[rbp]         ;
        mov     rcx, TrRcx[rbp]         ;
        mov     rax, TrRax[rbp]         ;
        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        add     rsp, (KTRAP_FRAME_LENGTH - (5 * 8) - 128) ; deallocate stack
        swapgs                          ; swap GS base to user mode TEB
        iretq                           ;

else

        mov     r8, TrRsp[rbp]          ; get previous RSP value
        mov     r9, TrRbp[rbp]          ; get previous RBP value
        xor     edx, edx                ; scrub volatile integer registers
        pxor    xmm0, xmm0              ; scrub volatile floating registers
        pxor    xmm1, xmm1              ;
        pxor    xmm2, xmm2              ;
        pxor    xmm3, xmm3              ;
        pxor    xmm4, xmm4              ;
        pxor    xmm5, xmm5              ;
        mov     rcx, TrRip[rbp]         ; get return address
        mov     r11, TrEFlags[rbp]      ; get previous EFLAGS
        mov     rbp, r9                 ; restore RBP
        mov     rsp, r8                 ; restore RSP
        swapgs                          ; swap GS base to user mode TEB
        sysretq                         ; return from system call to user mode

endif

ifidn <State>, <Volatile>

fourth: ldmxcsr TrMxCsr[rbp]            ; restore XMM control/status
        movaps  xmm0, TrXmm0[rbp]       ; restore volatile XMM registers
        movaps  xmm1, TrXmm1[rbp]       ;
        movaps  xmm2, TrXmm2[rbp]       ;
        movaps  xmm3, TrXmm3[rbp]       ;
        movaps  xmm4, TrXmm4[rbp]       ;
        movaps  xmm5, TrXmm5[rbp]       ;

ifidn <NmiFlag>, <Nmi>

        mov     eax, TrGsBase[rbp]      ; restore GS base MSR
        mov     edx, TrGsBase + 4[rbp]  ;
        mov     ecx, MSR_GS_BASE        ;
        wrmsr                           ;
        mov     rax, TrFaultAddress[rbp] ; restore CR2
        mov     cr2, rax                ;

endif

        mov     r11, TrR11[rbp]         ; restore volatile integer state
        mov     r10, TrR10[rbp]         ;
        mov     r9, TrR9[rbp]           ;
        mov     r8, TrR8[rbp]           ;

ifnb <LBranch>

        mov     ecx, TrLastBranchMSR[rbp] ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        mov     eax, TrLastBranchControl[rbp] ; write last branch control register
        mov     edx, TrLastBranchControl + 4[rbp] ;
        wrmsr                           ;
@@:                                     ;

endif

        mov     rdx, TrRdx[rbp]         ;
        mov     rcx, TrRcx[rbp]         ;
        mov     rax, TrRax[rbp]         ;
        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        add     rsp, (KTRAP_FRAME_LENGTH - (5 * 8) - 128) ; deallocate stack
        iretq                           ;

endif

;
; State is kernel mode.
;

else

        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        mov     rsp, TrRsp[rsp]         ; restore RSP
        sti                             ; enable interrupts
        ret                             ; return from system call to kernel mode

endif

        endm

;
; Define User Mode Scheduling information generation macro.
;
;   This macro detects whether the current thread participates in User Mode
;   scheduling and has entered the kernel on behalf of another user mode
;   thread.
;
;   Registers RAX, RCX, and RDX should be avaialable for consumption by this
;   macro.
;
; Arguments:
;
;   SaveGSSwap - If non-blank, then the GS Swap MSR contents are available in
;       EAX:EDX.
;
;   Thread - Supplies the register containing the current thread.
;
;   SkipLabel - Supplies a skip label if the indicated thread is not a primary.
;

PREPARE_UMS_DIRECTED_SWITCH macro SaveGSSwap, Thread, SkipLabel

        local   first

        test    byte ptr ThDebugActive[Thread], DEBUG_ACTIVE_PRIMARY_THREAD

ifnb <SkipLabel>

        jz      short SkipLabel         ; not a primary, jump to target

else

        jz      short first             ; not a primary, exit

endif

;
; If GS swap save is set, the EAX:EDX pair contains the TEB.
;

ifb <SaveGSSwap>

        mov     ecx, MSR_GS_SWAP        ; set GS swap MSR number
        rdmsr                           ; read MSR

endif

        shl     rdx, 32                 ; shift high bits
        or      rax, rdx                ; merge value to form full TEB value
        cmp     qword ptr ThTeb[Thread], rax ; check if TEB matches

ifnb <SkipLabel>

        jz      short SkipLabel         ; match, not a directed switch

else

        jz      short first             ; match, not a directed switch

endif

        cmp     qword ptr ThTebMappedLowVa[Thread], rax ; check if low TEB matches

ifnb <SkipLabel>

        jz      short SkipLabel         ; match, not a directed switch

else

        jz      short first             ; match, not a directed switch

endif

;
; This thread will attempt to perform a directed switch. Until it reaches the
; control transfer point disable normal kernel apcs (e.g. suspend) as the
; backing UMS KT may attempt to synchronize with this thread.
;

        mov     rdx, ThUcb[Thread]      ; load UMS control block
        bts     dword ptr ThMiscFlags[Thread], KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT
        dec     word ptr ThKernelApcDisable[Thread] ; disable normal APCs
        mov     UcbUmsTeb[rdx], rax     ; save into UCB storage slot

first:

        endm


;
; Define save trap state macro.
;
;   This macro saves the volatile state, and if necessary, saves the user
;   debug state and loads the kernel debug state.
;
; Arguments:
;
;   SaveGSSwap - If non-blank, then save the GS swap register if the previous
;       mode is user.
;
; Implicit arguments:
;
;    rbp - Supplies the address of the trap frame.
;

SAVE_TRAP_STATE macro Service, SaveGSSwap, NmiFlag, LBranch, PrepareUms

        local   first, second

        mov     TrRax[rbp], rax         ; save volatile integer registers
        mov     TrRcx[rbp], rcx         ;
        mov     TrRdx[rbp], rdx         ;

ifnb <LBranch>

        mov     ecx, KeLastBranchMSR    ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        rdmsr                           ; read last branch control register
        mov     TrLastBranchControl[rbp], eax ; save last branch control
        mov     TrLastBranchControl + 4[rbp], edx ;
        btr     eax, 0                  ; clear bit 0 in last branch control
        wrmsr                           ; disable last branch recording
@@:     mov     TrLastBranchMSR[rbp], ecx ; save last branch MSR number

endif

        mov     TrR8[rbp], r8           ;
        mov     TrR9[rbp], r9           ;
        mov     TrR10[rbp], r10         ;
        mov     TrR11[rbp], r11         ;

ifidn <NmiFlag>, <Nmi>

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jnz     short second            ; if nz, previous mode user

;
; Preserve the current GS base in the trap frame.
;

        mov     ecx, MSR_GS_BASE        ; save GS base MSR in trap frame
        rdmsr                           ;
        mov     TrGsBase[rbp], eax      ;
        mov     TrGsBase + 4[rbp], edx  ;

;
; Load the correct kernel GS base.
;

        lea     rcx, KiProcessorBlock   ; get processor block array address
        lea     rdx, KiProcessorNumberToIndexMappingTable ; get mapping table
        mov     eax, KGDT64_R3_CMTEB    ; set selector number
        lsl     eax, eax                ; load segment limit
        mov     r8d, eax                ; make a copy of segment limit
        and     r8d, 3ffh               ; get group number
        shl     r8d, 6                  ; shift the group number by 6 bits
        shr     eax, 14                 ; extract processor number
        or      eax, r8d                ; get the index to the mapping table
        mov     eax, [rdx + rax * 4]    ; processor index
        mov     rdx, [rcx + rax * 8]    ; get current PRCB address
        sub     rdx, PcPrcb             ; compute current PCR address
        mov     eax, edx                ; set current GS base MSR
        shr     rdx, 32                 ;
        mov     ecx, MSR_GS_BASE        ;
        wrmsr                           ;

;
; Preserve CR2 in the trap frame.
;

        mov     rax, cr2                ; save CR2 in trap frame
        mov     TrFaultAddress[rbp], rax ;
        jmp     short first             ;

second:

else

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short first             ; if z, previous mode kernel

endif

        swapgs                          ; swap GS base to kernel mode PCR
        mov     r10, gs:[PcCurrentThread] ; get current thread address

ifnb <SaveGSSwap>

        cmp     word ptr TrSegCs[rbp], (KGDT64_R3_CODE or RPL_MASK) ; check for 64-bit mode
        jne     short @f                ; if ne, not running in 64-bit mode
        mov     ecx, MSR_GS_SWAP        ; set GS swap MSR number
        rdmsr                           ; read GS swap MSR
        mov     TrGsSwap[rbp], eax      ; save GS swap MSR
        mov     TrGsSwap + 4[rbp], edx  ;

endif

ifnb <PrepareUms>

        PREPARE_UMS_DIRECTED_SWITCH <SaveGSSwap>, r10

endif

@@:

        test    byte ptr ThDebugActive[r10], DEBUG_ACTIVE_DBG_INSTRUMENTED ; test if debug enabled
        mov     word ptr TrDr7[rbp], 0  ; assume debug not enabled
        jz      short first             ; if e, debug/instrumentation not enabled
        call    KiSaveDebugRegisterState ; save debug register state
first:  cld                             ; clear direction flag
        stmxcsr TrMxCsr[rbp]            ; save XMM control/status
        ldmxcsr dword ptr gs:[PcMxCsr]  ; set default XMM control/status
        movaps  TrXmm0[rbp], xmm0       ; save volatile xmm registers
        movaps  TrXmm1[rbp], xmm1       ;
        movaps  TrXmm2[rbp], xmm2       ;
        movaps  TrXmm3[rbp], xmm3       ;
        movaps  TrXmm4[rbp], xmm4       ;
        movaps  TrXmm5[rbp], xmm5       ;

        endm

;
; Define interrupt frame generation macro.
;
;   This macro generates an interrupt frame.
;
; Arguments:
;
;   Vector - If non-blank, then the vector number is on the stack.
;
;   Direct - If non-blank, then the interrupt is directly connected.
;
; Return value:
;
;   If Vector is non-blank, then the value of the vector is returned in eax.
;
; Note: Trap and interrupt frames are exempt from the "first instruction must
;       be two bytes" rule.
;

GENERATE_INTERRUPT_FRAME macro Vector, Direct, NmiFlag, LBranch

        extern  KiInterlockedPopEntrySListEndEntryPoint:qword
        extern  KiInterlockedPopEntrySListResumeEntryPoint:qword
        extern  KiCheckForSListAddress:proc

;
; At this point the hardware frame has been pushed onto an aligned stack. The
; vector number or a dummy vector number and rbp have also been pushed on the
; stack.
;

ifb <Direct>

        push_reg rsi                    ; save nonvolatile register
        alloc_stack (KTRAP_FRAME_LENGTH - (8 * 8)) ; allocate fixed frame
        mov     rsi, rbp                ; set address of interrupt object

else

        alloc_stack (KTRAP_FRAME_LENGTH - (8 * 7)) ; allocate fixed frame

endif

        set_frame rbp, 128              ; set frame pointer

        END_PROLOGUE

        mov     byte ptr TrExceptionActive[rbp], 0 ; set interrupt active

        SAVE_TRAP_STATE <>, <>, <NmiFlag>, <LBranch> ; save trap state

;
; Check if a kernel-mode SLIST pop operation is being interrupted and reset
; RIP as necessary.
;

ifdifi <Direct>, <DirectNoSListCheck>

        mov     rax, KiInterlockedPopEntrySListResumeEntryPoint ; get SLIST resume address
        cmp     rax, TrRip[rbp]         ; check resume address is above RIP
        jae     short not_slist         ; if ae, resume address above RIP
        mov     rax, KiInterlockedPopEntrySListEndEntryPoint ; get SLIST end address
        cmp     rax, TrRip[rbp]         ; check end address is below RIP
        jb      short not_slist         ; if b, end address below RIP
        lea     rcx, (-128)[rbp]        ; set trap frame address
        call    KiCheckForSListAddress  ; check RIP and reset if necessary
not_slist:                              ;

endif

ifnb <Vector>

        mov     eax, TrErrorCode[rbp]   ; return vector number

endif

        inc     dword ptr gs:[PcInterruptCount] ; increment interrupt count

        endm

;
; Define enter interrupt macro.
;
;   This macro raises IRQL, sets the interrupt flag, records the previous
;   IRQL in the trap frame, and invokes the HAL to perform an EOI.
;
; Arguments:
;
;   NoEOI - If blank, then generate end of interrupt.
;
;   NoCount - If blank, then increment nesting level.
;
; Implicit arguments:
;
;   rcx - Supplies the interrupt IRQL.
;
;   rbp - Supplies the address of the trap frame.
;
;   Interrupt flag is clear.
;
; Return Value:
;
;   None.
;

ENTER_INTERRUPT macro NoEOI, NoCount, NmiFlag

        local   exit

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;
;
; N.B. Raise IRQL cannot be used below since this macro is used in the NMI
;      handler and would trigger a false assert.
;

        SwapIrql                        ; raise IRQL to interrupt level

        mov     TrPreviousIrql[rbp], al ; save previous IRQL

ifb <NoCount>

        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        inc     byte ptr PbNestingLevel[rcx] ; increment nesting level
        cmp     byte ptr PbNestingLevel[rcx], 1 ; check if thread time
        jne     short exit              ; if ne, not thread time
        mov     r8, PbCurrentThread[rcx] ; get current thread address
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        sub     rax, PbStartCycles[rcx] ; compute total cycles for period
        add     ThCycleTime[r8], rax    ; accumulate cycles
        add     PbStartCycles[rcx], rax ; compute start of next period
        test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_ACCOUNTING_ANY ; check for throttle or profiling
        jz      short exit              ; if z, not active
        test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_CPU_THROTTLED ; check for throttle
        jz      @f                      ; if z, throttling not active
        mov     rdx, rax                ; set total cycles for period
        call    PsChargeProcessCpuCycles ; charge CPU cycles
        mov     r8, gs:[PcCurrentThread] ; reload current thread address
@@:     test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_COUNTER_PROFILING ; check for profiling
        jz      short exit              ; if z, counter is enabled
        mov     rcx, r8                 ; set current thread address
        call    KiEndCounterAccumulation ;
exit:                                   ;

endif

ifb <NoEOI>

        EndSystemInterrupt              ; perform EOI

endif

ifdif <NmiFlag>, <Nmi>

        sti                             ; enable interrupts

endif

        endm

;
; Define exit interrupt macro.
;
;   This macro exits an interrupt.
;
; Arguments:
;
;   NoEOI - If blank, then generate end of interrupt.
;
;   NoCount - If blank, then decrement nesting level.
;
;   Direct - If non-blank, then the interrupt is directly connected.
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame.
;
; Return Value:
;
;   None.
;

EXIT_INTERRUPT macro NoEOI, NoCount, Direct, NmiFlag, LBranch

        local   decrement, exit, request

        cli                             ; disable interrupts

ifb <NoEOI>

        EndSystemInterrupt              ; perform EOI

endif

ifb <NoCount>

        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        cmp     byte ptr PbNestingLevel[rcx], 1 ; check if ending processor time
        ja      short decrement         ; if nz, more interrupts nested
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        sub     rax, PbStartCycles[rcx] ; compute total cycles for period
        add     PbCycleTime[rcx], rax   ; accumulate cycles
        add     PbStartCycles[rcx], rax ; compute start of next period
        mov     rax, PbCurrentThread[rcx] ; get current thread address
        test    byte ptr ThThreadControlFlags[rax], THREAD_FLAGS_COUNTER_PROFILING ; check for counters
        jz      short @f                ; if z, counter is not enabled
        setz    dl                      ; set call from context switch to FALSE
        mov     rcx, rax                ; set current thread address
        call    KiBeginCounterAccumulation ; call counter accumulation routine
        mov     rcx, gs:[PcCurrentPrcb] ; reload rcx
@@:     mov     dl, PbInterruptRequest[rcx] ; get interrupt request value
        and     byte ptr PbInterruptRequest[rcx], 0 ; clear interrupt request
        cmp     byte ptr PbIdleHalt[rcx], 0 ; check for idle halt interrupt
        jne     short decrement         ; if ne, interrupt from idle halt
        test    dl, dl                  ; test if dispatch interrupt request
        jz      short decrement         ; if z, no dispatch interrupt request
        cmp     byte ptr TrPreviousIrql[rbp], DISPATCH_LEVEL ; check for bypass
        jae     short request           ; if ae, bypass not possible
        and     byte ptr PbNestingLevel[rcx], 0 ; clear nesting level
        call    KiDpcInterruptBypass    ; bypass dispatch interrupt
        jmp     short exit              ; finish in common code

request:                                ;
        mov     ecx, DISPATCH_LEVEL     ; request dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        mov     rcx, gs:[PcCurrentPrcb] ; reload rcx

decrement:
        dec     byte ptr PbNestingLevel[rcx] ; decrement nesting level                                ;

exit:

endif

        movzx   ecx, byte ptr TrPreviousIrql[rbp] ; get previous IRQL

        SetIrql                         ; set IRQL to previous level

ifb <Direct>

        mov     rsi, TrRsi[rbp]         ; restore extra register

endif

        RESTORE_TRAP_STATE <Volatile>, <NoDisable>, <NmiFlag>, <LBranch> ; restore trap state

        endm

;
; Define trap frame generation macro.
;
;   This macro generates a trap frame.
;
; Arguments:
;
;   ErrorCode - If non-blank, then an error code is on the stack.
;
;   PatchCycle - If non-blank, then store the global patch cycle count in
;       the trap frame.
;
;   SaveGSSwap - If non-blank, then save the GS swap register if the previous
;       mode is user.
;
;   PrepareUms - If non-blank, then this trap entry point supports user mode
;       scheduling (UMS). Function must either always call KiExceptionDispatch
;       at some point or explicitly call KiUmsTrapEntry upfront if 
;       KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT is set.
;
; Return value:
;
;   If ErrorCode is non-blank, then the value of the error code is returned
;   in eax.
;
; Note: Trap and interrupt frames are exempt from the "first instruction must
;       be two bytes" rule.
;

GENERATE_TRAP_FRAME macro ErrorCode, PatchCycle, SaveGSSwap, PrepareUms

        local   exit

ifb <ErrorCode>

        push_frame                      ; mark machine frame without error code
        alloc_stack 8                   ; allocate dummy error code

else

ifidn <ErrorCode>, <MxCsr>

        push_frame                      ; mark machine frame without error code
        alloc_stack 8                   ; allocate dummy error code

else

        push_frame code                 ; mark machine frame with error code

endif

endif

        push_reg rbp                    ; save nonvolatile register
        alloc_stack (KTRAP_FRAME_LENGTH - (7 * 8)) ; allocate fixed frame
        set_frame rbp, 128              ; set frame pointer

        END_PROLOGUE

        mov     byte ptr TrExceptionActive[rbp], 1 ; set exception active

        SAVE_TRAP_STATE <>, <SaveGSSwap>, <>, <>, <PrepareUms> ; save trap state

ifnb <PatchCycle>

        mov     eax, KiCodePatchCycle   ; get current patch cycle count
        mov     TrCodePatchCycle[rbp], eax ; save patch cycle count

endif

ifnb <ErrorCode>

ifidn <ErrorCode>, <MxCsr>

        mov     ax, TrMxCsr[rbp]        ; return saved MXCSR

else

        mov     eax, TrErrorCode[rbp]   ; return error code

ifidn <ErrorCode>, <Virtual>

        mov     rcx, cr2                ; return virtual address

endif

endif

endif

;
; Enable interrupts if and only if they were enabled before the trap occurred.
; If the exception is not handled by the kernel debugger and interrupts were
; previously disabled, then a bug check will occur.
;

        test    qword ptr TrEFlags[rbp], EFLAGS_IF_MASK ; test if interrupt enabled
        jz      short exit              ; if z, interrupts not enabled
        sti                             ; enable interrupts
exit:                                   ; reference label

        endm

;
; Define kernel icecap macros for tracing assembly routines.
;

ifdef _CAPKERN

ifndef _ICECAP_ASM

        extern  __CAP_Start_Profiling:proc
        extern  __CAP_End_Profiling:proc

endif

;
; CAPSTART - Log a call-record.
;
; Both Caller and Callee are functions.
;
; __CAP_Start_Profiling does not use PxHome locations.
;

CAPSTART macro Caller, Callee

        push    rcx                     ; save volatile register
        lea     rcx, Callee             ; set address of callee
        call    __CAP_Start_Profiling   ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPSTART2 - Log a call-record.
;
; Caller is a function and Callee is a register or memory location.
;
; The reason for having CAPSTART2 is that AMD64 assembler does not
; allow "mov <register>, <function-name>" -- it only accepts "lea"
; for storing a function-pointer into a register (see above).
;
; __CAP_Start_Profiling does not use PxHome locations.
;

CAPSTART2 macro Caller, Callee

        push    rcx                     ; save volatile register
        mov     rcx, Callee             ; set address of callee
        call    __CAP_Start_Profiling   ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPEND - Log a return record.
;
; Caller is a function.
;
; __CAP_End_Profiling does not use PxHome locations.
;

CAPEND macro Caller

        push    rcx                     ; save volatile register
        call    __CAP_End_Profiling     ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPTRAP - Log a trap record.
;

CAPTRAP macro

        call    __CAP_Trap              ; record profile information

        endm

;
; CAPSYSTEMSERVICE - Log a system service record.
;

CAPSYSTEMSERVICE macro

        call    __CAP_SystemService     ; record profile information

        endm

else

CAPSTART macro Caller, Callee

        endm

CAPSTART2 macro Caller, Callee

        endm

CAPEND macro Caller

        endm

CAPTRAP macro

        endm

CAPSYSTEMSERVICE macro

        endm

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\kxia64.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects
*/
//++
//
// Module Name:
//
//  kxia64.h
//
// Abstract:
//
//  This module contains the nongenerated part of the IA64 assembler
//  header file. In general, it contains processor architecture constant
//  information, however some assembler macros are also included.
//
// Revision History:
//
//--

#define SHADOW_IRQL_IMPLEMENTATION 1

//
// N. B. Register aliases have been moved to ksia64.h (because we
// use assembler aliases not #define's)
//

// Register constants

// For setting non-rotating predicates (not used very much)

#define PS0 0x0001
#define PS1 0x0002
#define PS2 0x0004
#define PS3 0x0008
#define PS4 0x0010
#define PS5 0x0020

#define PRP 0x0080

#define PT0 0x0040
#define PT1 0x0100
#define PT2 0x0200
#define PT3 0x0400
#define PT4 0x0800
#define PT5 0x1000
#define PT6 0x2000
#define PT7 0x4000
#define PT8 0x8000

// For setting nomination register

#define NOM_BS0 0x0001
#define NOM_BS1 0x0002
#define NOM_BS2 0x0004
#define NOM_BS3 0x0008
#define NOM_BS4 0x0010
#define NOM_BS5 0x0020

#define NOM_BRP 0x0080

#define NOM_BT0 0x0040
#define NOM_BT1 0x0100
#define NOM_BT2 0x0200
#define NOM_BT3 0x0400
#define NOM_BT4 0x0800
#define NOM_BT5 0x1000
#define NOM_BT6 0x2000
#define NOM_BT7 0x4000
#define NOM_BT8 0x8000
//
//
// Define IA64 system registers.
//
// Define IA64 system register bit field offsets.
//
// Processor Status Register (PSR) Bit positions

// User / System mask
#define PSR_MBZ4    0
#define PSR_BE      1
#define PSR_UP      2
#define PSR_AC      3
#define PSR_MFL     4
#define PSR_MFH     5
// PSR bits 6-12 reserved (must be zero)
#define PSR_MBZ0    6
#define PSR_MBZ0_V  0x7fi64
// System only mask
#define PSR_IC      13
#define PSR_I       14
#define PSR_PK      15
#define PSR_MBZ1    16
#define PSR_MBZ1_V  0x1i64
#define PSR_DT      17
#define PSR_DFL     18
#define PSR_DFH     19
#define PSR_SP      20
#define PSR_PP      21
#define PSR_DI      22
#define PSR_SI      23
#define PSR_DB      24
#define PSR_LP      25
#define PSR_TB      26
#define PSR_RT      27
// PSR bits 28-31 reserved (must be zero)
#define PSR_MBZ2    28
#define PSR_MBZ2_V  0xfi64
// Neither mask
#define PSR_CPL     32
#define PSR_CPL_LEN 2
#define PSR_IS      34
#define PSR_MC      35
#define PSR_IT      36
#define PSR_ID      37
#define PSR_DA      38
#define PSR_DD      39
#define PSR_SS      40
#define PSR_RI      41
#define PSR_RI_LEN  2
#define PSR_ED      43
#define PSR_BN      44
#define PSR_IA      45
// PSR bits 46-63 reserved (must be zero)
#define PSR_MBZ3    46
#define PSR_MBZ3_V  0x3ffffi64

//
// Privilege levels
//

#define PL_KERNEL    0
#define PL_USER      3

//
// Instruction set (IS) bits
//

#define IS_EM        0
#define IS_IA        1

// Floating Point Status Register (FPSR) Bit positions

// Status Field 0 - Flags
#define FPSR_VD        0
#define FPSR_DD        1
#define FPSR_ZD        2
#define FPSR_OD        3
#define FPSR_UD        4
#define FPSR_ID        5
// Status Field 0 - Controls
#define FPSR_FTZ0      6
#define FPSR_WRE0      7
#define FPSR_PC0       8
#define FPSR_RC0       10
#define FPSR_TD0       12
// Status Field 0 - Flags
#define FPSR_V0        13
#define FPSR_D0        14
#define FPSR_Z0        15
#define FPSR_O0        16
#define FPSR_U0        17
#define FPSR_I0        18
// Status Field 1 - Controls
#define FPSR_FTZ1      19
#define FPSR_WRE1      20
#define FPSR_PC1       21
#define FPSR_RC1       23
#define FPSR_TD1       25
// Status Field 1 - Flags
#define FPSR_V1        26
#define FPSR_D1        27
#define FPSR_Z1        28
#define FPSR_O1        29
#define FPSR_U1        30
#define FPSR_I1        31
// Status Field 2 - Controls
#define FPSR_FTZ2      32
#define FPSR_WRE2      33
#define FPSR_PC2       34
#define FPSR_RC2       36
#define FPSR_TD2       38
// Status Field 2 - Flags
#define FPSR_V2        39
#define FPSR_D2        40
#define FPSR_Z2        41
#define FPSR_O2        42
#define FPSR_U2        43
#define FPSR_I2        44
// Status Field 3 - Controls
#define FPSR_FTZ3      45
#define FPSR_WRE3      46
#define FPSR_PC3       47
#define FPSR_RC3       49
#define FPSR_TD3       51
// Status Field 3 - Flags
#define FPSR_V3        52
#define FPSR_D3        53
#define FPSR_Z3        54
#define FPSR_O3        55
#define FPSR_U3        56
#define FPSR_I3        57
// FPSR bits 58-63 Reserved -- Must be zero
#define FPSR_MBZ0      58
#define FPSR_MBZ0_V    0x3fi64

//
// For setting up FPSR on kernel entry
//
// all FP exceptions masked
//
// rounding to nearest, 64-bit precision, wide range enabled for FPSR.fs1
//
// rounding to nearest, 53-bit precision, wide range disabled for FPSR.fs0
//

#define FPSR_FOR_KERNEL 0x9804C0270033F

//
// Define hardware Task Priority Register (TPR)
//
// TPR bit positions

// Bits 0 - 3 ignored
#define TPR_MIC        4
#define TPR_MIC_LEN    4
// Bits 8 - 15 reserved
// TPR.mmi is always 0 in NT
#define TPR_MMI        16
// Bits 17 - 63 ignored

//
// The current IRQL is maintained in the TPR.mic field. The
// shift count is the number of bits to shift right to extract the
// IRQL from the TPR. See the GET/SET_IRQL macros.
//

#define TPR_IRQL_SHIFT TPR_MIC

//
// To go from vector number <-> IRQL we just do a shift
//

#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT

//
// Define hardware Interrupt Status Register (ISR)
//
// ISR bit positions

#define ISR_CODE       0
#define ISR_CODE_LEN   16
#define ISR_CODE_MASK  0xFFFF
#define ISR_NA_CODE_MASK  0xF
#define ISR_IA_VECTOR  16
#define ISR_IA_VECTOR_LEN 8
// ISR bits 24-31 reserved
#define ISR_MBZ0       24
#define ISR_MBZ0_V     0xff
#define ISR_X          32
#define ISR_W          33
#define ISR_R          34
#define ISR_NA         35
#define ISR_SP         36
#define ISR_RS         37
#define ISR_IR         38
#define ISR_NI         39
// ISR bit 40 reserved
#define ISR_MBZ1       40
#define ISR_EI         41
#define ISR_ED         43
// ISR bits 44-63 reserved
#define ISR_MBZ2       44
#define ISR_MBZ2_V     0xfffff

//
// ISR codes for Non-Access Instructions: ISR{3:0}
//

#define ISR_TPA            0        // tpa instruction
#define ISR_FC             1        // fc instruction
#define ISR_PROBE          2        // probe instruction
#define ISR_TAK            3        // tak instruction
#define ISR_LFETCH         4        // lfetch, lfetch.fault instruction
#define ISR_PROBE_FAULT    5        // probe.fault instruction

//
// ISR codes for General Exceptions: ISR{7:4}
//

#define ISR_ILLEGAL_OP     0        // Illegal operation fault
#define ISR_PRIV_OP        1        // Privileged operation fault
#define ISR_PRIV_REG       2        // Privileged register fault
#define ISR_RESVD_REG      3        // Reserved register/field fault
#define ISR_ILLEGAL_ISA    4        // Disabled instruction set transition fault
#define ISR_ILLEGAL_HAZARD 8        // Illegal hazard fault

//
// ISR codes for Nat Consumption Faults: ISR{7:4}
//

#define ISR_NAT_REG     1           // Nat Register Consumption fault
#define ISR_NAT_PAGE    2           // Nat Page Consumption fault

//
// For Traps ISR{3:0}
//

// FP trap
#define ISR_FP_TRAP    0
// Lower privilege transfer trap
#define ISR_LP_TRAP    1
// Taken branch trap
#define ISR_TB_TRAP    2
// Single step trap
#define ISR_SS_TRAP    3
// Unimplemented instruction address trap
#define ISR_UI_TRAP    4

//
// Define hardware Default Control Register (DCR)
//
// DCR bit positions

#define DCR_PP         0
#define DCR_BE         1
#define DCR_LC         2
// DCR bits 3-7 reserved
#define DCR_DM         8
#define DCR_DP         9
#define DCR_DK         10
#define DCR_DX         11
#define DCR_DR         12
#define DCR_DA         13
#define DCR_DD         14
#define DCR_DEFER_ALL  0x7f00
// DCR bits 16-63 reserved
#define DCR_MBZ1       2
#define DCR_MBZ1_V     0xffffffffffffi64

// Define hardware RSE Configuration Register
//
// RS Configuration (RSC) bit field positions

#define RSC_MODE       0
#define RSC_PL         2
#define RSC_BE         4
// RSC bits 5-15 reserved
#define RSC_MBZ0       5
#define RSC_MBZ0_V     0x3ff
#define RSC_LOADRS     16
#define RSC_LOADRS_LEN 14
// RSC bits 30-63 reserved
#define RSC_MBZ1       30
#define RSC_MBZ1_LEN   34
#define RSC_MBZ1_V     0x3ffffffffi64

// RSC modes
// Lazy
#define RSC_MODE_LY (0x0)
// Store intensive
#define RSC_MODE_SI (0x1)
// Load intensive
#define RSC_MODE_LI (0x2)
// Eager
#define RSC_MODE_EA (0x3)

// RSC Endian bit values
#define RSC_BE_LITTLE 0
#define RSC_BE_BIG    1

// RSC while in kernel: enabled, little endian, pl = 0, eager mode
#define RSC_KERNEL ((RSC_MODE_EA<<RSC_MODE) | (RSC_BE_LITTLE<<RSC_BE))
// RSE disabled: disabled, pl = 0, little endian, eager mode
#define RSC_KERNEL_DISABLED ((RSC_MODE_LY<<RSC_MODE) | (RSC_BE_LITTLE<<RSC_BE))

//
// Define Interruption Function State (IFS) Register
//
// IFS bit field positions
//

#define IFS_IFM        0
#define IFS_IFM_LEN    38
#define IFS_MBZ0       38
#define IFS_MBZ0_V     0x1ffffffi64
#define IFS_V          63
#define IFS_V_LEN      1

//
// IFS is valid when IFS_V = IFS_VALID
//

#define IFS_VALID      1

//
// define the width of each size field in PFS/IFS
//

#define PFS_PPL                  62         // pfs.ppl bit location
#define PFS_PPL_LEN              PSR_CPL_LEN
#define PFS_EC_SHIFT             52
#define PFS_EC_SIZE              6
#define PFS_EC_MASK              0x3F
#define PFS_SIZE_SHIFT           7
#define PFS_SIZE_MASK            0x7F
#define NAT_BITS_PER_RNAT_REG    63
#define RNAT_ALIGNMENT           (NAT_BITS_PER_RNAT_REG << 3)

//
// Define Region Register (RR)
//
// RR bit field positions
//

#define RR_VE          0
#define RR_MBZ0        1
#define RR_PS          2
#define RR_PS_LEN      6
#define RR_RID         8
#define RR_RID_LEN     24
#define RR_MBZ1        32

//
// indirect mov index for loading RR
//

#define RR_INDEX       61
#define RR_INDEX_LEN   3

//
// Define low order 8 bit's of RR. All RR's have same PS and VE
//

#define RR_PS_VE  ( (PAGE_SHIFT<<RR_PS) | (1<<RR_VE) )

//
// Number of region registers used by NT
//

#define NT_RR_SIZE 4

//
// Total number of region registers
//

#define RR_SIZE 8

//
// Define Protection Key Register (PKR)
//
// PKR bit field positions
//

#define PKR_V          0
#define PKR_WD         1
#define PKR_RD         2
#define PKR_XD         3
#define PKR_MBZ0       4
#define PKR_KEY        8
#define PKR_KEY_LEN    24
#define PKR_MBZ1       32

//
// Define low order 8 bit's of PKR. All valid PKR's have same V, WD, RD, XD
//

#define PKR_VALID  (1<<PKR_V)

//
// Number of protection key registers
//

#define PKRNUM 16

//
// Define Interrupt TLB Insertion Register
//
// ITIR bit field positions
//

#define ITIR_RV0       0
#define ITIR_PS        2
#define ITIR_KEY       8
#define ITIR_RV1       32

//
// The following definitions are obsolete but
// there are codes in ke/ia64 reference them.
//
// Define Interruption Translation Register (IDTR/IITR)
//
// IDTR/IITR bit field positions
//

#define IDTR_MBZ0      0
#define IDTR_PS        2
#define IDTR_KEY       8
#define IDTR_MBZ1      32
#define IDTR_IGN0      48
#define IDTR_PPN       56
#define IDTR_MBZ2      63

#define IITR_MBZ0      IDTR_MBZ0
#define IITR_PS        IDTR_PS
#define IITR_KEY       IDTR_KEY
#define IITR_MBZ1      IDTR_MBZ1
#define IITR_IGN0      IDTR_IGN0
#define IITR_PPN       IDTR_PPN
#define IITR_MBZ2      IDTR_MBZ2

//
// ITIR  bit field masks

#define IITR_PPN_MASK              0x7FFF000000000000
#define IITR_ATTRIBUTE_PPN_MASK    0x0003FFFFFFFFF000

//
// Define Translation Insertion Format (TR)
//
// TR bit field positions
//

#define TR_P           0
#define TR_RV0         1
#define TR_MA          2
#define TR_A           5
#define TR_D           6
#define TR_PL          7
#define TR_AR          9
#define TR_PPN         13          // must be same as PAGE_SHIFT
#define TR_RV1         50
#define TR_ED          52
#define TR_IGN0        53

//
// Macros for generating TR value
//
#define TR_VALUE(ed, ppn, ar, pl, d, a, ma, p)        \
                ( ( ed << TR_ED )                  |  \
                  ( ppn & IITR_ATTRIBUTE_PPN_MASK) |  \
                  ( ar << TR_AR )                  |  \
                  ( pl << TR_PL )                  |  \
                  ( d << TR_D )                    |  \
                  ( a << TR_A )                    |  \
                  ( ma << TR_MA )                  |  \
                  ( p << TR_P )                       \
                )

#define ITIR_VALUE(key, ps)                                             \
                ( ( ps << ITIR_PS )                                  |  \
                  ( key << ITIR_KEY )                                   \
                )

//
// Page size definitions
//
#define PS_4K        0xC             // 0xC=12, 2^12=4K
#define PS_8K        0xD             // 0xD=13, 2^13=8K
#define PS_16K       0xE             // 0xE=14, 2^14=16K
#define PS_64K       0x10            // 0x10=16, 2^16=64K
#define PS_256K      0x12            // 0x12=18, 2^18=256K
#define PS_1M        0x14            // 0x14=20, 2^20=1M
#define PS_4M        0x16            // 0x16=22, 2^22=4M
#define PS_16M       0x18            // 0x18=24, 2^24=16M
#define PS_64M       0x1a            // 0x1a=26, 2^26=64M
#define PS_256M      0x1c            // 0x1a=26, 2^26=64M

//
// Debug Registers definitions
//

//
// At least, 4 data and 4 instruction register pairs are implemented
// on all processor models.
//
#define NUMBER_OF_DEBUG_REGISTER_PAIRS    4

//
// For the break conditions (mask):
//

#define DR_MASK      0         // Mask
#define DR_MASK_LEN  56        // Mask length
#define DR_PLM0      56        // Enable privlege level 0
#define DR_PLM1      57        // Enable privlege level 1
#define DR_PLM2      58        // Enable privlege level 2
#define DR_PLM3      59        // Enable privlege level 3 (user)
#define DR_IG        60        // Ignore
#define DR_RW        62        // Read/Write
#define DR_RW_LEN     2        // R/W length
#define DR_X         63        // Execute

//
// Performance Monitor Registers definitions
//

//
// At least, 4 data and 4 instruction register pairs are implemented
// on all processor models.
//
#define NUMBER_OF_PERFMON_REGISTER_PAIRS    4

//
// Macro to generate mask value from bit position
// N.B. If this macro is used in a C expression and the result is a
// 64-bit, the "value" argument shoud be cast as "unsigned long long" to
// produce a 64-bit mask.
//

#define MASK_IA64(bp,value)  (value << bp)

//
// Interrupt Vector Definitions
//

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT

//
// Define interruption vector offsets
//

#define OFFSET_VECTOR_BREAK         0x2800  // Break instruction vector
#define OFFSET_VECTOR_EXT_INTERRUPT 0x2c00  // External interrupt vector
#define OFFSET_VECTOR_EXC_GENERAL   0x4400  // General exception vector

//
//
// Define IA64 page mask values.
//
#define PAGEMASK_4KB 0x0                // 4kb page
#define PAGEMASK_16KB 0x3               // 16kb page
#define PAGEMASK_64KB 0xf               // 64kb page
#define PAGEMASK_256KB 0x3f             // 256kb page
#define PAGEMASK_1MB 0xff               // 1mb page
#define PAGEMASK_4MB 0x3ff              // 4mb page
#define PAGEMASK_16MB 0xfff             // 16mb page

//
// Define IA64 primary cache states.
//
#define PRIMARY_CACHE_INVALID 0x0       // primary cache invalid
#define PRIMARY_CACHE_SHARED 0x1        // primary cache shared (clean or dirty)
#define PRIMARY_CACHE_CLEAN_EXCLUSIVE 0x2 // primary cache clean exclusive
#define PRIMARY_CACHE_DIRTY_EXCLUSIVE 0x3 // primary cache dirty exclusive

//
// Page table constants
//

#define PS_SHIFT         2
#define PS_LEN           6
#define PTE_VALID_MASK   1
#define PTE_ACCESS_MASK  0x20
#define PTE_NOCACHE      0x10
#define PTE_CACHE_SHIFT  2
#define PTE_CACHE_LEN    3
#define PTE_LARGE_PAGE   54
#define PTE_PFN_SHIFT    8
#define PTE_PFN_LEN      24
#define PTE_ATTR_SHIFT   1
#define PTE_ATTR_LEN     5
#define PTE_PS           55
#define PTE_OFFSET_LEN   10
#define PDE_OFFSET_LEN   10
#define VFN_LEN          19
#define VFN_LEN64        24
#define TB_USER_MASK     0x180
#define PTE_DIRTY_MASK   0x40
#define PTE_WRITE_MASK   0x400
#define PTE_EXECUTE_MASK 0x200
#define PTE_CACHE_MASK   0x0
#define PTE_EXC_DEFER 0x10000000000000

#define VALID_KERNEL_PTE (PTE_VALID_MASK|PTE_ACCESS_MASK|PTE_WRITE_MASK|PTE_CACHE_MASK|PTE_DIRTY_MASK)
#define VALID_KERNEL_EXECUTE_PTE (PTE_VALID_MASK|PTE_ACCESS_MASK|PTE_EXECUTE_MASK|PTE_WRITE_MASK|PTE_CACHE_MASK|PTE_DIRTY_MASK|PTE_EXC_DEFER)
#define PTE_VALID        0
#define PTE_ACCESS       5
#define PTE_OWNER        7
#define PTE_WRITE        10
#define PTE_LP_CACHE_SHIFT    53
#define ATE_INDIRECT     62
#define ATE_MASK         0xFFFFFFFFFFFFF9DE
#define ATE_MASK0        0x621
#define PAGE4K_SHIFT     12
#define ALT4KB_BASE 0x6FC00000000
#define ALT4KB_END  0x6FC00800000

#define VRN_SHIFT        61
#define KSEG3_VRN        4
#define KSEG4_VRN        5
#define MAX_PHYSICAL_SHIFT 44

//
// Translation register usage
//

//
// In NTLDR
//

//
// Boot loader CONFIGFLAG definitions.
//

#define DISABLE_TAR_FIX           0
#define DISABLE_BTB_FIX           1
#define DISABLE_DATA_BP_FIX       2
#define DISABLE_DET_STALL_FIX     3
#define ENABLE_FULL_DISPERSAL     4
#define ENABLE_TB_BROADCAST       5
#define DISABLE_CPL_FIX           6
#define ENABLE_POWER_MANAGEMENT   7
#define DISABLE_IA32BR_FIX        8
#define DISABLE_L1_BYPASS         9
#define DISABLE_VHPT_WALKER      10
#define DISABLE_IA32RSB_FIX      11
#define DISABLE_INTERRUPTION_LOG 13
#define DISABLE_UNSAFE_FILL      14
#define DISABLE_STORE_UPDATE     15
#define ENABLE_HISTORY_BUFFER    16

#define BL_4M                0x00400000
#define BL_16M               0x01000000
#define BL_20M               0x01400000
#define BL_24M               0x01800000
#define BL_28M               0x01C00000
#define BL_32M               0x02000000
#define BL_36M               0x02400000
#define BL_40M               0x02800000
#define BL_48M               0x03000000
#define BL_64M               0x04000000
#define BL_80M               0x05000000
#define BL_128M              0x08000000

#define TR_INFO_TABLE_SIZE   10

//
// DTRs used by NTOSKRNL
//

#define DTR_KIPCR_INDEX      0
#define DTR_KERNEL_INDEX     1
#define DTR_KTBASE_INDEX     2
#define DTR_UTBASE_INDEX     3
#define DTR_STBASE_INDEX     4
#define DTR_PAL_INDEX        6
#define DTR_UTBASE_INDEX_TMP 7        // freed during the phase 0 init

//
// ITRs used by NTOSKRNL
//

#define ITR_EPC_INDEX        0
#define ITR_KERNEL_INDEX     1
#define ITR_PAL_INDEX        4

//
// Indexes into the HalReserved portion of PCR
//

#define SIZE_OF_HALRESERVED_ENTRY           8
#define PHYSICAL_SALEVENTRESOURCE_OFFSET     ( 31 * SIZE_OF_HALRESERVED_ENTRY )
 
//
// MCA recovery action hints 
//

#define MCA_CONTEXT_BAD             0x1
#define MCA_POISON_MEMORY           0x2

#define MEM_4K         0x1000
#define MEM_8K         0x2000
#define MEM_16K        0x4000
#define MEM_64K        0x10000
#define MEM_256K       0x40000
#define MEM_1M         0x100000
#define MEM_4M         0x400000
#define MEM_16M        0x1000000
#define MEM_64M        0x4000000
#define MEM_256M       0x10000000

//
// Macro for translation memory size in bytes to page size in TR format
//
#define MEM_SIZE_TO_PS(MemSize, TrPageSize)             \
                if (MemSize <= MEM_4K) {                \
                    TrPageSize = PS_4K;                 \
                } else if (MemSize <= MEM_8K)       {   \
                    TrPageSize = PS_8K;                 \
                } else if (MemSize <= MEM_16K)      {   \
                    TrPageSize = PS_16K;                \
                } else if (MemSize <= MEM_64K)      {   \
                    TrPageSize = PS_64K;                \
                } else if (MemSize <= MEM_256K)     {   \
                    TrPageSize = PS_256K;               \
                } else if (MemSize <= MEM_1M)       {   \
                    TrPageSize = PS_1M;                 \
                } else if (MemSize <= MEM_4M)       {   \
                    TrPageSize = PS_4M;                 \
                } else if (MemSize <= MEM_16M)      {   \
                    TrPageSize = PS_16M;                \
                } else if (MemSize <= MEM_64M)      {   \
                    TrPageSize = PS_64M;                \
                } else if (MemSize <= MEM_256M)     {   \
                    TrPageSize = PS_256M;               \
                }

//
// TLB forward progress queue
//

#define NUMBER_OF_FWP_ENTRIES 8

//
// Initial value of DCR (64-bits)
// res              rv dd da dr dx dk dp dm res   lc be pp
// 0x000000000000   0  1  1  1  1  1  1  0  00000 1  0  1
//
#define DCR_INITIAL 0x0000000000007e05

//
// Initial value of user PSR (64-bits)
// Bits 63-32
// res                     bn ed ri ss dd da id it mc is cpl
// 0000 0000 0000 0000 000 1   0 00 0  0  0  0  1  0  0  11
// Bits 31-0
// res  rt tb lp db si di pp sp dfh dfl dt rv pk i ic res        mfh mfl ac up be res
// 0000 1  0  0  0  0  0  1  0  1   0   1  0  0  1 1  0 0000 00  0   0   1  0  0  0
//
#define USER_PSR_INITIAL 0x00001013082a6008i64

//
// Initial value of user FPSR (64-bits)
//
// all FP exceptions masked
//
// rounding to nearest, 64-bit precision, wide range enabled for FPSR.fs1
//
// rounding to nearest, 53-bit precision, wide range disabled for FPSR.fs0
//

#define USER_FPSR_INITIAL 0x9804C0270033F

//
// Initial value of DCR (64-bits)
// res             dd da dr dx dk dp dm res   lc be pp
// 0x000000000000   1  1  1  1  1  1  1  00000 1  0  1
//
#define USER_DCR_INITIAL 0x0000000000007f05i64

//
// Initial value of user RSC (low 32-bits)
// Mode: Lazy. Little endian. User PL.
//
#define USER_RSC_INITIAL ((RSC_MODE_LY<<RSC_MODE) \
                          | (RSC_BE_LITTLE<<RSC_BE) \
                          | (0x3<<RSC_PL))

//
// Definitions that used by CSD and SSD
//

#define USER_CODE_DESCRIPTOR  0xCFBFFFFF00000000   
#define USER_DATA_DESCRIPTOR  0xCF3FFFFF00000000

//
//
// IA64 Software conventions
//

// Bytes in stack scratch area
#define STACK_SCRATCH_AREA  16

//
// Constants for trap
//

// Bits to shift for computing interrupt routine funtion pointer: fp = base + irql<<INT_ROUTINE_SHIFT

#ifdef _WIN64
#define INT_ROUTINES_SHIFT 3
#else
#define INT_ROUTINES_SHIFT 2
#endif

//
//
// Define disable and restore interrupt macros.
// Note: Serialization is implicit for rsm
//

#define DISABLE_INTERRUPTS(reg) \
         mov       reg = psr                    ;\
         rsm       1 << PSR_I

//
// Restore psr.i bit based on value of bit PSR_I in reg
// Enable does not do serialization, so interrupts may not be enabeld for
// a number of cycles after ssm.
//

#define RESTORE_INTERRUPTS(reg)  \
         tbit##.##nz   pt0,pt1 = reg, PSR_I;;   ;\
(pt0)    ssm       1 << PSR_I                   ;\
(pt1)    rsm       1 << PSR_I

//
// The FAST versions can be used when it is not necessary to save/restore
// the previous interrupt enable state.
//

#define FAST_DISABLE_INTERRUPTS \
         rsm       1 << PSR_I

//
// FAST ENABLE does not do serialization -- we don't care if interrupt
// enable is not visible for few instructions.
//

#define FAST_ENABLE_INTERRUPTS \
         ssm       1 << PSR_I

#define YIELD   hint##.##m 0

//
//
// Define TB and cache parameters.
//
#define PCR_ENTRY 0                     // TB entry numbers (2) for the PCR
#define PDR_ENTRY 2                     // TB entry number (1) for the PDR
#define LARGE_ENTRY 3                   // TB entry number (1) for large entry
#define DMA_ENTRY 4                     // TB entry number (1) for DMA/InterruptSource

#define TB_ENTRY_SIZE (3 * 4)           // size of TB entry
#define FIXED_BASE 0                    // base index of fixed TB entries
#define FIXED_ENTRIES (DMA_ENTRY + 1)   // number of fixed TB entries

//
// Define cache parameters
//

#define DCACHE_SIZE 4 * 1024            // size of data cache in bytes
#define ICACHE_SIZE 4 * 1024            // size of instruction cache in bytes
#define MINIMUM_CACHE_SIZE 4 * 1024     // minimum size of cache
#define MAXIMUM_CACHE_SIZE 128 * 1024   // maximum size fo cache

//
// RID and Sequence number limits.
// Start with 1 because 0 means not initialized.
// RID's are 24 bits.
//

#define KSEG3_RID          0x00000
#define START_GLOBAL_RID   0x00001
#define START_SESSION_RID  0x00003
#define START_PROCESS_RID  0x00004

//
// making the maximum RID to 18-bit, temp fix for Merced
//

#define MAXIMUM_RID        0x3FFFF

//
// Sequence numbers are 32 bits
// Start with 1 because 0 means not initialized.
//

#define START_SEQUENCE     1
#define MAXIMUM_SEQUENCE   0xFFFFFFFFFFFFFFFF

//
//
// Define subtitle macro
//

#define SBTTL(x)

//
// Define procedure entry macros
//

#define PROLOGUE_BEGIN     .##prologue;
#define PROLOGUE_END       .##body;

#define ALTERNATE_ENTRY(Name)                    \
         .##global Name;                         \
         .##type   Name, @function;              \
Name::

#define CPUBLIC_LEAF_ENTRY(Name,i)               \
         .##text;                                \
         .##proc   Name##@##i;                   \
Name##@##i::

#define LEAF_ENTRY(Name)                         \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
Name::

#define LEAF_SETUP(i,l,o,r)                      \
         .##regstk i,l,o,r;                      \
         alloc     r31=ar##.##pfs,i,l,o,r

#define CPUBLIC_NESTED_ENTRY(Name,i)             \
         .##text;                                \
         .##proc   Name##@##i;                   \
         .##unwentry;                            \
Name##@##i::

#define NESTED_ENTRY_EX(Name, Handler)           \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
         .##personality Handler;                 \
Name::

#define NESTED_ENTRY(Name)                       \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
Name::

// Note: use of NESTED_SETUP requires number of locals (l) >= 2

#define NESTED_SETUP(i,l,o,r)                    \
         .##regstk i,l,o,r;                      \
         .##prologue 0xC, loc0;                  \
         alloc     savedpfs=ar##.##pfs,i,l,o,r  ;\
         mov       savedbrp=brp;

//
// Define procedure exit macros
//

#define LEAF_RETURN                              \
         br##.##ret##.##sptk##.##few##.##clr brp

#define NESTED_RETURN                            \
         mov       ar##.##pfs = savedpfs;        \
         mov       brp = savedbrp;               \
         br##.##ret##.##sptk##.##few##.##clr brp

#define LEAF_EXIT(Name)                          \
         .##endp Name;

#define NESTED_EXIT(Name)                        \
         .##endp Name;


//++
// Routine:
//
//       LDPTR(rD, rPtr)
//
// Routine Description:
//
//       load pointer value.
//
// Agruments:
//
//       rD:     destination register
//       rPtr: register containing pointer
//
// Return Value:
//
//       rD = load from address [rPtr]
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define LDPTR(rD, rPtr) \
       ld8        rD = [rPtr]
#else
#define LDPTR(rD, rPtr) \
       ld4        rD = [rPtr] ;\
       ;;                     ;\
       sxt4       rD = rD
#endif

//++
// Routine:
//
//       LDPTRINC(rD, rPtr, imm)
//
// Routine Description:
//
//       load pointer value and update base.
//
// Agruments:
//
//       rD:     destination register
//       rPtr: register containing pointer
//       imm:  number to be incremented to base
//
// Return Value:
//
//       rD = load from address [rPtr] and rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define LDPTRINC(rD, rPtr, imm) \
       ld8        rD = [rPtr], imm
#else
#define LDPTRINC(rD, rPtr, imm) \
       ld4        rD = [rPtr], imm ;\
       ;;                     ;\
       sxt4       rD = rD
#endif

//++
// Routine:
//
//       PLDPTRINC(rP, rD, rPtr, imm)
//
// Routine Description:
//
//       predicated load pointer value and update base.
//
// Agruments:
//
//       rP:   predicate register
//       rD:   destination register
//       rPtr: register containing pointer
//       imm:  number to be incremented to base
//
// Return Value:
//
//       if (rP) rD = load from address [rPtr] and rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define PLDPTRINC(rP, rD, rPtr, imm) \
(rP)   ld8        rD = [rPtr], imm
#else
#define PLDPTRINC(rP, rD, rPtr, imm) \
(rP)   ld4        rD = [rPtr], imm ;\
       ;;                     ;\
(rP)   sxt4       rD = rD
#endif

//++
// Routine:
//
//       PLDPTR(rP, rD, rPtr)
//
// Routine Description:
//
//       predicated load pointer value.
//
// Agruments:
//
//       rP:   predicate register
//       rD:   destination register
//       rPtr: register containing pointer
//
// Return Value:
//
//       if (rP == 1)  rD = load from address [rPtr], else NO-OP
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define PLDPTR(rP, rD, rPtr) \
(rP)    ld8       rD = [rPtr]
#else
#define PLDPTR(rP, rD, rPtr) \
(rP)    ld4       rD = [rPtr] ;\
       ;;                     ;\
(rP)    sxt4      rD = rD
#endif

//++
// Routine:
//
//       STPTR(rPtr, rS)
//
// Routine Description:
//
//       store pointer value.
//
// Agruments:
//
//       rPtr: register containing pointer
//       rS  : source pointer value
//
// Return Value:
//
//       store [rPtr] = rS
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define STPTR(rPtr, rS) \
       st8        [rPtr] = rS
#else
#define STPTR(rPtr, rS) \
       st4        [rPtr] = rS
#endif

//++
// Routine:
//
//       PSTPTR(rP, rPtr, rS)
//
// Routine Description:
//
//       predicated store pointer value.
//
// Agruments:
//
//       rP:   predicate register
//       rPtr: register containing pointer
//       rS  : source pointer value
//
// Return Value:
//
//       if (rP)  store [rPtr] = rS
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define PSTPTR(rP, rPtr, rS) \
(rP)   st8        [rPtr] = rS
#else
#define PSTPTR(rP, rPtr, rS) \
(rP)   st4        [rPtr] = rS
#endif

//++
// Routine:
//
//       STPTRINC(rPtr, rS, imm)
//
// Routine Description:
//
//       store pointer value.
//
// Agruments:
//
//       rPtr: register containing pointer
//       rS  : source pointer value
//       imm:  number to be incremented to base
//
// Return Value:
//
//       if (rP) store [rPtr] = rS, rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define STPTRINC(rPtr, rS, imm) \
       st8        [rPtr] = rS, imm
#else
#define STPTRINC(rPtr, rS, imm) \
       st4        [rPtr] = rS, imm
#endif

//++
// Routine:
//
//       ARGPTR(rPtr)
//
// Routine Description:
//
//       sign extend the pointer argument for WIN32
//
// Agruments:
//
//       rPtr: register containing pointer argument
//
// Return Value:
//
//
// Notes:
//
//
//
//--

#ifdef  _WIN64
#define ARGPTR(rPtr)
#else
#define ARGPTR(rPtr) \
        sxt4      rPtr = rPtr
#endif


//
// Assembler spinlock macros
//

//++
// Routine:
//
//       SPINLOCK_LOG_PRE_ACQUIRE(rPrcb, rLog, rStartTime, rIntCount)
//
// Routine Description:
//
//       spinlock logging processing prior to spinlock acquisition.
//
// Agruments:
//
//       rPrcb: pointer to the current PRCB.
//       rLog: predicate to hold the logging status
//       rStartTime: register to hold the current time.
//       rIntCount: register to hold the current interrupt count in PRCB.
//
// Return Value:
//
//       rLog: 1 if spinlock logging is enabled, 0 if it is disabled.
//       rStartTime: current time.
//       rIntCount: current interrupt count in PRCB.
//
// Notes:
//
//       Uses temporaries: GRs t21, t22. GR t1 is used but is preserved.
//--

#define SPINLOCK_LOG_PRE_ACQUIRE(rPrcb, rLog, rStartTime, rIntCount)           \
         mov           t21 = t1                                               ;\
         movl          t22 = PerfGlobalGroupMask+PERF_SPINLOCK_OFFSET         ;\
         ;;                                                                   ;\
         add           rIntCount = PbInterruptCount, rPrcb                    ;\
         ld4           t22 = [t22]                                            ;\
         mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
         ld4           rIntCount = [rIntCount]                                ;\
         mov           rStartTime = t1                                        ;\
         tbit##.##nz   rLog = t22, PERF_SPINLOCK_FLAG_SHIFT                   ;\
         ;;                                                                   ;\
         mov           t1 = t21

//++
// Routine:
//
//       SPINLOCK_LOG_POST_ACQUIRE(rLog, rLock, rStartTime, rSpinCount, Type)
//
// Routine Description:
//
//       spinlock logging processing after spinlock acquisition.
//
// Agruments:
//
//       rLog: the logging status, enabled or disabled
//       rLock: pointer to the spinlock 
//       rStartTime: the time just before attempting to acquire the spinlock
//       rSpinCount: supplies the spin count during lock acquisition
//       Type: Type of the spinlock
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Uses temporaries: GR t22. GR t1 is used but is preserved.
//       out4 is assumed to be properly assigned before this routine is 
//       invoked.
//--

#define SPINLOCK_LOG_POST_ACQUIRE(rLog, rLock, rStartTime, rSpinCount, Type)   \
(rLog)   mov           out0 = rLock                                           ;\
(rLog)   mov           out3 = rSpinCount                                      ;\
(rLog)   mov           t22 = t1                                               ;\
         ;;                                                                   ;\
(rLog)   mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
(rLog)   mov           out1 = t1                                              ;\
(rLog)   sub           out2 = t1, rStartTime                                  ;\
(rLog)   mov           out5 = Type                                            ;\
         ;;                                                                   ;\
(rLog)   mov           t1 = t22                                               ;\
(rLog)   br##.##call##.##spnt brp = PerfLogSpinLockAcquire

//++
// Routine:
//
//       SPINLOCK_LOG_PRE_RELEASE(rLog, rStartTime)
//
// Routine Description:
//
//       spinlock logging processing prior to spinlock release.
//
// Agruments:
//
//       rLog: predicate to hold the logging status
//       rStartTime: register to hold the current time.
//
// Return Value:
//
//       rLog: 1 if spinlock logging is enabled, 0 if it is disabled.
//       rStartTime: current time.
//
// Notes:
//
//       Uses temporaries: GRs t21, t22. GR t1 is used but is preserved.
//--

#define SPINLOCK_LOG_PRE_RELEASE(rLog, rStartTime)                             \
         mov           t21 = t1                                               ;\
         movl          t22 = PerfGlobalGroupMask+PERF_SPINLOCK_OFFSET         ;\
         ;;                                                                   ;\
         ld4           t22 = [t22]                                            ;\
         mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
         mov           rStartTime = t1                                        ;\
         tbit##.##nz   rLog = t22, PERF_SPINLOCK_FLAG_SHIFT                   ;\
         ;;                                                                   ;\
         mov           t1 = t21

//++
// Routine:
//
//       SPINLOCK_LOG_POST_RELEASE(rLog, rLock)
//
// Routine Description:
//
//       spinlock logging processing after spinlock release.
//
// Agruments:
//
//       rLog: the logging status, enabled or disabled
//       rLock: pointer to the spinlock
//
// Return Value:
//
//       None.
//
// Notes:
//
//       out2 is assumed to be properly assigned before this routine is
//       invoked.
//--

#define SPINLOCK_LOG_POST_RELEASE(rLog, rLock)                                 \
(rLog)   mov           out0 = rLock                                           ;\
(rLog)   mov           out1 = savedbrp                                        ;\
         ;;                                                                   ;\
(rLog)   br##.##call##.##spnt brp = PerfLogSpinLockRelease

//++
// Routine:
//
//       ACQUIRE_SPINLOCK(rpLock, rOwn, rSpinCount, Loop)
//
// Routine Description:
//
//       Acquire a spinlock. Waits for lock to become free
//       by spinning on the cached lock value.
//
// Agruments:
//
//       rpLock: pointer to the spinlock (64-bit)
//       rOwn:   value to store in lock to indicate owner
//               Depending on call location, it could be:
//                  - rpLock
//                  - pointer to process
//                  - pointer to thread
//                  - pointer to PRCB
//       rSpinCount: regsiter to hold the spincount on return
//       Loop:   unique name for loop label
//
// Return Value:
//
//       rSpinCount: returns the spincount
//
// Notes:
//
//       Uses temporaries: predicates pt0 - pt2, and GR t22
//       The first time through the loop pt0 is 1 and pt1 is 0. 
//       Other registers are uninitialized.
//--

#define ACQUIRE_SPINLOCK(rpLock, rOwn, rSpinCount, Loop)                       \
         cmp##.##eq    pt0, pt1 = zero, zero                                  ;\
         mov           rSpinCount = zero                                      ;\
         ;;                                                                   ;\
Loop:                                                                         ;\
.pred.rel "mutex",pt0,pt1                                                     ;\
(pt1)    YIELD                                                                ;\
(pt0)    xchg8         t22 = [rpLock], rOwn                                   ;\
(pt1)    ld8##.##nt1   t22 = [rpLock]                                         ;\
         ;;                                                                   ;\
(pt0)    cmp##.##ne    pt2 = zero, t22                                        ;\
         cmp##.##eq    pt0, pt1 = zero, t22                                   ;\
         ;;                                                                   ;\
(pt1)    add           rSpinCount = 1, rSpinCount                             ;\
(pt2)    br##.##dpnt   Loop

//++
// Routine:
//
//       UPDATE_SPINLOCK_COUNTERS(rPrcb, rStatus, rSpinCount)
//
// Routine Description:
//
//       Update various spinlock instrumentation counters in PRCB.
//
// Agruments:
//
//       rPrcb: pointer to the current PRCB.
//       rStatus: non-zero if acqusition is successful, 0 if not.
//       rSpinCount: supplies the spin count during lock acquisition. 
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses temporaries: predicates pt0 and pt1, and GR t17 - t22
//--

#define UPDATE_SPINLOCK_COUNTERS(rPrcb, rStatus, rSpinCount)                   \
         ;;                                                                   ;\
         cmp##.##ne    pt0 = zero, rSpinCount                                 ;\
         cmp##.##ne    pt1 = zero, rStatus                                    ;\
         ;;                                                                   ;\
(pt1)    movl          t17 = PbSpinLockAcquireCount                           ;\
(pt0)    movl          t18 = PbSpinLockContentionCount                        ;\
(pt0)    movl          t19 = PbSpinLockSpinCount                              ;\
         ;;                                                                   ;\
(pt1)    add           t17 = t17, rPrcb                                       ;\
(pt0)    add           t18 = t18, rPrcb                                       ;\
(pt0)    add           t19 = t19, rPrcb                                       ;\
         ;;                                                                   ;\
(pt1)    ld4           t20 = [t17]                                            ;\
(pt0)    ld4           t21 = [t18]                                            ;\
(pt0)    ld4           t22 = [t19]                                            ;\
         ;;                                                                   ;\
(pt1)    add           t20 = 1, t20                                           ;\
(pt0)    add           t21 = 1, t21                                           ;\
(pt0)    add           t22 = rSpinCount, t22                                  ;\
         ;;                                                                   ;\
(pt1)    st4           [t17] = t20                                            ;\
(pt0)    st4           [t18] = t21                                            ;\
(pt0)    st4           [t19] = t22

//++
// Routine:
//
//       RELEASE_SPINLOCK(rpLock)
//
// Routine Description:
//
//       Release a spinlock by setting lock to zero.
//
// Agruments:
//
//       rpLock: pointer to the spinlock.
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses an ordered store to ensure previous memory accesses in
//       critical section complete.
//--

#define RELEASE_SPINLOCK(rpLock)                                               \
         st8##.##rel           [rpLock] = zero

//++
// Routine:
//
//       PRELEASE_SPINLOCK(rpLock)
//
// Routine Description:
//
//       Predicated release spinlock.
//
// Agruments:
//
//       rpLock: pointer (swizzled) to the spinlock.
//               spinlock itself is 32-bit.
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses an ordered store to ensure previous memory accesses in
//       critical section complete.
//--

#define PRELEASE_SPINLOCK(px, rpLock)                                          \
(px)    st8##.##rel   [rpLock] = zero

//
// Interrupt and IRQL macros
//

//++
// Routine:
//
//       END_OF_INTERRUPT
//
// Routine Description:
//
//       Hook to perform end-of-interrupt processing. Currently
//       just writes to the EOI control register.
//
// Agruments:
//
//       None
//
// Return Value:
//
//       None
//
// Note:
//
//       Writing EOI requires explicit data serialize. srlz must be preceded by
//       stop bit.
//--

#define END_OF_INTERRUPT                         \
         mov       cr##.##eoi = zero            ;\
         ;;                                     ;\
         srlz##.##d    /* Requires data srlz */

//++
// Routine:
//
//       GET_IRQL(rOldIrql)
//
// Routine Description:
//
//       Read the current IRQL by reading the TPR control register.
//
// Agruments:
//
//       Register to contain the result.
//
// Return Value:
//
//       rOldIrql: the current value of the IRQL.
//
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define GET_IRQL(rOldIrql)                       \
        mov         rOldIrql = cr##.##tpr      ;;\
        extr##.##u  rOldIrql = rOldIrql, TPR_MIC, TPR_MIC_LEN

#else

#define GET_IRQL(rOldIrql)                              \
        movl        rOldIrql = KiPcr+PcCurrentIrql;;    \
        ld1         rOldIrql = [rOldIrql]

#endif

//++
// Routine:
//
//       SET_IRQL(rNewIrql)
//
// Routine Description:
//
//       Update the IRQL by writing the TPR control register.
//       register t21 & t22 are used as a scratch
//
// Agruments:
//
//       Register with the new IRQL value. Contains the unshifted
//       IRQL value (0-15).
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Writing TPR requires explicit data serialize. srlz must be preceded by
//       stop bit.
//
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define SET_IRQL(rNewIrql)                                    \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;     ;\
        mov       cr##.##tpr = t22;;                         ;\
        srlz##.##d
#else

#define SET_IRQL(rNewIrql)                                  \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
        movl      t21 = KiPcr+PcCurrentIrql;;              ;\
        mov       cr##.##tpr = t22                         ;\
        st1       [t21] = rNewIrql

#endif

//++
// Routine:
//
//       PSET_IRQL(pr, rNewIrql)
//
// Routine Description:
//
//       Update the IRQL by writing the TPR control register, predicated
//       on pr
//       register t21 & t22 are used as a scratch
//
// Agruments:
//
//       pr:       predicate -- set irql if pr true.
//
//       rNewIrql: Register with the new IRQL value. Contains the unshifted
//                 IRQL value (0-15).
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Relies on TPR.mi always 0.
//       Writing TPR requires explicit data serialize. srlz must be preceded by
//       stop bit.
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define PSET_IRQL(pr, rNewIrql)                             \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
(pr)    mov       cr##.##tpr = t22;;                       ;\
(pr)    srlz##.##d

#else

#define PSET_IRQL(pr, rNewIrql)                             \
        mov       t21 = rNewIrql                           ;\
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
(pr)    mov       cr##.##tpr = t22                         ;\
(pr)    movl      t22 = KiPcr+PcCurrentIrql;;              ;\
(pr)    st1       [t22] = t21

#endif

//++
// Routine:
//
//       SWAP_IRQL(rNewIrql)
//
// Routine Description:
//
//       get the current IRQL value and set the IRQL to the new value
//       register t21 and t22 are used as a scratch
//
// Agruments:
//
//       Register with the new IRQL value. Contains the unshifted
//       IRQL value (0-15).
//
// Return Value:
//
//       v0 - current IRQL
//
//--

#define SWAP_IRQL(rNewIrql)                                 \
        movl      t22 = KiPcr+PcCurrentIrql;;              ;\
        ld1       v0 = [t22]                               ;\
        dep##.##z t21 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
        mov       cr##.##tpr = t21                         ;\
        st1       [t22] = rNewIrql

//++
// Routine:
//
//       GET_IRQL_FOR_VECTOR(pGet,rIrql,rVector)
//
// Routine Description:
//
//       Hook to get the IRQL associated with an interrupt vector.
//       Currently just returns bit {7:4} of the 8-bit vector number.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rIrql:   Register to contain the associated IRQL.
//       rVector: Register containing the vector number.
//
// Return Value:
//
//       rIrql: The IRQL value. A 4-bit value in bits {3:0}. All
//              other bits are zero.
//
//--

#define GET_IRQL_FOR_VECTOR(pGet,rIrql,rVector)                      \
(pGet)  shr         rIrql = rVector, VECTOR_IRQL_SHIFT



//++
// Routine:
//
//       GET_VECTOR_FOR_IRQL(pGet,rVector,rIrql)
//
// Routine Description:
//
//       Hook to get the interrupt vector associated with an IRQL.
//       Currently just returns IRQL << 4.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rVector: Register containing the associated vector number.
//       rIrql:   Register to containing the IRQL.
//
// Return Value:
//
//       rVector: The vector value. An 8-bit value in bits {7:0}. All
//              other bits are zero.
//
//--

#define GET_VECTOR_FOR_IRQL(pGet, rVector, rIrql)                     \
(pGet)  shl         rVector = rIrql, VECTOR_IRQL_SHIFT

// Routine:
//
//       REQUEST_APC_INT(pReq)
//       REQUEST_DISPATCH_INT(pReq)
//
// Routine Description:
//
//       Request a software interrupt. Used to request
//       APC and DPC interrupts.
//
// Agruments:
//
//       pReq: Predicate: if true then do request, else skip
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses temporary registers t20, t21
//--

#define REQUEST_APC_INT(pReq)                                                  \
        mov         t20 = 1                                                   ;\
        movl        t21 = KiPcr+PcApcInterrupt                                ;\
        ;;                                                                    ;\
(pReq)  st1         [t21] = t20

#define REQUEST_DISPATCH_INT(pReq)                                             \
        mov         t20 = 1                                                   ;\
        movl        t21 = KiPcr+PcDispatchInterrupt                           ;\
        ;;                                                                    ;\
(pReq)  st1         [t21] = t20


#ifdef __assembler
//++
// Routine:
//
//       LOWER_IRQL(rNewIrql, trapFrame)
//
// Routine Description:
//
//       Check for pending s/w interrupts and lower Irql
//
// Agruments:
//
//       rNewIrql: interrupt request level
//
//       trapFrame: trap frame at the time of the interruption
//
// Return Value:
//
//       None
//
// Notes:
//
//       Pending s/w interrupts are dispatched if new IRQL is low enough,
//       even though interrupts are disabled
//--

#define LOWER_IRQL(rNewIrql, trapFrame)                                        \
        cmp##.##gtu pt0, pt1 = DISPATCH_LEVEL, rNewIrql                       ;\
        movl        t22 = KiPcr+PcSoftwareInterruptPending;;                  ;\
        ld2         t22 = [t22]                                               ;\
        mov         out0 = rNewIrql                                           ;\
        mov         out1 = trapFrame;;                                        ;\
(pt0)   cmp##.##ne  pt0, pt1 = r0, t22                                        ;\
        PSET_IRQL(pt1, rNewIrql)                                              ;\
(pt0)   br##.##call##.##spnt brp = KiCheckForSoftwareInterrupt

//++
//
// Routine:
//
//       LEAF_LOWER_IRQL_AND_RETURN(rNewIrql)
//
// Routine Description:
//
//       Check for pending s/w interrupts and lower Irql
//
//       If a software interupt is in fact pending and would
//       logically fire if IRQL is lowered to the new level,
//       branch to code that will promote to a nested function
//       and handle the interrupt, otherwise, lower IRQL and
//       return from this leaf function.
//
// Agruments:
//
//       rNewIrql: interrupt request level
//       End: label marking the end of the macro
//
// Return Value:
//
//       None
//
// Notes:
//
//       Pending s/w interrupts are dispatched if new IRQL is low enough,
//       even though interrupts are disabled
//--

#define CHECK_PENDING_SW_INT_AND_LOWER_IRQL(rNewIrql, End)                     \
        cmp##.##gtu pt0 = DISPATCH_LEVEL, rNewIrql                            ;\
        cmp##.##ne  pt1 = zero, zero                                          ;\
        movl        t21 = KiPcr+PcSoftwareInterruptPending;;                  ;\
        ;;                                                                    ;\
(pt0)   rsm         1 << PSR_I                                                ;\
(pt0)   ld2         t21 = [t21]                                               ;\
        ;;                                                                    ;\
(pt0)   cmp##.##ltu##.##unc pt1 = rNewIrql, t21                               ;\
        ;;                                                                    ;\
(pt1)   mov         out0 = rNewIrql                                           ;\
(pt1)   mov         out1 = zero                                               ;\
        ;;                                                                    ;\
(pt1)   ssm         1 << PSR_I                                                ;\
(pt1)   br##.##call##.##sptk brp = KiCheckForSoftwareInterrupt                ;\
(pt1)   br##.##sptk End                                                       ;\
        SET_IRQL(rNewIrql)                                                    ;\
        ssm         1 << PSR_I                                                ;\
End:

#endif // __assembler

//*******
//*
//* The following macros are used in C runtime asm code
//*
//* beginSection - a macro for declaring and beginning a section
//*         .sdata is used to create short data section, if it does not exist
//*
//* endSection - a macro for ending a previously declared section
//*
//*******

#define beginSection(SectName)  .##section   .CRT$##SectName, "a", "progbits"

#define endSection(SectName)

#define PublicFunction(Name) .##global Name; .##type Name,@function

//  XIA  Begin C Initializer Sections
//  XIC   Microsoft Reserved
//  XIU   User
//  XIZ  End C Initializer Sections
//
//  XCA  Begin C++ Constructor Sections
//  XCC   Compiler (MS)
//  XCL   Library
//  XCU   User
//  XCZ  End C++ Constructor Sections
//
//  XPA  Begin C Pre-Terminator Sections
//  XPU   User
//  XPX   Microsoft Reserved
//  XPZ  End C Pre-Terminator Sections
//
//  XTA  Begin C Pre-Terminator Sections
//  XTU   User
//  XTX   Microsoft Reserved
//  XTZ  End C Pre-Terminator Sections
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ksuuids.h ===
//------------------------------------------------------------------------------
// File: ksuuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for DVD/MPEG2 media types.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------------------------


//
// --- MPEG 2 definitions ---
//

// 36523B13-8EE5-11d1-8CA3-0060B057664A
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
0x36523B13, 0x8EE5, 0x11d1, 0x8C, 0xA3, 0x00, 0x60, 0xB0, 0x57, 0x66, 0x4A)

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

OUR_GUID_ENTRY( MEDIATYPE_MPEG2_SECTIONS,
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5)

// {1ED988B0-3FFC-4523-8725-347BEEC1A8A0}
OUR_GUID_ENTRY( MEDIASUBTYPE_MPEG2_VERSIONED_TABLES,
    0x1ed988b0, 0x3ffc, 0x4523, 0x87, 0x25, 0x34, 0x7b, 0xee, 0xc1, 0xa8, 0xa0)

OUR_GUID_ENTRY(MEDIASUBTYPE_ATSC_SI,
0xb3c7397c, 0xd303, 0x414d, 0xb3, 0x3c, 0x4e, 0xd2, 0xc9, 0xd2, 0x97, 0x33)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVB_SI,
0xe9dd31a3, 0x221d, 0x4adb, 0x85, 0x32, 0x9a, 0xf3, 0x9, 0xc1, 0xa4, 0x8)

OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_SI,
0xe89ad298, 0x3601, 0x4b06, 0xaa, 0xec, 0x9d, 0xde, 0xed, 0xcc, 0x5b, 0xd0)

// {EC232EB2-CB96-4191-B226-0EA129F38250}
OUR_GUID_ENTRY(MEDIASUBTYPE_TIF_SI,
0xec232eb2, 0xcb96, 0x4191, 0xb2, 0x26, 0xe, 0xa1, 0x29, 0xf3, 0x82, 0x50)

// {C892E55B-252D-42b5-A316-D997E7A5D995}
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2DATA,
0xc892e55b, 0x252d, 0x42b5, 0xa3, 0x16, 0xd9, 0x97, 0xe7, 0xa5, 0xd9, 0x95)

#endif

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_WMDRM_TRANSPORT,
0x18BEC4EA, 0x4676, 0x450e, 0xB4, 0x78, 0x0C, 0xD8, 0x4C, 0x54, 0xB3, 0x27)

// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// 138AA9A4-1EE2-4c5b-988E-19ABFDBC8A11
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE,
0x138aa9a4, 0x1ee2, 0x4c5b, 0x98, 0x8e, 0x19, 0xab, 0xfd, 0xbc, 0x8a, 0x11)

// {18BEC4EA-4676-450e-B478-0CD84C54B327}
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_UDCR_TRANSPORT,
0x18BEC4EA, 0x4676, 0x450e, 0xB4, 0x78, 0x0C, 0xD8, 0x4C, 0x54, 0xB3, 0x27)

// {0d7aed42-cb9a-11db-9705-005056c00008}
OUR_GUID_ENTRY( MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_RAW, 
0x0d7aed42, 0xcb9a, 0x11db, 0x97, 0x5, 0x0, 0x50, 0x56, 0xc0, 0x0, 0x8 )

// {af748dd4-d800-11db-9705-005056c00008}
OUR_GUID_ENTRY ( MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_PROCESSED,
0xaf748dd4, 0xd80, 0x11db, 0x97, 0x5, 0x0, 0x50, 0x56, 0xc0, 0x0, 0x8 )

#endif

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// e06d8033-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DTS,
0xe06d8033, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8034-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_SDDS,
0xe06d8034, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#endif

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange,
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// 3577EB09-9582-477f-B29C-B0C452A4FF9A
OUR_GUID_ENTRY(AM_KSPROPSETID_DVD_RateChange,
0x3577eb09, 0x9582, 0x477f, 0xb2, 0x9c, 0xb0, 0xc4, 0x52, 0xa4, 0xff, 0x9a)

// ae4720ae-aa71-42d8-b82a-fffdf58b76fd
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdKaraoke,
0xae4720ae, 0xaa71, 0x42d8, 0xb8, 0x2a, 0xff, 0xfd, 0xf5, 0x8b, 0x76, 0xfd)

// c830acbd-ab07-492f-8852-45b6987c2979
OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
0xc830acbd, 0xab07, 0x492f, 0x88, 0x52, 0x45, 0xb6, 0x98, 0x7c, 0x29, 0x79)

#endif

// -----------------------------------------------
// MPEG4 related KSPROPSETIDs from ksmedia.h of WDK
// -----------------------------------------------

// FF6C4BFA-07A9-4c7b-A237-672F9D68065F
OUR_GUID_ENTRY(AM_KSPROPSETID_MPEG4_MediaType_Attributes,
0xff6c4bfa, 0x7a9, 0x4c7b, 0xa2, 0x37, 0x67, 0x2f, 0x9d, 0x68, 0x6, 0x5f)

//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


// 07dad660L-22f1-11d1-a9f4-00c04fbbde8f
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f)

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
// multi-instance safe codec categories(kernel or user mode)
// {9C24A977-0951-451a-8006-0E49BD28CD5F}
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC_MI,
0x9c24a977, 0x951, 0x451a, 0x80, 0x6, 0xe, 0x49, 0xbd, 0x28, 0xcd, 0x5f)
#endif

// 0A4252A0L-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)


//
// GUIDs needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 28F54685-06FD-11D2-B27A-00A0C9223196
OUR_GUID_ENTRY(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196
OUR_GUID_ENTRY(IID_IKsPinFactory,
0xCD5EBE6BL, 0x8B6E, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMaccess.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaccess.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUser, NetUserModals, NetGroup, NetAccess, and NetLogon API.

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

//
// User Class
//

#ifndef _LMUSER_
#define _LMUSER_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>     // unfortunately created a dependence on this

//
// Function Prototypes - User
//

NET_API_STATUS NET_API_FUNCTION
NetUserAdd (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    OUT LPDWORD    parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  DWORD      filter,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserDel (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    IN  DWORD     num_entries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  DWORD     flags,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword (
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    __in_opt IN  LPCWSTR   username OPTIONAL,
    __in IN  LPCWSTR   oldpassword,
    __in IN  LPCWSTR   newpassword
    );


//
//  Data Structures - User
//

typedef struct _USER_INFO_0 {
    LPWSTR   usri0_name;
}USER_INFO_0, *PUSER_INFO_0, *LPUSER_INFO_0;

typedef struct _USER_INFO_1 {
    LPWSTR   usri1_name;
    LPWSTR   usri1_password;
    DWORD    usri1_password_age;
    DWORD    usri1_priv;
    LPWSTR   usri1_home_dir;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_script_path;
}USER_INFO_1, *PUSER_INFO_1, *LPUSER_INFO_1;

typedef struct _USER_INFO_2 {
    LPWSTR   usri2_name;
    LPWSTR   usri2_password;
    DWORD    usri2_password_age;
    DWORD    usri2_priv;
    LPWSTR   usri2_home_dir;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    LPWSTR   usri2_script_path;
    DWORD    usri2_auth_flags;
    LPWSTR   usri2_full_name;
    LPWSTR   usri2_usr_comment;
    LPWSTR   usri2_parms;
    LPWSTR   usri2_workstations;
    DWORD    usri2_last_logon;
    DWORD    usri2_last_logoff;
    DWORD    usri2_acct_expires;
    DWORD    usri2_max_storage;
    DWORD    usri2_units_per_week;
    PBYTE    usri2_logon_hours;
    DWORD    usri2_bad_pw_count;
    DWORD    usri2_num_logons;
    LPWSTR   usri2_logon_server;
    DWORD    usri2_country_code;
    DWORD    usri2_code_page;
}USER_INFO_2, *PUSER_INFO_2, *LPUSER_INFO_2;

typedef struct _USER_INFO_3 {
    LPWSTR   usri3_name;
    LPWSTR   usri3_password;
    DWORD    usri3_password_age;
    DWORD    usri3_priv;
    LPWSTR   usri3_home_dir;
    LPWSTR   usri3_comment;
    DWORD    usri3_flags;
    LPWSTR   usri3_script_path;
    DWORD    usri3_auth_flags;
    LPWSTR   usri3_full_name;
    LPWSTR   usri3_usr_comment;
    LPWSTR   usri3_parms;
    LPWSTR   usri3_workstations;
    DWORD    usri3_last_logon;
    DWORD    usri3_last_logoff;
    DWORD    usri3_acct_expires;
    DWORD    usri3_max_storage;
    DWORD    usri3_units_per_week;
    PBYTE    usri3_logon_hours;
    DWORD    usri3_bad_pw_count;
    DWORD    usri3_num_logons;
    LPWSTR   usri3_logon_server;
    DWORD    usri3_country_code;
    DWORD    usri3_code_page;
    DWORD    usri3_user_id;
    DWORD    usri3_primary_group_id;
    LPWSTR   usri3_profile;
    LPWSTR   usri3_home_dir_drive;
    DWORD    usri3_password_expired;
}USER_INFO_3, *PUSER_INFO_3, *LPUSER_INFO_3;

typedef struct _USER_INFO_4 {
    LPWSTR   usri4_name;
    LPWSTR   usri4_password;
    DWORD    usri4_password_age;
    DWORD    usri4_priv;
    LPWSTR   usri4_home_dir;
    LPWSTR   usri4_comment;
    DWORD    usri4_flags;
    LPWSTR   usri4_script_path;
    DWORD    usri4_auth_flags;
    LPWSTR   usri4_full_name;
    LPWSTR   usri4_usr_comment;
    LPWSTR   usri4_parms;
    LPWSTR   usri4_workstations;
    DWORD    usri4_last_logon;
    DWORD    usri4_last_logoff;
    DWORD    usri4_acct_expires;
    DWORD    usri4_max_storage;
    DWORD    usri4_units_per_week;
    PBYTE    usri4_logon_hours;
    DWORD    usri4_bad_pw_count;
    DWORD    usri4_num_logons;
    LPWSTR   usri4_logon_server;
    DWORD    usri4_country_code;
    DWORD    usri4_code_page;
    PSID     usri4_user_sid;
    DWORD    usri4_primary_group_id;
    LPWSTR   usri4_profile;
    LPWSTR   usri4_home_dir_drive;
    DWORD    usri4_password_expired;
}USER_INFO_4, *PUSER_INFO_4, *LPUSER_INFO_4;

typedef struct _USER_INFO_10 {
    LPWSTR   usri10_name;
    LPWSTR   usri10_comment;
    LPWSTR   usri10_usr_comment;
    LPWSTR   usri10_full_name;
}USER_INFO_10, *PUSER_INFO_10, *LPUSER_INFO_10;

typedef struct _USER_INFO_11 {
    LPWSTR   usri11_name;
    LPWSTR   usri11_comment;
    LPWSTR   usri11_usr_comment;
    LPWSTR   usri11_full_name;
    DWORD    usri11_priv;
    DWORD    usri11_auth_flags;
    DWORD    usri11_password_age;
    LPWSTR   usri11_home_dir;
    LPWSTR   usri11_parms;
    DWORD    usri11_last_logon;
    DWORD    usri11_last_logoff;
    DWORD    usri11_bad_pw_count;
    DWORD    usri11_num_logons;
    LPWSTR   usri11_logon_server;
    DWORD    usri11_country_code;
    LPWSTR   usri11_workstations;
    DWORD    usri11_max_storage;
    DWORD    usri11_units_per_week;
    PBYTE    usri11_logon_hours;
    DWORD    usri11_code_page;
}USER_INFO_11, *PUSER_INFO_11, *LPUSER_INFO_11;

typedef struct _USER_INFO_20 {
    LPWSTR   usri20_name;
    LPWSTR   usri20_full_name;
    LPWSTR   usri20_comment;
    DWORD    usri20_flags;
    DWORD    usri20_user_id;
}USER_INFO_20, *PUSER_INFO_20, *LPUSER_INFO_20;

typedef struct _USER_INFO_21 {
    BYTE     usri21_password[ENCRYPTED_PWLEN];
}USER_INFO_21, *PUSER_INFO_21, *LPUSER_INFO_21;

typedef struct _USER_INFO_22 {
    LPWSTR   usri22_name;
    BYTE     usri22_password[ENCRYPTED_PWLEN];
    DWORD    usri22_password_age;
    DWORD    usri22_priv;
    LPWSTR   usri22_home_dir;
    LPWSTR   usri22_comment;
    DWORD    usri22_flags;
    LPWSTR   usri22_script_path;
    DWORD    usri22_auth_flags;
    LPWSTR   usri22_full_name;
    LPWSTR   usri22_usr_comment;
    LPWSTR   usri22_parms;
    LPWSTR   usri22_workstations;
    DWORD    usri22_last_logon;
    DWORD    usri22_last_logoff;
    DWORD    usri22_acct_expires;
    DWORD    usri22_max_storage;
    DWORD    usri22_units_per_week;
    PBYTE    usri22_logon_hours;
    DWORD    usri22_bad_pw_count;
    DWORD    usri22_num_logons;
    LPWSTR   usri22_logon_server;
    DWORD    usri22_country_code;
    DWORD    usri22_code_page;
}USER_INFO_22, *PUSER_INFO_22, *LPUSER_INFO_22;

typedef struct _USER_INFO_23 {
    LPWSTR   usri23_name;
    LPWSTR   usri23_full_name;
    LPWSTR   usri23_comment;
    DWORD    usri23_flags;
    PSID     usri23_user_sid;
}USER_INFO_23, *PUSER_INFO_23, *LPUSER_INFO_23;

typedef struct _USER_INFO_1003 {
     LPWSTR  usri1003_password;
} USER_INFO_1003, *PUSER_INFO_1003, *LPUSER_INFO_1003;

typedef struct _USER_INFO_1005 {
     DWORD   usri1005_priv;
} USER_INFO_1005, *PUSER_INFO_1005, *LPUSER_INFO_1005;

typedef struct _USER_INFO_1006 {
     LPWSTR  usri1006_home_dir;
} USER_INFO_1006, *PUSER_INFO_1006, *LPUSER_INFO_1006;

typedef struct _USER_INFO_1007 {
     LPWSTR  usri1007_comment;
} USER_INFO_1007, *PUSER_INFO_1007, *LPUSER_INFO_1007;

typedef struct _USER_INFO_1008 {
     DWORD   usri1008_flags;
} USER_INFO_1008, *PUSER_INFO_1008, *LPUSER_INFO_1008;

typedef struct _USER_INFO_1009 {
     LPWSTR  usri1009_script_path;
} USER_INFO_1009, *PUSER_INFO_1009, *LPUSER_INFO_1009;

typedef struct _USER_INFO_1010 {
     DWORD   usri1010_auth_flags;
} USER_INFO_1010, *PUSER_INFO_1010, *LPUSER_INFO_1010;

typedef struct _USER_INFO_1011 {
     LPWSTR  usri1011_full_name;
} USER_INFO_1011, *PUSER_INFO_1011, *LPUSER_INFO_1011;

typedef struct _USER_INFO_1012 {
     LPWSTR  usri1012_usr_comment;
} USER_INFO_1012, *PUSER_INFO_1012, *LPUSER_INFO_1012;

typedef struct _USER_INFO_1013 {
     LPWSTR  usri1013_parms;
} USER_INFO_1013, *PUSER_INFO_1013, *LPUSER_INFO_1013;

typedef struct _USER_INFO_1014 {
     LPWSTR  usri1014_workstations;
} USER_INFO_1014, *PUSER_INFO_1014, *LPUSER_INFO_1014;

typedef struct _USER_INFO_1017 {
     DWORD   usri1017_acct_expires;
} USER_INFO_1017, *PUSER_INFO_1017, *LPUSER_INFO_1017;

typedef struct _USER_INFO_1018 {
     DWORD   usri1018_max_storage;
} USER_INFO_1018, *PUSER_INFO_1018, *LPUSER_INFO_1018;

typedef struct _USER_INFO_1020 {
    DWORD   usri1020_units_per_week;
    LPBYTE  usri1020_logon_hours;
} USER_INFO_1020, *PUSER_INFO_1020, *LPUSER_INFO_1020;

typedef struct _USER_INFO_1023 {
     LPWSTR  usri1023_logon_server;
} USER_INFO_1023, *PUSER_INFO_1023, *LPUSER_INFO_1023;

typedef struct _USER_INFO_1024 {
     DWORD   usri1024_country_code;
} USER_INFO_1024, *PUSER_INFO_1024, *LPUSER_INFO_1024;

typedef struct _USER_INFO_1025 {
     DWORD   usri1025_code_page;
} USER_INFO_1025, *PUSER_INFO_1025, *LPUSER_INFO_1025;

typedef struct _USER_INFO_1051 {
     DWORD   usri1051_primary_group_id;
} USER_INFO_1051, *PUSER_INFO_1051, *LPUSER_INFO_1051;

typedef struct _USER_INFO_1052 {
     LPWSTR  usri1052_profile;
} USER_INFO_1052, *PUSER_INFO_1052, *LPUSER_INFO_1052;

typedef struct _USER_INFO_1053 {
     LPWSTR  usri1053_home_dir_drive;
} USER_INFO_1053, *PUSER_INFO_1053, *LPUSER_INFO_1053;


//
//  Data Structures - User Modals
//

typedef struct _USER_MODALS_INFO_0 {
    DWORD    usrmod0_min_passwd_len;
    DWORD    usrmod0_max_passwd_age;
    DWORD    usrmod0_min_passwd_age;
    DWORD    usrmod0_force_logoff;
    DWORD    usrmod0_password_hist_len;
}USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;

typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;

typedef struct _USER_MODALS_INFO_2 {
    LPWSTR  usrmod2_domain_name;
    PSID    usrmod2_domain_id;
}USER_MODALS_INFO_2, *PUSER_MODALS_INFO_2, *LPUSER_MODALS_INFO_2;

typedef struct _USER_MODALS_INFO_3 {
    DWORD   usrmod3_lockout_duration;
    DWORD   usrmod3_lockout_observation_window;
    DWORD   usrmod3_lockout_threshold;
}USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;

typedef struct _USER_MODALS_INFO_1001 {
     DWORD   usrmod1001_min_passwd_len;
} USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;

typedef struct _USER_MODALS_INFO_1002 {
     DWORD   usrmod1002_max_passwd_age;
} USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;

typedef struct _USER_MODALS_INFO_1003 {
     DWORD   usrmod1003_min_passwd_age;
} USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;

typedef struct _USER_MODALS_INFO_1004 {
     DWORD   usrmod1004_force_logoff;
} USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;

typedef struct _USER_MODALS_INFO_1005 {
     DWORD   usrmod1005_password_hist_len;
} USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;

typedef struct _USER_MODALS_INFO_1006 {
     DWORD   usrmod1006_role;
} USER_MODALS_INFO_1006, *PUSER_MODALS_INFO_1006, *LPUSER_MODALS_INFO_1006;

typedef struct _USER_MODALS_INFO_1007 {
     LPWSTR  usrmod1007_primary;
} USER_MODALS_INFO_1007, *PUSER_MODALS_INFO_1007, *LPUSER_MODALS_INFO_1007;


//
// Special Values and Constants - User
//

//
//  Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
//

#define UF_SCRIPT                          0x0001
#define UF_ACCOUNTDISABLE                  0x0002
#define UF_HOMEDIR_REQUIRED                0x0008
#define UF_LOCKOUT                         0x0010
#define UF_PASSWD_NOTREQD                  0x0020
#define UF_PASSWD_CANT_CHANGE              0x0040
#define UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED 0x0080

//
// Account type bits as part of usri_flags.
//

#define UF_TEMP_DUPLICATE_ACCOUNT       0x0100
#define UF_NORMAL_ACCOUNT               0x0200
#define UF_INTERDOMAIN_TRUST_ACCOUNT    0x0800
#define UF_WORKSTATION_TRUST_ACCOUNT    0x1000
#define UF_SERVER_TRUST_ACCOUNT         0x2000

#define UF_MACHINE_ACCOUNT_MASK ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
                                  UF_WORKSTATION_TRUST_ACCOUNT | \
                                  UF_SERVER_TRUST_ACCOUNT )

#define UF_ACCOUNT_TYPE_MASK         ( \
                    UF_TEMP_DUPLICATE_ACCOUNT | \
                    UF_NORMAL_ACCOUNT | \
                    UF_INTERDOMAIN_TRUST_ACCOUNT | \
                    UF_WORKSTATION_TRUST_ACCOUNT | \
                    UF_SERVER_TRUST_ACCOUNT \
                )


#define UF_DONT_EXPIRE_PASSWD                         0x10000
#define UF_MNS_LOGON_ACCOUNT                          0x20000
#define UF_SMARTCARD_REQUIRED                         0x40000
#define UF_TRUSTED_FOR_DELEGATION                     0x80000
#define UF_NOT_DELEGATED                             0x100000
#define UF_USE_DES_KEY_ONLY                          0x200000
#define UF_DONT_REQUIRE_PREAUTH                      0x400000
#define UF_PASSWORD_EXPIRED                          0x800000
#define UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION   0x1000000
#define UF_NO_AUTH_DATA_REQUIRED                    0x2000000
#define UF_PARTIAL_SECRETS_ACCOUNT                  0x4000000
#define UF_USE_AES_KEYS                             0x8000000

#define UF_SETTABLE_BITS        ( \
                    UF_SCRIPT | \
                    UF_ACCOUNTDISABLE | \
                    UF_LOCKOUT | \
                    UF_HOMEDIR_REQUIRED  | \
                    UF_PASSWD_NOTREQD | \
                    UF_PASSWD_CANT_CHANGE | \
                    UF_ACCOUNT_TYPE_MASK | \
                    UF_DONT_EXPIRE_PASSWD | \
                    UF_MNS_LOGON_ACCOUNT |\
                    UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED |\
                    UF_SMARTCARD_REQUIRED | \
                    UF_TRUSTED_FOR_DELEGATION | \
                    UF_NOT_DELEGATED | \
                    UF_USE_DES_KEY_ONLY  | \
                    UF_DONT_REQUIRE_PREAUTH |\
                    UF_PASSWORD_EXPIRED |\
                    UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION |\
                    UF_NO_AUTH_DATA_REQUIRED |\
                    UF_USE_AES_KEYS |\
                    UF_PARTIAL_SECRETS_ACCOUNT \
                )

//
// bit masks for the NetUserEnum filter parameter.
//

#define FILTER_TEMP_DUPLICATE_ACCOUNT       (0x0001)
#define FILTER_NORMAL_ACCOUNT               (0x0002)
// #define FILTER_PROXY_ACCOUNT                (0x0004)
#define FILTER_INTERDOMAIN_TRUST_ACCOUNT    (0x0008)
#define FILTER_WORKSTATION_TRUST_ACCOUNT    (0x0010)
#define FILTER_SERVER_TRUST_ACCOUNT         (0x0020)

//
// bit masks for the NetUserGetLocalGroups flags
//
#define LG_INCLUDE_INDIRECT         (0x0001)

//
//  Bit masks for field usri2_auth_flags of USER_INFO_2.
//

#define AF_OP_PRINT             0x1
#define AF_OP_COMM              0x2
#define AF_OP_SERVER            0x4
#define AF_OP_ACCOUNTS          0x8
#define AF_SETTABLE_BITS        (AF_OP_PRINT | AF_OP_COMM | \
                                AF_OP_SERVER | AF_OP_ACCOUNTS)

//
//  UAS role manifests under NETLOGON
//

#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

//
//  Values for ParmError for NetUserSetInfo.
//

#define USER_NAME_PARMNUM               1
#define USER_PASSWORD_PARMNUM           3
#define USER_PASSWORD_AGE_PARMNUM       4
#define USER_PRIV_PARMNUM               5
#define USER_HOME_DIR_PARMNUM           6
#define USER_COMMENT_PARMNUM            7
#define USER_FLAGS_PARMNUM              8
#define USER_SCRIPT_PATH_PARMNUM        9
#define USER_AUTH_FLAGS_PARMNUM         10
#define USER_FULL_NAME_PARMNUM          11
#define USER_USR_COMMENT_PARMNUM        12
#define USER_PARMS_PARMNUM              13
#define USER_WORKSTATIONS_PARMNUM       14
#define USER_LAST_LOGON_PARMNUM         15
#define USER_LAST_LOGOFF_PARMNUM        16
#define USER_ACCT_EXPIRES_PARMNUM       17
#define USER_MAX_STORAGE_PARMNUM        18
#define USER_UNITS_PER_WEEK_PARMNUM     19
#define USER_LOGON_HOURS_PARMNUM        20
#define USER_PAD_PW_COUNT_PARMNUM       21
#define USER_NUM_LOGONS_PARMNUM         22
#define USER_LOGON_SERVER_PARMNUM       23
#define USER_COUNTRY_CODE_PARMNUM       24
#define USER_CODE_PAGE_PARMNUM          25
#define USER_PRIMARY_GROUP_PARMNUM      51
#define USER_PROFILE                    52 // ?? Delete when convenient
#define USER_PROFILE_PARMNUM            52
#define USER_HOME_DIR_DRIVE_PARMNUM     53

//
// the new infolevel counterparts of the old info level + parmnum
//

#define USER_NAME_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_NAME_PARMNUM)
#define USER_PASSWORD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_PARMNUM)
#define USER_PASSWORD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_AGE_PARMNUM)
#define USER_PRIV_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIV_PARMNUM)
#define USER_HOME_DIR_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_PARMNUM)
#define USER_COMMENT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + USER_COMMENT_PARMNUM)
#define USER_FLAGS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_FLAGS_PARMNUM)
#define USER_SCRIPT_PATH_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_SCRIPT_PATH_PARMNUM)
#define USER_AUTH_FLAGS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_AUTH_FLAGS_PARMNUM)
#define USER_FULL_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_FULL_NAME_PARMNUM)
#define USER_USR_COMMENT_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_USR_COMMENT_PARMNUM)
#define USER_PARMS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_PARMS_PARMNUM)
#define USER_WORKSTATIONS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_WORKSTATIONS_PARMNUM)
#define USER_LAST_LOGON_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGON_PARMNUM)
#define USER_LAST_LOGOFF_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGOFF_PARMNUM)
#define USER_ACCT_EXPIRES_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_ACCT_EXPIRES_PARMNUM)
#define USER_MAX_STORAGE_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_MAX_STORAGE_PARMNUM)
#define USER_UNITS_PER_WEEK_INFOLEVEL   \
            (PARMNUM_BASE_INFOLEVEL + USER_UNITS_PER_WEEK_PARMNUM)
#define USER_LOGON_HOURS_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_HOURS_PARMNUM)
#define USER_PAD_PW_COUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PAD_PW_COUNT_PARMNUM)
#define USER_NUM_LOGONS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_NUM_LOGONS_PARMNUM)
#define USER_LOGON_SERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_SERVER_PARMNUM)
#define USER_COUNTRY_CODE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_COUNTRY_CODE_PARMNUM)
#define USER_CODE_PAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_CODE_PAGE_PARMNUM)
#define USER_PRIMARY_GROUP_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM)
#define USER_POSIX_ID_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_POSIX_ID_PARMNUM)
#define USER_HOME_DIR_DRIVE_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_DRIVE_PARMNUM)

//
//  For SetInfo call (parmnum 0) when password change not required
//

#define NULL_USERSETINFO_PASSWD     "              "

#define TIMEQ_FOREVER               ((unsigned long) -1L)
#define USER_MAXSTORAGE_UNLIMITED   ((unsigned long) -1L)
#define USER_NO_LOGOFF              ((unsigned long) -1L)
#define UNITS_PER_DAY               24
#define UNITS_PER_WEEK              UNITS_PER_DAY * 7

//
// Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
//

#define USER_PRIV_MASK      0x3
#define USER_PRIV_GUEST     0
#define USER_PRIV_USER      1
#define USER_PRIV_ADMIN     2

//
// user modals related defaults
//

#define MAX_PASSWD_LEN      PWLEN
#define DEF_MIN_PWLEN       6
#define DEF_PWUNIQUENESS    5
#define DEF_MAX_PWHIST      8

#define DEF_MAX_PWAGE       TIMEQ_FOREVER               // forever
#define DEF_MIN_PWAGE       (unsigned long) 0L          // 0 days
#define DEF_FORCE_LOGOFF    (unsigned long) 0xffffffff  // never
#define DEF_MAX_BADPW       0                           // no limit
#define ONE_DAY             (unsigned long) 01*24*3600  // 01 day

//
// User Logon Validation (codes returned)
//

#define VALIDATED_LOGON         0
#define PASSWORD_EXPIRED        2
#define NON_VALIDATED_LOGON     3

#define VALID_LOGOFF            1

//
// parmnum manifests for user modals
//

#define MODALS_MIN_PASSWD_LEN_PARMNUM       1
#define MODALS_MAX_PASSWD_AGE_PARMNUM       2
#define MODALS_MIN_PASSWD_AGE_PARMNUM       3
#define MODALS_FORCE_LOGOFF_PARMNUM         4
#define MODALS_PASSWD_HIST_LEN_PARMNUM      5
#define MODALS_ROLE_PARMNUM                 6
#define MODALS_PRIMARY_PARMNUM              7
#define MODALS_DOMAIN_NAME_PARMNUM          8
#define MODALS_DOMAIN_ID_PARMNUM            9
#define MODALS_LOCKOUT_DURATION_PARMNUM     10
#define MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM 11
#define MODALS_LOCKOUT_THRESHOLD_PARMNUM    12

//
// the new infolevel counterparts of the old info level + parmnum
//

#define MODALS_MIN_PASSWD_LEN_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_LEN_PARMNUM)
#define MODALS_MAX_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MAX_PASSWD_AGE_PARMNUM)
#define MODALS_MIN_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_AGE_PARMNUM)
#define MODALS_FORCE_LOGOFF_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + MODALS_FORCE_LOGOFF_PARMNUM)
#define MODALS_PASSWD_HIST_LEN_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PASSWD_HIST_LEN_PARMNUM)
#define MODALS_ROLE_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + MODALS_ROLE_PARMNUM)
#define MODALS_PRIMARY_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PRIMARY_PARMNUM)
#define MODALS_DOMAIN_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_NAME_PARMNUM)
#define MODALS_DOMAIN_ID_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_ID_PARMNUM)

#endif // _LMUSER_

//
// Group Class
//

#ifndef _LMGROUP_
#define _LMGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   Username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - Group
//

typedef struct _GROUP_INFO_0 {
    LPWSTR   grpi0_name;
}GROUP_INFO_0, *PGROUP_INFO_0, *LPGROUP_INFO_0;

typedef struct _GROUP_INFO_1 {
    LPWSTR   grpi1_name;
    LPWSTR   grpi1_comment;
}GROUP_INFO_1, *PGROUP_INFO_1, *LPGROUP_INFO_1;

typedef struct _GROUP_INFO_2 {
    LPWSTR   grpi2_name;
    LPWSTR   grpi2_comment;
    DWORD    grpi2_group_id;
    DWORD    grpi2_attributes;
}GROUP_INFO_2, *PGROUP_INFO_2;

typedef struct _GROUP_INFO_3 {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    PSID     grpi3_group_sid;
    DWORD    grpi3_attributes;
}GROUP_INFO_3, *PGROUP_INFO_3;

typedef struct _GROUP_INFO_1002 {
     LPWSTR  grpi1002_comment;
} GROUP_INFO_1002, *PGROUP_INFO_1002, *LPGROUP_INFO_1002;

typedef struct _GROUP_INFO_1005 {
     DWORD  grpi1005_attributes;
} GROUP_INFO_1005, *PGROUP_INFO_1005, *LPGROUP_INFO_1005;


typedef struct _GROUP_USERS_INFO_0 {
     LPWSTR  grui0_name;
} GROUP_USERS_INFO_0, *PGROUP_USERS_INFO_0, *LPGROUP_USERS_INFO_0;

typedef struct _GROUP_USERS_INFO_1 {
     LPWSTR  grui1_name;
     DWORD   grui1_attributes;
} GROUP_USERS_INFO_1, *PGROUP_USERS_INFO_1, *LPGROUP_USERS_INFO_1;

//
// Special Values and Constants - Group
//

#define GROUPIDMASK                 0x8000      // MSB set if uid refers
                                                // to a group

//
// Predefined group for all normal users, administrators and guests
// LOCAL is a special group for pinball local security.
//

#define GROUP_SPECIALGRP_USERS      L"USERS"
#define GROUP_SPECIALGRP_ADMINS     L"ADMINS"
#define GROUP_SPECIALGRP_GUESTS     L"GUESTS"
#define GROUP_SPECIALGRP_LOCAL      L"LOCAL"

//
// parmnum manifests for SetInfo calls (only comment is settable)
//

#define GROUP_ALL_PARMNUM           0
#define GROUP_NAME_PARMNUM          1
#define GROUP_COMMENT_PARMNUM       2
#define GROUP_ATTRIBUTES_PARMNUM    3

//
// the new infolevel counterparts of the old info level + parmnum
//

#define GROUP_ALL_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM)
#define GROUP_NAME_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM)
#define GROUP_COMMENT_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM)
#define GROUP_ATTRIBUTES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM)
#define GROUP_POSIX_ID_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM)

#endif  // _LMGROUP_

//
// LocalGroup Class
//

#ifndef _LMLOCALGROUP_
#define _LMLOCALGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     localgroupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR resumehandle
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - LocalGroup
//

typedef struct _LOCALGROUP_INFO_0 {
    LPWSTR   lgrpi0_name;
}LOCALGROUP_INFO_0, *PLOCALGROUP_INFO_0, *LPLOCALGROUP_INFO_0;

typedef struct _LOCALGROUP_INFO_1 {
    LPWSTR   lgrpi1_name;
    LPWSTR   lgrpi1_comment;
}LOCALGROUP_INFO_1, *PLOCALGROUP_INFO_1, *LPLOCALGROUP_INFO_1;

typedef struct _LOCALGROUP_INFO_1002 {
     LPWSTR  lgrpi1002_comment;
}LOCALGROUP_INFO_1002, *PLOCALGROUP_INFO_1002, *LPLOCALGROUP_INFO_1002;

typedef struct _LOCALGROUP_MEMBERS_INFO_0 {
     PSID    lgrmi0_sid;
} LOCALGROUP_MEMBERS_INFO_0, *PLOCALGROUP_MEMBERS_INFO_0,
  *LPLOCALGROUP_MEMBERS_INFO_0;

typedef struct _LOCALGROUP_MEMBERS_INFO_1 {
     PSID         lgrmi1_sid;
     SID_NAME_USE lgrmi1_sidusage;
     LPWSTR       lgrmi1_name;
} LOCALGROUP_MEMBERS_INFO_1, *PLOCALGROUP_MEMBERS_INFO_1,
  *LPLOCALGROUP_MEMBERS_INFO_1;

typedef struct _LOCALGROUP_MEMBERS_INFO_2 {
     PSID         lgrmi2_sid;
     SID_NAME_USE lgrmi2_sidusage;
     LPWSTR       lgrmi2_domainandname;
} LOCALGROUP_MEMBERS_INFO_2, *PLOCALGROUP_MEMBERS_INFO_2,
  *LPLOCALGROUP_MEMBERS_INFO_2;

typedef struct _LOCALGROUP_MEMBERS_INFO_3 {
     LPWSTR       lgrmi3_domainandname;
} LOCALGROUP_MEMBERS_INFO_3, *PLOCALGROUP_MEMBERS_INFO_3,
  *LPLOCALGROUP_MEMBERS_INFO_3;

typedef struct _LOCALGROUP_USERS_INFO_0 {
     LPWSTR  lgrui0_name;
} LOCALGROUP_USERS_INFO_0, *PLOCALGROUP_USERS_INFO_0,
  *LPLOCALGROUP_USERS_INFO_0;


#define LOCALGROUP_NAME_PARMNUM          1
#define LOCALGROUP_COMMENT_PARMNUM       2

//
// Display Information APIs
//

NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Index,
    IN DWORD EntriesRequested,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer );

NET_API_STATUS NET_API_FUNCTION
NetGetDisplayInformationIndex(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPCWSTR Prefix,
    OUT LPDWORD Index );

//
// QueryDisplayInformation levels

typedef struct _NET_DISPLAY_USER {
    LPWSTR   usri1_name;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_full_name;
    DWORD    usri1_user_id;
    DWORD    usri1_next_index;
} NET_DISPLAY_USER, *PNET_DISPLAY_USER;

typedef struct _NET_DISPLAY_MACHINE {
    LPWSTR   usri2_name;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    DWORD    usri2_user_id;
    DWORD    usri2_next_index;
} NET_DISPLAY_MACHINE, *PNET_DISPLAY_MACHINE;

typedef struct _NET_DISPLAY_GROUP {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    DWORD    grpi3_group_id;
    DWORD    grpi3_attributes;
    DWORD    grpi3_next_index;
} NET_DISPLAY_GROUP, *PNET_DISPLAY_GROUP;

#endif  // _LMLOCALGROUP_

//
// Access Class
//

#ifndef _LMACCESS_
#define _LMACCESS_



//
// Function Prototypes - Access
//

NET_API_STATUS NET_API_FUNCTION
NetAccessAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     BasePath,
    IN  DWORD      Recursive,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessGetUserPerms (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   UGname,
    IN  LPCWSTR   resource,
    OUT LPDWORD  Perms
    );

//
// Data Structures - Access
//

typedef struct _ACCESS_INFO_0 {
    LPWSTR   acc0_resource_name;
}ACCESS_INFO_0, *PACCESS_INFO_0, *LPACCESS_INFO_0;

typedef struct _ACCESS_INFO_1 {
    LPWSTR   acc1_resource_name;
    DWORD    acc1_attr;
    DWORD    acc1_count;
}ACCESS_INFO_1, *PACCESS_INFO_1, *LPACCESS_INFO_1;

typedef struct _ACCESS_INFO_1002 {
     DWORD   acc1002_attr;
} ACCESS_INFO_1002, *PACCESS_INFO_1002, *LPACCESS_INFO_1002;


typedef struct _ACCESS_LIST {
    LPWSTR   acl_ugname;
    DWORD    acl_access;
}ACCESS_LIST, *PACCESS_LIST, *LPACCESS_LIST;

//
// Special Values and Constants - Access
//

//
// Maximum number of permission entries for each resource.
//

#define MAXPERMENTRIES      64

//
//  Bit values for the access permissions.  ACCESS_ALL is a handy
//  way to specify maximum permissions.  These are used in
//  acl_access field of access_list structures.
//

#define ACCESS_NONE         0
#define ACCESS_ALL          ( ACCESS_READ | \
                                ACCESS_WRITE | \
                                ACCESS_CREATE | \
                                ACCESS_EXEC | \
                                ACCESS_DELETE | \
                                ACCESS_ATRIB | \
                                ACCESS_PERM \
                            )

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02
#define ACCESS_CREATE       0x04
#define ACCESS_EXEC         0x08
#define ACCESS_DELETE       0x10
#define ACCESS_ATRIB        0x20
#define ACCESS_PERM         0x40

#define ACCESS_GROUP        0x8000

//
// Bit values for the acc1_attr field of the ACCESS_INFO_1 structure.
//

#define ACCESS_AUDIT        0x1

#define ACCESS_SUCCESS_OPEN         0x10
#define ACCESS_SUCCESS_WRITE        0x20
#define ACCESS_SUCCESS_DELETE       0x40
#define ACCESS_SUCCESS_ACL          0x80
#define ACCESS_SUCCESS_MASK         0xF0

#define ACCESS_FAIL_OPEN            0x100
#define ACCESS_FAIL_WRITE           0x200
#define ACCESS_FAIL_DELETE          0x400
#define ACCESS_FAIL_ACL             0x800
#define ACCESS_FAIL_MASK            0xF00

#define ACCESS_FAIL_SHIFT           4

//
// Parmnum value for NetAccessSetInfo.
//

#define ACCESS_RESOURCE_NAME_PARMNUM    1
#define ACCESS_ATTR_PARMNUM             2
#define ACCESS_COUNT_PARMNUM            3
#define ACCESS_ACCESS_LIST_PARMNUM      4

//
// the new infolevel counterparts of the old info level + parmnum
//

#define ACCESS_RESOURCE_NAME_INFOLEVEL  \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_RESOURCE_NAME_PARMNUM)
#define ACCESS_ATTR_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ATTR_PARMNUM)
#define ACCESS_COUNT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_COUNT_PARMNUM)
#define ACCESS_ACCESS_LIST_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ACCESS_LIST_PARMNUM)

//
// ACCESS_LETTERS defines a letter for each bit position in
// the acl_access field of struct access_list.  Note that some
// bits have a corresponding letter of ' ' (space).
//

#define ACCESS_LETTERS      "RWCXDAP         "



//    ********************************
//
//    Password Checking API structures
//
//    ********************************


//
//    What kind of password checking is to be performed?
//        NetValidateAuthentication : Check if the authentication can be done
//        NetValidatePasswordChange: Check if the password can be changed
//        NetValidatePasswordReset: Reset the password to the given value
//
typedef enum _NET_VALIDATE_PASSWORD_TYPE{
    NetValidateAuthentication = 1,
    NetValidatePasswordChange,
    NetValidatePasswordReset
} NET_VALIDATE_PASSWORD_TYPE, *PNET_VALIDATE_PASSWORD_TYPE;

//
//    Structure to keep the password hash
//
typedef struct _NET_VALIDATE_PASSWORD_HASH{
    ULONG Length;
    LPBYTE Hash;
} NET_VALIDATE_PASSWORD_HASH, *PNET_VALIDATE_PASSWORD_HASH;

// To be used with PresentFields member of NET_VALIDATE_PERSISTED_FIELDS
#define NET_VALIDATE_PASSWORD_LAST_SET          0x00000001
#define NET_VALIDATE_BAD_PASSWORD_TIME          0x00000002
#define NET_VALIDATE_LOCKOUT_TIME               0x00000004
#define NET_VALIDATE_BAD_PASSWORD_COUNT         0x00000008
#define NET_VALIDATE_PASSWORD_HISTORY_LENGTH    0x00000010
#define NET_VALIDATE_PASSWORD_HISTORY           0x00000020

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME, *PFILETIME;
#endif

//
//    Structure to keep information about the password and related things.
//        Present Fields: (used only in output args) which fields are changed.
//            See the constants above.
//        PasswordLastSet: When the password is last set.
//        BadPasswordTime: When the password was incorrect for the last time.
//        LockoutTime: When the account is locked out. If the account is not locked out
//            it is 0.
//        BadPasswordCount: How many times the password has given incorrectly in the
//            Observation Window.
//        PasswordHistoryLength: How many passwords are kept in the history
//        PasswordHistory: Password hashes that are in the history
//
typedef struct _NET_VALIDATE_PERSISTED_FIELDS{
    ULONG   PresentFields;
    FILETIME PasswordLastSet;
    FILETIME BadPasswordTime;
    FILETIME LockoutTime;
    ULONG   BadPasswordCount;
    ULONG   PasswordHistoryLength;
    PNET_VALIDATE_PASSWORD_HASH PasswordHistory;
} NET_VALIDATE_PERSISTED_FIELDS, *PNET_VALIDATE_PERSISTED_FIELDS;

//
//    Output Arg
//        ChangedPersistedFields: Any changes to the password related info
//        ValidationStatus: Shows the result of the request
//
typedef struct _NET_VALIDATE_OUTPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS ChangedPersistedFields;
    NET_API_STATUS ValidationStatus;
} NET_VALIDATE_OUTPUT_ARG, *PNET_VALIDATE_OUTPUT_ARG;

//
//    If authentication type of password check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    PasswordMatched: Indicates the result of the application's authentication of the supplied password
//
typedef struct _NET_VALIDATE_AUTHENTICATION_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    BOOLEAN PasswordMatched;
} NET_VALIDATE_AUTHENTICATION_INPUT_ARG, *PNET_VALIDATE_AUTHENTICATION_INPUT_ARG;

//
//    If password change type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMatch: denotes if the old password supplied by user matched or not
//
typedef struct  _NET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    LPWSTR ClearPassword;
    LPWSTR UserAccountName;
    NET_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMatch;
} NET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG, *PNET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;

//
//    If password reset type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMustChangeAtNextLogon: Password must change for the user to be logged in
//    ClearLockout: If the account was locked out, this field can be used to clear lockout
//
typedef struct _NET_VALIDATE_PASSWORD_RESET_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    LPWSTR ClearPassword;
    LPWSTR UserAccountName;
    NET_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN  PasswordMustChangeAtNextLogon;
    BOOLEAN  ClearLockout;
} NET_VALIDATE_PASSWORD_RESET_INPUT_ARG, *PNET_VALIDATE_PASSWORD_RESET_INPUT_ARG;

//
//    Password Checking API structures end here
//

NET_API_STATUS NET_API_FUNCTION
NetValidatePasswordPolicy(
    IN LPCWSTR ServerName,
    IN LPVOID Qualifier,
    IN NET_VALIDATE_PASSWORD_TYPE ValidationType,
    IN LPVOID InputArg,
    OUT LPVOID *OutputArg
    );

NET_API_STATUS NET_API_FUNCTION
NetValidatePasswordPolicyFree(
    IN LPVOID *OutputArg
    );

#endif // _LMACCESS_

//
// Domain Class
//

#ifndef _LMDOMAIN_
#define _LMDOMAIN_

//
// Function Prototypes - Domain
//

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    __in_opt IN  LPCWSTR   servername OPTIONAL,
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    __in_opt IN  LPCWSTR   servername OPTIONAL,
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *Buffer
    );

NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE Data,
    OUT LPBYTE *Buffer
    );

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

NTSTATUS NET_API_FUNCTION
NetEnumerateTrustedDomains (
    __in_opt IN LPWSTR ServerName OPTIONAL,
    __deref_out OUT LPWSTR *DomainNames
    );



//
// Special Values and Constants - Domain
//

//
// FunctionCode values for I_NetLogonControl.
//
// NOTE : if you change the following NETLOGON_CONTROL_* values,
// change them in net\svcdlls\logonsrv\logon.idl file also.
//

#define NETLOGON_CONTROL_QUERY         1    // No-op: just query
#define NETLOGON_CONTROL_REPLICATE     2    // Force replicate on BDC
#define NETLOGON_CONTROL_SYNCHRONIZE   3    // Force synchronize on BDC
#define NETLOGON_CONTROL_PDC_REPLICATE 4    // Force PDC to broadcast change
#define NETLOGON_CONTROL_REDISCOVER    5    // Force to re-discover trusted domain DCs
#define NETLOGON_CONTROL_TC_QUERY      6    // Query status of specified trusted channel status
#define NETLOGON_CONTROL_TRANSPORT_NOTIFY 7 // Notify netlogon that a new transport has come online
#define NETLOGON_CONTROL_FIND_USER     8    // Find named user in a trusted domain
#define NETLOGON_CONTROL_CHANGE_PASSWORD 9  // Change machine password on a secure channel to a trusted domain
#define NETLOGON_CONTROL_TC_VERIFY     10   // Verify status of specified trusted channel
#define NETLOGON_CONTROL_FORCE_DNS_REG 11   // Force DNS re-registration of all registered records
#define NETLOGON_CONTROL_QUERY_DNS_REG 12   // Query the status of DNS updates

// Debug function codes

#define NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL 0xFFFB
#define NETLOGON_CONTROL_BACKUP_CHANGE_LOG  0xFFFC
#define NETLOGON_CONTROL_TRUNCATE_LOG       0xFFFD
#define NETLOGON_CONTROL_SET_DBFLAG         0xFFFE
#define NETLOGON_CONTROL_BREAKPOINT         0xFFFF

//
// Query level 1 for I_NetLogonControl
//

typedef struct _NETLOGON_INFO_1 {
        DWORD netlog1_flags;
        NET_API_STATUS netlog1_pdc_connection_status;
} NETLOGON_INFO_1, *PNETLOGON_INFO_1;

typedef struct _NETLOGON_INFO_2 {
        DWORD netlog2_flags;

        //
        // If NETLOGON_VERIFY_STATUS_RETURNED bit is set in
        //  netlog2_flags, the following field will return
        //  the status of trust verification. Otherwise,
        //  the field will return the status of the secure
        //  channel to the primary domain of the machine
        //  (useful for BDCs only).
        //
        NET_API_STATUS netlog2_pdc_connection_status;
#ifdef MIDL_PASS
        [string] wchar_t * netlog2_trusted_dc_name;
#else
        LPWSTR netlog2_trusted_dc_name;
#endif // MIDL_PASS
        NET_API_STATUS netlog2_tc_connection_status;
} NETLOGON_INFO_2, *PNETLOGON_INFO_2;

typedef struct _NETLOGON_INFO_3 {
        DWORD netlog3_flags;
        DWORD netlog3_logon_attempts;
        DWORD netlog3_reserved1;
        DWORD netlog3_reserved2;
        DWORD netlog3_reserved3;
        DWORD netlog3_reserved4;
        DWORD netlog3_reserved5;
} NETLOGON_INFO_3, *PNETLOGON_INFO_3;

typedef struct _NETLOGON_INFO_4 {
#ifdef MIDL_PASS
        [string] wchar_t * netlog4_trusted_dc_name;
        [string] wchar_t * netlog4_trusted_domain_name;
#else
        LPWSTR netlog4_trusted_dc_name;
        LPWSTR netlog4_trusted_domain_name;
#endif // MIDL_PASS
} NETLOGON_INFO_4, *PNETLOGON_INFO_4;

//
// Values of netlog1_flags
//

#define NETLOGON_REPLICATION_NEEDED       0x01  // Database is out of date
#define NETLOGON_REPLICATION_IN_PROGRESS  0x02  // Replication is happening now
#define NETLOGON_FULL_SYNC_REPLICATION    0x04  // full sync replication required/progress
#define NETLOGON_REDO_NEEDED              0x08  // Redo of previous replication needed
#define NETLOGON_HAS_IP                   0x10  // The trusted domain DC has an IP address
#define NETLOGON_HAS_TIMESERV             0x20  // The trusted domain DC runs the Windows Time Service
#define NETLOGON_DNS_UPDATE_FAILURE       0x40  // There was a failure in the last update for one of the DNS records
#define NETLOGON_VERIFY_STATUS_RETURNED   0x80  // Trust verification status returned in netlog2_pdc_connection_status

#define SERVICE_ACCOUNT_PASSWORD TEXT("_SA_{262E99C9-6160-4871-ACEC-4E61736B6F21}")
#define SERVICE_ACCOUNT_SECRET_PREFIX TEXT("_SC_{262E99C9-6160-4871-ACEC-4E61736B6F21}_")

DEFINE_GUID( //262e99c9-6160-4871-acec-4e61736b6f21
    ServiceAccountPasswordGUID,
    0x262E99C9,
    0x6160,
    0x4871,
    0xAC, 0xEC, 0x4E, 0x61, 0x73, 0x6B, 0x6F, 0x21 );

NTSTATUS
NetAddServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in LPWSTR Reserved,
    __in DWORD Flags);
    
// Do not create an account by this name
// Only link this account to my computer if it exists
#define SERVICE_ACCOUNT_FLAG_LINK_TO_HOST_ONLY    0x00000001L

// Do not delete the service account object from AD
// Simply unlink it from this computer and delete the local secret
#define SERVICE_ACCOUNT_FLAG_UNLINK_FROM_HOST_ONLY    0x00000001L

NTSTATUS
NetRemoveServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in DWORD Flags);

NTSTATUS
NetEnumerateServiceAccounts(
    __in_opt LPWSTR ServerName,
    __in DWORD Flags,
    __out DWORD* AccountsCount,
    __deref_out_ecount(*AccountsCount) PZPWSTR* Accounts);
    
NTSTATUS
NetIsServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __out BOOL *IsService);

NTSTATUS
NetQueryServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in DWORD InfoLevel,
    __deref_out PBYTE* Buffer);

//
//  Data Structures - Service
//

typedef enum _MSA_INFO_LEVEL {
    MsaInfoLevel0 = 0,
    MsaInfoLevelMax
} MSA_INFO_LEVEL, *PMSA_INFO_LEVEL;

typedef enum _MSA_INFO_STATE {
    MsaInfoNotExist = 1,
    MsaInfoNotService,
    MsaInfoCannotInstall,
    MsaInfoCanInstall,
    MsaInfoInstalled
}MSA_INFO_STATE, *PMSA_INFO_STATE;

typedef struct _MSA_INFO_0 {
    MSA_INFO_STATE State;
}MSA_INFO_0, *PMSA_INFO_0, *LPMSA_INFO_0;

#ifdef __cplusplus
}
#endif

#endif // _LMDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\listeneradapter.h ===
/*++

Copyright (c) 1998-2005 Microsoft Corporation

Module Name:

    listeneradapter.h

Abstract:

    The exported routines for the wbhstipm dll.

--*/

#ifndef _LISTENER_ADAPTER_H_
#define _LISTENER_ADAPTER_H_


#ifdef __cplusplus
extern "C" {
#endif

//
//
//
// Enumerations
//

//
// callback function definitions
//

//
// *** Config Manager Callback functions ***
//

//
// Notifies the listener adapter that the configuration
// manager has connected.  After this call the listener
// adapter can expect configuration notifications to fire so 
// it can setup the listener to wait on incoming requests.   
// This notification will always proceed any configuration 
// notifications, and is a signal that they listener adapter
// should be in a clean state and ready to receive new
// configuration.
//
// WAS does not wait on the completion of this notification.
// 
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_CONNECTED)(
    IN VOID * pContext
    );

//
// Notifies the listener adapter that the WAS service
// has disconnected.  This may happen if WAS were to 
// crash.  In this case, the listener adapter is expected
// to cleanup everything that WAS configured.  Once WAS
// restarts it will provide any running listener adapters
// with configuration info again, so the listener adapter
// has to prepare to be re-configured.
//
// WAS does not wait on the completion of this notification.
// 
// 
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_DISCONNECT)(
    IN VOID * pContext,
    IN HRESULT hr
    );


//
// Notifies a listener adapter that WAS has completed passing
// all configuration for the service.  No more configuration
// will be passed until change notifications cause it.  At this
// point a listener adapter should activate all configured
// applications, not before.  Before this notification the listener
// adapter may have partial configuration data and may mis-route
// due to not realizing that another application that changes
// the routing exists.  It is also at this point that a service
// waiting on all applications and app pools to be configured
// can declare itself started.
//
// WAS does not wait on the completion of this notification.
// 
//
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_INITIALIZATION_COMPLETED)(
    IN VOID * pContext
    );


//
// *** App Pool Callback functions ***
//

//
// The application in the eyes of this listener adapter
// has been created.  In other words, an application that
// wants to participate in this app pool has been configured
// to use this protocol.  
//
// WAS does not wait on the completion of this notification.
//

typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_CREATED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN PSID    PSID
    );

//
// A notification the the app pool in the eyes of this
// listener is being deleted.  Once this call completes,
// the listener adapter should be capable of creating
// this app pool again should it be told to.  
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_DELETED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId
    );

//
// A notification that worker processes running 
// under this app pool will be running with a new
// identity.  
//
// WAS does wait on the completion of this notification.
//
// Once all all of the listener adapters have completed 
// this notification any recycles neccessary will be 
// performed, and worker processes will again be able to launch.  
// A listener adapter blocking on this routine can block 
// all others in the app pool from starting worker processes.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_IDENTITY_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN PSID    PSID
    );

//
// Notify's a listener adapter that the state of an
// app pool has changed.  Either the app pool is now capable
// of launching and running worker processes, or the app 
// pool is now disabled and will not run worker processes.
// 
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_STATE_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN BOOL    fIsEnabled
    );

//
// Notify's a listener adapter that it is possible to 
// launch other instances of this listener channel.  The listener
// adapter should call start listener channel when it receives the 
// next request to be processed.  The listener adapter
// should not call start listener channel after that until it is
// once again told to through this function.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_CAN_OPEN_NEW_LISTENER_CHANNEL_INSTANCE)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN DWORD ListenerChannelId
    );

//
// Notify's a listener adapter that all instances of a particular
// listener channel have been stopped.  During shutdown a listener adapter
// should wait on this before stopping, otherwise restarting
// may have problems, with listener channels all ready being in use.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_ALL_LISTENER_CHANNEL_INSTANCES_STOPPED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN DWORD ListenerChannelId
    );

//
// *** App Pool Callback functions ***
//

//
// Notifies the listener adapter that an application exists in
// the eyes of this listener adapter.  Whether the listener 
// adapter chooses to configure this application with the listener
// is up to the listener adapter.  The RequestsBlocked value tells the
// listener adapter that while you should listen on this application
// you should not process requests.  It is to block requests from going
// to parent applications because the child does not support the
// protocol.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_CREATED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN LPCWSTR Path,
    IN DWORD   SiteId,
    IN LPCWSTR AppPoolId,
    IN PBYTE   Bindings,
    IN DWORD   NumberOfBindings,
    IN BOOL    RequestsBlocked
    );

//
// Notifies the listener adapter that the application no longer
// should exist in the listener adapters eyes.  This may mean
// that the application was deleted, or that all applications for
// this site no longer use this protocol.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_DELETED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey
    );

//
// Notifies the listener adapter that the bindings for a particular
// application have changed.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_BINDINGS_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN PBYTE   Bindings,
    IN DWORD   NumberOfBindings
    );

//
// Notifies the listener adapter that the app pool for a particular
// application have changed.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_APP_POOL_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN LPCWSTR AppPoolId
    );

//
// Notifies the listener adapter that it should either no longer
// reject requests for the application, or that it should start
// rejecting requests for the application.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_REQUESTS_BLOCKED_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN BOOL    RequestsBlocked
    );

//
// Callback structure
//
struct WEBHOST_LISTENER_CALLBACKS
{
    DWORD                                                                         dwBytesInCallbackStructure;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_CONNECTED                                 pfnWebhostListenerConfigManagerConnected;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_DISCONNECT                                pfnWebhostListenerConfigManagerDisconnected;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_INITIALIZATION_COMPLETED                  pfnWebhostListenerConfigManagerInitializationCompleted;

    PFN_WEBHOST_LISTENER_APPLICATION_POOL_CREATED                                 pfnWebhostListenerApplicationPoolCreated;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_DELETED                                 pfnWebhostListenerApplicationPoolDeleted;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_IDENTITY_CHANGED                        pfnWebhostListenerApplicationPoolIdentityChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_STATE_CHANGED                           pfnWebhostListenerApplicationPoolStateChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_CAN_OPEN_NEW_LISTENER_CHANNEL_INSTANCE  pfnWebhostListenerApplicationPoolCanOpenNewListenerChannelInstance;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_ALL_LISTENER_CHANNEL_INSTANCES_STOPPED  pfnWebhostListenerApplicationPoolAllListenerChannelInstancesStopped;

    PFN_WEBHOST_LISTENER_APPLICATION_CREATED                                      pfnWebhostListenerApplicationCreated;
    PFN_WEBHOST_LISTENER_APPLICATION_DELETED                                      pfnWebhostListenerApplicationDeleted;
    PFN_WEBHOST_LISTENER_APPLICATION_BINDINGS_CHANGED                             pfnWebhostListenerApplicationBindingsChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_APP_POOL_CHANGED                             pfnWebhostListenerApplicationAppPoolChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_REQUESTS_BLOCKED_CHANGED                     pfnWebhostListenerApplicationRequestsBlockedChanged;
};

//
// exported functions
//

//
// Webhost client can call to determine
// the version of webhost it is running 
// against.  This information will allow 
// it to understand what exported functions
// it should expect.
//
HRESULT
WebhostGetVersion(
    OUT DWORD* pMajorVersion,
    OUT DWORD* pMinorVersion
    );

//
// Registers a protocol for WAS to honor
// when it is running.  The ProtocolHandle returned
// can be used to activate other calls against
// the registered protocol.
//
// pListenerCallbacks will be 
//
HRESULT
WebhostRegisterProtocol(
    IN LPCWSTR ProtocolId,
    IN VOID*   pListenerCallbacks,
    IN VOID *  pContext,
    OUT DWORD* pProtocolHandle
    );

//
// Before a protocol goes down, it should first 
// stop any listener channels that were running, and wait for
// those listener channels to stop (detemined through private means).
// Then it should unregister the protocol with the W3SVC
// client library.
//
HRESULT
WebhostUnregisterProtocol(
    IN DWORD   ProtocolHandle
    );

//
// This will request a listener channel be started in a 
// worker process for this app pool.  
//
// It is a failure to call if the client
// library is not in a connected state.
//
HRESULT
WebhostOpenListenerChannelInstance(
    IN DWORD   ProtocolHandle,
    IN LPCWSTR AppPoolId,
    IN DWORD   ListenerChannelId,
    IN PBYTE   ListenerChannelBlob,
    IN DWORD   ListenerChannelBlobByteCount
    );

//
// Function will stop all instances of
// this listener channel.  It is not a failure to call
// with no listener channels running.  It is a failure
// to call if not in a connected state.
//
HRESULT
WebhostCloseAllListenerChannelInstances(
    IN DWORD   ProtocolHandle,
    IN LPCWSTR AppPoolId,
    IN DWORD   ListenerChannelId
    );

//
// =========================================================================================
//


#ifdef __cplusplus
}
#endif

#endif  // _LISTENER_ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMMsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmmsg.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetMessage API.

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMMSG_
#define _LMMSG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    __in_opt  LPCWSTR  servername,
    __in      DWORD    level,
    __in      LPBYTE  *bufptr,
    __in      DWORD    prefmaxlen,
    __out     LPDWORD  entriesread,
    __out     LPDWORD  totalentries,
    __out     LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname,
    __in      DWORD    level,
    __in      LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    __in_opt  LPCWSTR servername,
    __in      LPCWSTR msgname,
    __in      LPCWSTR fromname,
    __in      LPBYTE  buf,
    __in      DWORD   buflen
    );

//
//  Data Structures
//

typedef struct _MSG_INFO_0 {
    LPWSTR  msgi0_name;
}MSG_INFO_0, *PMSG_INFO_0, *LPMSG_INFO_0;

typedef struct _MSG_INFO_1 {
    LPWSTR  msgi1_name;
    DWORD   msgi1_forward_flag;
    LPWSTR  msgi1_forward;
}MSG_INFO_1, *PMSG_INFO_1, *LPMSG_INFO_1;

//
// Special Values and Constants
//

//
// Values for msgi1_forward_flag.
//

#define MSGNAME_NOT_FORWARDED   0       // Name not forwarded
#define MSGNAME_FORWARDED_TO    0x04    // Name forward to remote station
#define MSGNAME_FORWARDED_FROM  0x10    // Name forwarded from remote station

#ifdef __cplusplus
}
#endif

#endif //_LMMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMDFS.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmdfs.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetDfs API

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

#ifndef _LMDFS_
#define _LMDFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// DFS Volume state
//

#define DFS_VOLUME_STATES              0xF

#define DFS_VOLUME_STATE_OK            1
#define DFS_VOLUME_STATE_INCONSISTENT  2
#define DFS_VOLUME_STATE_OFFLINE       3
#define DFS_VOLUME_STATE_ONLINE        4

//
// These are valid for setting the volume state on the root
// These are available to force a resynchronize on the root
// volume or to put it in a standby mode.
//
#define DFS_VOLUME_STATE_RESYNCHRONIZE 0x10
#define DFS_VOLUME_STATE_STANDBY       0x20

//
//  When supported by a DFS namespace, the local state on
//  the DFS root target is refreshed with information from
//  the master state in the DFS metadata forcibly.
//

#define DFS_VOLUME_STATE_FORCE_SYNC  0x40

//
// These are valid on getting the volume state on the root
// These are available to determine the flavor of DFS
// A few bits are reserved to determine the flavor of the DFS root.
// To get the flavor, and the state with DFS_VOLUME_FLAVORS.
//
// (_state & DFS_VOLUME_FLAVORS) will tell you the flavor of the dfs root.
//
//

#define DFS_VOLUME_FLAVORS           0x0300


#define DFS_VOLUME_FLAVOR_UNUSED1    0x0000
#define DFS_VOLUME_FLAVOR_STANDALONE 0x0100
#define DFS_VOLUME_FLAVOR_AD_BLOB    0x0200
#define DFS_STORAGE_FLAVOR_UNUSED2   0x0300

//
// DFS Storage State
//

#define DFS_STORAGE_STATES            0xF
#define DFS_STORAGE_STATE_OFFLINE      1
#define DFS_STORAGE_STATE_ONLINE       2
#define DFS_STORAGE_STATE_ACTIVE       4


//
// Priority of a DFS target consists of the
// tuple <priority class, priority rank>. Priority
// ranks are valid only within a priority class and
// not across priority classes.
// Priority rank is 0-n, where 0 is highest rank.
//
// We have consciously chosen 0 to indicate the
// "normal" priority class, i.e. one that would
// be used if target priorities aren't used.
//
// The members of the enumeration have been explicitly
// set in a specific order (in the enumeration).
//
// We need the MIDL_PASS decoration to force sending
// the enums as 32-bit values instead of the default
// 16-bit values for enums. 
//

#ifdef  MIDL_PASS
typedef [v1_enum] enum _DFS_TARGET_PRIORITY_CLASS {
#else
typedef enum _DFS_TARGET_PRIORITY_CLASS {
#endif
    DfsInvalidPriorityClass = -1,
    DfsSiteCostNormalPriorityClass = 0,
    DfsGlobalHighPriorityClass,
    DfsSiteCostHighPriorityClass,
    DfsSiteCostLowPriorityClass,
    DfsGlobalLowPriorityClass
} DFS_TARGET_PRIORITY_CLASS;

typedef struct _DFS_TARGET_PRIORITY {
    DFS_TARGET_PRIORITY_CLASS   TargetPriorityClass;    // Priority class of target.
    USHORT                      TargetPriorityRank;     // Priority rank of target.
    USHORT                      Reserved;               // Must be set to 0.
} DFS_TARGET_PRIORITY, *PDFS_TARGET_PRIORITY;

//
// Level 1:
//
typedef struct _DFS_INFO_1 {
    LPWSTR  EntryPath;              // Dfs name for the top of this piece of storage
} DFS_INFO_1, *PDFS_INFO_1, *LPDFS_INFO_1;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_1_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
} DFS_INFO_1_32, *PDFS_INFO_1_32, *LPDFS_INFO_1_32;

#endif  /* _WIN64   */

//
// Level 2:
//
typedef struct _DFS_INFO_2 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storages for this volume
} DFS_INFO_2, *PDFS_INFO_2, *LPDFS_INFO_2;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_2_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_2_32, *PDFS_INFO_2_32, *LPDFS_INFO_2_32;

#endif  /* _WIN64   */

typedef struct _DFS_STORAGE_INFO {
    ULONG   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    LPWSTR  ServerName;             // Name of server hosting this storage
    LPWSTR  ShareName;              // Name of share hosting this storage
} DFS_STORAGE_INFO, *PDFS_STORAGE_INFO, *LPDFS_STORAGE_INFO;

#if defined(_WIN64)

//
// We should be calling this structure DFS_STORAGE_INFO_32 as per
// convention. However, we don't want to pollute the namespace of new
// types that have been defined (for example, DFS_STORAGE_INFO_1) as
// enhancements to the "base" DFS_STORAGE_INFO structure. Hence,
// we define the WOW64 support structure as DFS_STORAGE_INFO_0_32.
//

typedef struct _DFS_STORAGE_INFO_0_32 {
    ULONG   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    ULONG   ServerName;             // Name of server hosting this storage
    ULONG   ShareName;              // Name of share hosting this storage
} DFS_STORAGE_INFO_0_32, *PDFS_STORAGE_INFO_0_32, *LPDFS_STORAGE_INFO_0_32;

#endif  // _WIN64.

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_STORAGE_INFO_1 {
    ULONG                   State;          // State of this target, one of DFS_TARGET_STATE_*
                                            // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    LPWSTR                  ServerName;     // Name of server hosting this target
    LPWSTR                  ShareName;      // Name of share hosting this target
    DFS_TARGET_PRIORITY     TargetPriority; // Priority of this target.
} DFS_STORAGE_INFO_1, *PDFS_STORAGE_INFO_1, *LPDFS_STORAGE_INFO_1;

//
// Level 3:
//
typedef struct _DFS_INFO_3 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of
                                    //      storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_3, *PDFS_INFO_3, *LPDFS_INFO_3;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_3_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
    ULONG   Storage;                // An array (of NumberOfStorages elements) of
                                    //      storage-specific information. Each element
                                    //      is of type DFS_STORAGE_INFO_0_32.
} DFS_INFO_3_32, *PDFS_INFO_3_32, *LPDFS_INFO_3_32;

#endif  /* _WIN64   */

//
// Level 4:
//
typedef struct _DFS_INFO_4 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    ULONG   Timeout;                // Timeout, in seconds, of this junction point
    GUID    Guid;                   // Guid of this junction point
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of
                                    //      storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_4, *PDFS_INFO_4, *LPDFS_INFO_4;


#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_4_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    ULONG   Timeout;                // Timeout, in seconds, of this junction point
    GUID    Guid;                   // Guid of this junction point
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
    ULONG   Storage;                // An array (of NumberOfStorages elements) of
                                    //      storage-specific information. Each element
                                    //      is of type DFS_STORAGE_INFO_0_32.
} DFS_INFO_4_32, *PDFS_INFO_4_32, *LPDFS_INFO_4_32;

#endif  /* _WIN64   */


//
// Level 5:
//
typedef struct _DFS_INFO_5 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_5, *PDFS_INFO_5, *LPDFS_INFO_5;

//
// Level 6:
//
typedef struct _DFS_INFO_6 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
    DWORD   NumberOfStorages;       // Number of targets for this root/link.
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO_1    Storage;
#else
    LPDFS_STORAGE_INFO_1    Storage;    // An array (of NumberOfStorages elements) of
                                        // storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_6, *PDFS_INFO_6, *LPDFS_INFO_6;

//
// Level 7:
//
typedef struct _DFS_INFO_7 {
    GUID        GenerationGuid;     // Guid representation of the version/generation
                                    // number of the DFS root.
} DFS_INFO_7, *PDFS_INFO_7, *LPDFS_INFO_7;

//
// Level 8:
//
typedef struct _DFS_INFO_8 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_8, *PDFS_INFO_8, *LPDFS_INFO_8;

//
// Level 9:
//
typedef struct _DFS_INFO_9 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
    DWORD   NumberOfStorages;       // Number of targets for this root/link.
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO_1    Storage;
#else
    LPDFS_STORAGE_INFO_1    Storage;    // An array (of NumberOfStorages elements) of
                                        // storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_9, *PDFS_INFO_9, *LPDFS_INFO_9;

//
// The PropertyFlags field of DFS_INFO_5, DFS_INFO_6,
// DFS_INFO_103, DFS_INFO_105 & DFS_INFO_107.
//

#define  DFS_VALID_PROPERTY_FLAGS    (DFS_PROPERTY_FLAG_INSITE_REFERRALS | \
                                        DFS_PROPERTY_FLAG_ROOT_SCALABILITY | \
                                        DFS_PROPERTY_FLAG_SITE_COSTING | \
                                        DFS_PROPERTY_FLAG_TARGET_FAILBACK | \
                                        DFS_PROPERTY_FLAG_CLUSTER_ENABLED | \
                                        DFS_PROPERTY_FLAG_ABDE)
                

//
// The "insite" flag. When set, only targets in the same
// site as the client are returned.
//
// Valid for domain/standalone roots/links
//

#define DFS_PROPERTY_FLAG_INSITE_REFERRALS  0x00000001

//
// "Root scalability" mode. When set, DFS server polls
// the nearest DC instead of PDC to check for DFS namespace
// changes. Valid only for domain roots.
//

#define DFS_PROPERTY_FLAG_ROOT_SCALABILITY  0x00000002

//
// Enables Active Directory site costing of targets. When enabled,
// targets are grouped into sets of increasing site costs from
// DFS client to target. Each set has targets of same cost.
// If not set, there are only two sets: set of targets in same
// site as client and set of targets not in the same site as the client.
// The latter is called "site awareness".
// Valid only domain/standalone roots
//

#define DFS_PROPERTY_FLAG_SITE_COSTING      0x00000004

//
// Should the DFS client attempt to failback to a closer target
// when it is available after failing over to a non-optimal target?
// Valid for domain/standalone roots/links.
//

#define DFS_PROPERTY_FLAG_TARGET_FAILBACK   0x00000008

//
// Bit will be 1 if the DFS root is clustered. Cannot be set
// using the NetDfsSetInfo() API.
//

#define DFS_PROPERTY_FLAG_CLUSTER_ENABLED   0x00000010

//
//  When set by the caller, Access-Based Directory Enumeration support
//  is enabled on all the DFS root target share of the DFS namespace.
//  Valid only for DFS namespaces which support the capability
//  DFS_NAMESPACE_CAPABILITY_ABDE. Valid only on the DFS namespace root
//  and not on root targets, link or link targets.
//  This property must be enabled to associate security descriptor
//  with a DFS link.
//

#define DFS_PROPERTY_FLAG_ABDE  0x00000020

//
//  Level 50:
//

//
//  DFS metadata version and capabilities of an existing
//  DFS namespace.
//

typedef struct _DFS_INFO_50 {
    ULONG       NamespaceMajorVersion;
    ULONG       NamespaceMinorVersion;
    ULONGLONG   NamespaceCapabilities;
} DFS_INFO_50, *PDFS_INFO_50, *LPDFS_INFO_50;


//
// Level 100:
//
typedef struct _DFS_INFO_100 {
    LPWSTR  Comment;                // Comment for this volume or storage
} DFS_INFO_100, *PDFS_INFO_100, *LPDFS_INFO_100;

//
// Level 101:
//
typedef struct _DFS_INFO_101 {
    DWORD   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
} DFS_INFO_101, *PDFS_INFO_101, *LPDFS_INFO_101;

//
// Level 102:
//
typedef struct _DFS_INFO_102 {
    ULONG   Timeout;                // Timeout, in seconds, of the junction
} DFS_INFO_102, *PDFS_INFO_102, *LPDFS_INFO_102;

//
// Level 103:
//
typedef struct _DFS_INFO_103 {
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // Flag meaningful only if corresponding bit set in
                                    // PropertyFlagMask above.
} DFS_INFO_103, *PDFS_INFO_103, *LPDFS_INFO_103;


//
// Level 104:
//
typedef struct _DFS_INFO_104 {
    DFS_TARGET_PRIORITY     TargetPriority;     // Priority of target.
} DFS_INFO_104, *PDFS_INFO_104, *LPDFS_INFO_104;

//
// Level 105:
//
typedef struct _DFS_INFO_105 {
    LPWSTR      Comment;            // Comment for this root/link.
    DWORD       State;              // State of this root/link. One of DFS_VOLUME_STATE_*
    ULONG       Timeout;            // Referral TTL, in seconds, of root/link.
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // One of DFS_PROPERTY_FLAG_*
} DFS_INFO_105, *PDFS_INFO_105, *LPDFS_INFO_105;

//
// Level 106:
//
typedef struct _DFS_INFO_106 {
    DWORD               State;              // State of this root/link target.
                                            //      One of DFS_TARGET_STATE_*
    DFS_TARGET_PRIORITY TargetPriority;     // Priority of this target.
} DFS_INFO_106, *PDFS_INFO_106, *LPDFS_INFO_106;

//
// Level 107:
//
typedef struct _DFS_INFO_107 {
    LPWSTR      Comment;            // Comment for this root/link.
    DWORD       State;              // State of this root/link. One of DFS_VOLUME_STATE_*
    ULONG       Timeout;            // Referral TTL, in seconds, of root/link.
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // One of DFS_PROPERTY_FLAG_*

#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
} DFS_INFO_107, *PDFS_INFO_107, *LPDFS_INFO_107;

//
// Level 150:
//
typedef struct _DFS_INFO_150 {

#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
} DFS_INFO_150, *PDFS_INFO_150, *LPDFS_INFO_150;

//

// Level 200:
//
typedef struct _DFS_INFO_200 {
    LPWSTR  FtDfsName;              // FtDfs name
} DFS_INFO_200, *PDFS_INFO_200, *LPDFS_INFO_200;


//
// Level 300:
//
typedef struct _DFS_INFO_300 {
    DWORD   Flags;
    LPWSTR  DfsName;              // Dfs name
} DFS_INFO_300, *PDFS_INFO_300, *LPDFS_INFO_300;


//
// Add a new volume or additional storage for an existing volume at
// DfsEntryPath.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsAdd(
    __in LPWSTR     DfsEntryPath,   // DFS entry path for this added volume or storage
    __in LPWSTR     ServerName,     // Name of server hosting the storage
    __in LPWSTR     ShareName,      // Existing share name for the storage
    __in_opt LPWSTR Comment,        // Optional comment for this volume or storage
    __in  DWORD     Flags           // See below. Zero for no flags.
);

//
// Flags:
//
#define DFS_ADD_VOLUME          1   // Add a new volume to the DFS if not already there
#define DFS_RESTORE_VOLUME      2   // Volume/Replica is being restored - do not verify share etc.

//
// Setup/teardown API's for standard and FtDfs roots.
//

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRoot(
    __in LPWSTR     ServerName,     // Server to remote to
    __in LPWSTR     RootShare,      // Share to make Dfs root
    __in_opt LPWSTR Comment,        // Comment
    __in  DWORD     Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveStdRoot(
    __in  LPWSTR ServerName,        // Server to remote to
    __in  LPWSTR RootShare,         // Share that host Dfs root
    __reserved  DWORD  Flags        // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddFtRoot(
    __in LPWSTR         ServerName,     // Server to remote to
    __in LPWSTR         RootShare,      // Share to make Dfs root
    __in  LPWSTR        FtDfsName,      // Name of FtDfs to create/join
    __in_opt LPWSTR     Comment,        // Comment
    __in DWORD          Flags           // Flags for operation.  Zero for no flags.
);


NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRoot(
    __in LPWSTR         ServerName,     // Server to remote to
    __in LPWSTR         RootShare,      // Share that host Dfs root
    __in LPWSTR         FtDfsName,      // Name of FtDfs to remove or unjoin from.
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRootForced(
    __in  LPWSTR        DomainName,     // Name of domain the server is in
    __in  LPWSTR        ServerName,     // Server to remote to
    __in  LPWSTR        RootShare,      // Share that host Dfs root
    __in  LPWSTR        FtDfsName,      // Name of FtDfs to remove or unjoin from.
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

//
// Call to reinitialize the dfsmanager on a machine
//

NET_API_STATUS NET_API_FUNCTION
NetDfsManagerInitialize(
    __in LPWSTR         ServerName,     // Server to remote to
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRootForced(
    __in  LPWSTR        ServerName,     // Server to remote to
    __in  LPWSTR        RootShare,      // Share to make Dfs root
    __in_opt  LPWSTR    Comment,        // Comment
    __in LPWSTR         Store           // Drive:\dir backing the share
);

NET_API_STATUS NET_API_FUNCTION
NetDfsGetDcAddress(
    __in LPWSTR         ServerName,     // Server to remote to
    __deref_out LPWSTR  *DcIpAddress,   // The IP address of the DC to use
    __out PBOOLEAN      IsRoot,         // TRUE if server is a Dfs root, FALSE otherwise
    __out PULONG        Timeout         // Time, in sec, that we stay with this DC
);


//
// Flags for NetDfsSetDcAddress()
//

#define NET_DFS_SETDC_FLAGS                 0x00000000
#define NET_DFS_SETDC_TIMEOUT               0x00000001
#define NET_DFS_SETDC_INITPKT               0x00000002

//
// Structures used for site reporting.  Last used in Windows 2000, maintained for
// the obsolete SRVSVC RPC API NetrDfsManagerReportSiteInfo.
//

typedef struct {
    ULONG SiteFlags;    // Below
#ifdef  MIDL_PASS
    [string,unique] LPWSTR SiteName;
#else
    LPWSTR SiteName;
#endif
} DFS_SITENAME_INFO, *PDFS_SITENAME_INFO, *LPDFS_SITENAME_INFO;

// SiteFlags

#define DFS_SITE_PRIMARY    0x1     // This site returned by DsGetSiteName()

typedef struct {
    ULONG cSites;
#ifdef  MIDL_PASS
    [size_is(cSites)] DFS_SITENAME_INFO Site[];
#else
    DFS_SITENAME_INFO Site[1];
#endif
} DFS_SITELIST_INFO, *PDFS_SITELIST_INFO, *LPDFS_SITELIST_INFO;

//
// Remove a volume or additional storage for volume from the Dfs at
// DfsEntryPath. When applied to the last storage in a volume, removes
// the volume from the DFS.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsRemove(
    __in LPWSTR     DfsEntryPath,       // DFS entry path for this added volume or storage
    __in_opt LPWSTR ServerName,         // Name of server hosting the storage
    __in_opt LPWSTR ShareName           // Name of share hosting the storage
);

//
// Get information about all of the volumes in the Dfs. DfsName is
// the "server" part of the UNC name used to refer to this particular Dfs.
//
// Valid levels are 1-5, 200, 300
//
NET_API_STATUS NET_API_FUNCTION
NetDfsEnum(
    __in LPWSTR         DfsName,        // Name of the Dfs for enumeration
    __in DWORD          Level,          // Level of information requested
    __in DWORD          PrefMaxLen,     // Advisory, but -1 means "get it all"
    __out LPBYTE        *Buffer,        // API allocates and returns buffer with requested info
    __out LPDWORD       EntriesRead,    // Number of entries returned
    __inout LPDWORD     ResumeHandle    // Must be 0 on first call, reused on subsequent calls
);

//
// Get information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-5, 100
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share on server serving the volume
    __in DWORD          Level,          // Level of information requested
    __out LPBYTE        *Buffer         // API allocates and returns buffer with requested info
);

//
// Set info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 100, 101 and 102
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share hosting a storage
    __in DWORD          Level,          // Level of information to be set
    __in LPBYTE         Buffer          // Buffer holding information
);

//
// Get client's cached information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-4
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetClientInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share on server serving the volume
    __in DWORD          Level,          // Level of information requested
    __out LPBYTE        *Buffer         // API allocates and returns buffer with requested info
);

//
// Set client's cached info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 101 and 102.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetClientInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share hosting a storage
    __in DWORD          Level,          // Level of information to be set
    __in LPBYTE         Buffer          // Buffer holding information
);

//
// Move a DFS volume and all subordinate volumes from one place in the
// DFS to another place in the DFS.
//


NET_API_STATUS NET_API_FUNCTION
NetDfsMove(
    __in LPWSTR     OldDfsEntryPath,    // Current DFS entry path for this volume
    __in LPWSTR     NewDfsEntryPath,    // New DFS entry path for this volume
    __in ULONG      Flags
);

//
//  Flags accepted by NetDfsMove
//

//
//  This  indicates that if a colliding link is found it should be replaced
//

#define  DFS_MOVE_FLAG_REPLACE_IF_EXISTS  0x00000001


NET_API_STATUS NET_API_FUNCTION
NetDfsRename(
    __in LPWSTR     Path,               // Current Win32 path in a Dfs
    __in LPWSTR     NewPath             // New Win32 path in the same Dfs
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddRootTarget(
    __in        LPWSTR  pDfsPath,
    __in_opt    LPWSTR  pTargetPath,
    __in        ULONG   MajorVersion,
    __in_opt    LPWSTR  pComment,
    __in        ULONG   Flags
    );

//
//  Reuse existing definition used by NetrDfsRemoveFtRoot().
//

#ifndef DFS_FORCE_REMOVE
#define DFS_FORCE_REMOVE    0x80000000
#endif

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveRootTarget(
    __in        LPWSTR  pDfsPath,
    __in_opt    LPWSTR  pTargetPath,
    __in        ULONG   Flags
    );

NET_API_STATUS NET_API_FUNCTION
NetDfsGetSecurity(
    __in LPWSTR                                                         DfsEntryPath,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetSecurity(
    __in LPWSTR                 DfsEntryPath,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsGetStdContainerSecurity(
    __in LPWSTR                                                         MachineName,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetStdContainerSecurity(
    __in LPWSTR                 MachineName,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);
    
NET_API_STATUS NET_API_FUNCTION
NetDfsGetFtContainerSecurity(
    __in LPWSTR                                                         DomainName,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetFtContainerSecurity(
    __in LPWSTR                 DomainName,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);

//
//  Origin of DFS namespace version information.
//

typedef enum {
    DFS_NAMESPACE_VERSION_ORIGIN_COMBINED = 0,  //  Max version {server, AD DS domain}
                                                //      can support.
    DFS_NAMESPACE_VERSION_ORIGIN_SERVER,        //  Max version server can support.
    DFS_NAMESPACE_VERSION_ORIGIN_DOMAIN         //  Max version AD DS domain can support.
} DFS_NAMESPACE_VERSION_ORIGIN, *PDFS_NAMESPACE_VERSION_ORIGIN;

//
//  Capabilities:
//      Set of bit flags which indicates support for a specific capability.
//

//
//  DFS namespace supports associating a security descriptor with DFS link
//  for Access-Based Directory Enumeration purposes.
//

#define DFS_NAMESPACE_CAPABILITY_ABDE           ((ULONGLONG) 0x0000000000000001)


typedef struct _DFS_SUPPORTED_NAMESPACE_VERSION_INFO {

    //
    //  Domain-based DFS information.
    //  Valid only if DomainDfsMajorVersion != 0.
    //

    ULONG       DomainDfsMajorVersion;
    ULONG       DomainDfsMinorVersion;
    ULONGLONG   DomainDfsCapabilities;

    //
    //  Standalone DFS information.
    //  Valid only if StandaloneDfsMajorVersion != 0.
    //

    ULONG       StandaloneDfsMajorVersion;
    ULONG       StandaloneDfsMinorVersion;
    ULONGLONG   StandaloneDfsCapabilities;
} DFS_SUPPORTED_NAMESPACE_VERSION_INFO, *PDFS_SUPPORTED_NAMESPACE_VERSION_INFO;


NET_API_STATUS NET_API_FUNCTION
NetDfsGetSupportedNamespaceVersion(
    __in        DFS_NAMESPACE_VERSION_ORIGIN            Origin,
    __in_opt    PWSTR                                   pName,
    __deref_out PDFS_SUPPORTED_NAMESPACE_VERSION_INFO   *ppVersionInfo
    );

#ifdef __cplusplus
}
#endif

#endif // _LMDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMRemUtl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmremutl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetRemote API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

--*/

#ifndef _LMREMUTL_
#define _LMREMUTL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Type Definitions
//

#ifndef DESC_CHAR_UNICODE

typedef CHAR DESC_CHAR;
typedef LPSTR LPDESC;

#else // DESC_CHAR_UNICODE is defined

typedef WCHAR DESC_CHAR;
typedef LPWSTR LPDESC;

#endif // DESC_CHAR_UNICODE is defined



//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetRemoteTOD (
    IN LPCWSTR UncServerName,
    __out OUT LPBYTE *BufferPtr
    );

NET_API_STATUS NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPCWSTR UncServerName OPTIONAL,   // Must start with "\\".
    IN DWORD OptionsWanted,             // Set SUPPORTS_ bits wanted.
    OUT LPDWORD OptionsSupported        // Supported features, masked.
    );

NET_API_STATUS
__cdecl
RxRemoteApi(
    IN DWORD ApiNumber,
    __in IN LPCWSTR UncServerName,                    // Required, with \\name.
    __in IN LPDESC ParmDescString,
    __in_opt IN LPDESC DataDesc16 OPTIONAL,
    __in_opt IN LPDESC DataDesc32 OPTIONAL,
    __in_opt IN LPDESC DataDescSmb OPTIONAL,
    __in_opt IN LPDESC AuxDesc16 OPTIONAL,
    __in_opt IN LPDESC AuxDesc32 OPTIONAL,
    __in_opt IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD  Flags,
    ...                                         // rest of API's arguments
    );



//
//  Data Structures
//

typedef struct _TIME_OF_DAY_INFO {
    DWORD      tod_elapsedt;
    DWORD      tod_msecs;
    DWORD      tod_hours;
    DWORD      tod_mins;
    DWORD      tod_secs;
    DWORD      tod_hunds;
    LONG       tod_timezone;
    DWORD      tod_tinterval;
    DWORD      tod_day;
    DWORD      tod_month;
    DWORD      tod_year;
    DWORD      tod_weekday;
} TIME_OF_DAY_INFO, *PTIME_OF_DAY_INFO, *LPTIME_OF_DAY_INFO;

//
// Special Values and Constants
//

//
// Mask bits for use with NetRemoteComputerSupports:
//

#define SUPPORTS_REMOTE_ADMIN_PROTOCOL  0x00000002L
#define SUPPORTS_RPC                    0x00000004L
#define SUPPORTS_SAM_PROTOCOL           0x00000008L
#define SUPPORTS_UNICODE                0x00000010L
#define SUPPORTS_LOCAL                  0x00000020L
#define SUPPORTS_ANY                    0xFFFFFFFFL

//
// Flag bits for RxRemoteApi:
//

#define NO_PERMISSION_REQUIRED  0x00000001      // set if use NULL session
#define ALLOCATE_RESPONSE       0x00000002      // set if RxRemoteApi allocates response buffer
#define USE_SPECIFIC_TRANSPORT  0x80000000

#ifdef __cplusplus
}
#endif

#endif //_LMREMUTL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMaudit.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaudit.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetAudit

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMAUDIT_
#define _LMAUDIT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD	0
#define LOGFLAGS_BACKWARD	0x1
#define LOGFLAGS_SEEK		0x2

#endif

//
// Function Prototypes - Audit
//

NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  backupfile OPTIONAL,
    IN  LPCWSTR  service OPTIONAL  // WARNING: buggy support before LM 2.0C!!
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  service OPTIONAL,  // WARNING: buggy support before LM 2.0C!!
    IN  LPHLOG   auditloghandle,
    IN  DWORD    offset,
    IN  LPDWORD  reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD    type,
    IN  LPBYTE   buf,
    IN  DWORD    numbytes,
    IN  LPCWSTR  service OPTIONAL,
    IN  LPBYTE   reserved OPTIONAL
    );


//
// Data Structures - Audit
//

typedef struct _AUDIT_ENTRY {
     DWORD          ae_len;
     DWORD          ae_reserved;
     DWORD          ae_time;
     DWORD          ae_type;
     DWORD          ae_data_offset;  /* Offset from beginning
                              address of audit_entry */
     DWORD          ae_data_size;  // byte count of ae_data area (not incl pad).
} AUDIT_ENTRY, *PAUDIT_ENTRY, *LPAUDIT_ENTRY;

#define REVISED_AUDIT_ENTRY_STRUCT


typedef struct _AE_SRVSTATUS {
     DWORD	    ae_sv_status;
} AE_SRVSTATUS, *PAE_SRVSTATUS, *LPAE_SRVSTATUS;

typedef struct _AE_SESSLOGON {
     DWORD          ae_so_compname;
     DWORD          ae_so_username;
     DWORD          ae_so_privilege;
} AE_SESSLOGON, *PAE_SESSLOGON, *LPAE_SESSLOGON;

typedef struct _AE_SESSLOGOFF {
     DWORD          ae_sf_compname;
     DWORD          ae_sf_username;
     DWORD          ae_sf_reason;
} AE_SESSLOGOFF, *PAE_SESSLOGOFF, *LPAE_SESSLOGOFF;

typedef struct _AE_SESSPWERR {
     DWORD          ae_sp_compname;
     DWORD          ae_sp_username;
} AE_SESSPWERR, *PAE_SESSPWERR, *LPAE_SESSPWERR;

typedef struct _AE_CONNSTART {
     DWORD          ae_ct_compname;
     DWORD          ae_ct_username;
     DWORD          ae_ct_netname;
     DWORD          ae_ct_connid;
} AE_CONNSTART, *PAE_CONNSTART, *LPAE_CONNSTART;

typedef struct _AE_CONNSTOP {
     DWORD          ae_cp_compname;
     DWORD          ae_cp_username;
     DWORD          ae_cp_netname;
     DWORD          ae_cp_connid;
     DWORD          ae_cp_reason;
} AE_CONNSTOP, *PAE_CONNSTOP, *LPAE_CONNSTOP;

typedef struct _AE_CONNREJ {
     DWORD          ae_cr_compname;
     DWORD          ae_cr_username;
     DWORD          ae_cr_netname;
     DWORD          ae_cr_reason;
} AE_CONNREJ, *PAE_CONNREJ, *LPAE_CONNREJ;

typedef struct _AE_RESACCESS {
     DWORD          ae_ra_compname;
     DWORD          ae_ra_username;
     DWORD          ae_ra_resname;
     DWORD          ae_ra_operation;
     DWORD          ae_ra_returncode;
     DWORD          ae_ra_restype;
     DWORD          ae_ra_fileid;
} AE_RESACCESS, *PAE_RESACCESS, *LPAE_RESACCESS;

typedef struct _AE_RESACCESSREJ {
     DWORD          ae_rr_compname;
     DWORD          ae_rr_username;
     DWORD          ae_rr_resname;
     DWORD          ae_rr_operation;
} AE_RESACCESSREJ, *PAE_RESACCESSREJ, *LPAE_RESACCESSREJ;

typedef struct _AE_CLOSEFILE {
     DWORD          ae_cf_compname;
     DWORD          ae_cf_username;
     DWORD          ae_cf_resname;
     DWORD          ae_cf_fileid;
     DWORD          ae_cf_duration;
     DWORD          ae_cf_reason;
} AE_CLOSEFILE, *PAE_CLOSEFILE, *LPAE_CLOSEFILE;

typedef struct _AE_SERVICESTAT {
     DWORD          ae_ss_compname;
     DWORD          ae_ss_username;
     DWORD          ae_ss_svcname;
     DWORD          ae_ss_status;
     DWORD          ae_ss_code;
     DWORD          ae_ss_text;
     DWORD          ae_ss_returnval;
} AE_SERVICESTAT, *PAE_SERVICESTAT, *LPAE_SERVICESTAT;

typedef struct _AE_ACLMOD {
     DWORD          ae_am_compname;
     DWORD          ae_am_username;
     DWORD          ae_am_resname;
     DWORD          ae_am_action;
     DWORD          ae_am_datalen;
} AE_ACLMOD, *PAE_ACLMOD, *LPAE_ACLMOD;

typedef struct _AE_UASMOD {
     DWORD          ae_um_compname;
     DWORD          ae_um_username;
     DWORD          ae_um_resname;
     DWORD          ae_um_rectype;
     DWORD          ae_um_action;
     DWORD          ae_um_datalen;
} AE_UASMOD, *PAE_UASMOD, *LPAE_UASMOD;

typedef struct _AE_NETLOGON {
     DWORD          ae_no_compname;
     DWORD          ae_no_username;
     DWORD          ae_no_privilege;
     DWORD          ae_no_authflags;
} AE_NETLOGON, *PAE_NETLOGON, *LPAE_NETLOGON;

typedef struct _AE_NETLOGOFF {
     DWORD          ae_nf_compname;
     DWORD          ae_nf_username;
     DWORD          ae_nf_reserved1;
     DWORD          ae_nf_reserved2;
} AE_NETLOGOFF, *PAE_NETLOGOFF, *LPAE_NETLOGOFF;

typedef struct _AE_ACCLIM {
     DWORD          ae_al_compname;
     DWORD          ae_al_username;
     DWORD          ae_al_resname;
     DWORD          ae_al_limit;
} AE_ACCLIM, *PAE_ACCLIM, *LPAE_ACCLIM;

#define ACTION_LOCKOUT          00
#define ACTION_ADMINUNLOCK      01

typedef struct _AE_LOCKOUT {
    DWORD           ae_lk_compname;     // Ptr to computername of client.
    DWORD           ae_lk_username;     // Ptr to username of client (NULL
                                        //  if same as computername).
    DWORD           ae_lk_action;       // Action taken on account:
                                        // 0 means locked out, 1 means not.
    DWORD           ae_lk_bad_pw_count; // Bad password count at the time
                                        // of lockout.
} AE_LOCKOUT, *PAE_LOCKOUT, *LPAE_LOCKOUT;

typedef struct _AE_GENERIC {
     DWORD          ae_ge_msgfile;
     DWORD          ae_ge_msgnum;
     DWORD          ae_ge_params;
     DWORD          ae_ge_param1;
     DWORD          ae_ge_param2;
     DWORD          ae_ge_param3;
     DWORD          ae_ge_param4;
     DWORD          ae_ge_param5;
     DWORD          ae_ge_param6;
     DWORD          ae_ge_param7;
     DWORD          ae_ge_param8;
     DWORD          ae_ge_param9;
} AE_GENERIC, *PAE_GENERIC, *LPAE_GENERIC;

//
// Special Values and Constants - Audit
//

//
// 	Audit entry types (field ae_type in audit_entry).
//

#define AE_SRVSTATUS	0
#define AE_SESSLOGON	1
#define AE_SESSLOGOFF	2
#define AE_SESSPWERR	3
#define AE_CONNSTART	4
#define AE_CONNSTOP	5
#define AE_CONNREJ	6
#define AE_RESACCESS	7
#define AE_RESACCESSREJ	8
#define AE_CLOSEFILE	9
#define AE_SERVICESTAT	11
#define AE_ACLMOD	12
#define AE_UASMOD	13
#define AE_NETLOGON	14
#define AE_NETLOGOFF	15
#define AE_NETLOGDENIED 16
#define AE_ACCLIMITEXCD 17
#define AE_RESACCESS2	18
#define AE_ACLMODFAIL	19
#define AE_LOCKOUT      20
#define AE_GENERIC_TYPE 21
//
//	Values for ae_ss_status field of ae_srvstatus.
//

#define AE_SRVSTART	0
#define AE_SRVPAUSED	1
#define AE_SRVCONT	2
#define AE_SRVSTOP	3

//
// 	Values for ae_so_privilege field of ae_sesslogon.
//

#define AE_GUEST	0		
#define AE_USER		1
#define AE_ADMIN	2

//
//	Values for various ae_XX_reason fields.
//

#define AE_NORMAL	0		
#define AE_USERLIMIT	0
#define AE_GENERAL	0
#define AE_ERROR	1
#define AE_SESSDIS	1
#define AE_BADPW	1
#define AE_AUTODIS	2
#define AE_UNSHARE	2
#define AE_ADMINPRIVREQD 2
#define AE_ADMINDIS	3
#define AE_NOACCESSPERM 3
#define AE_ACCRESTRICT	4

#define	AE_NORMAL_CLOSE	0
#define	AE_SES_CLOSE	1
#define	AE_ADMIN_CLOSE	2

//
// Values for xx_subreason fields.
//

#define AE_LIM_UNKNOWN	    0
#define AE_LIM_LOGONHOURS   1
#define AE_LIM_EXPIRED	    2
#define AE_LIM_INVAL_WKSTA  3
#define AE_LIM_DISABLED     4
#define AE_LIM_DELETED	    5

//
// Values for xx_action fields
//

#define AE_MOD		0
#define AE_DELETE	1
#define AE_ADD		2

//
// Types of UAS record for um_rectype field
//

#define AE_UAS_USER	    0
#define AE_UAS_GROUP	    1
#define AE_UAS_MODALS	    2

//
// Bitmasks for auditing events
//
// The parentheses around the hex constants broke h_to_inc
// and have been purged from the face of the earth.
//

#define SVAUD_SERVICE           0x1
#define SVAUD_GOODSESSLOGON     0x6
#define SVAUD_BADSESSLOGON      0x18
#define SVAUD_SESSLOGON         (SVAUD_GOODSESSLOGON | SVAUD_BADSESSLOGON)
#define SVAUD_GOODNETLOGON      0x60
#define SVAUD_BADNETLOGON       0x180
#define SVAUD_NETLOGON          (SVAUD_GOODNETLOGON | SVAUD_BADNETLOGON)
#define SVAUD_LOGON             (SVAUD_NETLOGON | SVAUD_SESSLOGON)
#define SVAUD_GOODUSE           0x600
#define SVAUD_BADUSE            0x1800
#define SVAUD_USE               (SVAUD_GOODUSE | SVAUD_BADUSE)
#define SVAUD_USERLIST          0x2000
#define SVAUD_PERMISSIONS       0x4000
#define SVAUD_RESOURCE          0x8000
#define SVAUD_LOGONLIM		0x00010000

//
// Resource access audit bitmasks.
//

#define AA_AUDIT_ALL	    0x0001
#define AA_A_OWNER	    0x0004
#define AA_CLOSE	    0x0008
#define AA_S_OPEN	    0x0010
#define AA_S_WRITE	    0x0020
#define AA_S_CREATE	    0x0020
#define AA_S_DELETE	    0x0040
#define AA_S_ACL	    0x0080
#define AA_S_ALL	    ( AA_S_OPEN | AA_S_WRITE | AA_S_DELETE | AA_S_ACL)
#define AA_F_OPEN	    0x0100
#define AA_F_WRITE	    0x0200
#define AA_F_CREATE	    0x0200
#define AA_F_DELETE	    0x0400
#define AA_F_ACL	    0x0800
#define AA_F_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)

// Pinball-specific
#define AA_A_OPEN	    0x1000
#define AA_A_WRITE	    0x2000
#define AA_A_CREATE	    0x2000
#define AA_A_DELETE	    0x4000
#define AA_A_ACL	    0x8000
#define AA_A_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)


#ifdef __cplusplus
}
#endif

#endif  // _LMAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMConfig.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmconfig.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetConfig

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCONFIG_
#define _LMCONFIG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define REVISED_CONFIG_APIS

//
// Function Prototypes - Config
//

NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
    IN  LPCWSTR  parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );

NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );


NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  reserved1 OPTIONAL,
    IN  LPCWSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );


//
// Data Structures - Config
//

typedef struct _CONFIG_INFO_0 {
     LPWSTR         cfgi0_key;
     LPWSTR         cfgi0_data;
} CONFIG_INFO_0, *PCONFIG_INFO_0, *LPCONFIG_INFO_0;


#ifdef __cplusplus
}
#endif

#endif  // _LMCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMRepl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.


--*/

#ifndef _LMREPL_
#define _LMREPL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPWSTR         rp0_exportpath;
    LPWSTR         rp0_exportlist;
    LPWSTR         rp0_importpath;
    LPWSTR         rp0_importlist;
    LPWSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPWSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPWSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPWSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPWSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPWSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPWSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#ifdef __cplusplus
}
#endif

#endif //_LMREPL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMSName.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmsname.h

Abstract:

    This file contains service name strings.  It is included by lmsvc.h.

Environment:

    User Mode -Win32


--*/

#ifndef _LMSNAME_
#define _LMSNAME_

#if _MSC_VER > 1000
#pragma once
#endif

//
//  Standard LAN Manager service names.
//

#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
#define SERVICE_LM20_WORKSTATION  TEXT("WORKSTATION")
#define WORKSTATION_DISPLAY_NAME  TEXT("Workstation")

#define SERVICE_SERVER            TEXT("LanmanServer")
#define SERVICE_LM20_SERVER       TEXT("SERVER")
#define SERVER_DISPLAY_NAME       TEXT("Server")

#define SERVICE_BROWSER           TEXT("BROWSER")
#define SERVICE_LM20_BROWSER      SERVICE_BROWSER

#define SERVICE_MESSENGER         TEXT("MESSENGER")
#define SERVICE_LM20_MESSENGER    SERVICE_MESSENGER

#define SERVICE_NETRUN            TEXT("NETRUN")
#define SERVICE_LM20_NETRUN       SERVICE_NETRUN

#define SERVICE_SPOOLER           TEXT("SPOOLER")
#define SERVICE_LM20_SPOOLER      SERVICE_SPOOLER

#define SERVICE_ALERTER           TEXT("ALERTER")
#define SERVICE_LM20_ALERTER      SERVICE_ALERTER

#define SERVICE_NETLOGON          TEXT("NETLOGON")
#define SERVICE_LM20_NETLOGON     SERVICE_NETLOGON

#define SERVICE_NETPOPUP          TEXT("NETPOPUP")
#define SERVICE_LM20_NETPOPUP     SERVICE_NETPOPUP

#define SERVICE_SQLSERVER         TEXT("SQLSERVER")
#define SERVICE_LM20_SQLSERVER    SERVICE_SQLSERVER

#define SERVICE_REPL              TEXT("REPLICATOR")
#define SERVICE_LM20_REPL         SERVICE_REPL

#define SERVICE_RIPL              TEXT("REMOTEBOOT")
#define SERVICE_LM20_RIPL         SERVICE_RIPL

#define SERVICE_TIMESOURCE        TEXT("TIMESOURCE")
#define SERVICE_LM20_TIMESOURCE   SERVICE_TIMESOURCE

#define SERVICE_AFP               TEXT("AFP")
#define SERVICE_LM20_AFP          SERVICE_AFP

#define SERVICE_UPS               TEXT("UPS")
#define SERVICE_LM20_UPS          SERVICE_UPS

#define SERVICE_XACTSRV           TEXT("XACTSRV")
#define SERVICE_LM20_XACTSRV      SERVICE_XACTSRV

#define SERVICE_TCPIP             TEXT("TCPIP")
#define SERVICE_LM20_TCPIP        SERVICE_TCPIP

#define SERVICE_NBT               TEXT("NBT")
#define SERVICE_LM20_NBT          SERVICE_NBT

#define SERVICE_LMHOSTS           TEXT("LMHOSTS")
#define SERVICE_LM20_LMHOSTS      SERVICE_LMHOSTS

#define SERVICE_TELNET            TEXT("Telnet")
#define SERVICE_LM20_TELNET       SERVICE_TELNET

#define SERVICE_SCHEDULE          TEXT("Schedule")
#define SERVICE_LM20_SCHEDULE     SERVICE_SCHEDULE

#define SERVICE_NTLMSSP           TEXT("NtLmSsp")

#define SERVICE_DHCP              TEXT("DHCP")
#define SERVICE_LM20_DHCP         SERVICE_DHCP

#define SERVICE_NWSAP             TEXT("NwSapAgent")
#define SERVICE_LM20_NWSAP        SERVICE_NWSAP
#define NWSAP_DISPLAY_NAME        TEXT("NW Sap Agent")

#define SERVICE_NWCS              TEXT("NWCWorkstation")
#define SERVICE_DNS_CACHE         TEXT("DnsCache")

#define SERVICE_W32TIME           TEXT("w32time")
#define SERVCE_LM20_W32TIME       SERVICE_W32TIME

#define SERVICE_KDC               TEXT("kdc")
#define SERVICE_LM20_KDC          SERVICE_KDC

#define SERVICE_RPCLOCATOR        TEXT("RPCLOCATOR")
#define SERVICE_LM20_RPCLOCATOR   SERVICE_RPCLOCATOR

#define SERVICE_TRKSVR            TEXT("TrkSvr")
#define SERVICE_LM20_TRKSVR       SERVICE_TRKSVR

#define SERVICE_TRKWKS            TEXT("TrkWks")
#define SERVICE_LM20_TRKWKS       SERVICE_TRKWKS

#define SERVICE_NTFRS             TEXT("NtFrs")
#define SERVICE_LM20_NTFRS        SERVICE_NTFRS

#define SERVICE_ISMSERV           TEXT("IsmServ")
#define SERVICE_LM20_ISMSERV      SERVICE_ISMSERV

#define SERVICE_NTDS              TEXT("NTDS")
#define SERVICE_LM20_NTDS         SERVICE_NTDS

#define SERVICE_ADWS              TEXT("ADWS")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMCons.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation


    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.



--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
// Only the UNICODE version of the LM APIs are available on NT.
// Non-UNICODE version on other platforms
//
#if defined( _WIN32_WINNT ) || defined( WINNT ) || defined( __midl ) \
    || defined( FORCE_UNICODE )
#define LMSTR   LPWSTR
#define LMCSTR  LPCWSTR
#else
#define LMSTR   LPSTR
#define LMCSTR  LPCSTR
#endif

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")

/**INTERNAL_ONLY**/

// The backup message file named here is a duplicate of net.msg. It
// is not shipped with the product, but is used at buildtime to
// msgbind certain messages to netapi.dll and some of the services.
// This allows for OEMs to modify the message text in net.msg and
// have those changes show up.        Only in case there is an error in
// retrieving the messages from net.msg do we then get the bound
// messages out of bak.msg (really out of the message segment).

#define BACKUP_MSG_FILENAME     TEXT("BAK.MSG")

/**END_INTERNAL**/

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5899     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5899

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMStats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    __in        LPTSTR  ServerName,
    __in        LPTSTR  Service,
    __in        DWORD   Level,
    __in        DWORD   Options,
    __deref_out LPBYTE *Buffer
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMJoin.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    netsetup.h

Abstract:

    Definitions and prototypes for the Net setup apis, for joining/unjoinging
    domains and promoting/demoting servers

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

--*/

#ifndef __LMJOIN_H__
#define __LMJOIN_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Types of name that can be validated
//
typedef enum  _NETSETUP_NAME_TYPE {

    NetSetupUnknown = 0,
    NetSetupMachine,
    NetSetupWorkgroup,
    NetSetupDomain,
    NetSetupNonExistentDomain,
#if(_WIN32_WINNT >= 0x0500)
    NetSetupDnsMachine
#endif

} NETSETUP_NAME_TYPE, *PNETSETUP_NAME_TYPE;


//
// Status of a workstation
//
typedef enum _NETSETUP_JOIN_STATUS {

    NetSetupUnknownStatus = 0,
    NetSetupUnjoined,
    NetSetupWorkgroupName,
    NetSetupDomainName

} NETSETUP_JOIN_STATUS, *PNETSETUP_JOIN_STATUS;

//
// Flags to determine the behavior of the join/unjoin APIs
//
#define NETSETUP_JOIN_DOMAIN    0x00000001      // If not present, workgroup is joined
#define NETSETUP_ACCT_CREATE    0x00000002      // Do the server side account creation/rename
#define NETSETUP_ACCT_DELETE    0x00000004      // Delete the account when a domain is left
#define NETSETUP_WIN9X_UPGRADE  0x00000010      // Invoked during upgrade of Windows 9x to
                                                // Windows NT
#define NETSETUP_DOMAIN_JOIN_IF_JOINED  0x00000020  // Allow the client to join a new domain
                                                // even if it is already joined to a domain
#define NETSETUP_JOIN_UNSECURE  0x00000040      // Performs an unsecure join
#define NETSETUP_MACHINE_PWD_PASSED 0x00000080  // Indicates that the machine (not user) password
                                                //  is passed. Valid only for unsecure joins
#define NETSETUP_DEFER_SPN_SET  0x00000100      // Specifies that writting SPN and DnsHostName
                                                //  attributes on the computer object should be
                                                //  defered until rename that will follow join
                                                
#define NETSETUP_JOIN_DC_ACCOUNT    0x00000200  // Allow join if existing account is a DC
#define NETSETUP_JOIN_WITH_NEW_NAME 0x00000400  // Check for computer name change
#define NETSETUP_JOIN_READONLY      0x00000800  // Perform join using a pre-created account w/o requiring a writable DC
#define NETSETUP_DNS_NAME_CHANGES_ONLY 0x00001000      // When performing machine rename only update DNS based names 

#define NETSETUP_INSTALL_INVOCATION 0x00040000  // The APIs were invoked during install

#define NETSETUP_AMBIGUOUS_DC       0x00001000  // When joiing the domain don't try to set the
                                                // preferred DC in the registry.
#define NETSETUP_NO_NETLOGON_CACHE  0x00002000  // Don't create the netlogon cache
#define NETSETUP_DONT_CONTROL_SERVICES 0x00004000 // Don't force netlogon to start
#define NETSETUP_SET_MACHINE_NAME   0x00008000  // For offline join only, set target machine hostname and NB name.
#define NETSETUP_FORCE_SPN_SET      0x00010000  // Override other settings during domain join
                                                // and attempt to set the SPN.
#define NETSETUP_NO_ACCT_REUSE      0x00020000  // Do not reuse an existing account

#define NETSETUP_IGNORE_UNSUPPORTED_FLAGS  0x10000000  // If this bit is set, unrecognized flags
                                                       //  will be ignored by the NetJoin API and
                                                       //  the API will behave as if the flags
                                                       //  were not set.

#define NETSETUP_VALID_UNJOIN_FLAGS (NETSETUP_ACCT_DELETE | NETSETUP_IGNORE_UNSUPPORTED_FLAGS | NETSETUP_JOIN_DC_ACCOUNT)

// The following flags are used when the system is processing information left from a prior offline
// join.  We want to force DC discovery and we don't want to create the netlogon cache.  We also
// don't want to immediately force netlogon to start, let it start on its own.
#define NETSETUP_PROCESS_OFFLINE_FLAGS ( NETSETUP_JOIN_DOMAIN |                     \
                                         NETSETUP_DOMAIN_JOIN_IF_JOINED |           \
                                         NETSETUP_JOIN_WITH_NEW_NAME |              \
                                         NETSETUP_DONT_CONTROL_SERVICES |           \
                                         NETSETUP_MACHINE_PWD_PASSED)  

//
// 0x80000000 is reserved for internal use only
//


//
// Joins a machine to the domain.
//
NET_API_STATUS
NET_API_FUNCTION
NetJoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    );
    

#if(_WIN32_WINNT >= 0x0601)  

//
// Flags to determine the behavior of NetProvisionComputerAccount
//

// The caller requires account creation by privilege, this option will cause a retry 
// on failure using down level account creation APIs.
//
#define NETSETUP_PROVISION_DOWNLEVEL_PRIV_SUPPORT 0x00000001 

// If the named account already exists an attempt will be made to reuse. Requires 
// sufficient credentials i.e. Domain Administrator or the object owner.
//
#define NETSETUP_PROVISION_REUSE_ACCOUNT          0x00000002 
                                                    
// Use the default machine account password which is the machine name in lowercase.
//
#define NETSETUP_PROVISION_USE_DEFAULT_PASSWORD   0x00000004 
                                                 
// Do not try to find the account on any DC in the domain. This is faster but 
// should only be used when the caller is certain that an account by the same 
// name hasn't recently been created. Only valid when specifying the target DC. 
// When the pre-requisites are met, this option allows for must faster provisioning 
// useful for scenarios such as batch processing.         
//
#define NETSETUP_PROVISION_SKIP_ACCOUNT_SEARCH    0x00000008   

//
// The following are reserved for internal use.
//

// The operation is online.
// This is an internal option not available through the API.
//
#define NETSETUP_PROVISION_ONLINE_CALLER          0x40000000          

// Validate the machine password only. This is an internal option not available
// through the API.          
//
#define NETSETUP_PROVISION_CHECK_PWD_ONLY         0x80000000



NET_API_STATUS
NET_API_FUNCTION
NetProvisionComputerAccount( 
   __in            LPCWSTR lpDomain,
   __in            LPCWSTR lpMachineName,
   __in_opt        LPCWSTR lpMachineAccountOU,
   __in_opt        LPCWSTR lpDcName,  
   __in            DWORD   dwOptions,
   __deref_opt_out PBYTE  *pProvisionBinData,
   __out_opt       DWORD  *pdwProvisionBinDataSize,
   __deref_opt_out LPWSTR *pProvisionTextData
);

NET_API_STATUS
NET_API_FUNCTION
NetRequestOfflineDomainJoin(
    __in_bcount(cbProvisionBinDataSize) BYTE *pProvisionBinData,
    __in DWORD   cbProvisionBinDataSize,
    __in DWORD   dwOptions,
    __in LPCWSTR lpWindowsPath
);

#endif // (_WIN32_WINNT >= 0x0601)  

NET_API_STATUS
NET_API_FUNCTION
NetUnjoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fUnjoinOptions
    );

NET_API_STATUS
NET_API_FUNCTION
NetRenameMachineInDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpNewMachineName OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    );


//
// Determine the validity of a name
//
NET_API_STATUS
NET_API_FUNCTION
NetValidateName(
    IN  LPCWSTR             lpServer OPTIONAL,
    IN  LPCWSTR             lpName,
    IN  LPCWSTR             lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR             lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    );

//
// Determines whether a workstation is joined to a domain or not
//
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinInformation(
    __in_opt IN   LPCWSTR                lpServer OPTIONAL,
    __out_opt OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    );


//
// Determines the list of OUs that the client can create a machine account in
//
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinableOUs(
    IN  LPCWSTR     lpServer OPTIONAL,
    IN  LPCWSTR     lpDomain,
    IN  LPCWSTR     lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR     lpPassword OPTIONAL,
    __out_opt OUT DWORD      *OUCount,
    __deref_out OUT LPWSTR    **OUs
    );
    
#if(_WIN32_WINNT >= 0x0501)

//
// Computer rename preparation APIs
//

#define NET_IGNORE_UNSUPPORTED_FLAGS  0x01

NET_API_STATUS
NET_API_FUNCTION
NetAddAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

NET_API_STATUS
NET_API_FUNCTION
NetRemoveAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

NET_API_STATUS
NET_API_FUNCTION
NetSetPrimaryComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR PrimaryName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

//
// The following enumeration must be kept
// in sync with COMPUTER_NAME_TYPE defined
// in winbase.h
//

typedef enum _NET_COMPUTER_NAME_TYPE {
    NetPrimaryComputerName,
    NetAlternateComputerNames,
    NetAllComputerNames,
    NetComputerNameTypeMax
} NET_COMPUTER_NAME_TYPE, *PNET_COMPUTER_NAME_TYPE;

NET_API_STATUS
NET_API_FUNCTION
NetEnumerateComputerNames(
    IN  LPCWSTR Server OPTIONAL,
    IN  NET_COMPUTER_NAME_TYPE NameType,
    IN  ULONG Reserved,
    __out OUT PDWORD EntryCount,
    __deref_out OUT LPWSTR **ComputerNames
    );
    
#endif // (_WIN32_WINNT >= 0x0501) 

#ifdef __cplusplus
}
#endif

#endif // __LMJOIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMErrlog.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmerrlog.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetErrorLog

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMERRLOG_
#define _LMERRLOG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data Structures - Config
//

typedef struct _ERROR_LOG {
     DWORD         el_len;
     DWORD         el_reserved;
     DWORD         el_time;
     DWORD         el_error;
     LPWSTR        el_name;             // pointer to service name
     LPWSTR        el_text;             // pointer to string array
     LPBYTE        el_data;             // pointer to BYTE array
     DWORD         el_data_size;        // byte count of el_data area
     DWORD         el_nstrings;         // number of strings in el_text.
} ERROR_LOG, *PERROR_LOG, *LPERROR_LOG;


#define REVISED_ERROR_LOG_STRUCT


#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD    0
#define LOGFLAGS_BACKWARD   0x1
#define LOGFLAGS_SEEK       0x2

#endif

//
// Function Prototypes - ErrorLog
//

NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    __in_opt LPCWSTR UncServerName,
    __in_opt LPCWSTR BackupFile,
    __in_opt LPBYTE  Reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    __in_opt    LPCWSTR   UncServerName,
    __in_opt    LPWSTR    Reserved1,
    __in        LPHLOG    ErrorLogHandle,
    __in        DWORD     Offset,
    __in_opt    LPDWORD   Reserved2,
    __in        DWORD     Reserved3,
    __in        DWORD     OffsetFlag,
    __deref_out LPBYTE   *BufPtr,
    __in        DWORD     PrefMaxSize,
    __out       LPDWORD   BytesRead,
    __out       LPDWORD   TotalAvailable
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    __in_opt LPBYTE  Reserved1,
    __in     DWORD   Code,
    __in     LPCWSTR Component,
    __in     LPBYTE  Buffer,
    __in     DWORD   NumBytes,
    __in     LPBYTE  MsgBuf,
    __in     DWORD   StrCount,
    __in_opt LPBYTE  Reserved2
    );

//
// Special Values and Constants
//


//
//  Generic (could be used by more than one service)
//   error log messages from 0 to 25
//
// Do not change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ERRLOG_BASE 3100        /* NELOG errors start here */

#define NELOG_Internal_Error        (ERRLOG_BASE + 0)
    /*
    * The operation failed because a network software error occurred.
    */

#define NELOG_Resource_Shortage     (ERRLOG_BASE + 1)
    /*
    * The system ran out of a resource controlled by the %1 option.
    */

#define NELOG_Unable_To_Lock_Segment    (ERRLOG_BASE + 2)
    /*
    * The service failed to obtain a long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Unable_To_Unlock_Segment  (ERRLOG_BASE + 3)
    /*
    * The service failed to release the long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Uninstall_Service     (ERRLOG_BASE + 4)
    /*
    * There was an error stopping service %1.
    *  The error code from NetServiceControl is the data.
    */

#define NELOG_Init_Exec_Fail        (ERRLOG_BASE + 5)
    /*
    * Initialization failed because of a system execution failure on
    *  path %1. The system error code is the data.
    */

#define NELOG_Ncb_Error         (ERRLOG_BASE + 6)
    /*
    * An unexpected network control block (NCB) was received. The NCB is the data.
    */

#define NELOG_Net_Not_Started       (ERRLOG_BASE + 7)
    /*
    * The network is not started.
    */

#define NELOG_Ioctl_Error       (ERRLOG_BASE + 8)
    /*
    * A DosDevIoctl or DosFsCtl to NETWKSTA.SYS failed.
    * The data shown is in this format:
    *     DWORD  approx CS:IP of call to ioctl or fsctl
    *     WORD   error code
    *     WORD   ioctl or fsctl number
    */

#define NELOG_System_Semaphore      (ERRLOG_BASE + 9)
    /*
    * Unable to create or open system semaphore %1.
    *  The error code is the data.
    */

#define NELOG_Init_OpenCreate_Err   (ERRLOG_BASE + 10)
    /*
    * Initialization failed because of an open/create error on the
    *  file %1. The system error code is the data.
    */

#define NELOG_NetBios           (ERRLOG_BASE + 11)
    /*
    * An unexpected NetBIOS error occurred.
    *  The error code is the data.
    */

#define NELOG_SMB_Illegal       (ERRLOG_BASE + 12)
    /*
    * An illegal server message block (SMB) was received.
    *  The SMB is the data.
    */

#define NELOG_Service_Fail      (ERRLOG_BASE + 13)
    /*
    * Initialization failed because the requested service %1
    *  could not be started.
   */

#define NELOG_Entries_Lost      (ERRLOG_BASE + 14)
    /*
    * Some entries in the error log were lost because of a buffer
    * overflow.
    */


//
//  Server specific error log messages from 20 to 40
//

#define NELOG_Init_Seg_Overflow     (ERRLOG_BASE + 20)
    /*
    * Initialization parameters controlling resource usage other
    *  than net buffers are sized so that too much memory is needed.
    */

#define NELOG_Srv_No_Mem_Grow       (ERRLOG_BASE + 21)
    /*
    * The server cannot increase the size of a memory segment.
    */

#define NELOG_Access_File_Bad       (ERRLOG_BASE + 22)
    /*
    * Initialization failed because account file %1 is either incorrect
    * or not present.
    */

#define NELOG_Srvnet_Not_Started    (ERRLOG_BASE + 23)
    /*
    * Initialization failed because network %1 was not started.
    */

#define NELOG_Init_Chardev_Err      (ERRLOG_BASE + 24)
    /*
    * The server failed to start. Either all three chdev
    *  parameters must be zero or all three must be nonzero.
    */

#define NELOG_Remote_API        (ERRLOG_BASE + 25)
    /* A remote API request was halted due to the following
    * invalid description string: %1.
    */

#define NELOG_Ncb_TooManyErr        (ERRLOG_BASE + 26)
    /* The network %1 ran out of network control blocks (NCBs).  You may need to increase NCBs
    * for this network.  The following information includes the
    * number of NCBs submitted by the server when this error occurred:
    */

#define NELOG_Mailslot_err      (ERRLOG_BASE + 27)
    /* The server cannot create the %1 mailslot needed to send
    * the ReleaseMemory alert message.  The error received is:
    */

#define NELOG_ReleaseMem_Alert      (ERRLOG_BASE + 28)
    /* The server failed to register for the ReleaseMemory alert,
    * with recipient %1. The error code from
    * NetAlertStart is the data.
    */

#define NELOG_AT_cannot_write       (ERRLOG_BASE + 29)
    /* The server cannot update the AT schedule file. The file
    * is corrupted.
    */

#define NELOG_Cant_Make_Msg_File    (ERRLOG_BASE + 30)
    /* The server encountered an error when calling
    * NetIMakeLMFileName. The error code is the data.
    */

#define NELOG_Exec_Netservr_NoMem   (ERRLOG_BASE + 31)
    /* Initialization failed because of a system execution failure on
    * path %1. There is not enough memory to start the process.
    * The system error code is the data.
    */

#define NELOG_Server_Lock_Failure   (ERRLOG_BASE + 32)
    /* Longterm lock of the server buffers failed.
    * Check swap disk's free space and restart the system to start the server.
    */

//
//  Message service and POPUP specific error log messages from 40 to 55
//

#define NELOG_Msg_Shutdown      (ERRLOG_BASE + 40)
    /*
    * The service has stopped due to repeated consecutive
    *  occurrences of a network control block (NCB) error.  The last bad NCB follows
    *  in raw data.
    */

#define NELOG_Msg_Sem_Shutdown      (ERRLOG_BASE + 41)
    /*
    * The Message server has stopped due to a lock on the
    *  Message server shared data segment.
    */

#define NELOG_Msg_Log_Err       (ERRLOG_BASE + 50)
    /*
    * A file system error occurred while opening or writing to the
    *  system message log file %1. Message logging has been
    *  switched off due to the error. The error code is the data.
    */



#define NELOG_VIO_POPUP_ERR     (ERRLOG_BASE + 51)
    /*
    * Unable to display message POPUP due to system VIO call error.
    *  The error code is the data.
    */

#define NELOG_Msg_Unexpected_SMB_Type   (ERRLOG_BASE + 52)
    /*
    * An illegal server message block (SMB) was received.  The SMB is the data.
    */

//
//  Workstation specific error log messages from 60 to 75
//


#define NELOG_Wksta_Infoseg     (ERRLOG_BASE + 60)
    /*
    * The workstation information segment is bigger than 64K.
    *  The size follows, in DWORD format:
    */

#define NELOG_Wksta_Compname        (ERRLOG_BASE + 61)
    /*
    * The workstation was unable to get the name-number of the computer.
    */

#define NELOG_Wksta_BiosThreadFailure   (ERRLOG_BASE + 62)
    /*
    * The workstation could not initialize the Async NetBIOS Thread.
    *  The error code is the data.
    */

#define NELOG_Wksta_IniSeg      (ERRLOG_BASE + 63)
    /*
    * The workstation could not open the initial shared segment.
    *  The error code is the data.
    */

#define NELOG_Wksta_HostTab_Full    (ERRLOG_BASE + 64)
    /*
    * The workstation host table is full.
    */

#define NELOG_Wksta_Bad_Mailslot_SMB    (ERRLOG_BASE + 65)
    /*
    * A bad mailslot server message block (SMB) was received.  The SMB is the data.
    */

#define NELOG_Wksta_UASInit     (ERRLOG_BASE + 66)
    /*
    * The workstation encountered an error while trying to start the user accounts database.
    *  The error code is the data.
    */

#define NELOG_Wksta_SSIRelogon      (ERRLOG_BASE + 67)
    /*
    * The workstation encountered an error while responding to an SSI revalidation request.
    *  The function code and the error codes are the data.
    */

//
//  Alerter service specific error log messages from 70 to 79
//


#define NELOG_Build_Name        (ERRLOG_BASE + 70)
    /*
    * The Alerter service had a problem creating the list of
    * alert recipients.  The error code is %1.
    */

#define NELOG_Name_Expansion        (ERRLOG_BASE + 71)
    /*
    * There was an error expanding %1 as a group name. Try
    *  splitting the group into two or more smaller groups.
    */

#define NELOG_Message_Send      (ERRLOG_BASE + 72)
    /*
    * There was an error sending %2 the alert message -
    *  (
    *  %3 )
    *  The error code is %1.
    */

#define NELOG_Mail_Slt_Err      (ERRLOG_BASE + 73)
    /*
    * There was an error in creating or reading the alerter mailslot.
    *  The error code is %1.
    */

#define NELOG_AT_cannot_read        (ERRLOG_BASE + 74)
    /*
    * The server could not read the AT schedule file.
    */

#define NELOG_AT_sched_err      (ERRLOG_BASE + 75)
    /*
    * The server found an invalid AT schedule record.
    */

#define NELOG_AT_schedule_file_created  (ERRLOG_BASE + 76)
    /*
    * The server could not find an AT schedule file so it created one.
    */

#define NELOG_Srvnet_NB_Open        (ERRLOG_BASE + 77)
    /*
    * The server could not access the %1 network with NetBiosOpen.
    */

#define NELOG_AT_Exec_Err       (ERRLOG_BASE + 78)
    /*
    * The AT command processor could not run %1.
   */

//
//      Cache Lazy Write and HPFS386 specific error log messages from 80 to 89
//

#define NELOG_Lazy_Write_Err            (ERRLOG_BASE + 80)
        /*
        * WARNING:  Because of a lazy-write error, drive %1 now
        *  contains some corrupted data.  The cache is stopped.
        */

#define NELOG_HotFix            (ERRLOG_BASE + 81)
    /*
    * A defective sector on drive %1 has been replaced (hotfixed).
    * No data was lost.  You should run CHKDSK soon to restore full
    * performance and replenish the volume's spare sector pool.
    *
    * The hotfix occurred while processing a remote request.
    */

#define NELOG_HardErr_From_Server   (ERRLOG_BASE + 82)
    /*
    * A disk error occurred on the HPFS volume in drive %1.
    * The error occurred while processing a remote request.
    */

#define NELOG_LocalSecFail1 (ERRLOG_BASE + 83)
    /*
    * The user accounts database (NET.ACC) is corrupted.  The local security
    * system is replacing the corrupted NET.ACC with the backup
    * made at %1.
    * Any updates made to the database after this time are lost.
    *
    */

#define NELOG_LocalSecFail2 (ERRLOG_BASE + 84)
    /*
    * The user accounts database (NET.ACC) is missing.  The local
    * security system is restoring the backup database
    * made at %1.
    * Any updates made to the database made after this time are lost.
    *
    */

#define NELOG_LocalSecFail3 (ERRLOG_BASE + 85)
    /*
    * Local security could not be started because the user accounts database
    * (NET.ACC) was missing or corrupted, and no usable backup
    * database was present.
    *
    * THE SYSTEM IS NOT SECURE.
    */

#define NELOG_LocalSecGeneralFail   (ERRLOG_BASE + 86)
    /*
    * Local security could not be started because an error
    * occurred during initialization. The error code returned is %1.
    *
    * THE SYSTEM IS NOT SECURE.
    *
    */

//
//  NETWKSTA.SYS specific error log messages from 90 to 99
//

#define NELOG_NetWkSta_Internal_Error   (ERRLOG_BASE + 90)
    /*
    * A NetWksta internal error has occurred:
    *  %1
    */

#define NELOG_NetWkSta_No_Resource  (ERRLOG_BASE + 91)
    /*
    * The redirector is out of a resource: %1.
    */

#define NELOG_NetWkSta_SMB_Err      (ERRLOG_BASE + 92)
    /*
    * A server message block (SMB) error occurred on the connection to %1.
    *  The SMB header is the data.
    */

#define NELOG_NetWkSta_VC_Err       (ERRLOG_BASE + 93)
    /*
    * A virtual circuit error occurred on the session to %1.
    *  The network control block (NCB) command and return code is the data.
    */

#define NELOG_NetWkSta_Stuck_VC_Err (ERRLOG_BASE + 94)
    /*
    * Hanging up a stuck session to %1.
    */

#define NELOG_NetWkSta_NCB_Err      (ERRLOG_BASE + 95)
    /*
    * A network control block (NCB) error occurred (%1).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Write_Behind_Err (ERRLOG_BASE + 96)
    /*
    * A write operation to %1 failed.
    *  Data may have been lost.
    */

#define NELOG_NetWkSta_Reset_Err    (ERRLOG_BASE + 97)
    /*
    * Reset of driver %1 failed to complete the network control block (NCB).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Too_Many     (ERRLOG_BASE + 98)
    /*
    * The amount of resource %1 requested was more
    *  than the maximum. The maximum amount was allocated.
    */

//
//  Spooler specific error log messages from 100 to 103
//

#define NELOG_Srv_Thread_Failure        (ERRLOG_BASE + 104)
    /*
    * The server could not create a thread.
    *  The THREADS parameter in the CONFIG.SYS file should be increased.
    */

#define NELOG_Srv_Close_Failure         (ERRLOG_BASE + 105)
    /*
    * The server could not close %1.
    *  The file is probably corrupted.
    */

#define NELOG_ReplUserCurDir               (ERRLOG_BASE + 106)
    /*
    *The replicator cannot update directory %1. It has tree integrity
    * and is the current directory for some process.
    */

#define NELOG_ReplCannotMasterDir       (ERRLOG_BASE + 107)
    /*
    *The server cannot export directory %1 to client %2.
    * It is exported from another server.
    */

#define NELOG_ReplUpdateError           (ERRLOG_BASE + 108)
    /*
    *The replication server could not update directory %2 from the source
    * on %3 due to error %1.
    */

#define NELOG_ReplLostMaster            (ERRLOG_BASE + 109)
    /*
    *Master %1 did not send an update notice for directory %2 at the expected
    * time.
    */

#define NELOG_NetlogonAuthDCFail        (ERRLOG_BASE + 110)
    /*
    *This computer could not authenticate with %2, a Windows domain controller
    * for domain %1, and therefore this computer might deny logon requests.
    * This inability to authenticate might be caused by another computer on the
    * same network using the same name or the password for this computer account
    * is not recognized. If this message appears again, contact your system
    * administrator.
    */

#define NELOG_ReplLogonFailed           (ERRLOG_BASE + 111)
    /*
    *The replicator attempted to log on at %2 as %1 and failed.
    */

#define NELOG_ReplNetErr            (ERRLOG_BASE + 112)
    /*
    *  Network error %1 occurred.
    */

#define NELOG_ReplMaxFiles            (ERRLOG_BASE + 113)
    /*
    *  Replicator limit for files in a directory has been exceeded.
    */


#define NELOG_ReplMaxTreeDepth            (ERRLOG_BASE + 114)
    /*
    *  Replicator limit for tree depth has been exceeded.
    */

#define NELOG_ReplBadMsg             (ERRLOG_BASE + 115)
    /*
    *  Unrecognized message received in mailslot.
    */

#define NELOG_ReplSysErr            (ERRLOG_BASE + 116)
    /*
    *  System error %1 occurred.
    */

#define NELOG_ReplUserLoged          (ERRLOG_BASE + 117)
    /*
    *  Cannot log on. User is currently logged on and argument TRYUSER
    *  is set to NO.
    */

#define NELOG_ReplBadImport           (ERRLOG_BASE + 118)
    /*
    *  IMPORT path %1 cannot be found.
    */

#define NELOG_ReplBadExport           (ERRLOG_BASE + 119)
    /*
    *  EXPORT path %1 cannot be found.
    */

#define NELOG_ReplSignalFileErr           (ERRLOG_BASE + 120)
    /*
    *  Replicator failed to update signal file in directory %2 due to
    *  %1 system error.
    */

#define NELOG_DiskFT                (ERRLOG_BASE+121)
    /*
    * Disk Fault Tolerance Error
    *
    * %1
    */

#define NELOG_ReplAccessDenied           (ERRLOG_BASE + 122)
    /*
    *  Replicator could not access %2
    *  on %3 due to system error %1.
    */

#define NELOG_NetlogonFailedPrimary      (ERRLOG_BASE + 123)
    /*
    *The primary domain controller for domain %1 has apparently failed.
    */

#define NELOG_NetlogonPasswdSetFailed (ERRLOG_BASE + 124)
    /*
    * Changing machine account password for account %1 failed with
    * the following error: %n%2
    */

#define NELOG_NetlogonTrackingError      (ERRLOG_BASE + 125)
    /*
    *An error occurred while updating the logon or logoff information for %1.
    */

#define NELOG_NetlogonSyncError          (ERRLOG_BASE + 126)
    /*
    *An error occurred while synchronizing with primary domain controller %1
    */

#define NELOG_NetlogonRequireSignOrSealError (ERRLOG_BASE + 127)
    /*
    * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
    * failed because %1 does not support signing or sealing the Netlogon
    * session.
    *
    * Either upgrade the Domain controller or set the RequireSignOrSeal
    * registry entry on this machine to 0.
    */

//
//  UPS service specific error log messages from 130 to 135
//

#define NELOG_UPS_PowerOut      (ERRLOG_BASE + 130)
    /*
    * A power failure was detected at the server.
    */

#define NELOG_UPS_Shutdown      (ERRLOG_BASE + 131)
    /*
    * The UPS service performed server shut down.
    */

#define NELOG_UPS_CmdFileError      (ERRLOG_BASE + 132)
    /*
    * The UPS service did not complete execution of the
    * user specified shut down command file.
    */

#define NELOG_UPS_CannotOpenDriver  (ERRLOG_BASE+133)
    /*
    * The UPS driver could not be opened.  The error code is
    * the data.
    */

#define NELOG_UPS_PowerBack     (ERRLOG_BASE + 134)
    /*
    * Power has been restored.
    */

#define NELOG_UPS_CmdFileConfig     (ERRLOG_BASE + 135)
    /*
    * There is a problem with a configuration of user specified
    * shut down command file.
    */

#define NELOG_UPS_CmdFileExec       (ERRLOG_BASE + 136)
    /*
    * The UPS service failed to execute a user specified shutdown
    * command file %1.  The error code is the data.
    */

//
//  Remoteboot server specific error log messages are from 150 to 157
//

#define NELOG_Missing_Parameter     (ERRLOG_BASE + 150)
    /*
    * Initialization failed because of an invalid or missing
    *  parameter in the configuration file %1.
    */

#define NELOG_Invalid_Config_Line   (ERRLOG_BASE + 151)
    /*
    * Initialization failed because of an invalid line in the
    *  configuration file %1. The invalid line is the data.
    */

#define NELOG_Invalid_Config_File   (ERRLOG_BASE + 152)
    /*
    * Initialization failed because of an error in the configuration
    *  file %1.
    */

#define NELOG_File_Changed      (ERRLOG_BASE + 153)
    /*
    * The file %1 has been changed after initialization.
    *  The boot-block loading was temporarily terminated.
    */

#define NELOG_Files_Dont_Fit        (ERRLOG_BASE + 154)
    /*
    * The files do not fit to the boot-block configuration
    * file %1. Change the BASE and ORG definitions or the order
    * of the files.
    */

#define NELOG_Wrong_DLL_Version     (ERRLOG_BASE + 155)
    /*
    * Initialization failed because the dynamic-link
    *  library %1 returned an incorrect version number.
    */

#define NELOG_Error_in_DLL      (ERRLOG_BASE + 156)
    /*
    * There was an unrecoverable error in the dynamic-
    *  link library of the service.
    */

#define NELOG_System_Error      (ERRLOG_BASE + 157)
    /*
    * The system returned an unexpected error code.
    *  The error code is the data.
    */

#define NELOG_FT_ErrLog_Too_Large (ERRLOG_BASE + 158)
    /*
    * The fault-tolerance error log file, LANROOT\LOGS\FT.LOG,
    *  is more than 64K.
    */

#define NELOG_FT_Update_In_Progress (ERRLOG_BASE + 159)
    /*
    * The fault-tolerance error-log file, LANROOT\LOGS\FT.LOG, had the
    * update in progress bit set upon opening, which means that the
    * system crashed while working on the error log.
    */

#define NELOG_Joined_Domain         (ERRLOG_BASE + 160)
    /*
    * This computer has been successfully joined to domain '%1'.
    */

#define NELOG_Joined_Workgroup      (ERRLOG_BASE + 161)
    /*
    * This computer has been successfully joined to workgroup '%1'.
    */


//
// Microsoft has created a generic error log entry for OEMs to use to
// log errors from OEM value added services.  The code, which is the
// 2nd arg to NetErrorLogWrite, is 3299.  This value is manifest in
// NET/H/ERRLOG.H as NELOG_OEM_Code.  The text for error log entry
// NELOG_OEM_Code is:  "%1 %2 %3 %4 %5 %6 %7 %8 %9.".
//
// Microsoft suggests that OEMs use the insertion strings as follows:
// %1:  OEM System Name (e.g. 3+Open)
// %2:  OEM Service Name (e.g. 3+Mail)
// %3:  Severity level (e.g.  error, warning, etc.)
// %4:  OEM error log entry sub-identifier  (e.g. error code #)
// %5 - % 9:  Text.
//
// The call to NetErrorWrite must set nstrings = 9, and provide 9
// ASCIIZ strings.  If the caller does not have 9 insertion strings,
// provide null strings for the empty insertion strings.
//

#define NELOG_OEM_Code              (ERRLOG_BASE + 199)
    /*
    * %1 %2 %3 %4 %5 %6 %7 %8 %9.
    */

//
// another error log range defined for NT Lanman.
//

#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */

#define NELOG_NetlogonSSIInitError              (ERRLOG2_BASE + 0)
    /*
     * The Netlogon service could not initialize the replication data
     * structures successfully. The service was terminated.  The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonFailedToUpdateTrustList   (ERRLOG2_BASE + 1)
    /*
     * The Netlogon service failed to update the domain trust list.  The
     * following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToAddRpcInterface   (ERRLOG2_BASE + 2)
    /*
     * The Netlogon service could not add the RPC interface.  The
     * service was terminated. The following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToReadMailslot      (ERRLOG2_BASE + 3)
    /*
     * The Netlogon service could not read a mailslot message from %1 due
     * to the following error: %n%2
     */

#define NELOG_NetlogonFailedToRegisterSC        (ERRLOG2_BASE + 4)
    /*
     * The Netlogon service failed to register the service with the
     * service controller. The service was terminated. The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonChangeLogCorrupt          (ERRLOG2_BASE + 5)
    /*
     * The change log cache maintained by the Netlogon service for %1
     * database changes is inconsistent. The Netlogon service is resetting
     * the change log.
     */

#define NELOG_NetlogonFailedToCreateShare       (ERRLOG2_BASE + 6)
    /*
     * The Netlogon service could not create server share %1.  The following
     * error occurred: %n%2
     */

#define NELOG_NetlogonDownLevelLogonFailed      (ERRLOG2_BASE + 7)
    /*
     * The down-level logon request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonDownLevelLogoffFailed     (ERRLOG2_BASE + 8)
    /*
     * The down-level logoff request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonNTLogonFailed             (ERRLOG2_BASE + 9)
    /*
     * The Windows NT or Windows 2000 %1 logon request for the user %2\%3 from %4 (via %5)
     * failed.
     */

#define NELOG_NetlogonNTLogoffFailed            (ERRLOG2_BASE + 10)
    /*
     * The Windows NT or Windows 2000 %1 logoff request for the user %2\%3 from %4
     * failed.
     */

#define NELOG_NetlogonPartialSyncCallSuccess    (ERRLOG2_BASE + 11)
    /*
     * The partial synchronization request from the server %1 completed
     * successfully. %2 changes(s) has(have) been returned to the
     * caller.
     */

#define NELOG_NetlogonPartialSyncCallFailed     (ERRLOG2_BASE + 12)
    /*
     * The partial synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonFullSyncCallSuccess       (ERRLOG2_BASE + 13)
    /*
     * The full synchronization request from the server %1 completed
     * successfully. %2 object(s) has(have) been returned to
     * the caller.
     */

#define NELOG_NetlogonFullSyncCallFailed        (ERRLOG2_BASE + 14)
    /*
     * The full synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonPartialSyncSuccess        (ERRLOG2_BASE + 15)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully. %3 change(s) is(are)
     * applied to the database.
     */


#define NELOG_NetlogonPartialSyncFailed         (ERRLOG2_BASE + 16)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonFullSyncSuccess           (ERRLOG2_BASE + 17)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully.
     */


#define NELOG_NetlogonFullSyncFailed            (ERRLOG2_BASE + 18)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonAuthNoDomainController    (ERRLOG2_BASE + 19)
    /*
     * This computer was not able to set up a secure session with a domain
     * controller in domain %1 due to the following: %n%2
     * %nThis may lead to authentication problems. Make sure that this
     * computer is connected to the network. If the problem persists,
     * please contact your domain administrator.
     *
     * %n%nADDITIONAL INFO
     * %nIf this computer is a domain controller for the specified domain, it
     * sets up the secure session to the primary domain controller emulator in the specified
     * domain. Otherwise, this computer sets up the secure session to any domain controller
     * in the specified domain.
     */

#define NELOG_NetlogonAuthNoTrustLsaSecret      (ERRLOG2_BASE + 20)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the computer %3 does not have a local security database account.
     */

#define NELOG_NetlogonAuthNoTrustSamAccount     (ERRLOG2_BASE + 21)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the Domain Controller did not have an account %4
     * needed to set up the session by this computer %3.
     *
     * %n%nADDITIONAL DATA
     * %nIf this computer is a member of or a Domain Controller in the specified domain, the
     * aforementioned account is a computer account for this computer in the specified domain.
     * Otherwise, the account is an interdomain trust account with the specified domain.
     */

#define NELOG_NetlogonServerAuthFailed          (ERRLOG2_BASE + 22)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The name(s) of the account(s) referenced in the security database is
     * %2.  The following error occurred: %n%3
     */

#define NELOG_NetlogonServerAuthNoTrustSamAccount (ERRLOG2_BASE + 23)
    /*
     * The session setup from computer '%1' failed because the security database
     * does not contain a trust account '%2' referenced by the specified computer.
     *
     * %n%nUSER ACTION
     *
     * %nIf this is the first occurrence of this event for the specified computer
     * and account, this may be a transient issue that doesn't require any action
     * at this time.
     *      
     * If this is a Read-Only Domain Controller and '%2' is a legitimate machine
     * account for the computer '%1' then '%1' should be marked cacheable for this
     * location if appropriate or otherwise ensure connectivity to a domain controller 
     * capable of servicing the request (for example a writable domain controller).
     *      
     * Otherwise, the following steps may be taken to resolve this problem:
     *
     * %n%nIf '%2' is a legitimate machine account for the computer '%1', then '%1'
     * should be rejoined to the domain.
     *
     * %n%nIf '%2' is a legitimate interdomain trust account, then the trust should
     * be recreated.
     *
     * %n%nOtherwise, assuming that '%2' is not a legitimate account, the following
     * action should be taken on '%1':
     *
     * %n%nIf '%1' is a Domain Controller, then the trust associated with '%2' should be deleted.
     *
     * %n%nIf '%1' is not a Domain Controller, it should be disjoined from the domain.
     */

//
// General log messages for NT services.
//

#define NELOG_FailedToRegisterSC                  (ERRLOG2_BASE + 24)
    /*
     * Could not register control handler with service controller %1.
     */

#define NELOG_FailedToSetServiceStatus            (ERRLOG2_BASE + 25)
    /*
     * Could not set service status with service controller %1.
     */

#define NELOG_FailedToGetComputerName             (ERRLOG2_BASE + 26)
    /*
     * Could not find the computer name %1.
     */

#define NELOG_DriverNotLoaded                     (ERRLOG2_BASE + 27)
    /*
     * Could not load %1 device driver.
     */

#define NELOG_NoTranportLoaded                    (ERRLOG2_BASE + 28)
    /*
     * Could not load any transport.
     */

//
// More Netlogon service events
//

#define NELOG_NetlogonFailedDomainDelta           (ERRLOG2_BASE + 29)
    /*
     * Replication of the %1 Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedGlobalGroupDelta      (ERRLOG2_BASE + 30)
    /*
     * Replication of the %1 Global Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedLocalGroupDelta       (ERRLOG2_BASE + 31)
    /*
     * Replication of the %1 Local Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedUserDelta             (ERRLOG2_BASE + 32)
    /*
     * Replication of the %1 User "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedPolicyDelta           (ERRLOG2_BASE + 33)
    /*
     * Replication of the %1 Policy Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedTrustedDomainDelta    (ERRLOG2_BASE + 34)
    /*
     * Replication of the %1 Trusted Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedAccountDelta          (ERRLOG2_BASE + 35)
    /*
     * Replication of the %1 Account Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedSecretDelta           (ERRLOG2_BASE + 36)
    /*
     * Replication of the %1 Secret "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonSystemError                 (ERRLOG2_BASE + 37)
    /*
    * The system returned the following unexpected error code: %n%1
    */

#define NELOG_NetlogonDuplicateMachineAccounts    (ERRLOG2_BASE + 38)
    /*
    * Netlogon has detected two machine accounts for server "%1".
    * The server can be either a Windows 2000 Server that is a member of the
    * domain or the server can be a LAN Manager server with an account in the
    * SERVERS global group.  It cannot be both.
    */

#define NELOG_NetlogonTooManyGlobalGroups         (ERRLOG2_BASE + 39)
    /*
    * This domain has more global groups than can be replicated to a LanMan
    * BDC.  Either delete some of your global groups or remove the LanMan
    * BDCs from the domain.
    */

#define NELOG_NetlogonBrowserDriver               (ERRLOG2_BASE + 40)
    /*
    * The Browser driver returned the following error to Netlogon: %n%1
    */

#define NELOG_NetlogonAddNameFailure              (ERRLOG2_BASE + 41)
    /*
    * Netlogon could not register the %1<1B> name for the following reason: %n%2
    */

//
//  More Remoteboot service events.
//
#define NELOG_RplMessages                         (ERRLOG2_BASE + 42)
    /*
    * Service failed to retrieve messages needed to boot remote boot clients.
    */

#define NELOG_RplXnsBoot                          (ERRLOG2_BASE + 43)
    /*
    * Service experienced a severe error and can no longer provide remote boot
    * for 3Com 3Start remote boot clients.
    */

#define NELOG_RplSystem                           (ERRLOG2_BASE + 44)
    /*
    * Service experienced a severe system error and will shut itself down.
    */

#define NELOG_RplWkstaTimeout                     (ERRLOG2_BASE + 45)
    /*
    * Client with computer name %1 failed to acknowledge receipt of the
    * boot data.  Remote boot of this client was not completed.
    */

#define NELOG_RplWkstaFileOpen                    (ERRLOG2_BASE + 46)
    /*
    * Client with computer name %1 was not booted due to an error in opening
    * file %2.
    */

#define NELOG_RplWkstaFileRead                    (ERRLOG2_BASE + 47)
    /*
    * Client with computer name %1 was not booted due to an error in reading
    * file %2.
    */

#define NELOG_RplWkstaMemory                      (ERRLOG2_BASE + 48)
    /*
    * Client with computer name %1 was not booted due to insufficient memory
    * at the remote boot server.
    */

#define NELOG_RplWkstaFileChecksum                (ERRLOG2_BASE + 49)
    /*
    * Client with computer name %1 will be booted without using checksums
    * because checksum for file %2 could not be calculated.
    */

#define NELOG_RplWkstaFileLineCount               (ERRLOG2_BASE + 50)
    /*
    * Client with computer name %1 was not booted due to too many lines in
    * file %2.
    */

#define NELOG_RplWkstaBbcFile                     (ERRLOG2_BASE + 51)
    /*
    * Client with computer name %1 was not booted because the boot block
    * configuration file %2 for this client does not contain boot block
    * line and/or loader line.
    */

#define NELOG_RplWkstaFileSize                    (ERRLOG2_BASE + 52)
    /*
    * Client with computer name %1 was not booted due to a bad size of
    * file %2.
    */

#define NELOG_RplWkstaInternal                    (ERRLOG2_BASE + 53)
    /*
    * Client with computer name %1 was not booted due to remote boot
    * service internal error.
    */

#define NELOG_RplWkstaWrongVersion                (ERRLOG2_BASE + 54)
    /*
    * Client with computer name %1 was not booted because file %2 has an
    * invalid boot header.
    */

#define NELOG_RplWkstaNetwork                     (ERRLOG2_BASE + 55)
    /*
    * Client with computer name %1 was not booted due to network error.
    */

#define NELOG_RplAdapterResource                  (ERRLOG2_BASE + 56)
    /*
    * Client with adapter id %1 was not booted due to lack of resources.
    */

#define NELOG_RplFileCopy                         (ERRLOG2_BASE + 57)
    /*
    * Service experienced error copying file or directory %1.
    */

#define NELOG_RplFileDelete                       (ERRLOG2_BASE + 58)
    /*
    * Service experienced error deleting file or directory %1.
    */

#define NELOG_RplFilePerms                        (ERRLOG2_BASE + 59)
    /*
    * Service experienced error setting permissions on file or directory %1.
    */
#define NELOG_RplCheckConfigs                     (ERRLOG2_BASE + 60)
    /*
    * Service experienced error evaluating RPL configurations.
    */
#define NELOG_RplCreateProfiles                   (ERRLOG2_BASE + 61)
    /*
    * Service experienced error creating RPL profiles for all configurations.
    */
#define NELOG_RplRegistry                         (ERRLOG2_BASE + 62)
    /*
    * Service experienced error accessing registry.
    */
#define NELOG_RplReplaceRPLDISK                   (ERRLOG2_BASE + 63)
    /*
    * Service experienced error replacing possibly outdated RPLDISK.SYS.
    */
#define NELOG_RplCheckSecurity                    (ERRLOG2_BASE + 64)
    /*
    * Service experienced error adding security accounts or setting
    * file permissions.  These accounts are the RPLUSER local group
    * and the user accounts for the individual RPL workstations.
    */
#define NELOG_RplBackupDatabase                   (ERRLOG2_BASE + 65)
    /*
    * Service failed to back up its database.
    */
#define NELOG_RplInitDatabase                     (ERRLOG2_BASE + 66)
    /*
    * Service failed to initialize from its database.  The database may be
    * missing or corrupted.  Service will attempt restoring the database
    * from the backup.
    */
#define NELOG_RplRestoreDatabaseFailure           (ERRLOG2_BASE + 67)
    /*
    * Service failed to restore its database from the backup.  Service
    * will not start.
    */
#define NELOG_RplRestoreDatabaseSuccess           (ERRLOG2_BASE + 68)
    /*
    * Service successfully restored its database from the backup.
    */
#define NELOG_RplInitRestoredDatabase             (ERRLOG2_BASE + 69)
    /*
    * Service failed to initialize from its restored database.  Service
    * will not start.
    */

//
// More Netlogon and RPL service events
//
#define NELOG_NetlogonSessionTypeWrong            (ERRLOG2_BASE + 70)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 from computer
     * %2 using account %4 failed.  %2 is declared to be a BDC in domain %3.
     * However, %2 tried to connect as either a DC in a trusted domain,
     * a member workstation in domain %3, or as a server in domain %3.
     * Use the Active Directory Users and Computers tool or Server Manager to remove the BDC account for %2.
     */
#define NELOG_RplUpgradeDBTo40                    (ERRLOG2_BASE + 71)
    /*
    * The Remoteboot database was in NT 3.5 / NT 3.51 format and NT is
    * attempting to convert it to NT 4.0 format. The JETCONV converter
    * will write to the Application event log when it is finished.
    */
#define NELOG_NetlogonLanmanBdcsNotAllowed        (ERRLOG2_BASE + 72)
    /*
     * Global group SERVERS exists in domain %1 and has members.
     * This group defines Lan Manager BDCs in the domain.
     * Lan Manager BDCs are not permitted in NT domains.
     */
#define NELOG_NetlogonNoDynamicDns                (ERRLOG2_BASE + 73)
    /*
     * The following DNS server that is authoritative for the DNS domain controller
     * locator records of this domain controller does not support dynamic DNS updates:
     *
     * %n%nDNS server IP address: %1
     * %nReturned Response Code (RCODE): %2
     * %nReturned Status Code: %3
     *
     * %n%nUSER ACTION
     *
     * %nConfigure the DNS server to allow dynamic DNS updates or manually add the DNS
     * records from the file '%SystemRoot%\System32\Config\Netlogon.dns' to the DNS database.
     */

#define NELOG_NetlogonDynamicDnsRegisterFailure   (ERRLOG2_BASE + 74)
     /*
      * The dynamic registration of the DNS record '%1' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %3
      * %nReturned Response Code (RCODE): %4
      * %nReturned Status Code: %5
      *
      * %n%nFor computers and users to locate this domain controller, this record must be
      * registered in DNS.
      *
      * %n%nUSER ACTION
      *
      * %nDetermine what might have caused this failure, resolve the problem, and initiate
      * registration of the DNS records by the domain controller. To determine what might
      * have caused this failure, run DCDiag.exe. To learn more about DCDiag.exe, see Help
      * and Support Center. To initiate registration of the DNS records by this domain 
      * controller, run 'nltest.exe /dsregdns' from the command prompt on the domain controller
      * or restart Net Logon service. %n  Or, you can manually add this record to DNS, but it
      * is not recommended.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonDynamicDnsDeregisterFailure (ERRLOG2_BASE + 75)
     /*
      * The dynamic deletion of the DNS record '%1' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %3
      * %nReturned Response Code (RCODE): %4
      * %nReturned Status Code: %5
      *
      * %n%nUSER ACTION
      *
      * %nTo prevent remote computers from connecting unnecessarily to the domain controller,
      * delete the record manually or troubleshoot the failure to dynamically delete the
      * record. To learn more about debugging DNS, see Help and Support Center.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonFailedFileCreate            (ERRLOG2_BASE + 76)
    /*
     * Failed to create/open file %1 with the following error: %n%2
     */

#define NELOG_NetlogonGetSubnetToSite             (ERRLOG2_BASE + 77)
    /*
     * Netlogon got the following error while trying to get the subnet to site
     * mapping information from the DS: %n%1
     */

#define NELOG_NetlogonNoSiteForClient              (ERRLOG2_BASE + 78)
   /*
    * '%1' tried to determine its site by looking up its IP address ('%2')
    * in the Configuration\Sites\Subnets container in the DS.  No subnet matched
    * the IP address.  Consider adding a subnet object for this IP address.
    */

#define NELOG_NetlogonBadSiteName                  (ERRLOG2_BASE + 79)
    /*
     * The site name for this computer is '%1'.  That site name is not a valid
     * site name.  A site name must be a valid DNS label.
     * Rename the site to be a valid name.
     */

#define NELOG_NetlogonBadSubnetName                (ERRLOG2_BASE + 80)
    /*
     * The subnet object '%1' appears in the Configuration\Sites\Subnets
     * container in the DS.  The name is not syntactically valid.  The valid
     * syntax is xx.xx.xx.xx/yy where xx.xx.xx.xx is a valid IP subnet number
     * and yy is the number of bits in the subnet mask.
     *
     * Correct the name of the subnet object.
     */

#define NELOG_NetlogonDynamicDnsServerFailure      (ERRLOG2_BASE + 81)
    /*
     * Dynamic registration or deletion of one or more DNS records associated with DNS
     * domain '%1' failed.  These records are used by other computers to locate this
     * server as a domain controller (if the specified domain is an Active Directory
     * domain) or as an LDAP server (if the specified domain is an application partition).
     *
     * %n%nPossible causes of failure include:
     *
     * %n- TCP/IP properties of the network connections of this computer contain wrong IP address(es) of the preferred and alternate DNS servers
     * %n- Specified preferred and alternate DNS servers are not running
     * %n- DNS server(s) primary for the records to be registered is not running
     * %n- Preferred or alternate DNS servers are configured with wrong root hints
     * %n- Parent DNS zone contains incorrect delegation to the child zone authoritative for the DNS records that failed registration
     *
     * %n%nUSER ACTION
     *
     * %nFix possible misconfiguration(s) specified above and initiate registration or deletion of
     * the DNS records by running 'nltest.exe /dsregdns' from the command prompt on the domain
     * controller or by restarting Net Logon service on the domain controller.
     */

#define NELOG_NetlogonDynamicDnsFailure            (ERRLOG2_BASE + 82)
    /*
     * Dynamic registration or deregistration of one or more DNS records failed with the following error: %n%1
     */

#define NELOG_NetlogonRpcCallCancelled             (ERRLOG2_BASE + 83)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * is not responsive.  The current RPC call from Netlogon on \\%3 to %1 has been cancelled.
     */

#define NELOG_NetlogonDcSiteCovered                (ERRLOG2_BASE + 84)
    /*
     * Site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCovered             (ERRLOG2_BASE + 85)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     */

#define NELOG_NetlogonGcSiteCovered                (ERRLOG2_BASE + 86)
    /*
     * Site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCovered             (ERRLOG2_BASE + 87)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     */

#define NELOG_NetlogonFailedSpnUpdate              (ERRLOG2_BASE + 88)
    /*
     * Attempt to update HOST Service Principal Names (SPNs) of the computer
     * object in Active Directory failed. The updated values were '%1' and '%2'.
     * The following error occurred: %n%3
     */

#define NELOG_NetlogonFailedDnsHostNameUpdate      (ERRLOG2_BASE + 89)
    /*
     * Attempt to update DNS Host Name of the computer object
     * in Active Directory failed. The updated value was '%1'.
     * The following error occurred: %n%2
     */

#define NELOG_NetlogonAuthNoUplevelDomainController (ERRLOG2_BASE + 90)
    /*
     * No suitable Domain Controller is available for domain %1.
     * An NT4 or older domain controller is available but it cannot
     * be used for authentication purposes in the Windows 2000 or newer
     * domain that this computer is a member of.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonAuthDomainDowngraded         (ERRLOG2_BASE + 91)
    /*
     * The domain of this computer, %1 has been downgraded from Windows 2000
     * or newer to Windows NT4 or older. The computer cannot function properly
     * in this case for authentication purposes. This computer needs to rejoin
     * the domain.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonNdncSiteCovered                (ERRLOG2_BASE + 92)
    /*
     * Site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically selected to
     * cover site '%2' for non-domain NC '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCovered             (ERRLOG2_BASE + 93)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     */

#define NELOG_NetlogonDcOldSiteCovered               (ERRLOG2_BASE + 94)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Domain Controller for domain '%3'. As a result,
     * site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCoveredAuto           (ERRLOG2_BASE + 95)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     * However, site '%1' is still (manually) covered by this Domain Controller for
     * domain '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonGcOldSiteCovered               (ERRLOG2_BASE + 96)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Global Catalog server for forest '%3'. As a result,
     * site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCoveredAuto           (ERRLOG2_BASE + 97)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     * However, site '%1' is still (manually) covered by this Global catalog for
     * forest '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonNdncOldSiteCovered             (ERRLOG2_BASE + 98)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this LDAP server for non-domain NC '%3'. As a result,
     * site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically
     * selected to cover site '%2' for non-domain NC '%3' based on
     * configured Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCoveredAuto         (ERRLOG2_BASE + 99)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     * However, site '%1' is still (manually) covered by this LDAP server for
     * non-domain NC '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonSpnMultipleSamAccountNames     (ERRLOG2_BASE + 100)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because the Domain Controller
     * '%1' had more than one account with the name '%2' corresponding to this computer.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator who may need to manually resolve the account name
     * collision.
     */

#define NELOG_NetlogonSpnCrackNamesFailure           (ERRLOG2_BASE + 101)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because this computer account
     * name, '%2' could not be mapped to the computer object on Domain Controller '%1'.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator. The following technical information may be
     * useful for the resolution of this failure:%n
     * DsCrackNames status = 0x%3, crack error = 0x%4.
     */

#define NELOG_NetlogonNoAddressToSiteMapping         (ERRLOG2_BASE + 102)
    /*
     * None of the IP addresses (%2) of this Domain Controller map to the configured site '%1'.
     * While this may be a temporary situation due to IP address changes, it is generally
     * recommended that the IP address of the Domain Controller (accessible to machines in
     * its domain) maps to the Site which it services. If the above list of IP addresses is
     * stable, consider moving this server to a site (or create one if it does not already
     * exist) such that the above IP address maps to the selected site. This may require the
     * creation of a new subnet object (whose range includes the above IP address) which maps
     * to the selected site object.
     */

#define NELOG_NetlogonInvalidGenericParameterValue   (ERRLOG2_BASE + 103)
    /*
     * The following error occurred while reading a parameter '%2' in the
     * Netlogon %1 registry section:%n%3
     */

#define NELOG_NetlogonInvalidDwordParameterValue     (ERRLOG2_BASE + 104)
    /*
     * The Netlogon %1 registry key contains an invalid value 0x%2 for parameter '%3'.
     * The minimum and maximum values allowed for this parameter are 0x%4 and 0x%5, respectively.
     * The value of 0x%6 has been assigned to this parameter.
     */

#define NELOG_NetlogonServerAuthFailedNoAccount      (ERRLOG2_BASE + 105)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The following error occurred: %n%2
     */

#define NELOG_NetlogonNoDynamicDnsManual             (ERRLOG2_BASE + 106)
    /*
     * Dynamic DNS updates have been manually disabled on this domain controller.
     *
     * %n%nUSER ACTION
     *
     * %nReconfigure this domain controller to use dynamic DNS updates or manually add the DNS
     * records from the file '%SystemRoot%\System32\Config\Netlogon.dns' to the DNS database.
     */

#define NELOG_NetlogonNoSiteForClients               (ERRLOG2_BASE + 107)
    /*
     * During the past %1 hours there have been %2 connections to this Domain
     * Controller from client machines whose IP addresses don't map to any of
     * the existing sites in the enterprise. Those clients, therefore, have
     * undefined sites and may connect to any Domain Controller including
     * those that are in far distant locations from the clients. A client's site
     * is determined by the mapping of its subnet to one of the existing sites.
     * To move the above clients to one of the sites, please consider creating
     * subnet object(s) covering the above IP addresses with mapping to one of the
     * existing sites.  The names and IP addresses of the clients in question have
     * been logged on this computer in the following log file
     * '%SystemRoot%\debug\netlogon.log' and, potentially, in the log file
     * '%SystemRoot%\debug\netlogon.bak' created if the former log becomes full.
     * The log(s) may contain additional unrelated debugging information. To filter
     * out the needed information, please search for lines which contain text
     * 'NO_CLIENT_SITE:'. The first word after this string is the client name and
     * the second word is the client IP address. The maximum size of the log(s) is
     * controlled by the following registry DWORD value
     * 'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters\LogFileMaxSize';
     * the default is %3 bytes.  The current maximum size is %4 bytes.  To set a
     * different maximum size, create the above registry value and set the desired
     * maximum size in bytes.
     */

#define NELOG_NetlogonDnsDeregAborted                (ERRLOG2_BASE + 108)
    /*
     * The deregistration of some DNS domain controller locator records was aborted
     * at the time of this domain controller demotion because the DNS deregistrations
     * took too long.
     *
     * %n%nUSER ACTION
     *
     * %nManually delete the DNS records listed in the file
     * '%SystemRoot%\System32\Config\Netlogon.dns' from the DNS database.
     */

#define NELOG_NetlogonRpcPortRequestFailure          (ERRLOG2_BASE + 109)
    /*
     * The NetLogon service on this domain controller has been configured to use port %1
     * for incoming RPC connections over TCP/IP from remote machines. However, the
     * following error occurred when Netlogon attempted to register this port with the RPC
     * endpoint mapper service: %n%2 %nThis will prevent the NetLogon service on remote
     * machines from connecting to this domain controller over TCP/IP that may result in
     * authentication problems.
     *
     * %n%nUSER ACTION
     *
     * %nThe specified port is configured via the Group Policy or via a registry value 'DcTcpipPort'
     * under the 'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters'
     * registry key; the value configured through the Group Policy takes precedence. If the
     * port specified is in error, reset it to a correct value. You can also remove this
     * configuration for the port in which case the port will be assigned dynamically by
     * the endpoint mapper at the time the NetLogon service on remote machines makes RPC connections
     * to this domain controller. After the misconfiguration is corrected, restart the NetLogon
     * service on this machine and verify that this event log no longer appears.
     */

#define NELOG_NetlogonPartialSiteMappingForClients   (ERRLOG2_BASE + 110)
    /*
     * During the past %1 hours, this domain controller has received %2 connections
     * from dual-stack IPv4/IPv6 clients with partial subnet-site mappings. A client
     * has a partial subnet-site mapping if its IPv4 address is mapped to a site but
     * its global IPv6 address is not mapped to a site, or vice versa. To ensure correct
     * behavior for applications running on member computers and servers that rely on
     * subnet-site mappings, dual-stack IPv4/IPv6 clients must have both IPv4 and global
     * IPv6 addresses mapped to the same site. If a partially mapped client attempts
     * to connect to this domain controller using its unmapped IP address, its mapped
     * address is used for the client's site mapping.
     *
     * %n%nThe log files %SystemRoot%\debug\netlogon.log or %SystemRoot%\debug\netlogon.bak
     * contain the name, unmapped IP address and mapped IP address for each partially
     * mapped client. The log files may also contain unrelated debugging information.
     * To locate the information pertaining to partial-subnet mappings, search for
     * lines that contain the text 'PARTIAL_CLIENT_SITE_MAPPING:'. The first word after
     * this text is the client name. Following the client name is the client's unmapped
     * IP address (the IP address that does not have a subnet-site mapping) and the
     * client's mapped IP address, which was used to return site information.
     *
     * %n%nUSER ACTION
     *
     * %nUse the Active Directory Sites and Services management console (MMC) snap-in
     * to add the subnet mapping for the unmapped IP addresses to the same site being
     * used by the mapped IP addresses. When adding site mappings for IPv6 addresses,
     * you should use global IPv6 addresses and not for instance temporary, link-local
     * or site-local IPv6 addresses.
     *
     * %n%nThe default maximum size of the log files is %3 bytes. The current maximum
     * size is %4 bytes. To set a different maximum size, create the following registry
     * DWORD value to specify the maximum size in bytes:
     *
     * %nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters\LogFileMaxSize
     */

#define NELOG_NetlogonRemoteDynamicDnsRegisterFailure   (ERRLOG2_BASE + 111)
     /*
      * The dynamic registration of the DNS record '%1' for the remote domain controller '%3'
      * failed on the following DNS server:
      *
      * %n%nDNS server IP address: %4
      * %nReturned Response Code (RCODE): %5
      * %nReturned Status Code: %6
      *
      * %n%nFor computers and users to locate the domain controller '%3', this record must be
      * registered in DNS.
      *
      * %n%nUSER ACTION
      *
      * %nDetermine what might have caused this failure, resolve the problem, and initiate
      * registration of the DNS records by the domain controller '%3'. For help with determining
      * and resolving the problem, see Help and Support for information about troubleshooting
      * DNS. To initiate registration of the DNS records by the domain controller '%3', run
      * 'nltest.exe /dsregdns' from the command prompt on the domain controller '%3' or restart
      * the Net Logon service on the domain controller '%3'. Nltest.exe is a command line tool
      * that is built into Windows Server.
      * %n As a workaround, you can manually add this record to DNS, but it is not recommended
      * because you then must manually update any changes it requires hereafter.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonRemoteDynamicDnsDeregisterFailure (ERRLOG2_BASE + 112)
     /*
      * The dynamic deregistration of the DNS record '%1' for the remote domain controller
      * '%3' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %4
      * %nReturned Response Code (RCODE): %5
      * %nReturned Status Code: %6
      *
      * %n%nUSER ACTION
      *
      * %nTo prevent remote computers from attempting to connect to the domain controller '%3'
      * using an invalid record, delete the record '%1' manually or troubleshoot the root cause
      * behind the dynamic deregistration failure. To learn more about troubleshooting DNS, see
      * Help and Support.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonRejectedRemoteDynamicDnsRegister   (ERRLOG2_BASE + 113)
     /*
      * The dynamic registration request for the DNS record '%1' has been rejected by the
      * remote domain controller '%2'. Error: '%3'
      *
      * %n%nFor computers and users to locate this domain controller, this record must be
      * registered in DNS. If the problem persists, please contact your domain administrator.
      */

#define NELOG_NetlogonRejectedRemoteDynamicDnsDeregister (ERRLOG2_BASE + 114)
     /*
      * The dynamic deregistration request of the DNS record '%1' has been rejected by the
      * remote domain controller '%2'. Error: '%3'
      *
      * %n%nTo prevent remote computers from connecting unnecessarily to this domain controller,
      * an administrator with sufficient privileges must manually delete the record on the DNS
      * server that hosts it.
      */

#define NELOG_NetlogonRemoteDynamicDnsUpdateRequestFailure   (ERRLOG2_BASE + 115)
     /*
      * The remoting of the dynamic update request for the local domain controller's DNS records
      * through a secure session has failed with error '%1'.
      *
      * %n%nFor other computers and member servers to locate this domain controller, the appropriate
      * records must be registered in DNS. On this domain controller, look for events related to
      * failure to set up a secure session to determine why the request is failing. If the problem
      * persists, please contact your domain administrator.
      */

#ifdef __cplusplus
}
#endif

#endif // _LMERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMErr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
*/
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1999          **/
/********************************************************************/

/***    lmerr.h - network error definitions
 *
 */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/**END_INTERNAL**/

/*NOINC*/
#ifndef NETERR_INCLUDED
#define NETERR_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/


#define NERR_Success            0       /* Success */

// ERROR_ equates can be intermixed with NERR_ equates.
#include <winerror.h>



/***    NERR_BASE is the base of error codes from network utilities,
 *      chosen to avoid conflict with system and redirector error codes.
 *      2100 is a value that has been assigned to us by system.
 */
#define NERR_BASE       2100


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted      (NERR_BASE+2)   /* The workstation driver is not installed. */
#define NERR_UnknownServer      (NERR_BASE+3)   /* The server could not be located. */
#define NERR_ShareMem           (NERR_BASE+4)   /* An internal error occurred.  The network cannot access a shared memory segment. */

#define NERR_NoNetworkResource  (NERR_BASE+5)   /* A network resource shortage occurred . */
#define NERR_RemoteOnly         (NERR_BASE+6)   /* This operation is not supported on workstations. */
#define NERR_DevNotRedirected   (NERR_BASE+7)   /* The device is not connected. */
/* NERR_BASE+8 is used for ERROR_CONNECTED_OTHER_PASSWORD */
/* NERR_BASE+9 is used for ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted   (NERR_BASE+14)  /* The Server service is not started. */
#define NERR_ItemNotFound       (NERR_BASE+15)  /* The queue is empty. */
#define NERR_UnknownDevDir      (NERR_BASE+16)  /* The device or directory does not exist. */
#define NERR_RedirectedPath     (NERR_BASE+17)  /* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare     (NERR_BASE+18)  /* The name has already been shared. */
#define NERR_NoRoom             (NERR_BASE+19)  /* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems       (NERR_BASE+21)  /* Requested addition of items exceeds the maximum allowed. */
#define NERR_InvalidMaxUsers    (NERR_BASE+22)  /* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall        (NERR_BASE+23)  /* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr          (NERR_BASE+27)  /* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError     (NERR_BASE+31)  /* An error occurred when opening or reading the configuration file. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
/* UNUSED BASE+34 */
/* UNUSED BASE+35 */
#define NERR_NetworkError       (NERR_BASE+36)  /* A general network error occurred. */
#define NERR_WkstaInconsistentState (NERR_BASE+37)
    /* The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service. */
#define NERR_WkstaNotStarted    (NERR_BASE+38)  /* The Workstation service has not been started. */
#define NERR_BrowserNotStarted  (NERR_BASE+39)  /* The requested information is not available. */
#define NERR_InternalError      (NERR_BASE+40)  /* An internal Windows error occurred.*/
#define NERR_BadTransactConfig  (NERR_BASE+41)  /* The server is not configured for transactions. */
#define NERR_InvalidAPI         (NERR_BASE+42)  /* The requested API is not supported on the remote server. */
#define NERR_BadEventName       (NERR_BASE+43)  /* The event name is invalid. */
#define NERR_DupNameReboot      (NERR_BASE+44)  /* The computer name already exists on the network. Change it and restart the computer. */
/*
 *      Config API related
 *              Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound    (NERR_BASE+46)  /* The specified component could not be found in the configuration information. */
#define NERR_CfgParamNotFound   (NERR_BASE+47)  /* The specified parameter could not be found in the configuration information. */
#define NERR_LineTooLong        (NERR_BASE+49)  /* A line in the configuration file is too long. */

/*
 *      Spooler API related
 *              Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound          (NERR_BASE+50)  /* The printer does not exist. */
#define NERR_JobNotFound        (NERR_BASE+51)  /* The print job does not exist. */
#define NERR_DestNotFound       (NERR_BASE+52)  /* The printer destination cannot be found. */
#define NERR_DestExists         (NERR_BASE+53)  /* The printer destination already exists. */
#define NERR_QExists            (NERR_BASE+54)  /* The printer queue already exists. */
#define NERR_QNoRoom            (NERR_BASE+55)  /* No more printers can be added. */
#define NERR_JobNoRoom          (NERR_BASE+56)  /* No more print jobs can be added.  */
#define NERR_DestNoRoom         (NERR_BASE+57)  /* No more printer destinations can be added. */
#define NERR_DestIdle           (NERR_BASE+58)  /* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp      (NERR_BASE+59)  /* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond      (NERR_BASE+60)  /* The print processor is not responding. */
#define NERR_SpoolerNotLoaded   (NERR_BASE+61)  /* The spooler is not running. */
#define NERR_DestInvalidState   (NERR_BASE+62)  /* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState      (NERR_BASE+63)  /* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState    (NERR_BASE+64)  /* This operation cannot be performed on the print job in its current state. */
#define NERR_SpoolNoMemory      (NERR_BASE+65)  /* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound     (NERR_BASE+66)  /* The device driver does not exist. */
#define NERR_DataTypeInvalid    (NERR_BASE+67)  /* The data type is not supported by the print processor. */
#define NERR_ProcNotFound       (NERR_BASE+68)  /* The print processor is not installed. */

/*
 *      Service API related
 *              Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked (NERR_BASE+80)  /* The service database is locked. */
#define NERR_ServiceTableFull   (NERR_BASE+81)  /* The service table is full. */
#define NERR_ServiceInstalled   (NERR_BASE+82)  /* The requested service has already been started. */
#define NERR_ServiceEntryLocked (NERR_BASE+83)  /* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName     (NERR_BASE+85)  /* The service name is invalid. */
#define NERR_ServiceCtlTimeout  (NERR_BASE+86)  /* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy     (NERR_BASE+87)  /* The service control is busy. */
#define NERR_BadServiceProgName (NERR_BASE+88)  /* The configuration file contains an invalid service program name. */
#define NERR_ServiceNotCtrl     (NERR_BASE+89)  /* The service could not be controlled in its present state. */
#define NERR_ServiceKillProc    (NERR_BASE+90)  /* The service ended abnormally. */
#define NERR_ServiceCtlNotValid (NERR_BASE+91)  /* The requested pause, continue, or stop is not valid for this service. */
#define NERR_NotInDispatchTbl   (NERR_BASE+92)  /* The service control dispatcher could not find the service name in the dispatch table. */
#define NERR_BadControlRecv     (NERR_BASE+93)  /* The service control dispatcher pipe read failed. */
#define NERR_ServiceNotStarting (NERR_BASE+94)  /* A thread for the new service could not be created. */

/*
 *      Wksta and Logon API related
 *              Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn    (NERR_BASE+100) /* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn        (NERR_BASE+101) /* The workstation is not logged on to the local-area network. */
#define NERR_BadUsername        (NERR_BASE+102) /* The user name or group name parameter is invalid.  */
#define NERR_BadPassword        (NERR_BASE+103) /* The password parameter is invalid. */
#define NERR_UnableToAddName_W  (NERR_BASE+104) /* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F  (NERR_BASE+105) /* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W  (NERR_BASE+106) /* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F  (NERR_BASE+107) /* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused       (NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath    (NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError   (NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server could not be found.  */
#define NERR_LogonDomainExists  (NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon  (NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *      ACF API related (access, user, group)
 *              Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound        (NERR_BASE+119) /* The security database could not be found. */
#define NERR_GroupNotFound      (NERR_BASE+120) /* The group name could not be found. */
#define NERR_UserNotFound       (NERR_BASE+121) /* The user name could not be found. */
#define NERR_ResourceNotFound   (NERR_BASE+122) /* The resource name could not be found.  */
#define NERR_GroupExists        (NERR_BASE+123) /* The group already exists. */
#define NERR_UserExists         (NERR_BASE+124) /* The account already exists. */
#define NERR_ResourceExists     (NERR_BASE+125) /* The resource permission list already exists. */
#define NERR_NotPrimary         (NERR_BASE+126) /* This operation is only allowed on the primary domain controller of the domain. */
#define NERR_ACFNotLoaded       (NERR_BASE+127) /* The security database has not been started. */
#define NERR_ACFNoRoom          (NERR_BASE+128) /* There are too many names in the user accounts database. */
#define NERR_ACFFileIOFail      (NERR_BASE+129) /* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists    (NERR_BASE+130) /* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon          (NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent        (NERR_BASE+132) /* The parent directory could not be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to add to the security database session cache segment. */
#define NERR_SpeGroupOp         (NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache         (NERR_BASE+135) /* This user is not cached in user accounts database session cache. */
#define NERR_UserInGroup        (NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup     (NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined   (NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired     (NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours  (NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort   (NERR_BASE+145) /* The password does not meet the password policy requirements. Check the minimum password length, password complexity and password history requirements. */
#define NERR_PasswordTooRecent  (NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase    (NERR_BASE+147) /* The security database is corrupted. */
#define NERR_DatabaseUpToDate   (NERR_BASE+148) /* No updates are necessary to this replicant network/local security database. */
#define NERR_SyncRequired       (NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *      Use API related
 *              Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound        (NERR_BASE+150) /* The network connection could not be found. */
#define NERR_BadAsgType         (NERR_BASE+151) /* This asg_type is invalid. */
#define NERR_DeviceIsShared     (NERR_BASE+152) /* This device is currently being shared. */
#define NERR_SameAsComputerName (NERR_BASE+153) /* The user name may not be same as computer name. */


/*
 *      Message Server related
 *              Error codes BASE+170 to BASE+209
 */

#define NERR_NoComputerName     (NERR_BASE+170) /* The computer name could not be added as a message alias.  The name may already exist on the network. */
#define NERR_MsgAlreadyStarted  (NERR_BASE+171) /* The Messenger service is already started. */
#define NERR_MsgInitFailed      (NERR_BASE+172) /* The Messenger service failed to start.  */
#define NERR_NameNotFound       (NERR_BASE+173) /* The message alias could not be found on the network. */
#define NERR_AlreadyForwarded   (NERR_BASE+174) /* This message alias has already been forwarded. */
#define NERR_AddForwarded       (NERR_BASE+175) /* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists      (NERR_BASE+176) /* This message alias already exists locally. */
#define NERR_TooManyNames       (NERR_BASE+177) /* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName    (NERR_BASE+178) /* The computer name could not be deleted.*/
#define NERR_LocalForward       (NERR_BASE+179) /* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor    (NERR_BASE+180) /* An error occurred in the domain message processor. */
#define NERR_PausedRemote       (NERR_BASE+181) /* The message was sent, but the recipient has paused the Messenger service. */
#define NERR_BadReceive         (NERR_BASE+182) /* The message was sent but not received. */
#define NERR_NameInUse          (NERR_BASE+183) /* The message alias is currently in use. Try again later. */
#define NERR_MsgNotStarted      (NERR_BASE+184) /* The Messenger service has not been started. */
#define NERR_NotLocalName       (NERR_BASE+185) /* The name is not on the local computer. */
#define NERR_NoForwardName      (NERR_BASE+186) /* The forwarded message alias could not be found on the network. */
#define NERR_RemoteFull         (NERR_BASE+187) /* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded   (NERR_BASE+188) /* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast (NERR_BASE+189) /* The broadcast message was truncated. */
#define NERR_InvalidDevice      (NERR_BASE+194) /* This is an invalid device name. */
#define NERR_WriteFault         (NERR_BASE+195) /* A write fault occurred. */
/* UNUSED BASE+196 */
#define NERR_DuplicateName      (NERR_BASE+197) /* A duplicate message alias exists on the network. */
#define NERR_DeleteLater        (NERR_BASE+198) /* @W This message alias will be deleted later. */
#define NERR_IncompleteDel      (NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets       (NERR_BASE+200) /* This operation is not supported on computers with multiple networks. */

/*
 *      Server API related
 *              Error codes BASE+210 to BASE+229
 */

#define NERR_NetNameNotFound    (NERR_BASE+210) /* This shared resource does not exist.*/
#define NERR_DeviceNotShared    (NERR_BASE+211) /* This device is not shared. */
#define NERR_ClientNameNotFound (NERR_BASE+212) /* A session does not exist with that computer name. */
#define NERR_FileIdNotFound     (NERR_BASE+214) /* There is not an open file with that identification number. */
#define NERR_ExecFailure        (NERR_BASE+215) /* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile            (NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData        (NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain     (NERR_BASE+220) /* The computer is not active in this domain. */
#define NERR_IsDfsShare         (NERR_BASE+221) /* The share must be removed from the Distributed File System before it can be deleted. */

/*
 *      CharDev API related
 *              Error codes BASE+230 to BASE+249
 */

/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode   (NERR_BASE+231) /* The operation is invalid for this device. */
#define NERR_DevNotFound        (NERR_BASE+232) /* This device cannot be shared. */
#define NERR_DevNotOpen         (NERR_BASE+233) /* This device was not open. */
#define NERR_BadQueueDevString  (NERR_BASE+234) /* This device name list is invalid. */
#define NERR_BadQueuePriority   (NERR_BASE+235) /* The queue priority is invalid. */
#define NERR_NoCommDevs         (NERR_BASE+237) /* There are no shared communication devices. */
#define NERR_QueueNotFound      (NERR_BASE+238) /* The queue you specified does not exist. */
#define NERR_BadDevString       (NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev             (NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler     (NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse       (NERR_BASE+243) /* This device is already in use as a communication device. */

/*
 *      NetICanonicalize and NetIType and NetIMakeLMFileName
 *      NetIListCanon and NetINameCheck
 *              Error codes BASE+250 to BASE+269
 */

#define NERR_InvalidComputer   (NERR_BASE+251) /* This computer name is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType          (NERR_BASE+257) /* Could not determine the type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/*
 *      NetProfile
 *              Error codes BASE+270 to BASE+276
 */

#define NERR_ProfileFileTooBig  (NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset      (NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup     (NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd  (NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr     (NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr     (NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 *      NetAudit and NetErrorLog
 *              Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow           (NERR_BASE+277)      /* Log file %1 is full. */
#define NERR_LogFileChanged        (NERR_BASE+278)      /* This log file has changed between reads. */
#define NERR_LogFileCorrupt        (NERR_BASE+279)      /* Log file %1 is corrupt. */


/*
 *      NetRemote
 *              Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused       (NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv      (NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost  (NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound      (NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This share name or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive         (NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists        (NERR_BASE+330) /* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts      (NERR_BASE+331) /* The alert table is full. */
#define NERR_NoSuchAlert        (NERR_BASE+332) /* An invalid or nonexistent alert name was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded  (NERR_BASE+334) /* A user's session with this server has been deleted
                                                 * because the user's logon hours are no longer valid. */

/*
 *  Additional Error and Audit log codes.
 *
 *          NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek     (NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *          NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig       (NERR_BASE+350) /* The user accounts database is not configured correctly. */
#define NERR_InvalidUASOp       (NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin          (NERR_BASE+352) /* This operation is not allowed on the last administrative account. */
#define NERR_DCNotFound         (NERR_BASE+353) /* Could not find domain controller for this domain. */
#define NERR_LogonTrackingError (NERR_BASE+354) /* Could not set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile  (NERR_BASE+356) /* Unable to add to the user accounts database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* This server's clock is not synchronized with the primary domain controller's clock. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */


/*
 *  Server Integration error codes.
 *
 *          NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer       (NERR_BASE+360) /* The server identification does not specify a valid server. */
#define NERR_NoSuchSession      (NERR_BASE+361) /* The session identification does not specify a valid session. */
#define NERR_NoSuchConnection   (NERR_BASE+362) /* The connection identification does not specify a valid connection. */
#define NERR_TooManyServers     (NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions    (NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles       (NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

#define NERR_TryDownLevel       (NERR_BASE+370) /* Try down-level (remote admin protocol) version of API instead. */

/*
 *  UPS error codes.
 *
 *          NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
#define NERR_UPSInvalidConfig       (NERR_BASE+381) /* The UPS service is not configured correctly. */
#define NERR_UPSInvalidCommPort     (NERR_BASE+382) /* The UPS service could not access the specified Comm Port. */
#define NERR_UPSSignalAsserted      (NERR_BASE+383) /* The UPS indicated a line fail or low battery situation. Service not started. */
#define NERR_UPSShutdownFailed      (NERR_BASE+384) /* The UPS service failed to perform a system shut down. */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 *
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED      (NERR_BASE+419) /* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 *       (Currently not used in NT)
 *
 */

/*
 *  Browser service API error codes
 *
 *       NERR_BASE + (450-475)
 *
 */
#define NERR_BrowserConfiguredToNotRun     (NERR_BASE+450) /* The browser service was configured with MaintainServerList=No. */

/*
 *  Additional Remoteboot error codes.
 *
 *          NERR_BASE + (510-550)
 */
#define NERR_RplNoAdaptersStarted          (NERR_BASE+510) /*Service failed to start since none of the network adapters started with this service.*/
#define NERR_RplBadRegistry                (NERR_BASE+511) /*Service failed to start due to bad startup information in the registry.*/
#define NERR_RplBadDatabase                (NERR_BASE+512) /*Service failed to start because its database is absent or corrupt.*/
#define NERR_RplRplfilesShare              (NERR_BASE+513) /*Service failed to start because RPLFILES share is absent.*/
#define NERR_RplNotRplServer               (NERR_BASE+514) /*Service failed to start because RPLUSER group is absent.*/
#define NERR_RplCannotEnum                 (NERR_BASE+515) /*Cannot enumerate service records.*/
#define NERR_RplWkstaInfoCorrupted         (NERR_BASE+516) /*Workstation record information has been corrupted.*/
#define NERR_RplWkstaNotFound              (NERR_BASE+517) /*Workstation record was not found.*/
#define NERR_RplWkstaNameUnavailable       (NERR_BASE+518) /*Workstation name is in use by some other workstation.*/
#define NERR_RplProfileInfoCorrupted       (NERR_BASE+519) /*Profile record information has been corrupted.*/
#define NERR_RplProfileNotFound            (NERR_BASE+520) /*Profile record was not found.*/
#define NERR_RplProfileNameUnavailable     (NERR_BASE+521) /*Profile name is in use by some other profile.*/
#define NERR_RplProfileNotEmpty            (NERR_BASE+522) /*There are workstations using this profile.*/
#define NERR_RplConfigInfoCorrupted        (NERR_BASE+523) /*Configuration record information has been corrupted.*/
#define NERR_RplConfigNotFound             (NERR_BASE+524) /*Configuration record was not found.*/
#define NERR_RplAdapterInfoCorrupted       (NERR_BASE+525) /*Adapter id record information has been corrupted.*/
#define NERR_RplInternal                   (NERR_BASE+526) /*An internal service error has occurred.*/
#define NERR_RplVendorInfoCorrupted        (NERR_BASE+527) /*Vendor id record information has been corrupted.*/
#define NERR_RplBootInfoCorrupted          (NERR_BASE+528) /*Boot block record information has been corrupted.*/
#define NERR_RplWkstaNeedsUserAcct         (NERR_BASE+529) /*The user account for this workstation record is missing.*/
#define NERR_RplNeedsRPLUSERAcct           (NERR_BASE+530) /*The RPLUSER local group could not be found.*/
#define NERR_RplBootNotFound               (NERR_BASE+531) /*Boot block record was not found.*/
#define NERR_RplIncompatibleProfile        (NERR_BASE+532) /*Chosen profile is incompatible with this workstation.*/
#define NERR_RplAdapterNameUnavailable     (NERR_BASE+533) /*Chosen network adapter id is in use by some other workstation.*/
#define NERR_RplConfigNotEmpty             (NERR_BASE+534) /*There are profiles using this configuration.*/
#define NERR_RplBootInUse                  (NERR_BASE+535) /*There are workstations, profiles or configurations using this boot block.*/
#define NERR_RplBackupDatabase             (NERR_BASE+536) /*Service failed to backup Remoteboot database.*/
#define NERR_RplAdapterNotFound            (NERR_BASE+537) /*Adapter record was not found.*/
#define NERR_RplVendorNotFound             (NERR_BASE+538) /*Vendor record was not found.*/
#define NERR_RplVendorNameUnavailable      (NERR_BASE+539) /*Vendor name is in use by some other vendor record.*/
#define NERR_RplBootNameUnavailable        (NERR_BASE+540) /*(boot name, vendor id) is in use by some other boot block record.*/
#define NERR_RplConfigNameUnavailable      (NERR_BASE+541) /*Configuration name is in use by some other configuration.*/

/**INTERNAL_ONLY**/

/*
 *  Dfs API error codes.
 *
 *          NERR_BASE + (560-590)
 */

#define NERR_DfsInternalCorruption         (NERR_BASE+560) /*The internal database maintained by the DFS service is corrupt*/
#define NERR_DfsVolumeDataCorrupt          (NERR_BASE+561) /*One of the records in the internal DFS database is corrupt*/
#define NERR_DfsNoSuchVolume               (NERR_BASE+562) /*There is no DFS name whose entry path matches the input Entry Path*/
#define NERR_DfsVolumeAlreadyExists        (NERR_BASE+563) /*A root or link with the given name already exists*/
#define NERR_DfsAlreadyShared              (NERR_BASE+564) /*The server share specified is already shared in the DFS*/
#define NERR_DfsNoSuchShare                (NERR_BASE+565) /*The indicated server share does not support the indicated DFS namespace*/
#define NERR_DfsNotALeafVolume             (NERR_BASE+566) /*The operation is not valid on this portion of the namespace*/
#define NERR_DfsLeafVolume                 (NERR_BASE+567) /*The operation is not valid on this portion of the namespace*/
#define NERR_DfsVolumeHasMultipleServers   (NERR_BASE+568) /*The operation is ambiguous because the link has multiple servers*/
#define NERR_DfsCantCreateJunctionPoint    (NERR_BASE+569) /*Unable to create a link*/
#define NERR_DfsServerNotDfsAware          (NERR_BASE+570) /*The server is not DFS Aware*/
#define NERR_DfsBadRenamePath              (NERR_BASE+571) /*The specified rename target path is invalid*/
#define NERR_DfsVolumeIsOffline            (NERR_BASE+572) /*The specified DFS link is offline*/
#define NERR_DfsNoSuchServer               (NERR_BASE+573) /*The specified server is not a server for this link*/
#define NERR_DfsCyclicalName               (NERR_BASE+574) /*A cycle in the DFS name was detected*/
#define NERR_DfsNotSupportedInServerDfs    (NERR_BASE+575) /*The operation is not supported on a server-based DFS*/
#define NERR_DfsDuplicateService           (NERR_BASE+576) /*This link is already supported by the specified server-share*/
#define NERR_DfsCantRemoveLastServerShare  (NERR_BASE+577) /*Can't remove the last server-share supporting this root or link*/
#define NERR_DfsVolumeIsInterDfs           (NERR_BASE+578) /*The operation is not supported for an Inter-DFS link*/
#define NERR_DfsInconsistent               (NERR_BASE+579) /*The internal state of the DFS Service has become inconsistent*/
#define NERR_DfsServerUpgraded             (NERR_BASE+580) /*The DFS Service has been installed on the specified server*/
#define NERR_DfsDataIsIdentical            (NERR_BASE+581) /*The DFS data being reconciled is identical*/
#define NERR_DfsCantRemoveDfsRoot          (NERR_BASE+582) /*The DFS root cannot be deleted - Uninstall DFS if required*/
#define NERR_DfsChildOrParentInDfs         (NERR_BASE+583) /*A child or parent directory of the share is already in a DFS*/
#define NERR_DfsInternalError              (NERR_BASE+590) /*DFS internal error*/

/*
 *  Net setup error codes.
 *
 *          NERR_BASE + (591-600)
 */
#define NERR_SetupAlreadyJoined            (NERR_BASE+591) /*This machine is already joined to a domain.*/
#define NERR_SetupNotJoined                (NERR_BASE+592) /*This machine is not currently joined to a domain.*/
#define NERR_SetupDomainController         (NERR_BASE+593) /*This machine is a domain controller and cannot be unjoined from a domain.*/
#define NERR_DefaultJoinRequired           (NERR_BASE+594) /*The destination domain controller does not support creating machine accounts in OUs.*/
#define NERR_InvalidWorkgroupName          (NERR_BASE+595) /*The specified workgroup name is invalid.*/
#define NERR_NameUsesIncompatibleCodePage  (NERR_BASE+596) /*The specified computer name is incompatible with the default language used on the domain controller.*/
#define NERR_ComputerAccountNotFound       (NERR_BASE+597) /*The specified computer account could not be found. Contact an administrator to verify the account is in the domain. If the account has been deleted unjoin, reboot, and rejoin the domain.*/
#define NERR_PersonalSku                   (NERR_BASE+598) /*This version of Windows cannot be joined to a domain.*/
#define NERR_SetupCheckDNSConfig           (NERR_BASE+599) /*An attempt to resolve the DNS name of a domain controller in the domain being joined has failed.  Please verify this client is configured to reach a DNS server that can resolve DNS names in the target domain. For information about network troubleshooting, see Windows Help.*/

/*
 *  Some Password and account error results
 *
 *          NERR_BASE + (601 - 608)
*/
#define NERR_PasswordMustChange            (NERR_BASE + 601)   /* Password must change at next logon */
#define NERR_AccountLockedOut              (NERR_BASE + 602)   /* Account is locked out */
#define NERR_PasswordTooLong               (NERR_BASE + 603)   /* Password is too long */
#define NERR_PasswordNotComplexEnough      (NERR_BASE + 604)   /* Password doesn't meet the complexity policy */ 
#define NERR_PasswordFilterError           (NERR_BASE + 605)   /* Password doesn't meet the requirements of the filter dll's */

/*
 *  Error codes used for offline domain join and completion
 *
 *          NERR_BASE + (609 - 619)
 */
#define NERR_NoOfflineJoinInfo             (NERR_BASE + 609)   /* Offline join completion information was not found. */
#define NERR_BadOfflineJoinInfo            (NERR_BASE + 610)   /* The offline join completion information was bad. */
#define NERR_CantCreateJoinInfo            (NERR_BASE + 611)   /* Unable to create offline join information. Please ensure you have access to the specified path location and permissions to modify its contents. Running as an elevated administrator may be required. */ 
#define NERR_BadDomainJoinInfo             (NERR_BASE + 612)   /* The domain join info being saved was incomplete or bad. */ 
#define NERR_JoinPerformedMustRestart      (NERR_BASE + 613)   /* Offline join operation successfully completed but a restart is needed. */ 
#define NERR_NoJoinPending                 (NERR_BASE + 614)   /* There was no offline join operation pending. */ 
#define NERR_ValuesNotSet                  (NERR_BASE + 615)   /* Unable to set one or more requested machine or domain name values on the local computer. */
#define NERR_CantVerifyHostname            (NERR_BASE + 616)   /* Could not verify the current machine's hostname against the saved value in the join completion information. */
#define NERR_CantLoadOfflineHive           (NERR_BASE + 617)   /* Unable to load the specified offline registry hive. Please ensure you have access to the specified path location and permissions to modify its contents. Running as an elevated administrator may be required. */
#define NERR_ConnectionInsecure            (NERR_BASE + 618)   /* The minimum session security requirements for this operation were not met. */
#define NERR_ProvisioningBlobUnsupported   (NERR_BASE + 619)   /* Computer account provisioning blob version is not supported. */


/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

#define MAX_NERR                (NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *              other error code ranges (errlog.h, service.h, apperr.h).
 */


/*NOINC*/
#endif /* NETERR_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMUseFlg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMServer.h ===
/*++ BUILD VERSION: 0007    // INCREMENT THIS IF A CHANGE HAS GLOBAL EFFECTS

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    lmserver.h

Abstract:

    This file contains information about NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSERVER_
#define _LMSERVER_

#if _MSC_VER > 1000
#pragma once
#endif

#include <winsvc.h>     // SERVICE_STATUS_HANDLE

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - SERVER
//

NET_API_STATUS NET_API_FUNCTION
NetServerEnum (
    __in_opt IN  LMCSTR      servername OPTIONAL,
    __in IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    __in IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __in IN  DWORD       servertype,
    __in_opt IN  LMCSTR      domain OPTIONAL,
    __out_opt IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerEnumEx (
    __in_opt IN  LMCSTR      ServerName OPTIONAL,
    __in IN  DWORD       Level,
    __deref_out OUT LPBYTE      *Bufptr,
    __in IN  DWORD       PrefMaxlen,
    __out OUT LPDWORD     EntriesRead,
    __out OUT LPDWORD     totalentries,
    __in IN  DWORD       servertype,
    __in_opt IN  LMCSTR      domain OPTIONAL,
    __in_opt IN  LMCSTR      FirstNameToReturn OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    __out_opt OUT LPDWORD ParmError OPTIONAL
    );

//
// Temporary hack function.
//

NET_API_STATUS
NetServerSetInfoCommandLine (
    __in WORD argc,
    __in_ecount(argc) LMSTR  argv[]
    );

NET_API_STATUS NET_API_FUNCTION
NetServerDiskEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameAdd(
    __in_opt IN LMSTR  ServerName         OPTIONAL,
    __in_opt IN LMSTR  EmulatedDomainName OPTIONAL,
    __in IN LMSTR  EmulatedServerName
);

NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameDel (
    __in_opt IN LMSTR  ServerName        OPTIONAL,
    __in IN LMSTR  EmulatedServerName
);

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAdd (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __in_bcount(sizeof(SERVER_TRANSPORT_INFO_0)) IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAddEx (
    __in_opt IN  LMSTR   servername      OPTIONAL,
    IN  DWORD   level,
    __in IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportDel (
    __in_opt LMSTR   servername,
    __in  DWORD   level,
    __in_xcount(level == 0 ? sizeof(SERVER_TRANSPORT_INFO_0) : sizeof(SERVER_TRANSPORT_INFO_1)) LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportEnum (
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resumehandle
    );

//
// The following function can be called by Win NT services to register
// their service type.  This function is exported from advapi32.dll.
// Therefore, if this is the only function called by that service, then
// it is not necessary to link to netapi32.lib.
//
BOOL NET_API_FUNCTION
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    );

//
// Data Structures - SERVER
//

typedef struct _SERVER_INFO_100 {
    DWORD           sv100_platform_id;
    LMSTR           sv100_name;
} SERVER_INFO_100, *PSERVER_INFO_100, *LPSERVER_INFO_100;

typedef struct _SERVER_INFO_101 {
    DWORD           sv101_platform_id;
    LMSTR           sv101_name;
    DWORD           sv101_version_major;
    DWORD           sv101_version_minor;
    DWORD           sv101_type;
    LMSTR           sv101_comment;
} SERVER_INFO_101, *PSERVER_INFO_101, *LPSERVER_INFO_101;

typedef struct _SERVER_INFO_102 {
     DWORD          sv102_platform_id;
     LMSTR          sv102_name;
     DWORD          sv102_version_major;
     DWORD          sv102_version_minor;
     DWORD          sv102_type;
     LMSTR          sv102_comment;
     DWORD          sv102_users;
     LONG           sv102_disc;
     BOOL           sv102_hidden;
     DWORD          sv102_announce;
     DWORD          sv102_anndelta;
     DWORD          sv102_licenses;
     LMSTR          sv102_userpath;
} SERVER_INFO_102, *PSERVER_INFO_102, *LPSERVER_INFO_102;

typedef struct _SERVER_INFO_103 {
     DWORD          sv103_platform_id;
     LMSTR          sv103_name;
     DWORD          sv103_version_major;
     DWORD          sv103_version_minor;
     DWORD          sv103_type;
     LMSTR          sv103_comment;
     DWORD          sv103_users;
     LONG           sv103_disc;
     BOOL           sv103_hidden;
     DWORD          sv103_announce;
     DWORD          sv103_anndelta;
     DWORD          sv103_licenses;
     LMSTR          sv103_userpath;
     DWORD          sv103_capabilities;
} SERVER_INFO_103, *PSERVER_INFO_103, *LPSERVER_INFO_103;

typedef struct _SERVER_INFO_402 {
     DWORD          sv402_ulist_mtime;
     DWORD          sv402_glist_mtime;
     DWORD          sv402_alist_mtime;
     LMSTR          sv402_alerts;
     DWORD          sv402_security;
     DWORD          sv402_numadmin;
     DWORD          sv402_lanmask;
     LMSTR          sv402_guestacct;
     DWORD          sv402_chdevs;
     DWORD          sv402_chdevq;
     DWORD          sv402_chdevjobs;
     DWORD          sv402_connections;
     DWORD          sv402_shares;
     DWORD          sv402_openfiles;
     DWORD          sv402_sessopens;
     DWORD          sv402_sessvcs;
     DWORD          sv402_sessreqs;
     DWORD          sv402_opensearch;
     DWORD          sv402_activelocks;
     DWORD          sv402_numreqbuf;
     DWORD          sv402_sizreqbuf;
     DWORD          sv402_numbigbuf;
     DWORD          sv402_numfiletasks;
     DWORD          sv402_alertsched;
     DWORD          sv402_erroralert;
     DWORD          sv402_logonalert;
     DWORD          sv402_accessalert;
     DWORD          sv402_diskalert;
     DWORD          sv402_netioalert;
     DWORD          sv402_maxauditsz;
     LMSTR          sv402_srvheuristics;
} SERVER_INFO_402, *PSERVER_INFO_402, *LPSERVER_INFO_402;

typedef struct _SERVER_INFO_403 {
     DWORD          sv403_ulist_mtime;
     DWORD          sv403_glist_mtime;
     DWORD          sv403_alist_mtime;
     LMSTR          sv403_alerts;
     DWORD          sv403_security;
     DWORD          sv403_numadmin;
     DWORD          sv403_lanmask;
     LMSTR          sv403_guestacct;
     DWORD          sv403_chdevs;
     DWORD          sv403_chdevq;
     DWORD          sv403_chdevjobs;
     DWORD          sv403_connections;
     DWORD          sv403_shares;
     DWORD          sv403_openfiles;
     DWORD          sv403_sessopens;
     DWORD          sv403_sessvcs;
     DWORD          sv403_sessreqs;
     DWORD          sv403_opensearch;
     DWORD          sv403_activelocks;
     DWORD          sv403_numreqbuf;
     DWORD          sv403_sizreqbuf;
     DWORD          sv403_numbigbuf;
     DWORD          sv403_numfiletasks;
     DWORD          sv403_alertsched;
     DWORD          sv403_erroralert;
     DWORD          sv403_logonalert;
     DWORD          sv403_accessalert;
     DWORD          sv403_diskalert;
     DWORD          sv403_netioalert;
     DWORD          sv403_maxauditsz;
     LMSTR          sv403_srvheuristics;
     DWORD          sv403_auditedevents;
     DWORD          sv403_autoprofile;
     LMSTR          sv403_autopath;
} SERVER_INFO_403, *PSERVER_INFO_403, *LPSERVER_INFO_403;

typedef struct _SERVER_INFO_502 {
    DWORD           sv502_sessopens;
    DWORD           sv502_sessvcs;
    DWORD           sv502_opensearch;
    DWORD           sv502_sizreqbuf;
    DWORD           sv502_initworkitems;
    DWORD           sv502_maxworkitems;
    DWORD           sv502_rawworkitems;
    DWORD           sv502_irpstacksize;
    DWORD           sv502_maxrawbuflen;
    DWORD           sv502_sessusers;
    DWORD           sv502_sessconns;
    DWORD           sv502_maxpagedmemoryusage;
    DWORD           sv502_maxnonpagedmemoryusage;
    BOOL            sv502_enablesoftcompat;
    BOOL            sv502_enableforcedlogoff;
    BOOL            sv502_timesource;
    BOOL            sv502_acceptdownlevelapis;
    BOOL            sv502_lmannounce;
} SERVER_INFO_502, *PSERVER_INFO_502, *LPSERVER_INFO_502;

typedef struct _SERVER_INFO_503 {
    DWORD           sv503_sessopens;
    DWORD           sv503_sessvcs;
    DWORD           sv503_opensearch;
    DWORD           sv503_sizreqbuf;
    DWORD           sv503_initworkitems;
    DWORD           sv503_maxworkitems;
    DWORD           sv503_rawworkitems;
    DWORD           sv503_irpstacksize;
    DWORD           sv503_maxrawbuflen;
    DWORD           sv503_sessusers;
    DWORD           sv503_sessconns;
    DWORD           sv503_maxpagedmemoryusage;
    DWORD           sv503_maxnonpagedmemoryusage;
    BOOL            sv503_enablesoftcompat;
    BOOL            sv503_enableforcedlogoff;
    BOOL            sv503_timesource;
    BOOL            sv503_acceptdownlevelapis;
    BOOL            sv503_lmannounce;
    LMSTR           sv503_domain;
    DWORD           sv503_maxcopyreadlen;
    DWORD           sv503_maxcopywritelen;
    DWORD           sv503_minkeepsearch;
    DWORD           sv503_maxkeepsearch;
    DWORD           sv503_minkeepcomplsearch;
    DWORD           sv503_maxkeepcomplsearch;
    DWORD           sv503_threadcountadd;
    DWORD           sv503_numblockthreads;
    DWORD           sv503_scavtimeout;
    DWORD           sv503_minrcvqueue;
    DWORD           sv503_minfreeworkitems;
    DWORD           sv503_xactmemsize;
    DWORD           sv503_threadpriority;
    DWORD           sv503_maxmpxct;
    DWORD           sv503_oplockbreakwait;
    DWORD           sv503_oplockbreakresponsewait;
    BOOL            sv503_enableoplocks;
    BOOL            sv503_enableoplockforceclose;
    BOOL            sv503_enablefcbopens;
    BOOL            sv503_enableraw;
    BOOL            sv503_enablesharednetdrives;
    DWORD           sv503_minfreeconnections;
    DWORD           sv503_maxfreeconnections;
} SERVER_INFO_503, *PSERVER_INFO_503, *LPSERVER_INFO_503;

typedef struct _SERVER_INFO_599 {
    DWORD           sv599_sessopens;
    DWORD           sv599_sessvcs;
    DWORD           sv599_opensearch;
    DWORD           sv599_sizreqbuf;
    DWORD           sv599_initworkitems;
    DWORD           sv599_maxworkitems;
    DWORD           sv599_rawworkitems;
    DWORD           sv599_irpstacksize;
    DWORD           sv599_maxrawbuflen;
    DWORD           sv599_sessusers;
    DWORD           sv599_sessconns;
    DWORD           sv599_maxpagedmemoryusage;
    DWORD           sv599_maxnonpagedmemoryusage;
    BOOL            sv599_enablesoftcompat;
    BOOL            sv599_enableforcedlogoff;
    BOOL            sv599_timesource;
    BOOL            sv599_acceptdownlevelapis;
    BOOL            sv599_lmannounce;
    LMSTR           sv599_domain;
    DWORD           sv599_maxcopyreadlen;
    DWORD           sv599_maxcopywritelen;
    DWORD           sv599_minkeepsearch;
    DWORD           sv599_maxkeepsearch;
    DWORD           sv599_minkeepcomplsearch;
    DWORD           sv599_maxkeepcomplsearch;
    DWORD           sv599_threadcountadd;
    DWORD           sv599_numblockthreads;
    DWORD           sv599_scavtimeout;
    DWORD           sv599_minrcvqueue;
    DWORD           sv599_minfreeworkitems;
    DWORD           sv599_xactmemsize;
    DWORD           sv599_threadpriority;
    DWORD           sv599_maxmpxct;
    DWORD           sv599_oplockbreakwait;
    DWORD           sv599_oplockbreakresponsewait;
    BOOL            sv599_enableoplocks;
    BOOL            sv599_enableoplockforceclose;
    BOOL            sv599_enablefcbopens;
    BOOL            sv599_enableraw;
    BOOL            sv599_enablesharednetdrives;
    DWORD           sv599_minfreeconnections;
    DWORD           sv599_maxfreeconnections;
    DWORD           sv599_initsesstable;
    DWORD           sv599_initconntable;
    DWORD           sv599_initfiletable;
    DWORD           sv599_initsearchtable;
    DWORD           sv599_alertschedule;
    DWORD           sv599_errorthreshold;
    DWORD           sv599_networkerrorthreshold;
    DWORD           sv599_diskspacethreshold;
    DWORD           sv599_reserved;
    DWORD           sv599_maxlinkdelay;
    DWORD           sv599_minlinkthroughput;
    DWORD           sv599_linkinfovalidtime;
    DWORD           sv599_scavqosinfoupdatetime;
    DWORD           sv599_maxworkitemidletime;
} SERVER_INFO_599, *PSERVER_INFO_599, *LPSERVER_INFO_599;

typedef struct _SERVER_INFO_598 {
    DWORD           sv598_maxrawworkitems;
    DWORD           sv598_maxthreadsperqueue;
    DWORD           sv598_producttype;
    DWORD           sv598_serversize;
    DWORD           sv598_connectionlessautodisc;
    DWORD           sv598_sharingviolationretries;
    DWORD           sv598_sharingviolationdelay;
    DWORD           sv598_maxglobalopensearch;
    DWORD           sv598_removeduplicatesearches;
    DWORD           sv598_lockviolationoffset;
    DWORD           sv598_lockviolationdelay;
    DWORD           sv598_mdlreadswitchover;
    DWORD           sv598_cachedopenlimit;
    DWORD           sv598_otherqueueaffinity;
    BOOL            sv598_restrictnullsessaccess;
    BOOL            sv598_enablewfw311directipx;
    DWORD           sv598_queuesamplesecs;
    DWORD           sv598_balancecount;
    DWORD           sv598_preferredaffinity;
    DWORD           sv598_maxfreerfcbs;
    DWORD           sv598_maxfreemfcbs;
    DWORD           sv598_maxfreelfcbs;
    DWORD           sv598_maxfreepagedpoolchunks;
    DWORD           sv598_minpagedpoolchunksize;
    DWORD           sv598_maxpagedpoolchunksize;
    BOOL            sv598_sendsfrompreferredprocessor;
    DWORD           sv598_cacheddirectorylimit;
    DWORD           sv598_maxcopylength;
    BOOL            sv598_enablecompression;
    BOOL            sv598_autosharewks;
    BOOL            sv598_autoshareserver;
    BOOL            sv598_enablesecuritysignature;
    BOOL            sv598_requiresecuritysignature;
    DWORD           sv598_minclientbuffersize;
    GUID            sv598_serverguid;
    DWORD           sv598_ConnectionNoSessionsTimeout;
    DWORD           sv598_IdleThreadTimeOut;
    BOOL            sv598_enableW9xsecuritysignature;
    BOOL            sv598_enforcekerberosreauthentication;
    BOOL            sv598_disabledos;
    DWORD           sv598_lowdiskspaceminimum;
    BOOL            sv598_disablestrictnamechecking;
    BOOL            sv598_enableauthenticateusersharing;
} SERVER_INFO_598, *PSERVER_INFO_598, *LPSERVER_INFO_598;

typedef struct _SERVER_INFO_1005 {
    LMSTR           sv1005_comment;
} SERVER_INFO_1005, *PSERVER_INFO_1005, *LPSERVER_INFO_1005;

typedef struct _SERVER_INFO_1107 {
    DWORD           sv1107_users;
} SERVER_INFO_1107, *PSERVER_INFO_1107, *LPSERVER_INFO_1107;

typedef struct _SERVER_INFO_1010 {
    LONG            sv1010_disc;
} SERVER_INFO_1010, *PSERVER_INFO_1010, *LPSERVER_INFO_1010;

typedef struct _SERVER_INFO_1016 {
    BOOL            sv1016_hidden;
} SERVER_INFO_1016, *PSERVER_INFO_1016, *LPSERVER_INFO_1016;

typedef struct _SERVER_INFO_1017 {
    DWORD           sv1017_announce;
} SERVER_INFO_1017, *PSERVER_INFO_1017, *LPSERVER_INFO_1017;

typedef struct _SERVER_INFO_1018 {
    DWORD           sv1018_anndelta;
} SERVER_INFO_1018, *PSERVER_INFO_1018, *LPSERVER_INFO_1018;

typedef struct _SERVER_INFO_1501 {
    DWORD           sv1501_sessopens;
} SERVER_INFO_1501, *PSERVER_INFO_1501, *LPSERVER_INFO_1501;

typedef struct _SERVER_INFO_1502 {
    DWORD           sv1502_sessvcs;
} SERVER_INFO_1502, *PSERVER_INFO_1502, *LPSERVER_INFO_1502;

typedef struct _SERVER_INFO_1503 {
    DWORD           sv1503_opensearch;
} SERVER_INFO_1503, *PSERVER_INFO_1503, *LPSERVER_INFO_1503;

typedef struct _SERVER_INFO_1506 {
    DWORD           sv1506_maxworkitems;
} SERVER_INFO_1506, *PSERVER_INFO_1506, *LPSERVER_INFO_1506;

typedef struct _SERVER_INFO_1509 {
    DWORD           sv1509_maxrawbuflen;
} SERVER_INFO_1509, *PSERVER_INFO_1509, *LPSERVER_INFO_1509;

typedef struct _SERVER_INFO_1510 {
    DWORD           sv1510_sessusers;
} SERVER_INFO_1510, *PSERVER_INFO_1510, *LPSERVER_INFO_1510;

typedef struct _SERVER_INFO_1511 {
    DWORD           sv1511_sessconns;
} SERVER_INFO_1511, *PSERVER_INFO_1511, *LPSERVER_INFO_1511;

typedef struct _SERVER_INFO_1512 {
    DWORD           sv1512_maxnonpagedmemoryusage;
} SERVER_INFO_1512, *PSERVER_INFO_1512, *LPSERVER_INFO_1512;

typedef struct _SERVER_INFO_1513 {
    DWORD           sv1513_maxpagedmemoryusage;
} SERVER_INFO_1513, *PSERVER_INFO_1513, *LPSERVER_INFO_1513;

typedef struct _SERVER_INFO_1514 {
    BOOL            sv1514_enablesoftcompat;
} SERVER_INFO_1514, *PSERVER_INFO_1514, *LPSERVER_INFO_1514;

typedef struct _SERVER_INFO_1515 {
    BOOL            sv1515_enableforcedlogoff;
} SERVER_INFO_1515, *PSERVER_INFO_1515, *LPSERVER_INFO_1515;

typedef struct _SERVER_INFO_1516 {
    BOOL            sv1516_timesource;
} SERVER_INFO_1516, *PSERVER_INFO_1516, *LPSERVER_INFO_1516;

typedef struct _SERVER_INFO_1518 {
    BOOL            sv1518_lmannounce;
} SERVER_INFO_1518, *PSERVER_INFO_1518, *LPSERVER_INFO_1518;

typedef struct _SERVER_INFO_1520 {
    DWORD           sv1520_maxcopyreadlen;
} SERVER_INFO_1520, *PSERVER_INFO_1520, *LPSERVER_INFO_1520;

typedef struct _SERVER_INFO_1521 {
    DWORD           sv1521_maxcopywritelen;
} SERVER_INFO_1521, *PSERVER_INFO_1521, *LPSERVER_INFO_1521;

typedef struct _SERVER_INFO_1522 {
    DWORD           sv1522_minkeepsearch;
} SERVER_INFO_1522, *PSERVER_INFO_1522, *LPSERVER_INFO_1522;

typedef struct _SERVER_INFO_1523 {
    DWORD           sv1523_maxkeepsearch;
} SERVER_INFO_1523, *PSERVER_INFO_1523, *LPSERVER_INFO_1523;

typedef struct _SERVER_INFO_1524 {
    DWORD           sv1524_minkeepcomplsearch;
} SERVER_INFO_1524, *PSERVER_INFO_1524, *LPSERVER_INFO_1524;

typedef struct _SERVER_INFO_1525 {
    DWORD           sv1525_maxkeepcomplsearch;
} SERVER_INFO_1525, *PSERVER_INFO_1525, *LPSERVER_INFO_1525;

typedef struct _SERVER_INFO_1528 {
    DWORD           sv1528_scavtimeout;
} SERVER_INFO_1528, *PSERVER_INFO_1528, *LPSERVER_INFO_1528;

typedef struct _SERVER_INFO_1529 {
    DWORD           sv1529_minrcvqueue;
} SERVER_INFO_1529, *PSERVER_INFO_1529, *LPSERVER_INFO_1529;

typedef struct _SERVER_INFO_1530 {
    DWORD           sv1530_minfreeworkitems;
} SERVER_INFO_1530, *PSERVER_INFO_1530, *LPSERVER_INFO_1530;

typedef struct _SERVER_INFO_1533 {
    DWORD           sv1533_maxmpxct;
} SERVER_INFO_1533, *PSERVER_INFO_1533, *LPSERVER_INFO_1533;

typedef struct _SERVER_INFO_1534 {
    DWORD           sv1534_oplockbreakwait;
} SERVER_INFO_1534, *PSERVER_INFO_1534, *LPSERVER_INFO_1534;

typedef struct _SERVER_INFO_1535 {
    DWORD           sv1535_oplockbreakresponsewait;
} SERVER_INFO_1535, *PSERVER_INFO_1535, *LPSERVER_INFO_1535;

typedef struct _SERVER_INFO_1536 {
    BOOL            sv1536_enableoplocks;
} SERVER_INFO_1536, *PSERVER_INFO_1536, *LPSERVER_INFO_1536;

typedef struct _SERVER_INFO_1537 {
    BOOL            sv1537_enableoplockforceclose;
} SERVER_INFO_1537, *PSERVER_INFO_1537, *LPSERVER_INFO_1537;

typedef struct _SERVER_INFO_1538 {
    BOOL            sv1538_enablefcbopens;
} SERVER_INFO_1538, *PSERVER_INFO_1538, *LPSERVER_INFO_1538;

typedef struct _SERVER_INFO_1539 {
    BOOL            sv1539_enableraw;
} SERVER_INFO_1539, *PSERVER_INFO_1539, *LPSERVER_INFO_1539;

typedef struct _SERVER_INFO_1540 {
    BOOL            sv1540_enablesharednetdrives;
} SERVER_INFO_1540, *PSERVER_INFO_1540, *LPSERVER_INFO_1540;

typedef struct _SERVER_INFO_1541 {
    BOOL            sv1541_minfreeconnections;
} SERVER_INFO_1541, *PSERVER_INFO_1541, *LPSERVER_INFO_1541;

typedef struct _SERVER_INFO_1542 {
    BOOL            sv1542_maxfreeconnections;
} SERVER_INFO_1542, *PSERVER_INFO_1542, *LPSERVER_INFO_1542;

typedef struct _SERVER_INFO_1543 {
    DWORD           sv1543_initsesstable;
} SERVER_INFO_1543, *PSERVER_INFO_1543, *LPSERVER_INFO_1543;

typedef struct _SERVER_INFO_1544 {
    DWORD           sv1544_initconntable;
} SERVER_INFO_1544, *PSERVER_INFO_1544, *LPSERVER_INFO_1544;

typedef struct _SERVER_INFO_1545 {
    DWORD           sv1545_initfiletable;
} SERVER_INFO_1545, *PSERVER_INFO_1545, *LPSERVER_INFO_1545;

typedef struct _SERVER_INFO_1546 {
    DWORD           sv1546_initsearchtable;
} SERVER_INFO_1546, *PSERVER_INFO_1546, *LPSERVER_INFO_1546;

typedef struct _SERVER_INFO_1547 {
    DWORD           sv1547_alertschedule;
} SERVER_INFO_1547, *PSERVER_INFO_1547, *LPSERVER_INFO_1547;

typedef struct _SERVER_INFO_1548 {
    DWORD           sv1548_errorthreshold;
} SERVER_INFO_1548, *PSERVER_INFO_1548, *LPSERVER_INFO_1548;

typedef struct _SERVER_INFO_1549 {
    DWORD           sv1549_networkerrorthreshold;
} SERVER_INFO_1549, *PSERVER_INFO_1549, *LPSERVER_INFO_1549;

typedef struct _SERVER_INFO_1550 {
    DWORD           sv1550_diskspacethreshold;
} SERVER_INFO_1550, *PSERVER_INFO_1550, *LPSERVER_INFO_1550;

typedef struct _SERVER_INFO_1552 {
    DWORD           sv1552_maxlinkdelay;
} SERVER_INFO_1552, *PSERVER_INFO_1552, *LPSERVER_INFO_1552;

typedef struct _SERVER_INFO_1553 {
    DWORD           sv1553_minlinkthroughput;
} SERVER_INFO_1553, *PSERVER_INFO_1553, *LPSERVER_INFO_1553;

typedef struct _SERVER_INFO_1554 {
    DWORD           sv1554_linkinfovalidtime;
} SERVER_INFO_1554, *PSERVER_INFO_1554, *LPSERVER_INFO_1554;

typedef struct _SERVER_INFO_1555 {
    DWORD           sv1555_scavqosinfoupdatetime;
} SERVER_INFO_1555, *PSERVER_INFO_1555, *LPSERVER_INFO_1555;

typedef struct _SERVER_INFO_1556 {
    DWORD           sv1556_maxworkitemidletime;
} SERVER_INFO_1556, *PSERVER_INFO_1556, *LPSERVER_INFO_1556;

typedef struct _SERVER_INFO_1557 {
    DWORD           sv1557_maxrawworkitems;
} SERVER_INFO_1557, *PSERVER_INFO_1557, *LPSERVER_INFO_1557;

typedef struct _SERVER_INFO_1560 {
    DWORD           sv1560_producttype;
} SERVER_INFO_1560, *PSERVER_INFO_1560, *LPSERVER_INFO_1560;

typedef struct _SERVER_INFO_1561 {
    DWORD           sv1561_serversize;
} SERVER_INFO_1561, *PSERVER_INFO_1561, *LPSERVER_INFO_1561;

typedef struct _SERVER_INFO_1562 {
    DWORD           sv1562_connectionlessautodisc;
} SERVER_INFO_1562, *PSERVER_INFO_1562, *LPSERVER_INFO_1562;

typedef struct _SERVER_INFO_1563 {
    DWORD           sv1563_sharingviolationretries;
} SERVER_INFO_1563, *PSERVER_INFO_1563, *LPSERVER_INFO_1563;

typedef struct _SERVER_INFO_1564 {
    DWORD           sv1564_sharingviolationdelay;
} SERVER_INFO_1564, *PSERVER_INFO_1564, *LPSERVER_INFO_1564;

typedef struct _SERVER_INFO_1565 {
    DWORD           sv1565_maxglobalopensearch;
} SERVER_INFO_1565, *PSERVER_INFO_1565, *LPSERVER_INFO_1565;

typedef struct _SERVER_INFO_1566 {
    BOOL           sv1566_removeduplicatesearches;
} SERVER_INFO_1566, *PSERVER_INFO_1566, *LPSERVER_INFO_1566;

typedef struct _SERVER_INFO_1567 {
    DWORD           sv1567_lockviolationretries;
} SERVER_INFO_1567, *PSERVER_INFO_1567, *LPSERVER_INFO_1567;

typedef struct _SERVER_INFO_1568 {
    DWORD           sv1568_lockviolationoffset;
} SERVER_INFO_1568, *PSERVER_INFO_1568, *LPSERVER_INFO_1568;

typedef struct _SERVER_INFO_1569 {
    DWORD           sv1569_lockviolationdelay;
} SERVER_INFO_1569, *PSERVER_INFO_1569, *LPSERVER_INFO_1569;

typedef struct _SERVER_INFO_1570 {
    DWORD           sv1570_mdlreadswitchover;
} SERVER_INFO_1570, *PSERVER_INFO_1570, *LPSERVER_INFO_1570;

typedef struct _SERVER_INFO_1571 {
    DWORD           sv1571_cachedopenlimit;
} SERVER_INFO_1571, *PSERVER_INFO_1571, *LPSERVER_INFO_1571;

typedef struct _SERVER_INFO_1572 {
    DWORD           sv1572_criticalthreads;
} SERVER_INFO_1572, *PSERVER_INFO_1572, *LPSERVER_INFO_1572;

typedef struct _SERVER_INFO_1573 {
    DWORD           sv1573_restrictnullsessaccess;
} SERVER_INFO_1573, *PSERVER_INFO_1573, *LPSERVER_INFO_1573;

typedef struct _SERVER_INFO_1574 {
    DWORD           sv1574_enablewfw311directipx;
} SERVER_INFO_1574, *PSERVER_INFO_1574, *LPSERVER_INFO_1574;

typedef struct _SERVER_INFO_1575 {
    DWORD           sv1575_otherqueueaffinity;
} SERVER_INFO_1575, *PSERVER_INFO_1575, *LPSERVER_INFO_1575;

typedef struct _SERVER_INFO_1576 {
    DWORD           sv1576_queuesamplesecs;
} SERVER_INFO_1576, *PSERVER_INFO_1576, *LPSERVER_INFO_1576;

typedef struct _SERVER_INFO_1577 {
    DWORD           sv1577_balancecount;
} SERVER_INFO_1577, *PSERVER_INFO_1577, *LPSERVER_INFO_1577;

typedef struct _SERVER_INFO_1578 {
    DWORD           sv1578_preferredaffinity;
} SERVER_INFO_1578, *PSERVER_INFO_1578, *LPSERVER_INFO_1578;

typedef struct _SERVER_INFO_1579 {
    DWORD           sv1579_maxfreerfcbs;
} SERVER_INFO_1579, *PSERVER_INFO_1579, *LPSERVER_INFO_1579;

typedef struct _SERVER_INFO_1580 {
    DWORD           sv1580_maxfreemfcbs;
} SERVER_INFO_1580, *PSERVER_INFO_1580, *LPSERVER_INFO_1580;

typedef struct _SERVER_INFO_1581 {
    DWORD           sv1581_maxfreemlcbs;
} SERVER_INFO_1581, *PSERVER_INFO_1581, *LPSERVER_INFO_1581;

typedef struct _SERVER_INFO_1582 {
    DWORD           sv1582_maxfreepagedpoolchunks;
} SERVER_INFO_1582, *PSERVER_INFO_1582, *LPSERVER_INFO_1582;

typedef struct _SERVER_INFO_1583 {
    DWORD           sv1583_minpagedpoolchunksize;
} SERVER_INFO_1583, *PSERVER_INFO_1583, *LPSERVER_INFO_1583;

typedef struct _SERVER_INFO_1584 {
    DWORD           sv1584_maxpagedpoolchunksize;
} SERVER_INFO_1584, *PSERVER_INFO_1584, *LPSERVER_INFO_1584;

typedef struct _SERVER_INFO_1585 {
    BOOL           sv1585_sendsfrompreferredprocessor;
} SERVER_INFO_1585, *PSERVER_INFO_1585, *LPSERVER_INFO_1585;

typedef struct _SERVER_INFO_1586 {
    DWORD          sv1586_maxthreadsperqueue;
} SERVER_INFO_1586, *PSERVER_INFO_1586, *LPSERVER_INFO_1586;

typedef struct _SERVER_INFO_1587 {
    DWORD          sv1587_cacheddirectorylimit;
} SERVER_INFO_1587, *PSERVER_INFO_1587, *LPSERVER_INFO_1587;

typedef struct _SERVER_INFO_1588 {
    DWORD          sv1588_maxcopylength;
} SERVER_INFO_1588, *PSERVER_INFO_1588, *LPSERVER_INFO_1588;

typedef struct _SERVER_INFO_1590 {
    DWORD          sv1590_enablecompression;
} SERVER_INFO_1590, *PSERVER_INFO_1590, *LPSERVER_INFO_1590;

typedef struct _SERVER_INFO_1591 {
    DWORD          sv1591_autosharewks;
} SERVER_INFO_1591, *PSERVER_INFO_1591, *LPSERVER_INFO_1591;

typedef struct _SERVER_INFO_1592 {
    DWORD          sv1592_autosharewks;
} SERVER_INFO_1592, *PSERVER_INFO_1592, *LPSERVER_INFO_1592;

typedef struct _SERVER_INFO_1593 {
    DWORD          sv1593_enablesecuritysignature;
} SERVER_INFO_1593, *PSERVER_INFO_1593, *LPSERVER_INFO_1593;

typedef struct _SERVER_INFO_1594 {
    DWORD          sv1594_requiresecuritysignature;
} SERVER_INFO_1594, *PSERVER_INFO_1594, *LPSERVER_INFO_1594;

typedef struct _SERVER_INFO_1595 {
    DWORD          sv1595_minclientbuffersize;
} SERVER_INFO_1595, *PSERVER_INFO_1595, *LPSERVER_INFO_1595;

typedef struct _SERVER_INFO_1596 {
    DWORD          sv1596_ConnectionNoSessionsTimeout;
} SERVER_INFO_1596, *PSERVER_INFO_1596, *LPSERVER_INFO_1596;

typedef struct _SERVER_INFO_1597 {
    DWORD          sv1597_IdleThreadTimeOut;
} SERVER_INFO_1597, *PSERVER_INFO_1597, *LPSERVER_INFO_1597;

typedef struct _SERVER_INFO_1598 {
    DWORD          sv1598_enableW9xsecuritysignature;
} SERVER_INFO_1598, *PSERVER_INFO_1598, *LPSERVER_INFO_1598;

typedef struct _SERVER_INFO_1599 {
    BOOLEAN        sv1598_enforcekerberosreauthentication;
} SERVER_INFO_1599, *PSERVER_INFO_1599, *LPSERVER_INFO_1599;

typedef struct _SERVER_INFO_1600 {
    BOOLEAN        sv1598_disabledos;
} SERVER_INFO_1600, *PSERVER_INFO_1600, *LPSERVER_INFO_1600;

typedef struct _SERVER_INFO_1601 {
    DWORD          sv1598_lowdiskspaceminimum;
} SERVER_INFO_1601, *PSERVER_INFO_1601, *LPSERVER_INFO_1601;

typedef struct _SERVER_INFO_1602 {
    BOOL           sv_1598_disablestrictnamechecking;
} SERVER_INFO_1602, *PSERVER_INFO_1602, *LPSERVER_INFO_1602;

//
// A special structure definition is required in order for this
// structure to work with RPC.  The problem is that having addresslength
// indicate the number of bytes in address means that RPC must know the
// link between the two.
//

#ifdef MIDL_PASS

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LMSTR           svti0_transportname;
    [size_is(svti0_transportaddresslength)]  LPBYTE svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LMSTR           svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

typedef struct _SERVER_TRANSPORT_INFO_1 {
    DWORD           svti1_numberofvcs;
    LMSTR           svti1_transportname;
    [size_is(svti1_transportaddresslength)]  LPBYTE svti1_transportaddress;
    DWORD           svti1_transportaddresslength;
    LMSTR           svti1_networkaddress;
    LMSTR           svti1_domain;
} SERVER_TRANSPORT_INFO_1, *PSERVER_TRANSPORT_INFO_1, *LPSERVER_TRANSPORT_INFO_1;

typedef struct _SERVER_TRANSPORT_INFO_2 {
    DWORD           svti2_numberofvcs;
    LMSTR           svti2_transportname;
    [size_is(svti2_transportaddresslength)] LPBYTE svti2_transportaddress;
    DWORD           svti2_transportaddresslength;
    LMSTR           svti2_networkaddress;
    LMSTR           svti2_domain;
    ULONG           svti2_flags;
} SERVER_TRANSPORT_INFO_2, *PSERVER_TRANSPORT_INFO_2, *LPSERVER_TRANSPORT_INFO_2;

typedef struct _SERVER_TRANSPORT_INFO_3 {
    DWORD           svti3_numberofvcs;
    LMSTR           svti3_transportname;
    [size_is(svti3_transportaddresslength)]  LPBYTE svti3_transportaddress;
    DWORD           svti3_transportaddresslength;
    LMSTR           svti3_networkaddress;
    LMSTR           svti3_domain;
    ULONG           svti3_flags;
    DWORD           svti3_passwordlength;
    BYTE            svti3_password[ 256 ];
} SERVER_TRANSPORT_INFO_3, *PSERVER_TRANSPORT_INFO_3, *LPSERVER_TRANSPORT_INFO_3;

#else

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LMSTR           svti0_transportname;
    LPBYTE          svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LMSTR           svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

typedef struct _SERVER_TRANSPORT_INFO_1 {
    DWORD           svti1_numberofvcs;
    LMSTR           svti1_transportname;
    LPBYTE          svti1_transportaddress;
    DWORD           svti1_transportaddresslength;
    LMSTR           svti1_networkaddress;
    LMSTR           svti1_domain;
} SERVER_TRANSPORT_INFO_1, *PSERVER_TRANSPORT_INFO_1, *LPSERVER_TRANSPORT_INFO_1;

typedef struct _SERVER_TRANSPORT_INFO_2 {
    DWORD           svti2_numberofvcs;
    LMSTR           svti2_transportname;
    LPBYTE          svti2_transportaddress;
    DWORD           svti2_transportaddresslength;
    LMSTR           svti2_networkaddress;
    LMSTR           svti2_domain;
    ULONG           svti2_flags;
} SERVER_TRANSPORT_INFO_2, *PSERVER_TRANSPORT_INFO_2, *LPSERVER_TRANSPORT_INFO_2;

typedef struct _SERVER_TRANSPORT_INFO_3 {
    DWORD           svti3_numberofvcs;
    LMSTR           svti3_transportname;
    LPBYTE          svti3_transportaddress;
    DWORD           svti3_transportaddresslength;
    LMSTR           svti3_networkaddress;
    LMSTR           svti3_domain;
    ULONG           svti3_flags;
    DWORD           svti3_passwordlength;
    BYTE            svti3_password[ 256 ];
} SERVER_TRANSPORT_INFO_3, *PSERVER_TRANSPORT_INFO_3, *LPSERVER_TRANSPORT_INFO_3;

#endif

//
// Defines - SERVER
//

//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define SV_PLATFORM_ID_OS2 400
#define SV_PLATFORM_ID_NT  500

//
//      Mask to be applied to svX_version_major in order to obtain
//      the major version number.
//

#define MAJOR_VERSION_MASK  0x0F

//
//      Bit-mapped values for svX_type fields. X = 1, 2 or 3.
//

#define SV_TYPE_WORKSTATION         0x00000001
#define SV_TYPE_SERVER              0x00000002
#define SV_TYPE_SQLSERVER           0x00000004
#define SV_TYPE_DOMAIN_CTRL         0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL      0x00000010
#define SV_TYPE_TIME_SOURCE         0x00000020
#define SV_TYPE_AFP                 0x00000040
#define SV_TYPE_NOVELL              0x00000080
#define SV_TYPE_DOMAIN_MEMBER       0x00000100
#define SV_TYPE_PRINTQ_SERVER       0x00000200
#define SV_TYPE_DIALIN_SERVER       0x00000400
#define SV_TYPE_XENIX_SERVER        0x00000800
#define SV_TYPE_SERVER_UNIX         SV_TYPE_XENIX_SERVER
#define SV_TYPE_NT                  0x00001000
#define SV_TYPE_WFW                 0x00002000
#define SV_TYPE_SERVER_MFPN         0x00004000
#define SV_TYPE_SERVER_NT           0x00008000
#define SV_TYPE_POTENTIAL_BROWSER   0x00010000
#define SV_TYPE_BACKUP_BROWSER      0x00020000
#define SV_TYPE_MASTER_BROWSER      0x00040000
#define SV_TYPE_DOMAIN_MASTER       0x00080000
#define SV_TYPE_SERVER_OSF          0x00100000
#define SV_TYPE_SERVER_VMS          0x00200000
#define SV_TYPE_WINDOWS             0x00400000  /* Windows95 and above */
#define SV_TYPE_DFS                 0x00800000  /* Root of a DFS tree */
#define SV_TYPE_CLUSTER_NT          0x01000000  /* NT Cluster */
#define SV_TYPE_TERMINALSERVER      0x02000000  /* Terminal Server(Hydra) */
#define SV_TYPE_CLUSTER_VS_NT       0x04000000  /* NT Cluster Virtual Server Name */
#define SV_TYPE_DCE                 0x10000000  /* IBM DSS (Directory and Security Services) or equivalent */
#define SV_TYPE_ALTERNATE_XPORT     0x20000000  /* return list for alternate transport */
#define SV_TYPE_LOCAL_LIST_ONLY     0x40000000  /* Return local list only */
#define SV_TYPE_DOMAIN_ENUM         0x80000000
#define SV_TYPE_ALL                 0xFFFFFFFF  /* handy for NetServerEnum2 */

//
//      Special value for sv102_disc that specifies infinite disconnect
//      time.
//

#define SV_NODISC           (-1L)  /* No autodisconnect timeout enforced */

//
//      Values of svX_security field. X = 2 or 3.
//

#define SV_USERSECURITY     1
#define SV_SHARESECURITY    0

//
//      Values of svX_hidden field. X = 2 or 3.
//

#define SV_HIDDEN       1
#define SV_VISIBLE      0

//
//      Values for ParmError parameter to NetServerSetInfo.
//

#define SV_PLATFORM_ID_PARMNUM          101
#define SV_NAME_PARMNUM                 102
#define SV_VERSION_MAJOR_PARMNUM        103
#define SV_VERSION_MINOR_PARMNUM        104
#define SV_TYPE_PARMNUM                 105
#define SV_COMMENT_PARMNUM              5
#define SV_USERS_PARMNUM                107
#define SV_DISC_PARMNUM                 10
#define SV_HIDDEN_PARMNUM               16
#define SV_ANNOUNCE_PARMNUM             17
#define SV_ANNDELTA_PARMNUM             18
#define SV_USERPATH_PARMNUM             112

#define SV_ULIST_MTIME_PARMNUM          401
#define SV_GLIST_MTIME_PARMNUM          402
#define SV_ALIST_MTIME_PARMNUM          403
#define SV_ALERTS_PARMNUM               11
#define SV_SECURITY_PARMNUM             405
#define SV_NUMADMIN_PARMNUM             406
#define SV_LANMASK_PARMNUM              407
#define SV_GUESTACC_PARMNUM             408
#define SV_CHDEVQ_PARMNUM               410
#define SV_CHDEVJOBS_PARMNUM            411
#define SV_CONNECTIONS_PARMNUM          412
#define SV_SHARES_PARMNUM               413
#define SV_OPENFILES_PARMNUM            414
#define SV_SESSREQS_PARMNUM             417
#define SV_ACTIVELOCKS_PARMNUM          419
#define SV_NUMREQBUF_PARMNUM            420
#define SV_NUMBIGBUF_PARMNUM            422
#define SV_NUMFILETASKS_PARMNUM         423
#define SV_ALERTSCHED_PARMNUM           37
#define SV_ERRORALERT_PARMNUM           38
#define SV_LOGONALERT_PARMNUM           39
#define SV_ACCESSALERT_PARMNUM          40
#define SV_DISKALERT_PARMNUM            41
#define SV_NETIOALERT_PARMNUM           42
#define SV_MAXAUDITSZ_PARMNUM           43
#define SV_SRVHEURISTICS_PARMNUM        431

#define SV_SESSOPENS_PARMNUM                501
#define SV_SESSVCS_PARMNUM                  502
#define SV_OPENSEARCH_PARMNUM               503
#define SV_SIZREQBUF_PARMNUM                504
#define SV_INITWORKITEMS_PARMNUM            505
#define SV_MAXWORKITEMS_PARMNUM             506
#define SV_RAWWORKITEMS_PARMNUM             507
#define SV_IRPSTACKSIZE_PARMNUM             508
#define SV_MAXRAWBUFLEN_PARMNUM             509
#define SV_SESSUSERS_PARMNUM                510
#define SV_SESSCONNS_PARMNUM                511
#define SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM   512
#define SV_MAXPAGEDMEMORYUSAGE_PARMNUM      513
#define SV_ENABLESOFTCOMPAT_PARMNUM         514
#define SV_ENABLEFORCEDLOGOFF_PARMNUM       515
#define SV_TIMESOURCE_PARMNUM               516
#define SV_ACCEPTDOWNLEVELAPIS_PARMNUM      517
#define SV_LMANNOUNCE_PARMNUM               518
#define SV_DOMAIN_PARMNUM                   519
#define SV_MAXCOPYREADLEN_PARMNUM           520
#define SV_MAXCOPYWRITELEN_PARMNUM          521
#define SV_MINKEEPSEARCH_PARMNUM            522
#define SV_MAXKEEPSEARCH_PARMNUM            523
#define SV_MINKEEPCOMPLSEARCH_PARMNUM       524
#define SV_MAXKEEPCOMPLSEARCH_PARMNUM       525
#define SV_THREADCOUNTADD_PARMNUM           526
#define SV_NUMBLOCKTHREADS_PARMNUM          527
#define SV_SCAVTIMEOUT_PARMNUM              528
#define SV_MINRCVQUEUE_PARMNUM              529
#define SV_MINFREEWORKITEMS_PARMNUM         530
#define SV_XACTMEMSIZE_PARMNUM              531
#define SV_THREADPRIORITY_PARMNUM           532
#define SV_MAXMPXCT_PARMNUM                 533
#define SV_OPLOCKBREAKWAIT_PARMNUM          534
#define SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM  535
#define SV_ENABLEOPLOCKS_PARMNUM            536
#define SV_ENABLEOPLOCKFORCECLOSE_PARMNUM   537
#define SV_ENABLEFCBOPENS_PARMNUM           538
#define SV_ENABLERAW_PARMNUM                539
#define SV_ENABLESHAREDNETDRIVES_PARMNUM    540
#define SV_MINFREECONNECTIONS_PARMNUM       541
#define SV_MAXFREECONNECTIONS_PARMNUM       542
#define SV_INITSESSTABLE_PARMNUM            543
#define SV_INITCONNTABLE_PARMNUM            544
#define SV_INITFILETABLE_PARMNUM            545
#define SV_INITSEARCHTABLE_PARMNUM          546
#define SV_ALERTSCHEDULE_PARMNUM            547
#define SV_ERRORTHRESHOLD_PARMNUM           548
#define SV_NETWORKERRORTHRESHOLD_PARMNUM    549
#define SV_DISKSPACETHRESHOLD_PARMNUM       550
#define SV_MAXLINKDELAY_PARMNUM             552
#define SV_MINLINKTHROUGHPUT_PARMNUM        553
#define SV_LINKINFOVALIDTIME_PARMNUM        554
#define SV_SCAVQOSINFOUPDATETIME_PARMNUM    555
#define SV_MAXWORKITEMIDLETIME_PARMNUM      556
#define SV_MAXRAWWORKITEMS_PARMNUM          557
#define SV_PRODUCTTYPE_PARMNUM              560
#define SV_SERVERSIZE_PARMNUM               561
#define SV_CONNECTIONLESSAUTODISC_PARMNUM   562
#define SV_SHARINGVIOLATIONRETRIES_PARMNUM  563
#define SV_SHARINGVIOLATIONDELAY_PARMNUM    564
#define SV_MAXGLOBALOPENSEARCH_PARMNUM      565
#define SV_REMOVEDUPLICATESEARCHES_PARMNUM  566
#define SV_LOCKVIOLATIONRETRIES_PARMNUM     567
#define SV_LOCKVIOLATIONOFFSET_PARMNUM      568
#define SV_LOCKVIOLATIONDELAY_PARMNUM       569
#define SV_MDLREADSWITCHOVER_PARMNUM        570
#define SV_CACHEDOPENLIMIT_PARMNUM          571
#define SV_CRITICALTHREADS_PARMNUM          572
#define SV_RESTRICTNULLSESSACCESS_PARMNUM   573
#define SV_ENABLEWFW311DIRECTIPX_PARMNUM    574
#define SV_OTHERQUEUEAFFINITY_PARMNUM       575
#define SV_QUEUESAMPLESECS_PARMNUM          576
#define SV_BALANCECOUNT_PARMNUM             577
#define SV_PREFERREDAFFINITY_PARMNUM        578
#define SV_MAXFREERFCBS_PARMNUM             579
#define SV_MAXFREEMFCBS_PARMNUM             580
#define SV_MAXFREELFCBS_PARMNUM             581
#define SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM   582
#define SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM    583
#define SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM    584
#define SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM    585
#define SV_MAXTHREADSPERQUEUE_PARMNUM       586
#define SV_CACHEDDIRECTORYLIMIT_PARMNUM     587
#define SV_MAXCOPYLENGTH_PARMNUM            588
#define SV_ENABLECOMPRESSION_PARMNUM        590
#define SV_AUTOSHAREWKS_PARMNUM             591
#define SV_AUTOSHARESERVER_PARMNUM          592
#define SV_ENABLESECURITYSIGNATURE_PARMNUM  593
#define SV_REQUIRESECURITYSIGNATURE_PARMNUM 594
#define SV_MINCLIENTBUFFERSIZE_PARMNUM      595
#define SV_CONNECTIONNOSESSIONSTIMEOUT_PARMNUM 596
#define SV_IDLETHREADTIMEOUT_PARMNUM        597
#define SV_ENABLEW9XSECURITYSIGNATURE_PARMNUM        598
#define SV_ENFORCEKERBEROSREAUTHENTICATION_PARMNUM   599
#define SV_DISABLEDOS_PARMNUM                        600
#define SV_LOWDISKSPACEMINIMUM_PARMNUM               601
#define SV_DISABLESTRICTNAMECHECKING_PARMNUM         602
#define SV_ENABLEAUTHENTICATEUSERSHARING_PARMNUM     603

//
// Single-field infolevels for NetServerSetInfo.
//

#define SV_COMMENT_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_COMMENT_PARMNUM)
#define SV_USERS_INFOLEVEL                      \
            (PARMNUM_BASE_INFOLEVEL + SV_USERS_PARMNUM)
#define SV_DISC_INFOLEVEL                       \
            (PARMNUM_BASE_INFOLEVEL + SV_DISC_PARMNUM)
#define SV_HIDDEN_INFOLEVEL                     \
            (PARMNUM_BASE_INFOLEVEL + SV_HIDDEN_PARMNUM)
#define SV_ANNOUNCE_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNOUNCE_PARMNUM)
#define SV_ANNDELTA_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNDELTA_PARMNUM)
#define SV_SESSOPENS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSOPENS_PARMNUM)
#define SV_SESSVCS_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSVCS_PARMNUM)
#define SV_OPENSEARCH_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_OPENSEARCH_PARMNUM)
#define SV_MAXWORKITEMS_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMS_PARMNUM)
#define SV_MAXRAWBUFLEN_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWBUFLEN_PARMNUM)
#define SV_SESSUSERS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSUSERS_PARMNUM)
#define SV_SESSCONNS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSCONNS_PARMNUM)
#define SV_MAXNONPAGEDMEMORYUSAGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM)
#define SV_MAXPAGEDMEMORYUSAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDMEMORYUSAGE_PARMNUM)
#define SV_ENABLESOFTCOMPAT_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESOFTCOMPAT_PARMNUM)
#define SV_ENABLEFORCEDLOGOFF_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFORCEDLOGOFF_PARMNUM)
#define SV_TIMESOURCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_TIMESOURCE_PARMNUM)
#define SV_LMANNOUNCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_LMANNOUNCE_PARMNUM)
#define SV_MAXCOPYREADLEN_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYREADLEN_PARMNUM)
#define SV_MAXCOPYWRITELEN_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYWRITELEN_PARMNUM)
#define SV_MINKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPSEARCH_PARMNUM)
#define SV_MAXKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPSEARCH_PARMNUM)
#define SV_MINKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPCOMPLSEARCH_PARMNUM)
#define SV_MAXKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPCOMPLSEARCH_PARMNUM)
#define SV_SCAVTIMEOUT_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVTIMEOUT_PARMNUM)
#define SV_MINRCVQUEUE_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_MINRCVQUEUE_PARMNUM)
#define SV_MINFREEWORKITEMS_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREEWORKITEMS_PARMNUM)
#define SV_MAXMPXCT_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXMPXCT_PARMNUM)
#define SV_OPLOCKBREAKWAIT_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKWAIT_PARMNUM)
#define SV_OPLOCKBREAKRESPONSEWAIT_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM)
#define SV_ENABLEOPLOCKS_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKS_PARMNUM)
#define SV_ENABLEOPLOCKFORCECLOSE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKFORCECLOSE_PARMNUM)
#define SV_ENABLEFCBOPENS_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFCBOPENS_PARMNUM)
#define SV_ENABLERAW_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLERAW_PARMNUM)
#define SV_ENABLESHAREDNETDRIVES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESHAREDNETDRIVES_PARMNUM)
#define SV_MINFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREECONNECTIONS_PARMNUM)
#define SV_MAXFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREECONNECTIONS_PARMNUM)
#define SV_INITSESSTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSESSTABLE_PARMNUM)
#define SV_INITCONNTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITCONNTABLE_PARMNUM)
#define SV_INITFILETABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITFILETABLE_PARMNUM)
#define SV_INITSEARCHTABLE_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSEARCHTABLE_PARMNUM)
#define SV_ALERTSCHEDULE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ALERTSCHEDULE_PARMNUM)
#define SV_ERRORTHRESHOLD_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ERRORTHRESHOLD_PARMNUM)
#define SV_NETWORKERRORTHRESHOLD_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_NETWORKERRORTHRESHOLD_PARMNUM)
#define SV_DISKSPACETHRESHOLD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_DISKSPACETHRESHOLD_PARMNUM)
#define SV_MAXLINKDELAY_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXLINKDELAY_PARMNUM)
#define SV_MINLINKTHROUGHPUT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_MINLINKTHROUGHPUT_PARMNUM)
#define SV_LINKINFOVALIDTIME_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_LINKINFOVALIDTIME_PARMNUM)
#define SV_SCAVQOSINFOUPDATETIME_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVQOSINFOUPDATETIME_PARMNUM)
#define SV_MAXWORKITEMIDLETIME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMIDLETIME_PARMNUM)
#define SV_MAXRAWWORKITEMS_INFOLOEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWWORKITEMS_PARMNUM)
#define SV_PRODUCTTYPE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_PRODUCTTYPE_PARMNUM)
#define SV_SERVERSIZE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SERVERSIZE_PARMNUM)
#define SV_CONNECTIONLESSAUTODISC_INFOLOEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONLESSAUTODISC_PARMNUM)
#define SV_SHARINGVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONRETRIES_PARMNUM)
#define SV_SHARINGVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONDELAY_PARMNUM)
#define SV_MAXGLOBALOPENSEARCH_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXGLOBALOPENSEARCH_PARMNUM)
#define SV_REMOVEDUPLICATESEARCHES_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_REMOVEDUPLICATESEARCHES_PARMNUM)
#define SV_LOCKVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONRETRIES_PARMNUM)
#define SV_LOCKVIOLATIONOFFSET_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONOFFSET_PARMNUM)
#define SV_LOCKVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONDELAY_PARMNUM)
#define SV_MDLREADSWITCHOVER_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MDLREADSWITCHOVER_PARMNUM)
#define SV_CACHEDOPENLIMIT_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CACHEDOPENLIMIT_PARMNUM)
#define SV_CRITICALTHREADS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_CRITICALTHREADS_PARMNUM)
#define SV_RESTRICTNULLSESSACCESS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_RESTRICTNULLSESSACCESS_PARMNUM)
#define SV_ENABLEWFW311DIRECTIPX_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEWFW311DIRECTIPX_PARMNUM)
#define SV_OTHERQUEUEAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_OTHERQUEUEAFFINITY_PARMNUM)
#define SV_QUEUESAMPLESECS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_QUEUESAMPLESECS_PARMNUM)
#define SV_BALANCECOUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_BALANCECOUNT_PARMNUM)
#define SV_PREFERREDAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_PREFERREDAFFINITY_PARMNUM)
#define SV_MAXFREERFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREERFCBS_PARMNUM)
#define SV_MAXFREEMFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEMFCBS_PARMNUM)
#define SV_MAXFREELFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREELFCBS_PARMNUM)
#define SV_MAXFREEPAGEDPOOLCHUNKS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM)
#define SV_MINPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_MAXPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_SENDSFROMPREFERREDPROCESSOR_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM)
#define SV_MAXTHREADSPERQUEUE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXTHREADSPERQUEUE_PARMNUM)
#define SV_CACHEDDIRECTORYLIMIT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CACHEDDIRECTORYLIMIT_PARMNUM)
#define SV_MAXCOPYLENGTH_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYLENGTH_PARMNUM)
#define SV_ENABLECOMPRESSION_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLECOMPRESSION_PARMNUM)
#define SV_AUTOSHAREWKS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_AUTOSHAREWKS_PARMNUM)
#define SV_AUTOSHARESERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_AUTOSHARESERVER_PARMNUM)
#define SV_ENABLESECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESECURITYSIGNATURE_PARMNUM)
#define SV_REQUIRESECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_REQUIRESECURITYSIGNATURE_PARMNUM)
#define SV_MINCLIENTBUFFERSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MINCLIENTBUFFERSIZE_PARMNUM)
#define SV_CONNECTIONNOSESSIONSTIMEOUT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONNOSESSIONSTIMEOUT_PARMNUM)
#define SV_IDLETHREADTIMEOUT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_IDLETHREADTIMEOUT_PARMNUM)
#define SV_ENABLEW9XSECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEW9XSECURITYSIGNATURE_PARMNUM)
#define SV_ENFORCEKERBEROSREAUTHENTICATION_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_ENFORCEKERBEROSREAUTHENTICATION_PARMNUM)
#define SV_DISABLEDOS_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_DISABLEDOS_PARMNUM)
#define SV_LOWDISKSPACEMINIMUM_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_LOWDISKSPACEMINIMUM_PARMNUM)
#define SV_DISABLESTRICTNAMECHECKING_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_DISABLESTRICTNAMECHECKING_PARMNUM)
#define SV_ENABLEAUTHENTICATEUSERSHARING_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEAUTHENTICATEUSERSHARING_PARMNUM)

#define SVI1_NUM_ELEMENTS       5
#define SVI2_NUM_ELEMENTS       40
#define SVI3_NUM_ELEMENTS       44

//
//      Maxmimum length for command string to NetServerAdminCommand.
//

#define SV_MAX_CMD_LEN          PATHLEN

//
//      Masks describing AUTOPROFILE parameters
//

#define SW_AUTOPROF_LOAD_MASK   0x1
#define SW_AUTOPROF_SAVE_MASK   0x2

//
//      Max size of svX_srvheuristics.
//

#define SV_MAX_SRV_HEUR_LEN     32      // Max heuristics info string length.

//
//      Equate for use with sv102_licenses.
//

#define SV_USERS_PER_LICENSE    5

//
// Equate for use with svti2_flags in NetServerTransportAddEx.
//

#define SVTI2_REMAP_PIPE_NAMES  0x2
#define SVTI2_SCOPED_NAME       0x4
#define SVTI2_VALID_FLAGS (SVTI2_REMAP_PIPE_NAMES|SVTI2_SCOPED_NAME)

//
// Server capability information
//

#define SRV_SUPPORT_HASH_GENERATION       0x0001
#define SRV_HASH_GENERATION_ACTIVE        0x0002

#ifdef __cplusplus
}
#endif

#endif // _LMSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMSvc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmsvc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetService API.

[Environment:]

    User Mode -Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSVC_
#define _LMSVC_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Include the file which contains all the service name strings.
//
#include <lmsname.h>

//
//  Data Structures
//

typedef struct _SERVICE_INFO_0 {
    LPWSTR  svci0_name;
} SERVICE_INFO_0, *PSERVICE_INFO_0, * LPSERVICE_INFO_0;

typedef struct _SERVICE_INFO_1 {
    LPWSTR  svci1_name;
    DWORD   svci1_status;
    DWORD   svci1_code;
    DWORD   svci1_pid;
} SERVICE_INFO_1, *PSERVICE_INFO_1, * LPSERVICE_INFO_1;

typedef struct _SERVICE_INFO_2 {
    LPWSTR  svci2_name;
    DWORD   svci2_status;
    DWORD   svci2_code;
    DWORD   svci2_pid;
    LPWSTR  svci2_text;
    DWORD   svci2_specific_error;
    LPWSTR  svci2_display_name;
} SERVICE_INFO_2, *PSERVICE_INFO_2, * LPSERVICE_INFO_2;

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetServiceControl (
    __in_opt    LPCWSTR servername,
    __in        LPCWSTR service,
    __in        DWORD   opcode,
    __in        DWORD   arg,
    __deref_out LPBYTE *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceEnum (
    __in_opt    LPCWSTR  servername,
    __in        DWORD    level,
    __deref_out LPBYTE  *bufptr,
    __in        DWORD    prefmaxlen,
    __out       LPDWORD  entriesread,
    __out       LPDWORD  totalentries,
    __inout_opt LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceGetInfo (
    __in_opt    LPCWSTR  servername,
    __in        LPCWSTR  service,
    __in        DWORD    level,
    __deref_out LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceInstall (
    __in_opt          LPCWSTR  servername,
    __in              LPCWSTR  service,
    __in              DWORD    argc,
    __in_ecount(argc) LPCWSTR  argv[],
    __deref_out       LPBYTE  *bufptr
    );

//
// Special Values and Constants
//

//
//  Bitmask and bit values for svci1_status, and svci2_status
//  fields.  For each "subfield", there is a mask defined,
//  and a number of constants representing the value
//  obtained by doing (status & mask).
//

// Bits 0,1 -- general status

#define SERVICE_INSTALL_STATE       0x03
#define SERVICE_UNINSTALLED         0x00
#define SERVICE_INSTALL_PENDING     0x01
#define SERVICE_UNINSTALL_PENDING   0x02
#define SERVICE_INSTALLED           0x03

// Bits 2,3 -- paused/active status

#define SERVICE_PAUSE_STATE              0x0C
#define LM20_SERVICE_ACTIVE              0x00
#define LM20_SERVICE_CONTINUE_PENDING    0x04
#define LM20_SERVICE_PAUSE_PENDING       0x08
#define LM20_SERVICE_PAUSED              0x0C

// Bit 4 -- uninstallable indication

#define SERVICE_NOT_UNINSTALLABLE   0x00
#define SERVICE_UNINSTALLABLE       0x10

// Bit 5 -- pausable indication

#define SERVICE_NOT_PAUSABLE        0x00
#define SERVICE_PAUSABLE            0x20

// Workstation service only:
// Bits 8,9,10 -- redirection paused/active

#define SERVICE_REDIR_PAUSED        0x700
#define SERVICE_REDIR_DISK_PAUSED   0x100
#define SERVICE_REDIR_PRINT_PAUSED  0x200
#define SERVICE_REDIR_COMM_PAUSED   0x400

//
//  Additional standard LAN Manager for MS-DOS services
//

#define SERVICE_DOS_ENCRYPTION  L"ENCRYPT"

//
//  NetServiceControl opcodes.
//

#define SERVICE_CTRL_INTERROGATE    0
#define SERVICE_CTRL_PAUSE          1
#define SERVICE_CTRL_CONTINUE       2
#define SERVICE_CTRL_UNINSTALL      3

//
//  Workstation service only:  Bits used in the "arg" parameter
//  to NetServiceControl in conjunction with the opcode
//  SERVICE_CTRL_PAUSE or SERVICE_CTRL_CONTINUE, to pause or
//  continue redirection.
//

#define SERVICE_CTRL_REDIR_DISK     0x1
#define SERVICE_CTRL_REDIR_PRINT    0x2
#define SERVICE_CTRL_REDIR_COMM     0x4

//
//  Values for svci1_code, and svci2_code when status
//  of the service is SERVICE_INSTALL_PENDING or
//  SERVICE_UNINSTALL_PENDING.
//  A service can optionally provide a hint to the installer
//  that the install is proceeding and how long to wait
//  (in 0.1 second increments) before querying status again.
//

#define SERVICE_IP_NO_HINT          0x0
#define SERVICE_CCP_NO_HINT         0x0

#define SERVICE_IP_QUERY_HINT       0x10000
#define SERVICE_CCP_QUERY_HINT      0x10000

//
// Mask for install proceeding checkpoint number
//

#define SERVICE_IP_CHKPT_NUM        0x0FF
#define SERVICE_CCP_CHKPT_NUM       0x0FF

//
// Mask for wait time hint before querying again
//

#define SERVICE_IP_WAIT_TIME        0x0FF00
#define SERVICE_CCP_WAIT_TIME       0x0FF00

//
// Shift count for building wait time _code values
//

#define SERVICE_IP_WAITTIME_SHIFT   8
#define SERVICE_NTIP_WAITTIME_SHIFT 12

//
// Mask used for upper and lower portions of wait hint time.
//
#define UPPER_HINT_MASK     0x0000FF00
#define LOWER_HINT_MASK     0x000000FF
#define UPPER_GET_HINT_MASK 0x0FF00000
#define LOWER_GET_HINT_MASK 0x0000FF00
#define SERVICE_NT_MAXTIME  0x0000FFFF
#define SERVICE_RESRV_MASK  0x0001FFFF
#define SERVICE_MAXTIME     0x000000FF

//
//  SERVICE_BASE is the base of service error codes,
//  chosen to avoid conflict with OS, redirector,
//  netapi, and errlog codes.
//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define SERVICE_BASE                3050
#define SERVICE_UIC_NORMAL          0
/*
 *  Uninstall codes, to be used in high byte of 'code' on final NetStatus,
 *  which sets the status to UNINSTALLED.
 */

#define SERVICE_UIC_BADPARMVAL          (SERVICE_BASE + 1)
/*
 * The Registry or the information you just typed includes an illegal
 * value for "%1".
 */

#define SERVICE_UIC_MISSPARM            (SERVICE_BASE + 2)
/*
 * The required parameter was not provided on the command
 * line or in the configuration file.
 */

#define SERVICE_UIC_UNKPARM             (SERVICE_BASE + 3)
/*
 * LAN Manager does not recognize "%1" as a valid option.
 */

#define SERVICE_UIC_RESOURCE            (SERVICE_BASE + 4)
/*
 * A request for resource could not be satisfied.
 */

#define SERVICE_UIC_CONFIG              (SERVICE_BASE + 5)
/*
 * A problem exists with the system configuration.
 */

#define SERVICE_UIC_SYSTEM              (SERVICE_BASE + 6)
/*
 * A system error has occurred.
 */

#define SERVICE_UIC_INTERNAL            (SERVICE_BASE + 7)
/*
 * An internal consistency error has occurred.
 */

#define SERVICE_UIC_AMBIGPARM           (SERVICE_BASE + 8)
/*
 * The configuration file or the command line has an ambiguous option.
 */

#define SERVICE_UIC_DUPPARM             (SERVICE_BASE + 9)
/*
 * The configuration file or the command line has a duplicate parameter.
 */

#define SERVICE_UIC_KILL                (SERVICE_BASE + 10)
/*
 * The service did not respond to control and was stopped with
 * the DosKillProc function.
 */

#define SERVICE_UIC_EXEC                (SERVICE_BASE + 11)
/*
 * An error occurred when attempting to run the service program.
 */

#define SERVICE_UIC_SUBSERV             (SERVICE_BASE + 12)
/*
 * The sub-service failed to start.
 */

#define SERVICE_UIC_CONFLPARM           (SERVICE_BASE + 13)
/*
 * There is a conflict in the value or use of these options: %1.
 */

#define SERVICE_UIC_FILE                (SERVICE_BASE + 14)
/*
 * There is a problem with the file.
 */



//
//  The modifiers
//

//
// General:
//

#define SERVICE_UIC_M_NULL  0

//
//  RESOURCE:
//

#define SERVICE_UIC_M_MEMORY    (SERVICE_BASE + 20)     /* memory */
#define SERVICE_UIC_M_DISK      (SERVICE_BASE + 21)     /* disk space */
#define SERVICE_UIC_M_THREADS   (SERVICE_BASE + 22)     /* thread */
#define SERVICE_UIC_M_PROCESSES (SERVICE_BASE + 23)     /* process */

//
//  CONFIG:
//

//
// Security failure
//

#define SERVICE_UIC_M_SECURITY          (SERVICE_BASE + 24)
/* Security Failure. %0 */

#define SERVICE_UIC_M_LANROOT           (SERVICE_BASE + 25)
/*
 * Bad or missing LAN Manager root directory.
 */

#define SERVICE_UIC_M_REDIR             (SERVICE_BASE + 26)
/*
 * The network software is not installed.
 */

#define SERVICE_UIC_M_SERVER            (SERVICE_BASE + 27)
/*
 * The server is not started.
 */

#define SERVICE_UIC_M_SEC_FILE_ERR      (SERVICE_BASE + 28)
/*
 * The server cannot access the user accounts database (NET.ACC).
 */

#define SERVICE_UIC_M_FILES             (SERVICE_BASE + 29)
/*
 * Incompatible files are installed in the LANMAN tree.
 */

#define SERVICE_UIC_M_LOGS              (SERVICE_BASE + 30)
/*
 * The LANMAN\LOGS directory is invalid.
 */

#define SERVICE_UIC_M_LANGROUP          (SERVICE_BASE + 31)
/*
 * The domain specified could not be used.
 */

#define SERVICE_UIC_M_MSGNAME           (SERVICE_BASE + 32)
/*
 * The computer name is being used as a message alias on another computer.
 */

#define SERVICE_UIC_M_ANNOUNCE          (SERVICE_BASE + 33)
/*
 * The announcement of the server name failed.
 */

#define SERVICE_UIC_M_UAS               (SERVICE_BASE + 34)
/*
 * The user accounts database is not configured correctly.
 */

#define SERVICE_UIC_M_SERVER_SEC_ERR    (SERVICE_BASE + 35)
/*
 * The server is not running with user-level security.
 */

#define SERVICE_UIC_M_WKSTA             (SERVICE_BASE + 37)
/*
 * The workstation is not configured properly.
 */

#define SERVICE_UIC_M_ERRLOG            (SERVICE_BASE + 38)
/*
 * View your error log for details.
 */

#define SERVICE_UIC_M_FILE_UW           (SERVICE_BASE + 39)
/*
 * Unable to write to this file.
 */

#define SERVICE_UIC_M_ADDPAK            (SERVICE_BASE + 40)
/*
 * ADDPAK file is corrupted.  Delete LANMAN\NETPROG\ADDPAK.SER
 * and reapply all ADDPAKs.
 */

#define SERVICE_UIC_M_LAZY              (SERVICE_BASE + 41)
/*
 * The LM386 server cannot be started because CACHE.EXE is not running.
 */

#define SERVICE_UIC_M_UAS_MACHINE_ACCT  (SERVICE_BASE + 42)
/*
 * There is no account for this computer in the security database.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NMEMB (SERVICE_BASE + 43)
/*
 * This computer is not a member of the group SERVERS.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NOGRP (SERVICE_BASE + 44)
/*
 * The group SERVERS is not present in the local security database.
 */

#define SERVICE_UIC_M_UAS_INVALID_ROLE  (SERVICE_BASE + 45)
/*
 * This computer is configured as a member of a workgroup, not as
 * a member of a domain. The Netlogon service does not need to run in this
 * configuration.
 */

#define SERVICE_UIC_M_NETLOGON_NO_DC    (SERVICE_BASE + 46)
/*
 * The primary Domain Controller for this domain could not be located.
 */

#define SERVICE_UIC_M_NETLOGON_DC_CFLCT (SERVICE_BASE + 47)
/*
 * This computer is configured to be the primary domain controller of its domain.
 * However, the computer %1 is currently claiming to be the primary domain controller
 * of the domain.
 */

#define SERVICE_UIC_M_NETLOGON_AUTH     (SERVICE_BASE + 48)
/*
 * The service failed to authenticate with the primary domain controller.
 */

#define SERVICE_UIC_M_UAS_PROLOG        (SERVICE_BASE + 49)
/*
 * There is a problem with the security database creation date or serial number.
 */


#define SERVICE2_BASE    5600
/* new SEVICE_UIC messages go here */

#define SERVICE_UIC_M_NETLOGON_MPATH    (SERVICE2_BASE + 0)
/*
 * Could not share the User or Script path.
 */

#define SERVICE_UIC_M_LSA_MACHINE_ACCT  (SERVICE2_BASE + 1)
/*
 * The password for this computer is not found in the local security
 * database.
 */

#define SERVICE_UIC_M_DATABASE_ERROR    (SERVICE2_BASE + 2)
/*
 * An internal error occurred while accessing the computer's
 * local or network security database.
 */


//
//  End modifiers
//

//
// Commonly used Macros:
//

#define SERVICE_IP_CODE(tt,nn) \
  ((long)SERVICE_IP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_CCP_CODE(tt,nn) \
  ((long)SERVICE_CCP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_UIC_CODE(cc,mm) \
  ((long)(((long)cc<<16)|(long)(unsigned short)mm))

//
// This macro takes a wait hint (tt) which can have a maximum value of
// 0xFFFF and puts it into the service status code field.
// 0x0FF1FFnn  (where nn is the checkpoint information).
//
#define SERVICE_NT_CCP_CODE(tt,nn)  \
  (  \
    ((long)SERVICE_CCP_QUERY_HINT)   | \
    ((long)(nn))   | \
    (((tt)&LOWER_HINT_MASK) << SERVICE_IP_WAITTIME_SHIFT)   | \
    (((tt)&UPPER_HINT_MASK) << SERVICE_NTIP_WAITTIME_SHIFT)   \
  )

//
// This macro takes a status code field, and strips out the wait hint
// from the upper and lower sections.
// 0x0FF1FFnn results in 0x0000FFFF.
//
#define SERVICE_NT_WAIT_GET(code) \
    (   \
      (((code) & UPPER_GET_HINT_MASK) >> SERVICE_NTIP_WAITTIME_SHIFT)  |  \
      (((code) & LOWER_GET_HINT_MASK) >> SERVICE_IP_WAITTIME_SHIFT)  \
    )

#ifdef __cplusplus
}
#endif

#endif // _LMSVC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\lowlevelmonitorconfigurationapi.h ===
#ifndef LowLevelMonitorConfigurationAPI_h
#define LowLevelMonitorConfigurationAPI_h

#include <PhysicalMonitorEnumerationAPI.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus 

#pragma pack( push, 1  )

typedef struct _MC_TIMING_REPORT
{
    DWORD dwHorizontalFrequencyInHZ;
    DWORD dwVerticalFrequencyInHZ;
    BYTE bTimingStatusByte;

} MC_TIMING_REPORT, *LPMC_TIMING_REPORT;

typedef enum _MC_VCP_CODE_TYPE
{
    MC_MOMENTARY,
    MC_SET_PARAMETER

} MC_VCP_CODE_TYPE, *LPMC_VCP_CODE_TYPE;

_BOOL WINAPI GetVCPFeatureAndVCPFeatureReply
    (
    HANDLE hMonitor,
    BYTE bVCPCode,
    __out_opt LPMC_VCP_CODE_TYPE pvct,
    __out LPDWORD pdwCurrentValue, 
    __out_opt LPDWORD pdwMaximumValue
    );

_BOOL WINAPI SetVCPFeature( HANDLE hMonitor, BYTE bVCPCode, DWORD dwNewValue );

_BOOL WINAPI SaveCurrentSettings( HANDLE hMonitor );

_BOOL WINAPI GetCapabilitiesStringLength( HANDLE hMonitor, __out LPDWORD pdwCapabilitiesStringLengthInCharacters );

_BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply 
    (
    HANDLE hMonitor, 
    __out_ecount(dwCapabilitiesStringLengthInCharacters) LPSTR pszASCIICapabilitiesString, 
    DWORD dwCapabilitiesStringLengthInCharacters
    );

_BOOL WINAPI GetTimingReport( HANDLE hMonitor, __out LPMC_TIMING_REPORT pmtrMonitorTimingReport );

#pragma pack( pop )

#ifdef __cplusplus
}
#endif // __cplusplus 

#endif // LowLevelMonitorConfigurationAPI_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMWksta.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmwksta.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetWorkstation and NetWkstaTransport API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMWKSTA_
#define _LMWKSTA_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __deref_opt_out_xcount("size varies with level") OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buffer,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    __out_opt OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd (
    __in_opt LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __in LPBYTE  buf,
    __out_opt LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel (
    __in_opt IN  LMSTR   servername OPTIONAL,
    __in_opt IN  LMSTR   transportname,
    IN  DWORD   ucond
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

//
//  Data Structures
//

//
// NetWkstaGetInfo and NetWkstaSetInfo
//

//
// NetWkstaGetInfo only.  System information - guest access
//
typedef struct _WKSTA_INFO_100 {
    DWORD   wki100_platform_id;
    LMSTR   wki100_computername;
    LMSTR   wki100_langroup;
    DWORD   wki100_ver_major;
    DWORD   wki100_ver_minor;
}WKSTA_INFO_100, *PWKSTA_INFO_100, *LPWKSTA_INFO_100;

//
// NetWkstaGetInfo only.  System information - user access
//
typedef struct _WKSTA_INFO_101 {
    DWORD   wki101_platform_id;
    LMSTR   wki101_computername;
    LMSTR   wki101_langroup;
    DWORD   wki101_ver_major;
    DWORD   wki101_ver_minor;
    LMSTR   wki101_lanroot;
}WKSTA_INFO_101, *PWKSTA_INFO_101, *LPWKSTA_INFO_101;

//
// NetWkstaGetInfo only.  System information - admin or operator access
//
typedef struct _WKSTA_INFO_102 {
    DWORD   wki102_platform_id;
    LMSTR   wki102_computername;
    LMSTR   wki102_langroup;
    DWORD   wki102_ver_major;
    DWORD   wki102_ver_minor;
    LMSTR   wki102_lanroot;
    DWORD   wki102_logged_on_users;
}WKSTA_INFO_102, *PWKSTA_INFO_102, *LPWKSTA_INFO_102;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// DOS specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_302{
    DWORD   wki302_char_wait;
    DWORD   wki302_collection_time;
    DWORD   wki302_maximum_collection_count;
    DWORD   wki302_keep_conn;
    DWORD   wki302_keep_search;
    DWORD   wki302_max_cmds;
    DWORD   wki302_num_work_buf;
    DWORD   wki302_siz_work_buf;
    DWORD   wki302_max_wrk_cache;
    DWORD   wki302_sess_timeout;
    DWORD   wki302_siz_error;
    DWORD   wki302_num_alerts;
    DWORD   wki302_num_services;
    DWORD   wki302_errlog_sz;
    DWORD   wki302_print_buf_time;
    DWORD   wki302_num_char_buf;
    DWORD   wki302_siz_char_buf;
    LMSTR   wki302_wrk_heuristics;
    DWORD   wki302_mailslots;
    DWORD   wki302_num_dgram_buf;
}WKSTA_INFO_302, *PWKSTA_INFO_302, *LPWKSTA_INFO_302;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo
//
// OS/2 specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_402{
    DWORD   wki402_char_wait;
    DWORD   wki402_collection_time;
    DWORD   wki402_maximum_collection_count;
    DWORD   wki402_keep_conn;
    DWORD   wki402_keep_search;
    DWORD   wki402_max_cmds;
    DWORD   wki402_num_work_buf;
    DWORD   wki402_siz_work_buf;
    DWORD   wki402_max_wrk_cache;
    DWORD   wki402_sess_timeout;
    DWORD   wki402_siz_error;
    DWORD   wki402_num_alerts;
    DWORD   wki402_num_services;
    DWORD   wki402_errlog_sz;
    DWORD   wki402_print_buf_time;
    DWORD   wki402_num_char_buf;
    DWORD   wki402_siz_char_buf;
    LMSTR   wki402_wrk_heuristics;
    DWORD   wki402_mailslots;
    DWORD   wki402_num_dgram_buf;
    DWORD   wki402_max_threads;
}WKSTA_INFO_402, *PWKSTA_INFO_402, *LPWKSTA_INFO_402;

//
// Same-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// NT specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_502{
    DWORD   wki502_char_wait;
    DWORD   wki502_collection_time;
    DWORD   wki502_maximum_collection_count;
    DWORD   wki502_keep_conn;
    DWORD   wki502_max_cmds;
    DWORD   wki502_sess_timeout;
    DWORD   wki502_siz_char_buf;
    DWORD   wki502_max_threads;

    DWORD   wki502_lock_quota;
    DWORD   wki502_lock_increment;
    DWORD   wki502_lock_maximum;
    DWORD   wki502_pipe_increment;
    DWORD   wki502_pipe_maximum;
    DWORD   wki502_cache_file_timeout;
    DWORD   wki502_dormant_file_limit;
    DWORD   wki502_read_ahead_throughput;

    DWORD   wki502_num_mailslot_buffers;
    DWORD   wki502_num_srv_announce_buffers;
    DWORD   wki502_max_illegal_datagram_events;
    DWORD   wki502_illegal_datagram_event_reset_frequency;
    BOOL    wki502_log_election_packets;

    BOOL    wki502_use_opportunistic_locking;
    BOOL    wki502_use_unlock_behind;
    BOOL    wki502_use_close_behind;
    BOOL    wki502_buf_named_pipes;
    BOOL    wki502_use_lock_read_unlock;
    BOOL    wki502_utilize_nt_caching;
    BOOL    wki502_use_raw_read;
    BOOL    wki502_use_raw_write;
    BOOL    wki502_use_write_raw_data;
    BOOL    wki502_use_encryption;
    BOOL    wki502_buf_files_deny_write;
    BOOL    wki502_buf_read_only_files;
    BOOL    wki502_force_core_create_mode;
    BOOL    wki502_use_512_byte_max_transfer;
}WKSTA_INFO_502, *PWKSTA_INFO_502, *LPWKSTA_INFO_502;


//
// The following info-levels are only valid for NetWkstaSetInfo
//

//
// The following levels are supported on down-level systems (LAN Man 2.x)
// as well as NT systems:
//
typedef struct _WKSTA_INFO_1010 {
     DWORD  wki1010_char_wait;
} WKSTA_INFO_1010, *PWKSTA_INFO_1010, *LPWKSTA_INFO_1010;

typedef struct _WKSTA_INFO_1011 {
     DWORD  wki1011_collection_time;
} WKSTA_INFO_1011, *PWKSTA_INFO_1011, *LPWKSTA_INFO_1011;

typedef struct _WKSTA_INFO_1012 {
     DWORD  wki1012_maximum_collection_count;
} WKSTA_INFO_1012, *PWKSTA_INFO_1012, *LPWKSTA_INFO_1012;

//
// The following level are supported on down-level systems (LAN Man 2.x)
// only:
//
typedef struct _WKSTA_INFO_1027 {
     DWORD  wki1027_errlog_sz;
} WKSTA_INFO_1027, *PWKSTA_INFO_1027, *LPWKSTA_INFO_1027;

typedef struct _WKSTA_INFO_1028 {
     DWORD  wki1028_print_buf_time;
} WKSTA_INFO_1028, *PWKSTA_INFO_1028, *LPWKSTA_INFO_1028;

typedef struct _WKSTA_INFO_1032 {
     DWORD  wki1032_wrk_heuristics;
} WKSTA_INFO_1032, *PWKSTA_INFO_1032, *LPWKSTA_INFO_1032;

//
// The following levels are settable on NT systems, and have no
// effect on down-level systems (i.e. LANMan 2.x) since these
// fields cannot be set on them:
//
typedef struct _WKSTA_INFO_1013 {
     DWORD  wki1013_keep_conn;
} WKSTA_INFO_1013, *PWKSTA_INFO_1013, *LPWKSTA_INFO_1013;

typedef struct _WKSTA_INFO_1018 {
     DWORD  wki1018_sess_timeout;
} WKSTA_INFO_1018, *PWKSTA_INFO_1018, *LPWKSTA_INFO_1018;

typedef struct _WKSTA_INFO_1023 {
     DWORD  wki1023_siz_char_buf;
} WKSTA_INFO_1023, *PWKSTA_INFO_1023, *LPWKSTA_INFO_1023;

typedef struct _WKSTA_INFO_1033 {
     DWORD  wki1033_max_threads;
} WKSTA_INFO_1033, *PWKSTA_INFO_1033, *LPWKSTA_INFO_1033;

//
// The following levels are only supported on NT systems:
//
typedef struct _WKSTA_INFO_1041 {
    DWORD   wki1041_lock_quota;
} WKSTA_INFO_1041, *PWKSTA_INFO_1041, *LPWKSTA_INFO_1041;

typedef struct _WKSTA_INFO_1042 {
    DWORD   wki1042_lock_increment;
} WKSTA_INFO_1042, *PWKSTA_INFO_1042, *LPWKSTA_INFO_1042;

typedef struct _WKSTA_INFO_1043 {
    DWORD   wki1043_lock_maximum;
} WKSTA_INFO_1043, *PWKSTA_INFO_1043, *LPWKSTA_INFO_1043;

typedef struct _WKSTA_INFO_1044 {
    DWORD   wki1044_pipe_increment;
} WKSTA_INFO_1044, *PWKSTA_INFO_1044, *LPWKSTA_INFO_1044;

typedef struct _WKSTA_INFO_1045 {
    DWORD   wki1045_pipe_maximum;
} WKSTA_INFO_1045, *PWKSTA_INFO_1045, *LPWKSTA_INFO_1045;

typedef struct _WKSTA_INFO_1046 {
    DWORD   wki1046_dormant_file_limit;
} WKSTA_INFO_1046, *PWKSTA_INFO_1046, *LPWKSTA_INFO_1046;

typedef struct _WKSTA_INFO_1047 {
    DWORD    wki1047_cache_file_timeout;
} WKSTA_INFO_1047, *PWKSTA_INFO_1047, *LPWKSTA_INFO_1047;

typedef struct _WKSTA_INFO_1048 {
    BOOL     wki1048_use_opportunistic_locking;
} WKSTA_INFO_1048, *PWKSTA_INFO_1048, *LPWKSTA_INFO_1048;

typedef struct _WKSTA_INFO_1049 {
    BOOL     wki1049_use_unlock_behind;
} WKSTA_INFO_1049, *PWKSTA_INFO_1049, *LPWKSTA_INFO_1049;

typedef struct _WKSTA_INFO_1050 {
    BOOL     wki1050_use_close_behind;
} WKSTA_INFO_1050, *PWKSTA_INFO_1050, *LPWKSTA_INFO_1050;

typedef struct _WKSTA_INFO_1051 {
    BOOL     wki1051_buf_named_pipes;
} WKSTA_INFO_1051, *PWKSTA_INFO_1051, *LPWKSTA_INFO_1051;

typedef struct _WKSTA_INFO_1052 {
    BOOL     wki1052_use_lock_read_unlock;
} WKSTA_INFO_1052, *PWKSTA_INFO_1052, *LPWKSTA_INFO_1052;

typedef struct _WKSTA_INFO_1053 {
    BOOL     wki1053_utilize_nt_caching;
} WKSTA_INFO_1053, *PWKSTA_INFO_1053, *LPWKSTA_INFO_1053;

typedef struct _WKSTA_INFO_1054 {
    BOOL     wki1054_use_raw_read;
} WKSTA_INFO_1054, *PWKSTA_INFO_1054, *LPWKSTA_INFO_1054;

typedef struct _WKSTA_INFO_1055 {
    BOOL     wki1055_use_raw_write;
} WKSTA_INFO_1055, *PWKSTA_INFO_1055, *LPWKSTA_INFO_1055;

typedef struct _WKSTA_INFO_1056 {
    BOOL     wki1056_use_write_raw_data;
} WKSTA_INFO_1056, *PWKSTA_INFO_1056, *LPWKSTA_INFO_1056;

typedef struct _WKSTA_INFO_1057 {
    BOOL     wki1057_use_encryption;
} WKSTA_INFO_1057, *PWKSTA_INFO_1057, *LPWKSTA_INFO_1057;

typedef struct _WKSTA_INFO_1058 {
    BOOL     wki1058_buf_files_deny_write;
} WKSTA_INFO_1058, *PWKSTA_INFO_1058, *LPWKSTA_INFO_1058;

typedef struct _WKSTA_INFO_1059 {
    BOOL     wki1059_buf_read_only_files;
} WKSTA_INFO_1059, *PWKSTA_INFO_1059, *LPWKSTA_INFO_1059;

typedef struct _WKSTA_INFO_1060 {
    BOOL     wki1060_force_core_create_mode;
} WKSTA_INFO_1060, *PWKSTA_INFO_1060, *LPWKSTA_INFO_1060;

typedef struct _WKSTA_INFO_1061 {
    BOOL     wki1061_use_512_byte_max_transfer;
} WKSTA_INFO_1061, *PWKSTA_INFO_1061, *LPWKSTA_INFO_1061;

typedef struct _WKSTA_INFO_1062 {
    DWORD   wki1062_read_ahead_throughput;
} WKSTA_INFO_1062, *PWKSTA_INFO_1062, *LPWKSTA_INFO_1062;


//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_0 {
    LMSTR   wkui0_username;
}WKSTA_USER_INFO_0, *PWKSTA_USER_INFO_0, *LPWKSTA_USER_INFO_0;

//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_1 {
    LMSTR   wkui1_username;
    LMSTR   wkui1_logon_domain;
    LMSTR   wkui1_oth_domains;
    LMSTR   wkui1_logon_server;
}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;

//
// NetWkstaUserSetInfo - local access.
//
typedef struct _WKSTA_USER_INFO_1101 {
     LMSTR   wkui1101_oth_domains;
} WKSTA_USER_INFO_1101, *PWKSTA_USER_INFO_1101,
  *LPWKSTA_USER_INFO_1101;


//
// NetWkstaTransportAdd - admin access
//
typedef struct _WKSTA_TRANSPORT_INFO_0 {
    DWORD   wkti0_quality_of_service;
    DWORD   wkti0_number_of_vcs;
    LMSTR   wkti0_transport_name;
    LMSTR   wkti0_transport_address;
    BOOL    wkti0_wan_ish;
}WKSTA_TRANSPORT_INFO_0, *PWKSTA_TRANSPORT_INFO_0,
 *LPWKSTA_TRANSPORT_INFO_0;


//
// Special Values and Constants
//

//
//  Identifiers for use as NetWkstaSetInfo parmnum parameter
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaSetInfo.
//

#define WKSTA_PLATFORM_ID_PARMNUM               100
#define WKSTA_COMPUTERNAME_PARMNUM              1
#define WKSTA_LANGROUP_PARMNUM                  2
#define WKSTA_VER_MAJOR_PARMNUM                 4
#define WKSTA_VER_MINOR_PARMNUM                 5
#define WKSTA_LOGGED_ON_USERS_PARMNUM           6
#define WKSTA_LANROOT_PARMNUM                   7
#define WKSTA_LOGON_DOMAIN_PARMNUM              8
#define WKSTA_LOGON_SERVER_PARMNUM              9
#define WKSTA_CHARWAIT_PARMNUM                  10  // Supported by down-level.
#define WKSTA_CHARTIME_PARMNUM                  11  // Supported by down-level.
#define WKSTA_CHARCOUNT_PARMNUM                 12  // Supported by down-level.
#define WKSTA_KEEPCONN_PARMNUM                  13
#define WKSTA_KEEPSEARCH_PARMNUM                14
#define WKSTA_MAXCMDS_PARMNUM                   15
#define WKSTA_NUMWORKBUF_PARMNUM                16
#define WKSTA_MAXWRKCACHE_PARMNUM               17
#define WKSTA_SESSTIMEOUT_PARMNUM               18
#define WKSTA_SIZERROR_PARMNUM                  19
#define WKSTA_NUMALERTS_PARMNUM                 20
#define WKSTA_NUMSERVICES_PARMNUM               21
#define WKSTA_NUMCHARBUF_PARMNUM                22
#define WKSTA_SIZCHARBUF_PARMNUM                23
#define WKSTA_ERRLOGSZ_PARMNUM                  27  // Supported by down-level.
#define WKSTA_PRINTBUFTIME_PARMNUM              28  // Supported by down-level.
#define WKSTA_SIZWORKBUF_PARMNUM                29
#define WKSTA_MAILSLOTS_PARMNUM                 30
#define WKSTA_NUMDGRAMBUF_PARMNUM               31
#define WKSTA_WRKHEURISTICS_PARMNUM             32  // Supported by down-level.
#define WKSTA_MAXTHREADS_PARMNUM                33

#define WKSTA_LOCKQUOTA_PARMNUM                 41
#define WKSTA_LOCKINCREMENT_PARMNUM             42
#define WKSTA_LOCKMAXIMUM_PARMNUM               43
#define WKSTA_PIPEINCREMENT_PARMNUM             44
#define WKSTA_PIPEMAXIMUM_PARMNUM               45
#define WKSTA_DORMANTFILELIMIT_PARMNUM          46
#define WKSTA_CACHEFILETIMEOUT_PARMNUM          47
#define WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM   48
#define WKSTA_USEUNLOCKBEHIND_PARMNUM           49
#define WKSTA_USECLOSEBEHIND_PARMNUM            50
#define WKSTA_BUFFERNAMEDPIPES_PARMNUM          51
#define WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM   52
#define WKSTA_UTILIZENTCACHING_PARMNUM          53
#define WKSTA_USERAWREAD_PARMNUM                54
#define WKSTA_USERAWWRITE_PARMNUM               55
#define WKSTA_USEWRITERAWWITHDATA_PARMNUM       56
#define WKSTA_USEENCRYPTION_PARMNUM             57
#define WKSTA_BUFFILESWITHDENYWRITE_PARMNUM     58
#define WKSTA_BUFFERREADONLYFILES_PARMNUM       59
#define WKSTA_FORCECORECREATEMODE_PARMNUM       60
#define WKSTA_USE512BYTESMAXTRANSFER_PARMNUM    61
#define WKSTA_READAHEADTHRUPUT_PARMNUM          62


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaUserSetInfo.
//

#define WKSTA_OTH_DOMAINS_PARMNUM              101


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaTransportAdd.
//

#define TRANSPORT_QUALITYOFSERVICE_PARMNUM     201
#define TRANSPORT_NAME_PARMNUM                 202

#ifdef __cplusplus
}
#endif

#endif // _LMWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LsaLookup.h ===
/*++

Copyright (c) Microsoft Corporation, 1992 -

Module Name:

    lsalookup.h

Abstract:

    LSA Policy Lookup API

--*/

#ifndef _LSALOOKUP_
#define _LSALOOKUP_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _NTDEF_

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#else // _NTDEF_

typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#endif // _NTDEF_

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//

//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {

    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     Sid - Contains the complete Sid of the tranlated SID
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//
#endif

//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//

//
// The following structure specifies the account domain info
// (corresponds to the PolicyAccountDomainInformation information class).
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//

//
// The following structure corresponds to the PolicyDnsDomainInformation
// information class
//

typedef struct _POLICY_DNS_DOMAIN_INFO
{
    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING DnsDomainName;
    LSA_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PSID Sid;

} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

// where the members have the following usage:
//
//      Name - Is the name of the Domain
//
//      DnsDomainName - Is the DNS name of the domain
//
//      DnsForestName - Is the DNS forest name of the domain
//
//      DomainGuid - Is the GUID of the domain
//
//      Sid - Is the Sid of the domain


//
// Access types for the Lookup Policy object
//
// Choose values to correspond to the POLICY_* access types
//

#define LOOKUP_VIEW_LOCAL_INFORMATION       0x00000001
#define LOOKUP_TRANSLATE_NAMES              0x00000800

//
// The following data type defines the classes of Lookup Policy
// Domain Information that may be queried. The values are chosen
// to match corresponding POLICY_INFORMATION_CLASS values.
//

typedef enum _LSA_LOOKUP_DOMAIN_INFO_CLASS {

    AccountDomainInformation = 5,
    DnsDomainInformation     = 12

} LSA_LOOKUP_DOMAIN_INFO_CLASS, *PLSA_LOOKUP_DOMAIN_INFO_CLASS;

//
// Lookup handle
//

typedef PVOID LSA_LOOKUP_HANDLE, *PLSA_LOOKUP_HANDLE;

NTSTATUS
LsaLookupOpenLocalPolicy(
    __in     PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    __in     ACCESS_MASK AccessMask,
    __inout  PLSA_LOOKUP_HANDLE PolicyHandle
    );

NTSTATUS
LsaLookupClose(
    __in LSA_LOOKUP_HANDLE ObjectHandle
    );

NTSTATUS
LsaLookupTranslateSids(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  ULONG Count,
    __in  PSID *Sids,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_NAME *Names
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
LsaLookupTranslateNames(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  ULONG Flags,
    __in  ULONG Count,
    __in  PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID2 *Sids
    );
#endif

NTSTATUS
LsaLookupGetDomainInfo(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  LSA_LOOKUP_DOMAIN_INFO_CLASS DomainInfoClass,
    __out PVOID *DomainInfo
    );

NTSTATUS
LsaLookupFreeMemory(
    __in PVOID Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LSALOOKUP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LZExpand.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    lzexpand.h

Abstract:

    Public interface to LZEXP?.LIB.

Author:


Revision History:

--*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZStart(
    VOID
    );

VOID
APIENTRY
LZDone(
    VOID
    );


__success(return >= 0)
__checkReturn
LONG
APIENTRY
CopyLZFile(
    __in INT hfSource,
    __in INT hfDest
    );

__success(return >= 0)
__checkReturn
LONG
APIENTRY
LZCopy(
    __in INT hfSource,
    __in INT hfDest
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZInit(
    __in INT hfSource
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
GetExpandedNameA(
    __in LPSTR lpszSource,
    __out_ecount(MAX_PATH) LPSTR lpszBuffer
    );
__success(return >= 0)
__checkReturn
INT
APIENTRY
GetExpandedNameW(
    __in LPWSTR lpszSource,
    __out_ecount(MAX_PATH) LPWSTR lpszBuffer
    );
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZOpenFileA(
    __in LPSTR lpFileName,
    __inout LPOFSTRUCT lpReOpenBuf,
    __in WORD wStyle
    );
__success(return >= 0)
__checkReturn
INT
APIENTRY
LZOpenFileW(
    __in LPWSTR lpFileName,
    __inout LPOFSTRUCT lpReOpenBuf,
    __in WORD wStyle
    );
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

__success(return >= 0)
__checkReturn
LONG
APIENTRY
LZSeek(
    __in INT hFile,
    __in LONG lOffset,
    __in INT iOrigin
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZRead(
    __in INT hFile,
    __out_bcount_part(cbRead, return) CHAR* lpBuffer,
    __in INT cbRead
    );

VOID
APIENTRY
LZClose(
    __in INT hFile
    );

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMShare.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    lmshare.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetShare
        NetSession
        NetFile
        NetConnection

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

//
// SHARE API
//

#ifndef _LMSHARE_
#define _LMSHARE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Share
//

NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __inout IN  LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    __in_opt IN  LMSTR       servername,
    __in IN  DWORD       level,
    __deref_out_xcount("size varies with level") OUT LPBYTE      *bufptr,
    __in IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnumSticky (
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    __in IN  DWORD   level,
    __deref_opt_out_xcount("size varies with level") OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   level,
    __inout_opt IN  LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelSticky (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareCheck   (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   device,
    __out_opt OUT LPDWORD type
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelEx (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __in IN  LPBYTE  buf
    );

//
// Data Structures - Share
//

typedef struct _SHARE_INFO_0 {
    LMSTR   shi0_netname;
} SHARE_INFO_0, *PSHARE_INFO_0, *LPSHARE_INFO_0;

typedef struct _SHARE_INFO_1 {
    LMSTR   shi1_netname;
    DWORD   shi1_type;
    LMSTR   shi1_remark;
} SHARE_INFO_1, *PSHARE_INFO_1, *LPSHARE_INFO_1;

typedef struct _SHARE_INFO_2 {
    LMSTR   shi2_netname;
    DWORD   shi2_type;
    LMSTR   shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LMSTR   shi2_path;
    LMSTR   shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;

typedef struct _SHARE_INFO_501 {
    LMSTR   shi501_netname;
    DWORD   shi501_type;
    LMSTR   shi501_remark;
    DWORD   shi501_flags;
} SHARE_INFO_501, *PSHARE_INFO_501, *LPSHARE_INFO_501;

typedef struct _SHARE_INFO_502 {
    LMSTR     shi502_netname;
    DWORD     shi502_type;
    LMSTR     shi502_remark;
    DWORD     shi502_permissions;
    DWORD     shi502_max_uses;
    DWORD     shi502_current_uses;
    LMSTR     shi502_path;
    LMSTR     shi502_passwd;
    DWORD     shi502_reserved;
    PSECURITY_DESCRIPTOR  shi502_security_descriptor;
} SHARE_INFO_502, *PSHARE_INFO_502, *LPSHARE_INFO_502;

typedef struct _SHARE_INFO_503 {
    LMSTR     shi503_netname;
    DWORD     shi503_type;
    LMSTR     shi503_remark;
    DWORD     shi503_permissions;
    DWORD     shi503_max_uses;
    DWORD     shi503_current_uses;
    LMSTR     shi503_path;
    LMSTR     shi503_passwd;
    LMSTR     shi503_servername;
    DWORD     shi503_reserved;
    PSECURITY_DESCRIPTOR  shi503_security_descriptor;
} SHARE_INFO_503, *PSHARE_INFO_503, *LPSHARE_INFO_503;

typedef struct _SHARE_INFO_1004 {
    LMSTR   shi1004_remark;
} SHARE_INFO_1004, *PSHARE_INFO_1004, *LPSHARE_INFO_1004;

typedef struct _SHARE_INFO_1005 {
    DWORD  shi1005_flags;
} SHARE_INFO_1005, *PSHARE_INFO_1005, *LPSHARE_INFO_1005;

typedef struct _SHARE_INFO_1006 {
    DWORD   shi1006_max_uses;
} SHARE_INFO_1006, *PSHARE_INFO_1006, *LPSHARE_INFO_1006;

typedef struct _SHARE_INFO_1501 {
    DWORD   shi1501_reserved;
    PSECURITY_DESCRIPTOR  shi1501_security_descriptor;
} SHARE_INFO_1501, *PSHARE_INFO_1501, *LPSHARE_INFO_1501;

typedef struct _SHARE_INFO_1503 {
    GUID       shi1503_sharefilter;
} SHARE_INFO_1503, *PSHARE_INFO_1503, *LPSHARE_INFO_1503;

//
// NetShareAlias functions
//
NET_API_STATUS NET_API_FUNCTION
NetServerAliasAdd(
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __out_bcount(sizeof(SERVER_ALIAS_INFO_0)) IN  LPBYTE  buf
    );

NET_API_STATUS NET_API_FUNCTION
NetServerAliasDel(
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    IN  LPBYTE  buf
    );

NET_API_STATUS NET_API_FUNCTION
NetServerAliasEnum(
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resumehandle
    );

typedef struct _SERVER_ALIAS_INFO_0 {
    LMSTR      srvai0_alias;
    LMSTR      srvai0_target;
    BOOLEAN    srvai0_default;
    ULONG      srvai0_reserved;
} SERVER_ALIAS_INFO_0, *PSERVER_ALIAS_INFO_0, *LPSERVER_ALIAS_INFO_0;

//
// Special Values and Constants - Share
//

//
// Values for parm_err parameter.
//

#define SHARE_NETNAME_PARMNUM         1
#define SHARE_TYPE_PARMNUM            3
#define SHARE_REMARK_PARMNUM          4
#define SHARE_PERMISSIONS_PARMNUM     5
#define SHARE_MAX_USES_PARMNUM        6
#define SHARE_CURRENT_USES_PARMNUM    7
#define SHARE_PATH_PARMNUM            8
#define SHARE_PASSWD_PARMNUM          9
#define SHARE_FILE_SD_PARMNUM       501
#define SHARE_SERVER_PARMNUM        503

//
// Single-field infolevels for NetShareSetInfo.
//

#define SHARE_REMARK_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SHARE_REMARK_PARMNUM)
#define SHARE_MAX_USES_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SHARE_MAX_USES_PARMNUM)
#define SHARE_FILE_SD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SHARE_FILE_SD_PARMNUM)

#define SHI1_NUM_ELEMENTS       4
#define SHI2_NUM_ELEMENTS       10


//
// Share types (shi1_type and shi2_type fields).
//

#define STYPE_DISKTREE          0
#define STYPE_PRINTQ            1
#define STYPE_DEVICE            2
#define STYPE_IPC               3

#define STYPE_TEMPORARY         0x40000000
#define STYPE_SPECIAL           0x80000000

#define SHI_USES_UNLIMITED      (DWORD)-1

//
// Flags values for the 501 and 1005 levels
//
#define SHI1005_FLAGS_DFS       0x0001    // Share is in the DFS
#define SHI1005_FLAGS_DFS_ROOT  0x0002    // Share is root of DFS

#define CSC_MASK_EXT            0x2030    // Used to mask off the following states (including SHI1005_FLAGS_ENABLE_HASH)
#define CSC_MASK                0x0030    // Used to mask off the following states

#define CSC_CACHE_MANUAL_REINT  0x0000    // No automatic file by file reintegration
#define CSC_CACHE_AUTO_REINT    0x0010    // File by file reintegration is OK
#define CSC_CACHE_VDO           0x0020    // no need to flow opens
#define CSC_CACHE_NONE          0x0030    // no CSC for this share

#define SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS  0x0100          // Used to disallow read-deny read behavior
#define SHI1005_FLAGS_FORCE_SHARED_DELETE       0x0200          // Used to allows force shared delete
#define SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING   0x0400          // The clients may cache the namespace
#define SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM 0x0800        // Trim visible files in enumerations based on access
#define SHI1005_FLAGS_FORCE_LEVELII_OPLOCK      0x1000          // Only issue level2 oplock
#define SHI1005_FLAGS_ENABLE_HASH               0x2000          // Enable hash generation and retrieval requests from share

//
// The subset of 1005 infolevel flags that can be set via the API
//

#define SHI1005_VALID_FLAGS_SET    (CSC_MASK|                                   \
                                    SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS|     \
                                    SHI1005_FLAGS_FORCE_SHARED_DELETE|          \
                                    SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING|      \
                                    SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM|  \
                                    SHI1005_FLAGS_FORCE_LEVELII_OPLOCK|         \
                                    SHI1005_FLAGS_ENABLE_HASH)

#endif // _LMSHARE_

//
// SESSION API
//

#ifndef _LMSESSION_
#define _LMSESSION_

//
// Function Prototypes Session
//

NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName OPTIONAL,
    __in_opt IN  LMSTR       username OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out_opt OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName,
    __in_opt IN  LMSTR       username
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionGetInfo (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName,
    __in_opt IN  LMSTR       username,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr
    );


//
// Data Structures - Session
//

typedef struct _SESSION_INFO_0 {
    LMSTR     sesi0_cname;              // client name (no backslashes)
} SESSION_INFO_0, *PSESSION_INFO_0, *LPSESSION_INFO_0;

typedef struct _SESSION_INFO_1 {
    LMSTR     sesi1_cname;              // client name (no backslashes)
    LMSTR     sesi1_username;
    DWORD     sesi1_num_opens;
    DWORD     sesi1_time;
    DWORD     sesi1_idle_time;
    DWORD     sesi1_user_flags;
} SESSION_INFO_1, *PSESSION_INFO_1, *LPSESSION_INFO_1;

typedef struct _SESSION_INFO_2 {
    LMSTR     sesi2_cname;              // client name (no backslashes)
    LMSTR     sesi2_username;
    DWORD     sesi2_num_opens;
    DWORD     sesi2_time;
    DWORD     sesi2_idle_time;
    DWORD     sesi2_user_flags;
    LMSTR     sesi2_cltype_name;
} SESSION_INFO_2, *PSESSION_INFO_2, *LPSESSION_INFO_2;

typedef struct _SESSION_INFO_10 {
    LMSTR     sesi10_cname;             // client name (no backslashes)
    LMSTR     sesi10_username;
    DWORD     sesi10_time;
    DWORD     sesi10_idle_time;
} SESSION_INFO_10, *PSESSION_INFO_10, *LPSESSION_INFO_10;

typedef struct _SESSION_INFO_502 {
    LMSTR     sesi502_cname;             // client name (no backslashes)
    LMSTR     sesi502_username;
    DWORD     sesi502_num_opens;
    DWORD     sesi502_time;
    DWORD     sesi502_idle_time;
    DWORD     sesi502_user_flags;
    LMSTR     sesi502_cltype_name;
    LMSTR     sesi502_transport;
} SESSION_INFO_502, *PSESSION_INFO_502, *LPSESSION_INFO_502;


//
// Special Values and Constants - Session
//


//
// Bits defined in sesi1_user_flags.
//

#define SESS_GUEST          0x00000001  // session is logged on as a guest
#define SESS_NOENCRYPTION   0x00000002  // session is not using encryption

#define SESI1_NUM_ELEMENTS  8
#define SESI2_NUM_ELEMENTS  9

#endif // _LMSESSION_

//
// CONNECTION API
//

#ifndef _LMCONNECTION_

#define _LMCONNECTION_

//
// Function Prototypes - CONNECTION
//

NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    __in_opt IN  LMSTR   servername OPTIONAL,
    __in_opt IN  LMSTR   qualifier,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    __out OUT LPDWORD entriesread,
    __out OUT LPDWORD totalentries,
    __inout_opt IN OUT LPDWORD resume_handle OPTIONAL
    );

//
// Data Structures - CONNECTION
//

typedef struct _CONNECTION_INFO_0 {
    DWORD   coni0_id;
} CONNECTION_INFO_0, *PCONNECTION_INFO_0, *LPCONNECTION_INFO_0;

typedef struct _CONNECTION_INFO_1 {
    DWORD   coni1_id;
    DWORD   coni1_type;
    DWORD   coni1_num_opens;
    DWORD   coni1_num_users;
    DWORD   coni1_time;
    LMSTR   coni1_username;
    LMSTR   coni1_netname;
} CONNECTION_INFO_1, *PCONNECTION_INFO_1, *LPCONNECTION_INFO_1;

#endif // _LMCONNECTION_




//
// FILE API
//

#ifndef _LMFILE_
#define _LMFILE_

//
// Function Prototypes - FILE
//

NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    __in_opt IN LMSTR    servername OPTIONAL,
    IN DWORD    fileid
    );

NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       basepath OPTIONAL,
    __in_opt IN  LMSTR       username OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT PDWORD_PTR  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetFileGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   fileid,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr
    );

//
// Data Structures - File
//

//  File APIs are available at information levels 2 & 3 only. Levels 0 &
//  1 are not supported.
//

typedef struct _FILE_INFO_2 {
    DWORD     fi2_id;
} FILE_INFO_2, *PFILE_INFO_2, *LPFILE_INFO_2;

typedef struct _FILE_INFO_3 {
    DWORD     fi3_id;
    DWORD     fi3_permissions;
    DWORD     fi3_num_locks;
    LMSTR     fi3_pathname;
    LMSTR     fi3_username;
} FILE_INFO_3, *PFILE_INFO_3, *LPFILE_INFO_3;

//
// Special Values and Constants - File
//

//
// bit values for permissions
//

#define PERM_FILE_READ      0x1 // user has read access
#define PERM_FILE_WRITE     0x2 // user has write access
#define PERM_FILE_CREATE    0x4 // user has create access


#ifdef __cplusplus
}
#endif

#endif // _LMFILE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\locationapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for locationapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __locationapi_h__
#define __locationapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILocationReport_FWD_DEFINED__
#define __ILocationReport_FWD_DEFINED__
typedef interface ILocationReport ILocationReport;
#endif 	/* __ILocationReport_FWD_DEFINED__ */


#ifndef __ILatLongReport_FWD_DEFINED__
#define __ILatLongReport_FWD_DEFINED__
typedef interface ILatLongReport ILatLongReport;
#endif 	/* __ILatLongReport_FWD_DEFINED__ */


#ifndef __ICivicAddressReport_FWD_DEFINED__
#define __ICivicAddressReport_FWD_DEFINED__
typedef interface ICivicAddressReport ICivicAddressReport;
#endif 	/* __ICivicAddressReport_FWD_DEFINED__ */


#ifndef __ILocation_FWD_DEFINED__
#define __ILocation_FWD_DEFINED__
typedef interface ILocation ILocation;
#endif 	/* __ILocation_FWD_DEFINED__ */


#ifndef __IDefaultLocation_FWD_DEFINED__
#define __IDefaultLocation_FWD_DEFINED__
typedef interface IDefaultLocation IDefaultLocation;
#endif 	/* __IDefaultLocation_FWD_DEFINED__ */


#ifndef __ILocationEvents_FWD_DEFINED__
#define __ILocationEvents_FWD_DEFINED__
typedef interface ILocationEvents ILocationEvents;
#endif 	/* __ILocationEvents_FWD_DEFINED__ */


#ifndef __IDispLatLongReport_FWD_DEFINED__
#define __IDispLatLongReport_FWD_DEFINED__
typedef interface IDispLatLongReport IDispLatLongReport;
#endif 	/* __IDispLatLongReport_FWD_DEFINED__ */


#ifndef __IDispCivicAddressReport_FWD_DEFINED__
#define __IDispCivicAddressReport_FWD_DEFINED__
typedef interface IDispCivicAddressReport IDispCivicAddressReport;
#endif 	/* __IDispCivicAddressReport_FWD_DEFINED__ */


#ifndef __ILocationReportFactory_FWD_DEFINED__
#define __ILocationReportFactory_FWD_DEFINED__
typedef interface ILocationReportFactory ILocationReportFactory;
#endif 	/* __ILocationReportFactory_FWD_DEFINED__ */


#ifndef __ILatLongReportFactory_FWD_DEFINED__
#define __ILatLongReportFactory_FWD_DEFINED__
typedef interface ILatLongReportFactory ILatLongReportFactory;
#endif 	/* __ILatLongReportFactory_FWD_DEFINED__ */


#ifndef __ICivicAddressReportFactory_FWD_DEFINED__
#define __ICivicAddressReportFactory_FWD_DEFINED__
typedef interface ICivicAddressReportFactory ICivicAddressReportFactory;
#endif 	/* __ICivicAddressReportFactory_FWD_DEFINED__ */


#ifndef __Location_FWD_DEFINED__
#define __Location_FWD_DEFINED__

#ifdef __cplusplus
typedef class Location Location;
#else
typedef struct Location Location;
#endif /* __cplusplus */

#endif 	/* __Location_FWD_DEFINED__ */


#ifndef __DefaultLocation_FWD_DEFINED__
#define __DefaultLocation_FWD_DEFINED__

#ifdef __cplusplus
typedef class DefaultLocation DefaultLocation;
#else
typedef struct DefaultLocation DefaultLocation;
#endif /* __cplusplus */

#endif 	/* __DefaultLocation_FWD_DEFINED__ */


#ifndef __LatLongReport_FWD_DEFINED__
#define __LatLongReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class LatLongReport LatLongReport;
#else
typedef struct LatLongReport LatLongReport;
#endif /* __cplusplus */

#endif 	/* __LatLongReport_FWD_DEFINED__ */


#ifndef __CivicAddressReport_FWD_DEFINED__
#define __CivicAddressReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class CivicAddressReport CivicAddressReport;
#else
typedef struct CivicAddressReport CivicAddressReport;
#endif /* __cplusplus */

#endif 	/* __CivicAddressReport_FWD_DEFINED__ */


#ifndef ___ILatLongReportFactoryEvents_FWD_DEFINED__
#define ___ILatLongReportFactoryEvents_FWD_DEFINED__
typedef interface _ILatLongReportFactoryEvents _ILatLongReportFactoryEvents;
#endif 	/* ___ILatLongReportFactoryEvents_FWD_DEFINED__ */


#ifndef ___ICivicAddressReportFactoryEvents_FWD_DEFINED__
#define ___ICivicAddressReportFactoryEvents_FWD_DEFINED__
typedef interface _ICivicAddressReportFactoryEvents _ICivicAddressReportFactoryEvents;
#endif 	/* ___ICivicAddressReportFactoryEvents_FWD_DEFINED__ */


#ifndef __LatLongReportFactory_FWD_DEFINED__
#define __LatLongReportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class LatLongReportFactory LatLongReportFactory;
#else
typedef struct LatLongReportFactory LatLongReportFactory;
#endif /* __cplusplus */

#endif 	/* __LatLongReportFactory_FWD_DEFINED__ */


#ifndef __CivicAddressReportFactory_FWD_DEFINED__
#define __CivicAddressReportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class CivicAddressReportFactory CivicAddressReportFactory;
#else
typedef struct CivicAddressReportFactory CivicAddressReportFactory;
#endif /* __cplusplus */

#endif 	/* __CivicAddressReportFactory_FWD_DEFINED__ */


#ifndef __DispLatLongReport_FWD_DEFINED__
#define __DispLatLongReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispLatLongReport DispLatLongReport;
#else
typedef struct DispLatLongReport DispLatLongReport;
#endif /* __cplusplus */

#endif 	/* __DispLatLongReport_FWD_DEFINED__ */


#ifndef __DispCivicAddressReport_FWD_DEFINED__
#define __DispCivicAddressReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispCivicAddressReport DispCivicAddressReport;
#else
typedef struct DispCivicAddressReport DispCivicAddressReport;
#endif /* __cplusplus */

#endif 	/* __DispCivicAddressReport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "SensorsApi.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_locationapi_0000_0000 */
/* [local] */ 

#include <SensorsApi.h>
#include <initguid.h>
#include <propkeydef.h>
#define LOCATION_API_VERSION    1
typedef 
enum LOCATION_REPORT_STATUS
    {	REPORT_NOT_SUPPORTED	= 0,
	REPORT_ERROR	= 1,
	REPORT_ACCESS_DENIED	= 2,
	REPORT_INITIALIZING	= 3,
	REPORT_RUNNING	= 4
    } 	LOCATION_REPORT_STATUS;






extern RPC_IF_HANDLE __MIDL_itf_locationapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_locationapi_0000_0000_v0_0_s_ifspec;

#ifndef __ILocationReport_INTERFACE_DEFINED__
#define __ILocationReport_INTERFACE_DEFINED__

/* interface ILocationReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILocationReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8B7F7EE-75D0-4db9-B62D-7A0F369CA456")
    ILocationReport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSensorID( 
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimestamp( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ILocationReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ILocationReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ILocationReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        END_INTERFACE
    } ILocationReportVtbl;

    interface ILocationReport
    {
        CONST_VTBL struct ILocationReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ILocationReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ILocationReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationReport_INTERFACE_DEFINED__ */


#ifndef __ILatLongReport_INTERFACE_DEFINED__
#define __ILatLongReport_INTERFACE_DEFINED__

/* interface ILatLongReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILatLongReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FED806D-0EF8-4f07-80AC-36A0BEAE3134")
    ILatLongReport : public ILocationReport
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLatitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pLatitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLongitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pLongitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetErrorRadius( 
            /* [retval][out] */ __RPC__out DOUBLE *pErrorRadius) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAltitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pAltitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAltitudeError( 
            /* [retval][out] */ __RPC__out DOUBLE *pAltitudeError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILatLongReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILatLongReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILatLongReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ILatLongReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLatitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pLatitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLongitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pLongitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetErrorRadius )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pErrorRadius);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAltitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pAltitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAltitudeError )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pAltitudeError);
        
        END_INTERFACE
    } ILatLongReportVtbl;

    interface ILatLongReport
    {
        CONST_VTBL struct ILatLongReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILatLongReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILatLongReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILatLongReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILatLongReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ILatLongReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ILatLongReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 


#define ILatLongReport_GetLatitude(This,pLatitude)	\
    ( (This)->lpVtbl -> GetLatitude(This,pLatitude) ) 

#define ILatLongReport_GetLongitude(This,pLongitude)	\
    ( (This)->lpVtbl -> GetLongitude(This,pLongitude) ) 

#define ILatLongReport_GetErrorRadius(This,pErrorRadius)	\
    ( (This)->lpVtbl -> GetErrorRadius(This,pErrorRadius) ) 

#define ILatLongReport_GetAltitude(This,pAltitude)	\
    ( (This)->lpVtbl -> GetAltitude(This,pAltitude) ) 

#define ILatLongReport_GetAltitudeError(This,pAltitudeError)	\
    ( (This)->lpVtbl -> GetAltitudeError(This,pAltitudeError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILatLongReport_INTERFACE_DEFINED__ */


#ifndef __ICivicAddressReport_INTERFACE_DEFINED__
#define __ICivicAddressReport_INTERFACE_DEFINED__

/* interface ICivicAddressReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICivicAddressReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0B19F70-4ADF-445d-87F2-CAD8FD711792")
    ICivicAddressReport : public ILocationReport
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAddressLine1( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress1) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAddressLine2( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCity( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStateProvince( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStateProvince) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPostalCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPostalCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountryRegion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCountryRegion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDetailLevel( 
            /* [retval][out] */ __RPC__out DWORD *pDetailLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICivicAddressReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICivicAddressReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICivicAddressReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICivicAddressReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAddressLine1 )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress1);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAddressLine2 )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCity )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStateProvince )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStateProvince);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPostalCode )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPostalCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountryRegion )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCountryRegion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDetailLevel )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out DWORD *pDetailLevel);
        
        END_INTERFACE
    } ICivicAddressReportVtbl;

    interface ICivicAddressReport
    {
        CONST_VTBL struct ICivicAddressReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICivicAddressReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICivicAddressReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICivicAddressReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICivicAddressReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ICivicAddressReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ICivicAddressReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 


#define ICivicAddressReport_GetAddressLine1(This,pbstrAddress1)	\
    ( (This)->lpVtbl -> GetAddressLine1(This,pbstrAddress1) ) 

#define ICivicAddressReport_GetAddressLine2(This,pbstrAddress2)	\
    ( (This)->lpVtbl -> GetAddressLine2(This,pbstrAddress2) ) 

#define ICivicAddressReport_GetCity(This,pbstrCity)	\
    ( (This)->lpVtbl -> GetCity(This,pbstrCity) ) 

#define ICivicAddressReport_GetStateProvince(This,pbstrStateProvince)	\
    ( (This)->lpVtbl -> GetStateProvince(This,pbstrStateProvince) ) 

#define ICivicAddressReport_GetPostalCode(This,pbstrPostalCode)	\
    ( (This)->lpVtbl -> GetPostalCode(This,pbstrPostalCode) ) 

#define ICivicAddressReport_GetCountryRegion(This,pbstrCountryRegion)	\
    ( (This)->lpVtbl -> GetCountryRegion(This,pbstrCountryRegion) ) 

#define ICivicAddressReport_GetDetailLevel(This,pDetailLevel)	\
    ( (This)->lpVtbl -> GetDetailLevel(This,pDetailLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICivicAddressReport_INTERFACE_DEFINED__ */


#ifndef __ILocation_INTERFACE_DEFINED__
#define __ILocation_INTERFACE_DEFINED__

/* interface ILocation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB2ECE69-56D9-4F28-B525-DE1B0EE44237")
    ILocation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterForReport( 
            /* [in] */ __RPC__in_opt ILocationEvents *pEvents,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD dwRequestedReportInterval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterForReport( 
            /* [in] */ __RPC__in REFIID reportType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReportStatus( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_REPORT_STATUS *pStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReportInterval( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out DWORD *pMilliseconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetReportInterval( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD millisecondsRequested) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDesiredAccuracy( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_DESIRED_ACCURACY *pDesiredAccuracy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDesiredAccuracy( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ enum LOCATION_DESIRED_ACCURACY desiredAccuracy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RequestPermissions( 
            /* [in] */ __RPC__in HWND hParent,
            /* [size_is][in] */ __RPC__in_ecount_full(count) IID *pReportTypes,
            /* [in] */ ULONG count,
            /* [in] */ BOOL fModal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterForReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in_opt ILocationEvents *pEvents,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD dwRequestedReportInterval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterForReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReportStatus )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_REPORT_STATUS *pStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReportInterval )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out DWORD *pMilliseconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetReportInterval )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD millisecondsRequested);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDesiredAccuracy )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_DESIRED_ACCURACY *pDesiredAccuracy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDesiredAccuracy )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ enum LOCATION_DESIRED_ACCURACY desiredAccuracy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in HWND hParent,
            /* [size_is][in] */ __RPC__in_ecount_full(count) IID *pReportTypes,
            /* [in] */ ULONG count,
            /* [in] */ BOOL fModal);
        
        END_INTERFACE
    } ILocationVtbl;

    interface ILocation
    {
        CONST_VTBL struct ILocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocation_RegisterForReport(This,pEvents,reportType,dwRequestedReportInterval)	\
    ( (This)->lpVtbl -> RegisterForReport(This,pEvents,reportType,dwRequestedReportInterval) ) 

#define ILocation_UnregisterForReport(This,reportType)	\
    ( (This)->lpVtbl -> UnregisterForReport(This,reportType) ) 

#define ILocation_GetReport(This,reportType,ppLocationReport)	\
    ( (This)->lpVtbl -> GetReport(This,reportType,ppLocationReport) ) 

#define ILocation_GetReportStatus(This,reportType,pStatus)	\
    ( (This)->lpVtbl -> GetReportStatus(This,reportType,pStatus) ) 

#define ILocation_GetReportInterval(This,reportType,pMilliseconds)	\
    ( (This)->lpVtbl -> GetReportInterval(This,reportType,pMilliseconds) ) 

#define ILocation_SetReportInterval(This,reportType,millisecondsRequested)	\
    ( (This)->lpVtbl -> SetReportInterval(This,reportType,millisecondsRequested) ) 

#define ILocation_GetDesiredAccuracy(This,reportType,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> GetDesiredAccuracy(This,reportType,pDesiredAccuracy) ) 

#define ILocation_SetDesiredAccuracy(This,reportType,desiredAccuracy)	\
    ( (This)->lpVtbl -> SetDesiredAccuracy(This,reportType,desiredAccuracy) ) 

#define ILocation_RequestPermissions(This,hParent,pReportTypes,count,fModal)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hParent,pReportTypes,count,fModal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocation_INTERFACE_DEFINED__ */


#ifndef __IDefaultLocation_INTERFACE_DEFINED__
#define __IDefaultLocation_INTERFACE_DEFINED__

/* interface IDefaultLocation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDefaultLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A65AF77E-969A-4a2e-8ACA-33BB7CBB1235")
    IDefaultLocation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefaultLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDefaultLocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDefaultLocation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetReport )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport);
        
        END_INTERFACE
    } IDefaultLocationVtbl;

    interface IDefaultLocation
    {
        CONST_VTBL struct IDefaultLocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefaultLocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDefaultLocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDefaultLocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDefaultLocation_SetReport(This,reportType,pLocationReport)	\
    ( (This)->lpVtbl -> SetReport(This,reportType,pLocationReport) ) 

#define IDefaultLocation_GetReport(This,reportType,ppLocationReport)	\
    ( (This)->lpVtbl -> GetReport(This,reportType,ppLocationReport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDefaultLocation_INTERFACE_DEFINED__ */


#ifndef __ILocationEvents_INTERFACE_DEFINED__
#define __ILocationEvents_INTERFACE_DEFINED__

/* interface ILocationEvents */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ILocationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAE02BBF-798B-4508-A207-35A7906DC73D")
    ILocationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLocationChanged( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStatusChanged( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ LOCATION_REPORT_STATUS newStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLocationChanged )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStatusChanged )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ LOCATION_REPORT_STATUS newStatus);
        
        END_INTERFACE
    } ILocationEventsVtbl;

    interface ILocationEvents
    {
        CONST_VTBL struct ILocationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationEvents_OnLocationChanged(This,reportType,pLocationReport)	\
    ( (This)->lpVtbl -> OnLocationChanged(This,reportType,pLocationReport) ) 

#define ILocationEvents_OnStatusChanged(This,reportType,newStatus)	\
    ( (This)->lpVtbl -> OnStatusChanged(This,reportType,newStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationEvents_INTERFACE_DEFINED__ */


#ifndef __IDispLatLongReport_INTERFACE_DEFINED__
#define __IDispLatLongReport_INTERFACE_DEFINED__

/* interface IDispLatLongReport */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDispLatLongReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8AE32723-389B-4A11-9957-5BDD48FC9617")
    IDispLatLongReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Latitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Longitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorRadius( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Altitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AltitudeError( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispLatLongReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispLatLongReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispLatLongReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDispLatLongReport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispLatLongReport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Latitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Longitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorRadius )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Altitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AltitudeError )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        END_INTERFACE
    } IDispLatLongReportVtbl;

    interface IDispLatLongReport
    {
        CONST_VTBL struct IDispLatLongReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispLatLongReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispLatLongReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispLatLongReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispLatLongReport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispLatLongReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispLatLongReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispLatLongReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispLatLongReport_get_Latitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Latitude(This,pVal) ) 

#define IDispLatLongReport_get_Longitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Longitude(This,pVal) ) 

#define IDispLatLongReport_get_ErrorRadius(This,pVal)	\
    ( (This)->lpVtbl -> get_ErrorRadius(This,pVal) ) 

#define IDispLatLongReport_get_Altitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Altitude(This,pVal) ) 

#define IDispLatLongReport_get_AltitudeError(This,pVal)	\
    ( (This)->lpVtbl -> get_AltitudeError(This,pVal) ) 

#define IDispLatLongReport_get_Timestamp(This,pVal)	\
    ( (This)->lpVtbl -> get_Timestamp(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispLatLongReport_INTERFACE_DEFINED__ */


#ifndef __IDispCivicAddressReport_INTERFACE_DEFINED__
#define __IDispCivicAddressReport_INTERFACE_DEFINED__

/* interface IDispCivicAddressReport */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDispCivicAddressReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16FF1A34-9E30-42c3-B44D-E22513B5767A")
    IDispCivicAddressReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressLine1( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress1) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressLine2( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress2) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StateProvince( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pStateProvince) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPostalCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryRegion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCountryRegion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DetailLevel( 
            /* [retval][out] */ __RPC__out ULONG *pDetailLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispCivicAddressReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispCivicAddressReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispCivicAddressReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispCivicAddressReport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressLine1 )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress1);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressLine2 )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress2);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_City )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StateProvince )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pStateProvince);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalCode )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPostalCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryRegion )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCountryRegion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DetailLevel )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__out ULONG *pDetailLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        END_INTERFACE
    } IDispCivicAddressReportVtbl;

    interface IDispCivicAddressReport
    {
        CONST_VTBL struct IDispCivicAddressReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispCivicAddressReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispCivicAddressReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispCivicAddressReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispCivicAddressReport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispCivicAddressReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispCivicAddressReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispCivicAddressReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispCivicAddressReport_get_AddressLine1(This,pAddress1)	\
    ( (This)->lpVtbl -> get_AddressLine1(This,pAddress1) ) 

#define IDispCivicAddressReport_get_AddressLine2(This,pAddress2)	\
    ( (This)->lpVtbl -> get_AddressLine2(This,pAddress2) ) 

#define IDispCivicAddressReport_get_City(This,pCity)	\
    ( (This)->lpVtbl -> get_City(This,pCity) ) 

#define IDispCivicAddressReport_get_StateProvince(This,pStateProvince)	\
    ( (This)->lpVtbl -> get_StateProvince(This,pStateProvince) ) 

#define IDispCivicAddressReport_get_PostalCode(This,pPostalCode)	\
    ( (This)->lpVtbl -> get_PostalCode(This,pPostalCode) ) 

#define IDispCivicAddressReport_get_CountryRegion(This,pCountryRegion)	\
    ( (This)->lpVtbl -> get_CountryRegion(This,pCountryRegion) ) 

#define IDispCivicAddressReport_get_DetailLevel(This,pDetailLevel)	\
    ( (This)->lpVtbl -> get_DetailLevel(This,pDetailLevel) ) 

#define IDispCivicAddressReport_get_Timestamp(This,pVal)	\
    ( (This)->lpVtbl -> get_Timestamp(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispCivicAddressReport_INTERFACE_DEFINED__ */


#ifndef __ILocationReportFactory_INTERFACE_DEFINED__
#define __ILocationReportFactory_INTERFACE_DEFINED__

/* interface ILocationReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ILocationReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2DAEC322-90B2-47e4-BB08-0DA841935A6B")
    ILocationReportFactory : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListenForReports( 
            /* [defaultvalue][in] */ ULONG requestedReportInterval = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopListeningForReports( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportInterval( 
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReportInterval( 
            /* [in] */ ULONG millisecondsRequested) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DesiredAccuracy( 
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DesiredAccuracy( 
            /* [in] */ ULONG desiredAccuracy) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestPermissions( 
            /* [in] */ __RPC__in ULONG *hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILocationReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILocationReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ILocationReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ILocationReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        END_INTERFACE
    } ILocationReportFactoryVtbl;

    interface ILocationReportFactory
    {
        CONST_VTBL struct ILocationReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILocationReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILocationReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILocationReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILocationReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ILocationReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ILocationReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ILocationReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ILocationReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ILocationReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ILocationReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ILocationReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationReportFactory_INTERFACE_DEFINED__ */


#ifndef __ILatLongReportFactory_INTERFACE_DEFINED__
#define __ILatLongReportFactory_INTERFACE_DEFINED__

/* interface ILatLongReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ILatLongReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F0804CB-B114-447D-83DD-390174EBB082")
    ILatLongReportFactory : public ILocationReportFactory
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LatLongReport( 
            /* [retval][out] */ __RPC__deref_out_opt IDispLatLongReport **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILatLongReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILatLongReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILatLongReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILatLongReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILatLongReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ILatLongReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ILatLongReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatLongReport )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispLatLongReport **pVal);
        
        END_INTERFACE
    } ILatLongReportFactoryVtbl;

    interface ILatLongReportFactory
    {
        CONST_VTBL struct ILatLongReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILatLongReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILatLongReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILatLongReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILatLongReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILatLongReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILatLongReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILatLongReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILatLongReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ILatLongReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ILatLongReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ILatLongReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ILatLongReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ILatLongReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ILatLongReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ILatLongReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 


#define ILatLongReportFactory_get_LatLongReport(This,pVal)	\
    ( (This)->lpVtbl -> get_LatLongReport(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILatLongReportFactory_INTERFACE_DEFINED__ */


#ifndef __ICivicAddressReportFactory_INTERFACE_DEFINED__
#define __ICivicAddressReportFactory_INTERFACE_DEFINED__

/* interface ICivicAddressReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ICivicAddressReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF773B93-C64F-4bee-BEB2-67C0B8DF66E0")
    ICivicAddressReportFactory : public ILocationReportFactory
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CivicAddressReport( 
            /* [retval][out] */ __RPC__deref_out_opt IDispCivicAddressReport **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICivicAddressReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICivicAddressReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CivicAddressReport )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispCivicAddressReport **pVal);
        
        END_INTERFACE
    } ICivicAddressReportFactoryVtbl;

    interface ICivicAddressReportFactory
    {
        CONST_VTBL struct ICivicAddressReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICivicAddressReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICivicAddressReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICivicAddressReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICivicAddressReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICivicAddressReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICivicAddressReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICivicAddressReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICivicAddressReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ICivicAddressReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ICivicAddressReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ICivicAddressReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ICivicAddressReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ICivicAddressReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ICivicAddressReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ICivicAddressReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 


#define ICivicAddressReportFactory_get_CivicAddressReport(This,pVal)	\
    ( (This)->lpVtbl -> get_CivicAddressReport(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICivicAddressReportFactory_INTERFACE_DEFINED__ */



#ifndef __LocationApiLib_LIBRARY_DEFINED__
#define __LocationApiLib_LIBRARY_DEFINED__

/* library LocationApiLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_LocationApiLib;

EXTERN_C const CLSID CLSID_Location;

#ifdef __cplusplus

class DECLSPEC_UUID("E5B8E079-EE6D-4E33-A438-C87F2E959254")
Location;
#endif

EXTERN_C const CLSID CLSID_DefaultLocation;

#ifdef __cplusplus

class DECLSPEC_UUID("8B7FBFE0-5CD7-494a-AF8C-283A65707506")
DefaultLocation;
#endif

EXTERN_C const CLSID CLSID_LatLongReport;

#ifdef __cplusplus

class DECLSPEC_UUID("ED81C073-1F84-4ca8-A161-183C776BC651")
LatLongReport;
#endif

EXTERN_C const CLSID CLSID_CivicAddressReport;

#ifdef __cplusplus

class DECLSPEC_UUID("D39E7BDD-7D05-46b8-8721-80CF035F57D7")
CivicAddressReport;
#endif

#ifndef ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__
#define ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ILatLongReportFactoryEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ILatLongReportFactoryEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("16EE6CB7-AB3C-424B-849F-269BE551FCBC")
    _ILatLongReportFactoryEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ILatLongReportFactoryEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ILatLongReportFactoryEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ILatLongReportFactoryEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ILatLongReportFactoryEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ILatLongReportFactoryEventsVtbl;

    interface _ILatLongReportFactoryEvents
    {
        CONST_VTBL struct _ILatLongReportFactoryEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ILatLongReportFactoryEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ILatLongReportFactoryEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ILatLongReportFactoryEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ILatLongReportFactoryEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _ILatLongReportFactoryEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _ILatLongReportFactoryEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _ILatLongReportFactoryEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__ */


#ifndef ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__
#define ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ICivicAddressReportFactoryEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ICivicAddressReportFactoryEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C96039FF-72EC-4617-89BD-84D88BEDC722")
    _ICivicAddressReportFactoryEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ICivicAddressReportFactoryEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ICivicAddressReportFactoryEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ICivicAddressReportFactoryEventsVtbl;

    interface _ICivicAddressReportFactoryEvents
    {
        CONST_VTBL struct _ICivicAddressReportFactoryEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ICivicAddressReportFactoryEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ICivicAddressReportFactoryEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ICivicAddressReportFactoryEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ICivicAddressReportFactoryEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _ICivicAddressReportFactoryEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _ICivicAddressReportFactoryEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _ICivicAddressReportFactoryEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_LatLongReportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("9DCC3CC8-8609-4863-BAD4-03601F4C65E8")
LatLongReportFactory;
#endif

EXTERN_C const CLSID CLSID_CivicAddressReportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("2A11F42C-3E81-4ad4-9CBE-45579D89671A")
CivicAddressReportFactory;
#endif

EXTERN_C const CLSID CLSID_DispLatLongReport;

#ifdef __cplusplus

class DECLSPEC_UUID("7A7C3277-8F84-4636-95B2-EBB5507FF77E")
DispLatLongReport;
#endif

EXTERN_C const CLSID CLSID_DispCivicAddressReport;

#ifdef __cplusplus

class DECLSPEC_UUID("4C596AEC-8544-4082-BA9F-EB0A7D8E65C6")
DispCivicAddressReport;
#endif
#endif /* __LocationApiLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LMUse.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuse.c

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUse API.


Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMUSE_
#define _LMUSE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetUseAdd (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    IN DWORD Level,
    __inout IN LPBYTE Buf,
    __out_opt OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUseDel (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    __in IN LMSTR  UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS NET_API_FUNCTION
NetUseEnum (
    __in_opt LMSTR  UncServerName,
    __in DWORD Level,
    __out_opt LPBYTE *BufPtr,
    __in DWORD PreferedMaximumSize,
    __out_opt LPDWORD EntriesRead,
    __out LPDWORD TotalEntries,
    __inout_opt LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    __in IN LMSTR  UseName,
    IN DWORD Level,
    __out_opt OUT LPBYTE *BufPtr
    );

//
//  Data Structures
//

typedef struct _USE_INFO_0 {
    LMSTR   ui0_local;
    LMSTR   ui0_remote;
}USE_INFO_0, *PUSE_INFO_0, *LPUSE_INFO_0;

typedef struct _USE_INFO_1 {
    LMSTR   ui1_local;
    LMSTR   ui1_remote;
    LMSTR   ui1_password;
    DWORD   ui1_status;
    DWORD   ui1_asg_type;
    DWORD   ui1_refcount;
    DWORD   ui1_usecount;
}USE_INFO_1, *PUSE_INFO_1, *LPUSE_INFO_1;

typedef struct _USE_INFO_2 {
    LMSTR    ui2_local;
    LMSTR    ui2_remote;
    LMSTR    ui2_password;
    DWORD    ui2_status;
    DWORD    ui2_asg_type;
    DWORD    ui2_refcount;
    DWORD    ui2_usecount;
    LMSTR    ui2_username;
    LMSTR    ui2_domainname;
}USE_INFO_2, *PUSE_INFO_2, *LPUSE_INFO_2;

typedef struct _USE_INFO_3 {
    USE_INFO_2 ui3_ui2;
    ULONG      ui3_flags;
} USE_INFO_3, *PUSE_INFO_3, *LPUSE_INFO_3;

typedef struct _USE_INFO_4 {
    USE_INFO_3 ui4_ui3;
    DWORD      ui4_auth_identity_length;
    PBYTE      ui4_auth_identity;
} USE_INFO_4, *PUSE_INFO_4, *LPUSE_INFO_4;

//
// Special Values and Constants
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetUseAdd.
//

#define USE_LOCAL_PARMNUM       1
#define USE_REMOTE_PARMNUM      2
#define USE_PASSWORD_PARMNUM    3
#define USE_ASGTYPE_PARMNUM     4
#define USE_USERNAME_PARMNUM    5
#define USE_DOMAINNAME_PARMNUM  6

//
// Values appearing in the ui1_status field of use_info_1 structure.
// Note that USE_SESSLOST and USE_DISCONN are synonyms.
//

#define USE_OK                  0
#define USE_PAUSED              1
#define USE_SESSLOST            2
#define USE_DISCONN             2
#define USE_NETERR              3
#define USE_CONN                4
#define USE_RECONN              5


//
// Values of the ui1_asg_type field of use_info_1 structure
//

#define USE_WILDCARD            ( (DWORD) (-1) )
#define USE_DISKDEV             0
#define USE_SPOOLDEV            1
#define USE_CHARDEV             2
#define USE_IPC                 3

//
// Flags defined in the use_info_3 structure
//

#define CREATE_NO_CONNECT 0x1        // creation flags
#define CREATE_BYPASS_CSC 0x2        // force connection to server, bypassing CSC
                                     //  all ops on this connection go to the server,
                                     //  never to the cache
#define CREATE_CRED_RESET 0x4	     // Create a connection with credentials passed in 
				     //  this netuse if none exist. If connection already 
				     //  exists then update credentials after issuing remote
				     //  tree connection. This is needed as CSC cannot verify 
				     //  credentials while offline.

#define USE_DEFAULT_CREDENTIALS 0x4  // No explicit credentials passed to NetUseAdd

#ifdef __cplusplus
}
#endif

#endif // _LMUSE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LoadPerf.h ===
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:
    loadperf.h

Abstract:
    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History
    16-Nov-95   Created (a-robw)
--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument
#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR) 1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR) 2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR) 4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR) 8)

LOADPERF_FUNCTION
InstallPerfDllW(
    __in_opt LPCWSTR   szComputerName,
    __in     LPCWSTR   lpIniFile,
    __in     ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA(
    __in_opt LPCSTR    szComputerName,
    __in     LPCSTR    lpIniFile,
    __in     ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA(
    __in LPSTR     lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW(
    __in LPWSTR    lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW(
    __in LPWSTR    lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA(
    __in LPSTR     lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA(
    __in     LPCSTR    szNewCtrFilePath,
    __in_opt LPCSTR    szNewHlpFilePath,
    __in     LPSTR     szLanguageID,
    __in     ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW(
    __in     LPCWSTR   szNewCtrFilePath,
    __in_opt LPCWSTR   szNewHlpFilePath,
    __in     LPWSTR    szLanguageID,
    __in     ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA(
    __in_opt LPCSTR    szReserved,
    __in     LPCSTR    szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW(
    __in_opt LPCWSTR   szReserved,
    __in     LPCWSTR   szServiceName
);

DWORD
BackupPerfRegistryToFileW(
    __in     LPCWSTR   szFileName,
    __in_opt LPCWSTR   szCommentString
);

DWORD
RestorePerfRegistryFromFileW(
    __in_opt LPCWSTR   szFileName,
    __in_opt LPCWSTR   szLangId
);

#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsA
#define UpdatePerfNameFiles             UpdatePerfNameFilesA
#define SetServiceAsTrusted             SetServiceAsTrustedA
#endif

#ifdef __cplusplus
}
#endif


#endif // _LOADPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\madcapcl.h ===
// Copyright (c) 1990-1999  Microsoft Corporation
#ifndef _MADCAPCL_H_
#define _MADCAPCL_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <time.h>

#if _MSC_VER > 1000
#pragma once
#endif

#define MCAST_CLIENT_ID_LEN 17

enum {
    MCAST_API_VERSION_0 = 0,
    MCAST_API_VERSION_1
};

#define MCAST_API_CURRENT_VERSION MCAST_API_VERSION_1

typedef unsigned short IP_ADDR_FAMILY;

typedef union _IPNG_ADDRESS {
    DWORD   IpAddrV4;
    BYTE    IpAddrV6[16];
} IPNG_ADDRESS, *PIPNG_ADDRESS;


/*++
Description:

    This union is used to pass both IPv4 and IPv6 style address.

Members:

    IpAddrV4 - IPv4 style address

    IpAddrV6 - IPv6 style address

--*/

typedef struct _MCAST_CLIENT_UID {
    LPBYTE ClientUID;
    DWORD ClientUIDLength;
} MCAST_CLIENT_UID, *LPMCAST_CLIENT_UID;

/*++
Description:

    This describes the unique clientID for each request.

Members:

    ClientUID - Buffer containing the clientID

    ClientUIDLength - The size of the above buffer in bytes.

--*/


typedef struct _MCAST_SCOPE_CTX {
    IPNG_ADDRESS      ScopeID;
    IPNG_ADDRESS      Interface;
    IPNG_ADDRESS      ServerID;
} MCAST_SCOPE_CTX, *PMCAST_SCOPE_CTX;

/*++
Description:

    This defines the handle of the scope from which the address
    is to be allocated/renewed/released.

Members:

    ScopeID - Scope ID is essentially first ip of the scope

    Interface - Interface on which this scope was found

    ServerID - IPAddress of the MADCAP server

--*/


typedef struct _MCAST_SCOPE_ENTRY {
    MCAST_SCOPE_CTX ScopeCtx;
    IPNG_ADDRESS      LastAddr;
    DWORD       TTL;
    UNICODE_STRING  ScopeDesc;
} MCAST_SCOPE_ENTRY, *PMCAST_SCOPE_ENTRY;

/*++
Description:

    This structure contains all the info pertaining to a given multicast
    scope.

Members:

    ScopeCtx - the handle for this scope

    LastAddr - last addr of the scope

    TTL - TTL value of this scope.

    ScopeDesc - user friendly description of scope

--*/



typedef struct _MCAST_LEASE_REQUEST {
    LONG        LeaseStartTime;
    LONG        MaxLeaseStartTime;
    DWORD       LeaseDuration;
    DWORD       MinLeaseDuration;
    IPNG_ADDRESS  ServerAddress;
    WORD        MinAddrCount;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_REQUEST, *PMCAST_LEASE_REQUEST;

/*++
Description:

    This structure is used to describe the request parameters for
    requesting/renewing/releasing multicast addresses

Members:

    LeaseStartTime - desired start time of the lease, pass 0 if desired start time
                     is current time. The desired time is specified in the number of seconds elapsed
                     since midnight (00:00:00), January 1, 1970, coordinated universal time.

    MaxLeaseStartTime - the maximum start time that the client is willing to accept.
                        Where time is the number of seconds elapsed since midnight (00:00:00),
                        January 1, 1970, coordinated universal time.

    LeaseDuration - desired lease time for the request, pass 0 if default
                    lease time is requested.

    MinLeaseDuration - the minimum lease time that the client is willing
                       to accept

    ServerAddress - server's ip address where this lease whas renewed/requested.
                    pass 0 if unknown (e.g in McastRequestAddress)

    MinAddrCount - minimum number of addresses that the client is willing
                   to accept

    AddrCount - the desired number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    pAddrBuf - buffer containing specific addresses being requested/renewed/released.
                For IPv4 it is a pointer to 4 byte addresses and for IPv6 it
                points to 16 byte chunks. Pass NULL if no specific addresses
                are requested.

Remarks:

    In MCAST_API_VERSION_1 version, the MaxLeaseStartTime, MinLeaseDuration and
    MinAddrCount are ignored by the API implementation. However, the clients should
    set appropriate desired values for these members so as when the OS update brings
    new implementation of the APIs then the clients can take advantage of it.

--*/


typedef struct _MCAST_LEASE_RESPONSE {
    LONG        LeaseStartTime;
    LONG        LeaseEndTime;
    IPNG_ADDRESS  ServerAddress;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_RESPONSE, *PMCAST_LEASE_RESPONSE;

/*++

Description:

    This structure is used to pass the response of the operation of
    requesting/renewing/releasing multicast addresses.

Members:

    LeaseStartTime - start time of the lease in number of seconds elapsed since
                     midnight (00:00:00), January 1, 1970, coordinated universal time.

    LeaseEndTime - time when lease ends, where time is the number of seconds elapsed
                   since midnight (00:00:00), January 1, 1970, coordinated universal time.

    ServerAddress - server's ip address where this lease is renewed/requested.

    AddrCount - number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    Addr - buffer containing addresses being requested/renewed/released. For IPv4
            it is a pointer to 4 byte addresses and for IPv6 it points to 16 byte chunks

--*/

DWORD
APIENTRY
McastApiStartup(
    IN  OUT  PDWORD   Version
    );

VOID
APIENTRY
McastApiCleanup(
    VOID
    );

DWORD
APIENTRY
McastGenUID(
    IN OUT LPMCAST_CLIENT_UID    pRequestID
    );

DWORD
APIENTRY
McastEnumerateScopes(
    IN     IP_ADDR_FAMILY       AddrFamily,
    IN     BOOL                 ReQuery,
    IN OUT PMCAST_SCOPE_ENTRY   pScopeList,
    IN OUT PDWORD               pScopeLen,
    OUT    PDWORD               pScopeCount
    );

DWORD
APIENTRY
McastRequestAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_SCOPE_CTX         pScopeCtx,
    IN     PMCAST_LEASE_REQUEST     pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pAddrResponse
    );

DWORD
APIENTRY
McastRenewAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_LEASE_REQUEST     pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pRenewResponse
    );

DWORD
APIENTRY
McastReleaseAddress(
    IN     IP_ADDR_FAMILY          AddrFamily,
    IN     LPMCAST_CLIENT_UID      pRequestID,
    IN     PMCAST_LEASE_REQUEST    pReleaseRequest
    );

#ifdef __cplusplus
}
#endif 
#endif _MADCAPCL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\manipulations.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for manipulations.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __manipulations_h__
#define __manipulations_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef ___IManipulationEvents_FWD_DEFINED__
#define ___IManipulationEvents_FWD_DEFINED__
typedef interface _IManipulationEvents _IManipulationEvents;
#endif 	/* ___IManipulationEvents_FWD_DEFINED__ */


#ifndef __IInertiaProcessor_FWD_DEFINED__
#define __IInertiaProcessor_FWD_DEFINED__
typedef interface IInertiaProcessor IInertiaProcessor;
#endif 	/* __IInertiaProcessor_FWD_DEFINED__ */


#ifndef __IManipulationProcessor_FWD_DEFINED__
#define __IManipulationProcessor_FWD_DEFINED__
typedef interface IManipulationProcessor IManipulationProcessor;
#endif 	/* __IManipulationProcessor_FWD_DEFINED__ */


#ifndef __InertiaProcessor_FWD_DEFINED__
#define __InertiaProcessor_FWD_DEFINED__

#ifdef __cplusplus
typedef class InertiaProcessor InertiaProcessor;
#else
typedef struct InertiaProcessor InertiaProcessor;
#endif /* __cplusplus */

#endif 	/* __InertiaProcessor_FWD_DEFINED__ */


#ifndef __ManipulationProcessor_FWD_DEFINED__
#define __ManipulationProcessor_FWD_DEFINED__

#ifdef __cplusplus
typedef class ManipulationProcessor ManipulationProcessor;
#else
typedef struct ManipulationProcessor ManipulationProcessor;
#endif /* __cplusplus */

#endif 	/* __ManipulationProcessor_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_manipulations_0000_0000 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum MANIPULATION_PROCESSOR_MANIPULATIONS
    {	MANIPULATION_NONE	= 0,
	MANIPULATION_TRANSLATE_X	= 0x1,
	MANIPULATION_TRANSLATE_Y	= 0x2,
	MANIPULATION_SCALE	= 0x4,
	MANIPULATION_ROTATE	= 0x8,
	MANIPULATION_ALL	= 0xf
    } 	MANIPULATION_PROCESSOR_MANIPULATIONS;

DEFINE_ENUM_FLAG_OPERATORS(MANIPULATION_PROCESSOR_MANIPULATIONS)
// Floating point constants.
DECLSPEC_SELECTANY extern const float POSITIVE_INFINITY = ((float)(1e308 * 10));
DECLSPEC_SELECTANY extern const float NEGATIVE_INFINITY = ((float)(-1e308 * 10));
DECLSPEC_SELECTANY extern const float NaN = ((float)((1e308 * 10)*0.));
typedef unsigned long MANIPULATOR_ID;



extern RPC_IF_HANDLE __MIDL_itf_manipulations_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_manipulations_0000_0000_v0_0_s_ifspec;


#ifndef __ManipulationsLib_LIBRARY_DEFINED__
#define __ManipulationsLib_LIBRARY_DEFINED__

/* library ManipulationsLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ManipulationsLib;

#ifndef ___IManipulationEvents_INTERFACE_DEFINED__
#define ___IManipulationEvents_INTERFACE_DEFINED__

/* interface _IManipulationEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID__IManipulationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4f62c8da-9c53-4b22-93df-927a862bbb03")
    _IManipulationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationStarted( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationDelta( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT translationDeltaX,
            /* [in] */ FLOAT translationDeltaY,
            /* [in] */ FLOAT scaleDelta,
            /* [in] */ FLOAT expansionDelta,
            /* [in] */ FLOAT rotationDelta,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationCompleted( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IManipulationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _IManipulationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _IManipulationEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationStarted )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationDelta )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT translationDeltaX,
            /* [in] */ FLOAT translationDeltaY,
            /* [in] */ FLOAT scaleDelta,
            /* [in] */ FLOAT expansionDelta,
            /* [in] */ FLOAT rotationDelta,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationCompleted )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation);
        
        END_INTERFACE
    } _IManipulationEventsVtbl;

    interface _IManipulationEvents
    {
        CONST_VTBL struct _IManipulationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IManipulationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IManipulationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IManipulationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IManipulationEvents_ManipulationStarted(This,x,y)	\
    ( (This)->lpVtbl -> ManipulationStarted(This,x,y) ) 

#define _IManipulationEvents_ManipulationDelta(This,x,y,translationDeltaX,translationDeltaY,scaleDelta,expansionDelta,rotationDelta,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation)	\
    ( (This)->lpVtbl -> ManipulationDelta(This,x,y,translationDeltaX,translationDeltaY,scaleDelta,expansionDelta,rotationDelta,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation) ) 

#define _IManipulationEvents_ManipulationCompleted(This,x,y,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation)	\
    ( (This)->lpVtbl -> ManipulationCompleted(This,x,y,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___IManipulationEvents_INTERFACE_DEFINED__ */


#ifndef __IInertiaProcessor_INTERFACE_DEFINED__
#define __IInertiaProcessor_INTERFACE_DEFINED__

/* interface IInertiaProcessor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInertiaProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18b00c6d-c5ee-41b1-90a9-9d4a929095ad")
    IInertiaProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_InitialOriginX( 
            /* [out] */ __RPC__out FLOAT *x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialOriginX( 
            /* [in] */ FLOAT x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialOriginY( 
            /* [out] */ __RPC__out FLOAT *y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialOriginY( 
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialVelocityX( 
            /* [out] */ __RPC__out FLOAT *x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialVelocityX( 
            /* [in] */ FLOAT x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialVelocityY( 
            /* [out] */ __RPC__out FLOAT *y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialVelocityY( 
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialAngularVelocity( 
            /* [out] */ __RPC__out FLOAT *velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialAngularVelocity( 
            /* [in] */ FLOAT velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialExpansionVelocity( 
            /* [out] */ __RPC__out FLOAT *velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialExpansionVelocity( 
            /* [in] */ FLOAT velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialRadius( 
            /* [out] */ __RPC__out FLOAT *radius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialRadius( 
            /* [in] */ FLOAT radius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryLeft( 
            /* [out] */ __RPC__out FLOAT *left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryLeft( 
            /* [in] */ FLOAT left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryTop( 
            /* [out] */ __RPC__out FLOAT *top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryTop( 
            /* [in] */ FLOAT top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryRight( 
            /* [out] */ __RPC__out FLOAT *right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryRight( 
            /* [in] */ FLOAT right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryBottom( 
            /* [out] */ __RPC__out FLOAT *bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryBottom( 
            /* [in] */ FLOAT bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginLeft( 
            /* [out] */ __RPC__out FLOAT *left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginLeft( 
            /* [in] */ FLOAT left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginTop( 
            /* [out] */ __RPC__out FLOAT *top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginTop( 
            /* [in] */ FLOAT top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginRight( 
            /* [out] */ __RPC__out FLOAT *right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginRight( 
            /* [in] */ FLOAT right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginBottom( 
            /* [out] */ __RPC__out FLOAT *bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginBottom( 
            /* [in] */ FLOAT bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredDisplacement( 
            /* [out] */ __RPC__out FLOAT *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredDisplacement( 
            /* [in] */ FLOAT displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredRotation( 
            /* [out] */ __RPC__out FLOAT *rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredRotation( 
            /* [in] */ FLOAT rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredExpansion( 
            /* [out] */ __RPC__out FLOAT *expansion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredExpansion( 
            /* [in] */ FLOAT expansion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredAngularDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredAngularDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredExpansionDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredExpansionDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialTimestamp( 
            /* [out] */ __RPC__out DWORD *timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialTimestamp( 
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Process( 
            /* [out] */ __RPC__out BOOL *completed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessTime( 
            /* [in] */ DWORD timestamp,
            /* [out] */ __RPC__out BOOL *completed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Complete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteTime( 
            /* [in] */ DWORD timestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInertiaProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInertiaProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialOriginX )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *x);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialOriginX )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT x);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialOriginY )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *y);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialOriginY )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialVelocityX )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *x);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialVelocityX )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT x);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialVelocityY )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *y);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialVelocityY )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialAngularVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocity);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialAngularVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT velocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialExpansionVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocity);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialExpansionVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT velocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialRadius )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *radius);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialRadius )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT radius);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *left);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT left);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *top);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT top);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *right);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT right);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *bottom);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT bottom);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *left);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT left);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *top);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT top);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *right);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT right);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *bottom);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT bottom);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredDisplacement )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredDisplacement )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT displacement);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredRotation )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *rotation);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredRotation )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT rotation);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredExpansion )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *expansion);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredExpansion )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT expansion);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredAngularDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredAngularDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredExpansionDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredExpansionDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialTimestamp )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out DWORD *timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialTimestamp )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Process )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out BOOL *completed);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessTime )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp,
            /* [out] */ __RPC__out BOOL *completed);
        
        HRESULT ( STDMETHODCALLTYPE *Complete )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteTime )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp);
        
        END_INTERFACE
    } IInertiaProcessorVtbl;

    interface IInertiaProcessor
    {
        CONST_VTBL struct IInertiaProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInertiaProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInertiaProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInertiaProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInertiaProcessor_get_InitialOriginX(This,x)	\
    ( (This)->lpVtbl -> get_InitialOriginX(This,x) ) 

#define IInertiaProcessor_put_InitialOriginX(This,x)	\
    ( (This)->lpVtbl -> put_InitialOriginX(This,x) ) 

#define IInertiaProcessor_get_InitialOriginY(This,y)	\
    ( (This)->lpVtbl -> get_InitialOriginY(This,y) ) 

#define IInertiaProcessor_put_InitialOriginY(This,y)	\
    ( (This)->lpVtbl -> put_InitialOriginY(This,y) ) 

#define IInertiaProcessor_get_InitialVelocityX(This,x)	\
    ( (This)->lpVtbl -> get_InitialVelocityX(This,x) ) 

#define IInertiaProcessor_put_InitialVelocityX(This,x)	\
    ( (This)->lpVtbl -> put_InitialVelocityX(This,x) ) 

#define IInertiaProcessor_get_InitialVelocityY(This,y)	\
    ( (This)->lpVtbl -> get_InitialVelocityY(This,y) ) 

#define IInertiaProcessor_put_InitialVelocityY(This,y)	\
    ( (This)->lpVtbl -> put_InitialVelocityY(This,y) ) 

#define IInertiaProcessor_get_InitialAngularVelocity(This,velocity)	\
    ( (This)->lpVtbl -> get_InitialAngularVelocity(This,velocity) ) 

#define IInertiaProcessor_put_InitialAngularVelocity(This,velocity)	\
    ( (This)->lpVtbl -> put_InitialAngularVelocity(This,velocity) ) 

#define IInertiaProcessor_get_InitialExpansionVelocity(This,velocity)	\
    ( (This)->lpVtbl -> get_InitialExpansionVelocity(This,velocity) ) 

#define IInertiaProcessor_put_InitialExpansionVelocity(This,velocity)	\
    ( (This)->lpVtbl -> put_InitialExpansionVelocity(This,velocity) ) 

#define IInertiaProcessor_get_InitialRadius(This,radius)	\
    ( (This)->lpVtbl -> get_InitialRadius(This,radius) ) 

#define IInertiaProcessor_put_InitialRadius(This,radius)	\
    ( (This)->lpVtbl -> put_InitialRadius(This,radius) ) 

#define IInertiaProcessor_get_BoundaryLeft(This,left)	\
    ( (This)->lpVtbl -> get_BoundaryLeft(This,left) ) 

#define IInertiaProcessor_put_BoundaryLeft(This,left)	\
    ( (This)->lpVtbl -> put_BoundaryLeft(This,left) ) 

#define IInertiaProcessor_get_BoundaryTop(This,top)	\
    ( (This)->lpVtbl -> get_BoundaryTop(This,top) ) 

#define IInertiaProcessor_put_BoundaryTop(This,top)	\
    ( (This)->lpVtbl -> put_BoundaryTop(This,top) ) 

#define IInertiaProcessor_get_BoundaryRight(This,right)	\
    ( (This)->lpVtbl -> get_BoundaryRight(This,right) ) 

#define IInertiaProcessor_put_BoundaryRight(This,right)	\
    ( (This)->lpVtbl -> put_BoundaryRight(This,right) ) 

#define IInertiaProcessor_get_BoundaryBottom(This,bottom)	\
    ( (This)->lpVtbl -> get_BoundaryBottom(This,bottom) ) 

#define IInertiaProcessor_put_BoundaryBottom(This,bottom)	\
    ( (This)->lpVtbl -> put_BoundaryBottom(This,bottom) ) 

#define IInertiaProcessor_get_ElasticMarginLeft(This,left)	\
    ( (This)->lpVtbl -> get_ElasticMarginLeft(This,left) ) 

#define IInertiaProcessor_put_ElasticMarginLeft(This,left)	\
    ( (This)->lpVtbl -> put_ElasticMarginLeft(This,left) ) 

#define IInertiaProcessor_get_ElasticMarginTop(This,top)	\
    ( (This)->lpVtbl -> get_ElasticMarginTop(This,top) ) 

#define IInertiaProcessor_put_ElasticMarginTop(This,top)	\
    ( (This)->lpVtbl -> put_ElasticMarginTop(This,top) ) 

#define IInertiaProcessor_get_ElasticMarginRight(This,right)	\
    ( (This)->lpVtbl -> get_ElasticMarginRight(This,right) ) 

#define IInertiaProcessor_put_ElasticMarginRight(This,right)	\
    ( (This)->lpVtbl -> put_ElasticMarginRight(This,right) ) 

#define IInertiaProcessor_get_ElasticMarginBottom(This,bottom)	\
    ( (This)->lpVtbl -> get_ElasticMarginBottom(This,bottom) ) 

#define IInertiaProcessor_put_ElasticMarginBottom(This,bottom)	\
    ( (This)->lpVtbl -> put_ElasticMarginBottom(This,bottom) ) 

#define IInertiaProcessor_get_DesiredDisplacement(This,displacement)	\
    ( (This)->lpVtbl -> get_DesiredDisplacement(This,displacement) ) 

#define IInertiaProcessor_put_DesiredDisplacement(This,displacement)	\
    ( (This)->lpVtbl -> put_DesiredDisplacement(This,displacement) ) 

#define IInertiaProcessor_get_DesiredRotation(This,rotation)	\
    ( (This)->lpVtbl -> get_DesiredRotation(This,rotation) ) 

#define IInertiaProcessor_put_DesiredRotation(This,rotation)	\
    ( (This)->lpVtbl -> put_DesiredRotation(This,rotation) ) 

#define IInertiaProcessor_get_DesiredExpansion(This,expansion)	\
    ( (This)->lpVtbl -> get_DesiredExpansion(This,expansion) ) 

#define IInertiaProcessor_put_DesiredExpansion(This,expansion)	\
    ( (This)->lpVtbl -> put_DesiredExpansion(This,expansion) ) 

#define IInertiaProcessor_get_DesiredDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_DesiredAngularDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredAngularDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredAngularDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredAngularDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_DesiredExpansionDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredExpansionDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredExpansionDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredExpansionDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_InitialTimestamp(This,timestamp)	\
    ( (This)->lpVtbl -> get_InitialTimestamp(This,timestamp) ) 

#define IInertiaProcessor_put_InitialTimestamp(This,timestamp)	\
    ( (This)->lpVtbl -> put_InitialTimestamp(This,timestamp) ) 

#define IInertiaProcessor_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IInertiaProcessor_Process(This,completed)	\
    ( (This)->lpVtbl -> Process(This,completed) ) 

#define IInertiaProcessor_ProcessTime(This,timestamp,completed)	\
    ( (This)->lpVtbl -> ProcessTime(This,timestamp,completed) ) 

#define IInertiaProcessor_Complete(This)	\
    ( (This)->lpVtbl -> Complete(This) ) 

#define IInertiaProcessor_CompleteTime(This,timestamp)	\
    ( (This)->lpVtbl -> CompleteTime(This,timestamp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInertiaProcessor_INTERFACE_DEFINED__ */


#ifndef __IManipulationProcessor_INTERFACE_DEFINED__
#define __IManipulationProcessor_INTERFACE_DEFINED__

/* interface IManipulationProcessor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IManipulationProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A22AC519-8300-48a0-BEF4-F1BE8737DBA4")
    IManipulationProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_SupportedManipulations( 
            /* [out] */ __RPC__out MANIPULATION_PROCESSOR_MANIPULATIONS *manipulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SupportedManipulations( 
            /* [in] */ MANIPULATION_PROCESSOR_MANIPULATIONS manipulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotPointX( 
            /* [out] */ __RPC__out FLOAT *pivotPointX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotPointX( 
            /* [in] */ FLOAT pivotPointX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotPointY( 
            /* [out] */ __RPC__out FLOAT *pivotPointY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotPointY( 
            /* [in] */ FLOAT pivotPointY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotRadius( 
            /* [out] */ __RPC__out FLOAT *pivotRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotRadius( 
            /* [in] */ FLOAT pivotRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteManipulation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDown( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMove( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUp( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDownWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMoveWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUpWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVelocityX( 
            /* [out] */ __RPC__out FLOAT *velocityX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVelocityY( 
            /* [out] */ __RPC__out FLOAT *velocityY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpansionVelocity( 
            /* [out] */ __RPC__out FLOAT *expansionVelocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAngularVelocity( 
            /* [out] */ __RPC__out FLOAT *angularVelocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MinimumScaleRotateRadius( 
            /* [out] */ __RPC__out FLOAT *minRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MinimumScaleRotateRadius( 
            /* [in] */ FLOAT minRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManipulationProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IManipulationProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IManipulationProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_SupportedManipulations )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out MANIPULATION_PROCESSOR_MANIPULATIONS *manipulations);
        
        HRESULT ( STDMETHODCALLTYPE *put_SupportedManipulations )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATION_PROCESSOR_MANIPULATIONS manipulations);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotPointX )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotPointX);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotPointX )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotPointX);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotPointY )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotPointY);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotPointY )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotPointY);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotRadius);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotRadius);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteManipulation )( 
            __RPC__in IManipulationProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessDown )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMove )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUp )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessDownWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMoveWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUpWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *GetVelocityX )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocityX);
        
        HRESULT ( STDMETHODCALLTYPE *GetVelocityY )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocityY);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpansionVelocity )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *expansionVelocity);
        
        HRESULT ( STDMETHODCALLTYPE *GetAngularVelocity )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *angularVelocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_MinimumScaleRotateRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *minRadius);
        
        HRESULT ( STDMETHODCALLTYPE *put_MinimumScaleRotateRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT minRadius);
        
        END_INTERFACE
    } IManipulationProcessorVtbl;

    interface IManipulationProcessor
    {
        CONST_VTBL struct IManipulationProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManipulationProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManipulationProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManipulationProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManipulationProcessor_get_SupportedManipulations(This,manipulations)	\
    ( (This)->lpVtbl -> get_SupportedManipulations(This,manipulations) ) 

#define IManipulationProcessor_put_SupportedManipulations(This,manipulations)	\
    ( (This)->lpVtbl -> put_SupportedManipulations(This,manipulations) ) 

#define IManipulationProcessor_get_PivotPointX(This,pivotPointX)	\
    ( (This)->lpVtbl -> get_PivotPointX(This,pivotPointX) ) 

#define IManipulationProcessor_put_PivotPointX(This,pivotPointX)	\
    ( (This)->lpVtbl -> put_PivotPointX(This,pivotPointX) ) 

#define IManipulationProcessor_get_PivotPointY(This,pivotPointY)	\
    ( (This)->lpVtbl -> get_PivotPointY(This,pivotPointY) ) 

#define IManipulationProcessor_put_PivotPointY(This,pivotPointY)	\
    ( (This)->lpVtbl -> put_PivotPointY(This,pivotPointY) ) 

#define IManipulationProcessor_get_PivotRadius(This,pivotRadius)	\
    ( (This)->lpVtbl -> get_PivotRadius(This,pivotRadius) ) 

#define IManipulationProcessor_put_PivotRadius(This,pivotRadius)	\
    ( (This)->lpVtbl -> put_PivotRadius(This,pivotRadius) ) 

#define IManipulationProcessor_CompleteManipulation(This)	\
    ( (This)->lpVtbl -> CompleteManipulation(This) ) 

#define IManipulationProcessor_ProcessDown(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessDown(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessMove(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessMove(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessUp(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessUp(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessDownWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessDownWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_ProcessMoveWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessMoveWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_ProcessUpWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessUpWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_GetVelocityX(This,velocityX)	\
    ( (This)->lpVtbl -> GetVelocityX(This,velocityX) ) 

#define IManipulationProcessor_GetVelocityY(This,velocityY)	\
    ( (This)->lpVtbl -> GetVelocityY(This,velocityY) ) 

#define IManipulationProcessor_GetExpansionVelocity(This,expansionVelocity)	\
    ( (This)->lpVtbl -> GetExpansionVelocity(This,expansionVelocity) ) 

#define IManipulationProcessor_GetAngularVelocity(This,angularVelocity)	\
    ( (This)->lpVtbl -> GetAngularVelocity(This,angularVelocity) ) 

#define IManipulationProcessor_get_MinimumScaleRotateRadius(This,minRadius)	\
    ( (This)->lpVtbl -> get_MinimumScaleRotateRadius(This,minRadius) ) 

#define IManipulationProcessor_put_MinimumScaleRotateRadius(This,minRadius)	\
    ( (This)->lpVtbl -> put_MinimumScaleRotateRadius(This,minRadius) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManipulationProcessor_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_InertiaProcessor;

#ifdef __cplusplus

class DECLSPEC_UUID("abb27087-4ce0-4e58-a0cb-e24df96814be")
InertiaProcessor;
#endif

EXTERN_C const CLSID CLSID_ManipulationProcessor;

#ifdef __cplusplus

class DECLSPEC_UUID("597D4FB0-47FD-4aff-89B9-C6CFAE8CF08E")
ManipulationProcessor;
#endif
#endif /* __ManipulationsLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\LpmApi.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    46490
//  $AgreementName:  public license reservation protocol daemon
//  $AgreementType:  oss license
//  $ExternalOrigin: university of southern california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    osmaner
//  $Module:   published_inc
//
//$ENDTAG

/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    LPMAPI.H - Include file for Local Policy Module

Abstract:

    This module defines the LPM structures and types.

Revision History:

    There is no support for ACS in Windows XP or later versions of Windows.

--*/

/****************************************************************************

            RSVPD -- ReSerVation Protocol Daemon

                USC Information Sciences Institute
                Marina del Rey, California

        Original Version: Shai Herzog, Nov. 1993.
        Current Version:  Steven Berson & Bob Braden, may 1996.

  Copyright (c) 1996 by the University of Southern California
  All rights reserved.

  Permission to use, copy, modify, and distribute this software and its
  documentation in source and binary forms for any purpose and without
  fee is hereby granted, provided that both the above copyright notice
  and this permission notice appear in all copies, and that any
  documentation, advertising materials, and other materials related to
  such distribution and use acknowledge that the software was developed
  in part by the University of Southern California, Information
  Sciences Institute.  The name of the University may not be used to
  endorse or promote products derived from this software without
  specific prior written permission.

  THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
  the suitability of this software for any purpose.  THIS SOFTWARE IS
  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  Other copyrights might apply to parts of this software and are so
  noted when applicable.

********************************************************************/

#ifndef __LPMAPI_H_
#define __LPMAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef CALLBACK
#define CALLBACK __stdcall
#endif

#ifndef APIENTRY
#define APIENTRY FAR __stdcall
#endif

/*
 *  Standard format of an RSVP object header
 */
typedef struct {

    USHORT  obj_length; /* Length in bytes */
    UCHAR   obj_class;  /* Class (values defined below) */
    UCHAR   obj_ctype;  /* C-Type (values defined below) */

} RsvpObjHdr;

#define ObjLength(x)   ((RsvpObjHdr *)x)->obj_length
#define ObjCType(x)    ((RsvpObjHdr *)x)->obj_ctype
#define ObjClass(x)    ((RsvpObjHdr *)x)->obj_class
#define ObjData(x)     ((RsvpObjHdr *)(x)+1)

/*
 *  Define object classes: Class-Num values
 */
#define class_NULL              0
#define class_SESSION           1
#define class_SESSION_GROUP     2
#define class_RSVP_HOP          3
#define class_INTEGRITY         4
#define class_TIME_VALUES       5
#define class_ERROR_SPEC        6
#define class_SCOPE             7
#define class_STYLE             8
#define class_FLOWSPEC          9   // these two are the same
#define class_IS_FLOWSPEC       9  // since we added IS in front of the name
#define class_FILTER_SPEC       10
#define class_SENDER_TEMPLATE   11
#define class_SENDER_TSPEC      12
#define class_ADSPEC            13
#define class_POLICY_DATA       14
#define class_CONFIRM           15
#define class_MAX               15

/*
 *  RSVP SESSION object
 */
#define ctype_SESSION_ipv4      1
#define ctype_SESSION_ipv4GPI   3   /* IPSEC: Generalized Port Id */

#define SESSFLG_E_Police    0x01    /* E_Police: Entry policing flag*/

typedef struct {

    IN_ADDR sess_destaddr;  // DestAddress
    UCHAR   sess_protid;    // Protocol Id
    UCHAR   sess_flags;     // Use the flags defined above
    USHORT  sess_destport;  // DestPort

} Session_IPv4;

/*    GPI versions have virtual dest port instead of dest port; this
 *    changes the interpretation but not the format, so we do not
 *    define new structs for GPI.
 */

typedef struct {

    RsvpObjHdr          sess_header;

    union {

        Session_IPv4    sess_ipv4;

    }       sess_u;

} RSVP_SESSION;

// Useful defines to access components of SESSION obect
#define Sess4Addr       sess_u.sess_ipv4.sess_destaddr
#define Sess4Port       sess_u.sess_ipv4.sess_destport
#define Sess4Protocol   sess_u.sess_ipv4.sess_protid
#define Sess4Flags      sess_u.sess_ipv4.sess_flags

/*
 *  RSVP HOP object
 */
#define ctype_RSVP_HOP_ipv4 1

typedef struct {

    IN_ADDR     hop_ipaddr; // Next/Previous Hop Address
    ULONG       hop_LIH;        // Logical Interface Handle

} Rsvp_Hop_IPv4;

typedef struct {

    RsvpObjHdr          hop_header;

    union {

        Rsvp_Hop_IPv4   hop_ipv4;

    } hop_u;

} RSVP_HOP;

#define Hop4LIH    hop_u.hop_ipv4.hop_LIH
#define Hop4Addr   hop_u.hop_ipv4.hop_ipaddr

/*
 *  RSVP STYLE object
 */

//  Define values for option vector

#define Opt_Share_mask  0x00000018  // 2 bits: Sharing control
#define Opt_Distinct    0x00000008  // Distinct reservations
#define Opt_Shared      0x00000010  // Shared reservations

#define Opt_SndSel_mask 0x00000007  // 3 bits: Sender selection
#define Opt_Wildcard    0x00000001  // Wildcard scope
#define Opt_Explicit    0x00000002  // Explicit scope

#define Style_is_Wildcard(p)    (((p)&Opt_SndSel_mask) == Opt_Wildcard)
#define Style_is_Shared(p)      (((p)&Opt_Share_mask) == Opt_Shared)

//  Define style values
#define STYLE_WF    Opt_Shared + Opt_Wildcard
#define STYLE_FF    Opt_Distinct + Opt_Explicit
#define STYLE_SE    Opt_Shared + Opt_Explicit

#define ctype_STYLE 1

typedef struct {

    RsvpObjHdr  style_header;

    ULONG       style_word;

} RESV_STYLE;

/*
 *  RSVP FILTER SPEC object
 */
#define ctype_FILTER_SPEC_ipv4      1   // IPv4 FILTER_SPEC
#define ctype_FILTER_SPEC_ipv4GPI   4   // IPv4/GPI FILTER_SPEC

typedef struct {

    IN_ADDR filt_ipaddr;    // IPv4 SrcAddress
    USHORT  filt_unused;
    USHORT  filt_port;      // SrcPort

} Filter_Spec_IPv4;

typedef struct {

    IN_ADDR filt_ipaddr;    // IPv4 SrcAddress
    ULONG   filt_gpi;       // Generalized Port Id

} Filter_Spec_IPv4GPI;

typedef struct {

    RsvpObjHdr              filt_header;

    union {

        Filter_Spec_IPv4    filt_ipv4;
        Filter_Spec_IPv4GPI filt_ipv4gpi;

    } filt_u;

} FILTER_SPEC;

#define FilterSrcaddr   filt_u.filt_ipv4.filt_ipaddr
#define FilterSrcport   filt_u.filt_ipv4.filt_port

/*
 *  RSVP SENDER_TEMPLATE object
 */
#define ctype_SENDER_TEMPLATE_ipv4      1   // IPv4 SENDER_TEMPLATE
#define ctype_SENDER_TEMPLATE_ipv4GPI   4   // IPv4/GPI SENDER_TEMPLATE

typedef FILTER_SPEC  SENDER_TEMPLATE;       // Identical to FILTER_SPEC

/*
 *  RSVP SCOPE object class
 */
#define ctype_SCOPE_list_ipv4       1

typedef struct {

    IN_ADDR     scopl_ipaddr[1];        // var-len list of IP sender addrs

} Scope_list_ipv4;

typedef struct {

    RsvpObjHdr          scopl_header;

    union {

        Scope_list_ipv4 scopl_ipv4;

    } scope_u;

} RSVP_SCOPE;

#define Scope4Addr      scope_u.scopl_ipv4.scopl_ipaddr
#define ScopeCnt(scp)   ((ObjLength(scp)-sizeof(RsvpObjHdr))/sizeof(struct in_addr))
#define ScopeLen(cnt)   (cnt*sizeof(struct in_addr)+sizeof(RsvpObjHdr))


/*
 *  ERROR_SPEC object class
 */
#define ctype_ERROR_SPEC_ipv4   1

typedef struct {
    struct in_addr  errs_errnode;   /* Error Node Address       */
    u_char      errs_flags; /* Flags:           */
#define ERROR_SPECF_InPlace 0x01    /*   Left resv in place     */
#define ERROR_SPECF_NotGuilty   0x02    /*   This rcvr not guilty   */

    UCHAR       errs_code;  /* Error Code (def'd below) */
    USHORT      errs_value; /* Error Value      */
#define ERR_FORWARD_OK  0x8000      /* Flag: OK to forward state */
#define Error_Usage(x)  (((x)>>12)&3)
#define ERR_Usage_globl 0x00        /* Globally-defined sub-code */
#define ERR_Usage_local 0x10        /* Locally-defined sub-code */
#define ERR_Usage_serv  0x11        /* Service-defined sub-code */
#define ERR_global_mask 0x0fff      /* Sub-code bits in Error Val */

}    Error_Spec_IPv4;


typedef struct {

    RsvpObjHdr  errs_header;

    union {

        Error_Spec_IPv4 errs_ipv4;

    } errs_u;

}    ERROR_SPEC;

#define errspec4_enode  errs_u.errs_ipv4.errs_errnode
#define errspec4_code   errs_u.errs_ipv4.errs_code
#define errspec4_value  errs_u.errs_ipv4.errs_value
#define errspec4_flags  errs_u.errs_ipv4.errs_flags


/*
 *  POLICY_DATA object class
 *
 *      Contents are Opaque RSVP/SBM
 */
#define ctype_POLICY_DATA   1

typedef struct {

    RsvpObjHdr      PolicyObjHdr;

    USHORT          usPeOffset;     // Offset to the start of Policy Elements
                                    // from the begining of Policy Data

    USHORT          usReserved;

} POLICY_DATA;

#define PD_HDR_LEN  sizeof(POLICY_DATA)

typedef struct {

    USHORT      usPeLength;     // Policy Element length

    USHORT      usPeType;       // Policy Element type

    UCHAR       ucPeData[4];    // Just a place holder to the start of
                                // Policy Element data
} POLICY_ELEMENT;

#define PE_HDR_LEN  (2 * sizeof(USHORT))

/**************************************************************************
 *
 *  Int-Serv Data Structures
 *
 **************************************************************************/

/*
 *  Service numbers
 */
#define GENERAL_INFO            1
#define GUARANTEED_SERV         2
#define PREDICTIVE_SERV         3
#define CONTROLLED_DELAY_SERV   4
#define CONTROLLED_LOAD_SERV    5
#define QUALITATIVE_SERV        6

/*
 *  Well-known parameter IDs
 */
enum  int_serv_wkp {
    IS_WKP_HOP_CNT =        4,
    IS_WKP_PATH_BW =        6,
    IS_WKP_MIN_LATENCY =    8,
    IS_WKP_COMPOSED_MTU =   10,
    IS_WKP_TB_TSPEC =       127, /* Token-bucket TSPEC parm */
    IS_WKP_Q_TSPEC =        128
};


/*
 *  Int-serv Main header
 */
typedef struct {

    UCHAR   ismh_version;   // Version
    UCHAR   ismh_unused;
    USHORT  ismh_len32b;    // # 32-bit words excluding this hdr

} IntServMainHdr;

#define INTSERV_VERS_MASK   0xf0
#define INTSERV_VERSION0    0
#define Intserv_Version(x)      (((x)&INTSERV_VERS_MASK)>>4)
#define Intserv_Version_OK(x)   (((x)->ismh_version&INTSERV_VERS_MASK)== \
                                INTSERV_VERSION0)

// Convert ishm_length to equivalent RSVP object size, for checking
#define Intserv_Obj_size(x) (((IntServMainHdr *)(x))->ismh_len32b * 4 + \
                            sizeof(IntServMainHdr) + sizeof(RsvpObjHdr))

/*
 *  Int-serv Service Element Header
 */

// Flag: Break bit
#define ISSH_BREAK_BIT    0x80

typedef struct {

    UCHAR       issh_service;   // Service number
    UCHAR       issh_flags;     // Flag byte
    USHORT      issh_len32b;    // #32-bit words excluding this hdr

}  IntServServiceHdr;

#define Issh_len32b(p)  ((p)->issh_len32b)

/*
 *  Int-serv Parameter Element Header
 */
#define ISPH_FLG_INV    0x80        // Flag: Invalid

typedef struct {

    UCHAR       isph_parm_num;  // Parameter number
    UCHAR       isph_flags;     // Flags
    USHORT      isph_len32b;    // #32-bit words excluding this hdr

}  IntServParmHdr;

#define Next_Main_Hdr(p)   (IntServMainHdr *)((ULONG *)(p)+1+(p)->ismh_len32b)
#define Next_Serv_Hdr(p)   (IntServServiceHdr *)((ULONG *)(p)+1+(p)->issh_len32b)
#define Next_Parm_Hdr(p)   (IntServParmHdr *)((ULONG *)(p)+1+(p)->isph_len32b)

/*
 *  Generic Tspec Parameters
 */
typedef struct {

    FLOAT       TB_Tspec_r;     // Token bucket rate (B/sec)
    FLOAT       TB_Tspec_b;     // Token bucket depth (B)
    FLOAT       TB_Tspec_p;     // Peak data rate (B/sec)
    ULONG       TB_Tspec_m;     // Min Policed Unit (B)
    ULONG       TB_Tspec_M;     // Max pkt size (B)

} GenTspecParms;

/*
 *  Generic Tspec
 */
typedef struct {

    IntServServiceHdr   gen_Tspec_serv_hdr; // (GENERAL_INFO, length)

    IntServParmHdr      gen_Tspec_parm_hdr; // (IS_WKP_TB_TSPEC)

    GenTspecParms       gen_Tspec_parms;

} GenTspec;

#define gtspec_r        gen_Tspec_parms.TB_Tspec_r
#define gtspec_b        gen_Tspec_parms.TB_Tspec_b
#define gtspec_m        gen_Tspec_parms.TB_Tspec_m
#define gtspec_M        gen_Tspec_parms.TB_Tspec_M
#define gtspec_p        gen_Tspec_parms.TB_Tspec_p
#define gtspec_parmno   gen_Tspec_parm_hdr.isph_parm_num
#define gtspec_flags    gen_Tspec_parm_hdr.isph_flags

#define gtspec_len      (sizeof(GenTspec) - sizeof(IntServServiceHdr))


/* contents of qualitative tspec */

typedef struct {

    ULONG       TB_Tspec_M;     // Max pkt size (M)

} QualTspecParms;


typedef struct {

    IntServServiceHdr   qual_Tspec_serv_hdr; // (QUALITATIVE_SERV, length)

    IntServParmHdr      qual_Tspec_parm_hdr; // (IS_WKP_Q_TSPEC)

    QualTspecParms      qual_Tspec_parms;

} QualTspec;

typedef struct {

    IntServServiceHdr   Q_spec_serv_hdr;    // (QUALITATIVE_SERV,0,len)

    IntServParmHdr      Q_spec_parm_hdr;    // (IS_WKP_Q_TSPEC)

    QualTspecParms      Q_spec_parms;       // QUALITATIVE Tspec parameters

}  QualAppFlowSpec;

#define QAspec_M        Q_spec_parms.TB_Tspec_M

/*
 *  Contents of int-serv Tspec
 */
typedef struct {

    IntServMainHdr  st_mh;

    union {

        GenTspec    gen_stspec; // Generic Tspec
        QualTspec   qual_stspec;

    } tspec_u;

} IntServTspecBody;

/*
 *  SENDER_TSPEC class object
 */
#define ctype_SENDER_TSPEC  2

typedef struct {

    RsvpObjHdr          stspec_header;

    IntServTspecBody    stspec_body;

} SENDER_TSPEC;

/*
 *  Controlled-Load Flowspec
 */
typedef struct {

    IntServServiceHdr   CL_spec_serv_hdr;    // (CONTROLLED_LOAD_SERV,0,len)

    IntServParmHdr      CL_spec_parm_hdr;    // (IS_WKP_TB_TSPEC)

    GenTspecParms       CL_spec_parms;       // GENERIC Tspec parameters

}  CtrlLoadFlowspec;

#define CLspec_r        CL_spec_parms.TB_Tspec_r
#define CLspec_b        CL_spec_parms.TB_Tspec_b
#define CLspec_p        CL_spec_parms.TB_Tspec_p
#define CLspec_m        CL_spec_parms.TB_Tspec_m
#define CLspec_M        CL_spec_parms.TB_Tspec_M
#define CLspec_parmno   CL_spec_parm_hdr.isph_parm_num
#define CLspec_flags    CL_spec_parm_hdr.isph_flags
#define CLspec_len32b   CL_spec_parm_hdr.isph_len32b

#define CLspec_len      (sizeof(CtrlLoadFlowspec) - sizeof(IntServServiceHdr))

/*  Service-specific Parameter IDs
 */
enum    {

    IS_GUAR_RSPEC =     130,

    GUAR_ADSPARM_C  =   131,
    GUAR_ADSPARM_D  =   132,
    GUAR_ADSPARM_Ctot = 133,
    GUAR_ADSPARM_Dtot = 134,
    GUAR_ADSPARM_Csum = 135,
    GUAR_ADSPARM_Dsum = 136

};

/*
 *  Guaranteed Rspec parameters
 */
typedef struct {

    FLOAT       Guar_R;         //  Guaranteed Rate B/s
    ULONG       Guar_S;         //  Slack term secs

} GuarRspec;

/*
 *  Guaranteed Flowspec
 */
typedef struct {

    IntServServiceHdr   Guar_serv_hdr;      // (GUARANTEED, 0, length)

    IntServParmHdr      Guar_Tspec_hdr;     // (IS_WKP_TB_TSPEC,)
    GenTspecParms       Guar_Tspec_parms;   // GENERIC Tspec parms

    IntServParmHdr      Guar_Rspec_hdr;     // (IS_GUAR_RSPEC)
    GuarRspec           Guar_Rspec;         // Guaranteed rate (B/sec)

}   GuarFlowSpec;

#define Gspec_r         Guar_Tspec_parms.TB_Tspec_r
#define Gspec_b         Guar_Tspec_parms.TB_Tspec_b
#define Gspec_p         Guar_Tspec_parms.TB_Tspec_p
#define Gspec_m         Guar_Tspec_parms.TB_Tspec_m
#define Gspec_M         Guar_Tspec_parms.TB_Tspec_M
#define Gspec_R         Guar_Rspec.Guar_R
#define Gspec_S         Guar_Rspec.Guar_S
#define Gspec_T_parmno  Guar_Tspec_hdr.isph_parm_num
#define Gspec_T_flags   Guar_Tspec_hdr.isph_flags
#define Gspec_R_parmno  Guar_Rspec_hdr.isph_parm_num
#define Gspec_R_flags   Guar_Rspec_hdr.isph_flags

#define Gspec_len       (sizeof(GuarFlowSpec) - sizeof(IntServServiceHdr))

/*
 *  Contents of int-serv flowspec
 */
typedef struct {

    IntServMainHdr          spec_mh;

    union {

        CtrlLoadFlowspec    CL_spec;   // Controlled-Load service

        GuarFlowSpec        G_spec;    // Guaranteed service
        
        QualAppFlowSpec     Q_spec;
        
    } spec_u;

}   IntServFlowSpec;

#define ISmh_len32b     spec_mh.ismh_len32b
#define ISmh_version    spec_mh.ismh_version
#define ISmh_unused     spec_mh.ismh_unused

/*
 *  Int-Serv FLOWSPEC object
 */
#define ctype_FLOWSPEC_Intserv0  2  // The int-serv flowspec (v.0)

typedef struct {

    RsvpObjHdr          flow_header;

    IntServFlowSpec     flow_body;

}IS_FLOWSPEC;


/*
 *  FLOW DESCRIPTOR
 */

typedef struct flow_desc {

    union {
        SENDER_TSPEC   *stspec;
        IS_FLOWSPEC    *isflow;
    } u1;

    union {
       SENDER_TEMPLATE *stemp;
       FILTER_SPEC     *fspec;
    } u2;

} FLOW_DESC;

#define FdSenderTspec       u1.stspec
#define FdIsFlowSpec        u1.isflow

#define FdSenderTemplate    u2.stemp
#define FdFilterSpec        u2.fspec

/*
 *  ADSPEC class object
 *
 *      Opaque to RSVP -- Contents defined in rapi_lib.h
 */
#define ctype_ADSPEC_INTSERV    2

/*
 *  Guaranteed service Adspec parameters -- fixed part
 */
typedef struct {

    IntServServiceHdr   Gads_serv_hdr;  // GUARANTEED, x, len
    
    IntServParmHdr      Gads_Ctot_hdr;  // GUAR_ADSPARM_Ctot
    ULONG               Gads_Ctot;
    
    IntServParmHdr      Gads_Dtot_hdr;  // (GUAR_ADSPARM_Dtot
    ULONG               Gads_Dtot;
    
    IntServParmHdr      Gads_Csum_hdr;  // GUAR_ADSPARM_Csum
    ULONG               Gads_Csum;
    
    IntServParmHdr      Gads_Dsum_hdr;  // GUAR_ADSPARM_Dsum
    ULONG               Gads_Dsum;
    
    /*
     *  May be followed by override general param values
     */
} Gads_parms_t;


/*
 *  General Path Characterization Parameters
 */
typedef struct {

    IntServServiceHdr   gen_parm_hdr;           // GENERAL_INFO, len

    IntServParmHdr      gen_parm_hopcnt_hdr;    // (IS_WKP_HOP_CNT
    ULONG               gen_parm_hopcnt;

    IntServParmHdr      gen_parm_pathbw_hdr;    // IS_WKP_PATH_BW
    FLOAT               gen_parm_path_bw;

    IntServParmHdr      gen_parm_minlat_hdr;    // IS_WKP_MIN_LATENCY
    ULONG               gen_parm_min_latency;

    IntServParmHdr      gen_parm_compmtu_hdr;   // IS_WKP_COMPOSED_MTU 
    ULONG               gen_parm_composed_MTU;
    
} GenAdspecParams;

/*
 *  Contents of (minimal) int-serv Adspec
 */
typedef struct {
    IntServMainHdr      adspec_mh;      // Main header
    
    GenAdspecParams     adspec_genparms;// General char parm fragment
    
    /*
     *  Followed by variable-length fragments for some or all
     *  services.  These can be minimal length fragments.
     */
     
} IS_ADSPEC_BODY;


#define GEN_ADSPEC_LEN (sizeof(Object_header) + sizeof(IS_adsbody_t ) )

typedef struct {

    RsvpObjHdr      adspec_header;
    
    IS_ADSPEC_BODY  adspec_body;    /* Defined in rapi_lib.h */

} ADSPEC;


// RSVP message types

#define RSVP_PATH       1
#define RSVP_RESV       2
#define RSVP_PATH_ERR   3
#define RSVP_RESV_ERR   4
#define RSVP_PATH_TEAR  5
#define RSVP_RESV_TEAR  6

/*  RSVP error codes
 */
#define RSVP_Err_NONE       0   /* No error (CONFIRM)       */
#define RSVP_Erv_Nonev      0   /*    No-error Error Value  */

/* Admission Control failure    */
#define RSVP_Err_ADMISSION  1

/* Globally-defined sub-codes for : Admission Control failure */
#define RSVP_Erv_Other      0   /* Unspecified cause        */
#define RSVP_Erv_DelayBnd   1   /* Cannot meet delay bound req  */
#define RSVP_Erv_Bandwidth  2   /* Insufficient bandwidth   */
#define RSVP_Erv_MTU        3   /* MTU in flowspec too large    */

// Microsoft specific error values
#define RSVP_Erv_Flow_Rate          0x8001
#define RSVP_Erv_Bucket_szie        0x8002
#define RSVP_Erv_Peak_Rate          0x8003
#define RSVP_Erv_Min_Policied_size  0x8004

/* Policy control failure   */
#define RSVP_Err_POLICY     2

// Policy error values from Identity draft
#define POLICY_ERRV_NO_MORE_INFO                1
#define POLICY_ERRV_UNSUPPORTED_CREDENTIAL_TYPE 2
#define POLICY_ERRV_INSUFFICIENT_PRIVILEGES     3
#define POLICY_ERRV_EXPIRED_CREDENTIALS         4
#define POLICY_ERRV_IDENTITY_CHANGED            5

// Microsoft specific policy error values

#define POLICY_ERRV_UNKNOWN                         0

#define POLICY_ERRV_GLOBAL_DEF_FLOW_COUNT           1
#define POLICY_ERRV_GLOBAL_GRP_FLOW_COUNT           2
#define POLICY_ERRV_GLOBAL_USER_FLOW_COUNT          3
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_COUNT   4
#define POLICY_ERRV_SUBNET_DEF_FLOW_COUNT           5
#define POLICY_ERRV_SUBNET_GRP_FLOW_COUNT           6
#define POLICY_ERRV_SUBNET_USER_FLOW_COUNT          7
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_COUNT   8

#define POLICY_ERRV_GLOBAL_DEF_FLOW_DURATION        9
#define POLICY_ERRV_GLOBAL_GRP_FLOW_DURATION        10
#define POLICY_ERRV_GLOBAL_USER_FLOW_DURATION       11
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_DURATION 12
#define POLICY_ERRV_SUBNET_DEF_FLOW_DURATION        13
#define POLICY_ERRV_SUBNET_GRP_FLOW_DURATION        14
#define POLICY_ERRV_SUBNET_USER_FLOW_DURATION       15
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_DURATION   16

#define POLICY_ERRV_GLOBAL_DEF_FLOW_RATE            17
#define POLICY_ERRV_GLOBAL_GRP_FLOW_RATE            18
#define POLICY_ERRV_GLOBAL_USER_FLOW_RATE           19
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_RATE    20
#define POLICY_ERRV_SUBNET_DEF_FLOW_RATE            21
#define POLICY_ERRV_SUBNET_GRP_FLOW_RATE            22
#define POLICY_ERRV_SUBNET_USER_FLOW_RATE           23
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_RATE    24

#define POLICY_ERRV_GLOBAL_DEF_PEAK_RATE            25
#define POLICY_ERRV_GLOBAL_GRP_PEAK_RATE            26
#define POLICY_ERRV_GLOBAL_USER_PEAK_RATE           27
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_PEAK_RATE    28
#define POLICY_ERRV_SUBNET_DEF_PEAK_RATE            29
#define POLICY_ERRV_SUBNET_GRP_PEAK_RATE            30
#define POLICY_ERRV_SUBNET_USER_PEAK_RATE           31
#define POLICY_ERRV_SUBNET_UNAUTH_USER_PEAK_RATE    32

#define POLICY_ERRV_GLOBAL_DEF_SUM_FLOW_RATE        33
#define POLICY_ERRV_GLOBAL_GRP_SUM_FLOW_RATE        34
#define POLICY_ERRV_GLOBAL_USER_SUM_FLOW_RATE       35
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_FLOW_RATE 36
#define POLICY_ERRV_SUBNET_DEF_SUM_FLOW_RATE        37
#define POLICY_ERRV_SUBNET_GRP_SUM_FLOW_RATE        38
#define POLICY_ERRV_SUBNET_USER_SUM_FLOW_RATE       39
#define POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_FLOW_RATE 40

#define POLICY_ERRV_GLOBAL_DEF_SUM_PEAK_RATE        41
#define POLICY_ERRV_GLOBAL_GRP_SUM_PEAK_RATE        42
#define POLICY_ERRV_GLOBAL_USER_SUM_PEAK_RATE       43
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_PEAK_RATE 44
#define POLICY_ERRV_SUBNET_DEF_SUM_PEAK_RATE        45
#define POLICY_ERRV_SUBNET_GRP_SUM_PEAK_RATE        46
#define POLICY_ERRV_SUBNET_USER_SUM_PEAK_RATE       47
#define POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_PEAK_RATE 48

#define POLICY_ERRV_UNKNOWN_USER                    49
#define POLICY_ERRV_NO_PRIVILEGES                   50
#define POLICY_ERRV_EXPIRED_USER_TOKEN              51
#define POLICY_ERRV_NO_RESOURCES                    52
#define POLICY_ERRV_PRE_EMPTED                      53
#define POLICY_ERRV_USER_CHANGED                    54
#define POLICY_ERRV_NO_ACCEPTS                      55
#define POLICY_ERRV_NO_MEMORY                       56
#define POLICY_ERRV_CRAZY_FLOWSPEC                  57


// Other RSVP defined Error codes
#define RSVP_Err_NO_PATH        3   /* No path state for Resv   */
#define RSVP_Err_NO_SENDER      4   /* No sender info for Resv  */
#define RSVP_Err_BAD_STYLE      5   /* Conflicting style        */
#define RSVP_Err_UNKNOWN_STYLE  6   /* Unknown reservation style    */
#define RSVP_Err_BAD_DSTPORT    7   /* Conflicting DstPort in Sess  */
#define RSVP_Err_BAD_SNDPORT    8   /* Conflicting Sender port  */
#define RSVP_Err_AMBIG_FILTER   9   /* Ambiguous Filter spec in Resv*/

#define RSVP_Err_PREEMPTED      12  /* Service Preempted        */

/* Unknown object Class-Num */
#define RSVP_Err_UNKN_OBJ_CLASS 13
/*   ErrVal = Class_num, CType  */

 /* Unknown object C-Type    */
#define RSVP_Err_UNKNOWN_CTYPE  14
/*   ErrVal = Class_num, CType  */

#define RSVP_Err_API_ERROR      20  /* API client error     */
/*   ErrVal = API error code    */

/* Traffic Control error    */
#define RSVP_Err_TC_ERROR       21

/* Globally-defined sub-codes for : Traffic Control errors */

#define RSVP_Erv_Conflict_Serv  01  /* Service Conflict     */
#define RSVP_Erv_No_Serv        02  /* Unknown Service      */
#define RSVP_Erv_Crazy_Flowspec 03  /* Unreasonable Flowspec    */
#define RSVP_Erv_Crazy_Tspec    04  /* Unreasonable Tspec       */

#define RSVP_Err_TC_SYS_ERROR   22  /* Traffic control system error */
      /* ErrVal = kernel error code   */


/* RSVP System error      */
#define RSVP_Err_RSVP_SYS_ERROR 23

/* Globally-defined sub-codes for : RSVP system errors */
#define RSVP_Erv_MEMORY         1   /* Out of memory */
#define RSVP_Erv_API            2   /* API logic error */

// Identity Policy elements related defines

// Reseved Identity PE types
#define LPM_PE_USER_IDENTITY    2
#define LPM_PE_APP_IDENTITY     3

// Defines for Identity error values
#define ERROR_NO_MORE_INFO          1
#define UNSUPPORTED_CREDENTIAL_TYPE 2
#define INSUFFICIENT_PRIVILEGES     3
#define EXPIRED_CREDENTIAL          4
#define IDENTITY_CHANGED            5


typedef struct {

    USHORT      usIdErrLength;

    UCHAR       ucAType;

    UCHAR       ucSubType;

    USHORT      usReserved;

    USHORT      usIdErrorValue;

    UCHAR       ucIdErrData[4];

} ID_ERROR_OBJECT;

    
#define ID_ERR_OBJ_HDR_LEN     (sizeof(ID_ERROR_OBJECT) - 4 * sizeof(UCHAR) )


/*

    LPM API specific definitions

*/

/**************************************

    LPM_Initialize

***************************************/

DECLARE_HANDLE(LPM_HANDLE);

DECLARE_HANDLE(RHANDLE);

typedef ULONG   LPV;

typedef USHORT  PETYPE;

#define LPM_OK  0

typedef int     MSG_TYPE;

typedef struct rsvpmsgobjs {

    MSG_TYPE        RsvpMsgType;
    
    RSVP_SESSION    *pRsvpSession;
    
    RSVP_HOP        *pRsvpFromHop;
    
    RSVP_HOP        *pRsvpToHop;
    
    RESV_STYLE      *pResvStyle;
    
    RSVP_SCOPE      *pRsvpScope;
    
    int             FlowDescCount;
    
    FLOW_DESC       *pFlowDescs;
    
    int             PdObjectCount;
    
    POLICY_DATA     **ppPdObjects;
    
    ERROR_SPEC      *pErrorSpec;

    ADSPEC          *pAdspec;
    
} RSVP_MSG_OBJS;

#if DBG
typedef void *
(APIENTRY * PALLOCMEM) ( DWORD Size, char *szFileName, DWORD nLine );
#else
typedef void *
(APIENTRY * PALLOCMEM) ( DWORD Size );
#endif

#if DBG
typedef void
(APIENTRY * PFREEMEM) ( void *pv, char *szFileName, DWORD nLine );
#else
typedef void
(APIENTRY * PFREEMEM) ( void *pv );
#endif

typedef struct policy_decision
{
    LPV             lpvResult;        // Use the LPV values from above
    
    WORD            wPolicyErrCode;   // RSVP defined error codes
    
    WORD            wPolicyErrValue;  // RSVP defined error values
    
} POLICY_DECISION;

typedef
ULONG *
(CALLBACK * CBADMITRESULT) (    
        LPM_HANDLE      LpmHandle,
        
        RHANDLE         RequestHandle,

        ULONG           ulPcmActionFlags,
    
        int             LpmError,
        
        int             PolicyDecisionsCount,
        
        POLICY_DECISION *pPolicyDecisions );

typedef
ULONG *
(CALLBACK * CBGETRSVPOBJECTS) (  

        LPM_HANDLE  LpmHandle,
        
        RHANDLE     RequestHandle,
        
        int         LpmError,
        
        int         RsvpObjectsCount,

        RsvpObjHdr  **ppRsvpObjects );

// The above 2 call backs can return the following errors

#define INV_LPM_HANDLE      1       // Supplied LpmHandle is invalid
#define LPM_TIME_OUT        2       // LPM has returned results after the time limit
#define INV_REQ_HANDLE      3       // Supplied Request handle is invalid
#define DUP_RESULTS         4       // LPM has already returned results for this request
#define INV_RESULTS         5       // Results supplied are invalid

typedef struct lpminitinfo {

    DWORD           PcmVersionNumber;
    
    DWORD           ResultTimeLimit;
    
    int             ConfiguredLpmCount;
    
    PALLOCMEM       AllocMemory;
    
    PFREEMEM        FreeMemory;
    
    CBADMITRESULT   PcmAdmitResultCallback;
    
    CBGETRSVPOBJECTS GetRsvpObjectsCallback;
    
} LPM_INIT_INFO;

// Valid PE types
// XXX ISSUE - Is 0xFFFF a better choice?
#define LPM_PE_ALL_TYPES        0

// Current LPM API version number
#define LPM_API_VERSION_1        1

// Current PCM version number
#define PCM_VERSION_1    1

ULONG
APIENTRY
LPM_Initialize (

    IN  LPM_HANDLE      LpmHandle,
    
    IN  LPM_INIT_INFO   *pLpmInitInfo,
    
    OUT DWORD           *pLpmVersionNumber,
    
    OUT PETYPE          *pSupportedPeType,
    
    OUT VOID            *Reserved );

/**************************************

    LPM_Deiitialize
    
***************************************/

ULONG
APIENTRY
LPM_Deinitialize (    
    IN  LPM_HANDLE      LpmHandle );
            

/**************************************

    LPM_AdmitRsvpMsg

***************************************/

// Valid LPV - LPM Priority Values
#define LPV_RESERVED        0
#define LPV_MIN_PRIORITY    1
#define LPV_MAX_PRIORITY    0xFF00
#define LPV_DROP_MSG        0xFFFD
#define LPV_DONT_CARE       0xFFFE
#define LPV_REJECT          0xFFFF

// Valid values for PcmActionFlags
#define FORCE_IMMEDIATE_REFRESH         1

// Function return values for LPM_AdmitResvMsg
#define LPM_RESULT_READY    0
#define LPM_RESULT_DEFER    1

ULONG
APIENTRY
LPM_AdmitRsvpMsg (

    IN  RHANDLE         PcmReqHandle,
    
    IN  RSVP_HOP        *pRecvdIntf,
    
    IN  RSVP_MSG_OBJS   *pRsvpMsgObjs,
    
    IN  int             RcvdRsvpMsgLength,
    
    IN  UCHAR           *RcvdRsvpMsg,

    OUT ULONG           *pulPcmActionFlags,
    
    OUT POLICY_DECISION *pPolicyDecisions,
    
    OUT void            *Reserved );


/**************************************

    LPM_GetRsvpObjects

***************************************/

// Function return values are defined in LPM_AdmitResvMsg section

ULONG
APIENTRY
LPM_GetRsvpObjects (

    IN  RHANDLE         PcmReqHandle,
    
    IN  ULONG           MaxPdSize,
    
    IN  RSVP_HOP        *SendingIntfAddr,
    
    IN  RSVP_MSG_OBJS   *pRsvpMsgObjs,
    
    OUT int             *pRsvpObjectsCount,

    OUT RsvpObjHdr      ***pppRsvpObjects,
    
    OUT void            *Reserved );


/**************************************

    LPM_DeleteState

***************************************/

// TearDown reasons

#define RCVD_PATH_TEAR      1
#define RCVD_RESV_TEAR      2
#define ADM_CTRL_FAILED     3
#define STATE_TIMEOUT       4
#define FLOW_DURATION       5


VOID
APIENTRY
LPM_DeleteState(

    IN  RSVP_HOP        *pRcvdIfAddr,
    
    IN  MSG_TYPE        RsvpMsgType,
    
    IN  RSVP_SESSION    *pRsvpSession,
    
    IN  RSVP_HOP        *pRsvpFromHop,
    
    IN  RESV_STYLE      *pResvStyle,
    
    IN  int             FilterSpecCount,
    
    IN  FILTER_SPEC     **ppFilterSpecList,
    
    IN  int             TearDownReason );

/**************************************

    LPM_IpAddrTable

***************************************/

typedef struct lpmiptable {

    ULONG       ulIfIndex;  // SNMP index for this interface

    ULONG       MediaType;  // As defined in IPIFCONS.H

    IN_ADDR     IfIpAddr;   // Interface IP address

    IN_ADDR     IfNetMask;  // Interface subnet mask

} LPMIPTABLE;

BOOL
APIENTRY
LPM_IpAddressTable (

    IN  ULONG       cIpAddrTable,
    
    IN  LPMIPTABLE  *pIpAddrTable );


/**************************************

    LPM_CommitResv

***************************************/

// CommitDecision values

#define RESOURCES_ALLOCATED             1
#define RESOURCES_MODIFIED              2

VOID
APIENTRY
LPM_CommitResv (

    IN  RSVP_SESSION    *RsvpSession,
    
    IN  RSVP_HOP        *FlowInstalledIntf,
    
    IN  RESV_STYLE      *RsvpStyle,
    
    IN  int             FilterSpecCount,
    
    IN  FILTER_SPEC     **ppFilterSpecList,
    
    IN  IS_FLOWSPEC     *pMergedFlowSpec,
    
    IN  ULONG           CommitDecision );


#ifdef __cplusplus
}
#endif


#endif // __LPMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\manipulations_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for manipulations.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_ManipulationsLib,0x935610b3,0x6f81,0x450f,0x85,0xd5,0x42,0xd3,0xd2,0x6c,0x5c,0x11);


MIDL_DEFINE_GUID(IID, IID__IManipulationEvents,0x4f62c8da,0x9c53,0x4b22,0x93,0xdf,0x92,0x7a,0x86,0x2b,0xbb,0x03);


MIDL_DEFINE_GUID(IID, IID_IInertiaProcessor,0x18b00c6d,0xc5ee,0x41b1,0x90,0xa9,0x9d,0x4a,0x92,0x90,0x95,0xad);


MIDL_DEFINE_GUID(IID, IID_IManipulationProcessor,0xA22AC519,0x8300,0x48a0,0xBE,0xF4,0xF1,0xBE,0x87,0x37,0xDB,0xA4);


MIDL_DEFINE_GUID(CLSID, CLSID_InertiaProcessor,0xabb27087,0x4ce0,0x4e58,0xa0,0xcb,0xe2,0x4d,0xf9,0x68,0x14,0xbe);


MIDL_DEFINE_GUID(CLSID, CLSID_ManipulationProcessor,0x597D4FB0,0x47FD,0x4aff,0x89,0xB9,0xC6,0xCF,0xAE,0x8C,0xF0,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\magnification.h ===
// -------------------------------------------------------------
// magnification.h
//
// Magnification Control API
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------


#ifndef _INC_MAGNIFIER
#define _INC_MAGNIFIER

#ifndef __wincodec_h__
#include <wincodec.h>
#endif

#ifdef __cplusplus    // If used by C++ code, 
extern "C" {          // we need to export the C interface
#endif

#ifdef _WIN32

// Magnifier Class Name
#define WC_MAGNIFIERA             "Magnifier"
#define WC_MAGNIFIERW             L"Magnifier"

#ifdef UNICODE
#define WC_MAGNIFIER              WC_MAGNIFIERW
#else
#define WC_MAGNIFIER              WC_MAGNIFIERA
#endif

#else
#define WC_MAGNIFIER              "Magnifier"
#endif

// Magnifier Window Styles
#define MS_SHOWMAGNIFIEDCURSOR      0x0001L
#define MS_CLIPAROUNDCURSOR         0x0002L
#define MS_INVERTCOLORS             0x0004L


// Filter Modes
#define MW_FILTERMODE_EXCLUDE   0
#define MW_FILTERMODE_INCLUDE   1

typedef struct tagMAGTRANSFORM
{
    float v[3][3];
} MAGTRANSFORM, *PMAGTRANSFORM;

typedef struct tagMAGIMAGEHEADER
{
    UINT width;
    UINT height;
    WICPixelFormatGUID format;
    UINT stride;
    UINT offset;
    SIZE_T cbSize;
} MAGIMAGEHEADER, *PMAGIMAGEHEADER;

typedef struct tagMAGCOLOREFFECT
{
    float transform[5][5];
} MAGCOLOREFFECT, *PMAGCOLOREFFECT;

typedef BOOL (CALLBACK* MagImageScalingCallback)(HWND hwnd, void * srcdata, MAGIMAGEHEADER srcheader, void * destdata, MAGIMAGEHEADER destheader, RECT unclipped, RECT clipped, HRGN dirty );

// Public Functions
BOOL WINAPI MagInitialize();
BOOL WINAPI MagUninitialize();

BOOL WINAPI MagSetWindowSource(HWND hwnd, RECT rect);
BOOL WINAPI MagGetWindowSource(HWND hwnd, RECT *pRect);
BOOL WINAPI MagSetWindowTransform(HWND hwnd, PMAGTRANSFORM pTransform);
BOOL WINAPI MagGetWindowTransform(HWND hwnd, PMAGTRANSFORM pTransform);
BOOL WINAPI MagSetWindowFilterList(HWND hwnd, DWORD dwFilterMode, int count, HWND *pHWND );
int  WINAPI MagGetWindowFilterList(HWND hwnd, DWORD *pdwFilterMode, int count, HWND *pHWND );
BOOL WINAPI MagSetImageScalingCallback(HWND hwnd, MagImageScalingCallback callback );
MagImageScalingCallback WINAPI MagGetImageScalingCallback(HWND hwnd );
BOOL WINAPI MagSetColorEffect(HWND hwnd, PMAGCOLOREFFECT pEffect);
BOOL WINAPI MagGetColorEffect(HWND hwnd, PMAGCOLOREFFECT pEffect);


#ifdef __cplusplus
}
#endif

#endif // !_INC_MAGNIFIER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Make.Inc ===
#----------------------------------------------------------------------------
#
# Descriptions:
#   Generic Make File Header for EDK
#
# Copyright:
#   Copyright (C) Microsoft Corp. 1993-1999.  All Rights Reserved.
#
#----------------------------------------------------------------------------


#*********************************************
# Check Component Name
#*********************************************

!ifndef COMP
!     ERROR Component name (COMP) has not been defined.
!endif


#*********************************************
# Parameter Defaults
#*********************************************

!ifndef BKOFFICE
BKOFFICE=c:\BkOffice
!endif

!if [DIR $(BKOFFICE) >NUL] != 0
!   ERROR Cannot find project root at $(BKOFFICE), set BKOFFICE variable
!endif

!ifndef INCLUDE
!   ERROR INCLUDE variable is empty; must include at least system include directory
!endif

!ifndef LIB
!   ERROR LIB variable is empty; must include at least system lib directory
!endif

!ifndef BLDTYPE
BLDTYPE=DBG
!endif

!ifndef CALL
CALL=C
!endif

!ifndef PACK
PACK=YES
!endif

!ifndef OUTERR
OUTERR=NO
!endif

!ifndef WARNING_LEVEL
WARNING_LEVEL=3
!endif

OSTARG=NTx86
OSTAG=WIN32
WINTAG=32
CPUTARG=IX86


#*********************************************
# Tools
#*********************************************

MAKEEXE = nmake
IMPLIB  = implib
CC      = cl
LIBU    = lib
LINK    = link
RC      = rc
MC      = mc
HC      = hc


#*********************************************
#
# Directories
#
# DIRINC   - project level include
# DIRBIN   - project level executables
# DIRLIB   - project level libraries
# DIRMAKE  - project makefiles
#
# DIRSRC   - component source directory
# DIRH     - component headers
# DIRRES   - component resources
# DIRBLD   - component build directory
# DIRPCHSRC- Pre-compiled header source directory
# DIRPCH   - Pre-compiled header output directory
#
#*********************************************

# Project directories
DIRINC=$(BKOFFICE)\include
DIRLIB=$(BKOFFICE)\lib
DIRBIN=$(BKOFFICE)\bin
DIRMAKE=$(BKOFFICE)\include

# Component directories
DIRBLD=.
DIRSRC=.
DIRH=.;$(DIRBLD)
DIRRES=.

# Pre-compiled header directories
DIRPCHSRC=$(BKOFFICE)\Samples\Exchange\Tools\PreCompH
DIRPCH=$(BKOFFICE)\Samples\Exchange\Tools\PreCompH

#*********************************************
# Paths
#*********************************************

PATH    = $(DIRBIN);$(PATH)
LIB     = $(DIRLIB);$(LIB)
INCLUDE = $(DIRH);$(DIRINC);$(INCLUDE)


#*********************************************
# Output Redirection
#*********************************************

!if "$(OUTERR)" == "NO"
ERRFILE=
OSYM=
!else
ERRFILE=$(DIRBLD)\$(COMP).err
OSYM= >>
!endif


#*********************************************
# Basic Compile Flags
#*********************************************

# CL is for all C and C++ files
CL= -I. -c -G3s -MT -W$(WARNING_LEVEL) -WX -J -Zp -Fo$(DIRBLD)^\ -nologo $(CL)

# NT/CPU specific flags
CL= -DWIN32 -D_X86_ $(CL)

# CFLAGS is for C files
#CFLAGS=$(CFLAGS)

# CPPFLAGS is for C++ files
#CPPFLAGS=$(CPPFLAGS)

# LFLAGS is for linking
LFLAGS=/NOD /NOLOGO -machine:$(CPUTARG) -out:$@ $(LFLAGS)

# DLLFLAGS is for linking DLLs
DLLFLAGS=$(LFLAGS) -dll -def:$(@B).def -map:$(DIRBLD)\$(COMP).map $(DLLFLAGS)

# LIBFLAGS is for building libraries
LIBFLAGS=-nologo -machine:$(CPUTARG) -out:$@ $(LIBFLAGS)

# RFLAGS is for Windows resources
RFLAGS=/r -I$(DIRRES) -fo$@ $(RFLAGS)

# MFLAGS is for the message compiler
MFLAGS=-v -s -h $(DIRBLD) -r $(DIRBLD) -x $(DIRBLD) $(MFLAGS)

# MRFLAGS is for the resource compiler when used after the message compiler
MRFLAGS=-l 409 -r -x -i$(DIRBLD) $(MRFLAGS)

#*********************************************
# Pre-compiled header macros
# NOPCH     - Define this to disable use and creation of precompiled headers.
# PCHUSE    - The default pre-compiled header for .C source files.
# PCUSECPP  - The default pre-compiled header for .CPP source files.
#
# PCHCR1    - To create the PCH file most .C sources depend upon.   (edk.h)
# PCHUSE1   - To use the PCH file most .C sources depend upon.      (edk.h)
# PCHCR2    - To create the PCH file most .CPP sources depend upon. (edk.h)
# PCHUSE2   - To use the PCH file most .CPP sources depend upon.    (edk.h)
# PCHCR3    - To create MFC PCH.                                 (edkafx.h)
# PCHUSE3   - To use MFC PCH.                                    (edkafx.h)
# PCHCR4    - To create the UNICODE PCH file for .C sources.        (edk.h)
# PCHUSE4   - To use the UNICODE PCH file for .C sources.           (edk.h)
#*********************************************

!ifndef NOPCH
# We are using precompiled headers.

PCHCR1  =  /Fp$(DIRPCH)\edk.pch    /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE1 =  /Fp$(DIRPCH)\edk.pch    /Yu"edk.h"
PCHCR2  =  /Fp$(DIRPCH)\edkx.pch   /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE2 =  /Fp$(DIRPCH)\edkx.pch   /Yu"edk.h"
PCHCR3  =  /Fp$(DIRPCH)\edkafx.pch /Yc"edkafx.h" -Fo$(DIRPCH)\ /Yd
PCHUSE3 =  /Fp$(DIRPCH)\edkafx.pch /Yu"edkafx.h"
PCHCR4  =  /Fp$(DIRPCH)\edku.pch   /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE4 =  /Fp$(DIRPCH)\edku.pch   /Yu"edk.h"

# Overide this to change the default pre-compiled header.
# You can also blank this if not using pre-compiled headers.
!ifndef PCHUSE
PCHUSE=$(PCHUSE1)
!endif
!ifndef PCHUSECPP
PCHUSECPP=$(PCHUSE2)
!endif

PCHOBJ1 = $(DIRPCH)\edk.obj
PCHOBJ2 = $(DIRPCH)\edkx.obj
PCHOBJ3 = $(DIRPCH)\edkafx.obj
PCHOBJ4 = $(DIRPCH)\edku.obj

!else
# NOT using precompiled headers.
!include "nopch.inc"
!endif

#*********************************************
# Calling convention Flag
#*********************************************

# Pascal Calling convention
!if "$(CALL)"=="PASCAL"
CL=-Gc $(CL)
!endif


#*********************************************
# Function Packaging Flag
#*********************************************

# Function packaging flag
!if "$(PACK)" == "YES"
CL=-Gy $(CL)
!endif


#*********************************************
# Optimization Flags
#*********************************************

!if "$(BLDTYPE)"=="SHP"
CL=-Ob1 -Og -Os $(CL)
!endif

!if "$(BLDTYPE)"=="DBG"
CL=-Od -Z7 $(CL)
!endif

!if "$(BLDTYPE)"=="TST"
CL=-Ob1 -Og -Os $(CL)
!endif


#*********************************************
# Build Type Flags
#*********************************************

!if "$(BLDTYPE)"=="SHP"
CL=-DSHIP $(CL)
LFLAGS=-debug:none -nodefaultlib:libc $(LFLAGS)
!endif

!if "$(BLDTYPE)"=="DBG"
CL=-DDEBUG -DTEST $(CL) 
LFLAGS=-debug:full -debugtype:cv -nodefaultlib:libc -incremental:no -pdb:none $(LFLAGS) 
!endif

!if "$(BLDTYPE)"=="TST"
CL=-DTEST $(CL)
LFLAGS=-debug:none  -nodefaultlib:libc $(LFLAGS)
!endif


#*********************************************
# Default Libraries
#*********************************************

# C Libraries 
CLIBS =  libcmt.lib \
         oldnames.lib

# NT Libraries
NTLIBS = kernel32.lib \
         user32.lib   \
         shell32.lib  \
         gdi32.lib    \
         ole32.lib    \
         uuid.lib     \
         winspool.lib \
         comdlg32.lib \
         advapi32.lib \
         netapi32.lib \
         imagehlp.lib \
         wsock32.lib  \
         rpcdce4.lib  \
         rpcndr.lib   \
         rpcns4.lib   \
         rpcrt4.lib
        
# MAPI Libraries
MAPILIBS = MAPI32.LIB

# Library List
# Components should either add to this list with a line like:
#      LIBLIST = $(LIBLIST) mylibs
# or, if they don't need all the default libs, (e.g. if don't need MAPI):
#      LIBLIST = $(CLIBS) $(NTLIBS) mylibs
LIBLIST = $(LIBLIST) $(CLIBS) $(NTLIBS) $(MAPILIBS)

# Objects
# This is just a default setting, expect most make files to 
# overide this (i.e. if they have more than one object or their
# one object is not named $(COMP).obj
!ifndef OBJLIST
OBJLIST=$(DIRBLD)\$(@B).OBJ
!endif


#*********************************************
# Inference Rules
#*********************************************

# C Targets
{$(DIRSRC)\}.c{$(DIRBLD)\}.obj:
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHUSE) $(CFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHUSE) $(CFLAGS) $< $(OSYM) $(ERRFILE)

# C++ Targets
{$(DIRSRC)\}.cpp{$(DIRBLD)\}.obj:
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHUSECPP) $(CPPFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHUSECPP) $(CPPFLAGS) $< $(OSYM) $(ERRFILE)

# Resource Targets from .RC files
{$(DIRRES)\}.rc{$(DIRBLD)\}.res:
!if "$(OUTERR)"=="YES"
    @echo $(RC) $(RFLAGS) $(DIRRES)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
    $(RC) $(RFLAGS) $(DIRRES)\$(@B).rc $(OSYM) $(ERRFILE)

# Resource Targets from .MC files
.SUFFIXES: .mc
{$(DIRSRC)\}.mc{$(DIRBLD)\}.res:
!if "$(OUTERR)"=="YES"
    @echo $(MC) $(MFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(MC) $(MFLAGS) $< $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo $(RC) $(MRFLAGS) -fo$(DIRBLD)\$(@B).res $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
    $(RC) $(MRFLAGS) -fo$(DIRBLD)\$(@B).res $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo del $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
        del $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)

# Import Libraries
{$(DIRSRC)\}.def{$(DIRBLD)\}.lib:
!if "$(OUTERR)"=="YES"
    @echo $(IMPLIB) -DEF:$(@B).DEF -OUT:$@ $(OSYM) $(ERRFILE)
!endif
    @echo $(IMPLIB) -DEF:$(@B).DEF -OUT:$@ $(OSYM) $(ERRFILE)
    xcopy $@ $(DIRLIB) $(OSYM) $(ERRFILE)

# Static Libraries
{$(DIRBLD)\}.obj{$(DIRBLD)\}.lib:
!if "$(OUTERR)"=="YES"
    @echo $(LIBU) $(LIBFLAGS) $** $(OSYM) $(ERRFILE)
!endif
    $(LIBU) $(LIBFLAGS) $** $(OSYM) $(ERRFILE)
    xcopy $@ $(DIRLIB) $(OSYM) $(ERRFILE)

# DLLs
{$(DIRBLD)\}.obj{$(DIRBLD)\}.dll:
    @echo $** > $(DIRBLD)\objfiles.lst
    @echo $(LIBLIST) > $(DIRBLD)\libfiles.lst
!if "$(OUTERR)"=="YES"
    @echo   $(LINK) $(DLLFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!endif
    $(LINK) $(DLLFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo xcopy $(DIRBLD)\$(@B).lib $(DIRLIB) $(OSYM) $(ERRFILE)
!endif
    -xcopy $(DIRBLD)\$(@B).lib $(DIRLIB) $(OSYM) $(ERRFILE)

# EXEs
{$(DIRBLD)\}.obj{$(DIRBLD)\}.exe:
    @echo $(OBJLIST) > $(DIRBLD)\objfiles.lst
    @echo $(LIBLIST) > $(DIRBLD)\libfiles.lst
!if "$(OUTERR)"=="YES"
    @echo   $(LINK) $(LFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!endif
    $(LINK) $(LFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)


#*********************************************
# Define the post-include file
#*********************************************

#ifndef POSTINCL
POSTINCL=$(BKOFFICE)\Include\postmake.inc
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\macamd64.inc ===
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Module:
;
;   macamd64.w
;
; Astract:
;
;   Contains AMD64 public architecture constants and assembly macros.
;
; Author:
;--

;++
;
; push_reg <reg>
;
; Macro Description:
;
;   This macro emits a single-byte push <reg> instruction in a
;   nested prologue, as well as the associated unwind code.
;
; Arguments:
;
;   reg - supplies the integer register to push
;
;--

push_reg macro Reg

        push    Reg
        .pushreg Reg

        endm

;++
;
; rex_push_reg <reg>
;
; Macro Description:
;
;   This macro emits a single-byte push <reg> instruction in a
;   nested prologue, as well as the associated unwind code.
;
;   This differs from push_reg only in that a redundant rex prefix
;   is added.  rex_push_reg must be used in lieu of push_reg when it
;   appears as the first instruction in a function, as the calling
;   standard dictates that functions must not begin with a single
;   byte instruction.
;
; Arguments:
;
;   reg - supplies the integer register to push
;
;--

rex_push_reg macro Reg

        db      048h
        push    Reg
        .pushreg Reg

        endm

;++
;
; push_eflags
;
; Macro Description:
;
;   This macro emits a single-byte pushfq instruction in a
;   nested prologue, as well as the associated unwind code.
;
; Arguments:
;
;   none
;
;--

push_eflags macro

        pushfq
        .allocstack 8

        endm

;++
;
; rex_push_eflags
;
; Macro Description:
;
;   This macro emits a single-byte pushfq instruction in a
;   nested prologue, as well as the associated unwind code.
;
;   This differs from push_eflags only in that a redundant rex prefix
;   is added.  rex_push_eflags must be used in lieu of push_eflags when it
;   appears as the first instruction in a function, as the calling
;   standard dictates that functions must not begin with a single
;   byte instruction.
;
; Arguments:
;
;   none
;
;--

rex_push_eflags macro

        db      048h
        pushfq
        .allocstack 8

        endm

;++
;
; ret_zero
;
; Macro Description:
;
;   This macro emits a three byte return instruction.
;
;   This differs from the typical ret in that it adds additional padding bytes
;   that prevent branch misprediction problems when the ret is the target of
;   a (un)conditional branch, or is immediately preceded by a conditional branch.
;
; Arguments:
;
;   none
;
;--

ret_zero macro

        db      0c2h, 0, 0

        endm

;++
;
; alloc_stack <Size>
;
; Macro Description:
;
;   This macro emits an opcode to subtract <Size> from rsp, as well
;   as the associated unwind code.
;
; Arguments:
;
;   Size - The number of bytes to subtract from rsp.
;
;--

alloc_stack macro Size

        sub     rsp, Size
        .allocstack Size

        endm

;++
;
; save_reg   <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode to save the non-volatile 64-bit general purpose
;   register indicated by <Reg> at offset <Offset> relative to the current
;   position of the stack pointer.  It also generates the associated unwind
;   code.
;
; Arguments:
;
;   Reg - Supplies the integer register to save
;
;   Offset - Supplies the offset relative to the current position of the stack
;            pointer.
;
;--

save_reg macro Reg, Offset

        mov     Offset[rsp], Reg
        .savereg Reg, Offset

        endm

;++
;
; save_xmm128   <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode to save the 128-bit non-volatile xmm register
;   indicated by <Reg> at offset <Offset> relative to the current position
;   of the stack pointer.  It also generates the associated unwind code.
;
; Arguments:
;
;   Reg - Supplies the xmm register register to save
;
;   Offset - Supplies the offset relative to the current position of the stack
;            pointer.
;
;--

save_xmm128 macro Reg, Offset

        movaps  Offset[rsp], Reg
        .savexmm128 Reg, Offset

        endm

;++
;
; push_frame
;
; Macro Description:
;
;   This macro emits unwind data indicating that a machine frame has been
;   pushed on the stack (usually by the CPU in response to a trap or fault).
;
; Arguments:
;
;   None.
;
;--

push_frame macro Code

        .pushframe Code

        endm

;++
;
; set_frame <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode and unwind data establishing the use of <Reg>
;   as the current stack frame pointer.
;
; Arguments:
;
;   Reg - Supplies the integer register to use as the current stack frame
;         pointer.
;
;   Offset - Supplies the optional offset of the frame pointer relative to
;            the stack frame.  In stack frames greater than 080h bytes,
;            a non-zero offset can help reduce the size of subsequent opcodes
;            that access portions of the stack frame by facilitating the use of
;            positive and negative single-byte displacements.
;
;            If not supplied, no offset is assumed.
;
;--

set_frame macro Reg, Offset

if Offset

        lea     Reg, Offset[rsp]

else

        mov     Reg, rsp

endif

        .setframe Reg, Offset

        endm

;++
;
; END_PROLOGUE
;
; Macro Description:
;
;   This macro marks the end of the prologue.  This must appear after all
;   of the prologue directives in a nested function.
;
; Arguments:
;
;   None.
;
;--

END_PROLOGUE macro

        .endprolog

        endm

;++
;
; LEAF_ENTRY <Name>, <Section>, <NoPad>
;
; Macro Description:
;
;   This macro indicates the beginning of a leaf function.
;
;   A leaf function is one that DOES NOT:
;
;   - manipulate non-volatile registers
;   - manipulate the stack pointer
;   - call other functions
;   - reference an exception handler
;   - contain a prologue
;   - have any unwind data associated with it
;
; Arguments:
;
;   Name - Supplies the name of the function
;
;   Section - Supplies the name of the section within which the function
;             is to appear
;
;   NoPad - If present, indicates that the function should not be prefixed
;           with 6 bytes of padding.  This is for internal use only - the
;           calling standard dictates that functions (nested and leaf) must
;           be prefixed with padding.
;
;--

LEAF_ENTRY macro Name, Section, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
;  LEAF_ENTRY_ARG1 <Name>, <Section>, <Arg1>, <NoPad>
;
; Macro Description:
;
; Indicates the beginning of a leaf function, as LEAF_ENTRY above,
; and declares one input parameter so that debug info will be
; generated for it. The other forms, LEAF_ENTRY_ARG2 and LEAF_ENTRY_ARG3,
; are similar.
;
;--

LEAF_ENTRY_ARG1 macro Name, Section, Arg1, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_ENTRY_ARG2 <Name>, <Section>, <Arg1>, <Arg2>, <NoPad>
;
; Macro Description:
;
; As LEAF_ENTRY_ARG1 above, marks the entry to a leaf function
; and defines 2 input parameters.
;
;--

LEAF_ENTRY_ARG2 macro Name, Section, Arg1, Arg2, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_ENTRY_ARG3 <Name>, <Section>, <Arg1>, <Arg2>, <Arg3>, <NoPad>
;
; Macro Description:
;
; As LEAF_ENTRY_ARG1 above, marks the entry to a leaf function
; and defines 3 input parameters.
;
;--

LEAF_ENTRY_ARG3 macro Name, Section, Arg1, Arg2, Arg3, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_END <Name>, <Section>
;
; Macro Description:
;
;   This macro indicates the end of a leaf function.  It must be paired
;   with a LEAF_ENTRY macro that includes matching Name and Section
;   parameters.
;
; Arguments:
;
;   Name - Supplies the name of the function.  Must match that supplied to
;          the corresponding LEAF_ENTRY macro.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.  Must match that supplied to the corresponding
;             LEAF_ENTRY macro.
;
;--

LEAF_END macro Name, section

Name    endp

Section ends

        endm

;++
;
; NESTED_ENTRY <Name>, <Section>, <Handler>, <NoPad>
;
; Macro Description:
;
;   This macro indicates the beginning of a nested function.
;
;   A nested function is one that does any of the following:
;
;   - manipulates non-volatile registers
;   - manipulates the stack pointer
;   - references an exception handler
;   - calls other functions
;
;   A nested function must include a prologue with unwind data.
;
; Arguments:
;
;   Name - Supplies the name of the function.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.
;
;   Handler - Supplies the name of the handler for exceptions raised
;             within the scope of this function.
;
;   NoPad - If present, indicates that the function should not be prefixed
;           with 6 bytes of padding.  This is for internal use only - the
;           calling standard dictates that functions (nested and leaf) must
;           be prefixed with padding.
;
;--

NESTED_ENTRY macro Name, Section, Handler, NoPad

ifdef _CurrentSection_

ifdif <Section>, _CurrentSection_

.err <NESTED_ENTRY invoked for different sections within same module>

endif

endif

_CurrentSection_ EQU <Section>

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name

ifb <Handler>

Name    proc    frame

else

Name    proc    frame:Handler

endif

        endm

;++
;
; NESTED_END <Name>, <Section>
;
; Macro Description:
;
;   This macro indicates the end of a nested function.  It must be paired
;   with a NESTED_ENTRY macro that includes matching Name and Section
;   parameters.
;
; Arguments:
;
;   Name - Supplies the name of the function.  Must match that supplied to
;          the corresponding NESTED_ENTRY macro.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.  Must match that supplied to the corresponding
;             NESTED_ENTRY macro.
;
;--

NESTED_END macro Name, section

Name    endp

Section ends

        endm

;++
;
; ALTERNATE_ENTRY <Name>
;
; Macro Description:
;
;   This macro indicates an alternate entry point in a function, or
;   a synonymous name for an existing function.
;
; Arguments:
;
;   Name - Supplies the name of the alternate entry point.
;
;--

ALTERNATE_ENTRY macro Name

Name:
        endm

;++
;
; Yield
;
; Macro Description:
;
;   This macro generates a yield instruction, interpreted by SMT processors
;   as an indication of a stall or idle condition.
;
; Arguments:
;
;   None.
;
;--

Yield   macro

        pause                           ; yield execution on SMT processors

        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MailMsgProps.h ===
/*
        @doc MAILMSG PROPERTIES
        @module mailmsgprops.h | MailMsg Properties for SMTP and NNTP
*/

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mailmsgprops.h

Abstract:

    This module contains the definitions for the MailMsg 
    Object property ID's.


--*/

#ifndef __MAILMSGPROPS_H__
#define __MAILMSGPROPS_H__

/*=======================================================================*/
// These macros are used to define the tables of property ID's.


#define IMMPID_START_LIST(name,start,guid)    struct __declspec(uuid(guid)) tagIMMPID_##name##_STRUCT;\
                                            typedef enum tagIMMPID_##name##_ENUM {\
                                                IMMPID_##name##_BEFORE__ = (start)-1,
#define IMMPID_END_LIST(name)                    IMMPID_##name##_AFTER__\
                                            } IMMPID_##name##_ENUM;


/*=======================================================================*/


// These are the per-message properties.

IMMPID_START_LIST(MP,0x1000,"13384CF0-B3C4-11d1-AA92-00AA006BC80B")

    // @const IMMPID | IMMPID_MP_RECIPIENT_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_RECIPIENT_LIST,

    // @const IMMPID | IMMPID_MP_CONTENT_FILE_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_CONTENT_FILE_NAME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_SMTP | 
    //  ANSI String - SMTP Address of sender
    IMMPID_MP_SENDER_ADDRESS_SMTP,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X500 | 
    //  ANSI String - X500 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X500,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X400 | 
    //  String - X400 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X400,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN | 
    //  String - Legacy DN Address of sender
    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,

    // @const IMMPID | IMMPID_MP_DOMAIN_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_DOMAIN_LIST,

    // @const IMMPID | IMMPID_MP_PICKUP_FILE_NAME | 
    //  ANSI String - Filename of msg file in pickup directory
    IMMPID_MP_PICKUP_FILE_NAME,

    // @const IMMPID | IMMPID_MP_AUTHENTICATED_USER_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_AUTHENTICATED_USER_NAME,

    // @const IMMPID | IMMPID_MP_CONNECTION_IP_ADDRESS | 
    //  ANSI String - IP address of MTA or client that submitted this message
    IMMPID_MP_CONNECTION_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_HELO_DOMAIN | 
    //  ANSI String - Domain name used in HELO/EHLO when message was submitted
    IMMPID_MP_HELO_DOMAIN,

    // @const IMMPID | IMMPID_MP_EIGHTBIT_MIME_OPTION | 
    //  BOOL - TRUE if message body is 8-bit MIME
    IMMPID_MP_EIGHTBIT_MIME_OPTION,

    // @const IMMPID | IMMPID_MP_CHUNKING_OPTION | 
    //   *** OBSOLETE ***
    IMMPID_MP_CHUNKING_OPTION,

    // @const IMMPID | IMMPID_MP_BINARYMIME_OPTION | 
    //  BOOL - TRUE if message body is binary MIME
    IMMPID_MP_BINARYMIME_OPTION,

    // @const IMMPID | IMMPID_MP_REMOTE_AUTHENTICATION_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_AUTHENTICATION_TYPE,

    // @const IMMPID | IMMPID_MP_ERROR_CODE | 
    //   *** OBSOLETE ***
    IMMPID_MP_ERROR_CODE,

    // @const IMMPID | IMMPID_MP_DSN_ENVID_VALUE | 
    //  Value of RFC1891 ENVID of submitted message
    IMMPID_MP_DSN_ENVID_VALUE,

    // @const IMMPID | IMMPID_MP_DSN_RET_VALUE | 
    //  ANSI String of what follows ESMTP RET
    IMMPID_MP_DSN_RET_VALUE,                

    // @const IMMPID | IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE,    

    // @const IMMPID | IMMPID_MP_ARRIVAL_TIME | 
    //  FILETIME that message arrived in system
    IMMPID_MP_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MESSAGE_STATUS | 
    // MP_STATUS_* value describing status of message system 
    IMMPID_MP_MESSAGE_STATUS,

    // @const IMMPID | IMMPID_MP_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration
    IMMPID_MP_EXPIRE_DELAY,         

    // @const IMMPID | IMMPID_MP_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration
    IMMPID_MP_EXPIRE_NDR,           

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_DELAY,   

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_NDR,     

    // @const IMMPID | IMMPID_MP_ARRIVAL_FILETIME | 
    //  FILETIME when message was submitted to queue
    IMMPID_MP_ARRIVAL_FILETIME,     

    // @const IMMPID | IMMPID_MP_HR_CAT_STATUS | 
    //  HRESULT MsgCat status (ie CAT_W_SOME_UNDELIVERABLE_MSGS)
    IMMPID_MP_HR_CAT_STATUS,        

    // @const IMMPID | IMMPID_MP_MSG_GUID | 
    //  String GUID ID which is only used if you want need to be able to replace 
    //  this message with another newer version.  This property is only 
    //  effective when used for a small amount of mail on the server, and is
    //  best suited for versioned mail (like DS replication).
    IMMPID_MP_MSG_GUID,        

    // @const IMMPID | IMMPID_MP_SUPERSEDES_MSG_GUID | 
    //  String GUID ID which this message superscedes.  If a message with with a 
    //  IMMPID_MP_MSG_GUID equal to this property is still on the server, then
    //  that message will not be sent out.

    IMMPID_MP_SUPERSEDES_MSG_GUID,

    // @const IMMPID | IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input was scanned for <CRLF>.<CRLF> in the msg
    // body
    IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,

    // @const IMMPID | IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input had any <CRLF>.<CRLF>
    //
    IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, 

    // @const IMMPID | IMMPID_MP_MSG_SIZE_HINT | 
    //  Provides an approximate size of the message content.  Does not convert
    //  message, or guarantee accuracy. For an accurate message size (but at 
    //  a higher performance cost) use IMailMsgProperties::GetContentSize.
    //
    IMMPID_MP_MSG_SIZE_HINT, 

    // @const IMMPID | IMMPID_MP_RFC822_MSG_ID | 
    //  String -- RFC 822 Message Id header.
    IMMPID_MP_RFC822_MSG_ID,

    // @const IMMPID | IMMPID_MP_RFC822_MSG_SUBJECT | 
    //  String -- RFC822 subject header
    IMMPID_MP_RFC822_MSG_SUBJECT,

    // @const IMMPID | IMMPID_MP_RFC822_FROM_ADDRESS | 
    //  String -- RFC822 from address
    IMMPID_MP_RFC822_FROM_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_TO_ADDRESS | 
    //  String -- RFC822 To address
    IMMPID_MP_RFC822_TO_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_CC_ADDRESS | 
    //  String -- RFC822 Cc address
    IMMPID_MP_RFC822_CC_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_BCC_ADDRESS | 
    //  String -- RFC822 Bcc address
    IMMPID_MP_RFC822_BCC_ADDRESS,

    // @const IMMPID | IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS | 
    //  String -- server IP Address
    IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_SERVER_NAME | 
    //  String -- server name
    IMMPID_MP_SERVER_NAME,

    // @const IMMPID | IMMPID_MP_SERVER_VERSION | 
    //  String -- server version
    IMMPID_MP_SERVER_VERSION,

    // @const IMMPID | IMMPID_MP_NUM_RECIPIENTS | 
    //  DWORD -- number of recipients
    IMMPID_MP_NUM_RECIPIENTS,


    // @const IMMPID | IMMPID_MP_X_PRIORITY | 
    //  DWORD -- the priority of message
    IMMPID_MP_X_PRIORITY,

    // @const IMMPID | IMMPID_MP_FROM_ADDRESS | 
    //  String -- From: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_FROM_ADDRESS,
    
    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS | 
    //  String -- Sender: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_SENDER_ADDRESS,

    // @const IMMPID | IMMPID_MP_DEFERRED_DELIVERY_FILETIME | 
    //  FILETIME -- Universal time to wait until before allowing
    //  message to be delivered.
    IMMPID_MP_DEFERRED_DELIVERY_FILETIME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_OTHER | 
    //  ANSI String - with the format "type:address"
    IMMPID_MP_SENDER_ADDRESS_OTHER,

    // @const IMMPID | IMMPID_MP_ORIGINAL_ARRIVAL_TIME | 
    //  FILETIME that message arrived in first exchange system
    IMMPID_MP_ORIGINAL_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MSG_CLASS | 
    //  The Message class of the mail, e.g. syste, replication, etc...
    IMMPID_MP_MSGCLASS,

    // @const IMMPID | IMMPID_MP_CONTENT_TYPE | 
    //  The content type of message.
    //  ANSI STRING.
    IMMPID_MP_CONTENT_TYPE,

    //@const IMMPID | IMMPID_MP_ENCRYPTION_TYPE |
    // DWORD - 0, no encryption
    //         1, signed only
    //         2, encrypted
    IMMPID_MP_ENCRYPTION_TYPE,

    //@const IMMPID | IMMPID_MP_CONNECTION_SERVER_PORT | 
    // DWORD - Port (if any) that this message was submitted on 
    IMMPID_MP_CONNECTION_SERVER_PORT,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_USER | 
    // ASCII STRING - Name of authenticated user
    IMMPID_MP_CLIENT_AUTH_USER,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_TYPE | 
    // ASCII STRING - Type of authentication used (AUTH keyword)
    IMMPID_MP_CLIENT_AUTH_TYPE,

    //@const IMMPID | IMMPID_MP_CRC_GLOBAL |
    // DWORD - Checksum for global properties (excluding the checksum properties!)
    IMMPID_MP_CRC_GLOBAL,

    //@const IMMPID | IMMPID_MP_CRC_RECIPS |
    // DWORD - Checksum for recipient properties
    IMMPID_MP_CRC_RECIPS,

    // @const IMMPID | IMMPID_MP_INBOUND_MAIL_FROM_AUTH | 
    //  ANSI String - Contents of the RFC2554 AUTH= string on a MAIL FROM on inbound messages
    IMMPID_MP_INBOUND_MAIL_FROM_AUTH,


    // Add new per-message properties above this line.
IMMPID_END_LIST(MP)


// Message classes
// @const DWORD | MP_MSGCLASS_SYSTEM
// for msgs of type -- system
#define MP_MSGCLASS_SYSTEM       1

// @const DWORD | MP_MSGCLASS_REPLICATION
// for msgs of type -- replication
#define MP_MSGCLASS_REPLICATION  2

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- delivery report
#define MP_MSGCLASS_DELIVERY_REPORT     3

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- non-delivery report
#define MP_MSGCLASS_NONDELIVERY_REPORT  4


// Message status property values defined:

// @const DWORD | MP_STATUS_SUCCESS | 
//  Initial status of message
#define MP_STATUS_SUCCESS                    0

// @const DWORD | MP_STATUS_RETRY | 
//  Status indicating retry.
#define MP_STATUS_RETRY                      1

// @const DWORD | MP_STATUS_ABORT_DELIVERY | 
//  Delivery of this message should be aborted and the message deleted.
#define MP_STATUS_ABORT_DELIVERY             2

// @const DWORD | MP_STATUS_BAD_MAIL | 
//  This message should be moved to badmail.
#define MP_STATUS_BAD_MAIL                   3

// @const DWORD | MP_STATUS_SUBMITTED | 
//  Message has been submitted for delivery.
#define MP_STATUS_SUBMITTED                  4

// @const DWORD | MP_STATUS_CATEGORIZED | 
//  Message has been categorized.
#define MP_STATUS_CATEGORIZED                5

// @const DWORD | MP_STATUS_ABANDON_DELIVERY | 
//  Delivery of this message should be abandoned until the service restarts
#define MP_STATUS_ABANDON_DELIVERY           6

//Per recipient flags for IMMPID_RP_RECIPIENT_FLAGS

// @const DWORD | RP_RECIP_FLAGS_RESERVED | 
//  You should not modify / use these bits
#define RP_RECIP_FLAGS_RESERVED     0x0000000F 

// @const DWORD | RP_DSN_NOTIFY_SUCCESS | 
//  Notify on success - set if RFC1891 NOTIFY=SUCCESS is used
#define RP_DSN_NOTIFY_SUCCESS       0x01000000 

// @const DWORD | RP_DSN_NOTIFY_FAILURE | 
//  Notify on failure - set if RFC1891 NOTIFY=FAILURE is used
#define RP_DSN_NOTIFY_FAILURE       0x02000000 

// @const DWORD | RP_DSN_NOTIFY_DELAY | 
//  Notify on delay - set if RFC1891 NOTIFY=DELAY is used
#define RP_DSN_NOTIFY_DELAY         0x04000000 

// @const DWORD | RP_DSN_NOTIFY_NEVER | 
//  Never notify - set if RFC1891 NOTIFY=NEVER is used
#define RP_DSN_NOTIFY_NEVER         0x08000000 

// @const DWORD | RP_DSN_NOTIFY_MASK | 
//  Mask of all notify parameters
#define RP_DSN_NOTIFY_MASK          0x0F000000

//The following flags can be used in searches, but should not be set directly

// @const DWORD | RP_HANDLED | 
//  Recipient has either been delivered or should not be delivered
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_HANDLED                  0x00000010 

// @const DWORD | RP_GENERAL_FAILURE | 
//  some form of hard failure happend
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_GENERAL_FAILURE          0x00000020 

// @const DWORD | RP_DSN_HANDLED | 
//  Final DSN has been sent (or no DSN needs to be sent)
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_DSN_HANDLED              0x00000040 

//The following constants define how a message can be RP_HANDLED

// @const DWORD | RP_DELIVERED | 
//  The recipient has been delivered successfully
#define RP_DELIVERED                0x00000110 

// @const DWORD | RP_DSN_SENT_NDR | 
//  NDR (FAILED DSN) for this recipient has been sent
#define RP_DSN_SENT_NDR             0x00000450 

// @const DWORD | RP_FAILED | 
//  Recipient has a hard failure
#define RP_FAILED                   0x00000830 

// @const DWORD | RP_UNRESOLVED | 
//  This recipient was not resolved by categorization
#define RP_UNRESOLVED               0x00001030 

// @const DWORD | RP_ENPANDED | 
//  ***OBSOLETE*** (replaced by RP_EXPANDED)
#define RP_ENPANDED                 0x00002010 

// @const DWORD | RP_EXPANDED | 
//  This recipient is an expanded DL
#define RP_EXPANDED                 0x00002010 

// @const DWORD | RP_DSN_SENT_DELAYED | 
//  At least one Delay DSN sent
#define RP_DSN_SENT_DELAYED         0x00004000 

// @const DWORD | RP_DSN_SENT_EXPANDED | 
//  Expanded DSN has been sent
#define RP_DSN_SENT_EXPANDED        0x00008040 

// @const DWORD | RP_DSN_SENT_RELAYED | 
//  Relayed DSN has been sent
#define RP_DSN_SENT_RELAYED         0x00010040 

// @const DWORD | RP_DSN_SENT_DELIVERED | 
//  Delivered DSN has been sent
#define RP_DSN_SENT_DELIVERED       0x00020040 


// @const DWORD | RP_REMOTE_MTA_NO_DSN | 
//  Remote MTA does not advertise DSN support (relay might be needed)
#define RP_REMOTE_MTA_NO_DSN        0x00080000 


// @const DWORD | RP_ERROR_CONTEXT_STORE | 
//  Error happened in store driver
#define RP_ERROR_CONTEXT_STORE      0x00100000 

// @const DWORD | RP_ERROR_CONTEXT_CAT | 
//  Error happened during categorization
#define RP_ERROR_CONTEXT_CAT        0x00200000 

// @const DWORD | RP_ERROR_CONTEXT_MTA | 
//  Error happened in a MTA (eg SMTP stack)
#define RP_ERROR_CONTEXT_MTA        0x00400000 


// @const DWORD | RP_VOLATILE_FLAGS_MASK | 
//  Flags that can be used for temp storage
#define RP_VOLATILE_FLAGS_MASK      0xF0000000 
                                               //while a component has access to recipients
                                               //Once control of recipients is passed, value
                                               //is un-defined.

// @const DWORD | RP_DSN_NOTIFY_INVALID | 
//  *** OBSOLETE ***
#define RP_DSN_NOTIFY_INVALID       0x00000000 

/*=======================================================================*/


// These are the per-recipient properties.

IMMPID_START_LIST(RP,0x2000,"79E82048-D320-11d1-9FF4-00C04FA37348")


    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_SUCCESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_SUCCESS,

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_INVALID | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_INVALID,    

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE,            

    // @const IMMPID | IMMPID_RP_ADDRESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS,                

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE_SMTP | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE_SMTP,    

    // @const IMMPID | IMMPID_RP_ERROR_CODE | 
    //   HRESULT status code
    IMMPID_RP_ERROR_CODE,            

    // @const IMMPID | IMMPID_RP_ERROR_STRING | 
    //   *** OBSOLETE ***
    IMMPID_RP_ERROR_STRING,            

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_VALUE | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_VALUE,        

    // @const IMMPID | IMMPID_RP_DSN_ORCPT_VALUE | 
    //   ANSI string - \<address type\>;\<address\>
    IMMPID_RP_DSN_ORCPT_VALUE,        

    // @const IMMPID | IMMPID_RP_ADDRESS_SMTP | 
    //   ANSI string - SMTP address
    IMMPID_RP_ADDRESS_SMTP,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X400 | 
    //   ANSI string - X.400 address
    IMMPID_RP_ADDRESS_X400,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X500 | 
    //   ANSI string - X.500 address
    IMMPID_RP_ADDRESS_X500,            

    // @const IMMPID | IMMPID_RP_LEGACY_EX_DN | 
    //   ANSI string - DN for Exchange 5.5 and prev
    IMMPID_RP_LEGACY_EX_DN,            

    // @const IMMPID | IMMPID_RP_RECIPIENT_FLAGS | 
    //   Per-recipient DSN/delivery flags. Flag constansts start with RP_.
    IMMPID_RP_RECIPIENT_FLAGS,      

    // @const IMMPID | IMMPID_RP_SMTP_STATUS_STRING | 
    //   ANSI string - SMTP status string... if defined
    IMMPID_RP_SMTP_STATUS_STRING,   
                                    // *must* start with 3-digit status code

    // @const IMMPID | IMMPID_RP_DSN_PRE_CAT_ADDRESS | 
    //   Original address as received by MTA in
    IMMPID_RP_DSN_PRE_CAT_ADDRESS,  
                                    // IMMPID_RP_DSN_ORCPT_VALUE format

    // @const IMMPID | IMMPID_RP_MDB_GUID | 
    //   Categorizer stamps the MDB guid
    IMMPID_RP_MDB_GUID,             
                                    // for this recipient here

    // @const IMMPID | IMMPID_RP_USER_GUID | 
    //   Categorizer stamps the
    IMMPID_RP_USER_GUID,            
                                    // objectGUID of the user object here
    // @const IMMPID | IMMPID_RP_DOMAIN | 
    //   Alternate SMTP domain for categorization
    IMMPID_RP_DOMAIN,            

    // @const IMMPID | IMMPID_RP_ADDRESS_OTHER | 
    //   ANSI string - other address type
    IMMPID_RP_ADDRESS_OTHER,            

    // @const IMMPID | IMMPID_RP_DISPLAY_NAME |
    //   Unicode string - recipient display name
    IMMPID_RP_DISPLAY_NAME,

    // Add new per-recipient properties above this line.
IMMPID_END_LIST(RP)


/*=======================================================================*/


// These are per-message volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(MPV,0x3000,"CBE69706-C9BD-11d1-9FF2-00C04FA37348")

    // @const IMMPID | IMMPID_MPV_STORE_DRIVER_HANDLE | 
    //  Store driver context for this message.
    IMMPID_MPV_STORE_DRIVER_HANDLE,

    // @const IMMPID | IMMPID_MPV_MESSAGE_CREATION_FLAGS | 
    //  Flags set at creation of mailmsg.
    IMMPID_MPV_MESSAGE_CREATION_FLAGS,

    // @const IMMPID | IMMPID_MPV_MESSAGE_OPEN_HANDLES | 
    // The number of handles (property and content) open for this message.
    //   0 means no handles open.
    //   1 means property or content open.
    //   2 means both property and content open.
    IMMPID_MPV_MESSAGE_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_HANDLES | 
    // The current total number of open message handles (of any type) 
    // on this server. 
    IMMPID_MPV_TOTAL_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES | 
    // The current total number of open property streams on this server. 
    IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES | 
    // The current total number of open content handles on this server. 
    IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,

    // Add new per-message volatile properties above this line.
IMMPID_END_LIST(MPV)

// This is the structure for the IMMPID_MPV_STORE_DRIVER_HANDLE property.
typedef struct tagIMMP_MPV_STORE_DRIVER_HANDLE {
    GUID guidSignature;    // signature of the store driver whose handle this is
} IMMP_MPV_STORE_DRIVER_HANDLE;

// Define message object creation flags

// @const DWORD | MPV_INBOUND_CUTOFF_EXCEEDED | 
//  Mailmsg configured cutoff has been exceeded... if this is an external 
//  delivery attempt, we should indicate that we do not have sufficient 
//  resources to accept the mail.
#define MPV_INBOUND_CUTOFF_EXCEEDED            0x00000001

// @const DWORD | MPV_WRITE_CONTENT |
//  Indicates that the content of this message can be modified.
#define MPV_WRITE_CONTENT                      0x00000002

/*=======================================================================*/


// These are per-recipient volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(RPV,0x4000,"79E82049-D320-11d1-9FF4-00C04FA37348")

    // @const IMMPID | IMMPID_RPV_DONT_DELIVER | 
    //  IMMPID_RPV_DONT_DELIVER is a boolean.  If set to TRUE, mailmsg 
    //  ignores this recipient when doing WriteList() (the recipient will 
    //  not exist in the new list).

    IMMPID_RPV_DONT_DELIVER,

    // @const IMMPID | IMMPID_RPV_NO_NAME_COLLISIONS | 
    //  IMMPID_RPV_NO_NAME_COLLISIONS is a boolean.  If set to TRUE, mailmsg 
    //  does not detect duplicates with this recipient on future calls to 
    //  AddSecondary().

    IMMPID_RPV_NO_NAME_COLLISIONS,
    // Add new per-recipient volatile properties above this line.
IMMPID_END_LIST(RPV)


// These are defined for backwards-compatability.  They will be removed
// ASAP...

// @const DWORD | IMMPID_RP_DONT_DELIVER | 
//   *** OBSOLETE ***
#define IMMPID_RP_DONT_DELIVER            IMMPID_RPV_DONT_DELIVER

// @const DWORD | IMMPID_RP_NO_NAME_COLLISIONS | 
//   *** OBSOLETE ***
#define IMMPID_RP_NO_NAME_COLLISIONS    IMMPID_RPV_NO_NAME_COLLISIONS


/*=======================================================================*/

// These are the per-message properties for NNTP

IMMPID_START_LIST(NMP,0x6000,"7433a9aa-20e2-11d2-94d6-00c04fa379f1")

    // @const IMMPID | IMMPID_NMP_SECONDARY_GROUPS | 
    //  An array of pointers to INNTPPropertyBag objects for each of
    //  the newsgroups that the article is being posted into for the
    //  current driver.
    IMMPID_NMP_SECONDARY_GROUPS,        

    // @const IMMPID | IMMPID_NMP_SECONDARY_ARTNUM | 
    //  An array of article numbers for each of the newsgroups that
    //  the article is being posted into for the current driver.
    IMMPID_NMP_SECONDARY_ARTNUM,

    // @const IMMPID | IMMPID_NMP_PRIMARY_GROUP | 
    //  A pointer to the INNTPPropertyBag object which represents the
    //  primary group for the current driver.
    IMMPID_NMP_PRIMARY_GROUP,

    // @const IMMPID | IMMPID_NMP_PRIMARY_ARTID | 
    //  The primary article number for the primary group.
    IMMPID_NMP_PRIMARY_ARTID,

    // @const IMMPID | IMMPID_NMP_POST_TOKEN | 
    //   The HTOKEN representing the client context.
    IMMPID_NMP_POST_TOKEN,                

    // @const IMMPID | IMMPID_NMP_NEWSGROUP_LIST | 
    //   The string of newsgroups which this article is being stored in.
    IMMPID_NMP_NEWSGROUP_LIST,            

    // @const IMMPID | IMMPID_NMP_HEADERS | 
    //   A string containing the headers of the message.
    IMMPID_NMP_HEADERS,                    

    // @const IMMPID | IMMPID_NMP_NNTP_PROCESSING | 
    //   Flags which describe how the message should be processed.  The 
    //   possible values are: NMP_PROCESS_POST, NMP_PROCESS_CONTROL, 
    //   and NMP_PROCESS_MODERATOR.  
    IMMPID_NMP_NNTP_PROCESSING,            

    // @const IMMPID | IMMPID_NMP_NNTP_APPROVED_HEADER | 
    //   A string containing the Approved: header of the message  
    IMMPID_NMP_NNTP_APPROVED_HEADER,            

    // Add new per-message properties above this line.
IMMPID_END_LIST(NMP)

// flags for IMMPID_NMP_NNTP_PROCESSING

// @const DWORD | NMP_PROCESS_POST | 
//  Set this flag to allow the NNTP server to post this message.
#define NMP_PROCESS_POST            0x00000001

// @const DWORD | NMP_PROCESS_CONTROL | 
//  Set this flag to allow the NNTP server to process control headers in this
//  message.
#define NMP_PROCESS_CONTROL            0x00000002

// @const DWORD | NMP_PROCESS_MODERATOR | 
//  Set this flag to allow the NNTP server to run this message through the
//  default moderated posting path.
#define NMP_PROCESS_MODERATOR        0x00000004

/*=======================================================================*/


// This is the starting range for user-reserved properties

IMMPID_START_LIST(CPV,0x8000,"A2A76B2A-E52D-11d1-AA64-00C04FA35B82")

    // @const IMMPID | IMMPID_CP_START | 
    //  Start of range
    IMMPID_CP_START,
IMMPID_END_LIST(CPV)


/*=======================================================================*/

// This table collects the data about the properties so that range-
// checking can be performed.  If any new property ranges are
// defined, they must be added to this structure.


#define IMMPID_DECLARE_ENTRY(name)    {&_uuidof(tagIMMPID_##name##_STRUCT),\
                                     IMMPID_##name##_BEFORE__+1,\
                                     IMMPID_##name##_AFTER__-1}

extern const __declspec(selectany) struct tagIMMPID_GUIDLIST_ITEM {
                                       const GUID *pguid;
                                       DWORD dwStart;
                                       DWORD dwLast;
                                   } IMMPID_GUIDS[] = {IMMPID_DECLARE_ENTRY(MP),
                                                       IMMPID_DECLARE_ENTRY(RP),
                                                       IMMPID_DECLARE_ENTRY(MPV),
                                                       IMMPID_DECLARE_ENTRY(RPV),
                                                       {&GUID_NULL,0,0}};

#endif // _MAILMSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIHook.h ===
/*
 *  M A P I H O O K . H
 *
 *  Defines the SpoolerMsgHook provider interface.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIHOOK_H
#define MAPIHOOK_H

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ISpoolerHook Interface ------------------------------------------------ */

/* MsgHooks */

#define HOOK_DELETE         ((ULONG) 0x00000001)
#define HOOK_CANCEL         ((ULONG) 0x00000002)

#define MAPI_ISPOOLERHOOK_METHODS(IPURE)                            \
    MAPIMETHOD(InboundMsgHook)                                      \
        (THIS_  LPMESSAGE                   lpMessage,              \
                LPMAPIFOLDER                lpFolder,               \
                LPMDB                       lpMDB,                  \
                ULONG FAR *                 lpulFlags,              \
                ULONG FAR *                 lpcbEntryID,            \
                LPBYTE FAR *                lppEntryID) IPURE;      \
    MAPIMETHOD(OutboundMsgHook)                                     \
        (THIS_  LPMESSAGE                   lpMessage,              \
                LPMAPIFOLDER                lpFolder,               \
                LPMDB                       lpMDB,                  \
                ULONG FAR *                 lpulFlags,              \
                ULONG FAR *                 lpcbEntryID,            \
                LPBYTE FAR *                lppEntryID) IPURE;      \
    
#undef       INTERFACE
#define      INTERFACE  ISpoolerHook
DECLARE_MAPI_INTERFACE_(ISpoolerHook, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_ISPOOLERHOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(ISpoolerHook, LPSPOOLERHOOK);

/* Hook Provider Entry Point */

#define HOOK_INBOUND        ((ULONG) 0x00000200)
#define HOOK_OUTBOUND       ((ULONG) 0x00000400)

typedef HRESULT (STDMAPIINITCALLTYPE HPPROVIDERINIT)(
    LPMAPISESSION           lpSession,
    HINSTANCE               hInstance,
    LPALLOCATEBUFFER        lpAllocateBuffer,
    LPALLOCATEMORE          lpAllocateMore,
    LPFREEBUFFER            lpFreeBuffer,
    LPMAPIUID               lpSectionUID,
    ULONG                   ulFlags,
    LPSPOOLERHOOK FAR *     lppSpoolerHook
);

HPPROVIDERINIT HPProviderInit;

#ifdef __cplusplus
}      /* extern "C"  */
#endif /* __cplusplus */

#endif /* MAPIHOOK_H  */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPINls.h ===
/*
 *	M A P I N L S . H
 *
 *	Internationalization Support Utilities
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
	#if defined(_WIN32) && (_MSC_VER >= 800)
		#define WINAPI				__stdcall
	#elif defined(WIN16)
		#define WINAPI				_far _pascal
	#else
		#define WINAPI				_far _pascal
	#endif
#endif

#if defined(DOS) || defined(_MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char				    BYTE;
typedef unsigned short      			WORD;
typedef unsigned long       			DWORD;
typedef unsigned int	 				UINT;
typedef int		 						BOOL;

#ifndef __CHAR_DEFINED__
typedef char							CHAR;
#endif

#ifdef UNICODE
typedef WCHAR							TCHAR;
#else
typedef char							TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#endif

typedef WCHAR FAR *						LPWSTR;
typedef const WCHAR FAR *				LPCWSTR;
typedef CHAR FAR *						LPSTR;
typedef const CHAR FAR *				LPCSTR;
typedef TCHAR FAR *						LPTSTR;
typedef const TCHAR FAR *				LPCTSTR;
typedef DWORD 							LCID;
typedef const void FAR *				LPCVOID;

#ifndef _MAC
#ifndef LPOLESTR
#if !defined (_WIN32)

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) 	str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !_WIN32 */
#endif /* LPOLESTR */
#endif /* _MAC */

#define NORM_IGNORECASE      			0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE  			0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS   			0x00000004     /* ignore symbols */

#if defined (_WIN32) /* from winnls.h */
#define NORM_IGNOREKANATYPE				0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH				0x00020000	   /* ignore width */
#elif defined (WIN16) /* from olenls.h */
#define NORM_IGNOREWIDTH				0x00000008		/* ignore width */
#define NORM_IGNOREKANATYPE				0x00000040		/* ignore kanatype */
#endif

#if defined(WIN16)

#define	lstrcpyA						lstrcpy
#define	lstrlenA						lstrlen
#define	lstrcmpA						lstrcmp
#define lstrcmpiA						lstrcmpi
#define	LoadStringA						LoadString
#define IsBadStringPtrA(a1, a2)			IsBadStringPtr(a1, a2)
#define	wvsprintfA						wvsprintf
#define	MessageBoxA						MessageBox
#define GetModuleHandleA				GetModuleHandle
#define CreateWindowA					CreateWindow
#define RegisterClassA					RegisterClass
#define	CharToOemBuff					AnsiToOemBuff
#define	CharToOem						AnsiToOem
#define	CharUpperBuff					AnsiUpperBuff
#define	CharUpper						AnsiUpper

#elif defined(DOS) || defined(_MAC)

#define	IsBadReadPtr(lp, cb)			(FALSE)
#define IsBadWritePtr(lp, cb)			(FALSE)
#define IsBadHugeReadPtr(lp, cb)		(FALSE)
#define IsBadHugeWritePtr(lp, cb)		(FALSE)
#define IsBadCodePtr(lpfn)				(FALSE)
#ifdef _MAC
#undef IsBadStringPtr
#endif
#define IsBadStringPtr(lpsz, cchMax)	(FALSE)
#define IsBadStringPtrA(lpsz, cchMax)	(FALSE)

#if defined(DOS)

#define	lstrcpyA						strcpy
#define	lstrlenA						strlen
#define	lstrcmpA						strcmp
#define lstrcmp							strcmp
#define lstrcmpi						strcmpi
#define lstrcpy							strcpy
#define lstrcat							strcat
#define lstrlen							strlen
#define wsprintf						sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define CP_ACP		0		/* default to ANSI code page */
#define CP_OEMCP	1		/* default to OEM  code page */

LCID	WINAPI	MNLS_GetUserDefaultLCID(void);
UINT	WINAPI	MNLS_GetACP(void);
int		WINAPI	MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
					LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
					LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
					LPCSTR lpMultiByteStr, int cchMultiByte,
					LPWSTR lpWideCharStr, int cchWideChar);
int		WINAPI	MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
					LPCWSTR lpWideCharStr, int cchWideChar,
					LPSTR lpMultiByteStr, int cchMultiByte,
					LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int		WINAPI	MNLS_lstrlenW(LPCWSTR lpString);
int		WINAPI	MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR	WINAPI	MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL	WINAPI	MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

#if !defined(_WINNT) && !defined(_WIN95)
#define GetUserDefaultLCID		MNLS_GetUserDefaultLCID
#define GetACP					MNLS_GetACP
#define MultiByteToWideChar		MNLS_MultiByteToWideChar
#define WideCharToMultiByte		MNLS_WideCharToMultiByte
#define CompareStringA			MNLS_CompareStringA
#endif

#if !defined(MAPI_NOWIDECHAR)

#define lstrlenW				MNLS_lstrlenW
#define lstrcmpW				MNLS_lstrcmpW
#define lstrcpyW				MNLS_lstrcpyW
#define CompareStringW			MNLS_CompareStringW

#if defined(WIN16) || defined(_WINNT) || defined(_WIN95)
#define IsBadStringPtrW			MNLS_IsBadStringPtrW
#elif defined(_MAC)
#define IsBadStringPtrW(lpsz, cchMax)			(FALSE)
#else
#define IsBadStringPtrW			(FALSE)
#endif

#endif	/* ! MAPI_NOWIDECHAR */

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIDbg.h ===
/*
 *	M A P I D B G . H
 *
 *	Debugging support for MAPI service providers.
 *	Support functions are implemented in MAPIDBG.C.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __MAPIDBG_H_
#define __MAPIDBG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DEBUG is defined, or
 *						to nothing if DEBUG is not defined
 *	
 *		IFNDBG(x)		Results in the expression x if DEBUG is not defined,
 *						or to nothing if DEBUG is defined
 *	
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a) 		(sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)		((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))
#define DebugTraceProblems(sz, rgprob)					IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG	__export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int EXPORTDBG __cdecl		DebugTraceFn(char *pszFormat, ...);
void EXPORTDBG __cdecl		DebugTraceProblemsFn(char *sz, void *rgprob);
char * EXPORTDBG __cdecl	SzDecodeScodeFn(SCODE sc);
char * EXPORTDBG __cdecl	SzDecodeUlPropTypeFn(unsigned long ulPropType);
char * EXPORTDBG __cdecl	SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(char *psz);
SCODE EXPORTDBG __cdecl		ScodeFromSzFn(char *psz);
void * EXPORTDBG __cdecl	DBGMEM_EncapsulateFn(void * pmalloc, char *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl		DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl		DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
#if defined(_WIN32) && defined(_X86_)
void EXPORTDBG __cdecl		DBGMEM_LeakHook(FARPROC pfn);
void EXPORTDBG __cdecl		GetCallStack(DWORD *, int, int);
#endif
void EXPORTDBG __cdecl		DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl		DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl		ScCheckScFn(SCODE, SCODE *, char *, char *, int);
void * EXPORTDBG __cdecl	VMAlloc(ULONG);
void * EXPORTDBG __cdecl	VMAllocEx(ULONG, ULONG);
void * EXPORTDBG __cdecl	VMRealloc(void *, ULONG);
void * EXPORTDBG __cdecl	VMReallocEx(void *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl		VMGetSize(void *);
ULONG EXPORTDBG __cdecl		VMGetSizeEx(void *, ULONG);
void EXPORTDBG __cdecl		VMFree(void *);
void EXPORTDBG __cdecl		VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *	Debugging Macros -------------------------------------------------------
 *	
 *		SzDecodeScode			Returns the string name of an SCODE
 *		SzDecodeUlPropTag		Returns the string name of a property
 *								tag
 *		UlPropTagFromSz			Given a property tag's name, returns
 *								its value
 *		ScodeFromSz				Given an SCODE's name, returns its
 *								value
 *	
 *		DBGMEM_Encapsulate		Given an IMalloc interface, adds heap-
 *								checking functionality and returns a
 *								wrapped interface
 *		DBGMEM_Shutdown			Undoes DBGMEM_Encapsulate, and prints
 *								out information on any allocations made
 *								since the interface was encapsulated
 *								that have not yet been released.
 *		DBGMEM_CheckMem			Checks all memory allocated on the heap,
 *								and optionally reports leaked blocks.
 *		DBGMEM_NoLeakDetect		Prevents a block from appearing on the leak
 *								report.  Pass NULL for pv to inhibit leak
 *								reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)				SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType)	SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)	SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)			UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)				ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)	DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)				DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)			DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm,	pv)		DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)		DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)				(0)
#define SzDecodeUlPropType(_ulPropType)	(0)
#define SzDecodeUlPropTag(_ulPropTag)	(0)
#define UlPropTagFromSz(_sz)			(0)
#define ScodeFromSz(_sz)				(0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *	SCODE maps -------------------------------------------------------------
 *	
 *		ScCheckSc		Given an SCODE and method name, verifies
 *						that the SCODE can legally be returned from
 *						thet method. Prints out a debug string if
 *						it cannot.
 *		HrCheckHr		As ScCheckSc, for functions that return
 *						HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)				ScCheckScFn(sc,fn##_Scodes,#fn,__FILE__, __LINE__)
#define HrCheckHr(hr,fn)				HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)				(sc)
#define HrCheckHr(hr,fn)				(hr)
#endif

#define HrCheckSc(sc,fn)				ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE MAPILogon_Scodes[];
extern SCODE MAPIAllocateBuffer_Scodes[];
extern SCODE MAPIAllocateMore_Scodes[];
extern SCODE MAPIFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IMAPIProp_CopyTo_Scodes[];
extern SCODE IMAPIProp_CopyProps_Scodes[];
extern SCODE IMAPIProp_DeleteProps_Scodes[];
extern SCODE IMAPIProp_GetIDsFromNames_Scodes[];
extern SCODE IMAPIProp_GetLastError_Scodes[];
extern SCODE IMAPIProp_GetNamesFromIDs_Scodes[];
extern SCODE IMAPIProp_GetPropList_Scodes[];
extern SCODE IMAPIProp_GetProps_Scodes[];
extern SCODE IMAPIProp_OpenProperty_Scodes[];
extern SCODE IMAPIProp_SetProps_Scodes[];
extern SCODE IMAPIProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IMAPITable_GetLastError_Scodes[];
extern SCODE IMAPITable_Advise_Scodes[];
extern SCODE IMAPITable_Unadvise_Scodes[];
extern SCODE IMAPITable_GetStatus_Scodes[];
extern SCODE IMAPITable_SetColumns_Scodes[];
extern SCODE IMAPITable_QueryColumns_Scodes[];
extern SCODE IMAPITable_GetRowCount_Scodes[];
extern SCODE IMAPITable_SeekRow_Scodes[];
extern SCODE IMAPITable_SeekRowApprox_Scodes[];
extern SCODE IMAPITable_QueryPosition_Scodes[];
extern SCODE IMAPITable_FindRow_Scodes[];
extern SCODE IMAPITable_Restrict_Scodes[];
extern SCODE IMAPITable_CreateBookmark_Scodes[];
extern SCODE IMAPITable_FreeBookmark_Scodes[];
extern SCODE IMAPITable_SortTable_Scodes[];
extern SCODE IMAPITable_QuerySortOrder_Scodes[];
extern SCODE IMAPITable_QueryRows_Scodes[];
extern SCODE IMAPITable_Abort_Scodes[];
extern SCODE IMAPITable_ExpandRow_Scodes[];
extern SCODE IMAPITable_CollapseRow_Scodes[];
extern SCODE IMAPITable_WaitForCompletion_Scodes[];
extern SCODE IMAPITable_GetCollapseState_Scodes[];
extern SCODE IMAPITable_SetCollapseState_Scodes[];

extern SCODE IMAPISession_LogOff_Scodes[];
extern SCODE IMAPISession_Release_Scodes[];
extern SCODE IMAPISession_GetLastError_Scodes[];
extern SCODE IMAPISession_GetMsgStoresTable_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];
extern SCODE IMAPISession_OpenMsgStore_Scodes[];
extern SCODE IMAPISession_OpenAddressBook_Scodes[];
extern SCODE IMAPISession_OpenEntry_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_Advise_Scodes[];
extern SCODE IMAPISession_Unadvise_Scodes[];
extern SCODE IMAPISession_CompareEntryIDs_Scodes[];
extern SCODE IMAPISession_MessageOptions_Scodes[];
extern SCODE IMAPISession_QueryDefaultMessageOpt_Scodes[];
extern SCODE IMAPISession_EnumAdrTypes_Scodes[];
extern SCODE IMAPISession_QueryIdentity_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];

extern SCODE IMsgStore_Advise_Scodes[] ;
extern SCODE IMsgStore_Unadvise_Scodes[] ;
extern SCODE IMsgStore_CompareEntryIDs_Scodes[] ;
extern SCODE IMsgStore_OpenEntry_Scodes[] ;
extern SCODE IMsgStore_SetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolderTable_Scodes[];
extern SCODE IMsgStore_StoreLogoff_Scodes[];
extern SCODE IMsgStore_AbortSubmit_Scodes[];
extern SCODE IMsgStore_GetOutgoingQueue_Scodes[] ;
extern SCODE IMsgStore_SetLockState_Scodes[] ;
extern SCODE IMsgStore_FinishedMsg_Scodes[] ;
extern SCODE IMsgStore_NotifyNewMail_Scodes[];

extern SCODE IMAPIFolder_GetContentsTable_Scodes[];
extern SCODE IMAPIFolder_GetHierarchyTable_Scodes[];
extern SCODE IMAPIFolder_SaveContentsSort_Scodes[];
extern SCODE IMAPIFolder_OpenEntry_Scodes[];
extern SCODE IMAPIFolder_CreateMessage_Scodes[];
extern SCODE IMAPIFolder_CopyMessages_Scodes[];
extern SCODE IMAPIFolder_DeleteMessages_Scodes[];
extern SCODE IMAPIFolder_CreateFolder_Scodes[];
extern SCODE IMAPIFolder_CopyFolder_Scodes[];
extern SCODE IMAPIFolder_DeleteFolder_Scodes[];
extern SCODE IMAPIFolder_SetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_GetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_SetReadFlags_Scodes[];
extern SCODE IMAPIFolder_GetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_SetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_EmptyFolder_Scodes[];

extern SCODE IMessage_SaveChanges_Scodes[];
extern SCODE IMessage_GetAttachmentTable_Scodes[];
extern SCODE IMessage_OpenAttach_Scodes[];
extern SCODE IMessage_CreateAttach_Scodes[];
extern SCODE IMessage_DeleteAttach_Scodes[];
extern SCODE IMessage_GetRecipientTable_Scodes[];
extern SCODE IMessage_ModifyRecipients_Scodes[];
extern SCODE IMessage_SubmitMessage_Scodes[];
extern SCODE IMessage_SetReadFlag_Scodes[];

extern SCODE IAttach_SaveChanges_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

extern SCODE IMAPIStatus_ChangePassword_Scodes[];
extern SCODE IMAPIStatus_FlushQueues_Scodes[];
extern SCODE IMAPIStatus_SettingsDialog_Scodes[];
extern SCODE IMAPIStatus_ValidateState_Scodes[];

extern SCODE IMSProvider_Logon_Scodes[];
extern SCODE IMSProvider_Deinit_Scodes[];
extern SCODE IMSProvider_Init_Scodes[];
extern SCODE IMSProvider_SpoolerLogon_Scodes[];
extern SCODE IMSProvider_Shutdown_Scodes[];

extern SCODE SMAPI_MAPILogon_Scodes[];
extern SCODE SMAPI_MAPILogoff_Scodes[];
extern SCODE SMAPI_MAPIFreeBuffer_Scodes[];
extern SCODE SMAPI_MAPISendMail_Scodes[];
extern SCODE SMAPI_MAPISendDocuments_Scodes[];
extern SCODE SMAPI_MAPIFindNext_Scodes[];
extern SCODE SMAPI_MAPIReadMail_Scodes[];
extern SCODE SMAPI_MAPISaveMail_Scodes[];
extern SCODE SMAPI_MAPIDeleteMail_Scodes[];
extern SCODE SMAPI_MAPIAddress_Scodes[];
extern SCODE SMAPI_MAPIResolveName_Scodes[];
extern SCODE SMAPI_MAPIDetails_Scodes[];

extern SCODE IMSLogon_OpenEntry_Scodes[];
extern SCODE IMSLogon_OpenStatusEntry_Scodes[];
extern SCODE IMSLogon_CompareEntryIDs_Scodes[];
extern SCODE IMSLogon_Advise_Scodes[];
extern SCODE IMSLogon_Unadvise_Scodes[];
extern SCODE IMSLogon_Logoff_Scodes[];
#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPICode.h ===
/*
 *	M A P I C O D E . H
 *
 *	Status Codes returned by MAPI routines
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *	MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *	OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *	or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *			0x0 - FACILITY_NULL		generally useful errors ([SE]_*)
 *			0x1 - FACILITY_RPC		remote procedure call errors (RPC_E_*)
 *			0x2 - FACILITY_DISPATCH late binding dispatch errors
 *			0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *			0x4 - FACILITY_ITF		interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *	On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *	laid out as follows:
 *	
 *	  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *	  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	 |S|R|C|N|r|    Facility         |               Code            |
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	
 *	 where
 *	
 *	    S - Severity - indicates success/fail
 *	
 *	        0 - Success
 *	        1 - Fail (COERROR)
 *	
 *	    R - reserved portion of the facility code, corresponds to NT's
 *	        second severity bit.
 *	
 *	    C - reserved portion of the facility code, corresponds to NT's
 *	        C field.
 *	
 *	    N - reserved portion of the facility code. Used to indicate a
 *	        mapped NT status value.
 *	
 *	    r - reserved portion of the facility code. Reserved for internal
 *	        use. Used to indicate HRESULT values that are not status
 *	        values, but are instead message ids for display strings.
 *	
 *	    Facility - is the facility code
 *			FACILITY_NULL                    0x0
 *			FACILITY_RPC                     0x1
 *			FACILITY_DISPATCH                0x2
 *			FACILITY_STORAGE                 0x3
 *			FACILITY_ITF                     0x4
 *			FACILITY_WIN32                   0x7
 *			FACILITY_WINDOWS                 0x8
 *	
 *	    Code - is the facility's status code
 *	
 */




/*
 * 	We can't use OLE 2.0 macros to build sCodes because the definition has
 *	changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )	(MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn )	(MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef	SUCCESS_SUCCESS
#undef	SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS		0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED								E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY						E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER						E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED					E_NOINTERFACE
#define MAPI_E_NO_ACCESS								E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT								MAKE_MAPI_E( 0x102 )
#define	MAPI_E_BAD_CHARWIDTH							MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG							MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS							MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID							MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT							MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED							MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED							MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY			  							MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK							MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES						MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND 								MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION				 					MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED								MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT							MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL								MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT							MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR							MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR								MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX			 					MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN								MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR							MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED									MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA								MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED								MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER							MAKE_MAPI_E( 0x11D )
#define MAPI_E_UNKNOWN_CPID								MAKE_MAPI_E( 0x11E )
#define MAPI_E_UNKNOWN_LCID								MAKE_MAPI_E( 0x11F )

/* Flavors of E_ACCESSDENIED, used at logon */

#define MAPI_E_PASSWORD_CHANGE_REQUIRED					MAKE_MAPI_E( 0x120 )
#define MAPI_E_PASSWORD_EXPIRED							MAKE_MAPI_E( 0x121 )
#define MAPI_E_INVALID_WORKSTATION_ACCOUNT				MAKE_MAPI_E( 0x122 )
#define MAPI_E_INVALID_ACCESS_TIME						MAKE_MAPI_E( 0x123 )
#define MAPI_E_ACCOUNT_DISABLED							MAKE_MAPI_E( 0x124 )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION							MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID							MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN					MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE								MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE			 					MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE								MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT							MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE							MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG									MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY								MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID							MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED		 					MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE	 					MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT				 					MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY			 					MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG		 					MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK		 					MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED		  					MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT			  					MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT					  					MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL				  					MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME				  					MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE		  					MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE		  					MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE			  					MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS			  					MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION			  					MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED							MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD								MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS							MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED								MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS								MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES								MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE								MAKE_MAPI_E( 0x60B )

#define MAPI_W_PARTIAL_COMPLETION						MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP							MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)	ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef	HR_SUCCEEDED
#define	HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define	HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif	/* MAPICODE_H */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPI.h ===
/*
 *	M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif


#ifndef EXPORT
#ifdef WIN16
#define EXPORT __export
#else
/* Additional special definitions here */
#define EXPORT
#endif
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDesc, FAR * lpMapiFileDesc;

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDesc, FAR * lpMapiRecipDesc;

#ifndef MAPI_ORIG				/* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG				/* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT		0x00000040	   Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID			0x00004000	/* allow 512 char returned ID	*/

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID		0x00004000	/* allow 512 char returned ID	*/

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

typedef ULONG (FAR PASCAL MAPILOGON)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszProfileName,
	__in LPSTR lpszPassword,
	FLAGS flFlags,
	ULONG ulReserved,
	LPLHANDLE lplhSession
);
typedef MAPILOGON FAR *LPMAPILOGON;
DECLSPEC_DEPRECATED MAPILOGON MAPILogon;

typedef ULONG (FAR PASCAL MAPILOGOFF)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPILOGOFF FAR *LPMAPILOGOFF;
DECLSPEC_DEPRECATED MAPILOGOFF MAPILogoff;


typedef ULONG (FAR PASCAL MAPISENDMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPISENDMAIL FAR *LPMAPISENDMAIL;
MAPISENDMAIL MAPISendMail;


typedef ULONG (FAR PASCAL MAPISENDDOCUMENTS)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszDelimChar,
	__in LPSTR lpszFilePaths,
	__in LPSTR lpszFileNames,
	ULONG ulReserved
);
typedef MAPISENDDOCUMENTS FAR *LPMAPISENDDOCUMENTS;
DECLSPEC_DEPRECATED MAPISENDDOCUMENTS MAPISendDocuments;


typedef ULONG (FAR PASCAL MAPIFINDNEXT)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageType,
	__in LPSTR lpszSeedMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPIFINDNEXT FAR *LPMAPIFINDNEXT;
DECLSPEC_DEPRECATED MAPIFINDNEXT MAPIFindNext;

typedef ULONG (FAR PASCAL MAPIREADMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiMessage FAR *lppMessage
);
typedef MAPIREADMAIL FAR *LPMAPIREADMAIL;
DECLSPEC_DEPRECATED MAPIREADMAIL MAPIReadMail;

typedef ULONG (FAR PASCAL MAPISAVEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPISAVEMAIL FAR *LPMAPISAVEMAIL;
DECLSPEC_DEPRECATED MAPISAVEMAIL MAPISaveMail;

typedef ULONG (FAR PASCAL MAPIDELETEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDELETEMAIL FAR *LPMAPIDELETEMAIL;
DECLSPEC_DEPRECATED MAPIDELETEMAIL MAPIDeleteMail;

typedef ULONG (EXPORT FAR PASCAL *LPMAPIFREEBUFFER)(LPVOID pv);
ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

typedef ULONG (FAR PASCAL MAPIADDRESS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszCaption,
	ULONG nEditFields,
	__in LPSTR lpszLabels,
	ULONG nRecips,
	lpMapiRecipDesc lpRecips,
	FLAGS flFlags,
	ULONG ulReserved,
	LPULONG lpnNewRecips,
	lpMapiRecipDesc FAR *lppNewRecips
);
typedef MAPIADDRESS FAR *LPMAPIADDRESS;
DECLSPEC_DEPRECATED MAPIADDRESS MAPIAddress;

typedef ULONG (FAR PASCAL MAPIDETAILS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiRecipDesc lpRecip,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDETAILS FAR *LPMAPIDETAILS;
DECLSPEC_DEPRECATED MAPIDETAILS MAPIDetails;

typedef ULONG (FAR PASCAL MAPIRESOLVENAME)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszName,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiRecipDesc FAR *lppRecip
);
typedef MAPIRESOLVENAME FAR *LPMAPIRESOLVENAME;
DECLSPEC_DEPRECATED MAPIRESOLVENAME MAPIResolveName;

#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26



#ifdef MAPIX_H
/*  Maps from a simple mapi session to a MAPI 1.0 extended mapi session */

STDMETHODIMP_(SCODE)
ScMAPIXFromSMAPI(LHANDLE lhSimpleSession,
				ULONG ulFlags,
				LPCIID lpInterface,
				LPMAPISESSION FAR * lppMAPISession);
#endif /* MAPIX_H */


#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIGuid.h ===
/*
 *	M A P I G U I D . H
 *
 *	Master definitions of all GUID's for MAPI.
 *
 *	When included without INITGUID defined, this header file
 *	defines symbols that reference IIDs elsewhere.
 *
 *	When included with INITGUID defined and a "USES_IID_I..."
 *	statement for each IID used by the subsystem, it generates the
 *	bytes for those actual IIDs into the associated object file.
 *
 *	This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	List of GUIDS allocated by MAPI
 *	
 *	0x00020300	IID_IMAPISession
 *	0x00020301	IID_IMAPITable
 *	0x00020302	IID_IMAPIAdviseSink
 *	0x00020303	IID_IMAPIProp
 *	0x00020304	IID_IProfSect
 *	0x00020305	IID_IMAPIStatus
 *	0x00020306	IID_IMsgStore
 *	0x00020307	IID_IMessage
 *	0x00020308	IID_IAttachment
 *	0x00020309	IID_IAddrBook
 *	0x0002030A	IID_IMailUser
 *	0x0002030B	IID_IMAPIContainer
 *	0x0002030C	IID_IMAPIFolder
 *	0x0002030D	IID_IABContainer
 *	0x0002030E	IID_IDistList
 *	0x0002030F	IID_IMAPISup
 *	0x00020310	IID_IMSProvider
 *	0x00020311	IID_IABProvider
 *	0x00020312	IID_IXPProvider
 *	0x00020313	IID_IMSLogon
 *	0x00020314	IID_IABLogon
 *	0x00020315	IID_IXPLogon
 *	0x00020316	IID_IMAPITableData
 *	0x00020317	IID_IMAPISpoolerInit
 *	0x00020318	IID_IMAPISpoolerSession
 *	0x00020319	IID_ITNEF
 *	0x0002031A	IID_IMAPIPropData
 *	0x0002031B	IID_IMAPIControl
 *	0x0002031C	IID_IProfAdmin
 *	0x0002031D	IID_IMsgServiceAdmin
 *	0x0002031E	IID_IMAPISpoolerService
 *	0x0002031F	IID_IMAPIProgress
 *	0x00020320	IID_ISpoolerHook
 *	0x00020321	IID_IMAPIViewContext
 *	0x00020322	IID_IMAPIFormMgr
 *	0x00020323	IID_IEnumMAPIFormProp
 *	0x00020324	IID_IMAPIFormInfo
 *	0x00020325	IID_IProviderAdmin
 *	0x00020327	IID_IMAPIForm
 *	0x00020328	PS_MAPI
 *	0x00020329	PS_PUBLIC_STRINGS
 *	0x0002032A	IID_IPersistMessage
 *	0x0002032B	IID_IMAPIViewAdviseSink
 *	0x0002032C	IID_IStreamDocfile
 *	0x0002032D	IID_IMAPIFormProp
 *	0x0002032E	IID_IMAPIFormContainer
 *	0x0002032F	IID_IMAPIFormAdviseSink
 *	0x00020330	IID_IStreamTnef
 *	0x00020350	IID_IMAPIFormFactory
 *	0x00020370	IID_IMAPIMessageSite
 *	0x00020380	PS_ROUTING_EMAIL_ADDRESSES
 *	0x00020381	PS_ROUTING_ADDRTYPE
 *	0x00020382	PS_ROUTING_DISPLAY_NAME
 *	0x00020383	PS_ROUTING_ENTRYID
 *	0x00020384	PS_ROUTING_SEARCH_KEY
 *	0x00020385	MUID_PROFILE_INSTANCE
 *	
 *	The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *	MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#if _MSC_VER > 1000
#pragma once
#endif
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,	0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,		0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink,	0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,	0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,		0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,	0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,	0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,		0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,		0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,			0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,		0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,		0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,		0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,		0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,		0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,	0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,		0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,	0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,		0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,		0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,		0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,		0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,		0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,		0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,		0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,		0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,	0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,	0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession,	0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,			0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,	0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,	0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService,	0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,	0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,	0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,	0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,	0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,	0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI,	0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,	0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage,	0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink,	0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,	0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,	0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE,	0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME,	0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,	0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,	0x00020384, 0, 0);
#endif

/*	MUID_PROFILE_INSTANCE
	Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
	for any given profile.  Applications and providers can depend on this value as being
	different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#endif	/* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIDefS.h ===
/*
 *	M A P I D E F S . H
 *
 *	Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32) /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <winerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM	1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (_WIN32)
#define STDMAPIINITCALLTYPE		__cdecl
#else
#define STDMAPIINITCALLTYPE		STDMETHODCALLTYPE
#endif
#define	STDINITMETHODIMP		HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type)	type STDMAPIINITCALLTYPE
#endif


#define MAPI_NT_SERVICE     ((ULONG) 0x00010000)  /* Provider is being loaded in an NT service */


#ifdef	__cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined (MIDL_PASS) /* MIDL doesn't want to see these */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#endif

typedef __nullterminated char FAR *		LPSTR;
typedef __nullterminated const char FAR *	LPCSTR;

typedef __nullterminated WCHAR FAR *		LPWSTR;
typedef __nullterminated const WCHAR FAR *	LPCWSTR;

#ifdef UNICODE
typedef WCHAR				TCHAR;
typedef LPWSTR				LPTSTR;
typedef LPCWSTR				LPCTSTR;
#else
typedef char				TCHAR;
typedef LPSTR				LPTSTR;
typedef LPCSTR				LPCTSTR;
#endif

typedef BYTE FAR *			LPBYTE;
#endif /* defined MIDL_PASS */

typedef ULONG FAR *			LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR	LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *	This flag is used in many different MAPI calls to signify that
 *	the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY				((ULONG) 0x00000001)

/*
 *	The following flags are used to indicate to the client what access
 *	level is permissible in the object. They appear in PR_ACCESS in
 *	message and folder objects as well as in contents and associated
 *	contents tables
 */

#define	MAPI_ACCESS_MODIFY					((ULONG) 0x00000001)
#define	MAPI_ACCESS_READ					((ULONG) 0x00000002)
#define	MAPI_ACCESS_DELETE					((ULONG) 0x00000004)
#define	MAPI_ACCESS_CREATE_HIERARCHY		((ULONG) 0x00000008)
#define	MAPI_ACCESS_CREATE_CONTENTS			((ULONG) 0x00000010)
#define	MAPI_ACCESS_CREATE_ASSOCIATED		((ULONG) 0x00000020)

/*
 *	The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *	that strings passed through the interface are in Unicode (a 16-bit
 *	character set). The default is an 8-bit character set.
 *
 *	The value fMapiUnicode can be used as the 'normal' value for
 *	that bit, given the application's default character set.
 */

#define MAPI_UNICODE			((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode			MAPI_UNICODE
#else
#define fMapiUnicode			0
#endif

/* successful HRESULT */
#define hrSuccess				0



/* Recipient types */
#ifndef MAPI_ORIG				/* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1		0x10000000	/* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4		   recipient is a CMC authorizing user		*/
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM			0x80
#define MAPI_NOTRECIP			0x40
#define MAPI_THISSESSION		0x20
#define MAPI_NOW				0x10
#define MAPI_NOTRESERVED		0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND			0x80

/* ENTRYID */
typedef struct
{
	BYTE	abFlags[4];
	BYTE	ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)		(offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)			(offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
	struct _ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	BYTE	ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
	BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)	(!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))

/*
 * Constants for one-off entry ID:
 * The MAPIUID that identifies the one-off provider;
 * the flag that defines whether the embedded strings are Unicode;
 * the flag that specifies whether the recipient gets TNEF or not.
 */

#define MAPI_ONE_OFF_UID { 0x81, 0x2b, 0x1f, 0xa4, 0xbe, 0xa3, 0x10, 0x19, \
						   0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02 }
#define MAPI_ONE_OFF_UNICODE		0x8000
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Object type */

#define MAPI_STORE		((ULONG) 0x00000001)	/* Message Store */
#define MAPI_ADDRBOOK	((ULONG) 0x00000002)	/* Address Book */
#define MAPI_FOLDER		((ULONG) 0x00000003)	/* Folder */
#define MAPI_ABCONT		((ULONG) 0x00000004)	/* Address Book Container */
#define MAPI_MESSAGE	((ULONG) 0x00000005)	/* Message */
#define MAPI_MAILUSER	((ULONG) 0x00000006)	/* Individual Recipient */
#define MAPI_ATTACH		((ULONG) 0x00000007)	/* Attachment */
#define MAPI_DISTLIST	((ULONG) 0x00000008)	/* Distribution List Recipient */
#define MAPI_PROFSECT	((ULONG) 0x00000009)	/* Profile Section */
#define MAPI_STATUS		((ULONG) 0x0000000A)	/* Status Object */
#define MAPI_SESSION	((ULONG) 0x0000000B)	/* Session */
#define MAPI_FORMINFO	((ULONG) 0x0000000C)	/* Form Information */


/*
 *	Maximum length of profile names and passwords, not including
 *	the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax	64
#define cchProfilePassMax	64
#endif


/* Property Types */

#define MV_FLAG			0x1000			/* Multi-value flag */

#define PT_UNSPECIFIED	((ULONG)  0)	/* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL			((ULONG)  1)	/* NULL property value */
#define	PT_I2			((ULONG)  2)	/* Signed 16-bit value */
#define PT_LONG			((ULONG)  3)	/* Signed 32-bit value */
#define	PT_R4			((ULONG)  4)	/* 4-byte floating point */
#define PT_DOUBLE		((ULONG)  5)	/* Floating point double */
#define PT_CURRENCY		((ULONG)  6)	/* Signed 64-bit int (decimal w/	4 digits right of decimal pt) */
#define	PT_APPTIME		((ULONG)  7)	/* Application time */
#define PT_ERROR		((ULONG) 10)	/* 32-bit error value */
#define PT_BOOLEAN		((ULONG) 11)	/* 16-bit boolean (non-zero true) */
#define PT_OBJECT		((ULONG) 13)	/* Embedded object in a property */
#define	PT_I8			((ULONG) 20)	/* 8-byte signed integer */
#define PT_STRING8		((ULONG) 30)	/* Null terminated 8-bit character string */
#define PT_UNICODE		((ULONG) 31)	/* Null terminated Unicode string */
#define PT_SYSTIME		((ULONG) 64)	/* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define	PT_CLSID		((ULONG) 72)	/* OLE GUID */
#define PT_BINARY		((ULONG) 258)	/* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define	PT_SHORT	PT_I2
#define	PT_I4		PT_LONG
#define	PT_FLOAT	PT_R4
#define	PT_R8		PT_DOUBLE
#define	PT_LONGLONG	PT_I8

/*
 *	The type of a MAPI-defined string property is indirected, so
 *	that it defaults to Unicode string on a Unicode platform and to
 *	String8 on an ANSI or DBCS platform.
 *
 *	Macros are defined here both for the property type, and for the
 *	field of the property value structure which should be
 *	dereferenced to obtain the string pointer.
 */

#ifdef	UNICODE
#define PT_TSTRING			PT_UNICODE
#define PT_MV_TSTRING		(MV_FLAG|PT_UNICODE)
#define LPSZ				lpszW
#define	LPPSZ				lppszW
#define MVSZ				MVszW
#else
#define PT_TSTRING			PT_STRING8
#define PT_MV_TSTRING		(MV_FLAG|PT_STRING8)
#define LPSZ				lpszA
#define	LPPSZ				lppszA
#define MVSZ				MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK			((ULONG)0x0000FFFF)	/* Mask for Property type */
#define PROP_TYPE(ulPropTag)	(((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL			0
#define PROP_ID_INVALID			0xFFFF
#define PR_NULL					PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType)	\
						(((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define	PT_MV_I2		(MV_FLAG|PT_I2)
#define PT_MV_LONG		(MV_FLAG|PT_LONG)
#define	PT_MV_R4		(MV_FLAG|PT_R4)
#define PT_MV_DOUBLE	(MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY	(MV_FLAG|PT_CURRENCY)
#define	PT_MV_APPTIME	(MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME	(MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8	(MV_FLAG|PT_STRING8)
#define PT_MV_BINARY	(MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE	(MV_FLAG|PT_UNICODE)
#define	PT_MV_CLSID		(MV_FLAG|PT_CLSID)
#define PT_MV_I8		(MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define	PT_MV_SHORT		PT_MV_I2
#define	PT_MV_I4		PT_MV_LONG
#define	PT_MV_FLOAT		PT_MV_R4
#define	PT_MV_R8		PT_MV_DOUBLE
#define	PT_MV_LONGLONG	PT_MV_I8

/*
 *	Property type reserved bits
 *
 *	MV_INSTANCE is used as a flag in table operations to request
 *	that a multi-valued property be presented as a single-valued
 *	property appearing in multiple rows.
 */

#define MV_INSTANCE		0x2000
#define MVI_FLAG		(MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)	((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
	ULONG	cValues;
	ULONG	aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
	(offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
	(offsetof(SPropTagArray,aulPropTag) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))
/*	SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue	SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (_WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
			/* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
	ULONG		cb;
	LPBYTE 		lpb;
} SBinary, FAR *LPSBinary;

typedef	struct _SShortArray
{
	ULONG		cValues;
	short int	FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
	ULONG		cValues;
	GUID		FAR *lpguid;
} SGuidArray;

typedef	struct _SRealArray
{
	ULONG		cValues;
	float		FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
	ULONG		cValues;
	LONG 		FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
	ULONG		cValues;
	LARGE_INTEGER	FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
	ULONG		cValues;
	FILETIME	FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
	ULONG		cValues;
	double		FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
	ULONG		cValues;
	CURRENCY	FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
	ULONG		cValues;
	SBinary		FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
	ULONG		cValues;
	double		FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
	ULONG		cValues;
	LPWSTR		FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
	ULONG		cValues;
	LPSTR		FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
	short int			i;			/* case PT_I2 */
	LONG				l;			/* case PT_LONG */
	ULONG				ul;			/* alias for PT_LONG */
	float				flt;		/* case PT_R4 */
	double				dbl;		/* case PT_DOUBLE */
	unsigned short int	b;			/* case PT_BOOLEAN */
	CURRENCY			cur;		/* case PT_CURRENCY */
	double				at;			/* case PT_APPTIME */
	FILETIME			ft;			/* case PT_SYSTIME */
	LPSTR				lpszA;		/* case PT_STRING8 */
	SBinary				bin;		/* case PT_BINARY */
	LPWSTR				lpszW;		/* case PT_UNICODE */
	LPGUID				lpguid;		/* case PT_CLSID */
	LARGE_INTEGER		li;			/* case PT_I8 */
	SShortArray			MVi;		/* case PT_MV_I2 */
	SLongArray			MVl;		/* case PT_MV_LONG */
	SRealArray			MVflt;		/* case PT_MV_R4 */
	SDoubleArray		MVdbl;		/* case PT_MV_DOUBLE */
	SCurrencyArray		MVcur;		/* case PT_MV_CURRENCY */
	SAppTimeArray		MVat;		/* case PT_MV_APPTIME */
	SDateTimeArray		MVft;		/* case PT_MV_SYSTIME */
	SBinaryArray		MVbin;		/* case PT_MV_BINARY */
	SLPSTRArray			MVszA;		/* case PT_MV_STRING8 */
	SWStringArray		MVszW;		/* case PT_MV_UNICODE */
	SGuidArray			MVguid;		/* case PT_MV_CLSID */
	SLargeIntegerArray	MVli;		/* case PT_MV_I8 */
	SCODE				err;		/* case PT_ERROR */
	LONG				x;			/* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
	ULONG		ulPropTag;
	ULONG		dwAlignPad;
	union _PV	Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
	ULONG	ulIndex;
	ULONG	ulPropTag;
	SCODE	scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
	ULONG			cProblem;
	SPropProblem	aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
	(offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
	(offsetof(SPropProblemArray,aProblem) + \
	(UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
	ULONG			cProblem; \
	SPropProblem	aProblem[_cprob]; \
} _name

/*
 *	ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *	FLATENTRYLIST
 *	MTSID
 *	FLATMTSIDLIST
 */

typedef struct {
	ULONG cb;
	BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
	ULONG		cEntries;
	ULONG		cbEntries;
	BYTE		abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
	ULONG		cb;
	BYTE		ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
	ULONG		cMTSIDs;
	ULONG		cbMTSIDs;
	BYTE		abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)		(offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)	(offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb)	(offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)			(offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)		(offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb)	(offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
	ULONG			ulReserved1;	/* Never used */
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
	ULONG			cEntries;
	ADRENTRY		aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
	(offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
	(offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
	ULONG			cEntries; \
	ADRENTRY		aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
	ULONG			ulAdrEntryPad;	/* Pad so SRow's can map to ADRENTRY's */
	ULONG			cValues;		/* Count of property values */
	LPSPropValue	lpProps;		/* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
	ULONG			cRows;			/* Count of rows */
	SRow			aRow[MAPI_DIM];	/* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)		(offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)	(offsetof(SRowSet,aRow) + \
									(UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
	ULONG			cRows; \
	SRow			aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
	LPVOID			lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *	LPALLOCATEMORE;
typedef FREEBUFFER FAR *	LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface;			\
		struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)				MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)		STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
		STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
		typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)									\
	MAPIMETHOD(QueryInterface)											\
		(THIS_ __in REFIID riid, __deref_out LPVOID FAR * ppvObj) IPURE;					\
	MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
	MAPIMETHOD_(ULONG,Release) (THIS) IPURE;							\

#undef	IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,		LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,		LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,		LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,			LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,		LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,	LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,		LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,		LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,		LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,		LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,		LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,		LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,	LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,	LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,	LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
	ULONG	ulVersion;
	LPTSTR	lpszError;
	LPTSTR	lpszComponent;
	ULONG	ulLowLevelError;
	ULONG	ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *	Notification event types. The event types can be combined in a bitmask
 *	for filtering. Each one has a parameter structure associated with it:
 *
 *		fnevCriticalError		ERROR_NOTIFICATION
 *		fnevNewMail				NEWMAIL_NOTIFICATION
 *		fnevObjectCreated		OBJECT_NOTIFICATION
 *		fnevObjectDeleted		OBJECT_NOTIFICATION
 *		fnevObjectModified		OBJECT_NOTIFICATION
 *		fnevObjectCopied		OBJECT_NOTIFICATION
 *		fnevSearchComplete		OBJECT_NOTIFICATION
 *		fnevTableModified		TABLE_NOTIFICATION
 *		fnevStatusObjectModified ?
 *
 *		fnevExtended			EXTENDED_NOTIFICATION
 */

#define fnevCriticalError			((ULONG) 0x00000001)
#define fnevNewMail					((ULONG) 0x00000002)
#define fnevObjectCreated			((ULONG) 0x00000004)
#define fnevObjectDeleted			((ULONG) 0x00000008)
#define fnevObjectModified			((ULONG) 0x00000010)
#define fnevObjectMoved				((ULONG) 0x00000020)
#define fnevObjectCopied			((ULONG) 0x00000040)
#define fnevSearchComplete			((ULONG) 0x00000080)
#define fnevTableModified			((ULONG) 0x00000100)
#define	fnevStatusObjectModified	((ULONG) 0x00000200)
#define	fnevReservedForMapi			((ULONG) 0x40000000)
#define fnevExtended				((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED		1
#define	TABLE_ERROR			2
#define	TABLE_ROW_ADDED		3
#define	TABLE_ROW_DELETED	4
#define	TABLE_ROW_MODIFIED	5
#define	TABLE_SORT_DONE		6
#define	TABLE_RESTRICT_DONE	7
#define	TABLE_SETCOL_DONE	8
#define TABLE_RELOAD		9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
	SCODE		scode;
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPMAPIERROR	lpMAPIError;		/* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;			/* identifies the new message */
	ULONG		cbParentID;
	LPENTRYID	lpParentID;			/* identifies the folder it lives in */
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPTSTR		lpszMessageClass;	/* message class (UNICODE or string8) */
	ULONG		ulMessageFlags;		/* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
	ULONG				cbEntryID;
	LPENTRYID			lpEntryID;		/* EntryID of object */
	ULONG				ulObjType;		/* Type of object */
	ULONG				cbParentID;
	LPENTRYID			lpParentID;		/* EntryID of parent object */
	ULONG				cbOldID;
	LPENTRYID			lpOldID;		/* EntryID of old object */
	ULONG				cbOldParentID;
	LPENTRYID			lpOldParentID;	/* EntryID of old parent */
	LPSPropTagArray		lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
	ULONG				ulTableEvent;	/* Identifies WHICH table event */
	HRESULT				hResult;		/* Value for TABLE_ERROR */
	SPropValue			propIndex;		/* This row's "index property" */
	SPropValue			propPrior;		/* Preceding row's "index property" */
	SRow				row;			/* New data of added/modified row */
	ULONG				ulPad;			/* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
	ULONG		ulEvent;					/* extended event code */
	ULONG		cb;							/* size of event parameters */
	LPBYTE		pbEventParameters;			/* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
	ULONG			cbEntryID;
	LPENTRYID		lpEntryID;
	ULONG			cValues;
	LPSPropValue	lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
	ULONG	ulEventType;		/* notification type, i.e. fnevSomething */
	ULONG	ulAlignPad;			/* Force to 8-byte boundary */
	union
	{
		ERROR_NOTIFICATION			err;
		NEWMAIL_NOTIFICATION		newmail;
		OBJECT_NOTIFICATION			obj;
		TABLE_NOTIFICATION			tab;
		EXTENDED_NOTIFICATION		ext;
		STATUS_OBJECT_NOTIFICATION	statobj;
	} info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)								\
	MAPIMETHOD_(ULONG, OnNotify)										\
		(THIS_	ULONG						cNotif,						\
				LPNOTIFICATION				lpNotifications) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
	LPVOID			lpvContext,
	ULONG			cNotification,
	LPNOTIFICATION	lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *	Message name for the 16-bit MAPI notififcation engine.
 *	This can be used in 16-bit applications to force processing
 *	of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL		((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)								\
	MAPIMETHOD(Progress)												\
		(THIS_	ULONG						ulValue,					\
				ULONG						ulCount,					\
				ULONG						ulTotal) IPURE;				\
	MAPIMETHOD(GetFlags)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(GetMax)													\
		(THIS_	ULONG FAR *					lpulMax) IPURE;				\
	MAPIMETHOD(GetMin)													\
		(THIS_	ULONG FAR *					lpulMin) IPURE;				\
	MAPIMETHOD(SetLimits)												\
		(THIS_	LPULONG						lpulMin,					\
				LPULONG						lpulMax,					\
				LPULONG						lpulFlags) IPURE;			\

#undef		INTERFACE
#define		INTERFACE	IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION		0x00000000L

/* GetPropList */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY		((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE		((ULONG) 0x00000002)
#define FORCE_SAVE				((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/******	MAPI_MODIFY				((ULONG) 0x00000001) above */
#define	MAPI_CREATE				((ULONG) 0x00000002)
#define STREAM_APPEND			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE				((ULONG) 0x00000001)
#define MAPI_NOREPLACE			((ULONG) 0x00000002)
#define MAPI_DECLINE_OK			((ULONG) 0x00000004)

#ifndef MAPI_DIALOG				/* also defined in mapi.h */
#define MAPI_DIALOG				((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT		/* also defined in mapi.h */
#define MAPI_USE_DEFAULT		0x00000040	/* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/******	MAPI_CREATE				((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS			((ULONG) 0x00000001)
#define MAPI_NO_IDS				((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID					0
#define MNID_STRING				1
typedef struct _MAPINAMEID
{
	LPGUID lpguid;
	ULONG ulKind;
	union {
		LONG lID;
		LPWSTR lpwstrName;
	} Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(SaveChanges)												\
		(THIS_ ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppPropArray) IPURE;		\
	MAPIMETHOD(GetPropList)												\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTagArray) IPURE;		\
	MAPIMETHOD(OpenProperty)											\
		(THIS_	ULONG						ulPropTag,					\
				LPCIID						lpiid,						\
				ULONG						ulInterfaceOptions,			\
				ULONG						ulFlags,					\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetProps)												\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpPropArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DeleteProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyTo)													\
		(THIS_	ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyProps)												\
		(THIS_	LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(GetNamesFromIDs)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTags,				\
				LPGUID						lpPropSetGuid,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcPropNames,				\
				LPMAPINAMEID FAR * FAR *	lpppPropNames) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)											\
		(THIS_	ULONG						cPropNames,					\
				LPMAPINAMEID FAR *			lppPropNames,				\
				ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTags) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE	IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE			((ULONG) 0)
#define TBLSTAT_QCHANGED			((ULONG) 7)
#define TBLSTAT_SORTING				((ULONG) 9)
#define TBLSTAT_SORT_ERROR			((ULONG) 10)
#define TBLSTAT_SETTING_COLS		((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR		((ULONG) 13)
#define TBLSTAT_RESTRICTING			((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR		((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT			((ULONG) 0)
#define TBLTYPE_KEYSET				((ULONG) 1)
#define TBLTYPE_DYNAMIC				((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND		((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND		((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE		((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
	ULONG	ulPropTag;			/* Column to sort on */
	ULONG	ulOrder;			/* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
	ULONG	  		cSorts;		/* Number of sort columns in aSort below*/
	ULONG			cCategories;	/* 0 for non-categorized, up to cSorts */
	ULONG			cExpanded;		/* 0 if no categories start expanded, */
									/*		up to cExpanded */
	SSortOrder		aSort[MAPI_DIM];	/* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
	(offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
	(offsetof(SSortOrderSet,aSort) + \
	(UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
	ULONG	  		cSorts;			\
	ULONG			cCategories;	\
	ULONG			cExpanded;		\
	SSortOrder		aSort[_csort];	\
} _name

typedef ULONG 		BOOKMARK;

#define BOOKMARK_BEGINNING	((BOOKMARK) 0)		/* Before first row */
#define BOOKMARK_CURRENT	((BOOKMARK) 1)		/* Before current row */
#define BOOKMARK_END		((BOOKMARK) 2)		/* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING		((ULONG) 0x00000000)
#define FL_SUBSTRING		((ULONG) 0x00000001)
#define FL_PREFIX			((ULONG) 0x00000002)

#define FL_IGNORECASE		((ULONG) 0x00010000)
#define FL_IGNORENONSPACE	((ULONG) 0x00020000)
#define FL_LOOSE			((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction	FAR * LPSRestriction;

/* Restriction types */

#define RES_AND				((ULONG) 0x00000000)
#define RES_OR				((ULONG) 0x00000001)
#define RES_NOT				((ULONG) 0x00000002)
#define RES_CONTENT			((ULONG) 0x00000003)
#define RES_PROPERTY		((ULONG) 0x00000004)
#define RES_COMPAREPROPS	((ULONG) 0x00000005)
#define RES_BITMASK			((ULONG) 0x00000006)
#define RES_SIZE			((ULONG) 0x00000007)
#define RES_EXIST			((ULONG) 0x00000008)
#define RES_SUBRESTRICTION	((ULONG) 0x00000009)
#define RES_COMMENT			((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT		((ULONG) 0)		/* <  */
#define RELOP_LE		((ULONG) 1)		/* <= */
#define RELOP_GT		((ULONG) 2)		/* >  */
#define RELOP_GE		((ULONG) 3)		/* >= */
#define RELOP_EQ		((ULONG) 4)		/* == */
#define RELOP_NE		((ULONG) 5)		/* != */
#define RELOP_RE		((ULONG) 6)		/* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ		((ULONG) 0)		/* ==0 */
#define BMR_NEZ		((ULONG) 1)		/* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
	ULONG			ulReserved;
	LPSRestriction 	lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
	ULONG			ulFuzzyLevel;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
	ULONG			relBMR;
	ULONG			ulPropTag;
	ULONG			ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
	ULONG			relop;
	ULONG			ulPropTag1;
	ULONG			ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	ULONG			cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
	ULONG			ulReserved1;
	ULONG			ulPropTag;
	ULONG			ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
	ULONG			ulSubObject;
	LPSRestriction	lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
	ULONG			cValues; /* # of properties in lpProp */
	LPSRestriction	lpRes;
	LPSPropValue	lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
	ULONG	rt;			/* Restriction type */
	union
	{
		SComparePropsRestriction	resCompareProps;	/* first */
		SAndRestriction				resAnd;
		SOrRestriction				resOr;
		SNotRestriction				resNot;
		SContentRestriction			resContent;
		SPropertyRestriction		resProperty;
		SBitMaskRestriction			resBitMask;
		SSizeRestriction			resSize;
		SExistRestriction			resExist;
		SSubRestriction				resSub;
		SCommentRestriction			resComment;
	} res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS		((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW			((ULONG) 1)
#define TBL_EMPTY_CATEGORY		((ULONG) 2)
#define TBL_EXPANDED_CATEGORY	((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY	((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT			((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC			((ULONG) 0x00000001)
#define TBL_BATCH			((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD		((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE		((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(GetStatus)												\
		(THIS_	ULONG FAR *					lpulTableStatus,			\
				ULONG FAR *					lpulTableType) IPURE;		\
	MAPIMETHOD(SetColumns)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QueryColumns)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lpPropTagArray) IPURE;		\
	MAPIMETHOD(GetRowCount)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulCount) IPURE;			\
	MAPIMETHOD(SeekRow)													\
		(THIS_	BOOKMARK					bkOrigin,					\
				LONG						lRowCount,					\
				LONG FAR *					lplRowsSought) IPURE;		\
	MAPIMETHOD(SeekRowApprox)											\
		(THIS_	ULONG						ulNumerator,				\
				ULONG						ulDenominator) IPURE;		\
	MAPIMETHOD(QueryPosition)											\
		(THIS_	ULONG FAR *					lpulRow,					\
				ULONG FAR *					lpulNumerator,				\
				ULONG FAR *					lpulDenominator) IPURE;		\
	MAPIMETHOD(FindRow)													\
		(THIS_	LPSRestriction				lpRestriction,				\
				BOOKMARK					bkOrigin,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(Restrict)												\
		(THIS_	LPSRestriction				lpRestriction,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateBookmark)											\
		(THIS_	BOOKMARK FAR *				lpbkPosition) IPURE;		\
	MAPIMETHOD(FreeBookmark)											\
		(THIS_	BOOKMARK					bkPosition) IPURE;			\
	MAPIMETHOD(SortTable)												\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QuerySortOrder)											\
		(THIS_	LPSSortOrderSet FAR *		lppSortCriteria) IPURE;		\
	MAPIMETHOD(QueryRows)												\
		(THIS_	LONG						lRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows) IPURE;				\
	MAPIMETHOD(Abort) (THIS) IPURE;										\
	MAPIMETHOD(ExpandRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows,					\
				ULONG FAR *					lpulMoreRows) IPURE;		\
	MAPIMETHOD(CollapseRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulRowCount) IPURE;		\
	MAPIMETHOD(WaitForCompletion)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulTimeout,					\
				ULONG FAR *					lpulTableStatus) IPURE;		\
	MAPIMETHOD(GetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbInstanceKey,				\
				LPBYTE						lpbInstanceKey,				\
				ULONG FAR *					lpcbCollapseState,			\
				LPBYTE FAR *				lppbCollapseState) IPURE;	\
	MAPIMETHOD(SetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbCollapseState,			\
				LPBYTE						pbCollapseState,			\
				BOOKMARK FAR *				lpbkLocation) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{ 	0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
	0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER		((ULONG) 33)	/* Message Store */
#define MAPI_AB					((ULONG) 34)	/* Address Book */
#define MAPI_AB_PROVIDER		((ULONG) 35)	/* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER	((ULONG) 36)	/* Transport Provider */
#define MAPI_SPOOLER			((ULONG) 37)	/* Message Spooler */
#define MAPI_PROFILE_PROVIDER	((ULONG) 38)	/* Profile Provider */
#define MAPI_SUBSYSTEM			((ULONG) 39)	/* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER		((ULONG) 40)	/* Spooler Hook */

#define STATUS_VALIDATE_STATE	((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG	((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD	((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES		((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND	((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE	((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY	((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE		((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST	((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE	((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION		((ULONG) 0x00000080)
#define STATUS_OWN_STORE		((ULONG) 0x00000100)
/****** HOOK_INBOUND			((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND			((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE	((ULONG) 0x00000800)
#define	STATUS_PRIMARY_STORE	((ULONG) 0x00001000)
#define	STATUS_SECONDARY_STORE	((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define	STATUS_AVAILABLE		((ULONG) 0x00000001)
#define STATUS_OFFLINE			((ULONG) 0x00000002)
#define STATUS_FAILURE			((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED	((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE	((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH	((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED	((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE	((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH	((ULONG) 0x00400000)
#define	STATUS_REMOTE_ACCESS	((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI					((ULONG) 0x00000001)
#define	REFRESH_XP_HEADER_CACHE		((ULONG) 0x00010000)
#define	PROCESS_XP_HEADER_CACHE 	((ULONG) 0x00020000)
#define	FORCE_XP_CONNECT			((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT			((ULONG) 0x00080000)
#define CONFIG_CHANGED				((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION	((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI			((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY		((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD		((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD		((ULONG) 0x00000004)
#define FLUSH_FORCE			((ULONG) 0x00000008)
#define FLUSH_NO_UI			((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK		((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)									\
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SettingsDialog)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangePassword)											\
		(THIS_	__in LPTSTR						lpOldPass,					\
				__in LPTSTR						lpNewPass,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS		((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH		((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define SEARCH_RUNNING			((ULONG) 0x00000001)
#define SEARCH_REBUILD			((ULONG) 0x00000002)
#define SEARCH_RECURSIVE		((ULONG) 0x00000004)
#define SEARCH_FOREGROUND		((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH				((ULONG) 0x00000001)
#define RESTART_SEARCH			((ULONG) 0x00000002)
#define RECURSIVE_SEARCH		((ULONG) 0x00000004)
#define SHALLOW_SEARCH			((ULONG) 0x00000008)
#define FOREGROUND_SEARCH		((ULONG) 0x00000010)
#define BACKGROUND_SEARCH		((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(GetContentsTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(GetHierarchyTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetSearchCriteria)										\
		(THIS_	LPSRestriction				lpRestriction,				\
				LPENTRYLIST					lpContainerList,			\
				ULONG						ulSearchFlags) IPURE;		\
	MAPIMETHOD(GetSearchCriteria)										\
		(THIS_	ULONG						ulFlags,					\
				LPSRestriction FAR *		lppRestriction,				\
				LPENTRYLIST FAR *			lppContainerList,			\
				ULONG FAR *					lpulSearchState)IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *	IABContainer PR_CONTAINER_FLAGS values
 *	If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *	doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *	If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
	ULONG cFlags;
	ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS			((ULONG) 0x00000001)
#define AB_SUBCONTAINERS		((ULONG) 0x00000002)
#define AB_MODIFIABLE			((ULONG) 0x00000004)
#define AB_UNMODIFIABLE			((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN			((ULONG) 0x00000010)
#define AB_NOT_DEFAULT			((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT	((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE	((ULONG) 0x00000002)
#define CREATE_REPLACE			((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED			((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS			((ULONG) 0x00000001)
#define MAPI_RESOLVED			((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAdrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
	passing in the following flag in the ulFlags parameter.  Setting this flag
	indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)	((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC						MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED				MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS					MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED						MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED						MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE				MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED				MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED					MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG					MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT			MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT				MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED			MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID				MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR			MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD			MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD			MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED			MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS				MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT			MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED			MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB			MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG						MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG						MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST				MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST			MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST			MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES				MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED			MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED			MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED				MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED				MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED					MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED				MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT			MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD			MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE			MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN			MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED			MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED			MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED						MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED					MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED				MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING			MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED			MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN			MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED			MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB			MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR			MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE			MAPI_DIAG( 47 )

/* Values of PR_DELIVERY_POINT (MH_T_DELIVERY_POINT) */

#define MAPI_MH_DP_PUBLIC_UA						((ULONG) 0)
#define MAPI_MH_DP_PRIVATE_UA						((ULONG) 1)
#define MAPI_MH_DP_MS								((ULONG) 2)
#define MAPI_MH_DP_ML								((ULONG) 3)
#define MAPI_MH_DP_PDAU								((ULONG) 4)
#define MAPI_MH_DP_PDS_PATRON						((ULONG) 5)
#define MAPI_MH_DP_OTHER_AU							((ULONG) 6)


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)									\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT				((ULONG) 0x00000000)
#define FOLDER_GENERIC			((ULONG) 0x00000001)
#define FOLDER_SEARCH			((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE			((ULONG) 0x00000001)
#define MESSAGE_DIALOG			((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS			((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES			((ULONG) 0x00000001)
#define FOLDER_DIALOG			((ULONG) 0x00000002)
#define DEL_FOLDERS				((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED			((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE				((ULONG) 0x00000001)
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS			((ULONG) 0x00000010)
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT		((ULONG) 0x00000001) below */
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG			((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/******	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010) below */
/****** CLEAR_RN_PENDING		((ULONG) 0x00000020) below */
/****** CLEAR_NRN_PENDING		((ULONG) 0x00000040) below */


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED		((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN		((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED		((ULONG) 0x00000008)

/* Bits for remote message status */

#define	MSGSTATUS_REMOTE_DOWNLOAD	((ULONG) 0x00001000)
#define	MSGSTATUS_REMOTE_DELETE		((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT			((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED		((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN		((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED		((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)									\
	MAPIMETHOD(CreateMessage)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMESSAGE FAR *				lppMessage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateFolder)											\
		(THIS_	ULONG						ulFolderType,				\
				__in LPTSTR					lpszFolderName,				\
				__in LPTSTR					lpszFolderComment,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMAPIFOLDER FAR *			lppFolder) IPURE;			\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				__in LPTSTR					lpszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteFolder)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlags)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulMessageStatus) IPURE;	\
	MAPIMETHOD(SetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulNewStatus,				\
				ULONG						ulNewStatusMask,			\
				ULONG FAR *					lpulOldStatus) IPURE;		\
	MAPIMETHOD(SaveContentsSort)										\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(EmptyFolder)												\
		(THIS_	ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE	((ULONG) 0x00000001)
#define STORE_READONLY			((ULONG) 0x00000002)
#define STORE_SEARCH_OK			((ULONG) 0x00000004)
#define STORE_MODIFY_OK			((ULONG) 0x00000008)
#define STORE_CREATE_OK			((ULONG) 0x00000010)
#define STORE_ATTACH_OK			((ULONG) 0x00000020)
#define STORE_OLE_OK			((ULONG) 0x00000040)
#define STORE_SUBMIT_OK			((ULONG) 0x00000080)
#define STORE_NOTIFY_OK			((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK		((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK		((ULONG) 0x00000400)
#define STORE_RTF_OK			((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK	((ULONG) 0x00001000)
#define STORE_SORT_OK			((ULONG) 0x00002000)
#define	STORE_PUBLIC_FOLDERS	((ULONG) 0x00004000)
#define	STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES		((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define	LOGOFF_NO_WAIT			((ULONG) 0x00000001)
#define	LOGOFF_ORDERLY			((ULONG) 0x00000002)
#define	LOGOFF_PURGE			((ULONG) 0x00000004)
#define LOGOFF_ABORT			((ULONG) 0x00000008)
#define LOGOFF_QUIET			((ULONG) 0x00000010)

#define LOGOFF_COMPLETE			((ULONG) 0x00010000)
#define	LOGOFF_INBOUND			((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND			((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE	((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED				((ULONG) 0x00000001)
#define MSG_UNLOCKED			((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define	FOLDER_IPM_SUBTREE_VALID		((ULONG) 0x00000001)
#define	FOLDER_IPM_INBOX_VALID			((ULONG) 0x00000002)
#define	FOLDER_IPM_OUTBOX_VALID			((ULONG) 0x00000004)
#define	FOLDER_IPM_WASTEBASKET_VALID	((ULONG) 0x00000008)
#define	FOLDER_IPM_SENTMAIL_VALID		((ULONG) 0x00000010)
#define	FOLDER_VIEWS_VALID				((ULONG) 0x00000020)
#define	FOLDER_COMMON_VIEWS_VALID		((ULONG) 0x00000040)
#define	FOLDER_FINDER_VALID				((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)									\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetReceiveFolder)										\
		(THIS_	__in LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetReceiveFolder)										\
		(THIS_	__in LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID,					\
				__in LPTSTR FAR *				lppszExplicitClass) IPURE;	\
	MAPIMETHOD(GetReceiveFolderTable)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(StoreLogoff)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(AbortSubmit)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetOutgoingQueue)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(SetLockState)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG						ulLockState) IPURE;			\
	MAPIMETHOD(FinishedMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(NotifyNewMail)											\
		(THIS_	LPNOTIFICATION				lpNotification) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT				((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ			((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED		((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT			((ULONG) 0x00000004)
#define MSGFLAG_UNSENT			((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH		((ULONG) 0x00000010)
#define MSGFLAG_FROMME			((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED		((ULONG) 0x00000040)
#define MSGFLAG_RESEND			((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED		((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS	((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD			((ULONG) 0x00000002)
#define MODRECIP_MODIFY			((ULONG) 0x00000004)
#define MODRECIP_REMOVE			((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT		((ULONG) 0x00000001)
#define CLEAR_READ_FLAG			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG			((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED			((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED		((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT				((long)  1)
#define PRIO_NORMAL				((long)  0)
#define PRIO_NONURGENT			((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE					((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL				((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE					((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL	((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW			((long) 0)
#define IMPORTANCE_NORMAL		((long) 1)
#define IMPORTANCE_HIGH			((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)									\
	MAPIMETHOD(GetAttachmentTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenAttach)												\
		(THIS_	ULONG						ulAttachmentNum,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(CreateAttach)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulAttachmentNum,			\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(DeleteAttach)											\
		(THIS_	ULONG						ulAttachmentNum,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetRecipientTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyRecipients)										\
		(THIS_	ULONG						ulFlags,					\
				LPADRLIST					lpMods) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlag)												\
		(THIS_	ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT			((ULONG) 0x00000000)
#define ATTACH_BY_VALUE			((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE		((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE	((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY		((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG		((ULONG) 0x00000005)
#define ATTACH_OLE				((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX		((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL			((ULONG) 0x00000001)
#define DIALOG_SDI				((ULONG) 0x00000002)
#define DIALOG_OPTIONS			((ULONG) 0x00000004)
#define ADDRESS_ONE				((ULONG) 0x00000008)
#define AB_SELECTONLY			((ULONG) 0x00000010)
#define AB_RESOLVE				((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER			((ULONG) 0x00000000)
#define DT_DISTLIST			((ULONG) 0x00000001)
#define DT_FORUM			((ULONG) 0x00000002)
#define DT_AGENT			((ULONG) 0x00000003)
#define DT_ORGANIZATION		((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST	((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER	((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE		((ULONG) 0x00010000)
#define DT_GLOBAL			((ULONG) 0x00020000)
#define DT_LOCAL			((ULONG) 0x00030000)
#define DT_WAN				((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC		((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER			((ULONG) 0x01000000)
#define DT_FOLDER_LINK		((ULONG) 0x02000000)
#define DT_FOLDER_SPECIAL	((ULONG) 0x04000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
												LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
												LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
	ULONG				ulUIParam,
	LPVOID				lpvContext,
	ULONG				cbEntryID,
	LPENTRYID			lpSelection,
	ULONG				ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
	ULONG			cbABContEntryID;
	LPENTRYID		lpABContEntryID;
	ULONG			ulFlags;

	LPVOID			lpReserved;
	ULONG			ulHelpContext;
	LPTSTR			lpszHelpFileName;

	LPFNABSDI		lpfnABSDI;
	LPFNDISMISS		lpfnDismiss;
	LPVOID			lpvDismissContext;
	LPTSTR			lpszCaption;
	LPTSTR			lpszNewEntryTitle;
	LPTSTR			lpszDestWellsTitle;
	ULONG			cDestFields;
	ULONG			nDestFieldFocus;
	LPTSTR FAR *	lppszDestTitles;
	ULONG FAR *		lpulDestComps;
	LPSRestriction	lpContRestriction;
	LPSRestriction	lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED			((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG			((ULONG) 0x00000001)
#define MDB_WRITE				((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */
#define	MDB_TEMPORARY			((ULONG) 0x00000020)
#define MDB_NO_MAIL				((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG			((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED		((ULONG) 0x00000000)
#define  MAPI_DISABLED		((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Activate)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulUIParam) IPURE;			\
	MAPIMETHOD(GetState)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulState) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE		((ULONG) 0x00000001)
#define DT_EDITABLE			((ULONG) 0x00000002)
#define DT_REQUIRED			((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE	((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT	((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS		((ULONG) 0x00000020)
#define DT_SET_SELECTION	((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL			((ULONG) 0x00000000)
#define DTCT_EDIT			((ULONG) 0x00000001)
#define DTCT_LBX			((ULONG) 0x00000002)
#define DTCT_COMBOBOX		((ULONG) 0x00000003)
#define DTCT_DDLBX			((ULONG) 0x00000004)
#define DTCT_CHECKBOX		((ULONG) 0x00000005)
#define DTCT_GROUPBOX		((ULONG) 0x00000006)
#define DTCT_BUTTON			((ULONG) 0x00000007)
#define DTCT_PAGE			((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON	((ULONG) 0x00000009)
#define DTCT_MVLISTBOX		((ULONG) 0x0000000B)
#define DTCT_MVDDLBX		((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
	ULONG ulbLpszLabelName;
	ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
	DTBLLABEL	dtbllabel; \
	TCHAR		lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
	DTBLEDIT	dtbledit; \
	TCHAR		lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR		((ULONG) 0x00000001)
#define MAPI_NO_VBAR		((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
	ULONG ulFlags;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPRPropertyName;
	ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
	DTBLCOMBOBOX	dtblcombobox; \
	TCHAR			lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
	ULONG ulFlags;
	ULONG ulPRDisplayProperty;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
	DTBLCHECKBOX	dtblcheckbox; \
	TCHAR		lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
	DTBLGROUPBOX	dtblgroupbox; \
	TCHAR			lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
	DTBLBUTTON	dtblbutton; \
	TCHAR		lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulbLpszComponent;
	ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
	DTBLPAGE	dtblpage; \
	TCHAR		lpszLabel[n]; \
	TCHAR		lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulcButtons;
	ULONG ulPropTag;
	long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
	DTBLRADIOBUTTON dtblradiobutton; \
	TCHAR			lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE					0x00000002
#define SERVICE_UI_ALWAYS  			0x00000002		/* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED 			0x00000010
#define UI_CURRENT_PROVIDER_FIRST	0x00000004
/* MSG_SERVICE_UI_READ_ONLY 		0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProvider)											\
		(THIS_	__in LPTSTR						lpszProvider,				\
				ULONG						cValues,					\
				LPSPropValue				lpProps,					\
				ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				MAPIUID FAR *				lpUID) IPURE;				\
	MAPIMETHOD(DeleteProvider)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPIDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIForm.h ===
/*
 *	M A P I F O R M . H
 *
 *	Declarations of interfaces for clients and providers of MAPI
 *  forms and form registries.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIFORM_H
#define MAPIFORM_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifndef _MAC
typedef const RECT FAR *LPCRECT;
#endif

/* HFRMREG is an enumeration which represents a registry container.
 * Microsoft reserves the values from 0 to 0x3FFF for its own use.
 */

typedef ULONG HFRMREG;

#define HFRMREG_DEFAULT  0
#define HFRMREG_LOCAL    1
#define HFRMREG_PERSONAL 2
#define HFRMREG_FOLDER   3

DECLARE_MAPI_INTERFACE_PTR(IPersistMessage, LPPERSISTMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IMAPIMessageSite, LPMAPIMESSAGESITE);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewContext, LPMAPIVIEWCONTEXT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewAdviseSink, LPMAPIVIEWADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormAdviseSink, LPMAPIFORMADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormInfo, LPMAPIFORMINFO);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormMgr, LPMAPIFORMMGR);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormContainer, LPMAPIFORMCONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIForm, LPMAPIFORM);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormFactory, LPMAPIFORMFACTORY);

typedef const char FAR *FAR * LPPCSTR;
typedef LPMAPIFORMINFO FAR *LPPMAPIFORMINFO;

STDAPI MAPIOpenFormMgr(LPMAPISESSION pSession, LPMAPIFORMMGR FAR * ppmgr);
STDAPI MAPIOpenLocalFormContainer(LPMAPIFORMCONTAINER FAR * ppfcnt);


/*-- GetLastError ----------------------------------------------------------*/
/* This defines the GetLastError method held in common by most mapiform
 * interfaces.  It is defined separately so that an implementor may include
 * more than one mapiform interface in a class.
 */

#define MAPI_GETLASTERROR_METHOD(IPURE)                                 \
    MAPIMETHOD(GetLastError) (THIS_                                     \
        /*in*/  HRESULT hResult,                                        \
	/*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIERROR FAR * lppMAPIError) IPURE;                  \


/*-- IPersistMessage -------------------------------------------------------*/
/* This interface is implemented by forms and is used to save,
 * initialize and load forms to and from messages.
 */

#define MAPI_IPERSISTMESSAGE_METHODS(IPURE)                             \
    MAPIMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;             \
    MAPIMETHOD(IsDirty)(THIS) IPURE;                                    \
    MAPIMETHOD(InitNew)(THIS_                                           \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(Load)(THIS_                                              \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage,                                      \
		/*in*/ ULONG ulMessageStatus,                                   \
		/*in*/ ULONG ulMessageFlags) IPURE;                             \
    MAPIMETHOD(Save)(THIS_                                              \
        /*in*/ LPMESSAGE pMessage,                                      \
        /*in*/ ULONG fSameAsLoad) IPURE;                                \
    MAPIMETHOD(SaveCompleted)(THIS_                                     \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(HandsOffMessage)(THIS) IPURE;                            \

#undef INTERFACE
#define INTERFACE IPersistMessage
DECLARE_MAPI_INTERFACE_(IPersistMessage, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IPERSISTMESSAGE_METHODS(PURE)
};


/*-- IMAPIMessageSite ------------------------------------------------------*/

#define MAPI_IMAPIMESSAGESITE_METHODS(IPURE)                            \
    MAPIMETHOD(GetSession) (THIS_                                       \
        /*out*/ LPMAPISESSION FAR * ppSession) IPURE;                   \
    MAPIMETHOD(GetStore) (THIS_                                         \
        /*out*/ LPMDB FAR * ppStore) IPURE;                             \
    MAPIMETHOD(GetFolder) (THIS_                                        \
        /*out*/ LPMAPIFOLDER FAR * ppFolder) IPURE;                     \
    MAPIMETHOD(GetMessage) (THIS_                                       \
        /*out*/ LPMESSAGE FAR * ppmsg) IPURE;                           \
    MAPIMETHOD(GetFormManager) (THIS_                                   \
        /*out*/ LPMAPIFORMMGR FAR * ppFormMgr) IPURE;                   \
    MAPIMETHOD(NewMessage) (THIS_                                       \
        /*in*/  ULONG fComposeInFolder,                                 \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPPERSISTMESSAGE pPersistMessage,                       \
        /*out*/ LPMESSAGE FAR * ppMessage,                              \
        /*out*/ LPMAPIMESSAGESITE FAR * ppMessageSite,                  \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(CopyMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination) IPURE;                 \
    MAPIMETHOD(MoveMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination,                        \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(DeleteMessage) (THIS_                                    \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(SaveMessage) (THIS) IPURE;                               \
    MAPIMETHOD(SubmitMessage) (THIS_                                    \
		/*in*/ ULONG ulFlags) IPURE;                                    \
    MAPIMETHOD(GetSiteStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIMessageSite
DECLARE_MAPI_INTERFACE_(IMAPIMessageSite, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIMESSAGESITE_METHODS(PURE)
};


/*-- IMAPIForm -------------------------------------------------------------*/
/* This interface is implemented by forms for the benefit of viewers.
 * One method (ShutdownForm) is provided such that simple forms implementing
 * only IMAPIForm and IPersistMessage have reasonable embedding behavior.
 */

#define MAPI_IMAPIFORM_METHODS(IPURE)                                   \
    MAPIMETHOD(SetViewContext) (THIS_                                   \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext) IPURE;                  \
    MAPIMETHOD(GetViewContext) (THIS_                                   \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(ShutdownForm)(THIS_                                             \
        /*in*/  ULONG ulSaveOptions) IPURE;                             \
    MAPIMETHOD(DoVerb) (THIS_                                           \
        /*in*/  LONG iVerb,                                             \
        /*in*/  LPMAPIVIEWCONTEXT lpViewContext, /* can be null */      \
        /*in*/  ULONG hwndParent,                                       \
        /*in*/  LPCRECT lprcPosRect) IPURE;                             \
    MAPIMETHOD(Advise)(THIS_                                            \
        /*in*/  LPMAPIVIEWADVISESINK pAdvise,                           \
        /*out*/ ULONG FAR * pdwStatus) IPURE;                           \
    MAPIMETHOD(Unadvise) (THIS_                                         \
        /*in*/  ULONG ulConnection) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIForm
DECLARE_MAPI_INTERFACE_(IMAPIForm, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORM_METHODS(PURE)
};

typedef enum tagSAVEOPTS
{
	SAVEOPTS_SAVEIFDIRTY = 0,
	SAVEOPTS_NOSAVE = 1,
	SAVEOPTS_PROMPTSAVE = 2
} SAVEOPTS;


/*-- IMAPIViewContext ------------------------------------------------------*/
/* Implemented by viewers to support next/previous in forms.
 */

/* Structure passed in GetPrintSetup  */

typedef struct {
	ULONG ulFlags;  /* MAPI_UNICODE */
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	ULONG ulFirstPageNumber;
	ULONG fPrintAttachments;
} FORMPRINTSETUP, FAR * LPFORMPRINTSETUP;

/* Values for pulFormat in GetSaveStream */

#define SAVE_FORMAT_TEXT                1
#define SAVE_FORMAT_RICHTEXT            2

/* Values from 0 to 0x3fff are reserved for future definition by Microsoft */

#define MAPI_IMAPIVIEWCONTEXT_METHODS(IPURE)                            \
    MAPIMETHOD(SetAdviseSink)(THIS_                                     \
        /*in*/  LPMAPIFORMADVISESINK pmvns) IPURE;                      \
    MAPIMETHOD(ActivateNext)(THIS_                                      \
        /*in*/  ULONG ulDir,                                            \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(GetPrintSetup)(THIS_                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPFORMPRINTSETUP FAR * lppFormPrintSetup) IPURE;        \
    MAPIMETHOD(GetSaveStream)(THIS_                                     \
        /*out*/ ULONG FAR * pulFlags,                                   \
        /*out*/ ULONG FAR * pulFormat,                                  \
        /*out*/ LPSTREAM FAR * ppstm) IPURE;                            \
    MAPIMETHOD(GetViewStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIViewContext
DECLARE_MAPI_INTERFACE_(IMAPIViewContext, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIVIEWCONTEXT_METHODS(PURE)
};

#define VCSTATUS_NEXT                           0x00000001
#define VCSTATUS_PREV                           0x00000002
#define VCSTATUS_MODAL                          0x00000004
#define VCSTATUS_INTERACTIVE                    0x00000008
#define VCSTATUS_READONLY                       0x00000010
#define VCSTATUS_DELETE                         0x00010000
#define VCSTATUS_COPY                           0x00020000
#define VCSTATUS_MOVE                           0x00040000
#define VCSTATUS_SUBMIT                         0x00080000
#define VCSTATUS_DELETE_IS_MOVE                 0x00100000
#define VCSTATUS_SAVE                           0x00200000
#define VCSTATUS_NEW_MESSAGE                    0x00400000

#define VCDIR_NEXT                              VCSTATUS_NEXT
#define VCDIR_PREV                              VCSTATUS_PREV
#define VCDIR_DELETE                            VCSTATUS_DELETE
#define VCDIR_MOVE                              VCSTATUS_MOVE


/*-- IMAPIFormAdviseSink ---------------------------------------------------*/
/* Part of form server, held by view; receives notifications from the view.
 *
 * This part of the form server, but is not an interface on the form
 * object.  This means that clients should not expect to QueryInterface
 * from an IMAPIForm* or IOleObject* to this interface, or vice versa.
 */

#define MAPI_IMAPIFORMADVISESINK_METHODS(IPURE)                         \
    STDMETHOD(OnChange)(THIS_ ULONG ulDir) IPURE;                       \
    STDMETHOD(OnActivateNext)(THIS_                                     \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*out*/ LPPERSISTMESSAGE FAR * ppPersistMessage) IPURE;         \

#undef INTERFACE
#define INTERFACE IMAPIFormAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIFormAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIFORMADVISESINK_METHODS(PURE)
};


/*-- IMAPIViewAdviseSink ---------------------------------------------------*/
/* Part of view context, held by form; receives notifications from the form.
 */

#define MAPI_IMAPIVIEWADVISESINK_METHODS(IPURE)                         \
    MAPIMETHOD(OnShutdown)(THIS) IPURE;                                    \
    MAPIMETHOD(OnNewMessage)(THIS) IPURE;                               \
    MAPIMETHOD(OnPrint)(THIS_                                           \
        /*in*/ ULONG dwPageNumber,                                      \
        /*in*/ HRESULT hrStatus) IPURE;                                 \
    MAPIMETHOD(OnSubmitted) (THIS) IPURE;                               \
    MAPIMETHOD(OnSaved) (THIS) IPURE;                                   \

#undef INTERFACE
#define INTERFACE IMAPIViewAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIViewAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIVIEWADVISESINK_METHODS(PURE)
};


/*-- IMAPIFormInfo ---------------------------------------------------------*/
/* Is implemented by registries.  Describes the form.
 */

/* Single enum value */

typedef struct
{								/* fpev */
	LPTSTR pszDisplayName;		/* carries the display string */
	ULONG nVal;					/* the value for the above enumeration */
} SMAPIFormPropEnumVal, FAR * LPMAPIFORMPROPENUMVAL;

/* MAPI Form property descriptor */

/*
 * Values for the tag in the SMAPIFormProp structure
 *
 * Microsoft reserves the range from 0 to 0x3FFF for future use in its other
 * forms registry implementations.
 */

typedef ULONG FORMPROPSPECIALTYPE;

#define FPST_VANILLA                    0
#define FPST_ENUM_PROP                  1

typedef struct
{
	ULONG ulFlags;				/* Contains MAPI_UNICODE if strings are UNICODE */
	ULONG nPropType;			/* type of the property, hiword is 0 */
	MAPINAMEID nmid;			/* id of the property */
	LPTSTR pszDisplayName;
	FORMPROPSPECIALTYPE nSpecialType;	/* tag for the following union */
	union
	{
		struct
		{
			MAPINAMEID nmidIdx;
			ULONG cfpevAvailable;	/* # of enums */
			LPMAPIFORMPROPENUMVAL pfpevAvailable;
		} s1;					/* Property String/Number association Enumeration */
	} u;
} SMAPIFormProp, FAR * LPMAPIFORMPROP;

/* Array of form properties */

typedef struct
{
	ULONG cProps;
	ULONG ulPad;				/* Pad to 8-byte alignment for insurance */
	SMAPIFormProp aFormProp[MAPI_DIM];
} SMAPIFormPropArray, FAR * LPMAPIFORMPROPARRAY;

#define CbMAPIFormPropArray(_c) \
         (offsetof(SMAPIFormPropArray, aFormProp) + \
         (_c)*sizeof(SMAPIFormProp))

/* Structure defining the layout of an mapi verb description */

typedef struct
{
	LONG lVerb;
	LPTSTR szVerbname;
	DWORD fuFlags;
	DWORD grfAttribs;
	ULONG ulFlags;				/* Either 0 or MAPI_UNICODE */
} SMAPIVerb, FAR * LPMAPIVERB;

/* Structure used for returning arrays of mapi verbs */

typedef struct
{
	ULONG cMAPIVerb;			/* Number of verbs in the structure */
	SMAPIVerb aMAPIVerb[MAPI_DIM];
} SMAPIVerbArray, FAR * LPMAPIVERBARRAY;

#define CbMAPIVerbArray(_c) \
         (offsetof(SMAPIVerbArray, aMAPIVerb) + \
         (_c)*sizeof(SMAPIVerb))

#define MAPI_IMAPIFORMINFO_METHODS(IPURE)                               \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppFormPropArray) IPURE;       \
    MAPIMETHOD(CalcVerbSet)(THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIVERBARRAY FAR * ppMAPIVerbArray) IPURE;           \
    MAPIMETHOD(MakeIconFromBinary)(THIS_                                \
        /*in*/ ULONG nPropID,                                           \
        /*out*/ HICON FAR* phicon) IPURE;                               \
    MAPIMETHOD(SaveForm)(THIS_                                          \
        /*in*/ LPCTSTR szFileName) IPURE;                               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*out*/ LPMAPIFORMCONTAINER FAR * ppformcontainer) IPURE;       \

#undef INTERFACE
#define INTERFACE IMAPIFormInfo
DECLARE_MAPI_INTERFACE_(IMAPIFormInfo, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE) 	/* note: subsumes getlasterror */
	MAPI_IMAPIFORMINFO_METHODS(PURE)
};


/* Enumeration of permissible values for PR_FORM_MESSAGE_BEHAVIOR */

#define	MAPI_MESSAGE_BEHAVIOR_IPM 0
#define	MAPI_MESSAGE_BEHAVIOR_FOLDER 1


/*-- IMAPIFormMgr ----------------------------------------------------------*/
/* The client-visible interface for form resolution and dispatch.
 */

/* Structure containing an array of message class strings */

typedef struct
{
	ULONG cValues;
	LPCSTR aMessageClass[MAPI_DIM];
} SMessageClassArray, FAR * LPSMESSAGECLASSARRAY;

#define CbMessageClassArray(_c) \
        (offsetof(SMessageClassArray, aMessageClass) + (_c)*sizeof(LPCSTR))

/* Structure containing an array of IMAPIFormInfo interfaces */

typedef struct
{
	ULONG cForms;
	LPMAPIFORMINFO aFormInfo[MAPI_DIM];
} SMAPIFormInfoArray, FAR * LPSMAPIFORMINFOARRAY;

#define CbMAPIFormInfoArray(_c) \
         (offsetof(SMAPIFormInfoArray, aFormInfo) + \
         (_c)*sizeof(LPMAPIFORMINFO))

/* Flags for IMAPIFormMgr::SelectFormContainer */

#define MAPIFORM_SELECT_ALL_REGISTRIES           0
#define MAPIFORM_SELECT_FOLDER_REGISTRY_ONLY     1
#define MAPIFORM_SELECT_NON_FOLDER_REGISTRY_ONLY 2

/* Flags for IMAPIFormMgr::CalcFormPropSet */

#define FORMPROPSET_UNION                 0
#define FORMPROPSET_INTERSECTION          1

/* Flags for IMAPIFormMgr::ResolveMessageClass and
   IMAPIFormMgr::ResolveMultipleMessageClasses */

#define MAPIFORM_EXACTMATCH             0x0020

#define MAPI_IMAPIFORMMGR_METHODS(IPURE)                                \
    MAPIMETHOD(LoadForm)(THIS_                                          \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPMAPIMESSAGESITE pMessageSite,                         \
        /*in*/  LPMESSAGE pmsg,                                         \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  REFIID riid,                                            \
        /*out*/ LPVOID FAR *ppvObj) IPURE;                              \
    MAPIMETHOD(ResolveMessageClass)(THIS_                               \
        /*in*/  LPCSTR szMsgClass,                                      \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPMAPIFORMINFO FAR* ppResult) IPURE;                    \
    MAPIMETHOD(ResolveMultipleMessageClasses)(THIS_                     \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClasses,                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * pfrminfoarray) IPURE;        \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR* ppResults) IPURE;              \
    MAPIMETHOD(CreateForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfoToActivate,                      \
        /*in*/  REFIID refiidToAsk,                                     \
        /*out*/ LPVOID FAR* ppvObj) IPURE;                              \
    MAPIMETHOD(SelectForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*out*/ LPMAPIFORMINFO FAR * ppfrminfoReturned) IPURE;          \
    MAPIMETHOD(SelectMultipleForms)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(SelectFormContainer)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*in*/  HFRMREG hfrmreg,                                        \
        /*in*/  LPUNKNOWN lpunk,                                        \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(PrepareForm)(THIS_                                       \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfo) IPURE;                         \
    MAPIMETHOD(IsInConflict)(THIS_                                      \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  LPMAPIFOLDER pFolderFocus) IPURE;                       \

#undef         INTERFACE
#define         INTERFACE    IMAPIFormMgr
DECLARE_MAPI_INTERFACE_(IMAPIFormMgr, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMMGR_METHODS(PURE)
};

/* Platform numbers (used in .CFG files for forms) */

#define MAPIFORM_CPU_X86                1
#define MAPIFORM_CPU_MIP                2
#define MAPIFORM_CPU_AXP                3
#define MAPIFORM_CPU_PPC                4
#define MAPIFORM_CPU_M68                5

#define MAPIFORM_OS_WIN_31              1
#define MAPIFORM_OS_WINNT_35            2
#define MAPIFORM_OS_WIN_95              3
#define MAPIFORM_OS_MAC_7x              4
#define MAPIFORM_OS_WINNT_40            5

#define MAPIFORM_PLATFORM(CPU, OS) ((ULONG) ((((ULONG) CPU) << 16) | OS))


/*-- IMAPIFormContainer -------------------------------------------------*/

/*  Flags for IMAPIFormMgr::CalcFormPropSet */

/* #define FORMPROPSET_UNION            0   */
/* #define FORMPROPSET_INTERSECTION     1   */

/*  Flags for IMAPIFormMgr::InstallForm     */

#define MAPIFORM_INSTALL_DIALOG                 MAPI_DIALOG
#define MAPIFORM_INSTALL_OVERWRITEONCONFLICT    0x0010

/*  Flags for IMAPIFormContainer::ResolveMessageClass and
    IMAPIFormContainer::ResolveMultipleMessageClasses */
/* #define MAPIFORM_EXACTIMATCH    0x0020   */

#define MAPI_IMAPIFORMCONTAINER_METHODS(IPURE)                       \
    MAPIMETHOD(InstallForm)(THIS_                                   \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR szCfgPathName) IPURE;                           \
    MAPIMETHOD(RemoveForm)(THIS_                                        \
        /*in*/  LPCSTR szMessageClass) IPURE;                           \
    MAPIMETHOD(ResolveMessageClass) (THIS_                              \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMINFO FAR * pforminfo) IPURE;                  \
    MAPIMETHOD(ResolveMultipleMessageClasses) (THIS_                    \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClassArray,                    \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppResults) IPURE;             \
    MAPIMETHOD(GetDisplay)(THIS_                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPTSTR FAR * pszDisplayName) IPURE;                     \

#undef INTERFACE
#define INTERFACE IMAPIFormContainer
DECLARE_MAPI_INTERFACE_(IMAPIFormContainer, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMCONTAINER_METHODS(PURE)
};

/*-- IMAPIFormFactory ------------------------------------------------------*/

#define MAPI_IMAPIFORMFACTORY_METHODS(IPURE)                            \
    MAPIMETHOD(CreateClassFactory) (THIS_                               \
        /*in*/  REFCLSID clsidForm,                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPCLASSFACTORY FAR * lppClassFactory) IPURE;            \
    MAPIMETHOD(LockServer) (THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  ULONG fLockServer) IPURE;                               \

#undef INTERFACE
#define INTERFACE IMAPIFormFactory
DECLARE_MAPI_INTERFACE_(IMAPIFormFactory, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMFACTORY_METHODS(PURE)
};

#endif							/* MAPIFORM_H */


=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIOID.h ===
/*
 *  M A P I O I D . H
 *
 *  MAPI OID definition header file
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIOID_
#define _MAPIOID_

/*
 *  MAPI 1.0 Object Identifiers (OID's)
 *
 *  All MAPI 1.0 OIDs are prefixed by the segment
 *
 *      {iso(1) ansi(2) usa(840) microsoft(113556) mapi(3)}
 *
 *  All MAPI 1.0 tags are also include the addistion segment
 *
 *      {tags(10)}
 *
 *  All MAPI 1.0 encodings are also include the addistion segment
 *
 *      {encodeings(11)}
 *
 *  The set of defined tags are as follows
 *
 *   {{mapiprefix} {tags} {tnef(1)}}                        MAPI 1.0 TNEF encapsulation tag
 *
 *   {{mapiprefix} {tags} {ole(3)}}                         MAPI 1.0 OLE prefix
 *   {{mapiprefix} {tags} {ole(3)} {v1(1)}}                 MAPI 1.0 OLE 1.0 prefix
 *   {{mapiprefix} {tags} {ole(3)} {v1(1)} {storage(1)}}    MAPI 1.0 OLE 1.0 OLESTREAM
 *   {{mapiprefix} {tags} {ole(3)} {v2(2)}}                 MAPI 1.0 OLE 2.0 prefix
 *   {{mapiprefix} {tags} {ole(3)} {v2(2)} {storage(1)}}    MAPI 1.0 OLE 2.0 IStorage
 *
 *  The set of defined encodings are as follows
 *
 *   {{mapiprefix} {encodings} {MacBinary(1)}}              MAPI 1.0 MacBinary
 */

#define OID_TAG         0x0A
#define OID_ENCODING    0x0B

#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE FAR * name

#define CB_OID_1        9
#define CB_OID_2        10
#define CB_OID_3        11
#define CB_OID_4        12

#ifdef INITOID
#include <initoid.h>
#endif

#ifdef  USES_OID_TNEF
DEFINE_OID_1(OID_TNEF, OID_TAG, 0x01);
#define CB_OID_TNEF CB_OID_1
#endif

#ifdef  USES_OID_OLE
DEFINE_OID_1(OID_OLE, OID_TAG, 0x03);
#define CB_OID_OLE CB_OID_1
#endif

#ifdef  USES_OID_OLE1
DEFINE_OID_2(OID_OLE1, OID_TAG, 0x03, 0x01);
#define CB_OID_OLE1 CB_OID_2
#endif

#ifdef  USES_OID_OLE1_STORAGE
DEFINE_OID_3(OID_OLE1_STORAGE, OID_TAG, 0x03, 0x01, 0x01);
#define CB_OID_OLE1_STORAGE CB_OID_3
#endif

#ifdef  USES_OID_OLE2
DEFINE_OID_2(OID_OLE2, OID_TAG, 0x03, 0x02);
#define CB_OID_OLE2 CB_OID_2
#endif

#ifdef  USES_OID_OLE2_STORAGE
DEFINE_OID_3(OID_OLE2_STORAGE, OID_TAG, 0x03, 0x02, 0x01);
#define CB_OID_OLE2_STORAGE CB_OID_3
#endif

#ifdef  USES_OID_MAC_BINARY
DEFINE_OID_1(OID_MAC_BINARY, OID_ENCODING, 0x01);
#define CB_OID_MAC_BINARY CB_OID_1
#endif

#ifdef  USES_OID_MIMETAG
DEFINE_OID_1(OID_MIMETAG, OID_TAG, 0x04);
#define CB_OID_MIMETAG CB_OID_1
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPITags.h ===
/*
 *	M A P I T A G S . H
 *
 *	Property tag definitions for standard properties of MAPI
 *	objects.
 *
 *	The following ranges should be used for all property IDs. Note that
 *	property IDs for objects other than messages and recipients should
 *	all fall in the range 0x3000 to 0x3FFF:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	0001	0BFF	MAPI_defined envelope property
 *	0C00	0DFF	MAPI_defined per-recipient property
 *	0E00	0FFF	MAPI_defined non-transmittable property
 *	1000	2FFF	MAPI_defined message content property
 *
 *	3000	3FFF	MAPI_defined property (usually not message or recipient)
 *
 *	4000	57FF	Transport-defined envelope property
 *	5800	5FFF	Transport-defined per-recipient property
 *	6000	65FF	User-defined non-transmittable property
 *	6600	67FF	Provider-defined internal non-transmittable property
 *	6800	7BFF	Message class-defined content property
 *	7C00	7FFF	Message class-defined non-transmittable
 *					property
 *
 *	8000	FFFE	User-defined Name-to-id mapped property
 *
 *	The 3000-3FFF range is further subdivided as follows:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	33FF	Common property such as display name, entry ID
 *	3400	35FF	Message store object
 *	3600	36FF	Folder or AB container
 *	3700	38FF	Attachment
 *	3900	39FF	Address book object
 *	3A00	3BFF	Mail user
 *	3C00	3CFF	Distribution list
 *	3D00	3DFF	Profile section
 *	3E00	3FFF	Status object
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	MAPITAGS_H
#define	MAPITAGS_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
	((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
	(PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *	Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE						PROP_TAG( PT_LONG,		0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED				PROP_TAG( PT_BOOLEAN,	0x0002)
#define PR_AUTHORIZING_USERS						PROP_TAG( PT_BINARY,	0x0003)
#define PR_AUTO_FORWARD_COMMENT						PROP_TAG( PT_TSTRING,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_W					PROP_TAG( PT_UNICODE,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_A					PROP_TAG( PT_STRING8,	0x0004)
#define PR_AUTO_FORWARDED							PROP_TAG( PT_BOOLEAN,	0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID		PROP_TAG( PT_BINARY,	0x0006)
#define PR_CONTENT_CORRELATOR						PROP_TAG( PT_BINARY,	0x0007)
#define PR_CONTENT_IDENTIFIER						PROP_TAG( PT_TSTRING,	0x0008)
#define PR_CONTENT_IDENTIFIER_W						PROP_TAG( PT_UNICODE,	0x0008)
#define PR_CONTENT_IDENTIFIER_A						PROP_TAG( PT_STRING8,	0x0008)
#define PR_CONTENT_LENGTH							PROP_TAG( PT_LONG,		0x0009)
#define PR_CONTENT_RETURN_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x000A)



#define PR_CONVERSATION_KEY							PROP_TAG( PT_BINARY,	0x000B)

#define PR_CONVERSION_EITS							PROP_TAG( PT_BINARY,	0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x000D)
#define PR_CONVERTED_EITS							PROP_TAG( PT_BINARY,	0x000E)
#define PR_DEFERRED_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x000F)
#define PR_DELIVER_TIME								PROP_TAG( PT_SYSTIME,	0x0010)
#define PR_DISCARD_REASON							PROP_TAG( PT_LONG,		0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS					PROP_TAG( PT_BOOLEAN,	0x0012)
#define PR_DL_EXPANSION_HISTORY						PROP_TAG( PT_BINARY,	0x0013)
#define PR_DL_EXPANSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x0014)
#define PR_EXPIRY_TIME								PROP_TAG( PT_SYSTIME,	0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0016)
#define PR_IMPORTANCE								PROP_TAG( PT_LONG,		0x0017)
#define PR_IPM_ID									PROP_TAG( PT_BINARY,	0x0018)
#define PR_LATEST_DELIVERY_TIME						PROP_TAG( PT_SYSTIME,	0x0019)
#define PR_MESSAGE_CLASS							PROP_TAG( PT_TSTRING,	0x001A)
#define PR_MESSAGE_CLASS_W							PROP_TAG( PT_UNICODE,	0x001A)
#define PR_MESSAGE_CLASS_A							PROP_TAG( PT_STRING8,	0x001A)
#define PR_MESSAGE_DELIVERY_ID						PROP_TAG( PT_BINARY,	0x001B)





#define PR_MESSAGE_SECURITY_LABEL					PROP_TAG( PT_BINARY,	0x001E)
#define PR_OBSOLETED_IPMS							PROP_TAG( PT_BINARY,	0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME		PROP_TAG( PT_BINARY,	0x0020)
#define PR_ORIGINAL_EITS							PROP_TAG( PT_BINARY,	0x0021)
#define PR_ORIGINATOR_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS				PROP_TAG( PT_BINARY,	0x0024)



#define PR_PARENT_KEY								PROP_TAG( PT_BINARY,	0x0025)
#define PR_PRIORITY									PROP_TAG( PT_LONG,		0x0026)



#define PR_ORIGIN_CHECK								PROP_TAG( PT_BINARY,	0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED			PROP_TAG( PT_BOOLEAN,	0x0028)
#define PR_READ_RECEIPT_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x0029)
#define PR_RECEIPT_TIME								PROP_TAG( PT_SYSTIME,	0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED		PROP_TAG( PT_BOOLEAN,	0x002B)
#define PR_REDIRECTION_HISTORY						PROP_TAG( PT_BINARY,	0x002C)
#define PR_RELATED_IPMS								PROP_TAG( PT_BINARY,	0x002D)
#define PR_ORIGINAL_SENSITIVITY						PROP_TAG( PT_LONG,		0x002E)
#define	PR_LANGUAGES								PROP_TAG( PT_TSTRING,	0x002F)
#define	PR_LANGUAGES_W								PROP_TAG( PT_UNICODE,	0x002F)
#define	PR_LANGUAGES_A								PROP_TAG( PT_STRING8,	0x002F)
#define PR_REPLY_TIME								PROP_TAG( PT_SYSTIME,	0x0030)
#define PR_REPORT_TAG								PROP_TAG( PT_BINARY,	0x0031)
#define PR_REPORT_TIME								PROP_TAG( PT_SYSTIME,	0x0032)
#define PR_RETURNED_IPM								PROP_TAG( PT_BOOLEAN,	0x0033)
#define PR_SECURITY									PROP_TAG( PT_LONG,		0x0034)
#define	PR_INCOMPLETE_COPY							PROP_TAG( PT_BOOLEAN,	0x0035)
#define PR_SENSITIVITY								PROP_TAG( PT_LONG,		0x0036)
#define PR_SUBJECT									PROP_TAG( PT_TSTRING,	0x0037)
#define PR_SUBJECT_W								PROP_TAG( PT_UNICODE,	0x0037)
#define PR_SUBJECT_A								PROP_TAG( PT_STRING8,	0x0037)
#define PR_SUBJECT_IPM								PROP_TAG( PT_BINARY,	0x0038)
#define PR_CLIENT_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0039)
#define PR_REPORT_NAME								PROP_TAG( PT_TSTRING,	0x003A)
#define PR_REPORT_NAME_W							PROP_TAG( PT_UNICODE,	0x003A)
#define PR_REPORT_NAME_A							PROP_TAG( PT_STRING8,	0x003A)
#define	PR_SENT_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x003B)
#define PR_X400_CONTENT_TYPE						PROP_TAG( PT_BINARY,	0x003C)
#define PR_SUBJECT_PREFIX							PROP_TAG( PT_TSTRING,	0x003D)
#define PR_SUBJECT_PREFIX_W	 						PROP_TAG( PT_UNICODE,	0x003D)
#define PR_SUBJECT_PREFIX_A	 						PROP_TAG( PT_STRING8,	0x003D)
#define PR_NON_RECEIPT_REASON						PROP_TAG( PT_LONG,		0x003E)
#define PR_RECEIVED_BY_ENTRYID						PROP_TAG( PT_BINARY,	0x003F)
#define PR_RECEIVED_BY_NAME							PROP_TAG( PT_TSTRING,	0x0040)
#define PR_RECEIVED_BY_NAME_W						PROP_TAG( PT_UNICODE,	0x0040)
#define PR_RECEIVED_BY_NAME_A						PROP_TAG( PT_STRING8,	0x0040)
#define	PR_SENT_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0041)
#define PR_SENT_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0042)
#define PR_SENT_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0042)
#define PR_SENT_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0043)
#define PR_RCVD_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0044)
#define PR_REPORT_ENTRYID							PROP_TAG( PT_BINARY,	0x0045)
#define PR_READ_RECEIPT_ENTRYID						PROP_TAG( PT_BINARY,	0x0046)
#define PR_MESSAGE_SUBMISSION_ID					PROP_TAG( PT_BINARY,	0x0047)
#define PR_PROVIDER_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0048)
#define	PR_ORIGINAL_SUBJECT							PROP_TAG( PT_TSTRING,	0x0049)
#define	PR_ORIGINAL_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0049)
#define	PR_ORIGINAL_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0049)
#define PR_DISC_VAL									PROP_TAG( PT_BOOLEAN,	0x004A)
#define PR_ORIG_MESSAGE_CLASS						PROP_TAG( PT_TSTRING,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_W						PROP_TAG( PT_UNICODE,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_A						PROP_TAG( PT_STRING8,	0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID					PROP_TAG( PT_BINARY,	0x004C)
#define PR_ORIGINAL_AUTHOR_NAME						PROP_TAG( PT_TSTRING,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W					PROP_TAG( PT_UNICODE,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A					PROP_TAG( PT_STRING8,	0x004D)
#define PR_ORIGINAL_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES					PROP_TAG( PT_BINARY,	0x004F)
#define PR_REPLY_RECIPIENT_NAMES					PROP_TAG( PT_TSTRING,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W					PROP_TAG( PT_UNICODE,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A					PROP_TAG( PT_STRING8,	0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0053)
#define PR_REPORT_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0054)
#define	PR_ORIGINAL_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0056)

#define	PR_MESSAGE_TO_ME							PROP_TAG( PT_BOOLEAN,	0x0057)
#define	PR_MESSAGE_CC_ME							PROP_TAG( PT_BOOLEAN,	0x0058)
#define	PR_MESSAGE_RECIP_ME							PROP_TAG( PT_BOOLEAN,	0x0059)

#define PR_ORIGINAL_SENDER_NAME						PROP_TAG( PT_TSTRING,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_W					PROP_TAG( PT_UNICODE,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_A					PROP_TAG( PT_STRING8,	0x005A)
#define	PR_ORIGINAL_SENDER_ENTRYID					PROP_TAG( PT_BINARY,	0x005B)
#define	PR_ORIGINAL_SENDER_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME			PROP_TAG( PT_TSTRING,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W		PROP_TAG( PT_UNICODE,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A		PROP_TAG( PT_STRING8,	0x005D)
#define	PR_ORIGINAL_SENT_REPRESENTING_ENTRYID		PROP_TAG( PT_BINARY,	0x005E)
#define	PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY	PROP_TAG( PT_BINARY,	0x005F)

#define PR_START_DATE								PROP_TAG( PT_SYSTIME,	0x0060)
#define PR_END_DATE									PROP_TAG( PT_SYSTIME,	0x0061)
#define PR_OWNER_APPT_ID							PROP_TAG( PT_LONG,		0x0062)
#define PR_RESPONSE_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0063)

#define PR_SENT_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x0067)

#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W	PROP_TAG( PT_UNICODE,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A	PROP_TAG( PT_STRING8,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x0069)

#define	PR_CONVERSATION_TOPIC						PROP_TAG( PT_TSTRING,	0x0070)
#define	PR_CONVERSATION_TOPIC_W						PROP_TAG( PT_UNICODE,	0x0070)
#define	PR_CONVERSATION_TOPIC_A						PROP_TAG( PT_STRING8,	0x0070)
#define	PR_CONVERSATION_INDEX						PROP_TAG( PT_BINARY,	0x0071)

#define PR_ORIGINAL_DISPLAY_BCC						PROP_TAG( PT_TSTRING,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_W					PROP_TAG( PT_UNICODE,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_A					PROP_TAG( PT_STRING8,	0x0072)
#define PR_ORIGINAL_DISPLAY_CC						PROP_TAG( PT_TSTRING,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_W					PROP_TAG( PT_UNICODE,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_A					PROP_TAG( PT_STRING8,	0x0073)
#define PR_ORIGINAL_DISPLAY_TO						PROP_TAG( PT_TSTRING,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_W					PROP_TAG( PT_UNICODE,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_A					PROP_TAG( PT_STRING8,	0x0074)

#define PR_RECEIVED_BY_ADDRTYPE						PROP_TAG( PT_TSTRING,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_W					PROP_TAG( PT_UNICODE,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_A					PROP_TAG( PT_STRING8,	0x0075)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS				PROP_TAG( PT_TSTRING,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_W				PROP_TAG( PT_UNICODE,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_A				PROP_TAG( PT_STRING8,	0x0076)

#define PR_RCVD_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0077)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0078)

#define PR_ORIGINAL_AUTHOR_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0079)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x007A)

#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W		PROP_TAG( PT_UNICODE,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A		PROP_TAG( PT_STRING8,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x007C)

#define PR_TRANSPORT_MESSAGE_HEADERS				PROP_TAG(PT_TSTRING,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_W				PROP_TAG(PT_UNICODE,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_A				PROP_TAG(PT_STRING8,	0x007D)

#define PR_DELEGATION								PROP_TAG(PT_BINARY,		0x007E)

#define PR_TNEF_CORRELATION_KEY						PROP_TAG(PT_BINARY,		0x007F)



/*
 *	Message content properties
 */

#define PR_BODY										PROP_TAG( PT_TSTRING,	0x1000)
#define PR_BODY_W									PROP_TAG( PT_UNICODE,	0x1000)
#define PR_BODY_A									PROP_TAG( PT_STRING8,	0x1000)
#define PR_REPORT_TEXT								PROP_TAG( PT_TSTRING,	0x1001)
#define PR_REPORT_TEXT_W							PROP_TAG( PT_UNICODE,	0x1001)
#define PR_REPORT_TEXT_A							PROP_TAG( PT_STRING8,	0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY		PROP_TAG( PT_BINARY,	0x1002)
#define PR_REPORTING_DL_NAME						PROP_TAG( PT_BINARY,	0x1003)
#define PR_REPORTING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC						PROP_TAG( PT_LONG,		0x1006)
#define PR_RTF_SYNC_BODY_COUNT						PROP_TAG( PT_LONG,		0x1007)
#define PR_RTF_SYNC_BODY_TAG						PROP_TAG( PT_TSTRING,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_W						PROP_TAG( PT_UNICODE,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_A						PROP_TAG( PT_STRING8,	0x1008)
#define PR_RTF_COMPRESSED							PROP_TAG( PT_BINARY,	0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT					PROP_TAG( PT_LONG,		0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT					PROP_TAG( PT_LONG,		0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID		PROP_TAG( PT_BINARY,	0x1012)

/*
 *  Reserved 0x1100-0x1200
 */


/*
 *	Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK					PROP_TAG( PT_BINARY,	0x0C00)
#define PR_EXPLICIT_CONVERSION						PROP_TAG( PT_LONG,		0x0C01)
#define PR_IPM_RETURN_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0C02)
#define PR_MESSAGE_TOKEN							PROP_TAG( PT_BINARY,	0x0C03)
#define PR_NDR_REASON_CODE							PROP_TAG( PT_LONG,		0x0C04)
#define PR_NDR_DIAG_CODE							PROP_TAG( PT_LONG,		0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0C06)
#define PR_DELIVERY_POINT							PROP_TAG( PT_LONG,		0x0C07)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT	PROP_TAG( PT_BINARY,	0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY	PROP_TAG( PT_BOOLEAN,	0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE					PROP_TAG( PT_LONG,		0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST			PROP_TAG( PT_LONG,		0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS				PROP_TAG( PT_BINARY,	0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES			PROP_TAG( PT_BINARY,	0x0C10)
#define PR_PROOF_OF_DELIVERY						PROP_TAG( PT_BINARY,	0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED				PROP_TAG( PT_BOOLEAN,	0x0C12)
#define PR_RECIPIENT_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE				PROP_TAG( PT_TSTRING,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W			PROP_TAG( PT_UNICODE,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A			PROP_TAG( PT_STRING8,	0x0C14)
#define PR_RECIPIENT_TYPE							PROP_TAG( PT_LONG,		0x0C15)
#define PR_REGISTERED_MAIL_TYPE						PROP_TAG( PT_LONG,		0x0C16)
#define PR_REPLY_REQUESTED							PROP_TAG( PT_BOOLEAN,	0x0C17)
#define PR_REQUESTED_DELIVERY_METHOD				PROP_TAG( PT_LONG,		0x0C18)
#define PR_SENDER_ENTRYID							PROP_TAG( PT_BINARY,	0x0C19)
#define PR_SENDER_NAME								PROP_TAG( PT_TSTRING,	0x0C1A)
#define PR_SENDER_NAME_W							PROP_TAG( PT_UNICODE,	0x0C1A)
#define PR_SENDER_NAME_A							PROP_TAG( PT_STRING8,	0x0C1A)
#define PR_SUPPLEMENTARY_INFO						PROP_TAG( PT_TSTRING,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W						PROP_TAG( PT_UNICODE,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A						PROP_TAG( PT_STRING8,	0x0C1B)
#define PR_TYPE_OF_MTS_USER							PROP_TAG( PT_LONG,		0x0C1C)
#define PR_SENDER_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0C1D)
#define PR_SENDER_ADDRTYPE							PROP_TAG( PT_TSTRING,	0x0C1E)
#define PR_SENDER_ADDRTYPE_W						PROP_TAG( PT_UNICODE,	0x0C1E)
#define PR_SENDER_ADDRTYPE_A						PROP_TAG( PT_STRING8,	0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS						PROP_TAG( PT_TSTRING,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W					PROP_TAG( PT_UNICODE,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A					PROP_TAG( PT_STRING8,	0x0C1F)

/*
 *	Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION							PROP_TAG( PT_I8,		0x0E00)
#define PR_DELETE_AFTER_SUBMIT						PROP_TAG( PT_BOOLEAN,	0x0E01)
#define PR_DISPLAY_BCC								PROP_TAG( PT_TSTRING,	0x0E02)
#define PR_DISPLAY_BCC_W							PROP_TAG( PT_UNICODE,	0x0E02)
#define PR_DISPLAY_BCC_A							PROP_TAG( PT_STRING8,	0x0E02)
#define PR_DISPLAY_CC								PROP_TAG( PT_TSTRING,	0x0E03)
#define PR_DISPLAY_CC_W								PROP_TAG( PT_UNICODE,	0x0E03)
#define PR_DISPLAY_CC_A								PROP_TAG( PT_STRING8,	0x0E03)
#define PR_DISPLAY_TO								PROP_TAG( PT_TSTRING,	0x0E04)
#define PR_DISPLAY_TO_W								PROP_TAG( PT_UNICODE,	0x0E04)
#define PR_DISPLAY_TO_A								PROP_TAG( PT_STRING8,	0x0E04)
#define PR_PARENT_DISPLAY							PROP_TAG( PT_TSTRING,	0x0E05)
#define PR_PARENT_DISPLAY_W							PROP_TAG( PT_UNICODE,	0x0E05)
#define PR_PARENT_DISPLAY_A							PROP_TAG( PT_STRING8,	0x0E05)
#define PR_MESSAGE_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0E06)
#define PR_MESSAGE_FLAGS							PROP_TAG( PT_LONG,		0x0E07)
#define PR_MESSAGE_SIZE								PROP_TAG( PT_LONG,		0x0E08)
#define PR_PARENT_ENTRYID							PROP_TAG( PT_BINARY,	0x0E09)
#define PR_SENTMAIL_ENTRYID							PROP_TAG( PT_BINARY,	0x0E0A)
#define PR_CORRELATE								PROP_TAG( PT_BOOLEAN,	0x0E0C)
#define PR_CORRELATE_MTSID							PROP_TAG( PT_BINARY,	0x0E0D)
#define PR_DISCRETE_VALUES							PROP_TAG( PT_BOOLEAN,	0x0E0E)
#define PR_RESPONSIBILITY							PROP_TAG( PT_BOOLEAN,	0x0E0F)
#define	PR_SPOOLER_STATUS							PROP_TAG( PT_LONG,		0x0E10)
#define	PR_TRANSPORT_STATUS							PROP_TAG( PT_LONG,		0x0E11)
#define PR_MESSAGE_RECIPIENTS						PROP_TAG( PT_OBJECT,	0x0E12)
#define PR_MESSAGE_ATTACHMENTS						PROP_TAG( PT_OBJECT,	0x0E13)
#define PR_SUBMIT_FLAGS								PROP_TAG( PT_LONG,		0x0E14)
#define PR_RECIPIENT_STATUS							PROP_TAG( PT_LONG,		0x0E15)
#define	PR_TRANSPORT_KEY							PROP_TAG( PT_LONG,		0x0E16)
#define PR_MSG_STATUS								PROP_TAG( PT_LONG,		0x0E17)
#define	PR_MESSAGE_DOWNLOAD_TIME					PROP_TAG( PT_LONG,		0x0E18)
#define PR_CREATION_VERSION							PROP_TAG( PT_I8,		0x0E19)
#define PR_MODIFY_VERSION							PROP_TAG( PT_I8,		0x0E1A)
#define PR_HASATTACH								PROP_TAG( PT_BOOLEAN,	0x0E1B)
#define PR_BODY_CRC									PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT						PROP_TAG( PT_TSTRING,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0E1D)
#define PR_RTF_IN_SYNC								PROP_TAG( PT_BOOLEAN,	0x0E1F)
#define PR_ATTACH_SIZE								PROP_TAG( PT_LONG,		0x0E20)
#define PR_ATTACH_NUM								PROP_TAG( PT_LONG,		0x0E21)
#define PR_PREPROCESS								PROP_TAG( PT_BOOLEAN,	0x0E22)

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

#define PR_ORIGINATING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x0E25)
#define PR_PROOF_OF_SUBMISSION						PROP_TAG( PT_BINARY,	0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	32FF	MAPI_defined common property
 *	3200	33FF	MAPI_defined form property
 *	3400	35FF	MAPI_defined message store property
 *	3600	36FF	MAPI_defined Folder or AB Container property
 *	3700	38FF	MAPI_defined attachment property
 *	3900	39FF	MAPI_defined address book property
 *	3A00	3BFF	MAPI_defined mailuser property
 *	3C00	3CFF	MAPI_defined DistList property
 *	3D00	3DFF	MAPI_defined Profile Section property
 *	3E00	3EFF	MAPI_defined Status property
 *	3F00	3FFF	MAPI_defined display table property
 */

/*
 *	Properties common to numerous MAPI objects.
 *
 *	Those properties that can appear on messages are in the
 *	non-transmittable range for messages. They start at the high
 *	end of that range and work down.
 *
 *	Properties that never appear on messages are defined in the common
 *	property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID									PROP_TAG( PT_BINARY,	0x0FFF)
#define PR_OBJECT_TYPE								PROP_TAG( PT_LONG,		0x0FFE)
#define PR_ICON										PROP_TAG( PT_BINARY,	0x0FFD)
#define PR_MINI_ICON								PROP_TAG( PT_BINARY,	0x0FFC)
#define PR_STORE_ENTRYID							PROP_TAG( PT_BINARY,	0x0FFB)
#define PR_STORE_RECORD_KEY							PROP_TAG( PT_BINARY,	0x0FFA)
#define PR_RECORD_KEY								PROP_TAG( PT_BINARY,	0x0FF9)
#define PR_MAPPING_SIGNATURE						PROP_TAG( PT_BINARY,	0x0FF8)
#define PR_ACCESS_LEVEL								PROP_TAG( PT_LONG,		0x0FF7)
#define PR_INSTANCE_KEY								PROP_TAG( PT_BINARY,	0x0FF6)
#define PR_ROW_TYPE									PROP_TAG( PT_LONG,		0x0FF5)
#define PR_ACCESS									PROP_TAG( PT_LONG,		0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID									PROP_TAG( PT_LONG,		0x3000)
#define PR_DISPLAY_NAME								PROP_TAG( PT_TSTRING,	0x3001)
#define PR_DISPLAY_NAME_W							PROP_TAG( PT_UNICODE,	0x3001)
#define PR_DISPLAY_NAME_A							PROP_TAG( PT_STRING8,	0x3001)
#define PR_ADDRTYPE									PROP_TAG( PT_TSTRING,	0x3002)
#define PR_ADDRTYPE_W								PROP_TAG( PT_UNICODE,	0x3002)
#define PR_ADDRTYPE_A								PROP_TAG( PT_STRING8,	0x3002)
#define PR_EMAIL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3003)
#define PR_EMAIL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3003)
#define PR_EMAIL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3003)
#define PR_COMMENT									PROP_TAG( PT_TSTRING,	0x3004)
#define PR_COMMENT_W								PROP_TAG( PT_UNICODE,	0x3004)
#define PR_COMMENT_A								PROP_TAG( PT_STRING8,	0x3004)
#define PR_DEPTH									PROP_TAG( PT_LONG,		0x3005)
#define PR_PROVIDER_DISPLAY							PROP_TAG( PT_TSTRING,	0x3006)
#define PR_PROVIDER_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3006)
#define PR_PROVIDER_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3006)
#define PR_CREATION_TIME							PROP_TAG( PT_SYSTIME,	0x3007)
#define PR_LAST_MODIFICATION_TIME					PROP_TAG( PT_SYSTIME,	0x3008)
#define PR_RESOURCE_FLAGS							PROP_TAG( PT_LONG,		0x3009)
#define PR_PROVIDER_DLL_NAME						PROP_TAG( PT_TSTRING,	0x300A)
#define PR_PROVIDER_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x300A)
#define PR_PROVIDER_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x300A)
#define PR_SEARCH_KEY								PROP_TAG( PT_BINARY,	0x300B)
#define PR_PROVIDER_UID								PROP_TAG( PT_BINARY,	0x300C)
#define PR_PROVIDER_ORDINAL							PROP_TAG( PT_LONG,		0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION								PROP_TAG(PT_TSTRING,	0x3301)
#define PR_FORM_VERSION_W							PROP_TAG(PT_UNICODE,	0x3301)
#define PR_FORM_VERSION_A							PROP_TAG(PT_STRING8,	0x3301)
#define PR_FORM_CLSID								PROP_TAG(PT_CLSID,		0x3302)
#define PR_FORM_CONTACT_NAME						PROP_TAG(PT_TSTRING,	0x3303)
#define PR_FORM_CONTACT_NAME_W						PROP_TAG(PT_UNICODE,	0x3303)
#define PR_FORM_CONTACT_NAME_A						PROP_TAG(PT_STRING8,	0x3303)
#define PR_FORM_CATEGORY							PROP_TAG(PT_TSTRING,	0x3304)
#define PR_FORM_CATEGORY_W							PROP_TAG(PT_UNICODE,	0x3304)
#define PR_FORM_CATEGORY_A							PROP_TAG(PT_STRING8,	0x3304)
#define PR_FORM_CATEGORY_SUB						PROP_TAG(PT_TSTRING,	0x3305)
#define PR_FORM_CATEGORY_SUB_W						PROP_TAG(PT_UNICODE,	0x3305)
#define PR_FORM_CATEGORY_SUB_A						PROP_TAG(PT_STRING8,	0x3305)
#define PR_FORM_HOST_MAP							PROP_TAG(PT_MV_LONG,	0x3306)
#define PR_FORM_HIDDEN								PROP_TAG(PT_BOOLEAN,	0x3307)
#define PR_FORM_DESIGNER_NAME						PROP_TAG(PT_TSTRING,	0x3308)
#define PR_FORM_DESIGNER_NAME_W						PROP_TAG(PT_UNICODE,	0x3308)
#define PR_FORM_DESIGNER_NAME_A						PROP_TAG(PT_STRING8,	0x3308)
#define PR_FORM_DESIGNER_GUID						PROP_TAG(PT_CLSID,		0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR					PROP_TAG(PT_LONG,		0x330A)

/*
 *	Message store properties
 */

#define PR_DEFAULT_STORE							PROP_TAG( PT_BOOLEAN,	0x3400)
#define PR_STORE_SUPPORT_MASK						PROP_TAG( PT_LONG,		0x340D)
#define PR_STORE_STATE								PROP_TAG( PT_LONG,		0x340E)

#define PR_IPM_SUBTREE_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3413)
#define PR_MDB_PROVIDER								PROP_TAG( PT_BINARY,	0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS					PROP_TAG( PT_OBJECT,	0x3415)

#define PR_VALID_FOLDER_MASK						PROP_TAG( PT_LONG,		0x35DF)
#define PR_IPM_SUBTREE_ENTRYID						PROP_TAG( PT_BINARY,	0x35E0)

#define PR_IPM_OUTBOX_ENTRYID						PROP_TAG( PT_BINARY,	0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID					PROP_TAG( PT_BINARY,	0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID						PROP_TAG( PT_BINARY,	0x35E4)
#define PR_VIEWS_ENTRYID							PROP_TAG( PT_BINARY,	0x35E5)
#define PR_COMMON_VIEWS_ENTRYID						PROP_TAG( PT_BINARY,	0x35E6)
#define PR_FINDER_ENTRYID							PROP_TAG( PT_BINARY,	0x35E7)

/* Proptags 0x35E8-0x35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *	Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS							PROP_TAG( PT_LONG,		0x3600)
#define PR_FOLDER_TYPE								PROP_TAG( PT_LONG,		0x3601)
#define PR_CONTENT_COUNT							PROP_TAG( PT_LONG,		0x3602)
#define PR_CONTENT_UNREAD							PROP_TAG( PT_LONG,		0x3603)
#define PR_CREATE_TEMPLATES							PROP_TAG( PT_OBJECT,	0x3604)
#define PR_DETAILS_TABLE							PROP_TAG( PT_OBJECT,	0x3605)
#define PR_SEARCH									PROP_TAG( PT_OBJECT,	0x3607)
#define PR_SELECTABLE								PROP_TAG( PT_BOOLEAN,	0x3609)
#define PR_SUBFOLDERS								PROP_TAG( PT_BOOLEAN,	0x360A)
#define PR_STATUS									PROP_TAG( PT_LONG,		0x360B)
#define PR_ANR										PROP_TAG( PT_TSTRING,	0x360C)
#define PR_ANR_W									PROP_TAG( PT_UNICODE,	0x360C)
#define PR_ANR_A									PROP_TAG( PT_STRING8,	0x360C)
#define PR_CONTENTS_SORT_ORDER						PROP_TAG( PT_MV_LONG,	0x360D)
#define PR_CONTAINER_HIERARCHY						PROP_TAG( PT_OBJECT,	0x360E)
#define PR_CONTAINER_CONTENTS						PROP_TAG( PT_OBJECT,	0x360F)
#define PR_FOLDER_ASSOCIATED_CONTENTS				PROP_TAG( PT_OBJECT,	0x3610)
#define PR_DEF_CREATE_DL							PROP_TAG( PT_BINARY,	0x3611)
#define PR_DEF_CREATE_MAILUSER						PROP_TAG( PT_BINARY,	0x3612)
#define	PR_CONTAINER_CLASS							PROP_TAG( PT_TSTRING,	0x3613)
#define	PR_CONTAINER_CLASS_W						PROP_TAG( PT_UNICODE,	0x3613)
#define	PR_CONTAINER_CLASS_A						PROP_TAG( PT_STRING8,	0x3613)
#define	PR_CONTAINER_MODIFY_VERSION					PROP_TAG( PT_I8,		0x3614)
#define PR_AB_PROVIDER_ID							PROP_TAG( PT_BINARY,	0x3615)
#define PR_DEFAULT_VIEW_ENTRYID						PROP_TAG( PT_BINARY,	0x3616)
#define	PR_ASSOC_CONTENT_COUNT						PROP_TAG( PT_LONG,		0x3617)

/* Reserved 0x36C0-0x36FF */

/*
 *	Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS				PROP_TAG( PT_BINARY,	0x3700)
#define PR_ATTACH_DATA_OBJ							PROP_TAG( PT_OBJECT,	0x3701)
#define PR_ATTACH_DATA_BIN							PROP_TAG( PT_BINARY,	0x3701)
#define PR_ATTACH_ENCODING							PROP_TAG( PT_BINARY,	0x3702)
#define PR_ATTACH_EXTENSION							PROP_TAG( PT_TSTRING,	0x3703)
#define PR_ATTACH_EXTENSION_W						PROP_TAG( PT_UNICODE,	0x3703)
#define PR_ATTACH_EXTENSION_A						PROP_TAG( PT_STRING8,	0x3703)
#define PR_ATTACH_FILENAME							PROP_TAG( PT_TSTRING,	0x3704)
#define PR_ATTACH_FILENAME_W						PROP_TAG( PT_UNICODE,	0x3704)
#define PR_ATTACH_FILENAME_A						PROP_TAG( PT_STRING8,	0x3704)
#define PR_ATTACH_METHOD							PROP_TAG( PT_LONG,		0x3705)
#define PR_ATTACH_LONG_FILENAME	 					PROP_TAG( PT_TSTRING,	0x3707)
#define PR_ATTACH_LONG_FILENAME_W					PROP_TAG( PT_UNICODE,	0x3707)
#define PR_ATTACH_LONG_FILENAME_A					PROP_TAG( PT_STRING8,	0x3707)
#define PR_ATTACH_PATHNAME							PROP_TAG( PT_TSTRING,	0x3708)
#define PR_ATTACH_PATHNAME_W						PROP_TAG( PT_UNICODE,	0x3708)
#define PR_ATTACH_PATHNAME_A						PROP_TAG( PT_STRING8,	0x3708)
#define PR_ATTACH_RENDERING							PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG								PROP_TAG( PT_BINARY,	0x370A)
#define PR_RENDERING_POSITION						PROP_TAG( PT_LONG,		0x370B)
#define PR_ATTACH_TRANSPORT_NAME					PROP_TAG( PT_TSTRING,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W					PROP_TAG( PT_UNICODE,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A					PROP_TAG( PT_STRING8,	0x370C)
#define PR_ATTACH_LONG_PATHNAME	 					PROP_TAG( PT_TSTRING,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_W					PROP_TAG( PT_UNICODE,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_A					PROP_TAG( PT_STRING8,	0x370D)
#define PR_ATTACH_MIME_TAG							PROP_TAG( PT_TSTRING,	0x370E)
#define PR_ATTACH_MIME_TAG_W						PROP_TAG( PT_UNICODE,	0x370E)
#define PR_ATTACH_MIME_TAG_A						PROP_TAG( PT_STRING8,	0x370E)
#define	PR_ATTACH_ADDITIONAL_INFO					PROP_TAG( PT_BINARY,	0x370F)

/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE								PROP_TAG( PT_LONG,		0x3900)
#define PR_TEMPLATEID								PROP_TAG( PT_BINARY,	0x3902)
#define PR_PRIMARY_CAPABILITY						PROP_TAG( PT_BINARY,	0x3904)


/*
 *	Mail user properties
 */
#define PR_7BIT_DISPLAY_NAME						PROP_TAG( PT_STRING8,	0x39FF)
#define PR_ACCOUNT									PROP_TAG( PT_TSTRING,	0x3A00)
#define PR_ACCOUNT_W								PROP_TAG( PT_UNICODE,	0x3A00)
#define PR_ACCOUNT_A								PROP_TAG( PT_STRING8,	0x3A00)
#define PR_ALTERNATE_RECIPIENT						PROP_TAG( PT_BINARY,	0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A02)
#define PR_CONVERSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x3A03)
#define PR_DISCLOSE_RECIPIENTS						PROP_TAG( PT_BOOLEAN,	0x3A04)
#define PR_GENERATION								PROP_TAG( PT_TSTRING,	0x3A05)
#define PR_GENERATION_W								PROP_TAG( PT_UNICODE,	0x3A05)
#define PR_GENERATION_A								PROP_TAG( PT_STRING8,	0x3A05)
#define PR_GIVEN_NAME								PROP_TAG( PT_TSTRING,	0x3A06)
#define PR_GIVEN_NAME_W								PROP_TAG( PT_UNICODE,	0x3A06)
#define PR_GIVEN_NAME_A								PROP_TAG( PT_STRING8,	0x3A06)
#define PR_GOVERNMENT_ID_NUMBER						PROP_TAG( PT_TSTRING,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER					PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W				PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A				PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A09)
#define PR_INITIALS									PROP_TAG( PT_TSTRING,	0x3A0A)
#define PR_INITIALS_W								PROP_TAG( PT_UNICODE,	0x3A0A)
#define PR_INITIALS_A								PROP_TAG( PT_STRING8,	0x3A0A)
#define PR_KEYWORD									PROP_TAG( PT_TSTRING,	0x3A0B)
#define PR_KEYWORD_W								PROP_TAG( PT_UNICODE,	0x3A0B)
#define PR_KEYWORD_A								PROP_TAG( PT_STRING8,	0x3A0B)
#define PR_LANGUAGE									PROP_TAG( PT_TSTRING,	0x3A0C)
#define PR_LANGUAGE_W								PROP_TAG( PT_UNICODE,	0x3A0C)
#define PR_LANGUAGE_A								PROP_TAG( PT_STRING8,	0x3A0C)
#define PR_LOCATION									PROP_TAG( PT_TSTRING,	0x3A0D)
#define PR_LOCATION_W								PROP_TAG( PT_UNICODE,	0x3A0D)
#define PR_LOCATION_A								PROP_TAG( PT_STRING8,	0x3A0D)
#define PR_MAIL_PERMISSION							PROP_TAG( PT_BOOLEAN,	0x3A0E)
#define PR_MHS_COMMON_NAME							PROP_TAG( PT_TSTRING,	0x3A0F)
#define PR_MHS_COMMON_NAME_W						PROP_TAG( PT_UNICODE,	0x3A0F)
#define PR_MHS_COMMON_NAME_A						PROP_TAG( PT_STRING8,	0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER					PROP_TAG( PT_TSTRING,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A10)
#define PR_SURNAME									PROP_TAG( PT_TSTRING,	0x3A11)
#define PR_SURNAME_W								PROP_TAG( PT_UNICODE,	0x3A11)
#define PR_SURNAME_A								PROP_TAG( PT_STRING8,	0x3A11)
#define PR_ORIGINAL_ENTRYID							PROP_TAG( PT_BINARY,	0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME					PROP_TAG( PT_TSTRING,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W					PROP_TAG( PT_UNICODE,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A					PROP_TAG( PT_STRING8,	0x3A13)
#define PR_ORIGINAL_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3A14)
#define PR_POSTAL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A15)
#define PR_POSTAL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A15)
#define PR_POSTAL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A15)
#define PR_COMPANY_NAME								PROP_TAG( PT_TSTRING,	0x3A16)
#define PR_COMPANY_NAME_W							PROP_TAG( PT_UNICODE,	0x3A16)
#define PR_COMPANY_NAME_A							PROP_TAG( PT_STRING8,	0x3A16)
#define PR_TITLE									PROP_TAG( PT_TSTRING,	0x3A17)
#define PR_TITLE_W									PROP_TAG( PT_UNICODE,	0x3A17)
#define PR_TITLE_A									PROP_TAG( PT_STRING8,	0x3A17)
#define PR_DEPARTMENT_NAME							PROP_TAG( PT_TSTRING,	0x3A18)
#define PR_DEPARTMENT_NAME_W						PROP_TAG( PT_UNICODE,	0x3A18)
#define PR_DEPARTMENT_NAME_A						PROP_TAG( PT_STRING8,	0x3A18)
#define PR_OFFICE_LOCATION							PROP_TAG( PT_TSTRING,	0x3A19)
#define PR_OFFICE_LOCATION_W						PROP_TAG( PT_UNICODE,	0x3A19)
#define PR_OFFICE_LOCATION_A						PROP_TAG( PT_STRING8,	0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER					PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W				PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A				PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER				PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W				PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A				PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER						PROP_TAG( PT_TSTRING,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME				PROP_TAG( PT_TSTRING,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W				PROP_TAG( PT_UNICODE,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A				PROP_TAG( PT_STRING8,	0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER					PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W				PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A				PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE							PROP_TAG( PT_BINARY,	0x3A22)
#define PR_PRIMARY_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A23)
#define PR_BUSINESS_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A24)
#define PR_HOME_FAX_NUMBER							PROP_TAG( PT_TSTRING,	0x3A25)
#define PR_HOME_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A25)
#define PR_HOME_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A25)
#define PR_COUNTRY									PROP_TAG( PT_TSTRING,	0x3A26)
#define PR_COUNTRY_W								PROP_TAG( PT_UNICODE,	0x3A26)
#define PR_COUNTRY_A								PROP_TAG( PT_STRING8,	0x3A26)
#define PR_BUSINESS_ADDRESS_COUNTRY					PR_COUNTRY
#define PR_BUSINESS_ADDRESS_COUNTRY_W				PR_COUNTRY_W
#define PR_BUSINESS_ADDRESS_COUNTRY_A				PR_COUNTRY_A

#define PR_LOCALITY									PROP_TAG( PT_TSTRING,	0x3A27)
#define PR_LOCALITY_W								PROP_TAG( PT_UNICODE,	0x3A27)
#define PR_LOCALITY_A								PROP_TAG( PT_STRING8,	0x3A27)
#define PR_BUSINESS_ADDRESS_CITY					PR_LOCALITY
#define PR_BUSINESS_ADDRESS_CITY_W					PR_LOCALITY_W
#define PR_BUSINESS_ADDRESS_CITY_A					PR_LOCALITY_A

#define PR_STATE_OR_PROVINCE						PROP_TAG( PT_TSTRING,	0x3A28)
#define PR_STATE_OR_PROVINCE_W						PROP_TAG( PT_UNICODE,	0x3A28)
#define PR_STATE_OR_PROVINCE_A						PROP_TAG( PT_STRING8,	0x3A28)
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE		PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W		PR_STATE_OR_PROVINCE_W
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A		PR_STATE_OR_PROVINCE_A

#define PR_STREET_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A29)
#define PR_STREET_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A29)
#define PR_STREET_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A29)
#define PR_BUSINESS_ADDRESS_STREET					PR_STREET_ADDRESS
#define PR_BUSINESS_ADDRESS_STREET_W				PR_STREET_ADDRESS_W
#define PR_BUSINESS_ADDRESS_STREET_A				PR_STREET_ADDRESS_A

#define PR_POSTAL_CODE								PROP_TAG( PT_TSTRING,	0x3A2A)
#define PR_POSTAL_CODE_W							PROP_TAG( PT_UNICODE,	0x3A2A)
#define PR_POSTAL_CODE_A							PROP_TAG( PT_STRING8,	0x3A2A)
#define PR_BUSINESS_ADDRESS_POSTAL_CODE				PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_W			PR_POSTAL_CODE_W
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_A			PR_POSTAL_CODE_A


#define PR_POST_OFFICE_BOX							PROP_TAG( PT_TSTRING,	0x3A2B)
#define PR_POST_OFFICE_BOX_W						PROP_TAG( PT_UNICODE,	0x3A2B)
#define PR_POST_OFFICE_BOX_A						PROP_TAG( PT_STRING8,	0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX			PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W		PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A		PR_POST_OFFICE_BOX_A


#define PR_TELEX_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2C)
#define PR_TELEX_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2C)
#define PR_TELEX_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2C)
#define PR_ISDN_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2D)
#define PR_ISDN_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2D)
#define PR_ISDN_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A2F)
#define PR_ASSISTANT								PROP_TAG( PT_TSTRING,	0x3A30)
#define PR_ASSISTANT_W								PROP_TAG( PT_UNICODE,	0x3A30)
#define PR_ASSISTANT_A								PROP_TAG( PT_STRING8,	0x3A30)
#define PR_SEND_RICH_INFO							PROP_TAG( PT_BOOLEAN,	0x3A40)

#define PR_WEDDING_ANNIVERSARY						PROP_TAG( PT_SYSTIME, 0x3A41)
#define PR_BIRTHDAY									PROP_TAG( PT_SYSTIME, 0x3A42)


#define PR_HOBBIES									PROP_TAG( PT_TSTRING, 0x3A43)
#define PR_HOBBIES_W								PROP_TAG( PT_UNICODE, 0x3A43)
#define PR_HOBBIES_A								PROP_TAG( PT_STRING8, 0x3A43)

#define PR_MIDDLE_NAME								PROP_TAG( PT_TSTRING, 0x3A44)
#define PR_MIDDLE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A44)
#define PR_MIDDLE_NAME_A							PROP_TAG( PT_STRING8, 0x3A44)

#define PR_DISPLAY_NAME_PREFIX						PROP_TAG( PT_TSTRING, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W					PROP_TAG( PT_UNICODE, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A					PROP_TAG( PT_STRING8, 0x3A45)

#define PR_PROFESSION								PROP_TAG( PT_TSTRING, 0x3A46)
#define PR_PROFESSION_W								PROP_TAG( PT_UNICODE, 0x3A46)
#define PR_PROFESSION_A								PROP_TAG( PT_STRING8, 0x3A46)

#define PR_PREFERRED_BY_NAME						PROP_TAG( PT_TSTRING, 0x3A47)
#define PR_PREFERRED_BY_NAME_W						PROP_TAG( PT_UNICODE, 0x3A47)
#define PR_PREFERRED_BY_NAME_A						PROP_TAG( PT_STRING8, 0x3A47)

#define PR_SPOUSE_NAME								PROP_TAG( PT_TSTRING, 0x3A48)
#define PR_SPOUSE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A48)
#define PR_SPOUSE_NAME_A							PROP_TAG( PT_STRING8, 0x3A48)

#define PR_COMPUTER_NETWORK_NAME					PROP_TAG( PT_TSTRING, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W					PROP_TAG( PT_UNICODE, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A					PROP_TAG( PT_STRING8, 0x3A49)

#define PR_CUSTOMER_ID								PROP_TAG( PT_TSTRING, 0x3A4A)
#define PR_CUSTOMER_ID_W							PROP_TAG( PT_UNICODE, 0x3A4A)
#define PR_CUSTOMER_ID_A							PROP_TAG( PT_STRING8, 0x3A4A)

#define PR_TTYTDD_PHONE_NUMBER						PROP_TAG( PT_TSTRING, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W					PROP_TAG( PT_UNICODE, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A					PROP_TAG( PT_STRING8, 0x3A4B)

#define PR_FTP_SITE									PROP_TAG( PT_TSTRING, 0x3A4C)
#define PR_FTP_SITE_W								PROP_TAG( PT_UNICODE, 0x3A4C)
#define PR_FTP_SITE_A								PROP_TAG( PT_STRING8, 0x3A4C)

#define PR_GENDER									PROP_TAG( PT_SHORT, 0x3A4D)

#define PR_MANAGER_NAME								PROP_TAG( PT_TSTRING, 0x3A4E)
#define PR_MANAGER_NAME_W							PROP_TAG( PT_UNICODE, 0x3A4E)
#define PR_MANAGER_NAME_A							PROP_TAG( PT_STRING8, 0x3A4E)

#define PR_NICKNAME									PROP_TAG( PT_TSTRING, 0x3A4F)
#define PR_NICKNAME_W								PROP_TAG( PT_UNICODE, 0x3A4F)
#define PR_NICKNAME_A								PROP_TAG( PT_STRING8, 0x3A4F)

#define PR_PERSONAL_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A50)


#define PR_BUSINESS_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A51)

#define PR_CONTACT_VERSION							PROP_TAG( PT_CLSID, 0x3A52)
#define PR_CONTACT_ENTRYIDS							PROP_TAG( PT_MV_BINARY, 0x3A53)

#define PR_CONTACT_ADDRTYPES						PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W						PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A						PROP_TAG( PT_MV_STRING8, 0x3A54)

#define PR_CONTACT_DEFAULT_ADDRESS_INDEX			PROP_TAG( PT_LONG, 0x3A55)

#define PR_CONTACT_EMAIL_ADDRESSES					PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W				PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A				PROP_TAG( PT_MV_STRING8, 0x3A56)


#define PR_COMPANY_MAIN_PHONE_NUMBER				PROP_TAG( PT_TSTRING, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W				PROP_TAG( PT_UNICODE, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A				PROP_TAG( PT_STRING8, 0x3A57)

#define PR_CHILDRENS_NAMES							PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W						PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A						PROP_TAG( PT_MV_STRING8, 0x3A58)



#define PR_HOME_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A59)
#define PR_HOME_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A59)
#define PR_HOME_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A59)

#define PR_HOME_ADDRESS_COUNTRY						PROP_TAG( PT_TSTRING, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A5A)

#define PR_HOME_ADDRESS_POSTAL_CODE					PROP_TAG( PT_TSTRING, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A5B)

#define PR_HOME_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W			PROP_TAG( PT_UNICODE, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A			PROP_TAG( PT_STRING8, 0x3A5C)

#define PR_HOME_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A5D)

#define PR_HOME_ADDRESS_POST_OFFICE_BOX				PROP_TAG( PT_TSTRING, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A5E)

#define PR_OTHER_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A5F)

#define PR_OTHER_ADDRESS_COUNTRY					PROP_TAG( PT_TSTRING, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A60)

#define PR_OTHER_ADDRESS_POSTAL_CODE				PROP_TAG( PT_TSTRING, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A61)

#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W		PROP_TAG( PT_UNICODE, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A		PROP_TAG( PT_STRING8, 0x3A62)

#define PR_OTHER_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A63)

#define PR_OTHER_ADDRESS_POST_OFFICE_BOX			PROP_TAG( PT_TSTRING, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A64)


/*
 *	Profile section properties
 */

#define PR_STORE_PROVIDERS							PROP_TAG( PT_BINARY,	0x3D00)
#define PR_AB_PROVIDERS								PROP_TAG( PT_BINARY,	0x3D01)
#define PR_TRANSPORT_PROVIDERS						PROP_TAG( PT_BINARY,	0x3D02)

#define PR_DEFAULT_PROFILE							PROP_TAG( PT_BOOLEAN,	0x3D04)
#define PR_AB_SEARCH_PATH							PROP_TAG( PT_MV_BINARY,	0x3D05)
#define PR_AB_DEFAULT_DIR							PROP_TAG( PT_BINARY,	0x3D06)
#define PR_AB_DEFAULT_PAB							PROP_TAG( PT_BINARY,	0x3D07)

#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME								PROP_TAG( PT_TSTRING,	0x3D09)
#define PR_SERVICE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D09)
#define PR_SERVICE_NAME_A							PROP_TAG( PT_STRING8,	0x3D09)
#define PR_SERVICE_DLL_NAME							PROP_TAG( PT_TSTRING,	0x3D0A)
#define PR_SERVICE_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x3D0A)
#define PR_SERVICE_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x3D0A)
#define PR_SERVICE_ENTRY_NAME						PROP_TAG( PT_STRING8,	0x3D0B)
#define PR_SERVICE_UID								PROP_TAG( PT_BINARY,	0x3D0C)
#define PR_SERVICE_EXTRA_UIDS						PROP_TAG( PT_BINARY,	0x3D0D)
#define PR_SERVICES									PROP_TAG( PT_BINARY,	0x3D0E)
#define PR_SERVICE_SUPPORT_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D10)
#define PR_AB_SEARCH_PATH_UPDATE   					PROP_TAG( PT_BINARY, 	 0x3D11)
#define PR_PROFILE_NAME								PROP_TAG( PT_TSTRING,	0x3D12)
#define PR_PROFILE_NAME_A							PROP_TAG( PT_STRING8,	0x3D12)
#define PR_PROFILE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D12)

/*
 *	Status object properties
 */

#define PR_IDENTITY_DISPLAY							PROP_TAG( PT_TSTRING,	0x3E00)
#define PR_IDENTITY_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3E00)
#define PR_IDENTITY_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3E00)
#define PR_IDENTITY_ENTRYID							PROP_TAG( PT_BINARY,	0x3E01)
#define PR_RESOURCE_METHODS							PROP_TAG( PT_LONG,		0x3E02)
#define PR_RESOURCE_TYPE							PROP_TAG( PT_LONG,		0x3E03)
#define PR_STATUS_CODE								PROP_TAG( PT_LONG,		0x3E04)
#define PR_IDENTITY_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3E05)
#define PR_OWN_STORE_ENTRYID						PROP_TAG( PT_BINARY,	0x3E06)
#define PR_RESOURCE_PATH							PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W							PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A							PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING							PROP_TAG( PT_TSTRING,	0x3E08)
#define PR_STATUS_STRING_W							PROP_TAG( PT_UNICODE,	0x3E08)
#define PR_STATUS_STRING_A							PROP_TAG( PT_STRING8,	0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL			PROP_TAG( PT_BOOLEAN,	0x3E09)
#define PR_HEADER_FOLDER_ENTRYID					PROP_TAG( PT_BINARY,	0x3E0A)
#define PR_REMOTE_PROGRESS							PROP_TAG( PT_LONG,		0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT						PROP_TAG( PT_TSTRING,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W					PROP_TAG( PT_UNICODE,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A					PROP_TAG( PT_STRING8,	0x3E0C)
#define PR_REMOTE_VALIDATE_OK						PROP_TAG( PT_BOOLEAN,	0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS							PROP_TAG( PT_LONG,		0x3F00)
#define PR_CONTROL_STRUCTURE						PROP_TAG( PT_BINARY,	0x3F01)
#define PR_CONTROL_TYPE								PROP_TAG( PT_LONG,		0x3F02)
#define PR_DELTAX									PROP_TAG( PT_LONG,		0x3F03)
#define PR_DELTAY									PROP_TAG( PT_LONG,		0x3F04)
#define PR_XPOS										PROP_TAG( PT_LONG,		0x3F05)
#define PR_YPOS										PROP_TAG( PT_LONG,		0x3F06)
#define PR_CONTROL_ID								PROP_TAG( PT_BINARY,	0x3F07)
#define PR_INITIAL_DETAILS_PANE						PROP_TAG( PT_LONG,		0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN 							0x67F0
#define PROP_ID_SECURE_MAX 							0x67FF


#endif	/* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPISPI.h ===
/*
 *	M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*	The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *	one or more versions of the SPI.  Each provider supports one or
 *	more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *	and in the provider to ensure that they agree to use exactly one
 *	version of the MAPI SPI.
 *
 *	The SPI version number is composed of a major (8-bit) version,
 *	minor (8-bit) version, and micro (16-bit) version.  The first
 *	retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *	The major version number changes rarely.
 *	The minor version number changes opon each retail ship of
 *	MAPI if the SPI has been modified.
 *	The micro version number changes internally at Microsoft
 *	during development of MAPI.
 *
 *	The version of the SPI documented by this set of header files
 *	is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *	service provider, and get a new set of header files, and update
 *	your code to the new interface, you'll be at the "current" version.
 */
#define	CURRENT_SPI_VERSION	0x00010010L

/*	Here are some well-known SPI version numbers:
 *	(These will eventually be useful for provider-writers who
 *	might choose to make provider DLLs that support more than
 *	one version of the MAPI SPI.
 */
#define	PDK1_SPI_VERSION	0x00010000L	/* 0.1.0  MAPI PDK1 Spring 1993 */

#define	PDK2_SPI_VERSION	0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION	0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
					LPVOID lpvSession,
					LPMESSAGE lpMessage,
					LPADRBOOK lpAdrBook,
					LPMAPIFOLDER lpFolder,
					LPALLOCATEBUFFER AllocateBuffer,
					LPALLOCATEMORE AllocateMore,
					LPFREEBUFFER FreeBuffer,
					ULONG FAR *lpcOutbound,
					LPMESSAGE FAR * FAR *lpppMessage,
					LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMemAllocRoutines)										\
		(THIS_	LPALLOCATEBUFFER FAR *		lpAllocateBuffer,			\
				LPALLOCATEMORE FAR *		lpAllocateMore,				\
				LPFREEBUFFER FAR *			lpFreeBuffer) IPURE;		\
	MAPIMETHOD(Subscribe)												\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						ulEventMask,				\
				ULONG						ulFlags,					\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unsubscribe)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(Notify)													\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						cNotification,				\
				LPNOTIFICATION				lpNotifications,			\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ModifyStatusRow)											\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpColumnVals,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUid,						\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfileObj) IPURE;		\
	MAPIMETHOD(RegisterPreprocessor)									\
		(THIS_	LPMAPIUID					lpMuid,						\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszDLLName,				\
				LPSTR	/* String8! */		lpszPreprocess,				\
				LPSTR	/* String8! */		lpszRemovePreprocessInfo,	\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewUID)													\
		(THIS_	LPMAPIUID					lpMuid) IPURE;				\
	MAPIMETHOD(MakeInvalid)												\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpObject,					\
				ULONG						ulRefCount,					\
				ULONG						cMethods) IPURE;			\

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)								\
	MAPIMETHOD(SpoolerYield)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SpoolerNotify)											\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpvData) IPURE;				\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetProviderUID)											\
		(THIS_	LPMAPIUID					lpProviderID,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntry1,					\
				LPENTRYID					lpEntry1,					\
				ULONG						cbEntry2,					\
				LPENTRYID					lpEntry2,					\
				ULONG						ulCompareFlags,				\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenTemplateID)											\
		(THIS_	ULONG						cbTemplateID,				\
				LPENTRYID					lpTemplateID,				\
				ULONG						ulTemplateFlags,			\
				LPMAPIPROP					lpMAPIPropData,				\
				LPCIID						lpInterface,				\
				LPMAPIPROP FAR *			lppMAPIPropNew,				\
				LPMAPIPROP					lpMAPIPropSibling) IPURE;	\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulOpenFlags,				\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(GetOneOffTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(DoConfigPropsheet)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszTitle,					\
				LPMAPITABLE					lpDisplayTable,				\
				LPMAPIPROP					lpCOnfigData,				\
				ULONG						ulTopPage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				LPENTRYLIST					lpMsgList,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				LPTSTR 						lszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)								\
	MAPIMETHOD(DoCopyTo)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoCopyProps)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoProgressDialog)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPMAPIPROGRESS FAR *		lppProgress) IPURE;			\
	MAPIMETHOD(ReadReceipt)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpReadMessage,				\
				LPMESSAGE FAR *				lppEmptyMessage) IPURE;		\
	MAPIMETHOD(PrepareSubmit)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ExpandRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(UpdatePAB)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(DoSentMail)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(Preprocess)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(CompleteMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(StoreLogoffTransports)									\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(StatusRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				LPADRLIST					lpRecipList) IPURE;			\
	MAPIMETHOD(WrapStoreEntryID)										\
		(THIS_	ULONG						cbOrigEntry,				\
				LPENTRYID					lpOrigEntry,				\
				ULONG FAR *					lpcbWrappedEntry,			\
				LPENTRYID FAR *				lppWrappedEntry) IPURE;		\
	MAPIMETHOD(ModifyProfile)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(IStorageFromStream)										\
		(THIS_	LPUNKNOWN					lpUnkIn,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPSTORAGE FAR *				lppStorageOut) IPURE;		\
	MAPIMETHOD(GetSvcConfigSupportObj)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPISUP FAR *				lppSvcSupport) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISUPPORT_METHODS1(PURE)
	MAPI_IMAPISUPPORT_METHODS2(PURE)
	MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*																	*/
/*							ADDRESS BOOK SPI						*/
/*																	*/
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY				((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
				ULONG FAR *					lpulpcbSecurity,			\
				LPBYTE FAR *				lppbSecurity,				\
                LPMAPIERROR FAR *			lppMAPIError,				\
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)				                                    \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *           lppTable) IPURE;            \
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
    ULONG				ulFlags,
    ULONG				ulMAPIVer,
    ULONG FAR *			lpulProviderVer,
    LPABPROVIDER FAR *	lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*																	*/
/*							TRANSPORT SPI							*/
/*																	*/
/********************************************************************/

/* For DeinitTransport */

#define	DEINIT_NORMAL				((ULONG) 0x00000001)
#define	DEINIT_HURRY				((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG				((ULONG) 0x00000001)
#define	LOGON_NO_CONNECT			((ULONG) 0x00000004)
#define	LOGON_NO_INBOUND			((ULONG) 0x00000008)
#define	LOGON_NO_OUTBOUND			((ULONG) 0x00000010)
/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define	LOGON_SP_IDLE				((ULONG) 0x00010000)
#define	LOGON_SP_POLL				((ULONG) 0x00020000)
#define	LOGON_SP_RESOLVE			((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(TransportLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				__in LPTSTR						lpszProfileName,			\
				ULONG FAR *					lpulFlags,					\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPXPLOGON FAR *				lppXPLogon) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT		((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE			((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
	ULONG			ulFlags;		/* MAPI_RECIPIENT, MAPI_MESSAGE */
	LPGUID			lpRecipGUID;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszAdrType;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszDLLName;	/* Options DLL */
	ULONG			ulOrdinal;		/* Ordinal in that DLL */
	ULONG			cbOptionsData;	/* Count of bytes in lpbOptionsData */
	LPBYTE			lpbOptionsData;	/* Providers per [recip|message] option data */
	ULONG			cOptionsProps;	/* Count of Options default prop values */
	LPSPropValue	lpOptionsProps;	/* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
			HINSTANCE			hInst,
			LPMALLOC			lpMalloc,
			ULONG				ulFlags,
			ULONG				cbOptionData,
			LPBYTE				lpbOptionData,
			LPMAPISUP			lpMAPISup,
			LPMAPIPROP			lpDataSource,
			LPMAPIPROP FAR *	lppWrappedSource,
            LPMAPIERROR FAR *	lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED		((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE		((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND		((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND			((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND		((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND			((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH	((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH	((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH	((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH	((ULONG) 0x00080000)

/* For TransportLogoff */

#define	LOGOFF_NORMAL				((ULONG) 0x00000001)
#define LOGOFF_HURRY				((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED				((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW				((ULONG) 0x00010000)
#define END_RESEND_LATER			((ULONG) 0x00020000)
#define END_DONT_RESEND				((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)									\
	MAPIMETHOD(AddressTypes)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcAdrType,					\
				__deref_out_ecount_full(*lpcAdrType) LPTSTR FAR * FAR *			lpppAdrTypeArray,			\
				ULONG FAR *					lpcMAPIUID,					\
				LPMAPIUID FAR * FAR *		lpppUIDArray) IPURE;		\
	MAPIMETHOD(RegisterOptions)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcOptions,					\
				LPOPTIONDATA FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(TransportNotify)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				LPVOID FAR *				lppvData) IPURE;			\
	MAPIMETHOD(Idle)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(TransportLogoff)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef,					\
				ULONG FAR *					lpulReturnParm) IPURE;		\
	MAPIMETHOD(EndMessage)												\
		(THIS_	ULONG						ulMsgRef,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Poll)													\
		(THIS_	ULONG FAR *					lpulIncoming) IPURE;		\
	MAPIMETHOD(StartMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef) IPURE;			\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
	BEGIN_INTERFACE	
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
	ULONG				ulFlags,
	ULONG				ulMAPIVer,
	ULONG FAR *			lpulProviderVer,
	LPXPPROVIDER FAR *	lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*																	*/
/*							MESSAGE STORE SPI						*/
/*																	*/
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY			((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL			((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT		((ULONG) 0x00000001)
#define LOGON_SP_PROMPT			((ULONG) 0x00000002)
#define LOGON_SP_NEWPW			((ULONG) 0x00000004)
#define LOGON_CHANGED			((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER			((ULONG) 0x00000001)
#define DIALOG_MESSAGE			((ULONG) 0x00000002)
#define DIALOG_PROP				((ULONG) 0x00000004)
#define DIALOG_ATTACH			((ULONG) 0x00000008)

#define DIALOG_MOVE				((ULONG) 0x00000010)
#define DIALOG_COPY				((ULONG) 0x00000020)
#define DIALOG_DELETE			((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL		((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL	((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING		((ULONG) 0x00000001)
#define NEEDS_SPOOLER			((ULONG) 0x00000002)

/* PrepareSubmit */

#define CHECK_SENDER			((ULONG) 0x00000001)
#define NON_STANDARD			((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Logon)													\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG FAR *					lpcbSpoolSecurity,			\
				LPBYTE FAR *				lppbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(SpoolerLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG						cbSpoolSecurity,			\
				LPBYTE						lpbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(CompareStoreIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(OpenStatusEntry)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPVOID FAR *				lppEntry) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
	HINSTANCE				hInstance,
	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
	ULONG					ulFlags,
	ULONG					ulMAPIVer,
	ULONG FAR *				lpulProviderVer,
	LPMSPROVIDER FAR *		lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*																	*/
/*					  MESSAGE SERVICE CONFIGURATION					*/
/*																	*/
/********************************************************************/

/* Flags for service configuration entry point */

/* #define MAPI_UNICODE				 0x80000000 */
/* #define SERVICE_UI_ALWAYS  		 0x00000002	*/
/* #define SERVICE_UI_ALLOWED 		 0x00000010	*/
#define MSG_SERVICE_UI_READ_ONLY	 0x00000008	/* display parameters only */
#define SERVICE_LOGON_FAILED		 0x00000020 /* reconfigure provider */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL			0x00000001
#define MSG_SERVICE_CREATE			0x00000002
#define MSG_SERVICE_CONFIGURE		0x00000003
#define MSG_SERVICE_DELETE			0x00000004
#define MSG_SERVICE_UNINSTALL		0x00000005
#define MSG_SERVICE_PROVIDER_CREATE	0x00000006
#define MSG_SERVICE_PROVIDER_DELETE	0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
	HINSTANCE		hInstance,
	LPMALLOC		lpMalloc,
	LPMAPISUP		lpMAPISup,
	ULONG			ulUIParam,
	ULONG			ulFlags,
	ULONG			ulContext,
	ULONG			cValues,
	LPSPropValue	lpProps,
	LPPROVIDERADMIN lpProviderAdmin,
	LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MciAvi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1996. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/*
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L

#define MCI_AVI_SETVIDEO_PALETTE_COLOR		0x8100L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Mdcommsg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                  \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIX.h ===
/*
 *	M A P I X . H
 *	
 *	Definitions of objects/flags, etc used by Extended MAPI.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif	

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,			LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,	LPSERVICEADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession,		LPMAPISESSION);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI					*/
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session			*/
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session		*/
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile		*/
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon				*/
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return		*/
#define MAPI_SERVICE_UI_ALWAYS	0x00002000	/* Do logon UI in all providers		*/
#define MAPI_NO_MAIL			0x00008000	/* Do not activate transports		*/
/* #define MAPI_NT_SERVICE			0x00010000	Allow logon from an NT service	*/
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* Display password UI only			*/
#endif
#define MAPI_TIMEOUT_SHORT		0x00100000	/* Minimal wait for logon resources	*/

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
	ULONG			ulVersion;
	ULONG			ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION				0

#define MAPI_MULTITHREAD_NOTIFICATIONS	0x00000001
/* Reserved for MAPI					0x40000000 */
/* #define MAPI_NT_SERVICE				0x00010000	Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
	LPVOID			lpMapiInit
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE		MAPIInitialize;
MAPIUNINITIALIZE	MAPIUninitialize;


/*  Extended MAPI Logon function */


typedef HRESULT (STDMETHODCALLTYPE MAPILOGONEX)(
	ULONG_PTR ulUIParam,
	__in_opt LPTSTR lpszProfileName,
	__in_opt LPTSTR lpszPassword,
	ULONG ulFlags,   /*  ulFlags takes all that SimpleMAPI does + MAPI_UNICODE */
	LPMAPISESSION FAR * lppSession
);
typedef MAPILOGONEX FAR *LPMAPILOGONEX;

MAPILOGONEX MAPILogonEx;


typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
	ULONG ulFlags,
	LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY				((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE			0x00000001	/* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY	0x00000002	/* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT	0x00000003	/* for simple MAPI and CMC */
#define	MAPI_PRIMARY_STORE			0x00000004	/* Used by some clients */
#define	MAPI_SECONDARY_STORE		0x00000005	/* Used by some clients */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE		0x00000001	/* Selects post/send semantics */
#define MAPI_NEW_MESSAGE		0x00000002	/* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgStoresTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenMsgStore)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(GetStatusTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(MessageOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszAdrType,				\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(QueryDefaultMessageOpt)									\
		(THIS_	__in LPTSTR						lpszAdrType,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(EnumAdrTypes)											\
		(THIS_	ULONG						ulFlags,					\
				__out ULONG FAR *					lpcAdrTypes,		\
				__out_ecount(lpcAdrTypes) 								\
						LPTSTR FAR * FAR *lpppszAdrTypes) IPURE;		\
	MAPIMETHOD(QueryIdentity)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						ulReserved) IPURE;			\
	MAPIMETHOD(SetDefaultStore)											\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(AdminServices)											\
		(THIS_	ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\
	MAPIMETHOD(ShowForm)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPMDB						lpMsgStore,					\
				LPMAPIFOLDER				lpParentFolder,				\
				LPCIID						lpInterface,				\
				ULONG						ulMessageToken,				\
				LPMESSAGE					lpMessageSent,				\
				ULONG						ulFlags,					\
				ULONG						ulMessageStatus,			\
				ULONG						ulMessageFlags,				\
				ULONG						ulAccess,					\
				__in LPSTR					lpszMessageClass) IPURE;	\
	MAPIMETHOD(PrepareForm)												\
		(THIS_	LPCIID						lpInterface,				\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMessageToken) IPURE;	\


#undef		 INTERFACE
#define		 INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISESSION_METHODS(PURE)
};

/*DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);*/

/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	__in LPTSTR					lpszName,					\
				__in LPTSTR					lpszAdrType,				\
				__in LPTSTR					lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				__in LPTSTR					lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	__in LPTSTR					lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES			0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProfileTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProfile)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteProfile)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangeProfilePassword)									\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewPassword,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyProfile)												\
		(THIS_	__in LPTSTR					lpszOldProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameProfile)											\
		(THIS_	__in LPTSTR					lpszOldProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetDefaultProfile)										\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminServices)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\


#undef		 INTERFACE
#define		 INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE		0x00000001
#define SERVICE_SINGLE_COPY			0x00000002
#define SERVICE_CREATE_WITH_STORE	0x00000004
#define SERVICE_PRIMARY_IDENTITY	0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY	0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)							\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgServiceTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateMsgService)										\
		(THIS_	__in LPTSTR					lpszService,				\
				__in LPTSTR					lpszDisplayName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMsgService)										\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(CopyMsgService)											\
		(THIS_	LPMAPIUID					lpUID,						\
				__in LPTSTR					lpszDisplayName,			\
				LPCIID						lpInterfaceToCopy,			\
				LPCIID						lpInterfaceDst,				\
				LPVOID						lpObjectDst,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszDisplayName) IPURE;		\
	MAPIMETHOD(ConfigureMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpProps) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(MsgServiceTransportOrder)								\
		(THIS_	ULONG						cUID,						\
				LPMAPIUID					lpUIDList,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminProviders)											\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPPROVIDERADMIN FAR *		lppProviderAdmin) IPURE;	\
	MAPIMETHOD(SetPrimaryIdentity)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef	__cplusplus
}		/*	extern "C" */
#endif	

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIWin.h ===
/*
 *	M A P I W I N . H
 *
 *	Definitions used by the MAPI Development Team to aid in
 *	developing single-source service providers that run on
 *	both WIN32 and WIN16 platforms.
 *	There are three sections.
 *
 *	The first section defines how to call something that
 *	is available by different methods in WIN16 vs. WIN32.
 *	As such, they are totally new mechanisms.
 *
 *	The second section establishes things that are available
 *	AS-IS in one environment but we have to define for the
 *	other environment.
 *
 *	The third section simply defines a few conventions
 *	(simplifications) for common operations.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	Routines are included in the first section to manage per-instance
 *	global variables for DLLs. They assume that all of the DLL's
 *	per-instance global variables live in a single block of memory.
 *	Functions are provided to install and retrieve the correct block of
 *	memory for the current instance.
 *
 *	There are only two functions:
 *
 *		PvGetInstanceGlobals	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobals	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 *
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 *
 *	The WIN16 implementation uses a fixed array of pointers and a
 *	matching fixed array of keys unique to the calling process.
 */

/*
 *	The second section consists largely of Win32 file I/O functions
 *	that are not supported under Win16. These functions are
 *	implemented in mapiwin.c, using DOS calls. Most have limitations
 *	relative to their Win32 counterparts, which are spelled out in
 *	the comments to the source code.
 */

#ifndef __MAPIWIN_H__
#define __MAPIWIN_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#include "mapinls.h"

#ifdef __cplusplus
extern "C" {
#endif


/********************************/
/*	Our conventions for things	*/
/*	we choose to do differently	*/
/*	on WIN16 vs. WIN32.			*/
/********************************/

#ifdef	WIN16

#define	MULDIV(x,y,z)				MulDiv32(x,y,z)
#define IsBadReadPtr(lp,cb)			FBadReadPtr(lp,cb)

#define cInstMax					50
LPVOID FAR PASCAL	PvGetInstanceGlobals(void);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid);
BOOL __export FAR PASCAL FCleanupInstanceGlobals(WORD, DWORD);

#elif defined(_MAC)	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

LPVOID FAR PASCAL	PvGetInstanceGlobals(WORD wDataSet);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv, WORD wDataSet);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid,
						WORD wDataSet);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid, DWORD wDataSet);
BOOL FAR PASCAL		FCleanupInstanceGlobals(WORD, DWORD);

#else	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

extern LPVOID pinstX;
#define PvGetInstanceGlobals()					pinstX
#define ScSetInstanceGlobals(_pv)				(pinstX = _pv, 0)
#define PvGetVerifyInstanceGlobals(_pid)		pinstX
#define ScSetVerifyInstanceGlobals(_pv,_pid)	(pinstX = _pv, 0)
#define PvSlowGetInstanceGlobals(_pid)			pinstX

#endif	/* WIN16 */

#if defined(_WIN32) && !defined(_MAC)
#define szMAPIDLLSuffix		"32"
#elif defined(WIN16) || defined(DOS)
#define szMAPIDLLSuffix		""
#elif  defined(_MAC)
#define szMAPIDLLSuffix		"M"
#else
#error "Don't know the suffix for DLLs on this platform"
#endif

/********************************/
/*  Things missing from one		*/
/*	system-provided environment	*/
/*	or the other.				*/
/********************************/

#if !defined(_WIN32)
#define	ZeroMemory(pb,cb)			memset((pb),0,(cb))
#define FillMemory(pb,cb,b)			memset((pb),(b),(cb))
#define CopyMemory(pbDst,pbSrc,cb)	do								\
									{								\
										size_t _cb = (size_t)(cb);	\
										if (_cb)					\
											memcpy(pbDst,pbSrc,_cb);\
									} while (FALSE)
#define MoveMemory(pbDst,pbSrc,cb)	memmove((pbDst),(pbSrc),(cb))

#define UNALIGNED

#endif

#if defined(WIN16) || defined(_MAC)

#ifndef _MAC
#include <error.h>				/*	for GetLastError() */
#endif

typedef	int					INT;
typedef	unsigned long		ULONG;
typedef	short				SHORT;
typedef	unsigned short		USHORT;
typedef double 				LONGLONG;
typedef double 				DWORDLONG;
typedef unsigned char		UCHAR;
typedef unsigned char FAR*	PUCHAR;
typedef int					BOOL;


#ifndef _MAC
typedef char				BOOLEAN;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif		/* _FILETIME */

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, FAR *LPSYSTEMTIME;

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    CHAR StandardName[ 32 ];		/* was WCHAR */
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    CHAR DaylightName[ 32 ];		/* was WCHAR */
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR *LPTIME_ZONE_INFORMATION;


#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define APIENTRY		WINAPI

#define	SetForegroundWindow			SetActiveWindow

#define wsprintfA					wsprintf
#define GetWindowsDirectoryA		GetWindowsDirectory
#define GetSystemDirectoryA			GetSystemDirectory
#define GetPrivateProfileStringA 	GetPrivateProfileString
#define GetPrivateProfileIntA		GetPrivateProfileInt
#define GetProfileStringA			GetProfileString
#define GetModuleFileNameA			GetModuleFileName
#define CharUpperBuffA				CharUpperBuff
#define LoadLibraryA				LoadLibrary
#define lstrcatA					lstrcat
#define RegisterWindowMessageA		RegisterWindowMessage
#define MAKEINTRESOURCEA			MAKEINTRESOURCE

#define WNDCLASSA					WNDCLASS									

#endif	/* !_MAC */

/* Synchronization */
#define InterlockedIncrement(plong)	(++(*(plong)))
#define InterlockedDecrement(plong) (--(*(plong)))

#ifndef CreateMutex
#define CreateMutexA	CreateMutex
#define CreateMutexW	CreateMutex
#define CreateMutex(pv, bool, sz)	(INVALID_HANDLE_VALUE)
#endif

#define WaitForSingleObject(hObj, dw)	((void)0)
#define ReleaseMutex(hObj)				((BOOL)1)
#define CloseMutexHandle(hObj)			TRUE

#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)

#define MAX_PATH					260

#ifndef	_MAC
/*
 *	File Access Modes
 *
 *	The possible combination of file access modes as passed into
 *	the CreateFile() api map to OpenFile() as follows:
 *
 *	 GENERIC_READ						OPEN_ACCESS_READONLY
 *	 GENERIC_WRITE						OPEN_ACCESS_WRITEONLY
 *	 GENERIC_READ | GENERIC_WRITE		OPEN_ACCESS_READWRITE
 *
 *	 0									OPEN_SHARE_DENYREADWRITE
 *	 FILE_SHARE_READ					OPEN_SHARE_DENYWRITE
 *	 FILE_SHARE_WRITE					OPEN_SHARE_DENYREAD
 *	 FILE_SHARE_READ | FILE_SHARE_WRITE	OPEN_SHARE_DENYNONE
 *
 *	Due to the mappings we cannot pass them through directly,
 *	so we will have to use a conversion within APIs that test
 *	these bits.  It would be best to use the Win32 #defines
 *	for these flags and convert as needed in the APIs.
 */
#define GENERIC_READ				(0x80000000) /* from WINNT.H */
#define GENERIC_WRITE				(0x40000000) /* from WINNT.H */
#define FILE_SHARE_READ				(0x00000001) /* from WINNT.H */
#define FILE_SHARE_WRITE			(0x00000002) /* from WINNT.H */
#endif	/* _MAC */

#define FILE_FLAG_SEQUENTIAL_SCAN	0x08000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#ifndef _MAC
#define INVALID_HANDLE_VALUE		((HANDLE)(-1))
#define DELETE						0x00010000L

#define FILE_BEGIN					0
#define FILE_CURRENT				1
#define FILE_END					2
#endif

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define	FILE_ATTRIBUTE_TEMPORARY		0x00000100

#define FILE_FLAG_WRITE_THROUGH     0x80000000
#define FILE_FLAG_RANDOM_ACCESS     0x10000000

#ifndef _MAC
typedef struct _WIN32_FIND_DATA {
    DWORD		dwFileAttributes;
    FILETIME	ftCreationTime;
    FILETIME	ftLastAccessTime;
    FILETIME	ftLastWriteTime;
    DWORD		nFileSizeHigh;
    DWORD		nFileSizeLow;
    DWORD		dwReserved0;
    DWORD		dwReserved1;
    CHAR		cFileName[ MAX_PATH ];
    CHAR		cAlternateFileName[ 16 ];
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;

#define TIME_ZONE_ID_INVALID		0xFFFFFFFF
#endif
#define TIME_ZONE_ID_UNKNOWN		0
#define TIME_ZONE_ID_STANDARD		1
#define TIME_ZONE_ID_DAYLIGHT		2



DWORD WINAPI	GetLastError(void);
DWORD WINAPI	GetFileAttributes(LPCSTR lpFileName);
DWORD WINAPI	GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL WINAPI		GetFileTime(HANDLE hFile, FILETIME FAR *lpftCreation,
				FILETIME FAR *lpftLastAccess, FILETIME FAR *lpftLastWrite);
BOOL WINAPI		SetFileTime(HANDLE hFile, const FILETIME FAR *lpftCreation,
				const FILETIME FAR *lpftLastAccess,
				const FILETIME FAR *lpftLastWrite);
#ifndef _MAC
/*  IsTask can crash - here's a safer one.  */
BOOL WINAPI		FIsTask(HTASK hTask);

HANDLE WINAPI	CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess,
				DWORD dwShareMode, LPVOID lpSecurityAttributes,
				DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
				HANDLE hTemplateFile);
BOOL WINAPI		ReadFile(HANDLE hFile, LPVOID lpBuffer,
				DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
				LPVOID lpOverlapped);
BOOL WINAPI		WriteFile(HANDLE hFile, LPCVOID lpBuffer,
				DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
				LPVOID lpOverlapped);
#endif
DWORD WINAPI	SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
				LONG FAR *lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL WINAPI		SetEndOfFile(HANDLE hFile);
BOOL WINAPI		CloseHandle(HANDLE hObject);
DWORD WINAPI	GetTempPath(DWORD nBufferLength, LPSTR lpBuffer);
UINT WINAPI		GetTempFileName32 (LPCSTR lpPathName, LPCSTR lpPrefixString,
				UINT uUnique, LPSTR lpTempFileName);
BOOL WINAPI		DeleteFile(LPCSTR lpFileName);
#ifndef _MAC
BOOL WINAPI		CreateDirectory(LPCSTR lpPathName, LPVOID lpSecurityAttributes);
#endif
BOOL WINAPI		RemoveDirectory(LPCSTR lpPathName);
BOOL WINAPI		CopyFile(LPCSTR szSrc, LPCSTR szDst, BOOL fFailIfExists);
BOOL WINAPI		MoveFile(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
HANDLE WINAPI	FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindClose(HANDLE hFindFile);
DWORD WINAPI	GetFullPathName(LPCSTR lpFileName, DWORD nBufferLength,
			    LPSTR lpBuffer, LPSTR *lpFilePart);
void WINAPI		Sleep(DWORD dwMilliseconds);
LONG WINAPI		CompareFileTime(const FILETIME FAR *, const FILETIME FAR *);
BOOL WINAPI		LocalFileTimeToFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToLocalFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToSystemTime(const FILETIME FAR *, SYSTEMTIME FAR *);
BOOL WINAPI		SystemTimeToFileTime(const SYSTEMTIME FAR *, FILETIME FAR *);
void WINAPI		GetSystemTime(SYSTEMTIME FAR *);
void WINAPI		GetLocalTime(SYSTEMTIME FAR *);
BOOL WINAPI		FileTimeToDosDateTime(const FILETIME FAR * lpFileTime,
			    WORD FAR *lpFatDate, WORD FAR *lpFatTime);
BOOL WINAPI		DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime,
			    FILETIME FAR * lpFileTime);
DWORD WINAPI	GetTimeZoneInformation(
				LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL WINAPI		SetTimeZoneInformation(
				const TIME_ZONE_INFORMATION FAR *lpTimeZoneInformation);

DWORD WINAPI	GetCurrentProcessId(void);
long WINAPI		MulDiv32(long, long, long);
#ifndef _MAC
BOOL WINAPI		FBadReadPtr(const void FAR* lp, UINT cb);
#endif

#else	/* !WIN16 */

/* Remaps GetTempFileName32() to the real 32bit version */

#define GetTempFileName32(_szPath,_szPfx,_n,_lpbuf)	GetTempFileName(_szPath,_szPfx,_n,_lpbuf)

#define CloseMutexHandle	CloseHandle

#endif	/* !WIN16 */


#ifdef _MAC
#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)
#endif

/********************************/
/*	Our private conventions		*/
/*	(common to WIN16/WIN32)		*/
/********************************/

#define	Cbtszsize(_a)	((lstrlen(_a)+1)*sizeof(TCHAR))
#define	CbtszsizeA(_a)	((lstrlenA(_a) + 1))
#define	CbtszsizeW(_a)	((lstrlenW(_a) + 1) * sizeof(WCHAR))
#define HexCchOf(_s)	(sizeof(_s)*2+1)
#define HexSizeOf(_s)	(HexCchOf(_s)*sizeof(TCHAR))

BOOL WINAPI IsBadBoundedStringPtr(const void FAR* lpsz, UINT cchMax);

#ifdef __cplusplus
}
#endif

#endif /* __MAPIWIN_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIWz.h ===
/*
 *	M A P I W Z . H
 *
 *	Definitions for the Profile Wizard.	 Includes all prototypes
 *	and constants required by the provider-wizard code consumers.
 *
 *	Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIWZ_H
#define _MAPIWZ_H

#if _MSC_VER > 1000
#pragma once
#endif

#define	WIZ_QUERYNUMPAGES	(WM_USER +10)
#define WIZ_NEXT			(WM_USER +11)
#define WIZ_PREV			(WM_USER +12)
/*
 *	NOTE: Provider-Wizards should not use ids ranging between
 *	(WM_USER + 1) and (WM_USER +20) as these have been reserved for
 *	future releases.
 */

/*	Flags for LaunchWizard API */

#define MAPI_PW_FIRST_PROFILE			0x00000001
#define MAPI_PW_LAUNCHED_BY_CONFIG		0x00000002
#define MAPI_PW_ADD_SERVICE_ONLY		0x00000004
#define MAPI_PW_PROVIDER_UI_ONLY		0x00000008
#define MAPI_PW_HIDE_SERVICES_LIST		0x00000010

/*
 *  Provider should set this property to TRUE if it does not
 *  want the Profile Wizard to display the PST setup page.
 */
#define PR_WIZARD_NO_PST_PAGE			PROP_TAG(PT_BOOLEAN, 0x6700)
#define PR_WIZARD_NO_PAB_PAGE			PROP_TAG(PT_BOOLEAN, 0x6701)

typedef HRESULT (STDAPICALLTYPE LAUNCHWIZARDENTRY)
(
	HWND			hParentWnd,
	ULONG			ulFlags,
	LPCTSTR FAR *	lppszServiceNameToAdd,
	ULONG			cbBufferMax,
	LPTSTR			lpszNewProfileName
);
typedef LAUNCHWIZARDENTRY FAR * LPLAUNCHWIZARDENTRY;

typedef BOOL (STDAPICALLTYPE SERVICEWIZARDDLGPROC)
(
	HWND			hDlg,
	UINT			wMsgID,
	WPARAM			wParam,
	LPARAM			lParam
);
typedef SERVICEWIZARDDLGPROC FAR * LPSERVICEWIZARDDLGPROC;

typedef ULONG (STDAPICALLTYPE WIZARDENTRY)
(
	HINSTANCE       hProviderDLLInstance,
	LPTSTR FAR *    lppcsResourceName,
	DLGPROC FAR *   lppDlgProc,
	LPMAPIPROP      lpMapiProp,
    LPVOID          lpMapiSupportObject
);
typedef WIZARDENTRY FAR * LPWIZARDENTRY;

#define LAUNCHWIZARDENTRYNAME			"LAUNCHWIZARD"

#endif	/* _MAPIWZ_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIVal.h ===
/*
 *	M A P I V A L . H
 *	
 *	Macros used to validate parameters on standard MAPI object methods.
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	_INC_VALIDATE
#define	_INC_VALIDATE

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include	<mapiutil.h>
#endif
#include	<stddef.h>
#include	<stdarg.h>


#define MAKE_ENUM(Method, Interface)	Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
	MAKE_ENUM(QueryInterface, IUnknown) = 0,
	MAKE_ENUM(AddRef, IUnknown),			/* For completness */
	MAKE_ENUM(Release, IUnknown),			/* For completness */
	
/* IMAPIProps */
	MAKE_ENUM(GetLastError, IMAPIProp),
	MAKE_ENUM(SaveChanges, IMAPIProp),
	MAKE_ENUM(GetProps, IMAPIProp),
	MAKE_ENUM(GetPropList, IMAPIProp),
	MAKE_ENUM(OpenProperty, IMAPIProp),
	MAKE_ENUM(SetProps, IMAPIProp),
	MAKE_ENUM(DeleteProps, IMAPIProp),
	MAKE_ENUM(CopyTo, IMAPIProp),
	MAKE_ENUM(CopyProps, IMAPIProp),
	MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
	MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_ENUM(GetLastError, IMAPITable),
	MAKE_ENUM(Advise, IMAPITable),
	MAKE_ENUM(Unadvise, IMAPITable),
	MAKE_ENUM(GetStatus, IMAPITable),
	MAKE_ENUM(SetColumns, IMAPITable),
	MAKE_ENUM(QueryColumns, IMAPITable),
	MAKE_ENUM(GetRowCount, IMAPITable),
	MAKE_ENUM(SeekRow, IMAPITable),
	MAKE_ENUM(SeekRowApprox, IMAPITable),
	MAKE_ENUM(QueryPosition, IMAPITable),
	MAKE_ENUM(FindRow, IMAPITable),
	MAKE_ENUM(Restrict, IMAPITable),
	MAKE_ENUM(CreateBookmark, IMAPITable),
	MAKE_ENUM(FreeBookmark, IMAPITable),
	MAKE_ENUM(SortTable, IMAPITable),
	MAKE_ENUM(QuerySortOrder, IMAPITable),
	MAKE_ENUM(QueryRows, IMAPITable),
	MAKE_ENUM(Abort, IMAPITable),
	MAKE_ENUM(ExpandRow, IMAPITable),
	MAKE_ENUM(CollapseRow, IMAPITable),
	MAKE_ENUM(WaitForCompletion, IMAPITable),
	MAKE_ENUM(GetCollapseState, IMAPITable),
	MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_ENUM(GetContentsTable, IMAPIContainer),
	MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
	MAKE_ENUM(OpenEntry, IMAPIContainer),
	MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
	MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_ENUM(CreateEntry, IABContainer),
	MAKE_ENUM(CopyEntries, IABContainer),
	MAKE_ENUM(DeleteEntries, IABContainer),
	MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
	MAKE_ENUM(CreateEntry, IDistList),
	MAKE_ENUM(CopyEntries, IDistList),
	MAKE_ENUM(DeleteEntries, IDistList),
	MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_ENUM(CreateMessage, IMAPIFolder),
	MAKE_ENUM(CopyMessages, IMAPIFolder),
	MAKE_ENUM(DeleteMessages, IMAPIFolder),
	MAKE_ENUM(CreateFolder, IMAPIFolder),
	MAKE_ENUM(CopyFolder, IMAPIFolder),
	MAKE_ENUM(DeleteFolder, IMAPIFolder),
	MAKE_ENUM(SetReadFlags, IMAPIFolder),
	MAKE_ENUM(GetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SaveContentsSort, IMAPIFolder),
	MAKE_ENUM(EmptyFolder, IMAPIFolder),

/* IMsgStore */
	MAKE_ENUM(Advise, IMsgStore),
	MAKE_ENUM(Unadvise, IMsgStore),
	MAKE_ENUM(CompareEntryIDs, IMsgStore),
	MAKE_ENUM(OpenEntry, IMsgStore),
	MAKE_ENUM(SetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
	MAKE_ENUM(StoreLogoff, IMsgStore),
	MAKE_ENUM(AbortSubmit, IMsgStore),
	MAKE_ENUM(GetOutgoingQueue, IMsgStore),
	MAKE_ENUM(SetLockState, IMsgStore),
	MAKE_ENUM(FinishedMsg, IMsgStore),
	MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_ENUM(GetAttachmentTable, IMessage),
	MAKE_ENUM(OpenAttach, IMessage),
	MAKE_ENUM(CreateAttach, IMessage),
	MAKE_ENUM(DeleteAttach, IMessage),
	MAKE_ENUM(GetRecipientTable, IMessage),
	MAKE_ENUM(ModifyRecipients, IMessage),
	MAKE_ENUM(SubmitMessage, IMessage),
	MAKE_ENUM(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_ENUM(Shutdown, IABProvider),
	MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
	MAKE_ENUM(GetLastError, IABLogon),
	MAKE_ENUM(Logoff, IABLogon),
	MAKE_ENUM(OpenEntry, IABLogon),
	MAKE_ENUM(CompareEntryIDs, IABLogon),
	MAKE_ENUM(Advise, IABLogon),
	MAKE_ENUM(Unadvise, IABLogon),
	MAKE_ENUM(OpenStatusEntry, IABLogon),
	MAKE_ENUM(OpenTemplateID, IABLogon),
	MAKE_ENUM(GetOneOffTable, IABLogon),
	MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_ENUM(Shutdown, IXPProvider),
	MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_ENUM(AddressTypes, IXPLogon),
	MAKE_ENUM(RegisterOptions, IXPLogon),
	MAKE_ENUM(TransportNotify, IXPLogon),
	MAKE_ENUM(Idle, IXPLogon),
	MAKE_ENUM(TransportLogoff, IXPLogon),
	MAKE_ENUM(SubmitMessage, IXPLogon),
	MAKE_ENUM(EndMessage, IXPLogon),
	MAKE_ENUM(Poll, IXPLogon),
	MAKE_ENUM(StartMessage, IXPLogon),
	MAKE_ENUM(OpenStatusEntry, IXPLogon),
	MAKE_ENUM(ValidateState, IXPLogon),
	MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_ENUM(Shutdown, IMSProvider),
	MAKE_ENUM(Logon, IMSProvider),
	MAKE_ENUM(SpoolerLogon, IMSProvider),
	MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_ENUM(GetLastError, IMSLogon),
	MAKE_ENUM(Logoff, IMSLogon),
	MAKE_ENUM(OpenEntry, IMSLogon),
	MAKE_ENUM(CompareEntryIDs, IMSLogon),
	MAKE_ENUM(Advise, IMSLogon),
	MAKE_ENUM(Unadvise, IMSLogon),
	MAKE_ENUM(OpenStatusEntry, IMSLogon),
	
/* IMAPIControl */
	MAKE_ENUM(GetLastError, IMAPIControl),
	MAKE_ENUM(Activate, IMAPIControl),
	MAKE_ENUM(GetState, IMAPIControl),
	
/* IMAPIStatus */
	MAKE_ENUM(ValidateState, IMAPIStatus),
	MAKE_ENUM(SettingsDialog, IMAPIStatus),
	MAKE_ENUM(ChangePassword, IMAPIStatus),
	MAKE_ENUM(FlushQueues, IMAPIStatus),

/* IStream */
	MAKE_ENUM(Read, IStream),
	MAKE_ENUM(Write, IStream),
	MAKE_ENUM(Seek, IStream),
	MAKE_ENUM(SetSize, IStream),
	MAKE_ENUM(CopyTo, IStream),
	MAKE_ENUM(Commit, IStream),
	MAKE_ENUM(Revert, IStream),
	MAKE_ENUM(LockRegion, IStream),
	MAKE_ENUM(UnlockRegion, IStream),
	MAKE_ENUM(Stat, IStream),
	MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_ENUM(OnNotify, IMAPIAdviseSink),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, &First);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)				\
		AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients
   - validate always */

#define ValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)				\
		AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal)	(FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
		(FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
		(   AssertSz(   (   offsetof( ADRLIST, cEntries) \
						 == offsetof( SRowSet, cRows)) \
					 && (   offsetof( ADRLIST, aEntries) \
						 == offsetof( SRowSet, aRow)) \
					 && (   offsetof( ADRENTRY, cValues) \
						 == offsetof( SRow, cValues)) \
					 && (   offsetof( ADRENTRY, rgPropVals) \
						 == offsetof( SRow, lpProps)) \
					, "ADRLIST doesn't match SRowSet") \
		 || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW(__in LPWSTR FAR	*lppszW,
			 ULONG		cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST	lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *	This depends upon using the standard method of declaring the object
 *	interface.
 *
 *	prefix is the method prefix you chose when declaring the object interface.
 *	method is the standard method name of the calling method.
 *	lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
	(   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
	 || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
	 ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
	(	IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
	 ||	IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
	 ||	IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)	\
	(   IsBadReadPtr( riid, sizeof(IID)) \
	 || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *	No parameter validation required.
 */
#define FBadAddRef( lpObj)	FALSE


/*
 * Release
 *	No parameter validation required.
 */
#define FBadRelease( lpObj)	FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
	(IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *	No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)	FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
	(   (   lpPTagA \
		 && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
	 || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
	(IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
						, lppUnk) \
	(   IsBadReadPtr( lpiid, sizeof(IID)) \
	 || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
	(   FBadRgPropVal( lpPropArray, (UINT) cValues) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
	(   (   !lpPTagA \
		 || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
				  , ulUIParam, lpProgress, lpInterface, lpDestObj \
				  , ulFlags, lppProblems) \
	(	(	ciidExclude \
		 && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
	 || (   lpExcludeProps \
		 && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpExcludeProps \
			 				, (UINT)(  (lpExcludeProps->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
					 , ulUIParam, lpProgress, lpInterface, lpDestObj \
					 , ulFlags, lppProblems) \
	(   (   lpPropTagArray \
		 && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPropTagArray \
			 				, (UINT)(  (lpPropTagArray->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
							 lpcPropNames, lpppPropNames) \
	(   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
	 || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
	 || (   *lppPropTags \
		 && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
		 	 || IsBadReadPtr( *lppPropTags \
			 				, (UINT)( ( ( *lppPropTags)->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
	 || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
						   , lppPropTags) \
	(   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
	 || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

	The eMethod parameter tells us which internal validation to perform.
	
	The ppThis parameter tells us where the stack is, so we can access the other
	parameters.
	
	Becuase of this *magic* we MUST obtain the pointer to the This pointer in
	the method function.
	
*/

#ifdef WIN16
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )

#define ArgSize(T) ((sizeof(T)+3)/4)
#define MakeArg1(idx, a1) memcpy(__rgArgs+idx, &a1, ArgSize(a1)*4)
#define MakeArg2(idx, a1, a2) MakeArg1(idx, a1); MakeArg1(idx+ArgSize(a1), a2)
#define MakeArg3(idx, a1, a2, a3) MakeArg1(idx, a1); MakeArg2(idx+ArgSize(a1), a2, a3)
#define MakeArg4(idx, a1, a2, a3, a4) MakeArg1(idx, a1); MakeArg3(idx+ArgSize(a1), a2, a3, a4)
#define MakeArg5(idx, a1, a2, a3, a4, a5) MakeArg1(idx, a1); MakeArg4(idx+ArgSize(a1), a2, a3, a4, a5)
#define MakeArg6(idx, a1, a2, a3, a4, a5, a6) MakeArg1(idx, a1); MakeArg5(idx+ArgSize(a1), a2, a3, a4, a5, a6)
#define MakeArg7(idx, a1, a2, a3, a4, a5, a6, a7) MakeArg1(idx, a1); MakeArg6(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7)
#define MakeArg8(idx, a1, a2, a3, a4, a5, a6, a7, a8) MakeArg1(idx, a1); MakeArg7(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8)
#define MakeArg9(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9) MakeArg1(idx, a1); MakeArg8(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9)
#define MakeArg10(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) MakeArg1(idx, a1); MakeArg9(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10)
#define MakeArg11(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) MakeArg1(idx, a1); MakeArg10(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
#define MakeArg12(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) MakeArg1(idx, a1); MakeArg11(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
#define MakeArg13(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) MakeArg1(idx, a1); MakeArg12(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
#define MakeArg14(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) MakeArg1(idx, a1); MakeArg13(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
#define MakeArg15(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) MakeArg1(idx, a1); MakeArg14(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
#define MakeArg16(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) MakeArg1(idx, a1); MakeArg15(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)

#define MakeArray1(a1) \
	DWORD __rgArgs[ArgSize(a1)]; \
	MakeArg1(0, a1)

#define MakeArray2(a1, a2) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2)]; \
	MakeArg2(0, a1, a2)

#define MakeArray3(a1, a2, a3) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3)]; \
	MakeArg3(0, a1, a2, a3)

#define MakeArray4(a1, a2, a3, a4) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4)]; \
	MakeArg4(0, a1, a2, a3, a4)

#define MakeArray5(a1, a2, a3, a4, a5) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5)]; \
	MakeArg5(0, a1, a2, a3, a4, a5)

#define MakeArray6(a1, a2, a3, a4, a5, a6) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6)]; \
	MakeArg6(0, a1, a2, a3, a4, a5, a6)

#define MakeArray7(a1, a2, a3, a4, a5, a6, a7) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7)]; \
	MakeArg7(0, a1, a2, a3, a4, a5, a6, a7)

#define MakeArray8(a1, a2, a3, a4, a5, a6, a7, a8) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8)]; \
	MakeArg8(0, a1, a2, a3, a4, a5, a6, a7, a8)

#define MakeArray9(a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9)]; \
	MakeArg9(0, a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define MakeArray10(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10)]; \
	MakeArg10(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)

#define MakeArray11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11)]; \
	MakeArg11(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)

#define MakeArray12(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12)]; \
	MakeArg12(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)

#define MakeArray13(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13)]; \
	MakeArg13(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)

#define MakeArray14(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14)]; \
	MakeArg14(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)

#define MakeArray15(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14) + ArgSize(a15)]; \
	MakeArg15(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)

#define MakeArray16(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14) + ArgSize(a15) + ArgSize(a16)]; \
	MakeArg16(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)



#define ValidateParameters1( m, a1 ) 
#define ValidateParameters2( m, a1, a2 ) \
			{ HRESULT _hr_; \
			MakeArray1(a2); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters3( m, a1, a2, a3 ) \
			{ HRESULT _hr_; \
			MakeArray2(a2, a3); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			{ HRESULT _hr_; \
			MakeArray3(a2, a3, a4); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			{ HRESULT _hr_; \
			MakeArray4(a2, a3, a4, a5); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ HRESULT _hr_; \
			MakeArray5(a2, a3, a4, a5, a6); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ HRESULT _hr_; \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ HRESULT _hr_; \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ HRESULT _hr_; \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ HRESULT _hr_; \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ HRESULT _hr_; \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ HRESULT _hr_; \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ HRESULT _hr_; \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ HRESULT _hr_; \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ HRESULT _hr_; \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ HRESULT _hr_; \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }

#define UlValidateParameters1( m, a1 ) 
#define UlValidateParameters2( m, a1, a2 ) \
			{ HRESULT _hr_; \
			MakeArray1(a2); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters3( m, a1, a2, a3 ) \
			{ HRESULT _hr_; \
			MakeArray2(a2, a3); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			{ HRESULT _hr_; \
			MakeArray3(a2, a3, a4); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			{ HRESULT _hr_; \
			MakeArray4(a2, a3, a4, a5); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ HRESULT _hr_; \
			MakeArray5(a2, a3, a4, a5, a6); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ HRESULT _hr_; \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ HRESULT _hr_; \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ HRESULT _hr_; \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ HRESULT _hr_; \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ HRESULT _hr_; \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ HRESULT _hr_; \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ HRESULT _hr_; \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ HRESULT _hr_; \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ HRESULT _hr_; \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ HRESULT _hr_; \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }

#ifdef DEBUG
#define CheckParameters1( m, a1 ) 
#define CheckParameters2( m, a1, a2 ) \
			{ \
			MakeArray1(a2); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters3( m, a1, a2, a3 ) \
			{ \
			MakeArray2(a2, a3); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			{ \
			MakeArray3(a2, a3, a4); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			{ \
			MakeArray4(a2, a3, a4, a5); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ \
			MakeArray5(a2, a3, a4, a5, a6); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#else /* DEBUG */
#define CheckParameters1( m, a1 ) 
#define CheckParameters2( m, a1, a2 )
#define CheckParameters3( m, a1, a2, a3 )
#define CheckParameters4( m, a1, a2, a3, a4 )
#define CheckParameters5( m, a1, a2, a3, a4, a5 )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 )
#endif /* DEBUG */
#else /* !_X86_  && !WIN16 */
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")

#define ValidateParameters1( m, a1 ) \
			ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )	\
			ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )	\
			ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
			UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )	\
			UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
			CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )	\
			CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *  	M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
			 CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
			 ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
			 UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
			 CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
			 ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
			 UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
			 CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
			 ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
			 UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
			 CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
			 CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
			 CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
			 ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
			 UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
			 CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
			 CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
			 ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
			 CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
			 CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
			 ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
			 UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
			 CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
			 ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
			 UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
			 CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
			 CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
			 ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
			 CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
			 CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
			 ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
			 UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
			 CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
			 ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
			 UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
			 CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
			 ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
			 UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
			 CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
			 ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
			 UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
			 CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
			 ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
			 UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
			 CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


#ifdef WIN16
HRESULT
PASCAL	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV	HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MAPIUtil.h ===
/*
 *	M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );

/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	__in LPTSTR			lpszFileName,
	__in_opt LPTSTR			lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	__in LPTSTR			lpszFileName,
	__in LPTSTR			lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for building a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE	1
#define MAPI_FULL_IPM_TREE	2

STDAPI					HrValidateIPMSubtree(LPMDB lpMDB, ULONG ulFlags,
						ULONG FAR *lpcValues, LPSPropValue FAR *lppValues,
						LPMAPIERROR FAR *lpperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)			FBinFromHex(__in LPTSTR lpsz, LPBYTE lpb);
STDAPI_(SCODE)			ScBinFromHexBounded(__in LPTSTR lpsz, LPBYTE lpb, ULONG cb);
STDAPI_(void)			HexFromBin(LPBYTE lpb, int cb, __in LPTSTR lpsz);
STDAPI_(ULONG)			UlFromSzHex(LPCTSTR lpsz);

/* Encoding and decoding entry IDs */
STDAPI					HrEntryIDFromSz(__in LPTSTR lpsz, ULONG FAR *lpcb,
						LPENTRYID FAR *lppEntryID);
STDAPI					HrSzFromEntryID(ULONG cb, LPENTRYID lpEntryID,
						__in LPTSTR FAR *lpsz);
STDAPI					HrComposeEID(LPMAPISESSION lpSession,
						ULONG cbStoreRecordKey, LPBYTE lpStoreRecordKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						ULONG FAR *lpcbEID, LPENTRYID FAR *lppEntryID);
STDAPI					HrDecomposeEID(LPMAPISESSION lpSession,
						ULONG cbEntryID, LPENTRYID lpEntryID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lpcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);
STDAPI					HrComposeMsgID(LPMAPISESSION lpSession,
						ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						__in LPTSTR FAR *lpszMsgID);
STDAPI					HrDecomposeMsgID(LPMAPISESSION lpSession,
						__in LPTSTR lpszMsgID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lppcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);

/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(__in LPSTR lpszLocal, __in LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(__in LPSTR lpszUNC, __in LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, __in LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, __out BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (__in LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, __out LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\mediaerr.h ===
//------------------------------------------------------------------------------
// File: MediaErr.h
//
// Desc: Shell error codes
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _MEDIAERR_H_
#define _MEDIAERR_H_

#define DMO_E_INVALIDSTREAMINDEX 0x80040201
#define DMO_E_INVALIDTYPE        0x80040202
#define DMO_E_TYPE_NOT_SET       0x80040203
#define DMO_E_NOTACCEPTING       0x80040204
#define DMO_E_TYPE_NOT_ACCEPTED  0x80040205
#define DMO_E_NO_MORE_ITEMS      0x80040206

#endif _MEDIAERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Mcx.h ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

#if _MSC_VER > 1000
#pragma once
#endif

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap

    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for d