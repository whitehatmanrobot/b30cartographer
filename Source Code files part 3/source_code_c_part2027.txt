public DateTime SettingsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        // titles
        //
        public DateTime TitlesVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;


        // achievements
        //
        public DateTime AchievementsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;


        public override string Xrl
        {
            get { return "/xstats/syncall.ashx"; }
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncAllResponse : XRLObject2
    {
        public SyncSettingsResponse Settings = new SyncSettingsResponse();
        public SyncTitlesResponse Titles = new SyncTitlesResponse();
        public SyncAchievementsResponse Achievements = new SyncAchievementsResponse();
    }


    public class ContextString : WireData
    {
        public uint ContextId;
        public uint NameLen;
        public string Name;
    }

    public class ContextEnumRequest : XRLObject2
    {
        public uint TitleId;
        public uint ContextId;
        public ushort LocaleId;
        public uint StartingIndex;
        public uint MaxContexts;

        public override string Xrl
        {
            get { return "/xstats/contextenum.ashx"; }
        }

    }

    public class ContextEnumResponse : XRLObject2
    {
        public uint TotalContexts;

        public uint ContextsLen;
        public ContextString[] Contexts;
    }

    #endregion

    #region Console Audit List(Xenon)

    public class ConsoleIdData : WireData
    {
        [WireInfo(ArraySize = 5)]
        public byte[] ConsoleId = null;

        public static ulong GetDecimalValue(byte[] consoleIdBytes)
        {
            if (consoleIdBytes == null)
            {
                return 0;
            }

            ulong result = 0;
            for (int i = consoleIdBytes.Length - 1; i >= 0; --i)
            {
                result = (result << 8) + consoleIdBytes[i];
            }
            return result;
        }

        public ConsoleIdData()
        {
        }

        public ConsoleIdData(byte[] ConsoleId)
        {
            this.ConsoleId = ConsoleId;
        }
    }

    /// <summary>
    /// UploadConsoleListRequest
    /// </summary>
    /// <param name="UploadingConsole">Console Id for console doing the upload</param>
    /// <param name="SigningConsole">Console Id of console that signed the PEC</param>
    /// <param name="ConsoleCount">Count of consoles</param>
    /// <param name="ConsoleList">Collection of console ids</param>
    /// <returns>nothing</returns>
    /// <remarks>
    /// Upload a list of consoles that have modified the PEC on the console
    /// </remarks>
    public class UploadConsoleListRequest : XRLObject2
    {
        public ulong UserId = 0;

        public ConsoleIdData UploadingConsoleId = new ConsoleIdData();
        public ConsoleIdData SigningConsoleId = new ConsoleIdData();

        [WireInfo(Max = XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST)]
        public byte ConsoleCount = 0;

        [WireInfo(SizeParam = "ConsoleCount")]
        public ConsoleIdData[] ConsoleIdList = null;

        public override string Xrl
        {
            get { return "/xstats/uploadconsoleauditlist.ashx"; }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\UserRole.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{
	[ComVisible(false)]
	public class UserRole : IUserRole
	{
		private string _rolename;
		private string _username;
		private string _domainname;
		private string _password;

		public string Name
		{
			get { return _rolename; }
			set { _rolename = value; }
		}

		public string FullUsername
		{
			get { return _domainname + "\\" + _username; }
			set 
			{ 
				String [] split = value.Split('\\');

				if( split.Length == 1 )
				{
					_domainname = ".";
					_username = split[0];
				}
				else if( split.Length == 2 )
				{
					_domainname = split[0];
					_username = split[1];
				}
				else
				{
					throw new ArgumentException("Invalid username");
				}
			}
		}

		public string Username
		{
			get { return _username; }
		}

		public string Domainname
		{
			get { return _domainname; }
		}

		public string Password
		{
			get { return _password; }
			set { _password = value; }
		}

		public UserRole()
		{
			_rolename = null;
			_username  = null;
			_password = null;
		}
	}
} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Validator.cs ===
using System;

using STF.common.utilities2;

namespace STF.common.service
{
    /// <summary>
    ///     This can be used as a generic validation module. To use this, do the following:
    ///     1)  Make the Validators that you will need (look around for existing ones first
    ///         as there's a chance you can reuse something.
    ///     1a) Implement DoCheckImpl on your new classes, see comment block
    ///         by that function declaration for details.
    ///     2)  Pass a bunch of Validators into MakeValidatorChain, which will return
    ///         a Validator that will do everything for you.
    ///     2a) In addition to the Validators, pass in the "final result" of the chain.
    ///     3)  Call DoCheck
    ///     3a) If this return true, you're good to go.
    ///     3b) If it returns false, we should not generate a certificate.  To get an
    ///         error message suitable for an exception, get the ErrorMessage property.
    /// </summary>
    ///
    /// <remarks>
    ///     Internally, the CertificateRequestChecker is basically a Chain of Responsiblity (GoF, page 233),
    ///     implemented as a linked-list of CertificateRequestGenerators.
    /// </remarks>
    public abstract class Validator
    {
        ///
        /// <summary>
        ///     Makes a Validator chain out of the Validators passed in.
        ///     Note that this alters the validators passed in--it doesn't clone them.
        /// </summary>
        ///
        /// <param name="finalResult">
        ///     Indicates whether the final result, if nothing has an opinion, should be true or false.
        ///     Note that these are modified as they are chained together.
        /// </param>
        /// <param name="validators">An array of validators to chain together, in the order in which they are passed in.</param>
        ///
        /// <returns>The first validator passed in, with the rest chained to it.</returns>
        ///
        public static Validator MakeValidatorChain(bool finalResult, params Validator[] validators)
        {
            if (validators == null || validators.Length <= 0)
            {
                throw new ArgumentException("You must pass in one or more valid Validators to make a Validator chain.", "validators");
            }

            int idx = 0;
            while (idx < validators.Length - 1)
            {
                validators[idx]._next = validators[idx + 1];
                ++idx;
            }
            validators[idx]._next = new EndOfChainValidator(finalResult);

            return validators[0];
        }


        ///
        /// <summary>
        ///     Actually do the check.
        /// </summary>
        ///
        /// <returns>Whether validation passed or failed.</returns>
        ///
        public bool DoCheck()
        {
            // Call the virtual checking function.
            // This is where the subclass gets to do its work.
            DoCheckResults result = DoCheckImpl();

            // If the subclass says this is absolutely a valid request
            // (as in a white-list case), then stop checking and
            // return true.  This indicates that no other check
            // could convince us that this is an invalid request.
            if (result == DoCheckResults.AbsoluteYes)
            {
                return true;
            }

            // If the subclass says this is absolutely not a valid
            // request, then stop checking and return false.  This
            // indicates that no other check could convince us that
            // this is a valid request.
            // Note that if we return false, we *must* have
            // set our ErrorMessage property.
            else if (result == DoCheckResults.AbsoluteNo)
            {
                if (String.IsNullOrEmpty(ErrorMessage))
                {
                    throw new ApplicationException("DoCheck is about to return false but has no error message.");
                }
                return false;
            }

            // If the subclass says "meh" then pass the decision down the list.
            else if (result == DoCheckResults.NoOpinion)
            {
                if (_next != null)
                    {
                    return _next.DoCheck();
                    }
                else
                    {
                    throw new ApplicationException("Use an EndOfChainCertificateChecker do a final yes or no answer.");
                    }
            }

            // This is an unexpected case which indicates that a member
            // has been added to DoCheckResults but hasn't been implemented
            // in this function, which would pretty much be the end
            // of the world.
            else
            {
                throw new ApplicationException(String.Format("Unexpected return value from DoCheckImpl: {0}.", result));
            }
        }


        ///
        /// <summary>
        ///     If DoCheck return false, this will contain an error message.
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we don't
        ///     have a string and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        /// </remarks>
        ///
        /// <returns>An error string representing why the validation didn't pass.</returns>
        ///
        public string ErrorMessage
        {
            get
            {
                if (String.IsNullOrEmpty(_error) && _next != null)
                {
                    return _next.ErrorMessage;
                }
                else
                {
                    return _error;
                }
            }
            protected set { _error = value; }
        }


        ///
        /// <summary>
        ///     If DoCheck returns false, this will contain a logging string, which is 
        ///     shorter than the normal error message
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we haven't
        ///     set the hr and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        ///
        ///     NOTE: Unlike ErrorMessage, subclasses are not required to set this field 
        ///     on failure. If they don't set this, but have set ErrorMessage, we will 
        ///     generate one for them.
        /// </remarks>
        ///
        /// <returns>A short error string giving a hint to ops and dev as to what 
        /// failed.</returns>
        ///
        public string LogError
        {
            get
            {
                if (String.IsNullOrEmpty(_logError))
                {
                    // If they haven't set the log error, but have set the error, then we 
                    // should use a default. Also, if this is the end of the chain, we 
                    // need a default.
                    if (!String.IsNullOrEmpty(_error) || _next == null)
                    {
                        return this.GetType().Name;
                    }
                    else
                    {
                        return _next.LogError;
                    }
                }
                else
                {
                    return _logError;
                }
            }
            protected set
            {
                if (value.Length > LOG_ERROR_MAX_LEN)
                {
                    throw new ArgumentException(String.Format("Validator.LogError set to {0}, which has length of {1}, which is greater than {2}.",
                                                              value, value.Length, LOG_ERROR_MAX_LEN));
                }
                else
                {
                    _logError = value;
                }
            }
        }


        ///
        /// <summary>
        ///     If DoCheck return false, this will contain an error code.
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we haven't
        ///     set the hr and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        /// </remarks>
        ///
        /// <returns>An error code representing why the validation didn't pass.</returns>
        ///
        public HResult Hr
        {
            get
            {
                if (_hrSet)
                {
                    return _hr;
                }
                else if (_next != null)
                {
                    return _next.Hr;
                }
                else
                {
                    return DEFAULT_HRESULT;
                }
            }

            protected set
            {
                _hr = value;
                _hrSet = true;
            }
        }


        ///
        /// <summary>
        ///     Derived classes must implement this function.  The meanings of the
        ///     return values are detailed below.  Take a look at DoCheck to see
        ///     how these are used.
        /// </summary>
        ///
        /// <returns>The result of the validation.</returns>
        public enum DoCheckResults
        {
            AbsoluteYes = 1,    // Absolutely return true from DoCheck.  Stop checking.
            NoOpinion   = 2,    // Don't really care.  Continue checking.
            AbsoluteNo  = 3,    // Absolutely return false from Docheck.  Stop checking.
        }
        protected abstract DoCheckResults DoCheckImpl();


        private string _error = String.Empty;
        private string _logError = String.Empty;
        private Validator _next = null;
        private HResult _hr = 0;
        private bool _hrSet = false;

        // I'd rather not introduce any new dependencies.
        private const uint DEFAULT_HRESULT = HResult.E_ACCESSDENIED;
        private const uint LOG_ERROR_MAX_LEN = 20;
    }


    //
    // From here on down we have Validators that might be of general use.
    //

    //
    // Ensures that the request comes in from a supported client.
    //
    public sealed class PlatformValidator : Validator
    {
        public PlatformValidator(byte[] platforms)
        {
            _platforms = platforms;
        }

        public PlatformValidator(byte allowedPlatform, byte[] platforms)
            : this(platforms)
        {
            _allowedPlatform = allowedPlatform;
        }

        public static PlatformValidator MakeXbox360PlatformValidator()
        {
            return new PlatformValidator(new byte[] {XOn.XPLT_XBOX360} );
        }

        override protected DoCheckResults DoCheckImpl()
        {
            byte platformDetected = GetPlatform();
            if (!Array.Exists(_platforms, delegate(byte platform) { return platform == platformDetected; } ))
            {
                this.ErrorMessage = String.Format(
                    "Request came from an unexpected platform type {0}. The allowed platform types are {1}.",
                    platformDetected,
                    EnumerableFormatter.FormatEnumerable(_platforms));
                return DoCheckResults.AbsoluteNo;
            }

            return DoCheckResults.NoOpinion;
        }

        private byte GetPlatform()
        {
            if (_allowedPlatform.HasValue)
            {
                return _allowedPlatform.Value;
            }
            else
            {
                if (SGInfo.IsActiveAuth())
                {
                    return XOn.XPLT_WEB;
                }
                else
                {
                    return SGInfo.Current.GetPlatformType();
                }
            }
        }

        private readonly byte[] _platforms;
        private readonly byte? _allowedPlatform;
    }


    //
    // A trivial checker that just returns yes or no. This can be used for the end of the chain.
    //
    sealed class EndOfChainValidator : Validator
    {
        public EndOfChainValidator(bool finalResult)
        {
            _finalAnswer = finalResult ? DoCheckResults.AbsoluteYes : DoCheckResults.AbsoluteNo;
        }

        override protected DoCheckResults DoCheckImpl()
        {
            return _finalAnswer;
        }

        private readonly DoCheckResults _finalAnswer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\VortexProt.cs ===
// VortexProt.cs
//
// Copyright (c) 2010 Microsoft Corporation. All Rights Reserved.
// Xbox Live
// Author: kgoodier 02/2010
//
// Definitions (and parsing code) for Vortex's binary protocol. This is a pretty compact 
// protocol, perhaps it will get used outside of the Vortex and distributed monitoring 
// world.
//
// This is not WireData, by the way. It's self-describing and doesn't, currently, have a 
// manifest or attributed classes describing all the various messages. 
//
// See http://xblwiki/default.aspx/XboxLive/VortexProtocol.html for spec.
//
   
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Net;

using STF.common.service;
using STF.common.utilities2;

namespace STF.common.protocol 
{

    // ----------------------------------------------------------------------------------
    // VortexBinaryReader
    //
    // Extends the basic BinaryReader, which only provides a signed 32-bit version of 
    // Read7BitEncodedXXX.  We need an unsigned 64-bit version.
    // ----------------------------------------------------------------------------------
    public class VortexBinaryReader : BinaryReader
    {
        public VortexBinaryReader(Stream inStream)
            : base(inStream)
        {
        }

        public ulong Read7BitEncodedUInt64()
        {
            byte b;
            ulong num = 0;
            int dataBits = 0;
            do
            {
                if (dataBits > 64)
                {
                    throw new FormatException("Invalid 7-bit encoding format: too many bits");
                }
                b = this.ReadByte();
                num |= (ulong)(b & 0x7f) << dataBits;
                dataBits += 7;
            }
            while ((b & 0x80) != 0);
            return num;
        }

        public long Read7BitEncodedInt64()
        {
            ulong num = Read7BitEncodedUInt64();
            return unchecked((long)FromZigZag(num));
        }

        public ulong FromZigZag(ulong v)
        {
            // Must right-shift with a signed left-hand-side, to ensure an arithmetic 
            // shift. Basically, we want all 0's if LSB is 0 or all 1's if LSB is 1. I 
            // can't find anything that left-shifts and extends with 1's instead of 0's.  
            // 
            // Note the cast to a long is the magic here, a right-shift of a signed number 
            // is an arithmetic shift that will leave 1s behind.
            ulong signbitmask = (ulong)((long)(v << 63) >> 63);

            // Must right-shift with an unsigned left-hand-side, to ensure a logical 
            // shift. We don't want to extend the sign bit here.
            return (v >> 1) ^ signbitmask;
        }

        public byte[] ReadBlob()
        {
            ulong count = Read7BitEncodedUInt64();
            return ReadBytes((int)count);
        }

        public object ReadVxField(out uint fieldType, out uint fieldId)
        {
            ReadVxFieldTypeId(out fieldType, out fieldId);
            return ReadVxFieldValue(fieldType);
        }

        // @@@ ReadString?

        public void ReadVxFieldTypeId(out uint fieldType, out uint fieldId)
        {
            ulong fieldTypeId = Read7BitEncodedUInt64();
            fieldType = (uint)(fieldTypeId & VxProtocol.c_FieldTypeMask);
            fieldId = (uint)(fieldTypeId >> VxProtocol.c_FieldTypeShift);
        }

        public object ReadVxFieldValue(uint fieldType)
        {
            // Read field-value
            switch (fieldType)
            {
            case (uint)VxProtocol.VxFieldType.Terminator:
                return null;

            case (uint)VxProtocol.VxFieldType.VarInt:
                return Read7BitEncodedUInt64();

            case (uint)VxProtocol.VxFieldType.Blob:
                return ReadBlob();

            case (uint)VxProtocol.VxFieldType.Single:
                return ReadSingle();

            case (uint)VxProtocol.VxFieldType.Double:
                return ReadDouble();

            case (uint)VxProtocol.VxFieldType.String:
                return UTF8Encoding.UTF8.GetString(ReadBlob());

            case (uint)VxProtocol.VxFieldType.SVarInt:
                return Read7BitEncodedInt64();

            case (uint)VxProtocol.VxFieldType.Special:
                {
                    uint specialFieldType;
                    uint specialFieldId;
                    SpecialField specialField = new SpecialField();

                    ReadVxFieldTypeId(out specialFieldType, out specialFieldId);
                    specialField.Value = ReadVxFieldValue(specialFieldType);
                    specialField.Id = specialFieldId;
                    return specialField;
                }

            default:
                throw new Exception("Unknown field type " + fieldType); // @@@
            }
        }

    }

    // ----------------------------------------------------------------------------------
    // VortexBinaryWriter
    //
    // Extends the basic BinaryWriter, which only provides a signed 32-bit version of 
    // Write7BitEncodedXXX.  We need an unsigned 64-bit version.
    // ----------------------------------------------------------------------------------
    public class VortexBinaryWriter : BinaryWriter
    {
        public VortexBinaryWriter(Stream inStream)
            : base(inStream)
        {
        }

        public void Write7BitEncodedUInt64(ulong v)
        {
            while (v >= 0x80)
            {
                Write((byte)(v | 0x80));
                v = v >> 7;
            }
            Write((byte)v);
        }

        public void Write7BitEncodedInt64(long v)
        {
            ulong num = ToZigZag(unchecked((ulong)v));
            Write7BitEncodedUInt64(num);
        }

        private ulong ToZigZag(ulong v)
        {
            // Must right-shift with a signed left-hand-side, to ensure an arithmetic 
            // shift. Basically, we want all 0's if MSB is 0 or all 1's if MSB is 1. 
            ulong signbitmask = (ulong)((long)v >> 63);
            return (v << 1) ^ signbitmask;
        }

        private void WriteVxFieldTypeId(uint fieldType, uint fieldId)
        {
            // 29 bits is max
            if (fieldId > 0x1FFFFFFF)
            {
                throw new ArgumentOutOfRangeException("Maximum value for field id is 29 bits, or 536870911. " + fieldId + " is out of range.", "fieldId");
            }
            ulong v = ((ulong)fieldId << VxProtocol.c_FieldTypeShift) | (ulong)(fieldType & VxProtocol.c_FieldTypeMask);
            Write7BitEncodedUInt64(v);
        }

        public void WriteBlob(byte[] blob)
        {
            Write7BitEncodedUInt64((ulong)blob.Length);
            Write(blob);
        }

        // Helpers

        public void WriteVxField(uint fieldId, ulong v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64(v);
        }

        public void WriteVxField(uint fieldId, long v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, uint v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, int v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, ushort v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, short v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, byte v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, sbyte v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, byte[] v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Blob, fieldId);
            WriteBlob(v);
        }

        public void WriteVxField(uint fieldId, float v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Single, fieldId);
            Write(v);
        }

        public void WriteVxField(uint fieldId, double v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Double, fieldId);
            Write(v);
        }

        public void WriteVxField(uint fieldId, string v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.String, fieldId);
            WriteBlob(UTF8Encoding.UTF8.GetBytes(v));
        }

        public void WriteVxField(uint fieldId, SpecialField sf)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Special, fieldId);
            WriteVxField(sf.Id, sf.Value);
        }

        public void WriteVxField(uint fieldId, Guid v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Blob, fieldId);
            WriteBlob(v.ToByteArray());
        }

        public void WriteVxField(uint fieldId, DateTime dt)
        {
            WriteVxField(fieldId, (ulong)dt.ToFileTimeUtc());
        }

        public void WriteVxField(uint fieldId, object o)
        {
            if (o == null)
                WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Terminator, fieldId);
            else if (o is byte)
                WriteVxField(fieldId, (byte)o);
            else if (o is sbyte)
                WriteVxField(fieldId, (sbyte)o);
            else if (o is short)
                WriteVxField(fieldId, (short)o);
            else if (o is ushort)
                WriteVxField(fieldId, (ushort)o);
            else if (o is int)
                WriteVxField(fieldId, (int)o);
            else if (o is uint)
                WriteVxField(fieldId, (uint)o);
            else if (o is long)
                WriteVxField(fieldId, (long)o);
            else if (o is ulong)
                WriteVxField(fieldId, (ulong)o);
            else if (o is float)
                WriteVxField(fieldId, (float)o);
            else if (o is double)
                WriteVxField(fieldId, (double)o);
            else if (o is string)
                WriteVxField(fieldId, (string)o);
            else if (o is byte[])
                WriteVxField(fieldId, (byte[])o);
            else if (o is SpecialField)
                WriteVxField(fieldId, (SpecialField)o);
            else if (o is Blob)
                WriteVxField(fieldId, (byte[])o);
            else if (o is Guid)
                WriteVxField(fieldId, (Guid)o);
            else if (o is DateTime)
                WriteVxField(fieldId, (DateTime)o);
            else if (o is char)
                WriteVxField(fieldId, new string(new char[] { (char)o }));
            else if (o is char[])
                WriteVxField(fieldId, new string((char[])o));
            else if (o is IPAddress)
                WriteVxField(fieldId, (byte[])((IPAddress)o).GetAddressBytes());
            else if (o is Floken)
                WriteVxField(fieldId, (ulong)((Floken)o).FlowToken);
            else
                throw new ArgumentException("Unknown field type " + o.GetType().ToString() + ": " + o.ToString());

        }

    }


    // ----------------------------------------------------------------------------------
    // VxEvent
    //
    // This is a generic representation of any binary message sent with the 
    // VortexProtocol. Since it is NOT a well-defined message type, it can be used to 
    // represent any incoming message, known or unknown.
    //
    // This class is best used to provide random-access (by ordinal) to the field
    // values. If you need more of wiredata scenario, where you already know the 
    // exact format of the message/event, then you should write some code to handle
    // that explicitly. It will be faster.
    //
    // ----------------------------------------------------------------------------------
    public class VxEvent
    {
        public const char c_ProducerEventSeparator = '@';
        public const uint c_MaxFieldOrdinal = 256;

        public Blob ProducerId
        {
            get { return _ProducerId; }
        }

        public uint EventId 
        {
            get { return _EventId; }
        }

        public DateTime Timestamp
        {
            get { return _Timestamp; }
        }

        public string LogStringId 
        {
            get 
            { 
                if (_LogStringId == null)
                {
                    // Return "ProducerId@EventId" in lieue of a pretty LogStringId
                    _LogStringId = _ProducerId.ToString() + c_ProducerEventSeparator + _EventId.ToString();
                }
                return _LogStringId;
            }
            set 
            { 
                _LogStringId = value; 
            }
        }

        public VortexFieldCollection EventFields
        {
            get { return _FieldCollection; }
        }

        public VxEvent(VortexBinaryReader inStream)
            : this(inStream, Blob.Empty, 0)
        {
        }

        public VxEvent(VortexBinaryReader inStream, Blob lastProducerId, long timestampBase)
        {
            Blob producerId = inStream.ReadBlob();
            _EventId = (uint)inStream.Read7BitEncodedUInt64();
            long timestampDelta = inStream.Read7BitEncodedInt64();
            _Timestamp = DateTime.FromFileTimeUtc(timestampBase + timestampDelta);
            _LogStringId = null;  // requires a manifest

            // Encoded run of producer ids, use last seen one if this one isn't present
            if (producerId.Length == 0)
            {
                _ProducerId = lastProducerId;
            }
            else
            {
                _ProducerId = producerId;
            }

            // Read event fields
            _FieldCollection = new VortexFieldCollection();
            while (true)
            {
                // Read field-type-id
                uint fieldType;
                uint fieldId;
                object val;

                val = inStream.ReadVxField(out fieldType, out fieldId);
                if (val == null)
                {
                    // We're done. Get out of here.
                    return;
                }
                _FieldCollection.AddField(fieldType, fieldId, val);
            }
        }

        public VxEvent(Blob producerId, uint eventId, DateTime timestamp)
        {
            _ProducerId = producerId;
            _EventId = eventId;
            _Timestamp = timestamp;
            _LogStringId = null;  // requires a manifest
            _FieldCollection = new VortexFieldCollection();
        }

        public VxEvent Clone()
        {
            VxEvent result = new VxEvent(_ProducerId, _EventId, _Timestamp);

            result._LogStringId = _LogStringId;
            result._FieldCollection = _FieldCollection.Clone();

            return result;
        }

        public void WriteStream(VortexBinaryWriter bw)
        {
            WriteStream(bw, Blob.Empty, 0);
        }

        public void WriteStream(VortexBinaryWriter bw, Blob lastProducerId, long timestampBase)
        {
            long timestampDiff = Timestamp.ToFileTimeUtc() - timestampBase;

            // Event headers
            if (lastProducerId == ProducerId)
            {
                // Encode a run.
                bw.Write((byte)0);
            }
            else
            {
                bw.WriteBlob(ProducerId);
            }
            bw.Write7BitEncodedUInt64(EventId);
            bw.Write7BitEncodedInt64(timestampDiff);
            
            // Fields
            EventFields.WriteStream(bw);

            // Terminator
            bw.Write((byte)0);
        }

        public override string ToString()
        {
            return ToString(true);
        }

        public string ToString(bool fIncludeTimestamp)
        {
            // [ClientTimestamp]|LogStringId|EventFields...

            StringBuilder sb = new StringBuilder(500);
            if (fIncludeTimestamp)
            {
                sb.Append(XDateTime.ToString(_Timestamp));
                sb.Append("|");
            }
            sb.Append(LogStringId);
            string fieldsStr = EventFields.ToString();
            if (!String.IsNullOrEmpty(fieldsStr))
            {
                sb.Append("|");
                sb.Append(fieldsStr);
            }
            return sb.ToString();
        }

        private Blob _ProducerId;
        private uint _EventId;
        private DateTime _Timestamp;
        private string _LogStringId;
        private VortexFieldCollection _FieldCollection;


        // ------------------------------------------------------------------------------
        // class VortexFieldCollection
        //
        // This represents a single-namespace's worth of fields. They are stored in a 
        // generic object form, but will always be a ulong, byte[], float, or double.  
        //
        // It is random-access by ordinal field id.
        // ------------------------------------------------------------------------------
        public class VortexFieldCollection
        {
            private Dictionary<uint, object> _fieldValues;
            private HashSet<uint> _specialFieldOrdinals;
            private uint _maxFieldOrdinal = 0;

            public int Count
            {
                get
                {
                    return _fieldValues.Count;
                }
            }

            public uint MaxFieldOrdinal
            {
                get
                {
                    return _maxFieldOrdinal;
                }
                set
                {
                    // The manifest may specify more fields, and this will help 
                    // ToString().
                    _maxFieldOrdinal = value;
                }
            }

            public uint[] SpecialFieldOrdinals
            {
                get 
                {
                    // @@@ if only we had Linq, we could just do 
                    // _specialFieldOrdinals.ToArray();
                    var list = new List<uint>();
                    foreach (uint i in _specialFieldOrdinals)
                    {
                        list.Add(i);
                    }
                    return list.ToArray();
                }
            }

            public VortexFieldCollection()
            {
                _fieldValues = new Dictionary<uint, object>(16); // rough guess of size
                _specialFieldOrdinals = new HashSet<uint>();
                _maxFieldOrdinal = 0;
            }

            public VortexFieldCollection Clone()
            {
                VortexFieldCollection result = new VortexFieldCollection();

                foreach (var field in _fieldValues)
                {
                    result._fieldValues.Add(field.Key, field.Value);
                }

                foreach (var item in _specialFieldOrdinals)
                {
                    result._specialFieldOrdinals.Add(item);
                }

                result._maxFieldOrdinal = _maxFieldOrdinal;

                return result;
            }

            public void AddField(uint fieldOrdinal, object fieldValue)
            {
                _fieldValues[fieldOrdinal] = fieldValue;
                if (fieldValue is SpecialField)
                {
                    _specialFieldOrdinals.Add(fieldOrdinal);
                }
                _maxFieldOrdinal = Math.Max(fieldOrdinal, _maxFieldOrdinal);
            }

            public void AddField(uint fieldType, uint fieldOrdinal, object fieldValue)
            {
                _fieldValues[fieldOrdinal] = fieldValue;
                if (fieldType == (uint)VxProtocol.VxFieldType.Special)
                {
                    _specialFieldOrdinals.Add(fieldOrdinal);
                }
                _maxFieldOrdinal = Math.Max(fieldOrdinal, _maxFieldOrdinal);
            }

            public void RemoveField(uint fieldOrdinalRemove, bool fShift)
            {
                if (!_fieldValues.ContainsKey(fieldOrdinalRemove))
                {
                    return;
                }

                // Build new dictionaries, since we may have to shift all the keys anyway 
                // or we may have removed the max ordinal. This is easier.
                Dictionary<uint, object> oldFieldValues = _fieldValues;
                uint oldMaxFieldOrdinal = _maxFieldOrdinal;

                _fieldValues = new Dictionary<uint, object>(oldFieldValues.Count);
                _specialFieldOrdinals = new HashSet<uint>();
                _maxFieldOrdinal = 0;

                uint shiftVal = 0;
                for (uint fieldId = 1; fieldId <= oldMaxFieldOrdinal; fieldId++)
                {
                    if (fieldId == fieldOrdinalRemove)
                    {
                        // This is the field we're removing
                        if (fShift)
                        {
                            shiftVal = 1;
                        }
                    }
                    else
                    {
                        uint newOrdinal = (uint)(fieldId - shiftVal);

                        object v;
                        if (!oldFieldValues.TryGetValue(fieldId, out v))
                            continue;

                        AddField(newOrdinal, v);
                    }
                }
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder(500);
                string sep = "";

                // Fields start at 1, not 0. We need to fill missing fields with the 
                // separator.
                // We also cap the max number of fields to 256 when converting to a 
                // string.
                uint maxFields = Math.Min(VxEvent.c_MaxFieldOrdinal, MaxFieldOrdinal);
                for (uint fieldId = 1; fieldId <= maxFields; fieldId++)
                {

                    sb.Append(sep);
                    sep = "|";

                    object v;
                    if (!_fieldValues.TryGetValue(fieldId, out v))
                        continue;

                    if (v is SpecialField)
                    {
                        v = ((SpecialField)v).Value;
                    }

                    if (v == null)
                        continue;
                    else if (v is ulong)
                        sb.Append(((ulong)v).ToString("X"));
                    else if (v is uint)
                        sb.Append(((uint)v).ToString("X"));
                    else if (v is ushort)
                        sb.Append(((ushort)v).ToString("X"));
                    else if (v is byte)
                        sb.Append(((byte)v).ToString("X"));
                    else if (v is byte[])
                        sb.Append(((Blob)(byte[])v).ToString());
                    else if (v is DateTime)
                        sb.Append(XDateTime.ToString((DateTime)v));
                    else
                    {
                        // Everything else is fine in its native format (right?)
                        sb.Append(v.ToString());
                    }
                }
                return sb.ToString();
            }

            public void WriteStream(VortexBinaryWriter bw)
            {
                // No ordering guarantees, don't do anything for "missing" ordinals, of 
                // course.
                foreach (var kvp in _fieldValues)
                {
                    bw.WriteVxField(kvp.Key, kvp.Value);
                }
            }

            // Generic accessor where you don't know the specific type, you just want the 
            // generic version. This will always return one of the following types:
            // * ulong
            // * long
            // * byte[]
            // * float
            // * double
            // * string
            // * SpecialField
            //

            public object GetField(uint fieldId)
            {
                object val;
                if (!_fieldValues.TryGetValue(fieldId, out val))
                {
                    throw new IndexOutOfRangeException("Field " + fieldId + " not found.");
                }
                return val;
            }

            public bool TryGetField(uint fieldId, out object val)
            {
                return _fieldValues.TryGetValue(fieldId, out val);
            }

            // These accessors are for when you know the specific type and want to read 
            // it.
            public ushort GetUInt16(uint fieldId)
            {
                return (ushort)(ulong)GetField(fieldId);
            }

            public uint GetUInt32(uint fieldId)
            {
                return (uint)(ulong)GetField(fieldId);
            }

            public ulong GetUInt64(uint fieldId)
            {
                return (ulong)GetField(fieldId);
            }

            public short GetInt16(uint fieldId)
            {
                return (short)(long)GetField(fieldId);
            }

            public int GetInt32(uint fieldId)
            {
                return (int)(long)GetField(fieldId); 
            }

            public long GetInt64(uint fieldId)
            {
                return (long)(long)GetField(fieldId);
            }

            public sbyte GetSByte(uint fieldId)
            {
                return (sbyte)(long)GetField(fieldId);
            }

            public byte GetByte(uint fieldId)
            {
                return (byte)(ulong)GetField(fieldId);
            }

            public float GetSingle(uint fieldId)
            {
                return (float)GetField(fieldId);
            }

            public double GetDouble(uint fieldId)
            {
                return (double)GetField(fieldId);
            }

            public byte[] GetBytes(uint fieldId)
            {
                return (byte[])GetField(fieldId);
            }

            public string GetString(uint fieldId)
            {
                return (string)GetField(fieldId);
            }

            public SpecialField GetSpecialField(uint fieldId)
            {
                return (SpecialField)GetField(fieldId);
            }

            // Some helper accessors, but not strictly necessary

            public Guid GetGuid(uint fieldId)
            {
                byte[] buf = (byte[])GetField(fieldId);
                return new Guid(buf);
            }

            public DateTime GetDateTime(uint fieldId)
            {
                long ft = (long)GetUInt64(fieldId);
                return DateTime.FromFileTimeUtc(ft);
            }
        }

    }

    // ------------------------------------------------------------------------------
    // class SpecialField
    //
    // ------------------------------------------------------------------------------
    public class SpecialField
    {
        public uint Id;
        public object Value;
    }

    // ----------------------------------------------------------------------------------
    // VxProtocol
    //
    // Main entry point for reading a binary Vortex protocol message. Right now, it 
    // assumes you want a generic representation of the events in the message with 
    // random-access to the individual fields by ordinal.
    // ----------------------------------------------------------------------------------
    public class VxProtocol
    {
        public const int c_FieldTypeShift = 3;
        public const int c_FieldTypeMask = (1 << c_FieldTypeShift) - 1;

        public enum VxProtocolType : byte
        {
            Etx = 1
        };

        // Only get 3 bits for this value in the protocol
        public enum VxFieldType : uint
        {
            Terminator = 0,
            VarInt = 1,
            Blob = 2,
            Single = 3,
            Double = 4,
            String = 5,
            SVarInt = 6,
            Special = 7,
        };

        public enum VxSpecialFieldTypeId : uint
        {
            VortexDeletedField = 1,    // Vortex should delete this field and shift ordinals
        }

        public static List<VxEvent> ReadStream(Stream inStream)
        {
            VortexBinaryReader br = new VortexBinaryReader(inStream);

            byte protocolType = br.ReadByte();
            switch (protocolType)
            {
                case (byte)VxProtocolType.Etx:
                    return ReadEtxStream(br);
                default:
                    throw new InvalidOperationException("Unrecognized protocol type " + protocolType);
            }
        }

        private static List<VxEvent> ReadEtxStream(VortexBinaryReader inStream)
        {
            // @@@ fixed or varint?
            long timestampBase = inStream.ReadInt64();

            List<VxEvent> eventList = new List<VxEvent>();
            try
            {
                // Give it a default value
                Blob lastProducerId = new Blob();

                // Note: instream.BaseStream.Position is supported for MemoryStreams, but 
                // not supported for HttpRequestStreams. Boo! So I guess we just have to 
                // read until an EndOfStreamException?

                if (inStream.BaseStream.CanSeek)
                {
                    while (inStream.BaseStream.Position < inStream.BaseStream.Length)
                    {
                        // @@@ Note: if we implement special fields that span multiple events
                        // then we'll need to store that knowledge and pass it to future events.
                        var msg = new VxEvent(inStream, lastProducerId, timestampBase);
                        lastProducerId = msg.ProducerId;
                        eventList.Add(msg);
                    }
                }
                else
                {
                    // wait for the exception...
                    while (true)
                    {
                        // @@@ Note: if we implement special fields that span multiple events
                        // then we'll need to store that knowledge and pass it to future events.
                        var msg = new VxEvent(inStream, lastProducerId, timestampBase);
                        lastProducerId = msg.ProducerId;
                        eventList.Add(msg);
                    }
                }

            }
            catch (EndOfStreamException)
            {
                // walked off end. any way to tell caller this but still return a valid 
                // list?
                if (eventList.Count == 0)
                    throw;
            }

            return eventList;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\UsageProt.cs ===
using STF.common.service;

namespace STF.common.protocol
{
    public class UsageDefs
    {
        public const ushort USAGE_QUERY_BY_ATTRIBUTES_SORT_BY_DATE = 0xFFFF;

        public const ushort USAGE_SOURCE_XBOX = 1;
        public const ushort USAGE_SOURCE_ZUNE = 2;
        
        public const ushort USAGE_ATTRIBUTE_MIN = 1;
        public const ushort USAGE_ATTRIBUTE_PLAYCOUNT = 1;
        public const ushort USAGE_ATTRIBUTE_DOWNLOADCOUNT = 2;
        public const ushort USAGE_ATTRIBUTE_PURCHASECOUNT = 3;
        public const ushort USAGE_ATTRIBUTE_RATING = 4;
        public const ushort USAGE_ATTRIBUTE_STREAMCOUNT = 5;
        public const ushort USAGE_ATTRIBUTE_SENDCOUNT = 6;
        public const ushort USAGE_ATTRIBUTE_COMMENTCOUNT = 7;
        public const ushort USAGE_ATTRIBUTE_SKIPCOUNT = 8;
        public const ushort USAGE_ATTRIBUTE_AD_PLAYCOUNT = 9;
        public const ushort USAGE_ATTRIBUTE_PERCENTAGE_VIEWED = 10;
        public const ushort USAGE_ATTRIBUTE_MAX = 10;

        public static bool IsAggregateAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_PLAYCOUNT:
            case USAGE_ATTRIBUTE_DOWNLOADCOUNT:
            case USAGE_ATTRIBUTE_PURCHASECOUNT:
            case USAGE_ATTRIBUTE_STREAMCOUNT:
            case USAGE_ATTRIBUTE_SENDCOUNT:
            case USAGE_ATTRIBUTE_COMMENTCOUNT:
            case USAGE_ATTRIBUTE_SKIPCOUNT:
            case USAGE_ATTRIBUTE_AD_PLAYCOUNT:
                return true;
            default:
                return false;
            }
        }

        public static bool IsReplaceAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_RATING:
            case USAGE_ATTRIBUTE_PERCENTAGE_VIEWED:
                return true;
            default:
                return false;
            }
        }

        public static bool IsIntegerValueAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_PLAYCOUNT:
            case USAGE_ATTRIBUTE_DOWNLOADCOUNT:
            case USAGE_ATTRIBUTE_PURCHASECOUNT:
            case USAGE_ATTRIBUTE_STREAMCOUNT:
            case USAGE_ATTRIBUTE_SENDCOUNT:
            case USAGE_ATTRIBUTE_COMMENTCOUNT:
            case USAGE_ATTRIBUTE_SKIPCOUNT:
            case USAGE_ATTRIBUTE_RATING:
            case USAGE_ATTRIBUTE_AD_PLAYCOUNT:
            case USAGE_ATTRIBUTE_PERCENTAGE_VIEWED:
                return true;
            default:
                return false;            
            }
        }

        public static bool IsBinaryValueAttribute(ushort attribute)
        {
            switch (attribute)
            {
            default:
                return false;
            }
        }
    }

    public class UsageStoreRequest : XRLObject2
    {
        public uint XMLSize;

        [WireInfo(SizeParam="XMLSize")]
        public string XML;

        public override string Xrl
        {
            get
            {
                return "/xstats/usagestore.ashx";
            }
        }
    }

    public class UsageStoreResponse : XRLObject2
    {
        public HResult hr;
    }

/*
    public class UsageQueryByAttributes : XRLObject2
    {
        public ulong userID;
        public ushort numAttributes;
        public ushort iSortAttribute; 
        public uint offsetResults;
        public uint maxResults;

        [WireInfo(SizeParam="numAttributes")]
        public int[] attributes;

        public string GetXRL()
        {
            return "/xstats/usagequerybyattributes.ashx";
        }
    }

    public class UsageQueryByAttributesResponse : XRLObject2
    {
        public HResult hr;
        public uint numResults;

        [WireInfo(SizeParam="numResults")]
        public UsageQueryByAttributesResponseData[] results;
    }

    public class UsageQueryByAttributesResponseData : WireData
    {
        public byte[] mediaInstanceId;
        public ushort numAttributes;

        [WireInfo(SizeParam="numAttributes")]
        public UsageAttributeData[] attributes;
    }

    public class UsageAttributeData : WireData
    {
        public ushort attributeId;
        public int attributeIntData;

        public uint attributeBinarySize;

        [WireInfo(SizeParam="attributeBinarySize")]
        public byte[] attributeBinaryData;
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\VirtualInterfaceInfo.cs ===
using System;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(false)]
public class VirtualInterfaceInfo : ConfigEventLogger, IVirtualInterfaceInfo
{
    private string _virtualInterface = STF.common.config.VirtualInterface.None;
    private string _interface = STF.common.config.Interface.None;
    private string _protocol = null;
    private string _ipAddress = null;
    private IPAddress _resolvedIp = null;
    private int _port = 0;
    private int _portEnd = 0;
    private string _vdir = null;
    private string _webstoreApp = null;
    private int _timeout = 0;
    private int _serviceId = 0; // 0 correpsonds to invalid service in another enum somewhere...
    private string _serviceName = null;
    private bool _needSGInfo = false;
    private int _internetPort = 0;
    private int _internetPortEnd = 0;
    private string _info1 = null;
    private string _info2 = null;
    private int? _minConnectionPoolSize = null;
    private int? _maxConnectionPoolSize = null;
    private int? _loadBalanceTimeout = null;
    private int? _connectionTimeout = null;
    private string _healthCheckUrl = null;
    private Dictionary<string,string> _notificationUrls = null;
    private object _notificationLock = new object();

    public override string ToString()
    {
        return "{{"
            +_virtualInterface.ToString()+","
            +_interface.ToString()+","
            +(_protocol == null ? "<null>" : _protocol)+","
            +(_ipAddress ?? "<null>")+","
            +_port.ToString()+","
            +_portEnd.ToString()+","
            +(_vdir== null ? "<null>" : _vdir)+","
            +(_webstoreApp== null ? "<null>" : _webstoreApp)+","
            +_timeout.ToString()+","
            +_serviceId.ToString()+","
            +(_serviceName== null ? "<null>" : _serviceName)+","
            +_needSGInfo.ToString()+","
            +_internetPort.ToString()+","
            +_internetPortEnd.ToString()+","
            +(_info1== null ? "<null>" : _info1)+","
            +(_info2== null ? "<null>" : _info2)+","
            +(_minConnectionPoolSize==null ? "<null>" : _minConnectionPoolSize.ToString())+","
            +(_maxConnectionPoolSize==null ? "<null>" : _maxConnectionPoolSize.ToString())+","
            +(_loadBalanceTimeout==null ? "<null>" : _loadBalanceTimeout.ToString())+","
            +(_connectionTimeout==null ? "<null>" : _connectionTimeout.ToString())+","
            +(_notificationUrls==null ? "<null>" : 
              "[" + string.Join(";", _notificationUrls.Select( u => u.Key + ":" + u.Value ).ToArray() ) +"]")
            +"}}";
    }

    public string VirtualInterface
    {
        get { return _virtualInterface; }
        set { _virtualInterface = value; }
    }

    public string Interface
    {
        get { return _interface; }
        set { _interface = value; }
    }

    public string Protocol
    {
        get { return _protocol; }
        set { _protocol = value; }
    }

//    [Obsolete]
    public IPAddress IPAddress
    {
        get
        {
            if (_resolvedIp == null)
            {
                foreach (IPAddress ip in Dns.GetHostAddresses(_ipAddress))
                {
                    if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                    {
                        _resolvedIp = ip;
                    }
                }
                //_resolvedIp = Dns.GetHostAddresses(_ipAddress)
                //                .FirstOrDefault(ip => ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);
            }
            return _resolvedIp;
        }
        set { _ipAddress = value.ToString(); _resolvedIp = value; }
    }

    public string IPAddressString
    {
        get { return _ipAddress == null? null : _ipAddress.ToString(); }
        set { _ipAddress = value; _resolvedIp = null; }
    }

//    [Obsolete]
    public uint IPAddressDword
    {
#pragma warning disable 612
        get { return String.IsNullOrEmpty(_ipAddress) ? 0 : ConfigUtil.IpAddressToDword( IPAddress ); }
#pragma warning restore 612
    }

    public int Port
    {
        get { return _port; }
        set { _port = value; }
    }

    public int PortEnd
    {
        get { return _portEnd; }
        set { _portEnd = value; }
    }

    public string VDir
    {
        get { return _vdir; }
        set { _vdir = value; }
    }

    public int Timeout
    {
        get { return (_connectionTimeout ?? _timeout); }
        set { _timeout = value; }
    }

    public string WebstoreApp
    {
        get { return _webstoreApp; }
        set { _webstoreApp = value; }
    }

    public int ServiceId
    {
        get { return _serviceId; }
        set { _serviceId = value; }
    }

    public string ServiceName
    {
        get { return _serviceName; }
        set { _serviceName = value; }
    }

    public bool NeedSGInfo
    {
        get { return _needSGInfo; }
        set { _needSGInfo = value; }
    }

    public int InternetPort
    {
        get { return _internetPort; }
        set { _internetPort = value; }
    }

    public int InternetPortEnd
    {
        get { return _internetPortEnd; }
        set { _internetPortEnd = value; }
    }

    public string Info1
    {
        get { return _info1; }
        set { _info1 = value; }
    }

    public string Info2
    {
        get { return _info2; }
        set { _info2 = value; }
    }

    public int? MinConnectionPoolSize
    {
        get { return _minConnectionPoolSize; }
        set { _minConnectionPoolSize = value; }
    }

    public int? MaxConnectionPoolSize
    {
        get { return _maxConnectionPoolSize; }
        set { _maxConnectionPoolSize = value; }
    }

    public int? LoadBalanceTimeout
    {
        get { return _loadBalanceTimeout; }
        set { _loadBalanceTimeout = value; }
    }

    public int? ConnectionTimeout
    {
        get { return _connectionTimeout; }
        set { _connectionTimeout = value; }
    }

    public Uri Url
    {
        get
        {
            if (Protocol == null || IPAddressString == null)
            {
                return null;
            }

            UriBuilder b = new UriBuilder();
            b.Scheme = Protocol;
            b.Host = IPAddressString;

            // Port == 0 means port was not specified, so leave it out
            // of the Uri
            if (Port != 0)
            {
                b.Port = Port;
            }

            return b.Uri;
        }
    }

    public string GetNotificationUrl(string notification)
    {
        if (_notificationUrls == null || String.IsNullOrEmpty(notification))
        {
            return null;
        }
        notification = notification.ToLower();

        lock( _notificationLock )
        {
            string value = null;

            _notificationUrls.TryGetValue(notification, out value);
            return value;
        }
    }

    public void AddNotificationUrl(string notification, string url)
    {
        if (String.IsNullOrEmpty(notification) == true)
        {
            return;
        }
        notification = notification.ToLower();

        lock( _notificationLock )
        {
            if (_notificationUrls == null)
            {
                _notificationUrls = new Dictionary<string,string>();
            }
            _notificationUrls[notification] = url;
        }
    }

    public string[] NotificationUrls
    {
        get
        {
            lock( _notificationLock )
            {
                if (_notificationUrls == null)
                {
                    return new string[0];
                }
                return _notificationUrls.Keys.ToArray();
            }
        }
    }

    public string HealthCheckUrl
    {
        get { return _healthCheckUrl; }
        set { _healthCheckUrl = value; }
    }

    public string SqlConnectionString
    {
        get
        {
            // only makes sense if the protocol is sql
            if (Protocol == null || Protocol != "sql")
            {
                string message = String.Format(
                    "VirtualInterfaceInfo.SqlConnectionString: VirtualInterface {0} does not have a Protocol of 'sql'.",
                    VirtualInterface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_240);
                throw ae;
            }

            // need an IPAddress
            if (String.IsNullOrEmpty(IPAddressString))
            {
                string message = String.Format(
                    "VirtualInterfaceInfo.SqlConnectionString: VirtualInterface {0} does not have a valid address.",
                    VirtualInterface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_241);
                throw ae;
            }

            // need a DBName
            if ((WebstoreApp == null) || (WebstoreApp.Length == 0))
            {
                string message = String.Format(
                    "VirtualInterfaceInfo.SqlConnectionString: VirtualInterface {0} does not have a database name specified.",
                    VirtualInterface.ToString());

                ApplicationException ae = new ApplicationException(message);
                LogNtEvent("XblConfig", message + "\r\n\r\n" + System.Environment.StackTrace, ConfigEvent.Id.COMMON_CONFIG_242);
                throw ae;
            }

            SqlConnectionStringBuilder  scsb = new SqlConnectionStringBuilder();

            scsb.DataSource = IPAddressString;
            scsb.InitialCatalog = WebstoreApp;
            scsb.IntegratedSecurity=true;
            scsb.ApplicationName = Config.ComponentName;

            // Calculate the timeout of the connection. The value in NPDB is
            // stored in millisecs, but seconds is needed for the builder
            scsb.ConnectTimeout = Timeout / 1000;

            // Calculate the load balance timeout. The value in NPDB is
            // stored in millisecs, but seconds is needed for the builder
            int loadBalanceTimeout = 0;
            if (_loadBalanceTimeout != null)
            {
                loadBalanceTimeout = _loadBalanceTimeout.Value / 1000;
            }
            else if ((Info1 != null) && (Info1.Length > 0))
            {
                loadBalanceTimeout = (int.Parse(Info1)) / 1000;
            }
            if (loadBalanceTimeout > 0)
            {
                scsb.LoadBalanceTimeout = loadBalanceTimeout;
            }

            // optional fields
            if (_minConnectionPoolSize != null)
            {
                scsb.MinPoolSize = _minConnectionPoolSize.Value;
            }
            if (_maxConnectionPoolSize != null)
            {
                scsb.MaxPoolSize = _maxConnectionPoolSize.Value;
            }

            return scsb.ToString();
        }
    }

}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\websvcprot.cs ===
/*==========================================================================
 *
 *  WebSvcProt.cs -- This module defines the wire protocol for Web Service Methods
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Xml;

using STF.common.service;


namespace STF.common.protocol
{
    public class WebServiceNameValuePair : WireData
    {
        public string name;
        public string value;

        public WebServiceNameValuePair(string name, string value)
        {
            this.name = name;
            this.value = value;
        }

        internal WebServiceNameValuePair(string pair)
        {
            string[] vals = pair.Split('=');

            name = HttpUtility.UrlDecode(vals[0]);
            value = HttpUtility.UrlDecode(vals[1]);
        }

        public override void WriteStream(BinaryWriter bw)
        {
            if (!String.IsNullOrEmpty(name))
            {
                bw.Write(Encoding.UTF8.GetBytes(HttpUtility.UrlEncode(name)));
                bw.Write((byte)61); // converted '=' character
                if (!String.IsNullOrEmpty(value))
                {
                    bw.Write(Encoding.UTF8.GetBytes(HttpUtility.UrlEncode(value)));
                }
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            throw new NotImplementedException();
        }

        public override string ToString()
        {
            return String.Concat("[", name, "], [", value, "]");
        }
    }

    public class LivecacheWebSvcRequest : XRLObject2
    {
        protected List<WebServiceNameValuePair> pairs = new List<WebServiceNameValuePair>();

        public override void WriteStream(BinaryWriter bw)
        {
            if (pairs != null)
            {
                for (int i = 0; i < pairs.Count - 1; i++)
                {
                    pairs[i].WriteStream(bw);
                    bw.Write((byte)38); // converted '&' character
                }

                // Write the last remaining entry without the extra '&' character
                pairs[pairs.Count-1].WriteStream(bw);
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            byte[] buf = null;

            buf = br.ReadBytes(1024);
            while (buf != null && buf.Length>0 )
            {
                string s = Encoding.UTF8.GetString(buf);
                string[] nv = s.Split('&');

                for (int i = 0; i < nv.Length - 1; i ++)
                {
                    pairs.Add(new WebServiceNameValuePair(nv[i]));
                }

                byte[] buf2 = br.ReadBytes(1024);
                if (buf2.Length > 0)
                {
                    int offset = s.LastIndexOf('&') + 1;
                    // -1 works, because that mean the entire buffer needs to be copied over
                    byte[] bufNew = new byte[buf2.Length + buf.Length - offset];

                    Array.ConstrainedCopy(buf, offset, bufNew, 0, buf.Length - offset);
                    Array.ConstrainedCopy(buf2, 0, bufNew, buf.Length - offset, buf2.Length);
                    buf = bufNew;
                }
                else
                {
                    // This is the complete last entry, just add it to the list
                    pairs.Add(new WebServiceNameValuePair(nv[nv.Length - 1]));
                    buf = null;
                }
            }

            return this;
        }

        public List<WebServiceNameValuePair> NameValuePairs
        {
            get { return pairs; }
        }

        public override string ContentType
        {
            get { return "application/x-www-form-urlencoded"; }
        }
    }

    public class LiveCacheWebSvcResponse : XRLObject2
    {
        public string response;

        public override WireData ReadStream(BinaryReader br)
        {
            return ReadStream(br.BaseStream);
        }

        public override WireData ReadStream(Stream s)
        {
            XmlTextReader reader = new XmlTextReader(s);

            reader.MoveToContent();
            response = reader.ReadOuterXml();

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            throw new NotImplementedException();
        }
    }

    public class LiveCacheWebHeaderCollection : LivecacheWebSvcRequest
    {
        /// <summary>
        /// Returns UT8 encoded string representation of the class
        /// </summary>
        /// <returns>UTF8 encoded string.</returns>
        public string GetEncodedString()
        {
            string returnString = Encoding.UTF8.GetString(base.ToArray());

            return returnString;
        }

        /// <summary>
        /// Constructs the object from the string.
        /// </summary>
        /// <param name="value">UTF8 encoded string value</param>
        /// <returns></returns>
        public WireData LoadFromString(string value)
        {
            byte[] byteArray = Encoding.UTF8.GetBytes(value);

            MemoryStream stream = new MemoryStream(byteArray);

            return base.ReadStream(new BinaryReader(stream));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\UacsProtocol.cs ===
using System;

using STF.common.service;
using STF.core.wiredata;

namespace STF.common.protocol
{
    public class AcceptTermsOfUseRequest : XRLObject2
    {
        public ulong userPuid = 0;

        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/AcceptTou.ashx"; }
        }
    }


    public class ChangeGamertagRequest : XRLObject2
    {
        public ulong machinePuid     = 0;

        public ulong userPuid        = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag       = "";

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/ChangeGamertag.ashx"; }
        }
    }

    public class ChangeGamertagResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key  = null;    // new key
    }


    public class ClearSubscriptionsRequest : XRLObject2
    {
        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/ClearSubscriptions.ashx"; }
        }
    }

    public class EnumerateEligibleRequest : XRLObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public uint        rating;

        public DateTime    lastChangedDate = DateTime.Now;

        public uint        offeringType;

        public uint        bitFilter;

        public uint        descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort      languageId;

        public ushort      voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string      voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/EnumerateEligible.ashx"; }
        }
    }

    public class GetANIDRequest : XRLObject2
    {
        public ulong userXuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetANID.ashx"; }
        }
    }

    public class GetANIDResponse : XRLObject2
    {
        public ushort AnidLength;

        [WireInfo(SizeParam = "AnidLength")]
        public string userAnid;

        public HResult anidHr;
    }

    public class GetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize = XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetPaymentInfo.ashx"; }
        }
    }

    public class GetPaymentInfoResponse : XRLObject2
    {
        public byte countryId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;
    }

    public class GetPostalCodeRequest : XRLObject2
    {
        public byte countryId = 0;

        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetPostalCode.ashx"; }
        }
    }

    public class GetPostalCodeResponse : XRLObject2
    {
        public byte matchCount;

        [WireInfo(SizeParam="matchCount")]
        public PostalCodeMatch[] match;
    }

    public class PostalCodeMatch : WireData
    {
        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        public ushort provinceLength = 0;

        [WireInfo(SizeParam="provinceLength")]
        public string province = String.Empty;

        public ushort cityLength = 0;

        [WireInfo(SizeParam="cityLength")]
        public string city = String.Empty;

        public ushort streetLength = 0;

        [WireInfo(SizeParam="streetLength")]
        public string street = String.Empty;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateAccountRequest : XRLObject2, ICreateAccountRequest
    {
        public ulong machinePuid;

        public uint titleId;

        public DateTime birthdate;

        public byte msSpam;

        public byte partnerSpam;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort activationCodeLength;

        [WireInfo(SizeParam="activationCodeLength")]
        public string activationCode;

        [WireInfo(Serialize=false)]
        public string countryCode;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/CreateOwnerAcct.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get
            {
                PhoneInfoData pi = new PhoneInfoData();
                pi.phonePrefix = phonePrefix;
                pi.phoneNumber = phoneNumber;
                pi.phoneExtension = phoneExtension;
                return pi;
            }
        }
        public AddressInfoData AddressInfo
        {
            get
            {
                AddressInfoData ai = new AddressInfoData();
                ai.street1 = street1;
                ai.street2 = street2;
                ai.city = city;
                ai.district = district;
                ai.state = state;
                ai.postalCode = postalCode;
                return ai;
            }
        }
        public byte PaymentInstrumentType
        {
            get { return (byte) 1; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get
            {
                CreditCardInfoData cci = new CreditCardInfoData();
                cci.accountHolderName = cardHolder;
                cci.accountNumber = cardNumber;
                cci.cardType = cardTypeId;
                cci.expirationDate = cardExpiration;
                return cci;
            }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msSpam; }
        }
        public byte PartnerOptIn
        {
            get { return partnerSpam; }
        }
    }

    public class CreateAccountResponse : XRLObject2
    {
        public ulong puid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    public class GetSubscriptionInfoRequest : XRLObject2
    {
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionInfo.ashx"; }
        }
    }

    public class GetSubscriptionInfoResponse : XRLObject2
    {
        public byte subscriptionLengthInMonths;

        public uint paymentTypeId;
    }

    public class GetSubscriptionStatusRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public uint  serviceId;

        public uint  languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusResponse : XRLObject2
    {
        public ulong currentOfferId;

        public byte  currentOfferStatus;

        public byte  anniversaryDate;

        public DateTime startDate;

        public DateTime endDate;

        public uint  renewalGracePeriod;

        public byte  renewalStatus;

        public ulong renewalOfferId;

        //
        // + Details object for current offer
        //
        public GetSubscriptionStatusDetailsData currentOfferDetails;

        //
        // + Details object for renewal offer if applicable
        //

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusDetailsData : XRLObject2
    {
        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string ISOCode;

        public uint   offeringDetails;
    }

    // requests that contain account recovery type information should
    // implement this so the common comparison routine can be used.
    public interface IRecoveryRequest
    {
        string PostalCode { get; }
        string PhonePrefix { get; }
        string PhoneNumber { get; }
        string PhoneExtension { get; }
        string CardHolder { get; }
        string CardNumber { get; }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class LinkWebAccountRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(Min=1)]
        public uint credentialType;

        [WireInfo(Min=1, Max=128)] // TODO: fix the max value
        public ushort webIdLen;

        [WireInfo(SizeParam="webIdLen")]
        public byte[] webId;

        public byte webIdIsOwner;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/LinkWebAccount.ashx"; }
        }
    }

    public class LinkWebAccountResponse : XRLObject2
    {
        public ulong userPuid;

        public ulong ownerPuid;

        public ulong oldUserWebPuid;

        public ulong oldOwnerWebPuid;
    }

    public class RenewSubscriptionRequest : XRLObject2
    {
        public ulong    userPuid;

        public ulong    machinePuid;

        public uint     titleId;

        public ulong    offerId;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort   voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string   voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/RenewSubscription.ashx"; }
        }
    }

    public class ReserveNameRequest : XRLObject2
    {
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get { return "/xuacs/ReserveName.ashx"; }
        }
    }

    public class ReserveNameSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class ReserveNameResponse : XRLObject2
    {
        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public ReserveNameSuggestedName[] names;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class RestoreAccountRequest : XRLObject2, IRecoveryRequest
    {
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/RestoreAccount.ashx"; }
        }
    }

    public class RestoreAccountResponse : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class SetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        public byte countryId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetPaymentInfo.ashx"; }
        }
    }

    public class SetUserAccountStatusRequest : XRLObject2
    {
        public ulong puid           = 0;

        public int newTermsOfService = 0;

        public int forceNameChangeRequired = 0;

        public DateTime suspendedUntil = DateTime.Now;

        public ushort totalDaysSuspended = 0;

        public DateTime voiceBannedUntil = DateTime.Now;

        public ushort totalDaysVoiceBanned = 0;

        public uint billingAccountStatus = 0;

        public uint resetPassword = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserAccountStatus.ashx"; }
        }
    }

    public class TroubleshootAccountRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/TroubleshootAccount.ashx"; }
        }
    }

    public class TroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public HResult billingHR;
    }

    public class VerifyBillingPinRequest : XRLObject2
    {
        public ulong  userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/VerifyBillingPIN.ashx"; }
        }
    }

    public class VerifyVoucherRequest : XRLObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/VerifyVoucherGetOffer.ashx"; }
        }
    }

    public class VerifyVoucherResponse : XRLObject2
    {
        public ulong offerId;
    }

    public class SetUserSettingsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   userFlags          =0;        // the new user flags

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserSettings.ashx"; }
        }
    }

    public class SetUserSettings2Request : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   tier               =0;        // the new tier of the user

        public ushort   userFlags          =0;        // the new user flags

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userPrivileges;               // the new user privileges

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserSettings2.ashx"; }
        }
    }

    public class XeGetPointsBalanceRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/xuacs/XeGetPointsBalance.ashx";
            }
        }
    }

    public class XeGetPointsBalanceResponse : XRLObject2WithFlags
    {
        static byte AboveLowBalance             = 0x01;

        public XeGetPointsBalanceResponse()
        {
            responseFlags = 0;
        }

        public uint pointsBalance;

        public byte dmpAccountStatus;

        public byte responseFlags; // aboveLowBalance

        public bool aboveLowBalance
        {
            get
            {
                return IsFlagSet(AboveLowBalance, responseFlags);
            }
            set
            {
                SetFlag(AboveLowBalance, value, ref responseFlags);
            }
        }
    }

    public class PassportToken : WireData
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;   // Passport session ticket.

        public static implicit operator byte[] (PassportToken value)
        {
            return value.signedPuid;
        }

        public static implicit operator PassportToken(byte[] value)
        {
            PassportToken t = new PassportToken();
            t.signedPuid = value;
            return t;
        }
    }

    public class UpdateParentalControlsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userRestrictPrivileges;               // the user restricted privileges

        [WireInfo(Min=1, Max=XOn.XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH*XOn.UTF8_MULT)]
        public ushort sourceLength = 0;

        [WireInfo(SizeParam="sourceLength", NullTerminate=true)]
        public string source;

        [WireInfo(MinSchemaVersion = "6.3")]
        public ushort tokenLength = 0;

        [WireInfo(MinSchemaVersion = "6.3", SizeParam = "tokenLength", NullTerminate = false)]
        public PassportToken[] tokens = null;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint setProfilePermissionEntries = 0;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint clearProfilePermissionEntries = 0;
        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUpdateParentalControls.ashx"; }
        }
    }

    public class GetParentalControlsRequest : XRLObject2
    {
        public Puid requestorPuid = 0;    // user making the request.

        public Puid userPuid = 0;        // user we're talking about.

        public override string Xrl
        {
            get { return "/xuacs/GetParentalControls.ashx"; }
        }
    }

    public class GetParentalControlsResponse : XRLObject2
    {
        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userRestrictPrivileges;               // the user restricted privileges
    }

    public class GetUserBillingNotificationsRequest : XRLObject2
    {
        public const byte FlagUnreadNotifications   = 0x0001; // set bit 0 for notifications with read flag to be returned
        public const byte FlagTransientNotification = 0x0002; // set bit 1 for notification to be treated as unread until expiration date

        [WireInfo(HexString=true)]
        public       ulong    userPuid;         // userid to read notifications for

        public       byte     flags;            // Set bit 0 for all messages

        public       DateTime notificationDate; // notifications before this date

        public override string Xrl
        {
            get { return "/xuacs/GetUserBillingNotifications.ashx"; }
        }
    }

    public class UserBillingNotification : WireData
    {
        public const int      notificationIdSubscriptionExpiration = 10020;
        public const int      notificationIdCreditCardDecline      = 20010;

        public       DateTime notificationDate = DateTime.MinValue; // Date of arrival

        public       int      isReadNotification = 0;

        // Protocol only supports
        public       int      notificationId = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      creditCardType = 0; // maps to XONLINE_CREDIT_CARD_TYPE in xondefs.h

        // Valid for notificationId = CreditCardDecline only
        public       ushort   accountNumberLastFour = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      declineReasonId = 0; // maps to XONLINE_CREDIT_CARD_DECLINE_TYPE in xondefs.h

        // Valid for notificationId = SubscriptionExpiration
        public       DateTime subscriptionExpirationDate;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2")]
        public       bool     subscriptionIsTrial;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2", HexString=true)]
        public       uint     subscriptionTitleId;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2")]
        public       Guid     subscriptionOfferId;
    }

    public class GetUserBillingNotificationsResponse : XRLObject2
    {
        public const int      MAX_COUNT = 10;

        [WireInfo(Max=MAX_COUNT)]
        public ushort userBillingNotificationsCount;

        [WireInfo(SizeParam="userBillingNotificationsCount")]
        public UserBillingNotification[] userBillingNotifications;
    }

    public class XeGetUserSubscriptionDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public ushort instanceIdLength = 0;

        [WireInfo(SizeParam="instanceIdLength")]
        public string instanceId = "";

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserSubscriptionDetails.ashx"; }
        }
    }

    public class UserSubscriptionDetailsData : XRLObject2
    {
        public const ushort maxFormattedPriceLength = 20;

        public uint wholePart;

        public byte fractionalPart;

        [WireInfo(HexString=true)]
        public byte currencyFormat;

        [WireInfo(Min=0, Max=3)]
        public ushort isoCodeLength;

        [WireInfo(SizeParam="isoCodeLength")]
        public string isoCode;

        [WireInfo(Min=0, Max=maxFormattedPriceLength)]
        public ushort formattedPriceLength;

        [WireInfo(SizeParam="formattedPriceLength")]
        public string formattedPrice;

        [WireInfo(HexString=true)]
        public uint offeringDetails;
    }

    public class XeGetUserSubscriptionDetailsResponse : XRLObject2
    {
        public const ushort maxDescriptionLength = 500;
        public const ushort maxFriendlyNameLength = 50;

        public ushort subscriptionIdLength = 0;

        [WireInfo(SizeParam="subscriptionIdLength")]
        public string subscriptionId = "";

        [WireInfo(Max=maxDescriptionLength)]
        public ushort descriptionLength = 0;

        [WireInfo(SizeParam="descriptionLength")]
        public string description = "";

        public byte currentOfferStatus;

        [WireInfo(MinSchemaVersion = "4.3")]
        public bool delayedCancel;

        [WireInfo(Max=(maxFriendlyNameLength * 2))]
        public ushort friendlyNameLength = 0;

        [WireInfo(SizeParam="friendlyNameLength")]
        public string friendlyName = "";

        public byte anniversaryDate;

        public DateTime purchaseDate = DateTime.UtcNow;

        public DateTime activationDate = DateTime.UtcNow;

        public DateTime endDate = DateTime.UtcNow;

        public byte hasViolations;

        public uint renewalGracePeriod;

        public byte renewalOfferStatus;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        public UserSubscriptionDetailsData currentOfferDetails;

        public UserSubscriptionDetailsData renewalOfferDetails;

        public PaymentInstrumentInfoEx paymentInstrument;

    }

    public class EnumFamilyMembersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid userPuid = 0;

        // When the user is logged in, the passport token can be NULL and this API will validate
        // identity through the SG. In cases where a user isn't logged in (such as account recovery),
        // the caller can pass a passport token to be used instead.
        [WireInfo(MinSchemaVersion = "7.0", Max=1)]
        public ushort userPassportTokenLength = 0;

        [WireInfo(MinSchemaVersion = "7.0", SizeParam = "userPassportTokenLength", NullTerminate = false)]
        public PassportToken[] userPassportToken = null;

        public override string Xrl
        {
            get { return "/xuacs/EnumFamilyMembers.ashx"; }
        }
    }

    public class FamilyDefs
    {
        public const ushort FAMILY_OWNER = 0x0001;
        public const ushort FAMILY_SUBSCRIPTION_GOLD = 0x0002;
    }

    public class FamilyMember : WireData
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        public ushort userFlags = 0; // FAMILY_* flags from FamilyDefs

        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string gamertag;
    }

    public class EnumFamilyMembersResponse : XRLObject2
    {
        // 25 dependents + owner
        public const ushort MAX_FAMILY_MEMBERS = 26;

        [WireInfo(Max = MAX_FAMILY_MEMBERS)]
        public ushort numFamilyMembers;

        [WireInfo(SizeParam = "numFamilyMembers")]
        public FamilyMember[] familyMembers;
    }

    public class AddDependentRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the new dependent
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the new owner. This user must be signed in.
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        // The passport credentials of the old owner. If the dependent was an independent
        // account, this will be the passport of the dependent. If the dependent was owned
        // by another account and is being transferred, this is the old owner.
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/AddDependent.ashx"; }
        }
    }

    public class RemoveDependentRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being removed from the family
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the remove operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/RemoveDependent.ashx"; }
        }
    }

    // If the user is the owner of a family and has a family gold subscription,
    // this allows the user to see how many users can be granted gold rights
    // as partof the subscription and how many gold seats are available to be assigned.
    // This is used by the family center application to display information about the
    // user's subscription.
    public class FamilySubscriptionGoldUserCountRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionGoldUserCount.ashx"; }
        }
    }

    public class FamilySubscriptionGoldUserCountResponse : XRLObject2
    {
        // The total number of gold seats that are provided by the family subscription of the
        // requesting user, including the one provided to the subscriber.
        // If the requesting user does not have an active family subscription, or is a dependent
        // that had been assigned a gold seat in a family subscription, this will be 0.
        public ushort total;

        // The number of gold seats for the requesting user's family subscription that have not
        // had dependents assigned to them
        public ushort available;
    }

    public class FamilySubscriptionAssignGoldUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being assigned a gold seat
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the assignment operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionAssignGoldUser.ashx"; }
        }
    }

    public class FamilySubscriptionRemoveGoldUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being removed from a gold seat
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the remove operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionRemoveGoldUser.ashx"; }
        }
    }

    /// <summary>
    /// Request class for Preview Merge subscription. Takes primary and secondary puid
    /// </summary>
    public class PreviewMergeSubscriptionRequest : XRLObject2
    {
        // The xuid of the primary family gold primary user
        [WireInfo(HexString = true)]
        public Puid primaryUserPuid = 0;

        // The xuid of the secondary  gold  user whose subscription is being merged with Primary
        [WireInfo(HexString = true)]
        public Puid secondaryUserPuid = 0;

        // 0 if there's no owner passport token, 1 if there is.
        // a passport token is required if the secondary user is not a
        // dependent of the primary user.
        [WireInfo(Max = 1)]
        public ushort ownerPassportTokenLength;

        // The passport token of the secondary's owner
        [WireInfo(SizeParam = "ownerPassportTokenLength")]
        public PassportToken[] ownerPassportToken;

        public override string Xrl
        {
            get { return "/xuacs/PreviewMergeSubscription.ashx"; }
        }
    }

    /// <summary>
    /// Response for PreviewMergeSubscription Request
    /// </summary>
    public class PreviewMergeSubscriptionResponse : XRLObject2
    {
        //Months transfered to Family gold subscription
        public uint monthsTransferred;

        //Next charge data for family gold subscription
        public DateTime nextChargeDate;
    }

    public class GetParentalControlGroupTemplatesRequest : XRLObject2
    {
        // The user making the request
        public ulong userPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/GetParentalControlGroupTemplates.ashx"; }
        }
    }

    // Information about a single privilege/permission setting in a template definition
    public class ParentalControlGroupSettingDefinition : WireData
    {
        public uint settingId;
        public bool enabled;
    }

    public class ParentalControlGroupTemplateDefinition : WireData
    {
        public const byte MaxSettings = 32;

        public int parentalControlGroupId;

        // The default privileges settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte privilegeCount;

        [WireInfo(SizeParam = "privilegeCount")]
        public ParentalControlGroupSettingDefinition[] privileges;

        // The default profile permission settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte permissionCount;

        [WireInfo(SizeParam = "permissionCount")]
        public ParentalControlGroupSettingDefinition[] permissions;
    }

    public class GetParentalControlGroupTemplatesResponse : XRLObject2
    {
        [WireInfo(ArraySize = 3)]
        public ParentalControlGroupTemplateDefinition[] templates;
    }

    public class UserParentalControlGroup : WireData
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        // The id of the user's parental control group
        public int parentalControlGroupId;

        // true if any privileges/permissions have been changed
        // from the template value
        public bool custom;
    }

    public class GetUserParentalControlGroupRequest : XRLObject2
    {
        // 25 dependents + owner
        public const ushort MaxFamilyMembers = 26;

        public const byte MaxSettings = 32;

        // Must be signed in and must either be the target user (you can alway
        // see your own parental control group) or must be the owner of the target.
        public Puid requestorPuid;

        // The users whose parental control group are being requested
        [WireInfo(Max = MaxFamilyMembers)]
        public byte userPuidCount;

        [WireInfo(SizeParam = "userPuidCount")]
        public Puid[] userPuids;

        public override string Xrl
        {
            get { return "/xuacs/GetUserParentalControlGroup.ashx"; }
        }
    }

    public class GetUserParentalControlGroupResponse : XRLObject2
    {
        // A list of the requested users and their effective parental control group.
        // Any requested user that the requestor doesn't have permission to see will
        // not be in the result array.
        [WireInfo(Max = GetUserParentalControlGroupRequest.MaxFamilyMembers)]
        public byte userCount;

        [WireInfo(SizeParam = "userCount")]
        public UserParentalControlGroup[] users;
    }

    public class UpdateParentalControlGroupRequest : XRLObject2
    {
        // The target user to update
        public ulong userPuid = 0;

        // The new parental control group to set on the target user.
        public int parentalControlGroupId;

        // 0 if there's no owner passport token, 1 if there is.
        [WireInfo(Max = 1)]
        public ushort ownerPassportLength;

        // The passport token of the target's owner
        [WireInfo(SizeParam = "ownerPassportLength")]
        public PassportToken[] ownerPassport;

        public override string Xrl
        {
            get { return "/xuacs/UpdateParentalControlGroup.ashx"; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\wiredatacg.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Xml.Serialization;

using STF.common.config;
using STF.common.mgmt;
using STF.core.wiredata;

namespace STF.common.service
{

    // Customize the behavior of serialization/deserialization of a field
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Struct)]
    public class WireInfoAttribute : Attribute
    {

        public string SizeParam = null;

        // Contains the fixed size of the field annotated by this attribute (which must
        // be an array)
        int size = -1;
        public int ArraySize
        {
            get { return size; }
            set { Debug.Assert(value >= 0); size = value; }
        }

        public bool HexString = false;

        public bool Serialize = true;

        public bool PrintToString = true;

        public bool NullTerminate = false; // For strings, specifies that the on the wire format should be null-terminated

        public bool MaskString = false;

        public bool LimitString = false;   // specifies in ToString() if string length should be limited
                                           // actual limit is defined in the npdb setting wiredata_stringLimit

        public bool BigEndian = false;     // Indicates that the value on the wire is big endian (native for console) and
                                           // needs to be converted to little-endian

        public Type SerializeAs = null;    // Defines that the field or type should be serialized as another well-known wiredata
                                           // type.  The expectation is that the field has an implicit or explicit conversion
                                           // operator to the SerializeAs type.
        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public static WireInfoAttribute None = new WireInfoAttribute();

        private long _min = 0;
        private long _max = 0;
        public bool MaxSet = false;
        public bool MinSet = false;
        public String MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint MinSchemaVersionVal = 0;
        public uint MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", (version & 0xFFFF0000) >> 16, version & 0xFFFF);
        }

    }

    //public delegate void DebugTraceHandler(string field);

    // Subclass this to produce your own WireDataclass. All public fields will be
    // considered for serialization. Be careful to use only supported field types.
    public class WireData
    {
        // How much to indent nested object and array members when converting to a string
        public const byte C_INDENT = 2;

        public static DateTime MinDateTimeValue = DateTime.FromFileTimeUtc(0);

        //public static DebugTraceHandler fieldDelegate;

        //public static event DebugTraceHandler fieldTrace
        //{
        //    [MethodImpl(MethodImplOptions.Synchronized)]
        //    add
        //    {n
        //        fieldDelegate = (DebugTraceHandler)Delegate.Combine(fieldDelegate, value);
        //    }

        //    [MethodImpl(MethodImplOptions.Synchronized)]
        //    remove
        //    {
        //        fieldDelegate = (DebugTraceHandler)Delegate.Remove(fieldDelegate, value);
        //    }
        //}

        //
        // Read a bunch of bytes into a WireData object
        //
        public WireData ReadBytes(byte[] bytes)
        {
            return ReadStream(new MemoryStream(bytes, 0, bytes.Length, true, true));
        }

        //
        // Read a stream into a WireData object
        //
        public virtual WireData ReadStream(Stream stream)
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        // If set, you will need to manually provide array sizes when writing WireDatas
        protected bool manualArraySize = false;

        public bool ManualArraySize
        {
            get { return manualArraySize; }
        }

        //
        // Override the operator byte[] to allow assigning a WireData object directly to a byte array.
        //
        public static explicit operator byte[](WireData wiredata)
        {
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);

            return stream.ToArray();
        }

        // Adding ToArray, as writing an explicit cast looks a little odd.
        public byte[] ToArray()
        {
            return (byte[])this;
        }

        //
        // Serialize the object to obtain its size in bytes. This is SLOW!
        //
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);

            return (int)stream.Length;
        }

        public virtual int SerializedSize
        {
            get
            {
                WireDataSizeofDelegate sizedel =
                    WireDataSerializerCache.GetSerializerFor<WireDataSizeofDelegate>(this.GetType());
                return sizedel(this);
            }
        }

        public override string ToString()
        {
            return ToString(0);
        }

        public virtual string ToString(int indent)
        {
            StringBuilder sb = new StringBuilder();
            ToString(sb, indent);
            return sb.ToString();
        }

        public void ToString(StringBuilder sb, int indent)
        {
            WireDataToStringDelegate tostrdel =
                WireDataSerializerCache.GetSerializerFor<WireDataToStringDelegate>(this.GetType());
            tostrdel(this, sb, indent);
        }
        //
        // Log to the appropriate log area
        //
        protected string LogBinary(Stream stream)
        {
            string result = "";

            if (stream.CanSeek && stream.CanRead)
            {
                long position = stream.Position;
                long length = stream.Length;

                int bytesToRead = (int)(length - position);
                int bytesRead = 0;

                byte []     bytes = new byte[bytesToRead];

                while (bytesToRead > 0)
                {
                    int n = stream.Read(bytes, bytesRead, bytesToRead);

                    if (n == 0)
                    {
                        break;
                    }

                    bytesRead += n;
                    bytesToRead -=n;
                }

                string[]    lines = ByteConvert.ToFormattedStrings(bytes);

                foreach (string s in lines)
                {
                    Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, s);
                }

                // Put things back the way they were when we started
                stream.Seek(position, SeekOrigin.Begin);

            }
            else
            {
                result = "unsupported stream type.";
            }

            return result;
        }


        //
        // Log to the appropriate log area
        //
        protected string LogText()
        {
            string     delimiter = "\n";
            string []  lines = this.ToString(0).Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, s);
            }

            return "";
        }

        public static string GetHrName(HResult hr)
        {
            return hr.Name;
        }

        public static string MaskString(string value)
        {
            return String.IsNullOrEmpty(value) ? value : String.Empty.PadRight(value.Length, '*');
        }

        public static string LimitString(string value)
        {
            if (value == null)
            {
                return " null";
            }

            int length = Config.GetIntSetting(Setting.wiredata_stringLimit);

            if (length > 0 && value.Length > length)
            {
                value = value.Substring(0, length) + " (more ...)";
            }

            return value;
        }

        // This call is to clean up strings that may have
        // ArraySize set on them, which would pad the string with
        // extra nulls at the end of the string.
        public static string TrimNulls(string val)
        {
            if (String.IsNullOrEmpty(val))
            {
                return String.Empty;
            }

            int termPos = val.IndexOf('\0');
            if (termPos >= 0)
            {
                return val.Substring(0, termPos);
            }

            return val;
        }

        // Format a byte array as a hex string
        public static void ByteArrayToString(StringBuilder sb, byte[] bin, int indent, bool limit, bool mask)
        {
            if (bin == null)
            {
                sb.AppendLine(" null");
                return;
            }

            sb.AppendLine("byte[" + bin.Length + "] {");
            uint maxLines = UInt32.MaxValue;
            if (limit)
            {
                // 65 characters per line created by the convert function
                maxLines = (uint)Math.Min(1, Config.GetIntSetting(Setting.wiredata_stringLimit) / (65 + indent + C_INDENT));
            }

            string fill = String.Empty.PadRight(indent + C_INDENT);

            if (mask)
            {
                sb.Append(fill).AppendLine("**masked**");
            }
            else
            {
                Array.ForEach(ByteConvert.ToFormattedStrings(bin, maxLines), delegate(string s) { sb.AppendLine(fill + s); });
                if (maxLines < UInt32.MaxValue)
                {
                    sb.AppendLine(fill + "(more ...)");
                }
            }

            sb.AppendLine(String.Empty.PadRight(indent) + "}");
        }

        public void ValidateSchemaVersion()
        {
            WireDataValidateDelegate validatedel =
                WireDataSerializerCache.GetSerializerFor<WireDataValidateDelegate>(this.GetType());
            validatedel(this);            // Check current SchemaVersion against the one the Class expects
        }
        //
        // Write a WireData object to the given stream
        //
        public virtual void WriteStream(Stream stream)
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }

        private bool EncryptionRequired
        {
            get {
                WireDataEncryptionRequiredDelegate encDelegate =
                    WireDataSerializerCache.GetSerializerFor<WireDataEncryptionRequiredDelegate>(this.GetType());
                return encDelegate(this);
            }
        }

        // Serialize class into a BinaryWriter
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
#if false
            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Output: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
#endif
            WireDataWriteDelegate writeDelegate =
                WireDataSerializerCache.GetSerializerFor<WireDataWriteDelegate>(this.GetType());

            if (this.EncryptionRequired)
                WireDataEncrypt.Write(this, writeDelegate, binaryWriter);
            else {
                writeDelegate(this, binaryWriter);
            }

#if false
            // Log the binary output
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Output: ");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryWriter.BaseStream));
#endif
        }

        // Deserialize class from a BinaryReader
        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
#if false
            // Log the input buffer
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input:");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));
#endif
            WireDataReadDelegate readDelegate =
                WireDataSerializerCache.GetSerializerFor<WireDataReadDelegate>(this.GetType());

            try
            {
                if (EncryptionRequired)
                {
                    // decrypt message and replace binary reader
                    binaryReader = WireDataDecrypt.Read(this, readDelegate, binaryReader);
                }

                readDelegate(this, binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.WIREDATA_END_OF_STREAM, "Failed to read enough bytes for type " + GetType().Name, e);
            }
            catch (Exception e)
            {
                if ((e is XRLException) || (e is ExceptionWithoutEvent)) throw;
                HResult hr = XRLException.ToHResult(e, HResult.XONLINE_E_DESERIALIZATION_ERROR);
                throw new XRLException(hr, XEvent.Id.WIREDATA_DESERIALIZATION_ERROR, "Error deserializing request", e);
            }

#if false
            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
#endif
            return this;
        }

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // This is the version number of the latest schema. Must be the same as
        // XLIVE_SCHEMA_VERSION in STF.xd in the client tree.
        public static readonly uint CurrentSchemaVersion = MakeSchemaVersion(7, 1);

        // Version of the schema to use for serializing/deserializing this object.

        [XmlIgnore]
        public uint SchemaVersion = CurrentSchemaVersion;

        public static uint GetSchemaVersion(HttpRequest req)
        {
            // Assume version 1.0 for back compat
            uint schemaVersion = MakeSchemaVersion(1, 0);

            String schemaVersionStr = req.Headers["X-Schema-Ver"];
            if (schemaVersionStr != null)
            {
                schemaVersion = WireInfoAttribute.StringToVersion(schemaVersionStr);
            }

            return schemaVersion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\WireDataDecrypt.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;

using STF.common.service;

namespace STF.core.wiredata
{
    [ComVisible(false)]
    public static class WireDataDecrypt
    {
        static WireDataDecrypt()
        {
        }

        public static BinaryReader Read(
            WireData             wireData,
            WireDataReadDelegate readDelegate,
            BinaryReader         binaryReader
        )
        {
            try
            {
                int keyVersion = binaryReader.ReadInt32();

                // after the key version is the encrypted symmetric
                // key components.  use our private key to  decrypt

                byte[] encryptedBuffer = new byte[256];
                binaryReader.Read(encryptedBuffer, 0, 256);

                RsaPrivateKey privateKey = new RsaPrivateKey(ServiceKeyType.WIREDATA_PRIVATE_KEY, keyVersion);
                byte[] unencryptedBuffer = privateKey.Decrypt(encryptedBuffer);

                // take the unencrypted buffer  and  pull  out  the
                // pieces of the symmetric key then instantiate  it

                using (MemoryStream skMemoryStream = new MemoryStream(unencryptedBuffer))
                {
                    using (BinaryReader skBinaryReader = new BinaryReader(skMemoryStream))
                    {
                        int length = skBinaryReader.ReadInt32();

                        byte[] key = new byte[length];
                        if (skBinaryReader.Read(key, 0, length) != length) throw new EndOfStreamException();

                        length = skBinaryReader.ReadInt32();
                        byte[] iv = new byte[length];

                        if (skBinaryReader.Read(iv, 0, length) != length) throw new EndOfStreamException();

                        using (SymmetricKey symmetricKey = new SymmetricKey(key, iv))
                        {
                            unencryptedBuffer = symmetricKey.Decrypt(binaryReader.BaseStream);
                        }
                    }
                }

                MemoryStream wdMemoryStream = new MemoryStream(unencryptedBuffer);
                return new BinaryReader(wdMemoryStream);
            }
            catch (EndOfStreamException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DECRYPTION_ERROR,
                    XEvent.Id.WIREDATA_DECRYPTION_ERROR,
                    e, "Error decrypting wiredata buffer"
                );
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\WireDataEncrypt.cs ===
using System.IO;
using System.Runtime.InteropServices;

using STF.common.service;

namespace STF.core.wiredata
{
    [ComVisible(false)]
    public static class WireDataEncrypt
    {
        static WireDataEncrypt()
        {
        }

        public static void Write(
            WireData              wireData,
            WireDataWriteDelegate writeDelegate,
            BinaryWriter          binaryWriter
        )
        {
            using (RsaPublicKey publicKey = new RsaPublicKey(ServiceKeyType.WIREDATA_PUBLIC_KEY))
            {
                Write(wireData, writeDelegate, binaryWriter, publicKey);
            }
        }

        public static void Write(
            WireData              wireData,
            WireDataWriteDelegate writeDelegate,
            BinaryWriter          binaryWriter,
            RsaPublicKey          publicKey
        )
        {
            binaryWriter.Write(publicKey.KeyVersion);

            // create a memory stream and write  the  symmetric
            // key components into it before encrypting it  all

            using (SymmetricKey symmetricKey = new SymmetricKey())
            {
                using (MemoryStream skMemoryStream = new MemoryStream())
                {
                    using (BinaryWriter skBinaryWriter = new BinaryWriter(skMemoryStream))
                    {
                        skBinaryWriter.Write(symmetricKey.Key.Length);
                        skBinaryWriter.Write(symmetricKey.Key);
                        skBinaryWriter.Write(symmetricKey.IV.Length);
                        skBinaryWriter.Write(symmetricKey.IV);
                    }

                    // using the latest public key, we encrypt the
                    // memory stream containing our symmetric  key

                    binaryWriter.Write(publicKey.Encrypt(skMemoryStream.ToArray()));
                }

                // now use the symmetric key to write  out  the
                // original wiredata request/respsonse  message

                using (MemoryStream wdMemoryStream = new MemoryStream())
                {
                    using (BinaryWriter wdBinaryWriter = new BinaryWriter(wdMemoryStream))
                    {
                        writeDelegate(wireData, wdBinaryWriter);
                    }

                    binaryWriter.Write(symmetricKey.Encrypt(wdMemoryStream.ToArray()));
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\WireDataEncryptionAttribute.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.core.wiredata
{
    // Attribute to place on classes to control encryption parameters

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class WireDataEncryptionAttribute : Attribute
    {
        private uint?  _version  = null;

        public static WireDataEncryptionAttribute None = new WireDataEncryptionAttribute();

        public String AsOfSchemaVersion
        {
            get { return VersionToString(_version); }
            set { _version = StringToVersion(value); }
        }

        public static uint? StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2) throw new ArgumentException();
            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint? version)
        {
            return String.Format("{0}.{1}", ( version & 0xFFFF0000 ) >> 16, version & 0xFFFF);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\wiredata.cs ===
using System;
using System.Reflection;
using System.Collections;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Web;
using System.Xml.Serialization;

using STF.common.config;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.WireDataBin)]
[assembly: XomAreaDefinition(XomAreaName.WireDataTxt)]

namespace STF.common.service.reflection
{

    //
    // Attribute placed on fields of a class derived from WireData to add context to the field in order to serialize it
    //
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        public int      ArraySize = -1;

        public string   SizeParam = null;

        public bool     HexString = false;

        public bool     Serialize = true;

        public bool     NullTerminate = false; // For strings, specifies that the on the wire format should be null-terminated

        public bool     MaskString = false;

        public bool     LimitString = false;   // specifies in ToString() if string length should be limited
                                               // actual limit is defined in the npdb setting wiredata_stringLimit

        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public static WireInfoAttribute None = new WireInfoAttribute();


        private long   _min       = 0;
        private long   _max       = 0;
        public bool   MaxSet      = false;
        public bool   MinSet      = false;

        public String   MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String   MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint     MinSchemaVersionVal = 0;
        public uint     MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", ( version & 0xFFFF0000 ) >> 16, version & 0xFFFF);
        }
    }


    //
    // Wire Protocol objects should inherit from WireData to assume serialization and deserialization properties
    //
    [ComVisible(false)]
    public class WireData
    {
        // Setting this to true will dump WireData info as it's being written to a stream
        public static bool  DumpDiagnosticInfo = false;

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // DO NOT CHANGE THIS VALUE MANUALLY!
        //
        // It is derived from the version in wiredatacg.cs now, so please change that value only when
        // updating it to be the latest version.
        //
        public static readonly uint CurrentSchemaVersion = STF.common.service.WireData.CurrentSchemaVersion;

        // Version of the schema to use for serializing/deserializing this object.
        [XmlIgnore]
        public uint SchemaVersion = CurrentSchemaVersion;

        // If set, you will need to manually provide array sizes when writing WireDatas
        protected bool      ManualArraySize = false;


        //
        // When going through the reflection data for a type, we downconvert the type data
        //  from the native object format to an integer representation so that we can use
        //  switch statements during serialization and deserialization.
        //
        enum TypeData
        {
            TD_BOOLEAN,
            TD_BYTE,
            TD_BYTE_ARRAY,
            TD_CHAR,
            TD_DECIMAL,
            TD_DOUBLE,
            TD_SHORT,
            TD_INT,
            TD_LONG,
            TD_SBYTE,
            TD_FLOAT,
            TD_USHORT,
            TD_UINT,
            TD_ULONG,
            TD_STRING,
            TD_DATETIME,
            TD_WIREDATA,
            TD_GUID,
            TD_UNSUPPORTED
        };


        //
        // The WireTypeInfo
        //
        private class WireTypeInfo
        {
            // Convert the type data to a friendly enum for perf
            public TypeData[]   fieldType = null;
            public FieldInfo[]  fields = null;
            public WireInfoAttribute[] wireInfo = null;
            public WireInfoAttribute myWireInfo = null;

            // Cache which fields are arrays for perf
            public bool[]       fIsArray = null;

            // These values are used to connect array types
            //  to the field that specifies the length of the field
            //  use forward to find the length field from the array field
            //  use reverse to fine the array field from the length field
            public int[]        forward = null;
            public int[]        reverse = null;

            public WireTypeInfo(int size)
            {
                fieldType = new TypeData[size];

                wireInfo = new WireInfoAttribute[size];

                fIsArray = new bool[size];

                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    fieldType[i] = TypeData.TD_UNSUPPORTED;

                    fIsArray[i] = false;

                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        private static void ListFieldsInSubclasses(Type type, ArrayList outlist)
        {
            if (type == typeof(WireData))
            {
                return;
            }

            ListFieldsInSubclasses(type.BaseType, outlist);

            FieldInfo[] fieldsRaw = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < fieldsRaw.Length; i++)
            {
                outlist.Add(fieldsRaw[i]);
            }
        }

        //
        // The actual WireTypeInfo cache of all WireData types in the current assembly
        //
        private static Hashtable wireTypeInfoCache = new Hashtable();
        private static ReaderWriterLock rwlWireTypeInfoCache = new ReaderWriterLock();
        private const int LockTimeout = 30000;

        //
        // We do all the reflection processing once per type and cache
        // it in the wireTypeInfoCache hash table above.
        //
        private WireTypeInfo GetWireTypeInfo()
        {
            WireTypeInfo index = null;
            Type t = GetType();
            rwlWireTypeInfoCache.AcquireReaderLock(LockTimeout);
            try
            {
                // Do the quick check first to see if this type has already been initialized
                index = (WireTypeInfo)wireTypeInfoCache[t];
                if (index != null)
                {
                    return index;
                }

                // upgrade to a writer lock
                LockCookie lc = rwlWireTypeInfoCache.UpgradeToWriterLock(LockTimeout);
                try
                {
                    // Check to see if this WireData has already been initialized.
                    // If we blocked on the lock, the first thread to
                    // finish the operation makes the rest irrelevant.
                    index = (WireTypeInfo)wireTypeInfoCache[t];
                    if (index != null)
                    {
                        return index;
                    }

                    ArrayList fieldsList = new ArrayList();
                    ListFieldsInSubclasses(GetType(), fieldsList);
                    FieldInfo[] fields = fieldsList.ToArray(typeof(FieldInfo)) as FieldInfo[];

                    // Index this WireData derivative
                    index = new WireTypeInfo(fields.Length);

                    // Cache fields for later
                    index.fields = fields;

                    // Cache 'my' WireInfo, of this type, for later
                    index.myWireInfo = GetWireInfo(GetType());

                    for (int i = 0; i < index.fields.Length; i++)
                    {
                        FieldInfo           field = index.fields[i];
                        Type                type = field.FieldType;

                        index.wireInfo[i] = GetWireInfo(field);

                        if (type.IsArray || type == typeof(string))
                        {
                            index.fIsArray[i] = true;

                            // Get the base type of the array
                            if (type.IsArray)
                            {
                                type = type.GetElementType();
                            }

                            // Find the length specifier and setup the forward/reverse indexers
                            // but only if we actually intend to serialize this field at some
                            // point in the future
                            if (index.wireInfo[i].Serialize == true)
                            {
                                if (index.wireInfo[i].ArraySize == -1)
                                {
                                    string sizeParamName = index.wireInfo[i].SizeParam;
                                    if (sizeParamName == null)
                                    {
                                        sizeParamName = field.Name + "Len";
                                    }

                                    int j;
                                    for (j = 0; j < i; j++)
                                    {
                                        if (index.fields[j].Name == sizeParamName)
                                        {
                                            break;
                                        }
                                    }

                                    if (j == i)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");
                                    }

        // Something we should enable post-tsunami..
        //#if DEBUG
        //                            if (index.wireInfo[j].MaxSet == false)
        //                            {
        //                            }
        //#endif


                                    index.forward[i] = j;
                                    index.reverse[j] = i;
                                }
                                else
                                {
                                    if (index.wireInfo[i].SizeParam != null)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                                    }
                                }
                            }
                        }

                        // Convert the FieldType info into our private enum
                        TypeData    td = TypeData.TD_UNSUPPORTED;
                        bool        fHex = false;

                        if (type.IsSubclassOf(typeof(Enum)))
                        {
                            type = Enum.GetUnderlyingType(type);
                        }

                        if (type == typeof(bool))
                        {
                            td = TypeData.TD_BOOLEAN;
                        }
                        else if (type == typeof(byte))
                        {
                            if(index.fIsArray[i])
                            {
                                td = TypeData.TD_BYTE_ARRAY;
                            }
                            else
                            {
                                td = TypeData.TD_BYTE;
                                fHex = index.wireInfo[i].HexString;
                            }
                        }
                        else if (type == typeof(char))
                        {
                            td = TypeData.TD_CHAR;
                        }
                        else if (type == typeof(decimal))
                        {
                            td = TypeData.TD_DECIMAL;
                        }
                        else if (type == typeof(double))
                        {
                            td = TypeData.TD_DOUBLE;
                        }
                        else if (type == typeof(short))
                        {
                            td = TypeData.TD_SHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(int))
                        {
                            td = TypeData.TD_INT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(long))
                        {
                            td = TypeData.TD_LONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(sbyte))
                        {
                            td = TypeData.TD_SBYTE;
                        }
                        else if (type == typeof(float))
                        {
                            td = TypeData.TD_FLOAT;
                        }
                        else if (type == typeof(ushort))
                        {
                            td = TypeData.TD_USHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(uint))
                        {
                            td = TypeData.TD_UINT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(ulong))
                        {
                            td = TypeData.TD_ULONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(string))
                        {
                            td = TypeData.TD_STRING;
                        }
                        else if (type == typeof(DateTime))
                        {
                            td = TypeData.TD_DATETIME;
                        }
                        else if (type == typeof(Guid))
                        {
                            td = TypeData.TD_GUID;
                        }
                        else if (type.IsSubclassOf(typeof(WireData)))
                        {
                            td = TypeData.TD_WIREDATA;
                        }

                        if (td == TypeData.TD_UNSUPPORTED)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" not supported.");
                        }

                        index.fieldType[i] = td;

                        if (fHex != index.wireInfo[i].HexString)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" cannot be output in hexadecimal.");
                        }

                    }

                    wireTypeInfoCache.Add(GetType(), index);
                    return index;
                }
                finally
                {
                    rwlWireTypeInfoCache.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                rwlWireTypeInfoCache.ReleaseReaderLock();
            }
        }

        //
        // Retrieve the WireInfo attributes from the memberinfo specified
        //
        private WireInfoAttribute GetWireInfo(MemberInfo info)
        {
            object[] attribs = info.GetCustomAttributes(typeof(WireInfoAttribute), false);
            int len = attribs.Length;

            Debug.Assert(len == 0 || len == 1);

            if (len == 1)
            {
                return (WireInfoAttribute)attribs[0];
            }
            else
            {
                return WireInfoAttribute.None;
            }
        }

        // How much to indent nested object and array members when converting to a string
        private const int C_INDENT = 2;

        //
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public virtual string ToString(int indent)
        {
            Type type = GetType();
            WireTypeInfo index = GetWireTypeInfo();

            StringBuilder str = new StringBuilder();
            str.Append(type.Name + " {\n");

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo       field = index.fields[i];
                object          o = field.GetValue(this);

                if ((o != null) && (index.fIsArray[i]) && (index.fieldType[i] != TypeData.TD_STRING) && (index.fieldType[i] != TypeData.TD_BYTE_ARRAY))
                {
                    int actualArraySize = (o as Array).Length;

                    str.Append("".PadLeft(indent + C_INDENT) + field.Name + " is an array of length " + actualArraySize + "\n");

                    for (int j = 0; j < actualArraySize; j++)
                    {
                        object val = (o as Array).GetValue(j);

                        str.Append("".PadLeft(indent + C_INDENT) + field.Name + "[" + j + "]");

                        // Check for array of complex type
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            str.Append("=" + (val as WireData).ToString(indent + C_INDENT) + "\n");
                        }
                        else
                        {
                            str.Append("=" + PrintValue(val, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].LimitString, index.wireInfo[i].MaskString) + "\n");
                        }
                    }
                }
                else
                {
                    str.Append("".PadLeft(indent + C_INDENT) + field.Name);

                    if (o == null)
                    {
                        str.Append("= null\n");
                    }
                    // Check for complex type
                    else if (index.fieldType[i] == TypeData.TD_WIREDATA)
                    {
                        str.Append("=" + (o as WireData).ToString(indent + C_INDENT) + "\n");
                    }
                    else
                    {
                        str.Append("=" + PrintValue(o, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].LimitString, index.wireInfo[i].MaskString) + "\n");
                    }
                }
            }

            str.Append("".PadLeft(indent) + "}");

            return str.ToString();
        }

        // Format a byte array as a hex string
        static protected string ByteArrayToString(byte[] bin)
        {
            StringBuilder str = new StringBuilder(bin.Length * 2 + 1);
            for(int i=0; i < bin.Length; i++)
            {
                str.Append(bin[i].ToString("x2"));
            }

            return str.ToString();
        }


        //
        // Override the ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public override string ToString()
        {
            return ToString(0);
        }


        //
        // Log to the appropriate log area
        //
        protected string LogBinary(Stream stream)
        {
            string result = "";

            if (stream.CanSeek && stream.CanRead)
            {
                long position = stream.Position;
                long length = stream.Length;

                int bytesToRead = (int)(length - position);
                int bytesRead = 0;

                byte []     bytes = new byte[bytesToRead];

                while (bytesToRead > 0)
                {
                    int n = stream.Read(bytes, bytesRead, bytesToRead);

                    if (n == 0)
                    {
                        break;
                    }

                    bytesRead += n;
                    bytesToRead -=n;
                }

                string[]    lines = ByteConvert.ToFormattedStrings(bytes);

                foreach (string s in lines)
                {
                    Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, s);
                }

                // Put things back the way they were when we started
                stream.Seek(position, SeekOrigin.Begin);

            }
            else
            {
                result = "unsupported stream type.";
            }

            return result;
        }


        //
        // Log to the appropriate log area
        //
        protected string LogText()
        {
            string     delimiter = "\n";
            string []  lines = this.ToString(0).Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, s);
            }

            return "";
        }


        //
        // Read a bunch of bytes into a WireData object
        //
        public WireData ReadBytes(byte[] bytes)
        {
            return ReadStream(new MemoryStream(bytes));
        }

        //
        // Read a stream into a WireData object
        //
        public virtual WireData ReadStream(Stream stream)
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        //
        // Read from a BinaryReader into a WireData object
        //  Strings are decoded with UTF8.
        //  DateTime is converted from a 64 bit systime and is represented in LocalTime
        //
        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log the input buffer
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input:");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo    field = index.fields[i];

                object       o = null;

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                try
                {
                    // Handle arrays
                    if (index.fIsArray[i])
                    {
                        int size = index.wireInfo[i].ArraySize;

                        if (size == -1)
                        {
                            try
                            {
                                size = Convert.ToInt32(index.fields[index.forward[i]].GetValue(this));
                            }
                            catch(InvalidCastException e)
                            {
                                throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                            }
                        }

                        if (field.FieldType == typeof(string))
                        {
                            string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(size));
                            int termPos = s.IndexOf((char)0);

                            if (termPos > 0)
                            {
                                o = s.Substring(0, s.IndexOf((char)0));
                            }
                            else if (termPos == -1)
                            {
                                o = s;
                            }
                            else
                            {
                                o = "";
                            }
                        }
                        else if(index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            o = binaryReader.ReadBytes(size);
                            // bugs 24888, 31444
                            // Win2k SP2 doesn't throw if size bytes can't be read, it just quietly ignores it..
                            if (((byte[])o).Length < size)
                            {
                                throw new EndOfStreamException("Unable to read " + size + " bytes from stream; only found " + ((byte[])o).Length);
                            }
                        }
                        else
                        {
                            Type[] types = {typeof(int)};
                            object[] param = {size};

                            o = field.FieldType.GetConstructor(types).Invoke(param);

                            for (int j = 0; j < size; j++)
                            {
                                (o as Array).SetValue(ReadValue(binaryReader, index.fieldType[i], field.FieldType.GetElementType(), null), j);
                            }
                        }
                    }
                    else
                    {
                        // For nested WireData objects, default constructors may have already initialized child objects
                        //  with valid state. An example of this is Presence protocol structures that set up a container
                        //  reference to the parent object at construction. In these cases, we want to just use the
                        //  already created object and fill in the values rather than constructing a new one.
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            o = field.GetValue(this);
                        }

                        o = ReadValue(binaryReader, index.fieldType[i], field.FieldType, o);

                        // check max/min range
                        CheckRange(o, index.wireInfo[i], index.fieldType[i], field.Name);
                    }
                }
                catch (EndOfStreamException e)
                {
                    throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.WIREDATA_END_OF_STREAM, "Reached end of stream trying to read " + field.Name, e);
                }


                field.SetValue(this, o);
            }

            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            return this;
        }

        private void CheckRange(object o, WireInfoAttribute wireInfo, TypeData typeData, string name)
        {
            long val;

            switch (typeData)
            {
            case TypeData.TD_BYTE:
                val = (long)(byte)o;
                break;

            case TypeData.TD_SHORT:
                val = (long)(short)o;
                break;

            case TypeData.TD_INT:
                val = (long)(int)o;
                break;

            case TypeData.TD_LONG:
                val = (long)(long)o;
                break;

            case TypeData.TD_SBYTE:
                val = (long)(sbyte)o;
                break;

            case TypeData.TD_FLOAT:
                val = (long)(float)o;
                break;

            case TypeData.TD_USHORT:
                val = (long)(ushort)o;
                break;

            case TypeData.TD_UINT:
                val = (long)(uint)o;
                break;

            case TypeData.TD_ULONG:
                val = (long)(ulong)o;
                break;

            default:
                // numeric type, nothing to do
                return;
            }


            if (wireInfo.MaxSet == true && val > wireInfo.Max)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER,
                    "The value specified for field "  + name + " (" + val + ") exceeds the Max allowed value (" + wireInfo.Max + ") !");
            }

            if (wireInfo.MinSet == true && val < wireInfo.Min)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER_1,
                    "The value specified for field "  + name + " (" +  val + ") is less than the Min allowed value (" + wireInfo.Min + ") !");
            }
        }

        //
        // Override the operator byte[] to allow assigning a WireData object directly to a byte array.
        //
        public static explicit operator byte[](WireData wiredata)
        {
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);

            return stream.ToArray();
        }

        // Adding ToArray, as writing an explicit cast looks a little odd.
        public byte[] ToArray()
        {
            return (byte[])this;
        }

        //
        // Write a WireData object to the given stream
        //
        public virtual void WriteStream(Stream stream)
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }


        //
        // Write a WireData object to the given binaryWriter
        //  Strings are encoded with UTF8.
        //  DateTime is converted to a 64 bit systime in UTC
        //
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Output: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo field = index.fields[i];

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                if (WireData.DumpDiagnosticInfo)
                {
                    Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_HIGH, field.Name);
                }

                object o = field.GetValue(this);

                if (index.fIsArray[i])
                {
                    int actualArraySize = 0;

                    // Define edge case where wiredata would serialize different value with null vs. empty string. Define output
                    // to match the empty string path.
                    if (o == null && index.wireInfo[i].NullTerminate && index.wireInfo[i].ArraySize != -1)
                    {
                        o = String.Empty;
                    }

                    if (o != null)
                    {
                        actualArraySize = index.fieldType[i] == TypeData.TD_STRING ? Encoding.UTF8.GetByteCount((string)o) : (o as Array).Length;

                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (index.wireInfo[i].ArraySize != -1 && actualArraySize > index.wireInfo[i].ArraySize)
                            {
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                            }
                        }

                        if (index.fieldType[i] == TypeData.TD_STRING)
                        {
                            byte[] b = new UTF8Encoding().GetBytes((string)o);

                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // string as a member would fail to be written.
                            //
                            if ( b.Length > 0 )
                            {
                                binaryWriter.Write(b);
                            }

                            if( index.wireInfo[i].NullTerminate )
                            {
                                binaryWriter.Write( (byte)0 ); // Write out the null if requested
                            }
                        }
                        else if(index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            byte[] b = (byte[]) o;
                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // byte array as a member would fail to be written.
                            //
                            if ( b.Length > 0 )
                            {
                                binaryWriter.Write(b);
                            }
                        }
                        else
                        {
                            for (int j = 0; j < actualArraySize; j++)
                            {
                                object val = (o as Array).GetValue(j);
                                WriteValue(binaryWriter, val, index.fieldType[i]);
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if ((index.wireInfo[i].ArraySize != -1) && (index.wireInfo[i].ArraySize > actualArraySize))
                        {
                            if (index.fieldType[i] == TypeData.TD_STRING || index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[index.wireInfo[i].ArraySize - actualArraySize]);
                            }
                            else
                            {
                                if (index.fieldType[i] == TypeData.TD_WIREDATA)
                                {
                                    throw new Exception("WireData(): for type " + GetType().Name + "." + field.FieldType.GetElementType().Name + " -- The number of elements in the array must equal the ArraySize. No padding can be done for complex types.");
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < index.wireInfo[i].ArraySize; j++)
                                    {
                                        WriteValue(binaryWriter, 0, index.fieldType[i]);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            int iArray = index.reverse[i];

                            object oT = index.fields[iArray].GetValue(this);
                            if (oT == null)
                            {
                                o = 0;
                            }
                            else if (index.fieldType[iArray] == TypeData.TD_STRING)
                            {
                                int iSize = Encoding.UTF8.GetByteCount((string)oT);
                                if( index.wireInfo[iArray].NullTerminate )
                                {
                                    iSize += 1; // Add the null onto the size
                                }
                                o = iSize;
                            }
                            else
                            {
                                o = ((Array)oT).Length;
                            }
                        }
                    }

                    WriteValue(binaryWriter, o, index.fieldType[i]);
                }
            }

            // Log the binary output
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Output: ");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryWriter.BaseStream));
        }

        //
        // Serialize the object to obtain its size in bytes. This is SLOW!
        //
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);

            return (int)stream.Length;
        }

        #region Read/Write Converters
        //
        // Read a value of the provided type from the binaryReader
        //
        private object ReadValue(BinaryReader reader, TypeData typeData, Type type, object o)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                o = reader.ReadBoolean();
                break;

            case TypeData.TD_BYTE:
                o = reader.ReadByte();
                break;

            case TypeData.TD_CHAR:
                o = reader.ReadChar();
                break;

            case TypeData.TD_DECIMAL:
                o = reader.ReadDecimal();
                break;

            case TypeData.TD_DOUBLE:
                o = reader.ReadDouble();
                break;

            case TypeData.TD_SHORT:
                o = reader.ReadInt16();
                break;

            case TypeData.TD_INT:
                o = reader.ReadInt32();
                break;

            case TypeData.TD_LONG:
                o = reader.ReadInt64();
                break;

            case TypeData.TD_SBYTE:
                o = reader.ReadSByte();
                break;

            case TypeData.TD_FLOAT:
                o = reader.ReadSingle();
                break;

            case TypeData.TD_USHORT:
                o = reader.ReadUInt16();
                break;

            case TypeData.TD_UINT:
                o = reader.ReadUInt32();
                break;

            case TypeData.TD_ULONG:
                o = reader.ReadUInt64();
                break;

            case TypeData.TD_DATETIME:
                o = DateTime.FromFileTimeUtc(reader.ReadInt64());
                break;

            case TypeData.TD_WIREDATA:
                Debug.Assert(type.IsSubclassOf(typeof(WireData)));
                if (o == null)
                {
                    ConstructorInfo ci = type.GetConstructor(Type.EmptyTypes);
                    if (ci == null)
                    {
                        throw new Exception(String.Format("Type {0} must have a public default (parameterless) constructor.", type.ToString()));
                    }
                    else
                    {
                        o = ci.Invoke(null);
                    }
                }

                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                o = wd.ReadStream(reader) ?? o;
                break;

            case TypeData.TD_GUID:
                o = new Guid(reader.ReadBytes(16));
                break;

            default:
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");

            }

            return o;
        }

        //
        // Write a value of the provided type to the binaryWriter
        //
        private void WriteValue(BinaryWriter writer, object o, TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                writer.Write(Convert.ToBoolean(o));
                break;

            case TypeData.TD_BYTE:
                writer.Write(Convert.ToByte(o));
                break;

            case TypeData.TD_CHAR:
                writer.Write(Convert.ToChar(o));
                break;

            case TypeData.TD_DECIMAL:
                writer.Write(Convert.ToDecimal(o));
                break;

            case TypeData.TD_DOUBLE:
                writer.Write(Convert.ToDouble(o));
                break;

            case TypeData.TD_SHORT:
                writer.Write(Convert.ToInt16(o));
                break;

            case TypeData.TD_INT:
                writer.Write(Convert.ToInt32(o));
                break;

            case TypeData.TD_LONG:
                writer.Write(Convert.ToInt64(o));
                break;

            case TypeData.TD_SBYTE:
                writer.Write(Convert.ToSByte(o));
                break;

            case TypeData.TD_FLOAT:
                writer.Write(Convert.ToSingle(o));
                break;

            case TypeData.TD_USHORT:
                writer.Write(Convert.ToUInt16(o));
                break;

            case TypeData.TD_UINT:
                writer.Write(Convert.ToUInt32(o));
                break;

            case TypeData.TD_ULONG:
                writer.Write(Convert.ToUInt64(o));
                break;

            case TypeData.TD_DATETIME:
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
                break;

            case TypeData.TD_WIREDATA:
                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                wd.WriteStream(writer);
                break;

            case TypeData.TD_GUID:
                writer.Write(((Guid)o).ToByteArray());
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }
        }

        public void SerializeArray(WireData [] arrObject, int nLength, BinaryWriter binaryWriter)
        {
             for (int i=0;i<nLength;i++)
             {
                arrObject[i].SchemaVersion = this.SchemaVersion;
                arrObject[i].WriteStream(binaryWriter);
             }
        }

        //
        // Write a value of the provided type to a string
        //
        private string PrintValue(object o, TypeData typeData, bool fHex, bool fLimit, bool fMask)
        {
            string str;

            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                str = (Convert.ToBoolean(o)).ToString();
                break;

            case TypeData.TD_BYTE:
                str = fHex ? "0x" + (Convert.ToByte(o)).ToString("X2") : (Convert.ToByte(o)).ToString();
                break;

            case TypeData.TD_BYTE_ARRAY:
                str = ByteArrayToString((byte[])o);
                break;

            case TypeData.TD_CHAR:
                str = (Convert.ToChar(o)).ToString();
                break;

            case TypeData.TD_DECIMAL:
                str = (Convert.ToDecimal(o)).ToString();
                break;

            case TypeData.TD_DOUBLE:
                str = (Convert.ToDouble(o)).ToString();
                break;

            case TypeData.TD_SHORT:
                str = fHex ? "0x" + (Convert.ToInt16(o)).ToString("X4") : (Convert.ToInt16(o)).ToString();
                break;

            case TypeData.TD_INT:
                str = fHex ? "0x" + (Convert.ToInt32(o)).ToString("X8") : (Convert.ToInt32(o)).ToString();
                break;

            case TypeData.TD_LONG:
                str = fHex ? "0x" + (Convert.ToInt64(o)).ToString("X16") : (Convert.ToInt64(o)).ToString();
                break;

            case TypeData.TD_SBYTE:
                str = (Convert.ToSByte(o)).ToString();
                break;

            case TypeData.TD_FLOAT:
                str = (Convert.ToSingle(o)).ToString();
                break;

            case TypeData.TD_USHORT:
                str = fHex ? "0x" + (Convert.ToUInt16(o)).ToString("X4") : (Convert.ToUInt16(o)).ToString();
                break;

            case TypeData.TD_UINT:
                str = fHex ? "0x" + (Convert.ToUInt32(o)).ToString("X8") : (Convert.ToUInt32(o)).ToString();
                break;

            case TypeData.TD_ULONG:
                str = fHex ? "0x" + (Convert.ToUInt64(o)).ToString("X16") : (Convert.ToUInt64(o)).ToString();
                break;

            case TypeData.TD_DATETIME:
                str = (Convert.ToDateTime(o).ToFileTimeUtc()).ToString();
                break;

            case TypeData.TD_STRING:
                str = (string)o;
                break;

            case TypeData.TD_GUID:
                str = ((Guid)o).ToString();
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }

            // If the field is masked, replace all of the characters with an
            // asterisk ('*').  This will likely only be used for fields which
            // contain credit card or direct debit account numbers or other
            // equally sensitive data.
            if ( fMask && !String.IsNullOrEmpty(str) )
            {
                str = String.Empty.PadRight(str.Length, '*');
            }

            if (fLimit)
            {
                int length = Config.GetIntSetting("wiredata_stringLimit");

                if (length > 0)
                {
                    if (str.Length > length)
                    {
                        str = str.Substring(0, length) + " (more ...)";
                    }
                }
            }

            return str;
        }

        //
        // Return the size for a given type (only supports types used by ReadValue)
        //
        private uint SizeOfType(TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_DECIMAL:
            case TypeData.TD_GUID:
                return 16;

            case TypeData.TD_DATETIME:
            case TypeData.TD_DOUBLE:
            case TypeData.TD_LONG:
            case TypeData.TD_ULONG:
                return 8;

            case TypeData.TD_FLOAT:
            case TypeData.TD_INT:
            case TypeData.TD_UINT:
                return 4;

            case TypeData.TD_SHORT:
            case TypeData.TD_USHORT:
                return 2;

            case TypeData.TD_BOOLEAN:
            case TypeData.TD_BYTE:
            case TypeData.TD_CHAR:
            case TypeData.TD_SBYTE:
                return 1;

            case TypeData.TD_WIREDATA:
                return 0;

            default:
                throw new Exception("Type \"" + typeData.ToString() + "\" not supported by SizeOfType.");
            }
        }

        public static uint GetSchemaVersion(HttpRequest req)
        {
            // Assume version 1.0 for back compat
            uint schemaVersion = MakeSchemaVersion(1,0);

            String schemaVersionStr = req.Headers["X-Schema-Ver"];
            if (schemaVersionStr != null)
            {
                schemaVersion = WireInfoAttribute.StringToVersion(schemaVersionStr);
            }

            return schemaVersion;
        }

        public void ValidateSchemaVersion()
        {
            // Check current SchemaVersion against the one the Class expects
            WireTypeInfo myInfo = GetWireTypeInfo();

            if( this.SchemaVersion < myInfo.myWireInfo.MinSchemaVersionVal ||
                this.SchemaVersion > myInfo.myWireInfo.MaxSchemaVersionVal)
            {
                throw new XRLException(HResult.XONLINE_E_UNSUPPORTED_METHOD, XEvent.Id.COMMON_HACK_81,
                    "Wiredata Request SchemaVersion " + WireInfoAttribute.VersionToString(this.SchemaVersion) + " not allowed: " + this.GetType().ToString());
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XBancProxyProt.cs ===
using System;
using System.IO;

namespace STF.common.service
{
    public class XBancDefs
    {
        public const uint XBANC_PROTOCOL_VERSION_CURRENT = 1;
        public const uint XBANC_MESSAGE_HEADER_SIZE = 16;
        public const uint XBANC_MAX_PACKET_SIZE = 16384;
        public const uint XBANC_INCREMENT_HALFLIFE_INFINITE = 0xFFFFFFFF;
    }

    public enum XBANC_MSG_TYPES
    {
        // request types:
        XBMSG_MIN_REQ                    = 1000,
        XBMSG_QUERY_REQ                  = 1000,
        XBMSG_INSERT_REQ                 = 1001,
        XBMSG_REMOVE_REQ                 = 1002,
        XBMSG_SET_DATA_REQ               = 1003,
        XBMSG_CONTINUATION_REQ           = 1004,
        XBMSG_INCREMENT_REQ              = 1005,
        XBMSG_MAX_REQ                    = 1005,

        // response types:
        XBMSG_MIN_RESP                   = 1100,
        XBMSG_EMPTY_RESP                 = 1100,
        XBMSG_QUERY_RESP                 = 1101,
        XBMSG_INSERT_RESP                = 1102,
        XBMSG_REMOVE_RESP                = 1103,
        XBMSG_SET_DATA_RESP              = 1104,
        XBMSG_INCREMENT_RESP             = 1105,
        XBMSG_MAX_RESP                   = 1105,
    };
    
    public class XBancMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public XBancMessageHeader()
        {
        }

        public XBancMessageHeader(XBANC_MSG_TYPES eType)
        {
            dwProtocolVersion = XBancDefs.XBANC_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)XBancDefs.XBANC_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::WriteStream binaryWriter is null");
            }

            if ((dwMsgType < (uint)XBANC_MSG_TYPES.XBMSG_MIN_REQ) ||
                (dwMsgType > (uint)XBANC_MSG_TYPES.XBMSG_MAX_REQ))
            {
                throw new Exception("Fatal Error - XBancMessageHeader::WriteStream dwMsgType not a valid request type.");                
            }

            dwMsgLen = (uint)Size();
            
            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            try
            {
                dwProtocolVersion = binaryReader.ReadUInt32();
                dwMsgType = binaryReader.ReadUInt32();
                dwMsgLen = binaryReader.ReadUInt32();
                dwSeqNum = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read response object header", e);
            }
            
            if ((dwMsgType < (uint)XBANC_MSG_TYPES.XBMSG_MIN_RESP) ||
                (dwMsgType > (uint)XBANC_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream dwMsgType not a valid response type.");                
            }
            
            return this;
        }
    }

    public class XBancQueryRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public byte[] rgbKey;

        public XBancQueryRequest() : base(XBANC_MSG_TYPES.XBMSG_QUERY_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancQueryRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancQueryResponse : XBancMessageHeader
    {
        public HResult hr;
        public uint dwValueSize;
        public uint dwValidSeconds;
        public byte[] rgbValue;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwValueSize = binaryReader.ReadUInt32();
                dwValidSeconds = binaryReader.ReadUInt32();
                rgbValue = binaryReader.ReadBytes((int)dwValueSize);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class XBancInsertRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public XBancInsertRequest() : base(XBANC_MSG_TYPES.XBMSG_INSERT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancInsertRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class XBancInsertResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancInsertResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read insert response object", e);
            }
            
            return this;
        }
    }

    public class XBancRemoveRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public bool fMatchExact;
        public byte[] rgbKey;

        public XBancRemoveRequest() : base(XBANC_MSG_TYPES.XBMSG_REMOVE_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 8 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancRemoveRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(fMatchExact ? (uint)1 : (uint)0);            

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancRemoveResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancRemoveResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read remove response object", e);
            }

            return this;
        }
    }

    public class XBancSetDataRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public XBancSetDataRequest() : base(XBANC_MSG_TYPES.XBMSG_SET_DATA_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancSetDataRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class XBancSetDataResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancSetDataResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read setdata response object", e);
            }

            return this;
        }
    }

    public class XBancIncrementRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public ulong qwIncrementAmount;
        public uint dwHalfLifeSeconds;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;

        public XBancIncrementRequest() : base(XBANC_MSG_TYPES.XBMSG_INCREMENT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 24 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancIncrementRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(qwIncrementAmount);
            binaryWriter.Write(dwHalfLifeSeconds);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancIncrementResponse : XBancMessageHeader
    {
        public HResult hr;
        public ulong qwResult;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancIncrementResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                qwResult = binaryReader.ReadUInt64();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read increment response object", e);
            }
            
            return this;
        }
    }

    public class XBancEmptyResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancEmptyResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read empty response object", e);
            }
            
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\wmdrm.cs ===
// -------------------------------------------------------------------------------------
//
// Copyright (c) 2006 Microsoft Corporation
//
// wmdrm.c
//
// Stuff to create a WMDRM (Janus) device certificate for a Xbox 360 console. Depends on 
// wmdrm.dll
// 
// -------------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

using STF.common.diagnostics;

namespace STF.common.wmdrm
{
    [SuppressUnmanagedCodeSecurity, HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
    internal sealed class SafeLibraryHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
    {
        // Methods
        internal SafeLibraryHandle() : base(true)
        {
        }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success), DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern bool FreeLibrary(IntPtr hModule);

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);

        protected override bool ReleaseHandle()
        {
            return FreeLibrary(base.handle);
        }
    }


    public class Wmdrm    
    {
        const UInt32 DeviceUniqueIdMaxLen     = 256;
        const UInt32 DevicePublicKeyLen       = 40;
        const UInt32 DevicePrivateKeyLen      = 20;
        const UInt32 GroupCertPrivateKeyLen   = 20;
        const UInt32 FallbackSigningKeyLen    = 20;
        const UInt32 DeviceCertificateMaxLen  = 10 * 1024;
        const UInt32 GroupCertTemplateMaxLen  = ((DeviceCertificateMaxLen*6)/10);

        public class WmdrmException : Exception
        {
            public WmdrmException(string message, UInt32 hr) :
                base(string.Format("{0}. hr=0x{1}", message, hr.ToString("X")))
                { _hr = hr; }

            public UInt32 Hr { get { return _hr; } }

            protected UInt32 _hr;
        }

        static object wmdrmLock = new object();
        static SafeLibraryHandle wmdrmLibrary = null;

        public static void Load()
        {
            if (wmdrmLibrary == null)
            {
                lock (wmdrmLock)
                {
                    if (wmdrmLibrary == null)
                    {
                        string path = Path.Combine(AppDomain.CurrentDomain.RelativeSearchPath, "wmdrm.dll");
                        wmdrmLibrary = SafeLibraryHandle.LoadLibraryEx(path, IntPtr.Zero, 0);
                        Debug.Assert(wmdrmLibrary != null && wmdrmLibrary.IsInvalid == false);
                    }
                }
            }
        }
        
        // CreateDeviceCertificate
        //
        // Creates the device certificate for a Xbox 360 console.
        //
        //   * deviceUniqueId - Xbox 360 console id as a string
        //   * devicePublicKey - device Public key that was sent by the 360.
        //   * deviceCertificate (OUT) - receives the device certificate that was just 
        //   created
        public static void CreateDeviceCertificate(
            byte[] certTemplate,
            byte[] groupPrivateKey,
            byte[] fallbackSigningKey,
            string deviceUniqueId,
            byte[] devicePublicKey,
            out byte[] deviceCertificate)
        {
            // Allocate a buffer to accomodate the largest certificate possible

            byte[] buffer = new byte[DeviceCertificateMaxLen];

            UInt32 bufferlen = (UInt32) buffer.Length;

            // make sure wmdrm.dll is loaded
            Load();

            UInt32 hr = Dll_ServerCreateDeviceCertificate(
                deviceUniqueId,
                (UInt32) deviceUniqueId.Length,
                devicePublicKey,
                (UInt32) devicePublicKey.Length,
                certTemplate,
                (UInt32) certTemplate.Length,
                groupPrivateKey,
                (UInt32) groupPrivateKey.Length,
                fallbackSigningKey,
                (UInt32) fallbackSigningKey.Length,
                buffer,
                ref bufferlen);

            if(hr != 0)
            {
                throw new WmdrmException(
                    "Dll_ServerCreateDeviceCertificate failed", hr);
            }

            // Copy certificate to output buffer

            deviceCertificate = new byte[bufferlen];
            Buffer.BlockCopy(buffer, 0, deviceCertificate, 0, deviceCertificate.Length);
        }

        // CreateDeviceKeyPair
        //
        // Creates a device key pair for test purposes.
        //
        //   * publiKey - receives the newly created public key
        //   * privateKey - receives the newly create private key
        //
        public static void CreateDeviceKeyPair(
            out byte[] publicKey,
            out byte[] privateKey )
        {
            publicKey  = new byte[DevicePublicKeyLen];
            privateKey = new byte[DevicePrivateKeyLen];

            UInt32 publicKeyLen  = (UInt32) publicKey.Length;
            UInt32 privateKeyLen = (UInt32) privateKey.Length;

            // make sure wmdrm.dll is loaded
            Load();

            UInt32 hr = Dll_ServerCreateDeviceKeyPair(
                publicKey,
                ref publicKeyLen,
                privateKey,
                ref privateKeyLen);

            if(hr != 0)
            {
                throw new WmdrmException(
                    "Dll_ServerCreateDeviceKeyPair failed", hr);
            }

            Assert.AreEqual(publicKeyLen,  publicKey.Length);
            Assert.AreEqual(privateKeyLen, privateKey.Length);
        }


        // -----------------------------------------------------------------------------
        // Wmdrm.dll imports
        // -----------------------------------------------------------------------------

        [DllImport(
            "wmdrm.dll",
            EntryPoint="ServerCreateDeviceCertificate",
            ExactSpelling=true,
            CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
            protected static extern UInt32 Dll_ServerCreateDeviceCertificate(
                string      pwszDeviceUniqueId,
                UInt32      cchDeviceUniqueId,
                byte[]      pbDevicePublicKey,
                UInt32      cbDevicePublicKey,
                byte[]      pbGroupCertTemplate,
                UInt32      cbGroupCertTemplate,
                byte[]      pbGroupCertPrivateKey,
                UInt32      cbGroupCertPrivateKey,
                byte[]      pbFallbackSigningKey,
                UInt32      cbFallbackSigningKey,
                byte[]      pbDeviceCertificate,        // OUT
                ref UInt32  cbDeviceCertificate         // IN OUT
                );
        
        [DllImport(
            "wmdrm.dll",
            EntryPoint="ServerCreateDeviceKeyPair",
            ExactSpelling=true,
            CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
            protected static extern UInt32 Dll_ServerCreateDeviceKeyPair(
                byte[]      pbPublicKey,                // OUT
                ref UInt32  pcbPublicKey,               // IN OUT
                byte[]      pbPrivateKey,               // OUT
                ref UInt32  pcbPrivateKey               // IN OUT
                );
    }

    class WmdrmGroupCertificate
    {
        public byte[] Certificate = null;
        public byte[] PrivateKey  = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XblSamlSecurityTokenAuthenticator.cs ===
// 
// XblSamlSecurityTokenAuthenticator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// SamlSecurityTokenAuthenticator derived class for Saml Token authentication
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using STF.common.exceptions;

namespace STF.common.service
{

internal class XblSamlSecurityTokenAuthenticator : SamlSecurityTokenAuthenticator
{
    internal XblSamlSecurityTokenAuthenticator( string[] allowedThumbprints ) : base (new SecurityTokenAuthenticator[1] { new X509SecurityTokenAuthenticator(new XblX509CertificateValidator(allowedThumbprints)) }, new TimeSpan(0,5,0) )
    {
        AudienceUriMode = AudienceUriMode.Always;
        IList<string> allowedUris = AllowedAudienceUris;
        allowedUris.Add( XblSamlToken.xbl10_samlissuer );
    }
    
    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    /// <summary>
    /// General SAML token validation entry point.
    /// </summary>
    /// <param name="allowedThumbprints"></param>
    /// <param name="certDeviceId"></param>
    public void ValidateToken(XblSamlToken xblSamlToken, string certDeviceId)
    {
        SamlSecurityToken samlSecurityToken = xblSamlToken.SecurityToken;
        
        base.ValidateToken(samlSecurityToken);
        
        // Does the client connection certificate match the device for which the token was issued
        string deviceId;
        if (!string.IsNullOrEmpty(certDeviceId) && xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_deviceid, out deviceId))
        {
            if (deviceId != certDeviceId)
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_CLIENTTHUMBPRINT, "; SAML Claim DeviceID does not match client certificate DeviceId. The token was not issued for this connection certificate. DeviceID {0} Cert DeviceId {1}", deviceId, certDeviceId);
            }
        }

        //general saml validation
        if (XblSamlToken.xbl10_samlmajorversion != xblSamlToken.MajorVersion)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MajorVersion attribute is {0}, but {1} is expected.", xblSamlToken.MajorVersion, XblSamlToken.xbl10_samlmajorversion);
        }

        if (XblSamlToken.xbl10_samlminorversion != xblSamlToken.MinorVersion)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MinorVersion attribute is {0}, but {1} is expected.", xblSamlToken.MinorVersion, XblSamlToken.xbl10_samlminorversion);
        }

        if (XblSamlToken.xbl10_samlissuer != xblSamlToken.Issuer)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_ISSUER, "; SAML Issuer attribute is {0}, but {1} is expected.", xblSamlToken.Issuer, XblSamlToken.xbl10_samlissuer);
        }

        // There should be only one SamlStatement
        if (1 != samlSecurityToken.Assertion.Statements.Count)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_COUNT, "; SAML Statement count is {0}, but 1 is expected.", samlSecurityToken.Assertion.Statements.Count);
        }

        // It should be of type SamlAttributeStatement
        if (!(samlSecurityToken.Assertion.Statements[0] is System.IdentityModel.Tokens.SamlAttributeStatement))
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_TYPE, "; SAML Statement type is {0}, but Type:System.IdentityModel.Tokens.SamlAttributeStatement is expected.", samlSecurityToken.Assertion.Statements[0].GetType());
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\wsclient3.cs ===
/*==========================================================================
 *
 *  wsclient3.cs
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;
using System.Xml;

using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;

using STF.common.mgmt;
using STF.common.service;
using STF.common.sql.sqlclient;

#if !NOCSPP
[assembly: XomAreaDefinition(XomAreaName.wsttrace)]
#endif

namespace STF.common.sql.webstore
{
    /// <summary>
    /// The WSTCommandType that determines how the command will be executed.
    ///
    /// Explained as follows:
    ///
    /// WRITEONLY_COMMANDTYPE       -   Use only Write database for the execution.
    /// READTHENWRITE_COMMANDTYPE   -   First use Read database for the execution and, if fail over, use Write database.
    /// READONLY_COMMANDTYPE        -   Use only Read database for the execution.
    /// WRITETHENREAD_COMMANDTYPE   -   First use Write database for the execution and, if fail over, use Read database.
    /// READORWRITE_COMMANDTYPE     -   Use any database (write or read) in the partition and, if fail over, use any other available database.
    ///                                 This balances database access equally.
    /// </summary>
    public enum CmdType : int
    {
        WRITEONLY_COMMANDTYPE       = WstFailoverMode.PrimaryOnly,
        READTHENWRITE_COMMANDTYPE   = WstFailoverMode.SecondaryThenPrimary,
        READONLY_COMMANDTYPE        = WstFailoverMode.SecondaryOnly,
        WRITETHENREAD_COMMANDTYPE   = WstFailoverMode.PrimaryThenSecondary,
        READORWRITE_COMMANDTYPE     = WstFailoverMode.PrimaryOrSecondary,
        WRITE_DEFAULT               = WstFailoverMode.DefaultWrite,
    }

    public enum ParamType : int
    {
        INPUT   = ParameterDirection.Input,
        OUTPUT  = ParameterDirection.Output,
        RETVAL  = ParameterDirection.ReturnValue,
        INOUT   = ParameterDirection.InputOutput
    }


    /// <summary>
    /// WsClient is a thin wrapper around the webstore and SqlClient
    /// classes.   It serves a few functions:
    ///   - according to webstore docs, at least one WstCommand should
    ///     be kept in memory at all times, to track initialization data.
    ///     this class holds one instance for each app used.
    ///   - default values are given in leiu of DbNull (null for strings
    ///     and datetimes, 0 for numeric values).   This saves the consumer
    ///     from having to check IsDbNull any time a column is accessed, and
    ///     the errors resulting from it if they dont check.
    ///   - exceptions thrown as a result of one of the Execute*() functions
    ///     include the stored proc and param values used in the call.
    ///   - stord proc and param values are also show in XomTrace statements.
    ///   - interface is fairly close to WSClient used for 2.1, so transition
    ///     pain from one to another should be minimal.
    /// </summary>
    ///

    public class WSClient : IDisposable
    {
        /// <summary>
        /// for testing only, never use it in server code
        /// </summary>
        public static string SiteName = String.Empty;

        // special values for Partition property
        //
        public const int ANY_PARTITION = -2;
        public const int ALL_PARTITIONS = -1;


        private WstConnection       _cxn        = null;
        private WstCommand          _cmd        = null;
        private WstTransaction      _txn        = null;
        WebstoreDeployment           _dep        = null;
        private int                 _txnNestLevel = 0;
        private bool                _isFirstParam = true;
        private CmdType             _mode = CmdType.WRITE_DEFAULT;
        private string              _simpleDbName = String.Empty;


        private StringBuilder       _paramString      = new StringBuilder();





        // uses CmdType for backwards compat.
        public WSClient(string  applicationName, CmdType cmdType) : this(applicationName, (WstFailoverMode)cmdType) {}

        public WSClient(string applicationName, WstFailoverMode failoverMode)
        {
            _simpleDbName = applicationName;

            // for testing only. In server code the SiteName should be always empty
            applicationName = SiteName + applicationName;

            _cxn = new WstConnection(applicationName);
            _cxn.Open();

            _cmd = _cxn.CreateCommand();
            _cmd.CommandType = CommandType.StoredProcedure;
            _cmd.WstFailoverMode = failoverMode;

            _dep = GetWebStoreDeployment(applicationName);

            _mode = (CmdType)failoverMode;
        }

        public WstCommand Command
        {
            get { return _cmd; }
        }

        public int SetHashVal(int val)
        {
            if(null != _txn)
            {
                throw new XRLException(HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_182, "Transaction in progress. Cannot change hash value!");
            }

            _cmd.Partition  = WstHash.GetHash(val, _dep.Partitions.Count);

            return _cmd.Partition;
        }

        public int SetHashVal(long val)
        {
            if(null != _txn)
            {
                throw new XRLException(HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_183, "Transaction in progress. Cannot change  hash value!");
            }

            _cmd.Partition = WstHash.GetHash(val, _dep.Partitions.Count);
            return _cmd.Partition;
        }

        public int SetHashVal(ulong val)
        {
            return SetHashVal((long)val);
        }

        public int SetHashVal(Puid val)
        {
            return SetHashVal((long) val);
        }

        public int SetHashVal(string val)
        {
            if(null != _txn)
            {
                throw new XRLException(HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_184, "Transaction in progress. Cannot change  hash value!");
            }

            // NOTE: hashing on string is forced to be case-insensitive!
            _cmd.Partition = WstHash.GetHash(val.ToLower(), _dep.Partitions.Count);
            return _cmd.Partition;
        }

        public int SetHashVal(Guid val)
        {
            _cmd.Partition = WstHash.GetHash(val, _dep.Partitions.Count);
            return _cmd.Partition;
        }

        public int CalcPartition( string val )
        {
            return WstHash.GetHash(val.ToLower(), _dep.Partitions.Count);
        }

        public int CalcPartition(int val)
        {
            return WstHash.GetHash(val, _dep.Partitions.Count);
        }

        public int CalcPartition(long val)
        {
            return WstHash.GetHash(val, _dep.Partitions.Count);
        }

        public int CalcPartition(ulong val)
        {
            return CalcPartition((long)val);
        }

        public int CalcPartition(Guid val)
        {
            return WstHash.GetHash(val, _dep.Partitions.Count);
        }

        public int GetPhysicalPartition(int logicalPartition)
        {
            return _cxn.GetSqlPartition(logicalPartition);
        }

        public int Partition
        {
            get { return _cmd.Partition; }
            set
            {
                if(null != _txn)
                {
                    throw new XRLException(HResult.XONLINE_E_DATABASE_TRANSACTION_ERROR, XEvent.Id.COMMON_CODE_185, "Transaction in progress. Cannot change  hash value!");
                }
                _cmd.Partition = value;
            }
        }

        public int PhysicalPartition
        {
            get { return (_cmd.PartitionType == WstPartitionType.Physical ? _cmd.Partition : _cmd.LastPartitionExecuted); }
            set
            {
                _cmd.PartitionType = WstPartitionType.Physical;
                _cmd.Partition = value;
            }
        }


        public WstPartitionType PartitionType
        {
            get { return _cmd.PartitionType; }
            set { _cmd.PartitionType = value; }
        }

        public int PhysicalPartitions
        {
            get { return _cxn.SqlPartitions.Count; }
        }

        public int LogicalPartitions
        {
            get { return _dep.Partitions.Count; }
        }

        public SqlParameterCollection Parameters {
            get { return _cmd.Parameters; }
        }

        /// <summary>
        /// Wrapper for AddParameter junk.  This version assumes INPUT parameter type.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="val">The value of the parameter</param>
        public void AddParameter(string name, Guid val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, Guid val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.UniqueIdentifier;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "='" + val.ToString() + "'");
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Wrapper for AddParameter junk.  This version assumes INPUT parameter type.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="val">The value of the parameter</param>
        public void AddParameter(string name, string val)
        {
            AddParameter(ParamType.INPUT, name, val, val.Length);
        }
        public void AddParameter(ParamType pt, string name, string val)
        {
            AddParameter(pt,name,val,val.Length);
        }
        public void AddParameter(ParamType pt, string name, string val, int len)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.NVarChar;
            param.Value = val;
            param.Size = len;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "='" + val + "'");
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Wrapper for AddParameter junk.  This version assumes INPUT parameter type.
        /// </summary>
        /// <param name="name">The name of the parameter</param>
        /// <param name="val">The value of the parameter</param>
        public void AddParameter(string name, byte[] val)
        {
            // The old wsclient wrapper would insert a single byte of 0 if the
            // given byte array was null.  Emulate that behavior here.
            // (use the full param list if you want to actually specify null)
            if ( val == null )
            {
                val = new byte[]{0x0};
            }
            AddParameter(ParamType.INPUT, name, val, (val == null ? 0 : val.Length));
        }
        public void AddParameter(ParamType pt, string name, byte[] val, int len)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Binary;
            param.Value = val;
            param.Size = len;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=0x" + ByteConvert.ToString(val));
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }


        }

        /// <summary>
        /// Overloaded method for ints.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, byte val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, byte val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.TinyInt;
            param.Value = val;

            _cmd.Parameters.Add(param);


            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for shorts.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, short val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, short val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.SmallInt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }


        /// <summary>
        /// Overloaded method for ushorts.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, ushort val)
        {
            AddParameter(ParamType.INPUT, name, (short)val);
        }
        public void AddParameter(ParamType pt, string name, ushort val)
        {
            AddParameter(pt, name, (short)val);
        }


        /// <summary>
        /// Overloaded method for ints.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, int val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, int val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Int;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for uints.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, uint val)
        {
            AddParameter(ParamType.INPUT, name, (int)val);
        }
        public void AddParameter(ParamType pt, string name, uint val)
        {
            AddParameter(pt, name, (int)val);
        }

        /// <summary>
        /// Overloaded method for longs.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, long val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, long val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.BigInt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for ulongs.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, ulong val)
        {
            AddParameter(ParamType.INPUT, name, (long)val);
        }
        public void AddParameter(ParamType pt, string name, ulong val)
        {
            AddParameter(pt, name, (long)val);
        }

        /// <summary>
        /// Overloaded method for doubles.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, double val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, double val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Float;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Overloaded method for decimal.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, decimal val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }

        public void AddParameter(ParamType pt, string name, decimal val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Decimal;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }

        }

        /// <summary>
        /// Overloaded method for DateTimes.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, DateTime val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, DateTime val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.DateTime;

            // force value within range of SqlDateTime
            val = (val < (DateTime)SqlDateTime.MinValue) ? (DateTime)SqlDateTime.MinValue : val;
            val = (val > (DateTime)SqlDateTime.MaxValue) ? (DateTime)SqlDateTime.MaxValue : val;

            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Overloaded method for XmlNode.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, XmlNode val)
        {
            AddParameter(ParamType.INPUT, name, val);
        }
        public void AddParameter(ParamType pt, string name, XmlNode val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.SqlDbType = SqlDbType.Xml;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Overloaded method for DataTable.  Always an INPUT parameter
        /// </summary>
        public void AddParameter(string name, string typeName, DataTable val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)ParamType.INPUT;
            param.SqlDbType = SqlDbType.Structured;
            param.TypeName = typeName;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (!_isFirstParam)
            {
                _paramString.Append(", ");
            }
            _paramString.Append(name + "=" + val);
            _isFirstParam = false;
        }

        /// <summary>
        /// Overloaded method for DbType'd Objects.  Unless noted, assumes INPUT parameter.
        /// </summary>
        public void AddParameter(string name, object val, DbType dbType)
        {
            AddParameter(ParamType.INPUT, name, val, dbType);
        }
        public void AddParameter(ParamType pt, string name, object val, DbType dbType)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.DbType = dbType;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val);
                if (pt == ParamType.OUTPUT) _paramString.Append(" output");
                _isFirstParam = false;
            }
        }

        /// <summary>
        /// Add object parameter. Useful if you want to pass a DBNull value for example. I
        /// opted to name this differently from 'AddParameter' to avoid conflicts.
        /// </summary>
        /// <param name="name">Name of the parameter.</param>
        /// <param name="val">Value to assign to the parameter.</param>
        public void AddParameterObject(string name, object val)
        {
            AddParameterObject(ParamType.INPUT, name, val);
        }
        public void AddParameterObject(ParamType pt, string name, object val)
        {
            SqlParameter param = new SqlParameter();
            param.ParameterName = name;
            param.Direction = (ParameterDirection)pt;
            param.Value = val;

            _cmd.Parameters.Add(param);

            if (pt != ParamType.RETVAL)
            {
                if (!_isFirstParam) _paramString.Append(", ");
                _paramString.Append(name + "=" + val.ToString());
                if (pt == ParamType.OUTPUT) _paramString.Append(" Output");
                _isFirstParam = false;
            }
        }

        public string GetStringParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_7, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (string) null : (string) param.Value);
        }

        public byte[] GetByteArrayParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_8, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (byte[])null : (byte[])param.Value);
        }

        public byte GetByteParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_9, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (byte) 0 : (byte) param.Value);
        }

        public short GetShortParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_10, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (short) 0 : (short) param.Value);
        }

        public int GetIntParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_11, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (int) 0 : (int)param.Value);
        }

        public long GetLongParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_12, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (long) 0 : (long) param.Value);
        }

        public double GetDoubleParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_13, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? (double) 0.0 : (double) param.Value);
        }

        public Guid GetGuidParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_13, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? Guid.Empty : (Guid)param.Value);
        }

        /// <summary>
        /// If the OUTPUT parameter is null, DateTime.MinValue is returned.
        /// Use IsNullParameter to determine if the DateTime parameter is
        /// actually null.
        /// </summary>
        public DateTime GetDateParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.MC_BAD_CODE_14, "No parameter found with the name " + name + "!");
            return (Convert.IsDBNull(param.Value) ? DateTime.MinValue : (DateTime) param.Value);
        }

        /// <summary>
        /// Used to determine if an OUTPUT parameter is null.
        /// </summary>
        public bool IsNullParameter(string name)
        {
            SqlParameter param = _cmd.Parameters[name];
            if (param == null) throw new XRLException(HResult.XONLINE_E_DATABASE_PARAMETER_NOT_FOUND, XEvent.Id.COMMON_CODE_85, "No parameter found with the name " + name + "!");
            return Convert.IsDBNull(param.Value);
        }

        public static bool IsDBNull(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.IsDBNull(ordinal);
        }

        public static long GetInt64(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.GetInt64(ordinal);
        }

        public static ulong GetUInt64(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return (ulong) rdr.GetInt64(ordinal);
        }

        public static int GetInt32(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.GetInt32(ordinal);
        }

        public static int? GetNullableInt32(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;
            return rdr.GetInt32(ordinal);
        }

        public static uint GetUInt32(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return (uint) rdr.GetInt32(ordinal);
        }

        public static short GetInt16(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.GetInt16(ordinal);
        }

        public static int? GetNullableInt16(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;
            return rdr.GetInt16(ordinal);
        }

        public static ushort GetUInt16(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return (ushort) rdr.GetInt16(ordinal);
        }

        public static byte GetByte(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.GetByte(ordinal);
        }

        public static byte[] GetBytes(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return GetBytes(rdr, ordinal);
        }

        public static byte[] GetNullableBytes(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;
            return GetBytes(rdr, ordinal);
        }

        private static byte[] GetBytes(WstDataReader rdr, int ordinal)
        {
            // find the number of bytes to be read
            long numBytes = rdr.GetBytes(ordinal, 0, null, 0, 0);

            // allocate the new buffer based on the size
            byte[] b = new byte[numBytes];

            // read the bytes
            rdr.GetBytes(ordinal, 0, b, 0, b.Length);

            return b;
        }

        public static string GetString(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.GetString(ordinal);
        }

        public static string GetNullableString(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;
            return rdr.GetString(ordinal);
        }

        public static DateTime GetDateTime(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.IsDBNull(ordinal) ? DateTime.MinValue : rdr.GetDateTime(ordinal);
        }

        public static DateTime? GetNullableDateTime(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;
            return rdr.GetDateTime(ordinal);
        }

        public static XmlNode GetXml(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);

            XmlDocument document = new XmlDocument();
            document.LoadXml(rdr.GetString(ordinal));
            return document.FirstChild;
        }

        public static XmlNode GetNullableXml(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            if (rdr.IsDBNull(ordinal)) return null;

            XmlDocument document = new XmlDocument();
            document.LoadXml(rdr.GetString(ordinal));
            return document.FirstChild;
        }

        public static Guid GetGuid(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.IsDBNull(ordinal) ? Guid.Empty : rdr.GetSqlGuid(ordinal).Value;
        }

        public static bool GetBoolean(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return rdr.IsDBNull(ordinal) ? false : rdr.GetBoolean(ordinal);
        }

        public static Puid GetPuid(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return (Puid) rdr.GetInt64(ordinal);
        }

        public static HResult GetHResult(WstDataReader rdr, string columnName)
        {
            int ordinal = rdr.GetOrdinal(columnName);
            return (HResult) (uint) rdr.GetInt32(ordinal);
        }

        public static int GetHashPartition(byte[] val, string wstApp)
        {
            return WstHash.GetHash(BitConverter.ToInt64(val, 0), GetPartitionCount(wstApp));
        }

        public static int GetHashPartition(string val, string wstApp)
        {
            return WstHash.GetHash(val.ToLower(), GetPartitionCount(wstApp));
        }

        public static int GetHashPartition(ulong val, string wstApp)
        {
            return GetHashPartition((long)val, wstApp);
        }

        public static int GetHashPartition(long val, string wstApp)
        {
            return WstHash.GetHash(val, GetPartitionCount(wstApp));
        }

        public static int GetPartitionCount(string wstApp)
        {
           WebstoreDeployment dep = GetWebStoreDeployment(wstApp);
           return dep.Partitions.Count;
        }

        public static int GetPhysicalPartitionCount(string wstApp)
        {
           WebstoreDeployment dep = GetWebStoreDeployment(wstApp);
           return dep.SQLFailSafeSets.Count;
        }

        public static WebstoreDeployment GetWebStoreDeployment(string applicationName)
        {
            WebstoreDeployment dep = null;

            string szSiteName = null;
            string szApplicationNameOnly = applicationName;
            string [] arrSiteAndApplication = applicationName.Split(new Char [] {'\\'});

            if (arrSiteAndApplication.Length > 1)
            {
                szSiteName = arrSiteAndApplication[0];
                szApplicationNameOnly = arrSiteAndApplication[1];
            }

            if (null != szSiteName && null != WebstoreMetaData.Instance.Sites[szSiteName])
            {
                dep = WebstoreMetaData.Instance.Sites[szSiteName].Deployments[szApplicationNameOnly];
            }
            else
            {
                dep = WebstoreMetaData.Instance.DefaultConfig.Deployments[szApplicationNameOnly];
            }

            return dep;
        }

        public static IEnumerable<int> GetPhysicalPartitions(string applicationName)
        {
            WebstoreDeployment wstDep = GetWebStoreDeployment(applicationName);
            foreach (WebstoreSQLFss sqlFss in wstDep.SQLFailSafeSets)
            {
                if ( sqlFss.Status == WebstoreFssStatus.NotDeployed )
                    continue;

                yield return sqlFss.FssId;
            }
        }

        public string GetCallSignature()
        {
            return StoredProc + " " + _paramString.ToString();
        }

        public void ClearParameters()
        {
            _isFirstParam = true;
            _cmd        = _cxn.CreateCommand();
            _cmd.WstFailoverMode = (WstFailoverMode)_mode;
            _paramString = new StringBuilder("");
        }

        /// <summary>
        /// The string SQL command to be executed.  In OLE DB this looks something
        /// like this: "{ call p_MySproc(?, ?) }".
        /// </summary>
        public string CommandText
        {
            get { return _cmd.CommandText; }
            set { _cmd.CommandText = value; }
        }


        /// <summary>
        /// The stored proc to be executed.
        /// </summary>
        public string StoredProc
        {
            get { return CommandText; }
            set { _cmd.CommandType = CommandType.StoredProcedure;  CommandText = value; }
        }

        /// <summary>
        /// The sql statement to be executed.
        /// </summary>
        public string CommandSql
        {
            get { return CommandText; }
            set { _cmd.CommandType = CommandType.Text;  CommandText = value; }
        }

        /// <summary>
        /// Used to start a transaction.
        /// </summary>
        public void BeginTransaction()
        {
            if(null != _txn || _txnNestLevel > 0)
            {
                throw new Exception("Transaction already started!");
            }

            _txn = _cxn.BeginTransaction();
            _txnNestLevel++;
        }

        /// <summary>
        /// Used to commit a transaction.
        /// </summary>
        public void CommitTransaction()
        {
            if(null == _txn)
            {
                throw new Exception("No transaction started!");
            }

            _txn.Commit();
            _txnNestLevel--;
            if (0 != _txnNestLevel)
            {
                throw new Exception("Transaction count should be 0!");
            }
            _txn = null;
        }

        /// <summary>
        /// Used to rollback a transaction.
        /// </summary>
        public void RollbackTransaction()
        {
            if(null == _txn)
            {
                throw new Exception("No transaction started!");
            }

            _txn.Rollback();
            _txnNestLevel--;
            if (0 != _txnNestLevel)
            {
                throw new Exception("Transaction count should be 0!");
            }
            _txn = null;
        }

        /// <summary>
        /// Used to Execute the given string on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public WstDataReader Execute(string cmd)
        {
            _cmd.CommandText = cmd;
            if (_txn != null)
            {
                _cmd.Transaction = _txn;
            }
            return Execute();
        }


        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public WstDataReader Execute()
        {
#if !NOCSPP
            Xom.Trace(XomAreaName.wsttrace, LogLevel.L_LOW, "Executing " + StoredProc + " " + _paramString.ToString());
#endif
            if (_txn != null)
            {
                _cmd.Transaction = _txn;
            }

            try {
                SprocFailure.HandleBehaviorInjection(_simpleDbName, StoredProc);
                return _cmd.ExecuteReader();
            }

            catch (Exception e) {
                HResult hr = SqlClient.GetHResult(e);

                throw new XRLException(
                    hr, GetEventId(hr), e,
                    "Error executing {0}\r\nParameters {1}", CommandText, _paramString.ToString()
                );
            }
        }


        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound, without returning a resultset.
        /// </summary>
        public int ExecuteNonQuery(string cmd)
        {
            this.CommandText = cmd;
            return this.ExecuteNonQuery();
        }

        public int ExecuteNonQuery()
        {
#if DEBUG && !NOCSPP
            Xom.Trace(XomAreaName.wsttrace, LogLevel.L_LOW, "Executing " + StoredProc + " " + _paramString.ToString() );
#endif
            try
            {
                if (_txn != null)
                {
                    _cmd.Transaction = _txn;
                }
                SprocFailure.HandleBehaviorInjection(_simpleDbName, StoredProc);
                return _cmd.ExecuteNonQuery();
            }
            catch (Exception e)
            {
                HResult hr = SqlClient.GetHResult(e);

                throw new XRLException(
                    hr, GetEventId(hr), e,
                    "Error executing {0}\r\nParameters {1}", CommandText, _paramString.ToString()
                );
            }
        }


        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound, returning the first column of the first row
        /// </summary>
        public object ExecuteScalar(string cmd)
        {
            this.CommandText = cmd;
            return this.ExecuteScalar();
        }

        public object ExecuteScalar()
        {
#if !NOCSPP
            Xom.Trace(XomAreaName.wsttrace, LogLevel.L_LOW, "Executing " + StoredProc + " " + _paramString.ToString());
#endif
            if (_txn != null)
            {
                _cmd.Transaction = _txn;
            }

            try {
                SprocFailure.HandleBehaviorInjection(_simpleDbName, StoredProc);
                return _cmd.ExecuteScalar();
            }
            catch (Exception e) {
                HResult hr = SqlClient.GetHResult(e);

                throw new XRLException(
                    hr, GetEventId(hr), e,
                    "Error executing {0}\r\nParameters {1}", CommandText, _paramString.ToString()
                );
            }
        }

        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound, without returning a resultset.
        /// </summary>
        public XmlReader ExecuteXmlReader(string cmd)
        {
            this.CommandText = cmd;
            return this.ExecuteXmlReader();
        }

        /// <summary>
        /// Used to Execute the property Cmd on the WebStore hash bucket
        /// to which the client is bound.
        /// </summary>
        public XmlReader ExecuteXmlReader()
        {
#if !NOCSPP
            Xom.Trace(XomAreaName.wsttrace, LogLevel.L_LOW, "Executing " + _cmd.CommandText + " " + _paramString.ToString());
#endif
            if (_txn != null)
            {
                _cmd.Transaction = _txn;
            }

            try {
                SprocFailure.HandleBehaviorInjection(_simpleDbName, StoredProc);
                return _cmd.ExecuteXmlReader();
            }
            catch (Exception e) {
                HResult hr = SqlClient.GetHResult(e);

                throw new XRLException(
                    hr, GetEventId(hr), e,
                    "Error executing {0}\r\nParameters {1}", CommandText, _paramString.ToString()
                );
            }
        }

        private XEvent.Id GetEventId(HResult hr)
        {
            switch (hr)
            {
                case HResult.XONLINE_E_DATABASE_TIMEOUT  :
                    return XEvent.Id.WEBSTORE_EXECUTE_TIMEOUT_ERROR;
                case HResult.XONLINE_E_DATABASE_DEADLOCK :
                    return XEvent.Id.WEBSTORE_EXECUTE_DEADLOCK_ERROR;

                default:
                    return XEvent.Id.WEBSTORE_EXECUTE_ERROR;
            }
        }

        public void Close()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (_cmd != null) _cmd.Dispose();
            if (_cxn != null) _cxn.Dispose();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XblSamlToken.cs ===
// 
// XblSamlToken.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Wrapper class for Xbl1.0 Saml Token
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using STF.common.exceptions;

namespace STF.common.service
{

public class XblSamlToken
{
    public const int xbl10_samlmajorversion     = 1;
    public const int xbl10_samlminorversion     = 1;
    public const string xbl10_samlissuer        = "http://sts.xboxlive.com";
    public const string ns_attribute_claims     = "http://xboxlive.com/claims";

    public const string subject_name_machine    = "XboxLive Machine security ticket";
    public const string subject_name_partner    = "XboxLive Partner security ticket";
    public const string subject_name_user       = "XboxLive User security ticket";
    
    public const string name_attribute_platformtype     = "PlatformType";
    public const string name_attribute_machineid        = "MachineID";
    public const string name_attribute_deviceid         = "DeviceID";
    public const string name_attribute_clientversion    = "ClientVersion";
    public const string name_attribute_titleid          = "TitleID";
    public const string name_attribute_titleversion     = "TitleVersion";
    public const string name_attribute_puid0 = "Puid0";
    public const string name_attribute_cid0 = "CID0";
    public const string name_attribute_xuid0 = "Xuid0";
    public const string name_attribute_gamertag0 = "Gamertag0";
    public const string name_attribute_tier0 = "Tier0";
    public const string name_attribute_country0 = "Country0";
    public const string name_attribute_privileges0 = "Privileges0";
    public const string name_attribute_partnerid0 = "PartnerID0";

    // Base strings, for iterating over all slots.
    public const string name_attribute_puid = "Puid{0}";
    public const string name_attribute_cid = "CID{0}";
    public const string name_attribute_xuid = "Xuid{0}";
    public const string name_attribute_gamertag = "Gamertag{0}";
    public const string name_attribute_tier = "Tier{0}";
    public const string name_attribute_country = "Country{0}";
    public const string name_attribute_privileges = "Privileges{0}";
    public const string name_attribute_partnerid = "PartnerID{0}";

    // Attributes
    protected SamlSecurityToken _samlSecurityToken;
    protected Dictionary<string, string> _claims = new Dictionary<string, string>();
    
    // Constructor
    public XblSamlToken( string samlToken )
    {
        _samlSecurityToken = XblSamlToken.GetTokenFromString(samlToken);

        // Populate the dictionary from token Attributes
        IList<SamlAttribute> samlAttributes = ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;
        
        foreach ( SamlAttribute samlAttribute in samlAttributes )
        {
            _claims.Add(samlAttribute.Name, samlAttribute.AttributeValues[0]);
        }
        
    }

    // Properties
    public IList<SamlAttribute> Attributes
    {
        get {
            return ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;
        }
    }

    public bool IsMachineTicket
    {
        get { 
            return (subject_name_machine==SubjectName);
        }
    }

    public bool IsPartnerTicket
    {
        get { 
            return (subject_name_partner==SubjectName);
        }
    }
    
    public bool IsUserTicket
    {
        get { 
            return (subject_name_user==SubjectName);
        }
    }
    
    public string Issuer
    {
        get {
            return _samlSecurityToken.Assertion.Issuer;
        }
    }
    
    public int MajorVersion
    {
        get {
            return _samlSecurityToken.Assertion.MajorVersion;
        }
    }
    
    public int MinorVersion
    {
        get {
            return _samlSecurityToken.Assertion.MinorVersion;
        }
    }
    
    public DateTime NotBefore
    {
        get {
            return _samlSecurityToken.Assertion.Conditions.NotBefore;
        }
    }

    public SamlSecurityToken SecurityToken
    {
        get {
            return _samlSecurityToken;
        }
    }
    
    public SamlSubject Subject
    {
        get {
            return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject;
        }
    }

    public string SubjectName
    {
        get {
            return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject.Name;
        }
    }
    
    public DateTime ValidTo
    {
        get {
            return _samlSecurityToken.ValidTo;
        }
    }

    // -------------------------------------------------------------------------------
    // Implementation static public
    // -------------------------------------------------------------------------------

    // -------------------------------------------------------------------------------
    // GetCertificateBySubjectName
    //
    // Used for SAML Token signing
    // -------------------------------------------------------------------------------
    static public X509Certificate2Collection GetCertificateBySubjectName(string certSubject, bool isPrivateKeyRequired, bool thereCanBeOnlyOne)
    {
        X509Certificate2Collection certificates;
        X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
        
        store.Open(OpenFlags.ReadOnly);
        
        try
        {
            // Find the certificate that matches the subject
            certificates = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
            // Make sure this list doesn't include any "near" matches
            for (int i = 0; i < certificates.Count; )
            {
                X509Certificate2 cert = certificates[i];
                string name = cert.SubjectName.Name;
                string commonName;

                int startCommonName = name.IndexOf("CN=") + 3;
                int endCommonName = name.IndexOf(",", startCommonName);
                if (-1 == endCommonName)
                {
                    commonName = name.Substring(startCommonName);
                }
                else
                {
                    commonName = name.Substring(startCommonName, endCommonName - startCommonName);
                }

                // Now check for an exact match on the name
                if (!string.Equals(certSubject, commonName, StringComparison.OrdinalIgnoreCase))
                {
                    certificates.RemoveAt(i);
                    cert.Reset();
                }
                else
                {
                    i++;
                }
            }
        }
        finally
        {
            store.Close();
        }
        if (certificates == null || certificates.Count == 0)
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "No certificates with subject {0} were found in the specified store ", certSubject);
        if (certificates.Count > 1 && thereCanBeOnlyOne)
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "Multiple certificates with subject {0} were found in the specified store ", certSubject);
        if (isPrivateKeyRequired)
        {
            foreach (X509Certificate2 certificate in certificates)
            {
                if (!certificate.HasPrivateKey)
                {
                    throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "Certificate with subject {0} doesn't have a private key", certSubject);
                }
            }
        }

        return certificates;
    }
    
    // -------------------------------------------------------------------------------
    // GetTokenFromString 
    //
    // Validates a string is in fact a SAML Token and returns the Token as read from 
    // the string.
    // -------------------------------------------------------------------------------
    public static SamlSecurityToken GetTokenFromString(
        string samlToken)
    {
        //SamlUtilInit();
        SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<SecurityToken>( new List<SecurityToken>() ), false);
        SamlSerializer serializer = new SamlSerializer();

        using (XmlReader reader = XmlReader.Create(new StringReader(samlToken)))
        {
            //this validates the signature and time windows, as well as format of conditions and attributes
            return serializer.ReadToken(reader, WSSecurityTokenSerializer.DefaultInstance, outOfBandTokenResolver);
        }
    }

    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    public string GetAttributeValue( string name )
    {
        return _claims[name];
    }

    // -------------------------------------------------------------------------------
    // TryGetAttributeValue 
    //
    // Gets the value associated with the specified key.
    // -------------------------------------------------------------------------------
    public bool TryGetAttributeValue( string name, out string value )
    {
        return _claims.TryGetValue(name, out value);
    }

    /// <summary>
    /// General SAML token validation entry point.
    /// </summary>
    /// <param name="allowedThumbprints"></param>
    /// <param name="clientCertThumbprint"></param>
    public void Validate(string[] allowedThumbprints, string certDeviceId)
    {
        XblSamlSecurityTokenAuthenticator xblSamlSecurityTokenAuthenticator = new XblSamlSecurityTokenAuthenticator( allowedThumbprints );
        
        xblSamlSecurityTokenAuthenticator.ValidateToken(this, certDeviceId);
    }

    /// <summary>
    /// This Validate entry point is specific to WM7 traffic through the AuthSG.
    /// </summary>
    /// <param name="certificateAuthority"></param>
    /// <param name="clientCertThumbprint"></param>
    public void Validate(X509Certificate2Collection certificateAuthorities, string certDeviceId )
    {
        string[] allowedThumbprints = new string[certificateAuthorities.Count];
        int i=0;
        foreach (X509Certificate2 certificateAuthority in certificateAuthorities)
        {
            allowedThumbprints[i] = certificateAuthority.Thumbprint;
            i++;
        }

        Validate( allowedThumbprints, certDeviceId);
        
        // Make sure the platform type is consistent with the claims
        if (XOn.XPLT_MOBILE != byte.Parse(GetAttributeValue(XblSamlToken.name_attribute_platformtype)))
        {
            string value;
            if (TryGetAttributeValue(XblSamlToken.name_attribute_machineid, out value))
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE, "; SAML Claim MachineID found PlatformType claim must be MOBILE.  MachineID {0} PlatformType {1}", value, GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            }
            if (TryGetAttributeValue(XblSamlToken.name_attribute_deviceid, out value))
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE, "; SAML Claim DeviceID found PlatformType claim must be MOBILE.  DeviceID {0} PlatformType {1}", value, GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            }
        }
    }
    
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\WireDataSerializer.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;

using STF.core.wiredata;
using STF.common.exceptions;

namespace STF.common.service
{
    using TypeSerializers = Dictionary<Type, Delegate>;

    // Thrown during WireDatainitialization for bad field types, bad attributes, etc.
    public sealed class WireInfoInitException : Exception
    {
        public WireInfoInitException(Type type, FieldInfo field, string message)
            :
            base(string.Format(
                    "Failed to initialize WireData serializer.\nClass: {0}\nField: {1}\nMessage: '{2}'",
                    type != null ? type.Name : "(n/a)",
                    field != null ? field.Name : "(n/a)",
                    message)) { }
    }

    internal sealed class RetvalBinder : Binder
    {
        Type _type;
        internal RetvalBinder(Type t)
        {
            _type = t;
        }

        public override FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, System.Globalization.CultureInfo culture)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override object ChangeType(object value, Type type, System.Globalization.CultureInfo culture)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void ReorderArgumentArray(ref object[] args, object state)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override MethodBase SelectMethod(
                                        BindingFlags bindingAttr,
                                        MethodBase[] match,
                                        Type[] types,
                                        ParameterModifier[] modifiers)
        {
            foreach (MethodBase m in match)
            {
                MethodInfo method = (MethodInfo)m;
                if (method.ReturnType == _type)
                    return m;
            }

            return null;
        }

        public override PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers)
        {
            throw new Exception("The method or operation is not implemented.");
        }
    }


    // The dynamic methods will have this signature.  We  will
    // use the following delegates to invoke and refer to them.

    public delegate void WireDataReadDelegate(WireData o, BinaryReader br);
    public delegate void WireDataWriteDelegate(WireData o, BinaryWriter bw);
    public delegate int WireDataSizeofDelegate(WireData o);
    public delegate void WireDataToStringDelegate(WireData o, StringBuilder sb, int indent);
    public delegate void WireDataValidateDelegate(WireData o);
    public delegate bool WireDataEncryptionRequiredDelegate(WireData o);

    // Generates, stores and provides access to the dynamic serialization methods 
    // generated for each WireDatatype
    public static class WireDataSerializerCache
    {
        // Dictionary of Serializers per WireDatatype
        static volatile Dictionary<Type, TypeSerializers> _typeSerializers = new Dictionary<Type, TypeSerializers>();
        static AssemblyBuilder _asmBdr;
        static ModuleBuilder _modBdr;

        static object _syncRoot = new object();

        sealed class WireDataTypeInfo
        {
            public Type type;
            public Dictionary<string, MethodBuilder> methodBuilders;
        }

        public static void GenerateSerializers(string assemblyName)
        {
            GenerateSerializers(assemblyName, Assembly.GetExecutingAssembly());
        }

        // Generate dynamic serializer methods for WireDatatypes.
        public static void GenerateSerializers(string assemblyName, params Assembly[] assemblies)
        {
            Version ver = typeof(WireDataSerializerCache).Assembly.GetName().Version;
            // Create a new dynamic assembly, a new dynamic module and a new dynamic type 
            // on the current AppDomain. Only one type will be used to hold all the 
            // dynaminc methods.
            string assemblyFileName = assemblyName + ".dll";
            AssemblyBuilder asmBdr = AppDomain.CurrentDomain.DefineDynamicAssembly(
                new AssemblyName(assemblyName) { Version = ver },
                AssemblyBuilderAccess.Save);

            ModuleBuilder modBdr = asmBdr.DefineDynamicModule(assemblyFileName, assemblyFileName);

            // Generate context objects for each WireDatatype in specified assembly. At the 
            // same time generate all method builders for each type. These can 
            // be used to generate calls to these methods before they are finished.
            foreach (Assembly assembly in assemblies)
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (type.IsSubclassOf(typeof(WireData)))
                    {
                        EmitMethodsForType(modBdr, type, null);
                    }
                }
            }

            asmBdr.Save(assemblyFileName);
        }
        class SerializerMethodOptions
        {
            public string Name;
            public BindingFlags GetMethodFlags = BindingFlags.Default;
            public Action<MethodBuilder, Type, FieldContext[]> EmitMethod;

            public Type DelegateType
            {
                get
                {
                    return _delegate;
                }
                set
                {
                    if (value != null && !value.IsSubclassOf(typeof(Delegate)))
                    {
                        throw new Exception("Type specified must be a delegate type");
                    }
                    _delegate = value;
                    if (_delegate != null)
                    {
                        GenerateTypes();
                    }
                }
            }

            public Type ReturnType
            {
                get; private set;
            }

            public Type[] ParamTypes
            {
                get; private set;
            }

            Type _delegate;

            void GenerateTypes()
            {
                var m = _delegate.GetMethod("Invoke");
                ReturnType = m.ReturnType;
                ParamTypes = m.GetParameters().Select(p => p.ParameterType).ToArray();
            }
        };

        static List<SerializerMethodOptions> _methodsList = new List<SerializerMethodOptions>
        {
            new SerializerMethodOptions
            {
                Name = "Read",
                DelegateType = typeof(WireDataReadDelegate),
                EmitMethod = ReadSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "Write",
                DelegateType = typeof(WireDataWriteDelegate),
                EmitMethod = WriteSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "SizeOf",
                DelegateType = typeof(WireDataSizeofDelegate),
                EmitMethod = SizeofSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "ToString",
                GetMethodFlags = BindingFlags.Public | BindingFlags.Static,
                DelegateType = typeof(WireDataToStringDelegate),
                EmitMethod = ToStringSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "Validate",
                DelegateType = typeof(WireDataValidateDelegate),
                EmitMethod = EmitMethodValidate,
            },
            new SerializerMethodOptions
            {
                Name = "IsEncryptionRequired",
                DelegateType = typeof(WireDataEncryptionRequiredDelegate),
                EmitMethod = EncryptionRequiredSerializer.EmitMethod,
            },
        };

        static void EmitMethodsForType(ModuleBuilder modBdr, Type type, Dictionary<Type, TypeSerializers> dict)
        {
            TypeBuilder typeBdr = modBdr.DefineType(
                type.FullName + "Serializer",
                TypeAttributes.AutoClass | TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);

            WireDataTypeInfo wdtype = new WireDataTypeInfo();
            wdtype.type = type;

            wdtype.methodBuilders = _methodsList
                            .Select(m => typeBdr.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, m.ReturnType, m.ParamTypes))
                            .ToDictionary(m => m.Name);

            // This is where most of the magic happens. Emit the IL for Read, Write and 
            // ToString methods.
            EmitMethods(wdtype);

            // All methods are done. Call CreateType() to finish generating the type.  
            // After this the methods are ready to be used.
            Type dynamicType = typeBdr.CreateType();

            if (dict != null)
            {
                // Store method delegates in order to be retrieved for later use.
                TypeSerializers serializers = (from m in _methodsList
                               let minfo = m.GetMethodFlags == BindingFlags.Default ? dynamicType.GetMethod(m.Name) : dynamicType.GetMethod(m.Name, m.GetMethodFlags)
                               select Delegate.CreateDelegate(m.DelegateType, minfo))
                              .ToDictionary(d => d.GetType());

                dict.Add(type, serializers);
            }
        }

        static void EnsureSerializersFor(Type t)
        {
            if (!_typeSerializers.ContainsKey(t))
            {
                lock (_syncRoot)
                {
                    if (!_typeSerializers.ContainsKey(t))
                    {
                        if (_asmBdr == null)
                        {
                            Version ver = typeof(WireDataSerializerCache).Assembly.GetName().Version;

                            _asmBdr = AppDomain.CurrentDomain.DefineDynamicAssembly(
                                new AssemblyName("WireDataSerializerAssembly") { Version = ver },
                                AssemblyBuilderAccess.Run);
                        }

                        if (_modBdr == null)
                        {
                            _modBdr = _asmBdr.DefineDynamicModule("WireDataSerializerModule");
                        }

                        Dictionary<Type, TypeSerializers> newSerializers = new Dictionary<Type, TypeSerializers>(_typeSerializers);
                        EmitMethodsForType(_modBdr, t, newSerializers);

                        // Since there is no single-writer semantic guaranteed by the dictionary, replacing the whole dictionary
                        // in one swoop.  volatile _typeSerializers guarantees that assignment is after object is complete.
                        _typeSerializers = newSerializers;
                    }
                }
            }
        }

        // Retrieve the serializer given the delegate type
        static internal T GetSerializerFor<T>(Type t)
            where T : class
        {
            EnsureSerializersFor(t);
            return (T)(object)_typeSerializers[t][typeof(T)];
        }

        // Store context about a field while a field is being processed.
        class FieldContext
        {
            public WireInfoAttribute wdattr = null;
            public FieldInfo field = null;
            public FieldContext sizeParam = null;
            public FieldContext sizeOf = null;
            public LocalBuilder encodedBlob = null;
        }

        private static void ListFieldsInSubclasses(Type type, List<FieldInfo> outlist)
        {
            if (type == typeof(WireData))
            {
                return;
            }

            ListFieldsInSubclasses(type.BaseType, outlist);

            FieldInfo[] fieldsRaw = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < fieldsRaw.Length; i++)
            {
                outlist.Add(fieldsRaw[i]);
            }
        }

        static MethodInfo GetConversionMethod(Type fromType, Type toType)
        {
            // Allow for conversion to exist on either class, source or destination.
            // Prefer explicit conversion to implicit conversion.
            return
                // class fromType { public static operator explicit toType(fromType); }
                fromType.GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public,
                             new RetvalBinder(toType), new Type[] { fromType }, null) ??
                // class toType { public static operator explicit toType(fromType); }
                toType.GetMethod("op_Explicit", new Type[] { fromType }) ??
                // class fromType { public static operator implicit toType(fromType); }
                fromType.GetMethod("op_Implicit", BindingFlags.Static | BindingFlags.Public,
                             new RetvalBinder(toType), new Type[] { fromType }, null) ??
                // class toType { public static operator implicit toType(fromType); }
                toType.GetMethod("op_Implicit", new Type[] { fromType });
        }

        // Emit IL for the Reader and Writer method for a WireDatatype.
        static void EmitMethods(
            WireDataTypeInfo wdtype)
        {
            try
            {
                //
                //if (wdtype.type.IsAbstract)
                //{
                //    throw new WireInfoInitException(wdtype.type, null, "Cannot directly serialize an abstract class");
                //}

                // Make a list of fields and do some preliminary checking.
                List<FieldContext> fields = new List<FieldContext>();
                List<FieldInfo> fieldsList = new List<FieldInfo>();
                ListFieldsInSubclasses(wdtype.type, fieldsList);
                foreach (FieldInfo fieldInfo in fieldsList)
                {
                    object[] customAttrs = fieldInfo.GetCustomAttributes(
                        typeof(WireInfoAttribute),
                        false);

                    WireInfoAttribute wdattr = customAttrs.Length == 1 ?
                        (WireInfoAttribute)customAttrs[0] :
                        WireInfoAttribute.None;

                    if (wdattr.Serialize)
                    {
                        bool supportedType =
                            (!fieldInfo.FieldType.IsArray && WireDataGenerator.IsSupportedFieldType(fieldInfo.FieldType)) ||
                            (fieldInfo.FieldType.IsArray && WireDataGenerator.IsSupportedFieldType(fieldInfo.FieldType.GetElementType()) && fieldInfo.FieldType != typeof(string[]));

                        // Determine if the field has a SerializeAs parameter that can be used to convert the datatype
                        Type fieldType = fieldInfo.FieldType.IsArray ? fieldInfo.FieldType.GetElementType() : fieldInfo.FieldType;
                        customAttrs = fieldType.GetCustomAttributes(typeof(WireInfoAttribute), false);
                        WireInfoAttribute fieldAttr = customAttrs.Length == 1 ? (WireInfoAttribute)customAttrs[0] : WireInfoAttribute.None;

                        if (!supportedType)
                        {
                            // If there is another type used for serialization, use that.
                            if (wdattr.SerializeAs == null && fieldAttr.SerializeAs == null)
                            {
                                throw new WireInfoInitException(wdtype.type,
                                    fieldInfo,
                                    "Type '" + fieldInfo.FieldType.FullName + "' not supported.");
                            }
                            else
                            {
                                // Going to stomp over the default, so allocate a new object.
                                if (wdattr == WireInfoAttribute.None && fieldAttr.SerializeAs != null)
                                {
                                    wdattr = new WireInfoAttribute();
                                }
                                wdattr.SerializeAs = wdattr.SerializeAs ?? fieldAttr.SerializeAs;

                                // Now that we know the type has a serializer, confirm that there are implicit conversion operators to the desired type.
                                if (!WireDataGenerator.IsSupportedFieldType(wdattr.SerializeAs) ||
                                    (WireDataGenerator.IsSupportedFieldType(wdattr.SerializeAs) && wdattr.SerializeAs == typeof(string)))
                                {
                                    throw new WireInfoInitException(wdtype.type,
                                        fieldInfo,
                                        "Type '" + fieldInfo.FieldType.FullName + "' which has SerializeAs type '" + wdattr.SerializeAs.FullName + "' which is not supported.");
                                }

                                if ( GetConversionMethod(fieldType, wdattr.SerializeAs) == null || GetConversionMethod(wdattr.SerializeAs, fieldType) == null )
                                {
                                    throw new WireInfoInitException(wdtype.type,
                                        fieldInfo,
                                        "Type '" + fieldInfo.FieldType.FullName + "' does not have conversion operators to and from SerializeAs type '" + wdattr.SerializeAs.FullName + "'.");
                                }
                            }
                        }
                        else if (wdattr.SerializeAs != null || fieldAttr.SerializeAs != null)
                        {
                            throw new WireInfoInitException(wdtype.type,
                                fieldInfo,
                                "Native Wiredata type " + fieldInfo.FieldType.FullName + " does not support SerializeAs");
                        }
                        else if (wdattr.NullTerminate && fieldInfo.FieldType != typeof(string))
                        {
                            throw new WireInfoInitException(wdtype.type,
                                fieldInfo,
                                "NullTerminate is only supported for string field types");
                        }
                    }

                    FieldContext fieldContext = new FieldContext();
                    fieldContext.wdattr = wdattr;
                    fieldContext.field = fieldInfo;
                    fields.Add(fieldContext);
                }

                // XB360CS 27492: TODO Still think this is not right, but can't change entire tree yet.  Code will do correct thing
                //if (fields.Count == 0)
                //{
                //    throw new WireInfoInitException(wdtype.type, null, "There are no fields to serialize");
                //}

                // Fill out dependencies. Fields with the SizeParam attribute are dependent on the 
                // field with that name. Fields in the SizeParam attribute must be defined before 
                // their dependents.
                for (int i = 0; i < fields.Count; i++)
                {
                    FieldContext fieldContext = fields[i];

                    if (!fieldContext.wdattr.Serialize)
                    {
                        continue;
                    }

                    if (fieldContext.wdattr.BigEndian)
                    {
                        Type typeParam = fieldContext.field.FieldType;
                        if (
                            !(
                              WireDataGenerator.IsSupportedBigEndianType(typeParam) ||
                              (typeParam.IsArray && WireDataGenerator.IsSupportedBigEndianType(typeParam.GetElementType())) ||
                              (typeParam.IsEnum && WireDataGenerator.IsSupportedBigEndianType(Enum.GetUnderlyingType(typeParam))) ||
                              (fieldContext.wdattr.SerializeAs != null && WireDataGenerator.IsSupportedBigEndianType(fieldContext.wdattr.SerializeAs)) 
                             )
                           )
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                "Field specifies a 'BigEndian' attribute has an unsupported " +
                                    "type. Valid types are: {short, ushort, int, uint, long, ulong (and enums based on those types), float, double, DateTime, or Guid, and arrays of the referenced types}."
                                   );
                        }
                    }

                    if (fieldContext.wdattr.SizeParam != null)
                    {
                        if (fieldContext.wdattr.ArraySize != -1)
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                String.Format("Field '{0}' can not have both a SizeParam and an ArraySize", fieldContext.field.Name));
                        }

                        for (int j = i - 1; j >= 0; j--)
                        {
                            if (fields[j].field.Name == fieldContext.wdattr.SizeParam)
                            {
                                Type typeSizeParam = fields[j].field.FieldType;
                                if (typeSizeParam != typeof(Byte) &&
                                   // typeSizeParam != typeof(SByte) &&
                                   typeSizeParam != typeof(Int16) &&
                                   typeSizeParam != typeof(UInt16) &&
                                   typeSizeParam != typeof(Int32) &&
                                   typeSizeParam != typeof(UInt32) &&
                                   typeSizeParam != typeof(Int64) &&
                                   typeSizeParam != typeof(UInt64))
                                {
                                    throw new WireInfoInitException(
                                        wdtype.type, fieldContext.field,
                                        string.Format(
                                            "Field '{0}' specified in 'SizeParam' attribute has an unsupported " +
                                            "type. Valid types are: {byte, short, ushort, int, uint, long, ulong}.",
                                            fieldContext.wdattr.SizeParam));
                                }

                                fieldContext.sizeParam = fields[j];
                                fields[j].sizeOf = fieldContext;
                                break;
                            }
                        }

                        if (fieldContext.sizeParam == null)
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                string.Format("Field '{0}' specified in 'SizeParam' attribute does not exist",
                                              fieldContext.wdattr.SizeParam));
                        }
                    }

                    if (fieldContext.wdattr.SizeParam == null && fieldContext.wdattr.ArraySize == -1
                        && (fieldContext.field.FieldType == typeof(string) || fieldContext.field.FieldType.IsArray))
                    {
                        for (int j = i - 1; j >= 0; j--)
                        {
                            if (fields[j].field.Name == fieldContext.field.Name + "Len")
                            {
                                Type typeSizeParam = fields[j].field.FieldType;
                                if (typeSizeParam != typeof(Byte) &&
                                   // typeSizeParam != typeof(SByte) &&
                                   typeSizeParam != typeof(Int16) &&
                                   typeSizeParam != typeof(UInt16) &&
                                   typeSizeParam != typeof(Int32) &&
                                   typeSizeParam != typeof(UInt32) &&
                                   typeSizeParam != typeof(Int64) &&
                                   typeSizeParam != typeof(UInt64))
                                {
                                    throw new WireInfoInitException(
                                        wdtype.type, fieldContext.field,
                                        string.Format(
                                            "Field '{0}' as length for field '{1}' has an unsupported " +
                                            "type. Valid types are: {byte, short, ushort, int, uint, long, ulong}.",
                                            fields[j].field.Name, fields[i].field.Name));
                                }

                                fieldContext.sizeParam = fields[j];
                                fields[j].sizeOf = fieldContext;
                                break;
                            }
                        }
                    }

                    if ((fieldContext.field.FieldType.IsArray || fieldContext.field.FieldType == typeof(string)) &&
                            fieldContext.sizeParam == null && fieldContext.wdattr.ArraySize == -1)
                    {
                        throw new WireInfoInitException(
                            wdtype.type, fieldContext.field,
                            String.Format("Field '{0}' must have either an ArraySize, a SizeParam or there must be a field named '{0}Len'.",
                                            fieldContext.field.Name));
                    }
                }

                // Emit the Reader and Writer methods
                FieldContext[] fieldsArray = fields.ToArray();

                foreach (var m in _methodsList)
                {
                    m.EmitMethod(wdtype.methodBuilders[m.Name], wdtype.type, fieldsArray);
                }
            }
            catch (WireInfoInitException e)
            {
                // An exception had occurred during initialization, but we can't report it now.  There is a possiblity that the method
                // will never be called, so there is no reason to throw the exception early.  Instead, emit throwing the exception in the
                // methods.

                foreach (var bdr in wdtype.methodBuilders.Values)
                {
                    new WireDataGenerator(bdr).EmitThrowException(e.Message);
                }
            }
            catch (Exception e)
            {
                throw new Exception("Unable to generate serializers for type '" + wdtype.type.Name + "'", e);
            }
        }

        class SerializerBase : WireDataGenerator
        {
            protected Type rootType { get; private set; }

            public SerializerBase(MethodBuilder builder, Type type) : base(builder)
            {
                rootType = type;
            }


            public void EmitSchemaVersionCheck(
                WireInfoAttribute wdattr,
                Action emitTask
            )
            {
                EmitMinMaxCheck(
                    wdattr.MinSchemaVersionVal, wdattr.MaxSchemaVersionVal,
                    delegate { Emit(OpCodes.Ldfld, typeof(WireData).GetField("SchemaVersion")); },
                    emitTask
                );
            }

            public void EmitArrayLength(
                FieldContext field
            )
            {
                EmitArrayLength(
                    LoadDelegate(field.field),
                    false
                );
            }
        }

        class EncryptionRequiredSerializer : SerializerBase
        {
            private EncryptionRequiredSerializer(MethodBuilder builder, Type type)
            : base (builder, type)
            {}

            private void Emit()
            {
                object[] attributes = rootType.GetCustomAttributes(typeof(WireDataEncryptionAttribute), true);
                if ((attributes == null) || (attributes.Length == 0))
                {
                    EmitZero();
                    Emit(OpCodes.Ret);
                    return;
                }

                EmitMethodHeader(rootType);

                // WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion)
                WireDataEncryptionAttribute attribute = (WireDataEncryptionAttribute)attributes[0];
                uint version = WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion).GetValueOrDefault();
                EmitConst((int)version);

                // this.SchemaVersion
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));

                // WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion) <= this.SchemaVersion
                //   There is no "less than or equals opcode, so doing instead:
                //   (WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion) > this.SchemaVersion) == false
                Emit(OpCodes.Cgt_Un);
                EmitZero();
                Emit(OpCodes.Ceq);
                Emit(OpCodes.Ret);
            }

            internal static void EmitMethod(MethodBuilder builder, Type type, FieldContext[] ignored)
            {
                (new EncryptionRequiredSerializer(builder, type)).Emit();
            }

        }

        class SizeofSerializer : SerializerBase
        {
            bool hdrCreated;
            int constLength;

            private SizeofSerializer(MethodBuilder builder, Type type)
            : base (builder, type)
            {}

            void EnsureHeaderCreated()
            {
                if (hdrCreated)
                    return;

                EmitMethodHeader(rootType);

                DeclareLocal(typeof(int));
                EmitZero();
                Emit(OpCodes.Stloc_1);

                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Ldnull);
                Emit(OpCodes.Stloc_2);

                hdrCreated = true;
            }

            static Dictionary<Type, int> serializeLens = new Dictionary<Type, int>
            {
                { typeof(bool), sizeof(bool) },
                { typeof(sbyte), sizeof(sbyte) },
                { typeof(byte), sizeof(byte) },
                { typeof(short), sizeof(short) },
                { typeof(ushort), sizeof(ushort) },
                { typeof(int), sizeof(int) },
                { typeof(uint), sizeof(uint) },
                { typeof(long), sizeof(long) },
                { typeof(ulong), sizeof(ulong) },
                { typeof(float), sizeof(float) },
                { typeof(double), sizeof(double) },
                { typeof(DateTime), sizeof(long) },
                { typeof(Guid), 16 },
                { typeof(decimal), 16 },            
            };

            static bool TryGetConstLengthFromType(
                Type type,
                out int len)
            {
                len = 0;

                if (type.IsEnum)
                {
                    type = Enum.GetUnderlyingType(type);
                }

                return serializeLens.TryGetValue(type, out len);
            }

            void EmitAddToLocalSize(Action loadAddend)
            {
                Emit(OpCodes.Ldloc_1);
                loadAddend();
                Emit(OpCodes.Add);
                Emit(OpCodes.Stloc_1);
            }

            void EmitIfSchemaVersionSensitive(FieldContext field, int len)
            {
                if (IsSchemaVersionSensitive(field))
                {
                    EnsureHeaderCreated();

                    EmitSchemaVersionCheck(
                        field.wdattr,
                        delegate()
                        {
                            EmitAddToLocalSize(
                                delegate()
                                {
                                    EmitConst(len);
                                });
                        });
                }
                else
                {
                    constLength += len;
                }
            }

            Action PrepareFieldForEmit(FieldContext field, out int sizeToAdd)
            {
                Type fieldType = field.field.FieldType;

                if (!fieldType.IsArray && field.wdattr.SerializeAs != null)
                {
                    fieldType = field.wdattr.SerializeAs;
                }

                sizeToAdd = 0;

                if (TryGetConstLengthFromType(fieldType, out sizeToAdd))
                {
                    return null;
                }
                else if (fieldType == typeof(char))
                {
                    return delegate()
                    {
                        EmitAddToLocalSize(
                            delegate()
                            {
                                EmitCall(OpCodes.Call, typeof(Encoding).GetProperty("UTF8").GetGetMethod(), null);
                                Emit(OpCodes.Ldloc_0);
                                if (field.wdattr.SerializeAs != null)
                                {
                                    Emit(OpCodes.Ldfld, field.field);
                                    EmitCall(
                                        OpCodes.Call,
                                        GetConversionMethod(field.field.FieldType, field.wdattr.SerializeAs),
                                        null);
                                    LocalBuilder l = DeclareLocal(field.wdattr.SerializeAs);
                                    Emit(OpCodes.Stloc, l);
                                    Emit(OpCodes.Ldloca, l);
                                }
                                else
                                {
                                    Emit(OpCodes.Ldflda, field.field);
                                }
                                EmitConst(1);
                                EmitCall(
                                    OpCodes.Callvirt,
                                    typeof(Encoding).GetMethod("GetByteCount", new Type[] { typeof(char*), typeof(int) }),
                                    null);
                            });
                    };
                }
                else if (fieldType == typeof(string))
                {
                    if (field.wdattr.ArraySize != -1)
                    {
                        sizeToAdd = field.wdattr.ArraySize;

                        if (field.wdattr.NullTerminate)
                        {
                            sizeToAdd++;
                        }

                        return null;
                    }
                    else
                    {
                        return delegate()
                        {
                            // Emit estimation of string size
                            EmitNullCheck(
                                    LoadDelegate(field.field),
                                    delegate() 
                                    {
                                        EmitAddToLocalSize(
                                        delegate()
                                        {
                                            EmitCall(OpCodes.Call, typeof(Encoding).GetProperty("UTF8").GetGetMethod(), null);
                                            EmitLoad(field.field);
                                            EmitCall(
                                                OpCodes.Callvirt,
                                                typeof(Encoding).GetMethod("GetByteCount", new Type[] { typeof(string) }),
                                                null);
                                            if (field.wdattr.NullTerminate)
                                            {
                                                EmitConst(1);
                                                Emit(OpCodes.Add);
                                            }
                                        });
                                });
                        };
                    }
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    return delegate()
                    {
                        EmitNullCheck(
                            LoadDelegate(field.field),

                            delegate()
                            {
                                EmitAddToLocalSize(
                                    delegate()
                                    {
                                        EmitLoad(field.field);
                                        if (field.wdattr.SerializeAs != null)
                                        {
                                            EmitCall(OpCodes.Call, GetConversionMethod(field.field.FieldType, field.wdattr.SerializeAs), null);
                                        }
                                        EmitCall(OpCodes.Callvirt, fieldType.GetProperty("SerializedSize").GetGetMethod(), null);
                                    });
                            });
                    };
                }
                else if (fieldType.IsArray)
                {
                    Type elemType = field.wdattr.SerializeAs ?? fieldType.GetElementType();

                    int outLen;
                    if (TryGetConstLengthFromType(elemType, out outLen))
                    {
                        // If there is a static arraysize parameter, then compute total length
                        if (field.wdattr.ArraySize != -1)
                        {
                            sizeToAdd = outLen * field.wdattr.ArraySize;
                            return null;
                        }
                        else
                        {
                            return delegate()
                            {
                                EmitNullCheck(
                                    LoadDelegate(field.field),
                                    delegate()
                                    {
                                        EmitAddToLocalSize(
                                            delegate()
                                            {
                                                EmitArrayLength(field);
                                                if (outLen != 1)
                                                {
                                                    EmitConst(outLen);
                                                    Emit(OpCodes.Mul);
                                                }
                                            });
                                    });
                            };
                        }
                    }
                    else
                    {
                        return delegate()
                        {
                            EmitNullCheck(
                                LoadDelegate(field.field),
                                delegate()
                                {
                                    // Iterate through fields to calculate size
                                    EmitIncrementalLoop(
                                        delegate(LocalBuilder l)
                                        {
                                            if (elemType.IsSubclassOf(typeof(WireData)))
                                            {
                                                EmitNullCheck(
                                                    delegate()
                                                    {
                                                        EmitLoad(field.field);
                                                        Emit(OpCodes.Ldloc, l);
                                                        Emit(OpCodes.Ldelem, elemType);
                                                    },
                                                    delegate()
                                                    {
                                                        EmitAddToLocalSize(
                                                            delegate()
                                                            {
                                                                EmitLoad(field.field);
                                                                Emit(OpCodes.Ldloc, l);
                                                                Emit(OpCodes.Ldelem, elemType);
                                                                if (field.wdattr.SerializeAs != null)
                                                                {
                                                                    EmitCall(OpCodes.Call, GetConversionMethod(fieldType.GetElementType(), field.wdattr.SerializeAs), null);
                                                                }
                                                                EmitCall(OpCodes.Callvirt, elemType.GetProperty("SerializedSize").GetGetMethod(), null);
                                                            });
                                                    },
                                                    null);
                                            }
                                            else
                                            {
                                                throw new Exception("unknown array size serializer: " + elemType.ToString());
                                            }
                                        },
                                        delegate(LocalBuilder l)
                                        {
                                            EmitArrayLength(field);
                                        });
                                });
                        };
                    }
                }
                else
                {
                    throw new Exception("unknown size serialization: " + fieldType.ToString());
                }
            }

            void Emit(FieldContext[] fields)
            {
                for (int i = 0; i < fields.Length; i++)
                {
                    FieldContext field = fields[i];

                    if (!field.wdattr.Serialize)
                    {
                        continue;
                    }

                    int len;
                    Action emitField = PrepareFieldForEmit(field, out len);

                    if (emitField == null)
                    {
                        EmitIfSchemaVersionSensitive(field, len);
                    }
                    else
                    {
                        EnsureHeaderCreated();

                        EmitSchemaVersionCheck(field.wdattr, emitField);
                    }

                }

                if (!hdrCreated)
                {
                    EmitConst(constLength);
                }
                else
                {
                    Emit(OpCodes.Ldloc_1);

                    if (constLength != 0)
                    {
                        EmitConst(constLength);
                        Emit(OpCodes.Add);
                    }
                }

                Emit(OpCodes.Ret);
            }

            internal static void EmitMethod(MethodBuilder builder, Type type, FieldContext[] fields)
            {
                (new SizeofSerializer(builder, type)).Emit(fields);
            }
        }

        class ToStringSerializer : SerializerBase
        {
            ToStringSerializer(MethodBuilder builder, Type type)
                : base (builder, type)
            {}

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new ToStringSerializer(builder, type)).Emit(fields);
            }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_1);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                EmitConst(WireData.C_INDENT);
                Emit(OpCodes.Add);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_2);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                EmitConst(2 * WireData.C_INDENT);
                Emit(OpCodes.Add);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_3);

                Emit(OpCodes.Ldarg_1);
                Emit(OpCodes.Ldstr, PrettyPrintTypeName(rootType) + " {");
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Pop);

                for (int i = 0; i < fields.Length; i++)
                {

                    if (!fields[i].wdattr.PrintToString)
                    {
                        continue;
                    }            

                    EmitDelegateCall(fields[i].field.Name);

                    Emit(OpCodes.Ldarg_1);
                    Emit(OpCodes.Ldloc_2);
                    EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                    Emit(OpCodes.Ldstr, fields[i].field.Name + "=");
                    EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                    EmitField(fields[i],
                        fields[i].field.FieldType,
                        LoadDelegate(fields[i].field),
                        LoadAddressDelegate(fields[i].field),
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_2);
                            EmitConst(WireData.C_INDENT);
                            Emit(OpCodes.Add);
                        });
                }

                Emit(OpCodes.Ldarg_1);

                Emit(OpCodes.Ldloc_1);
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Ldstr, "}");
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Pop);

                Emit(OpCodes.Ret);
            }

            void EmitField(FieldContext field, Type fieldType, Action loadElem, Action loadElemAddr, Action loadIndentSize)
            {
                bool needPop = true;
                if (fieldType == typeof(string))
                {
                    if (field.wdattr.LimitString)
                    {
                        // The call to LimitString will appropriately return "= null"
                        // WireData.LimitString(field)
                        loadElem();
                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                    }
                    else
                    {
                        Label labelExists = DefineLabel();
                        // field ?? " null"
                        loadElem();
                        Emit(OpCodes.Dup);
                        Emit(OpCodes.Brtrue_S, labelExists);
                        Emit(OpCodes.Pop);
                        Emit(OpCodes.Ldstr, " null");
                        MarkLabel(labelExists);
                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                    }

                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType.IsEnum)
                {
                    loadElem();
                    Emit(OpCodes.Box, fieldType);
                    EmitCall(OpCodes.Callvirt, typeof(object).GetMethod("ToString", Type.EmptyTypes), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType == typeof(DateTime))
                {
                    loadElemAddr();
                    Emit(OpCodes.Ldstr, "s");
                    EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("ToString", new Type[] { typeof(string) }), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType == typeof(HResult))
                {
                    loadElem();

                    EmitCall(OpCodes.Call, typeof(WireData).GetMethod("GetHrName"), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                // Handle structs, but not the primitive types (byte, int, etc.)  That case is handled later.
                else if (fieldType.IsValueType && !fieldType.IsPrimitive)
                {
                    // If super-cool ToString(StringBuilder, int) exists, use that.
                    MethodInfo func;

                    func = fieldType.GetMethod("ToString", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (func != null)
                    {
                        loadElemAddr();
                        EmitCall(OpCodes.Callvirt, func, null);
                    }
                    else
                    {
                        // No specific ToString method, calling object.ToString()
                        loadElem();
                        Emit(OpCodes.Box, fieldType);
                        EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);
                    }
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    Emit(OpCodes.Pop);
                    needPop = false;

                    EmitNullCheck(
                        loadElem,
                        delegate()
                        {
                            loadElem();
                            Emit(OpCodes.Ldarg_1);
                            loadIndentSize();
                            EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", new Type[] { typeof(StringBuilder), typeof(int) }), null);
                        },
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldstr, " null");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        });
                }
                else if (fieldType == typeof(byte[]))
                {
                    needPop = false;

                    loadElem();
                    Emit(OpCodes.Ldarg_2);
                    EmitConst(WireData.C_INDENT);
                    Emit(OpCodes.Add);
                    EmitConst(field.wdattr.LimitString.GetType(), field.wdattr.LimitString ? 1 : 0);
                    EmitConst(field.wdattr.MaskString.GetType(), field.wdattr.MaskString ? 1 : 0);
                    EmitCall(OpCodes.Call, typeof(WireData).GetMethod("ByteArrayToString", new Type[] { typeof(StringBuilder), typeof(byte[]), typeof(int), typeof(bool), typeof(bool) }), null);
                }
                else if (fieldType.IsArray)
                {
                    needPop = false;

                    Emit(OpCodes.Pop);
                    EmitNullCheck(
                        loadElem,
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            EmitStringConcat(
                                PrettyPrintTypeName(fieldType.GetElementType()) + "[",
                                new Action(
                                    delegate()
                                    {
                                        EmitArrayLength(loadElem, true);
                                    }),
                                "] {");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);

                            EmitArray(field, fieldType, loadElem);

                            // Emit closing brace
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldloc_2);
                            EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Ldstr, "}");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        },
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldstr, " null");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        });
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    needPop = false;
                    EmitField(field,
                        field.wdattr.SerializeAs,
                        delegate()
                        {
                            loadElem();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate()
                        {
                            LocalBuilder ltemp = DeclareLocal(field.wdattr.SerializeAs);
                            loadElem();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                            Emit(OpCodes.Stloc, ltemp);
                            Emit(OpCodes.Ldloca, ltemp);
                        },
                        loadIndentSize);
                }
                else
                {
                    if (IsSupportedHexStringType(field, fieldType))
                    {
                        EmitStringConcatAllStrings(
                            "0x",
                            new Action(
                                delegate()
                                {
                                    EmitHexValue(field, fieldType, loadElemAddr);
                                }));

                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        if (field.wdattr.LimitString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                    }
                    else if (field.wdattr.LimitString)
                    {
                        loadElemAddr();
                        EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);

                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                    }
                    else
                    {
                        MethodInfo m = typeof(StringBuilder).GetMethod("Append", new Type[] { fieldType });
                        if (m == null || (m != null && field.wdattr.MaskString))
                        {
                            loadElemAddr();

                            EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);
                            if (field.wdattr.MaskString)
                            {
                                EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                            }
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                        }
                        else
                        {
                            loadElem();

                            EmitCall(OpCodes.Callvirt, m, null);
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", Type.EmptyTypes), null);
                        }
                    }
                }

                if (needPop)
                {
                    Emit(OpCodes.Pop);
                }
            }

            static bool IsSupportedHexStringType(FieldContext field, Type fieldType)
            {
                return field.wdattr.HexString &&
                    (fieldType == typeof(byte) || fieldType == typeof(sbyte) ||
                    fieldType == typeof(short) || fieldType == typeof(ushort) ||
                    fieldType == typeof(int) || fieldType == typeof(uint) ||
                    fieldType == typeof(long) || fieldType == typeof(ulong));
            }

            void EmitHexValue(FieldContext field, Type fieldType, Action loadElemAddr)
            {
                string fieldFormat = null;
                if (fieldType == typeof(byte) || fieldType == typeof(sbyte))
                {
                    fieldFormat = "X2";
                }
                else if (fieldType == typeof(short) || fieldType == typeof(ushort))
                {
                    fieldFormat = "X4";
                }
                else if (fieldType == typeof(int) || fieldType == typeof(uint))
                {
                    fieldFormat = "X8";
                }
                else if (fieldType == typeof(long) || fieldType == typeof(ulong))
                {
                    fieldFormat = "X16";
                }

                loadElemAddr();
                Emit(OpCodes.Ldstr, fieldFormat);
                EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", new Type[] { typeof(string) }), null);
            }

            void EmitArray(FieldContext field, Type fieldType, Action loadElem)
            {
                Type elemType = fieldType.GetElementType();

                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        Emit(OpCodes.Ldarg_1);
                        EmitStringConcat(
                            new Action(
                                delegate()
                                {
                                    Emit(OpCodes.Ldloc_3);
                                }),
                            "[",
                            new Action(
                                delegate()
                                {
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(OpCodes.Box, typeof(int));
                                }),
                                "]=");
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);

                        EmitField(field,
                            fieldType.GetElementType(),
                            delegate()
                            {
                                loadElem();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelem, elemType);
                            },
                            delegate()
                            {
                                loadElem();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelema, elemType);
                            },
                            delegate()
                            {
                                Emit(OpCodes.Ldarg_2);
                                EmitConst(2 * WireData.C_INDENT);
                                Emit(OpCodes.Add);
                            });
                    },
                    delegate(LocalBuilder i)
                    {
                        EmitArrayLength(field);
                    });
            }
        }

        static bool IsSchemaVersionSensitive(FieldContext field)
        {
            return field.wdattr.MinSchemaVersionVal > UInt32.MinValue || field.wdattr.MaxSchemaVersionVal < UInt32.MaxValue;
        }

        // Emit the Read method
        class ReadSerializer : SerializerBase
        {
            ReadSerializer(MethodBuilder builder, Type type)
                : base(builder, type)
            { }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                // Emit the value of the UTF8Encoding that will be referenced throughout this method
                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Newobj, typeof(UTF8Encoding).GetConstructor(Type.EmptyTypes));
                Emit(OpCodes.Stloc_1);

                // Temp variable for string length comparisons
                DeclareLocal(typeof(int));

                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    EmitDelegateCall(rootType.Name + "." + fields[i].field.Name);

                    EmitSchemaVersionCheck(
                        fields[i].wdattr, delegate()
                        {
                            EmitField(fields[i],
                                fields[i].field.FieldType,
                                LoadDelegate(fields[i].field),
                                delegate(Action loadValue)
                                {
                                    Emit(OpCodes.Ldloc_0);
                                    loadValue();
                                    Emit(OpCodes.Stfld, fields[i].field);
                                });
                        });
                }

                Emit(OpCodes.Ret);
            }


            void EmitField(
                FieldContext field,
                Type fieldType,
                Action loadField,
                Action<Action> storeField)
            {
                EmitReadField(field, fieldType, true, loadField, storeField);
            }

            void EmitReadField(
                FieldContext field,
                Type fieldType,
                bool checkExists,
                Action loadField,
                Action<Action> storeField)
            {
                if (fieldType == typeof(byte[]))
                {
                    EmitReadBytes(field, field.field.FieldType, loadField, storeField);
                }
                else if (fieldType.IsArray)
                {
                    EmitReadArray(field, fieldType, loadField, storeField);
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    EmitReadField(
                        field,
                        field.wdattr.SerializeAs,
                        checkExists,
                        delegate()
                        {
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate(Action loadValue)
                        {
                            storeField(
                                delegate()
                                {
                                    loadValue();
                                    EmitCall(OpCodes.Call, GetConversionMethod(field.wdattr.SerializeAs, fieldType), null);
                                });
                        });
                }
                else if (fieldType == typeof(string))
                {
                    EmitReadString(field, loadField, storeField);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    EmitReadWireInfo(field, fieldType, loadField, checkExists, storeField);
                }
                else if (fieldType == typeof(DateTime))
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(typeof(long), null, field.wdattr.BigEndian);
                            EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("FromFileTimeUtc", new Type[] { typeof(long) }), null);
                        });
                }
                else if (fieldType == typeof(Guid))
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(typeof(byte[]),
                                delegate()
                                {
                                    EmitConst(16);
                                },
                                false);
                            if (field.wdattr.BigEndian)
                            {
                                EmitCall(OpCodes.Call, typeof(STF.common.utilities2.ByteOrder).GetMethod("RevertGuidBytesInline"), null);
                            }
                            Emit(OpCodes.Newobj, typeof(Guid).GetConstructor(new Type[] { typeof(byte[]) }));
                        });
                }
                else if (fieldType.IsEnum)
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(Enum.GetUnderlyingType(fieldType), null, field.wdattr.BigEndian);
                        });
                }
                else
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(fieldType, null, field.wdattr.BigEndian);
                        });

                    //check range
                    if (field.wdattr != null && field.wdattr.MaxSet)
                    {
                        Label labelIsGreater = DefineLabel();

                        loadField();
                        EmitConst(typeof(long), (int)field.wdattr.Max);
                        Emit(IsUnsignedFieldType(fieldType) ? OpCodes.Ble_Un_S : OpCodes.Ble_S, labelIsGreater);
                        EmitConst(typeof(uint), unchecked((int)HResult.E_INVALIDARG));
                        EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                        var err = String.Format("Field '{0}' has read value [{{0}}] which is greater than max value allowed [{1}]",
                                                    field.field.Name, field.wdattr.Max);
                        Emit(OpCodes.Ldstr, err);
                        EmitConst(1);
                        Emit(OpCodes.Newarr, typeof(object));
                        var arrayLocal = DeclareLocal(typeof(object[]));
                        Emit(OpCodes.Stloc, arrayLocal);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        EmitZero();
                        loadField();
                        Emit(OpCodes.Box, fieldType);
                        Emit(OpCodes.Stelem_Ref);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        Emit(OpCodes.Newobj, typeof(XblException).GetConstructor(new Type[] { typeof(HResult), typeof(string), typeof(object[]) }));
                        Emit(OpCodes.Throw);
                        MarkLabel(labelIsGreater);
                    }

                    if (field.wdattr != null && field.wdattr.MinSet)
                    {
                        Label labelIsLess = DefineLabel();

                        loadField();
                        EmitConst(typeof(long), (int)field.wdattr.Min);
                        Emit(IsUnsignedFieldType(fieldType) ? OpCodes.Bge_Un_S : OpCodes.Bge_S, labelIsLess);
                        EmitConst(typeof(uint), unchecked((int)HResult.E_INVALIDARG));
                        EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                        var err = String.Format("Field '{0}' has read value [{{0}}] which is less than min value allowed [{1}]",
                                                    field.field.Name, field.wdattr.Min);
                        Emit(OpCodes.Ldstr, err);
                        EmitConst(1);
                        Emit(OpCodes.Newarr, typeof(object));
                        var arrayLocal = DeclareLocal(typeof(object[]));
                        Emit(OpCodes.Stloc, arrayLocal);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        EmitZero();
                        loadField();
                        Emit(OpCodes.Box, fieldType);
                        Emit(OpCodes.Stelem_Ref);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        Emit(OpCodes.Newobj, typeof(XblException).GetConstructor(new Type[] { typeof(HResult), typeof(string), typeof(object[]) }));
                        Emit(OpCodes.Throw);
                        MarkLabel(labelIsLess);
                    }

                    if (field.sizeOf != null && field.sizeOf.wdattr.ArraySize != -1)
                    {
                        Label labelRead = DefineLabel();

                        loadField();
                        EmitConst(fieldType, field.sizeOf.wdattr.ArraySize);
                        Emit(OpCodes.Beq, labelRead);
                        loadField();
                        EmitZero(fieldType);
                        Emit(OpCodes.Beq, labelRead);
                        EmitThrowException(
                            delegate()
                            {
                                EmitStringConcat(
                                    "Field '" + field.field.Name + "' has read value [",
                                    new Action(
                                        delegate()
                                        {
                                            loadField();
                                            Emit(OpCodes.Box, fieldType);
                                        }
                                    ),
                                    "] that does not match it's ArraySize [" + field.sizeOf.wdattr.ArraySize + "]");
                            });

                        MarkLabel(labelRead);
                    }
                }
            }

            // Emit IL to read a string field
            void EmitReadString(FieldContext field, Action loadField, Action<Action> storeField)
            {
                LocalBuilder bytes = DeclareLocal(typeof(byte[]));

                EmitReadBytes(field, typeof(byte[]),
                    delegate()
                    {
                        Emit(OpCodes.Ldloc, bytes);
                    },
                    delegate(Action loadValue)
                    {
                        loadValue();
                        Emit(OpCodes.Stloc, bytes);
                    });

                storeField(
                    delegate()
                    {
                        EmitUtf8Decode(
                            delegate()
                            {
                                Emit(OpCodes.Ldloc, bytes);
                            });
                    });

                // Don't qualify the SubString() operation for the fields that would by metadata have extra nulls
                // For strings, the xbox360 will send up a null string as length 1 and '\0' as the character, instead
                // of null.  So, need to skip the check until it can be determined under what conditions the console
                // will send this.
                // if (field.wdattr.NullTerminate || field.wdattr.ArraySize != -1)
                // {
                Label labelSkipTask = DefineLabel();

                loadField();
                EmitZero();
                EmitCall(OpCodes.Callvirt, typeof(string).GetMethod("IndexOf", new Type[] { typeof(char) }), null);
                Emit(OpCodes.Stloc_2);
                Emit(OpCodes.Ldloc_2);
                EmitZero();
                Emit(OpCodes.Blt_S, labelSkipTask);

                storeField(
                    delegate()
                    {
                        loadField();
                        EmitZero();
                        Emit(OpCodes.Ldloc_2);
                        EmitCall(OpCodes.Callvirt, typeof(string).GetMethod("Substring", new Type[] { typeof(int), typeof(int) }), null);
                    });

                MarkLabel(labelSkipTask);
            }
            //        }

            // Emit IL to read a byte[] field
            void EmitReadBytes(FieldContext field, Type fieldType, Action loadField, Action<Action> storeField)
            {
                storeField(
                    delegate()
                    {
                        EmitBinaryRead(fieldType, delegate()
                        {
                            EmitFieldSize(field);
                        }, field.wdattr.BigEndian);
                    });

                Label labelValidSize = DefineLabel();

                EmitArrayLength(loadField);
                EmitFieldSize(field);

                if (field.wdattr.ArraySize != -1)
                {
                    Emit(OpCodes.Beq_S, labelValidSize);
                    EmitThrowException(typeof(EndOfStreamException),
                        delegate()
                        {
                            EmitStringConcat(
                                "Unable to read " + field.wdattr.ArraySize + " bytes for field '" + field.field.Name + "' from stream, ",
                                new Action(delegate()
                                {
                                    EmitArrayLength(loadField, true);
                                }),
                                " bytes read.");
                        });
                }
                else
                {
                    Emit(OpCodes.Bge_S, labelValidSize);
                    EmitThrowException(typeof(EndOfStreamException),
                        delegate()
                        {
                            EmitStringConcat(
                                "Unable to read ",
                                new Action(delegate()
                                {
                                    EmitLoad(field.sizeParam.field);
                                    Emit(OpCodes.Box, field.sizeParam.field.FieldType);
                                }),
                                " bytes for field '" + field.field.Name + "' from stream, ",
                                new Action(delegate()
                                {
                                    EmitArrayLength(loadField, true);
                                }),
                                " bytes read.");
                        });
                }
                MarkLabel(labelValidSize);

            }

            // Emit IL to read a array field
            void EmitReadArray(FieldContext field, Type fieldType, Action loadField, Action<Action> storeField)
            {
                // Create array and store it in the field
                Type elemType = fieldType.GetElementType();

                // Initialize the array even if the param is zero.
                storeField(
                    delegate()
                    {
                        EmitFieldSize(field);
                        Emit(OpCodes.Newarr, elemType);
                    });

                // Use loop to read and store each element in the array
                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        EmitDelegateCall(
                            delegate()
                            {
                                EmitStringConcat(
                                    field.field.DeclaringType.Name + "." + field.field.Name,
                                    "[",
                                    new Action(
                                        delegate()
                                        {
                                            Emit(OpCodes.Ldloc, i);
                                            Emit(OpCodes.Box, typeof(int));
                                        }),
                                        "]");
                            });
                        if (elemType.IsSubclassOf(typeof(WireData)))
                        {
                            EmitReadWireInfo(
                                field, elemType,
                                delegate()
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(OpCodes.Ldelem_Ref);
                                },
                                false,
                                delegate(Action loadValue)
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    loadValue();
                                    Emit(OpCodes.Stelem_Ref);
                                });
                        }
                        else
                        {
                            // Check to see if element load should use ref -- validation requires that
                            // SerializeAs can only be used with structs or objects (primitives don't have implicit
                            // conversion methods, so can't convert to SerializeAs class)
                            bool useRef = field.wdattr.SerializeAs != null && !elemType.IsValueType;
                            EmitReadField(
                                field,
                                elemType,
                                false,
                                delegate()
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(useRef ? OpCodes.Ldelem_Ref : OpCodes.Ldelem);
                                },
                                delegate(Action loadValue)
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    loadValue();
                                    if (useRef)
                                    {
                                        Emit(OpCodes.Stelem_Ref);
                                    }
                                    else
                                    {
                                        Emit(OpCodes.Stelem, elemType);
                                    }
                                });
                        }
                    },
                    delegate(LocalBuilder i)
                    {
                        EmitFieldSize(field);
                    });
            }

            // Emit IL to de-serialize a WireDataobject. The storeObject delegate is used to 
            // store the WireDataobject that was deserialized.
            void EmitReadWireInfo(
                FieldContext field,
                Type fieldType,
                Action loadObject,
                bool checkObjectExists,
                Action<Action> storeObject)
            {
                MethodInfo readMethod = fieldType.GetMethod(
                    "ReadStream",
                    BindingFlags.Public | BindingFlags.ExactBinding | BindingFlags.Instance,
                    null,
                    new Type[] { typeof(BinaryReader) },
                    new ParameterModifier[0]
                    );

                // In some cases, the value is assumed to exist, so there is no need to check and create the object.
                Label labelObjExists = DefineLabel();

                if (checkObjectExists)
                {
                    loadObject();
                    Emit(OpCodes.Dup);
                    Emit(OpCodes.Brtrue_S, labelObjExists);
                    Emit(OpCodes.Pop);
                }

                ConstructorInfo ci = fieldType.GetConstructor(Type.EmptyTypes);
                if (ci == null)
                {
                    throw new Exception(String.Format("Type {0} must have a public default (parameterless) constructor", fieldType.ToString()));
                }

                LocalBuilder lNew = DeclareLocal(fieldType);

                Emit(OpCodes.Newobj, ci);

                MarkLabel(labelObjExists);

                Emit(OpCodes.Stloc, lNew);

                Emit(OpCodes.Ldloc, lNew);
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                Emit(OpCodes.Stfld, typeof(WireData).GetField("SchemaVersion"));

                storeObject(
                    delegate()
                    {
                        // ret = var.ReadStream(stream) ?? var;
                        Emit(OpCodes.Ldloc, lNew);
                        Emit(OpCodes.Ldarg_1);

                        EmitCall(OpCodes.Callvirt, readMethod, null);

                        Label returnExists = DefineLabel();
                        Emit(OpCodes.Dup);

                        Emit(OpCodes.Brtrue_S, returnExists);
                        Emit(OpCodes.Pop);
                        Emit(OpCodes.Ldloc, lNew);
                        MarkLabel(returnExists);
                    });
            }

            // Emit IL that pushed the size of a field on the stack. For fields with constant 
            // length, IL to push a constant will be generated. For fields with the SizeParam 
            // attribute, the field referenced by the SizeParam will be pushed and converted to 
            // an int.
            void EmitFieldSize(FieldContext field)
            {
                if (field.wdattr.ArraySize != -1)
                {
                    // Size is a constant
                    EmitConst(field.wdattr.ArraySize + (field.wdattr.NullTerminate ? 1 : 0));
                }
                else if (field.sizeParam != null)
                {
                    // Size comes from another field
                    EmitLoad(field.sizeParam.field);
                    if (field.sizeParam.field.FieldType != typeof(int))
                    {
                        EmitConvert(typeof(int));
                    }
                }
                else
                {
                    throw new Exception();
                }
            }

            // Emit IL to invoke a BinaryReader.Read* method. Which method depends on the 
            // type of the field. For calls that take a parameter (ReadBytes), the fillParam 
            // delegate will be used to generate the code that pushed the parameter on the 
            // stack.
            void EmitBinaryRead(
                Type fieldType,
                Action fillParam,
                bool byteSwap)
            {

                MethodInfo readMethod =
                    fieldType == typeof(bool) ?
                        typeof(BinaryReader).GetMethod("ReadBoolean", Type.EmptyTypes) :
                    fieldType == typeof(char) ?
                        typeof(BinaryReader).GetMethod("ReadChar", Type.EmptyTypes) :
                    fieldType == typeof(byte) ?
                        typeof(BinaryReader).GetMethod("ReadByte", Type.EmptyTypes) :
                    fieldType == typeof(sbyte) ?
                        typeof(BinaryReader).GetMethod("ReadSByte", Type.EmptyTypes) :
                    fieldType == typeof(UInt16) ?
                        typeof(BinaryReader).GetMethod("ReadUInt16", Type.EmptyTypes) :
                    fieldType == typeof(Int16) ?
                        typeof(BinaryReader).GetMethod("ReadInt16", Type.EmptyTypes) :
                    fieldType == typeof(UInt32) ?
                        typeof(BinaryReader).GetMethod("ReadUInt32", Type.EmptyTypes) :
                    fieldType == typeof(Int32) ?
                        typeof(BinaryReader).GetMethod("ReadInt32", Type.EmptyTypes) :
                    fieldType == typeof(UInt64) ?
                        typeof(BinaryReader).GetMethod("ReadUInt64", Type.EmptyTypes) :
                    fieldType == typeof(Int64) ?
                        typeof(BinaryReader).GetMethod("ReadInt64", Type.EmptyTypes) :
                    fieldType == typeof(float) ?
                        typeof(BinaryReader).GetMethod("ReadSingle", Type.EmptyTypes) :
                    fieldType == typeof(double) ?
                        typeof(BinaryReader).GetMethod("ReadDouble", Type.EmptyTypes) :
                    fieldType == typeof(decimal) ?
                        typeof(BinaryReader).GetMethod("ReadDecimal", Type.EmptyTypes) :
                    fieldType == typeof(byte[]) ?
                        typeof(BinaryReader).GetMethod("ReadBytes", new Type[] { typeof(int) }) :
                    null;

                if (readMethod == null)
                {
                    throw new Exception(
                        string.Format("Field type {0} not supported",
                                      fieldType.ToString()));
                }

                Emit(OpCodes.Ldarg_1); // BinaryReader br

                if (fillParam != null)
                {
                    fillParam();
                }

                EmitCall(OpCodes.Callvirt, readMethod, null);

                if (byteSwap)
                {
                    EmitCall(OpCodes.Call, typeof(STF.common.utilities2.ByteOrder).GetMethod("Revert", new Type[] { fieldType }), null);
                }
            }

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new ReadSerializer(builder, type)).Emit(fields);
            }
        }

        // Emit the Write method
        class WriteSerializer : SerializerBase
        {
            WriteSerializer(MethodBuilder builder, Type type)
                : base(builder, type)
            { }

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new WriteSerializer(builder, type)).Emit(fields);
            }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                // Emit the value of the UTF8Encoding that will be referenced throughout this method
                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Newobj, typeof(UTF8Encoding).GetConstructor(Type.EmptyTypes));
                Emit(OpCodes.Stloc_1);

                // If we have any string fields, we need to encode them to UTF8 before we 
                // start serializing the fields.
                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    // Emit IL to encode a string field using UTF8 and store it in a local. The 
                    // LocalBuilder is stored in the FieldContext.encodedBlob.
                    if (fields[i].field.FieldType == typeof(string))
                    {
                        fields[i].encodedBlob = DeclareLocal(typeof(byte[]));

                        EmitNullCheck(
                            LoadDelegate(fields[i].field),
                            delegate()
                            {
                                EmitUtf8Encode(
                                    LoadDelegate(fields[i].field)
                                );
                                Emit(OpCodes.Stloc, fields[i].encodedBlob);
                            },
                            fields[i].wdattr.NullTerminate && fields[i].wdattr.ArraySize != -1 ?
                            delegate()
                            {
                                EmitZero();
                                Emit(OpCodes.Newarr, typeof(byte));
                                Emit(OpCodes.Stloc, fields[i].encodedBlob);
                            } :
                            (Action)null);
                    }
                }

                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    try
                    {
                        EmitSchemaVersionCheck(
                            fields[i].wdattr, delegate()
                            {
                                EmitField(
                                    fields[i],
                                    fields[i].field.FieldType,
                                    LoadDelegate(fields[i].field),
                                    LoadAddressDelegate(fields[i].field)
                                );
                            });
                    }
                    catch (Exception e)
                    {
                        throw new Exception("Unable to serialize field '" + fields[i].field.Name + "'", e);
                    }
                }

                Emit(OpCodes.Ret);
            }

            // Emit IL to serialize field
            void EmitField(
                FieldContext field,
                Type fieldType,
                Action loadField,
                Action loadFieldAddr)
            {
                if (field.encodedBlob != null)
                {
                    // This is an encoded string.
                    EmitFieldString(
                        field,
                        delegate()
                        {
                            Emit(OpCodes.Ldloc, field.encodedBlob);
                        });
                }
                else if (fieldType == typeof(byte[]))
                {
                    EmitFieldBytes(field, loadField);
                }
                else if (fieldType.IsArray)
                {
                    EmitFieldArray(field, fieldType, loadField);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    EmitWireInfo(field, fieldType, loadField);
                }
                else if (fieldType == typeof(DateTime))
                {
                    EmitBinaryWrite(
                        typeof(long),
                        delegate()
                        {
                            loadFieldAddr();
                            EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("ToFileTimeUtc", Type.EmptyTypes), null);
                        },
                        field.wdattr.BigEndian);
                }
                else if (fieldType == typeof(Guid))
                {
                    EmitBinaryWrite(
                        typeof(byte[]),
                        delegate()
                        {
                            loadFieldAddr();
                            EmitCall(OpCodes.Call, typeof(Guid).GetMethod("ToByteArray", Type.EmptyTypes), null);
                            if (field.wdattr.BigEndian)
                            {
                                EmitCall(OpCodes.Call, typeof(STF.common.utilities2.ByteOrder).GetMethod("RevertGuidBytesInline"), null);
                            }
                        },
                        false);
                }
                else if (field.sizeOf != null)
                {
                    EmitFieldArrayLen(field);
                }
                else if (fieldType.IsEnum)
                {
                    EmitBinaryWrite(Enum.GetUnderlyingType(fieldType), loadField, field.wdattr.BigEndian);
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    EmitField(
                        field,
                        field.wdattr.SerializeAs,
                        delegate()
                        {
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate()
                        {
                            LocalBuilder ltemp = DeclareLocal(field.wdattr.SerializeAs);
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                            Emit(OpCodes.Stloc, ltemp);
                            Emit(OpCodes.Ldloca, ltemp);
                        });
                }
                else
                {
                    EmitBinaryWrite(fieldType, loadField, field.wdattr.BigEndian);
                }
            }

            // Emit IL to serialize a WireDataobject. The loadObject delegate is used to 
            // push the WireDataobject to be serialized on the stack.
            void EmitWireInfo(FieldContext field, Type fieldType, Action loadObject)
            {
                MethodInfo writeMethod = fieldType.GetMethod(
                    "WriteStream",
                    BindingFlags.Public | BindingFlags.ExactBinding | BindingFlags.Instance,
                    null,
                    new Type[] { typeof(BinaryWriter) },
                    null
                    );


                Label labelObjExists = DefineLabel();

                loadObject();
                Emit(OpCodes.Brtrue, labelObjExists);
                EmitThrowException("Cannot deserialize null WireData field '" + field.field.Name + "'");
                //EmitThrowValidationException(WireData.ValidationExceptionEnum.WriteNullWireDataField, field.field.Name);


                MarkLabel(labelObjExists);

                LocalBuilder ltemp = null;

                loadObject();
                if (field.wdattr.SerializeAs != null)
                {
                    ltemp = DeclareLocal(fieldType);
                    Emit(OpCodes.Stloc, ltemp);
                    Emit(OpCodes.Ldloc, ltemp);
                }
                
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                Emit(OpCodes.Stfld, typeof(WireData).GetField("SchemaVersion"));

                if (field.wdattr.SerializeAs != null)
                {
                    Emit(OpCodes.Ldloc, ltemp);
                }
                else
                {
                    loadObject();
                }

                Emit(OpCodes.Ldarg_1);

                EmitCall(OpCodes.Callvirt, writeMethod, null);
            }

            // Emit IL to serialize a array field
            void EmitFieldArray(FieldContext field, Type fieldType, Action loadField)
            {
                Type elemType = fieldType.GetElementType();

                Label labelSkipWrite = DefineLabel();

                EmitLoad(field.field);
                Emit(OpCodes.Brfalse, labelSkipWrite);

                EmitValidateArraySize(field, elemType, loadField);

                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        EmitField(
                            field,
                            elemType,
                            delegate()
                            {
                                // Load element of field on the stack
                                loadField();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelem, elemType);
                            },
                            delegate()
                            {
                                // Load element of field on the stack
                                loadField();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelema, elemType);
                            });
                    },
                    delegate(LocalBuilder i)
                    {
                        // Load size of array on the stack to be compared against the loop 
                        // index
                        EmitArrayLength(loadField);
                    }
                );

                if (field.wdattr.ArraySize != -1)
                {
                    if (elemType.IsSubclassOf(typeof(WireData)) ||
                        (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs.IsSubclassOf(typeof(WireData))))
                    {
                        Label labelEndThrow = DefineLabel();
                        Emit(OpCodes.Br, labelEndThrow);
                        MarkLabel(labelSkipWrite);

                        EmitThrowException("Cannot serialize null wiredata field '" + field.field.Name + "'");
                        MarkLabel(labelEndThrow);
                    }
                    else
                    {
                        Label labelManualSize = DefineLabel();

                        MarkLabel(labelSkipWrite);
                        Emit(OpCodes.Ldloc_0);
                        Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                        Emit(OpCodes.Brtrue, labelManualSize);

                        // Emit the rest of the values if necessary
                        EmitIncrementalLoop(
                            delegate(LocalBuilder i)
                            {
                                EmitField(
                                    field,
                                    field.wdattr.SerializeAs ?? elemType,
                                    delegate()
                                    {
                                        EmitZero(field.wdattr.SerializeAs ?? elemType, false);
                                    },
                                    delegate()
                                    {
                                        EmitZero(field.wdattr.SerializeAs ?? elemType, true);
                                    });
                            },
                            delegate(LocalBuilder i)
                            {
                                Label labelNullArray = DefineLabel();
                                Label labelNullArrayEnd = DefineLabel();
                                EmitConst(field.wdattr.ArraySize);
                                loadField();
                                Emit(OpCodes.Brfalse, labelNullArray);
                                EmitArrayLength(loadField);
                                Emit(OpCodes.Br, labelNullArrayEnd);
                                MarkLabel(labelNullArray);
                                EmitZero();
                                MarkLabel(labelNullArrayEnd);
                                Emit(OpCodes.Sub);
                            }
                        );

                        MarkLabel(labelManualSize);
                    }
                }
                else
                {
                    MarkLabel(labelSkipWrite);
                }
            }

            void EmitFieldArrayLen(FieldContext field)
            {
                // If manual array size is set, just write the field directly, else write the stated values.

                Label labelElse = DefineLabel();
                Label labelEndIf = DefineLabel();

                Emit(OpCodes.Ldloc_0);
                Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                Emit(OpCodes.Brfalse, labelElse);

                EmitBinaryWrite(
                    field.field.FieldType,
                    LoadDelegate(field.field),
                    field.wdattr.BigEndian);

                Emit(OpCodes.Br, labelEndIf);
                MarkLabel(labelElse);
                // This is a string length parameter, emit the actual length of the array or this field if ManualArraySize is false
                // Need to emit the length of the item the field refers to at this point.

                EmitNullCheck(
                    // Loads field
                    delegate()
                    {
                        // Load the relevent object to check if the object is null
                        if (field.sizeOf.encodedBlob == null)
                        {
                            // This is a non-string array.
                            EmitLoad(field.sizeOf.field);
                        }
                        else
                        {
                            // Get the array that was loaded by the string.
                            Emit(OpCodes.Ldloc, field.sizeOf.encodedBlob);
                        }
                    },
                    // IsNotNull
                    delegate()
                    {
                        EmitBinaryWrite(
                            field.field.FieldType,
                            delegate()
                            {
                                if (field.sizeOf.wdattr.ArraySize == -1)
                                {
                                    // If the object is not null, then get the length
                                    if (field.sizeOf.encodedBlob == null)
                                    {
                                        // This is a non-string array.
                                        EmitLoad(field.sizeOf.field);
                                    }
                                    else
                                    {
                                        // Get the array that was loaded by the string.
                                        Emit(OpCodes.Ldloc, field.sizeOf.encodedBlob);
                                    }

                                    Emit(OpCodes.Ldlen);

                                    // This is to set as a default value assuming the object is null.
                                    // If the type is a string, and the NullTerminate is true, then start with
                                    // a default value of 1.
                                    if (field.sizeOf.encodedBlob != null && field.sizeOf.wdattr.NullTerminate)
                                    {
                                        EmitConst(1);

                                        // Since there actually is a length, add this to the initial
                                        // default value
                                        Emit(OpCodes.Add);
                                    }
                                }
                                else
                                {
                                    // The array will be a fixed size, so just emit that.
                                    EmitConst(field.sizeOf.wdattr.ArraySize);
                                }

                                if (field.field.FieldType != typeof(int))
                                {
                                    EmitClassConvert(typeof(int), field.field.FieldType);
                                }
                            },
                            field.wdattr.BigEndian);
                    },
                    // IsNull
                    delegate()
                    {

                        EmitBinaryWrite(
                            field.field.FieldType,
                            delegate()
                            {
                                EmitZero(field.field.FieldType);
                            },
                            false);
                    });

                MarkLabel(labelEndIf);
            }

            void EmitFieldBytes(
                FieldContext field,
                Action loadField)
            {
                Label labelSkipTask = DefineLabel();

                // Skip emit if the length of the byte array is not greater than 0
                loadField();
                Emit(OpCodes.Brfalse, labelSkipTask);

                EmitArrayLength(loadField);
                EmitZero();
                Emit(OpCodes.Ble, labelSkipTask);

                EmitValidateArraySize(field, typeof(byte), loadField);

                EmitBinaryWrite(typeof(byte[]), loadField, field.wdattr.BigEndian);

                MarkLabel(labelSkipTask);

                EmitFieldBytesEmptyElements(field, loadField);
            }

            // Emit IL to generate call to BinaryWriter.Write(*). The method used will depend 
            // on the type of the field to serialize. The loadField delegate will be used to 
            // push the field on the stack.
            void EmitBinaryWrite(
                Type dataType,
                Action loadField,
                bool byteSwap)
            {

                Emit(OpCodes.Ldarg_1); // BinaryWriter bw
                loadField();

                if (byteSwap)
                {
                    EmitCall(OpCodes.Call, typeof(STF.common.utilities2.ByteOrder).GetMethod("Revert", new Type[] { dataType }), null);
                }

                EmitCall(
                    OpCodes.Callvirt,
                    typeof(BinaryWriter).GetMethod("Write", new Type[] { dataType }),
                    null);
            }

            // Emit IL to generate call to BinaryWriter.Write(*) for encoded strings.
            void EmitFieldString(
                FieldContext field,
                Action loadField)
            {
                EmitNullCheck(
                    loadField,
                    delegate()
                    {
                        Label labelSkipWrite = DefineLabel();

                        EmitArrayLength(loadField);
                        EmitZero();
                        Emit(OpCodes.Ble, labelSkipWrite);

                        EmitValidateArraySize(field, typeof(byte), loadField);

                        EmitBinaryWrite(typeof(byte[]), loadField, field.wdattr.BigEndian);

                        MarkLabel(labelSkipWrite);

                        if (field.wdattr.NullTerminate)
                        {
                            // Load the null terminating zero if the attributes require null termination
                            EmitBinaryWrite(
                                typeof(byte),
                                delegate()
                                {
                                    EmitZero(typeof(byte));
                                },
                                false);
                        }
                    },
                    null);

                EmitFieldBytesEmptyElements(field, loadField);
            }

            void EmitFieldBytesEmptyElements(FieldContext field, Action loadField)
            {
                // Make sure to emit rest of length if required.
                if (field.wdattr.ArraySize != -1)
                {
                    Label labelManualSize = DefineLabel();

                    Emit(OpCodes.Ldloc_0);
                    Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                    Emit(OpCodes.Brtrue, labelManualSize);

                    Label labelDoBody = DefineLabel();
                    loadField();
                    Emit(OpCodes.Brfalse, labelDoBody);

                    EmitArrayLength(loadField);
                    EmitConst(field.wdattr.ArraySize);
                    Emit(OpCodes.Bge, labelManualSize);

                    MarkLabel(labelDoBody);
                    Label labelNullArray = DefineLabel();
                    Label labelNullArrayEnd = DefineLabel();
                    Emit(OpCodes.Ldarg_1); // BinaryWriter bw
                    EmitConst(field.wdattr.ArraySize);
                    loadField();
                    Emit(OpCodes.Brfalse, labelNullArray);
                    EmitArrayLength(loadField);
                    Emit(OpCodes.Br, labelNullArrayEnd);
                    MarkLabel(labelNullArray);
                    EmitZero();
                    MarkLabel(labelNullArrayEnd);
                    Emit(OpCodes.Sub);
                    Emit(OpCodes.Newarr, typeof(byte));
                    EmitCall(
                        OpCodes.Callvirt,
                        typeof(BinaryWriter).GetMethod("Write", new Type[] { typeof(byte[]) }),
                        null);

                    MarkLabel(labelManualSize);
                }
            }

            void EmitValidateArraySize(FieldContext field, Type elemType, Action loadField)
            {
                if (field.wdattr.ArraySize != -1)
                {
                    Label labelSkip = DefineLabel();
                    string message;

                    Emit(OpCodes.Ldloc_0);
                    Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                    Emit(OpCodes.Brtrue, labelSkip);
                    EmitArrayLength(loadField);
                    EmitConst(field.wdattr.ArraySize);
                    if (elemType.IsSubclassOf(typeof(WireData)) ||
                        (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs.IsSubclassOf(typeof(WireData))))
                    {
                        Emit(OpCodes.Beq, labelSkip);
                        message = "a differing number of elements to it's ArraySize [" + field.wdattr.ArraySize + "]";
                    }
                    else
                    {
                        Emit(OpCodes.Ble, labelSkip);
                        message = "too many items for it's ArraySize [" + field.wdattr.ArraySize + "]";
                    }

                    EmitThrowException(
                        delegate()
                        {
                            EmitStringConcat(
                                "Field '" + field.field.Name + "' contains [",
                                new Action(
                                    delegate
                                    {
                                        EmitArrayLength(loadField, true);
                                    }),
                                "] elements, " + message);
                        });
                    MarkLabel(labelSkip);
                }
            }
        }

        static void EmitMethodValidate(MethodBuilder validateBdr, Type type, FieldContext[] ignored)
        {
            SerializerBase wdgen = new SerializerBase(validateBdr, type);
            object[] attrs = type.GetCustomAttributes(typeof(WireInfoAttribute), false);

            if (attrs.Length == 1)
            {
                WireInfoAttribute wdattr = (WireInfoAttribute)attrs[0];
                if (wdattr.MinSchemaVersionVal > UInt32.MinValue || wdattr.MaxSchemaVersionVal < UInt32.MaxValue)
                {
                    wdgen.EmitMethodHeader(type);
                    wdgen.EmitSchemaVersionCheck(
                        wdattr,
                        delegate()
                        {
                            // If the version checks out, then return
                            wdgen.Emit(OpCodes.Ret);
                        });
                    wdgen.EmitConst(typeof(uint), unchecked((int)HResult.XONLINE_E_UNSUPPORTED_METHOD));
                    wdgen.EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                    wdgen.EmitConst(typeof(uint), unchecked((int)XEvent.Id.COMMON_HACK_81));
                    wdgen.EmitStringConcatAllStrings(
                        "WireData Request SchemaVersion ",
                        new Action(
                            delegate()
                            {
                                wdgen.EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                                wdgen.EmitCall(OpCodes.Call, typeof(WireInfoAttribute).GetMethod("VersionToString"), null);
                            }),
                        " not allowed: " + type.ToString());
                    wdgen.Emit(OpCodes.Newobj, typeof(XRLException).GetConstructor(new Type[] { typeof(HResult), typeof(XEvent.Id), typeof(string) }));
                    wdgen.Emit(OpCodes.Throw);
                }
                else
                {
                    // No schema version specific fields in the attribute, nothing to do.
                    wdgen.Emit(OpCodes.Ret);
                }
            }
            else
            {
                // if there is no attribute (since the attribute can only exist once) then there is no
                // restriction on version, and everything is valid
                wdgen.Emit(OpCodes.Ret);
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XCacheProxyProt.cs ===
/*==========================================================================
 *
 *  XCacheProxyProt.cs -- This module defines the wire protocol for cache service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Text;

namespace STF.common.service
{

    public enum XCacheLookupType : uint
    {
        eXUIDLookup = 1,
        eGamertagLookup,
        ePassportLookup,
        eTeamIDLookup,
        eTeamNameLookup
    };

    public enum XCacheResponseType : uint
    {
        eUserDataResponse = 1,
        eTeamDataResponse
    };

    public class XCacheDefs
    {
        public const uint XCACHE_PROTOCOL_VERSION_CURRENT = 1;
    }

// ------------------------------------------
//      Request messages
// ------------------------------------------

    public class XCacheRequestMsg : WireData
    {
        public uint dwTotalMsgSize;

        [WireInfo(Min=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT, Max=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT)]
        public uint dwVersion = XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT;

        public uint cdwRequests;

        [WireInfo(SizeParam="cdwRequests")]
        public XCacheLookupRequestHeader[] rgRequests;

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwTotalMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwTotalMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }
    };

    public class XCacheLookupRequestHeader : WireData
    {
        public uint dwMsgSize;
        public XCacheLookupType eLookupType;
        public uint cdwLookups;

        public XCacheLookupRequestHeader()
        {
        }
        public XCacheLookupRequestHeader(XCacheLookupType eType)
        {
            eLookupType = eType;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            return ReadStream(reader.BaseStream);
        }

        public override WireData ReadStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            base.ReadStream(new BinaryReader(stream));

            XCacheLookupRequestHeader derived = null;
            
            switch (eLookupType)
            {
            case XCacheLookupType.eXUIDLookup:
                derived = new XCacheXUIDLookupRequest();
                break;
            case XCacheLookupType.eGamertagLookup:
                derived = new XCacheGamertagLookupRequest();
                break;
            case XCacheLookupType.ePassportLookup:
                derived = new XCachePassportLookupRequest();
                break;
            case XCacheLookupType.eTeamIDLookup:
                derived = new XCacheTeamIDLookupRequest();
                break;
            case XCacheLookupType.eTeamNameLookup:
                derived = new XCacheTeamNameLookupRequest();
                break;
            default:
                throw new ApplicationException("XCacheLookupRequestHeader::ReadStream() unknown request type!");
            }

            stream.Position = startPos;
            return derived.ReadStreamInternal(stream);
        }

        public virtual WireData ReadStreamInternal(Stream stream)
        {
            return base.ReadStream(new BinaryReader(stream));
        }
    }

    public class XCacheXUIDLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public ulong[] rgqwXUIDs;

        public XCacheXUIDLookupRequest() : base(XCacheLookupType.eXUIDLookup)
        {
        }
    }

    public class XCacheGamertag : WireData
    {
        [WireInfo(ArraySize=(int)XOn.XONLINE_GAMERTAG_SIZE)]
        public string sGamertag;

        public XCacheGamertag()
        {
        }
        
        public XCacheGamertag(string gamertag)
        {
            sGamertag = gamertag;
        }
        
        public static implicit operator XCacheGamertag(string gamertag)
        {
            return  new XCacheGamertag(gamertag);
        }

        public static implicit operator string(XCacheGamertag xcgt)
        {
            return xcgt.sGamertag;
        }
    }

    public class XCacheGamertagLookupRequest : XCacheLookupRequestHeader
    {
        [WireInfo(Serialize=false)]
        public string[] rgszGamertags;

        [WireInfo(SizeParam="cdwLookups")]
        public XCacheGamertag[] rgXCGTs;

        public XCacheGamertagLookupRequest() : base(XCacheLookupType.eGamertagLookup)
        {
        }

        public override void WriteStream(BinaryWriter writer)
        {
            if (rgszGamertags != null)
            {
                rgXCGTs = Array.ConvertAll(rgszGamertags, delegate(string s) { return (XCacheGamertag)s; });
            }

            base.WriteStream(writer);
        }

        public override WireData ReadStreamInternal(Stream stream)
        {
            base.ReadStreamInternal(stream);

            rgszGamertags = Array.ConvertAll(rgXCGTs, delegate(XCacheGamertag xcgt) { return (string)xcgt; });

            return this;
        }
    }

    public class XCachePassportLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public ulong[] rgqwPassportPUIDs;

        public XCachePassportLookupRequest() : base(XCacheLookupType.ePassportLookup)
        {
        }
    }

    public class XCacheTeamNameLookupKey : WireData
    {
        [WireInfo(ArraySize=(int)XOn.MAX_TEAM_NAME_SIZE)]
        public string wszTeamName;
        public uint dwTitleID;

        public XCacheTeamNameLookupKey()
        {
        }
    }

    public class XCacheTeamIDLookupKey : WireData
    {
        public ulong qwTeamID;
        public uint dwTitleID;

        public XCacheTeamIDLookupKey()
        {
        }
    }

    public class XCacheTeamIDLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public XCacheTeamIDLookupKey[] rgTeams;

        public XCacheTeamIDLookupRequest() : base(XCacheLookupType.eTeamIDLookup)
        {
        }
    }

    public class XCacheTeamNameLookupRequest : XCacheLookupRequestHeader
    {       
        [WireInfo(SizeParam="cdwLookups")]
        public XCacheTeamNameLookupKey[] rgTeams;

        public XCacheTeamNameLookupRequest() : base(XCacheLookupType.eTeamNameLookup)
        {
        }
    }

// ------------------------------------------
//  Response messages
// ------------------------------------------

    public class XCacheResponseMsg : WireData
    {
        public uint dwTotalMsgSize;

        [WireInfo(Min=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT, Max=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT)]
        public uint dwVersion = XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT;

        public uint cdwResponses;

        [WireInfo(SizeParam="cdwResponses")]
        public XCacheLookupResponseHeader[] rgResponses;

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwTotalMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwTotalMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }
    }

    public class XCacheLookupResponseHeader : WireData
    {
        public uint dwMsgSize;
        public XCacheResponseType eResponseType;
        public uint cdwResponses;

        public XCacheLookupResponseHeader()
        {
        }
        public XCacheLookupResponseHeader(XCacheResponseType eType)
        {
            eResponseType = eType;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            return ReadStream(reader.BaseStream);
        }

        public override WireData ReadStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            base.ReadStream(new BinaryReader(stream));

            XCacheLookupResponseHeader derived = null;
            
            switch (eResponseType)
            {
            case XCacheResponseType.eUserDataResponse:
                derived = new XCacheUserLookupResponse();
                break;
            case XCacheResponseType.eTeamDataResponse:
                derived = new XCacheTeamLookupResponse();
                break;
            default:
                throw new ApplicationException("XCacheLookupResponseHeader::ReadStream() unknown response type!");
            }

            stream.Position = startPos;
            return derived.ReadStreamInternal(stream);
        }

        public WireData ReadStreamInternal(Stream stream)
        {
            return base.ReadStream(new BinaryReader(stream));
        }
    }

    public class XCacheUserLookupResponse : XCacheLookupResponseHeader
    {       
        [WireInfo(SizeParam="cdwResponses")]
        public XCacheUserResponseData[] rgUsers;

        public XCacheUserLookupResponse() : base(XCacheResponseType.eUserDataResponse)
        {
        }
    }

    public class XCacheTeamLookupResponse : XCacheLookupResponseHeader
    {       
        [WireInfo(SizeParam="cdwResponses")]
        public XCacheTeamResponseData[] rgTeams;

        public XCacheTeamLookupResponse() : base(XCacheResponseType.eTeamDataResponse)
        {
        }
    }

    public class XCacheUserResponseData : WireData
    {
        public ulong qwUserID;

        [WireInfo(ArraySize=(int)XOn.XONLINE_GAMERTAG_SIZE)]
        public string szGamertag;

        public ulong qwPassportPUID;
    }

    public class XCacheTeamResponseData : WireData
    {
        public ulong qwTeamID;

        [WireInfo(ArraySize=(int)XOn.MAX_TEAM_NAME_SIZE)]
        public string wszTeamName;

        public uint dwTitleID;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XCacheProxy.cs ===
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

using STF.common.config;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.XCacheProxy)]

namespace STF.common.service
{
	
    internal class XCacheConnection
    {
        protected Socket _sock = null;
        
        const int XCACHE_BUFFER_SIZE = 10000; //equals to xcache buffer size, any request/response should fit into that buffer

        protected DateTime _dtConnect;
        protected DateTime _dtExpire;

        [ThreadStatic]
        static protected Random _rand = null;
        
        public bool IsValidConnection()
        {
            return (_sock != null && _sock.Connected);
        }

        public bool IsExpired()
        {
            // re-query the config setting in case it has changed since we calculated the expire time.  use the maximum possible time in this case.
            DateTime dtExpire = _dtConnect.AddSeconds(1.5 * Config.GetDoubleSetting(Setting.xcache_connectionTimeoutSeconds));
            return ((_dtExpire.CompareTo(DateTime.Now) < 0) || (dtExpire.CompareTo(DateTime.Now) < 0));
        }

        public void Send ()
        {
            // do nothing
        }
        
        public bool Write (byte[] msg)
        {
            if ( IsValidConnection() )
            {
                _sock.Send(msg);
                return true;
            }
            
            Close();    

            throw new ApplicationException("XCacheConnection.Write(): connection not valid.");
        }
         
        public int ReceiveTimeoutMilliseconds
        {
            get
            {
                const int DefaultXCacheConnectionReceiveTimeoutMilliseconds = 10000; // 10 seconds
                int timeoutMs = 0;

                try
                {
                    timeoutMs = Config.GetIntSetting(Setting.xcache_connection_receive_timeout_milliseconds);
                }
                catch(Exception e) // log exception, use the default timeout instead
                {
                    Xom.NtEvent(XEvent.Id.XCACHECONNECTION_NO_RECEIVETIMEOUT_SETTING, e, "Cannot obtain xcache_connection_receive_timeout_milliseconds config setting, reverting to {0} ms default value instead.", DefaultXCacheConnectionReceiveTimeoutMilliseconds);
                    timeoutMs = DefaultXCacheConnectionReceiveTimeoutMilliseconds;
                }
                
                return timeoutMs;
            }
        }

        public int SendTimeoutMilliseconds
        {
            get
            {
                const int DefaultXCacheConnectionSendTimeoutMilliseconds = 10000; // 10 seconds
                int timeoutMs = 0;

                try
                {
                    timeoutMs = Config.GetIntSetting(Setting.xcache_connection_send_timeout_milliseconds);
                }
                catch(Exception e) // log exception, use the default timeout instead
                {
                    Xom.NtEvent(XEvent.Id.XCACHECONNECTION_NO_SENDTIMEOUT_SETTING, e, "Cannot obtain xcache_connection_send_timeout_milliseconds config setting, reverting to {0} ms default value instead.", DefaultXCacheConnectionSendTimeoutMilliseconds);
                    timeoutMs = DefaultXCacheConnectionSendTimeoutMilliseconds;
                }
                
                return timeoutMs;
            }
        }

        public void Init()
        {
            if (IsValidConnection())
            {
                return;
            }
            try
            {
                if (_rand == null)
                {
                    _rand = new Random();
                }
                
                _sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.xcache);
               
                _sock.Connect(ivii.IPAddressString, ivii.PortEnd);

                _sock.ReceiveTimeout = ReceiveTimeoutMilliseconds;
                _sock.SendTimeout = SendTimeoutMilliseconds;

                _dtConnect = DateTime.Now;

                // set the expiry time to be a random value in a window centered around the config setting time.  this prevents all connections from
                // timing out at the same time.
                _dtExpire = _dtConnect.AddSeconds((0.5 + _rand.NextDouble()) * Config.GetDoubleSetting(Setting.xcache_connectionTimeoutSeconds));
            }
            catch (Exception e)
            {
                Close();
                Xom.NtEvent(XEvent.Id.XCACHE_CLIENT_BROKEN_PIPE_2, e, "Cannot establish connection with Xcache server.");
            }
        }

        public byte[] Read()
        {
            if( IsValidConnection() )
            {
                // 4 bytes for size
                // NOTE: this only works because the first 4 bytes of XCacheResponseMsg is the total size of the message.
                byte[] headerBuf = new byte[4];

                int cTotalBytes = 0;
                while (cTotalBytes < 4)
                {
                    int cBytes = _sock.Receive(headerBuf, cTotalBytes, 4 - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XCacheConnection.Read(): Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                int dataSize = headerBuf[0]+ (headerBuf[1]<<8) + (headerBuf[2]<<16) + (headerBuf[3]<<24);
                
                // make a new buffer for header + data
                byte[] buf = new byte[dataSize];

                // copy the header
                for (int iHeader = 0; iHeader < 4; iHeader++)
                {
                    buf[iHeader] = headerBuf[iHeader];
                }
                
                while (cTotalBytes < dataSize)
                {
                    int cBytes = _sock.Receive(buf, cTotalBytes, dataSize - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XCacheConnection.Read(): Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                return buf;
            }

            Close();

            throw new ApplicationException("XCacheConnection.Read(): connection not valid.");
        }
       
        
        public void Close()
        {
            if (_sock != null)
            {
                try
                {
                    _sock.Shutdown(SocketShutdown.Both);
                    _sock.Close();
                }
                catch (SocketException)
                {
                    // eat any exception here.  we're closing anyway.
                }
                
                _sock = null;
            }
        }
    };

    internal class XCacheConnectionsPool
    {
 
        public static XCacheConnectionsPool Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (typeof(XCacheConnectionsPool))
                    {
                        if (instance == null)
                            instance = new XCacheConnectionsPool();
                    }                            
                }
                return instance;
            }
        }

        
        public void Shutdown()
        {
            // we should have _maxInst connections to close.
            for (int i =0 ; i< _maxInst; i++)
            {
                XCacheConnection xcc = null;
                do
                {
                    xcc = (XCacheConnection)_pool.Obtain();
                    if (xcc == null)
                    {
                        // wait for the connection to find its way back to the pool.
                        System.Threading.Thread.Sleep(100);
                    }
                }
                while (xcc == null);
                
                xcc.Close();
                xcc = null;
            }

            _pool = null;
        }
        
        public void ReleaseConnection(XCacheConnection xcc)
        {
            if (xcc.IsExpired())
            {
                xcc.Close();
            }
            _pool.Insert(xcc);
        }

        public XCacheConnection GetConnection()
        {
            XCacheConnection xcc = (XCacheConnection)_pool.Obtain();
            if (xcc != null)
            {
                if (xcc.IsExpired())
                {
                    xcc.Close();
                }
                xcc.Init();
            }
            
            return xcc;
        }

        private XCacheConnectionsPool()
        {
            Init();
        }
        private void Init()
        {
            _maxInst = Config.GetIntSetting(Setting.xcache_maxPipeConnections);            
            _pool = new FastPool(_maxInst * 2, false);

            for (int i =0 ; i< _maxInst; i++)
            {
                _pool.Insert(new XCacheConnection());
            }
        }        
        
        private static volatile XCacheConnectionsPool instance = null;
        private FastPool _pool = null;
        private int _maxInst;

    };
    
    public enum CacheType { StatChunk, FriendsPresence, UserSettings }

    public struct PUIDAndOwner
    {
        public PUIDAndOwner(ulong PUID, bool owner)
        {
            if (owner)
            {
                // Encode the fact that this is the owner in the high PUID bit
                _PUID = PUID | 0x8000000000000000;
            }
            else
            {
                _PUID = PUID;
            }
        }
        
        public bool Owner
        {
            get { return (_PUID & 0x8000000000000000) != 0; }
            set
            {
                if (value)
                {
                    _PUID = _PUID | 0x8000000000000000;
                }
                else
                {
                    _PUID = _PUID & 0x7fffffffffffffff;
                }
            }
        }
    
        public ulong PUID
        {
            get { return _PUID & 0x7fffffffffffffff; }
        }
    
        public ulong _PUID;
    }

    public static class XCache
    {    
        
        public const int _gamerTagLen = (int)XOn.XONLINE_GAMERTAG_SIZE;
        public const int _maxRecordsPerRequest = 1000;
        public const int _credentialTypePassport = 1;

        public static readonly string InvalidGamertag = "??????";

        private static XCacheResponseMsg SendXCacheRequest (XCacheRequestMsg request)
        {
            XCacheResponseMsg response;
            byte [] res = null;

            XCacheConnection pp = XCacheConnectionsPool.Instance.GetConnection();
            if ( null == pp )
            {
                throw new Exception( "XCacheProxy: Cannot perform an XCache lookup. No connections currently available. ");
            }

            try
            {
                bool fRetry = true;
                while (true)
                {    
                    try
                    {
                        MemoryStream ms = new MemoryStream();
                        request.WriteStream(ms);
                        
                        pp.Write(ms.ToArray());
                        pp.Send();
                        res = pp.Read();
                        ms.Flush();
                        ms.Position = 0;

                        response = new XCacheResponseMsg();
                        response.ReadBytes(res);

                        return response;
                    }
                    catch (Exception e)
                    {
                        pp.Close();

                        if (fRetry)
                        {
                            fRetry = false;
                            pp.Init();
                            continue;
                        }

                        Xom.NtEvent(XEvent.Id.XCACHE_SERVER_BUSY, e, "Exception occured");
                        throw;
                    }
                }
            }
            finally
            {
                XCacheConnectionsPool.Instance.ReleaseConnection(pp);
            }
        }

        public static bool IsInvalidGamertag(string gamertag)
        {
            return String.IsNullOrEmpty(gamertag) || InvalidGamertag.Equals(gamertag);
        }

        public static XCacheUserResponseData LookupUserByXUID(ulong xuid)
        {
            return LookupUsersByXUID(new ulong []{xuid})[0];
        }

        public static XCacheUserResponseData LookupUserByPassport(ulong passport)
        {
            return LookupUsersByPassport(new ulong []{passport})[0];
        }

        public static XCacheUserResponseData LookupUserByGamertag(string gamertag)
        {
            return LookupUsersByGamertag(new string []{gamertag})[0];
        }

        public static XCacheUserResponseData[] LookupUsersByXUID(ulong[] xuids)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheXUIDLookupRequest lookup = new XCacheXUIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwXUIDs = xuids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static XCacheUserResponseData[] LookupUsersByPassport(ulong[] passports)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = passports;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static XCacheUserResponseData[] LookupUsersByGamertag(string[] gamertags)
        {
            for (int i = 0; i < gamertags.Length; i++ )
            {                
                if ( gamertags[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("GamerTag passed " + gamertags[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest lookup = new XCacheGamertagLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgszGamertags = gamertags;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static ulong LookupPUID(string gamerTag)
        {
            if ( gamerTag == null || gamerTag.Length == 0 )
            {
                return 0;
            }
            
            string[] gamerTags = new string[1];
            gamerTags[0] = String.Copy( gamerTag );
            return (LookupPUIDs(gamerTags))[0];
        }
            
        public static ulong LookupPUID(ulong passportPuid)
        {
            if ( passportPuid == 0 )
            {
                return 0;
            }
            
            ulong[] passportPuids = new ulong[1];
            passportPuids[0] = passportPuid;
            return (LookupPUIDs(passportPuids))[0];
        }
            
        public static string LookupGamerTag(ulong puid)
        {
            if ( puid == 0 )
            {
                return InvalidGamertag;
            }

            ulong [] puids = new ulong[1];
            puids[0] = puid;
            return (LookupGamerTags( puids ))[0];
        }

        public static ulong ConvertWebIDToPassportPUID(byte[] webID)
        {
            return ((ulong)webID[0] |
                ((ulong)webID[1] << 8) |
                ((ulong)webID[2] << 16) |
                ((ulong)webID[3] << 24) |
                ((ulong)webID[4] << 32) |
                ((ulong)webID[5] << 40) |
                ((ulong)webID[6] << 48) |
                ((ulong)webID[7] << 56));
        }

        public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType, out uint[] rgdwUserFlags)
        {
            PUIDAndOwner[] puids = LookupWebID(webID, credType);
            
            rgdwUserFlags = new uint[puids.Length];
            for (int iPuid = 0; iPuid < puids.Length; iPuid++)
            {
                rgdwUserFlags[iPuid] = 0;
                XUIDAndTrust.SetUserFlagCountry(ref rgdwUserFlags[iPuid], XOn.XONLINE_COUNTRY_UNITED_STATES);
                XUIDAndTrust.SetUserFlagLanguage(ref rgdwUserFlags[iPuid], XOn.XC_LANGUAGE_ENGLISH);
                XUIDAndTrust.SetUserFlagTier(ref rgdwUserFlags[iPuid], XOn.XONLINE_TIER_GOLD);
            }

            return puids;
        }
        
        public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = new ulong[] {ConvertWebIDToPassportPUID(webID)};

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            if (userResponse.rgUsers[0].qwUserID != 0)
            {
                PUIDAndOwner[] puids = new PUIDAndOwner[1];
                puids[0]._PUID = userResponse.rgUsers[0].qwUserID;
                puids[0].Owner = true;
                                
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupWebID for WebId = " + ByteConvert.ToReverseString(webID) + " Result = " + puids[0]._PUID);
                return puids;
            }
            
            return new PUIDAndOwner[0];
      }

        public static PUIDAndOwner LookupWebID(byte[] webID, string GamerTag, uint credType)
        {
            PUIDAndOwner puid = new PUIDAndOwner(0, false);
            if (GamerTag.Length >= _gamerTagLen)
            {
                throw new ArgumentException("GamerTag passed " + GamerTag + " is too long");
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest gamertagLookup = new XCacheGamertagLookupRequest();
            XCachePassportLookupRequest passportLookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{gamertagLookup, passportLookup};
            gamertagLookup.rgszGamertags = new string[]{GamerTag};
            passportLookup.rgqwPassportPUIDs = new ulong[]{ConvertWebIDToPassportPUID(webID)};

            XCacheResponseMsg response = SendXCacheRequest(request);

            // responses come back in the order they were sent.  see XCacheRequestMsg.WriteStream() .
            XCacheUserLookupResponse gamertagResponse = (XCacheUserLookupResponse)response.rgResponses[0];
            XCacheUserLookupResponse passportResponse = (XCacheUserLookupResponse)response.rgResponses[1];
            if (gamertagResponse.rgUsers[0].qwUserID == passportResponse.rgUsers[0].qwUserID)
            {
                puid._PUID = gamertagResponse.rgUsers[0].qwUserID;
                puid.Owner = true;
            }

            Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupWebID for WebId = " + (ByteConvert.ToReverseString(webID)) + " gamerTag = [" + GamerTag + "] Result = [" + puid._PUID + "]");

            return puid;
        }
         
        public static ulong[] LookupPUIDs(string[] gamerTags)
        {
            ulong[] puids = null;
            if ( gamerTags == null || gamerTags.Length == 0 )
            {
                throw new ArgumentException("gamerTags == null or gamerTags.Length == 0");
            }

            if ( gamerTags.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_1, "Number of input parameters " + gamerTags.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + gamerTags.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }
            
            for (int i = 0; i < gamerTags.Length; i++ )
            {                
                if ( gamerTags[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("GamerTag passed " + gamerTags[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest lookup = new XCacheGamertagLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgszGamertags = gamerTags;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            puids = new ulong[userResponse.cdwResponses];
            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                puids[iResult] = userResponse.rgUsers[iResult].qwUserID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupPUIDs " + iResult + ": " + gamerTags[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }
     
        public static ulong[] LookupPUIDs(ulong[] passportPuids)
        {
            ulong[] puids = null;

            if ( passportPuids == null || passportPuids.Length == 0 )
            {
                throw new ArgumentException("passportPuids == null or passportPuids.Length == 0");
            }

            if ( passportPuids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_7, "Number of input parameters " + passportPuids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + passportPuids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = passportPuids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            puids = new ulong[userResponse.cdwResponses];
            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                puids[iResult] = userResponse.rgUsers[iResult].qwUserID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupPUIDs " + iResult + ": " + passportPuids[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }
     
        public static string[] LookupGamerTags(ulong[] puids)
        {
            string[] gamerTags = null;
            if ( puids == null || puids.Length == 0 )
            {
                throw new ArgumentException("puids == null or puids.Length == 0");
            }

            if ( puids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_3, "Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            gamerTags = new string[puids.Length];
            for ( int i = 0; i < puids.Length; i++ )
            {
                gamerTags[i] = InvalidGamertag;
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheXUIDLookupRequest lookup = new XCacheXUIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwXUIDs = puids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                if (userResponse.rgUsers[iResult].szGamertag != null && userResponse.rgUsers[iResult].szGamertag.Length > 0)
                {
                    gamerTags[iResult] =  userResponse.rgUsers[iResult].szGamertag;
                }
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupGamerTags " + iResult + ": " + puids[iResult] + " - " + gamerTags[iResult]);
            }
            
            return gamerTags;
        }
     
        public static ulong LookupTeamPUID( uint titleId, string teamName )
        {
            if ( teamName == null || teamName.Length == 0 )
            {
                return 0;
            }
            string[] teamNames = new string[1];
            teamNames[0] = String.Copy( teamName );
            return (LookupTeamPUIDs( titleId, teamNames ))[0];
        }
            
            
        public static string LookupTeamName(uint titleId, ulong puid)
        {
            if ( puid == 0 )
            {
                return "";
            }
            ulong[] puids = new ulong[1];
            puids[0] = puid;
            return (LookupTeamNames(titleId, puids)[0]);
        }

        public static ulong[] LookupTeamPUIDs(uint titleId, string[] teamNames)
        {
            ulong[] puids = null;
            if ( teamNames == null || teamNames.Length == 0 )
            {
                throw new ArgumentException("teamNames == null or teamNames.Length == 0");
            }

            if ( teamNames.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_4, "Number of input parameters " + teamNames.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + teamNames.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }
            
            for (int i = 0; i < teamNames.Length; i++ )
            {                
                if ( teamNames[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("team name passed " + teamNames[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheTeamNameLookupRequest lookup = new XCacheTeamNameLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgTeams = new XCacheTeamNameLookupKey[teamNames.Length];
            for (int iTeam = 0; iTeam < teamNames.Length; iTeam++)
            {
                lookup.rgTeams[iTeam] = new XCacheTeamNameLookupKey();
                lookup.rgTeams[iTeam].dwTitleID = titleId;
                lookup.rgTeams[iTeam].wszTeamName = teamNames[iTeam];
            }

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheTeamLookupResponse teamResponse = (XCacheTeamLookupResponse)response.rgResponses[0];

            puids = new ulong[teamResponse.cdwResponses];
            for (int iResult = 0; iResult < puids.Length; iResult++)
            {
                puids[iResult] = teamResponse.rgTeams[iResult].qwTeamID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupTeamPUIDs " + iResult + ": " + teamNames[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }


        public static string[] LookupTeamNames(uint titleId, ulong[] puids)
        {
            string[] teamNames = null;
            if ( puids == null || puids.Length == 0 )
            {
                throw new ArgumentException("puids == null or puids.Length == 0");
            }

            if ( puids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_6, "Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            teamNames = new string[puids.Length];

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheTeamIDLookupRequest lookup = new XCacheTeamIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgTeams = new XCacheTeamIDLookupKey[puids.Length];
            for (int iTeam = 0; iTeam < puids.Length; iTeam++)
            {
                lookup.rgTeams[iTeam] = new XCacheTeamIDLookupKey();
                lookup.rgTeams[iTeam].dwTitleID = titleId;
                lookup.rgTeams[iTeam].qwTeamID = puids[iTeam];
                teamNames[iTeam] = String.Copy("");
            }

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheTeamLookupResponse teamResponse = (XCacheTeamLookupResponse)response.rgResponses[0];

            for (int iResult = 0; iResult < teamResponse.cdwResponses; iResult++)
            {
                if (teamResponse.rgTeams[iResult].wszTeamName != null && teamResponse.rgTeams[iResult].wszTeamName.Length > 0)
                {
                    teamNames[iResult] =  teamResponse.rgTeams[iResult].wszTeamName;
                }
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupTeamName " + iResult + ":titleId = " + titleId + "teamPUID = " + puids[iResult] + " teamName = " + teamNames[iResult]);
            }

            return teamNames;
        }
    
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XblX509CertificateValidator.cs ===
// 
// XblX509CertificateValidator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// X509CertificateValidator derived class for Saml Token certificate validation
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using STF.common.exceptions;

namespace STF.common.service
{

internal class XblX509CertificateValidator : X509CertificateValidator
{
    protected string[] _allowedThumbprints;
    
    public XblX509CertificateValidator(string[] allowedThumbprints)
    {
        _allowedThumbprints = allowedThumbprints;
    }
    
    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    public override void Validate(X509Certificate2 certificate)
    {
        // Is this token signed with the right certificate?
        bool isValid = false;
        foreach (string thumbprint in _allowedThumbprints)
        {
            if (0 == string.Compare(thumbprint, certificate.Thumbprint, true))
            {
                isValid = true;
                break;
            }
        }

        if (!isValid)
        {
            StringBuilder message = new StringBuilder();

            message.AppendFormat("; SAML Assertion SigningToken was {0}, but one of the following was expected:", certificate.Thumbprint);
            foreach(string thumbprint in _allowedThumbprints)
            {
                message.AppendFormat("\r\n\t{0}", thumbprint);
            }

            throw new SecurityTokenValidationException(message.ToString());
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XBancProxy.cs ===
using System;
using System.IO;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

using STF.common.config;
using STF.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.XBancProxy)]
    
namespace STF.common.service
{
    public class XBanc
    {
        protected bool m_fUseLocalCache = false;
        protected static bool m_fInitialized = false;
        protected static volatile CacheTable<ByteArray, XBancLocalCacheValue> m_cache = new CacheTable<ByteArray, XBancLocalCacheValue>("XBanc Proxy - " + Config.ComponentName, Config.GetUIntSetting(Setting.xbanc_localCacheMaxSize));
        protected static CacheTableCounters m_CacheTableCounters = null;
        
        static XBanc()
        {
            // config setting change handler.
            Config.SettingChange += new SettingChangeEventHandler(XBanc.ChangeSetting);
            m_CacheTableCounters = CacheTableCounters.GetCounter("XBanc Proxy - " + Config.ComponentName);
        }

        public XBanc() : this(false)
        {
        }

        public XBanc(bool fUseLocalCache)
        {
            m_fUseLocalCache = fUseLocalCache;
        }

        public static void Init()
        {
            // this forces XBancConnection to run its static constructor.
            uint iStartup = XBancConnection.GetNumBuckets();
            m_fInitialized = true;
        }
                
        public static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1 == null) return (array2 == null);
            if (array2 == null) return false;
            if (array1.Length != array2.Length) return false;
            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i]) return false;
            }
            return true;
        }

        public bool IsLocalCachingEnabled()
        {
            return (m_fUseLocalCache && (m_cache.MaxSize > 0));
        }
        
        public bool ValidateKey(byte[] key)
        {
            /* TODO: add this to enforce that users call Init() before anything else.
            if (!m_fInitialized)
            {
                Xom.NtEvent(XEvent.Id.XBANC_PROXY_NOT_INITIALIZED, "XBancProxy accessed without being initialized.  Did you forget to call XBanc.Init() in your startup code?");
                return false;
            }
            */
            
            if ((key == null) ||
                (key.Length == 0) ||
                (key.Length > Config.GetUIntSetting(Setting.xbanc_max_key_length)))
            {
                return false;
            }

            return true;
        }

        public bool ValidateValue(byte[] value)
        {
            if ((value == null) ||
                (value.Length == 0))
            {
                return false;
            }

            return true;
        }
        
        protected uint HashKeyToBucket(byte[] key)
        {
            uint sum = 0;
            for (int i = 0; i < key.Length; i++)
            {
                sum += (uint)key[i];
            }

            return sum % XBancConnection.GetNumBuckets();
        }

        public static uint GetExtendedError(Exception e, byte[] rgbStream)
        {
            if (e is XRLException)
            {
                XRLException xrle = (XRLException)e;
                
                // check for a failure code from the inh server.
                if ((xrle.HResult == HResult.XONLINE_E_END_OF_STREAM) &&
                    (rgbStream != null))
                {
                    try
                    {
                        XBancEmptyResponse response = new XBancEmptyResponse();
                        response.ReadBytes(rgbStream);

                        // return the hr from the server.
                        return response.hr;
                    }
                    catch (Exception)
                    {
                        // couldnt get anything more.  we can eat this exception.
                    }
                }

                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, xrle, "XBanc.Query() caught exception");

                // return exception failure.
                return xrle.HResult;
            }
            else
            {
                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, e, "XBanc.Query() caught exception");
                
                // generic send failure.
                return HResult.E_ABORT;
            }
        }
        
        public uint Query(byte[] key, out byte[] value)
        {
            uint validSeconds;
            return Query(key, out value, out validSeconds);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds)
        {
            uint[] rgValidSeconds;
            byte[][] values;
            uint[] retVals;

            retVals = Query(new byte[][]{key}, out values, out rgValidSeconds);

            value = values[0];
            validSeconds = rgValidSeconds[0];
            return retVals[0];
         }

        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds)
        {
            values = null;
            validSeconds = null;
            
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            validSeconds = new uint[keys.Length];
            values = new byte[keys.Length][];

            ByteArray[] baKeys = null;
            XBancLocalCacheValue[] expiredItems = null;
            if (IsLocalCachingEnabled())
            {
                baKeys = new ByteArray[keys.Length];
                expiredItems = new XBancLocalCacheValue[keys.Length];
            }

            // If the client has requested that all xbanc queries fail,
            // then don't even bother with the real query.
            if (XbancMiss.HandleBehaviorInjectionQuery(retVals))
            {
                return retVals;
            }

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                // assume failure for each key until proven otherwise.
                // default is failfast, as any other failure is explicitly set
                retVals[iKey] = HResult.XONLINE_E_RESOURCE_UNAVAILABLE;
                
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                    continue;
                }

                // check the local cache
                if (IsLocalCachingEnabled())
                {
                    XBancLocalCacheValue localValue = null;
                    bool fCacheHit = true;
                    try
                    {
                        baKeys[iKey] = new ByteArray(keys[iKey]); 
                        localValue = m_cache[baKeys[iKey]];
                    }
                    catch (Exception)
                    {
                        // eat any exception.
                        fCacheHit = false;
                    }
                    
                    if ((localValue != null) && (!localValue.IsExpired()))
                    {
                        retVals[iKey] = HResult.S_OK;
                        values[iKey] = localValue.GetValue();
                        validSeconds[iKey] = (uint)localValue.GetRemainingSeconds();

                        // skip server trip for this key.
                        continue;
                    }
                    else if (fCacheHit)
                    {
                        // what we got was actually expired.  Lets call it a miss instead.
                        m_CacheTableCounters.UnMarkCacheHit();
                        m_CacheTableCounters.MarkCacheMiss();

                        // save the container for reuse.
                        expiredItems[iKey] = localValue;
                    }
                }
                
                XBancQueryRequest request = new XBancQueryRequest();
                request.rgbKey = keys[iKey];
                context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
            }

            XBancConnection.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (context._wtObjects[iKey] == null)
                {
                    // we never sent this key to xbanc.  it likely has a prior success/error code from above.
                    continue;
                }
                else if (context._wtObjects[iKey]._response == null)
                {
                    // we got nothing back from xbanc.
                    retVals[iKey] = HResult.E_ABORT;
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancQueryResponse response = new XBancQueryResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        values[iKey] = response.rgbValue;
                        validSeconds[iKey] = response.dwValidSeconds;
                        retVals[iKey] = response.hr;

                        // populate local cache.
                        // only populate if a real value was returned.
                        if (IsLocalCachingEnabled() && (response.hr == HResult.S_OK))
                        {
                            try
                            {
                                // try to reuse any old key or data container.
                                XBancLocalCacheValue newValue = expiredItems[iKey];
                                if (newValue == null)
                                {
                                    newValue = new XBancLocalCacheValue(baKeys[iKey], response.rgbValue);
                                }
                                else
                                {
                                    newValue.Init(response.rgbValue);
                                }
                                
                                m_cache[newValue.GetKey()] = newValue;
                            }
                            catch (Exception)
                            {
                                // eat any exception.
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Insert(byte[] key, byte[] value)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0});
            return retVals[0];
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] Insert(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            // If the client has requested that all Xbanc queries for this request
            // are missed, we also short-circuit inserts because we don't want the
            // caller to be confused.
            if (XbancMiss.ForceMissOn)
            {
                return retVals;
            }

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancInsertRequest request = new XBancInsertRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancInsertResponse response = new XBancInsertResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key)
        {
            uint[] retVals = Remove(new byte[][]{key});
            return retVals[0];
        }

        public uint[] Remove(byte[][] keys)
        {
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancRemoveRequest request = new XBancRemoveRequest();
                    request.rgbKey = keys[iKey];
                    request.fMatchExact = true;
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancRemoveResponse response = new XBancRemoveResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            if (matchExact == true)
            {
                return Remove(key);
            }
            
            if (!ValidateKey(key))
            {
                return HResult.E_INVALIDARG;
            }
            
            // make a request copy for each server.
            uint cServers = XBancConnection.GetNumServers();
            XBancRemoveRequest[] requests = new XBancRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new XBancRemoveRequest();
                requests[iServer].rgbKey = key;
                requests[iServer].fMatchExact = false;
            }

            try
            {
                // we treat these sends as fire and forget.
                XBancConnection.SendToAllServers(requests);
                return HResult.S_OK;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, e, "XBanc.Remove() caught exception");

                return HResult.E_ABORT;
            }
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancSetDataRequest request = new XBancSetDataRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancSetDataResponse response = new XBancSetDataResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Increment(byte[] key, ulong amount, out ulong result)
        {
            return Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, out ulong result)
        {
            return Increment(key, amount, halfLifeSeconds, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint absoluteSeconds, uint slidingSeconds, out ulong result)
        {
            ulong[] results;
            uint[] retVals = Increment(new byte[][]{key}, new ulong[]{amount}, new uint[]{halfLifeSeconds}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, out results);
            
            result = results[0];
            return retVals[0];
        }

        public uint[] Increment(byte[][] keys, ulong[] amounts, out ulong[] results)
        {
            uint[] halfLives = new uint[keys.Length];
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                halfLives[iKey] = XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE;
            }
            return Increment(keys, amounts, halfLives, new uint[keys.Length], new uint[keys.Length], out results);
        }
        
        public uint[] Increment(byte[][] keys, ulong[] amounts, uint[] halfLives, uint[] absoluteExpiries, uint[] slidingExpiries, out ulong[] results)
        {
            results = null;
            
            if ((keys == null) || (amounts == null) || (halfLives == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (amounts.Length != keys.Length) || (halfLives.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            results = new ulong[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || (halfLives[iKey] == 0))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancIncrementRequest request = new XBancIncrementRequest();
                    request.rgbKey = keys[iKey];
                    request.qwIncrementAmount = amounts[iKey];
                    request.dwHalfLifeSeconds = halfLives[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancIncrementResponse response = new XBancIncrementResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        results[iKey] = response.qwResult;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint[] Health()
        {            
            // make a request copy for each server.
            uint cServers = XBancConnection.GetNumServers();
            XBancRemoveRequest[] requests = new XBancRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new XBancRemoveRequest();
                requests[iServer].rgbKey = System.Text.Encoding.ASCII.GetBytes("Health");
                requests[iServer].fMatchExact = true;
            }

            uint[] hrs = XBancConnection.SendToAllServers(requests, true);

            return hrs;
        }

        public static void ChangeSetting(object sender, SettingChangeEventArgs e)
        {
            if (e.Setting == Setting.xbanc_localCacheMaxSize)
            {
                uint size = UInt32.Parse(e.ValueNew);
                if (size == 0)
                {
                    // dont bother deleting everything from the old cache.  just create a new empty one.
                    m_cache = new CacheTable<ByteArray, XBancLocalCacheValue>("XBanc Proxy - " + Config.ComponentName, 0);
                }
                else
                {
                    m_cache.MaxSize = UInt32.Parse(e.ValueNew);
                }
            }
        }

    }

    public class XBancLocalCacheValue : IMeasurable
    {
        protected ByteArray _baKey;
        protected byte[] _value;
        protected long _expireTime;

        uint IMeasurable.GetSize()
        {
            return (uint)((_value == null) ? 0 : _value.Length) + (uint)((_baKey == null) ? 0 : (_baKey.Bytes == null) ? 8 : _baKey.Bytes.Length) + 16;
        }

        public XBancLocalCacheValue(ByteArray baKey, byte[] value)
        {
            _baKey = baKey;
            Init(value);
        }
        
        public void Init(byte[] value)
        {
            _value = value;
            _expireTime = (Config.GetLongSetting(Setting.xbanc_localCacheItemDuration) * 10 * 1000 * 1000) + DateTime.Now.Ticks;
        }

        public ByteArray GetKey()
        {
            return _baKey;
        }
        
        public byte[] GetValue()
        {
            return _value;
        }
        
        public long GetRemainingSeconds()
        {
            // only valid if IsExpired() is false.
            return (_expireTime - DateTime.Now.Ticks) / (10 * 1000 * 1000);
        }

        public bool IsExpired()
        {
            return (_expireTime <= DateTime.Now.Ticks);
        }
    }

    internal class XBancContext
    {
        public XBancWaitTableObject[] _wtObjects;
        public int _keysRemaining;
        public ManualResetEvent _event = null;

        public XBancContext(int numRequests)
        {
            _keysRemaining = 0;
            _wtObjects = new XBancWaitTableObject[numRequests];
            _event = new ManualResetEvent(false);
        }

        public void AddRequest(uint keyIndex, uint bucket, XBancMessageHeader request)
        {
            _wtObjects[keyIndex] = new XBancWaitTableObject(this, keyIndex, bucket, request);
            _keysRemaining++;
        }
    }

    internal class XBancWaitTableObject
    {
        public XBancContext _context;
        public XBancMessageHeader _request;
        public byte[] _response;
        public uint _keyIndex;
        public uint _seqnum;
        public uint _bucket;

        public XomRequestTimeElapsed _waitTime;

        public XBancWaitTableObject(XBancContext context, uint keyIndex, uint bucket, XBancMessageHeader request)
        {
            _context = context;
            _keyIndex = keyIndex;
            _bucket = bucket;
            _request = request;
            _seqnum = 0;
        }
    }

    internal class XBancConnection
    {
        private const int LOCK_TIMEOUT = 30000;
        private const int SEND_QUEUE_TIMEOUT = 1000;
        private const int REPLY_TIMEOUT = 3000;

        // an array of InhConnection objects, use
        // GetInhConnection to access it.
        private static ReaderWriterLock _rwlConnections = null;
        private static int[] _bucketMap = null;
        private static XBancConnection[] _connections = null;

        private static volatile bool _fInitialized = false;
        private static object _lockInit = new object();

        // fast fail
        private static FastFailHelper _fastFailHelper = null;

        private Socket _socket;
        private IInterfaceInfo _interfaceInfo;
        private string _serverName;
        private int _seqNum = 1;

        // asynch send stuff
        private bool _shutdown;
        private FastQueue _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private XboxLiveThread _sendThread;
        private XboxLiveThread _receiveThread;

        // perf counter instance specific to this connection
        private XBancConnectionCounters _instanceCounters;
        
        // Create the _connections
        static XBancConnection()
        {
            // setup config change handlers.
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(XBancConnection.ChangeBucketMap);
            Config.ServerListChange += new ServerListChangeEventHandler(XBancConnection.ChangeServerList);

            // create a fast fail helper.
            _fastFailHelper = new FastFailHelper(
                Setting.xbanc_fastFailTimeoutThresholdCount, 
                Setting.xbanc_fastFailTimeoutTimespanSeconds, 
                Setting.xbanc_fastFailBlockIntervalSeconds);

            // create reader/writer lock for static connection management.
            _rwlConnections = new ReaderWriterLock();
        }

        //////////////////////////////////////////////////////////
        // Initialize
        //
        // Public static methods of this class MUST call this method (Initialize) to guarantee
        // all static members are properly initialized before doing any work
        // NOTE: This Initializes _connections and _bucketMap which are only used by public static members of this class
        private static void Initialize()
        {
            if ( !_fInitialized )
            {
                lock ( _lockInit )
                {
                    if ( !_fInitialized )
                    {
                        _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
                        try
                        {
                            LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                            try
                            {
                                // first get the servers.
                                string[] serverList = Config.GetServerListByInterface(Interface.xbanc);
                                _connections = new XBancConnection[serverList.Length];

                                for (int iServer = 0; iServer < _connections.Length; iServer++)
                                {
                                    IInterfaceInfo iface = Config.GetInterface(serverList[iServer], Interface.xbanc);

                                    // create the new InhConnection object
                                    Xom.Trace(
                                        "XBancProxy",
                                        LogLevel.L_NORMAL,
                                        "XBancConnection.InitConnections: creating new InhConnection to Inh server "
                                        + iServer.ToString()
                                        + ", IP address "
                                        +iface.IPAddressString);
                                    
                                    _connections[iServer] = new XBancConnection(iface, serverList[iServer]);
                                }
                                
                                // now we have to make the bucket map. 
                                uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                                _bucketMap = new int[numBuckets];
                               
                                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                                {
                                    _bucketMap[iBucket] = -1;
                                    
                                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)iBucket);

                                    // find this bucket's server in the list of servers
                                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                                    {
                                        if (0 == String.Compare(b.CurrentServerName, serverList[iServer], StringComparison.OrdinalIgnoreCase))
                                        {
                                            // found it.
                                            _bucketMap[iBucket] = iServer;
                                            break;
                                        }
                                    }

                                    if (_bucketMap[iBucket] == -1)
                                    {
                                        Xom.NtEvent(XEvent.Id.XBANC_CODE_15, "Could not map bucket " + iBucket.ToString() + "to server " + b.CurrentServerName);
                                    }
                                }
                            }
                            finally
                            {
                                _rwlConnections.DowngradeFromWriterLock(ref lc);
                            }
                        }
                        finally
                        {
                            _rwlConnections.ReleaseReaderLock();
                        }
                        
                        _fInitialized = true;
                    }
                }
            }
        }
        
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            if (e.Interface != Interface.xbanc)
            {
                // we're only concerned with xbanc's buckets.
                return;
            }
            
            if (0 == String.Compare(e.ValueNew.CurrentServerName, e.ValueOld.CurrentServerName, StringComparison.OrdinalIgnoreCase))
            {
                // no change that we care about.
                return;
            }
            
            bool fChanged = false;

            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {            
                    for (int iServer = 0; iServer < _connections.Length; iServer++)
                    {
                        if (0 == String.Compare(e.ValueNew.CurrentServerName, _connections[iServer].GetServerName(), StringComparison.OrdinalIgnoreCase))
                        {
                            _bucketMap[e.Bucket] = iServer;
                            fChanged = true;
                            break;
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            if (!fChanged)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.XBANC_CODE_16, "XBancConnection::ChangeBucketMap() could not find a connection to server " + e.ValueNew.CurrentServerName);
            }
        }

        public static void ChangeServerList(object sender, ServerListChangeEventArgs e)
        {
            if (e.Interface != Interface.xbanc)
            {
                // we're only concerned with xbanc's servers.
                return;
            }

            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // build a translation map for the indices.
                int[] iIndexMap = new int[_connections.Length];

                for (int iOldServer = 0; iOldServer < _connections.Length; iOldServer++)
                {
                    iIndexMap[iOldServer] = -1;
                    for (int iNewServer = 0; iNewServer < e.ValueNew.Length; iNewServer++)
                    {
                        if (0 == String.Compare(_connections[iOldServer].GetServerName(), e.ValueNew[iNewServer], StringComparison.OrdinalIgnoreCase))
                        {
                            iIndexMap[iOldServer] = iNewServer;
                        }
                    }
                }

                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // make a new connection list and copy over any old connections that still remain.
                    XBancConnection[] newConnections = new XBancConnection[e.ValueNew.Length];
                    for (int iOldServer = 0; iOldServer < _connections.Length; iOldServer++)
                    {
                        if (iIndexMap[iOldServer] == -1)
                        {
                            // not in the map -- we dont need this one anymore.
                            _connections[iOldServer].Shutdown(false);
                        }
                        else
                        {
                            newConnections[iIndexMap[iOldServer]] = _connections[iOldServer];
                        }                

                        _connections[iOldServer] = null;
                    }

                    // make new connections
                    for (int iNewServer = 0; iNewServer < newConnections.Length; iNewServer++)
                    {
                        if (newConnections[iNewServer] == null)
                        {
                            IInterfaceInfo iface = Config.GetInterface(e.ValueNew[iNewServer], Interface.xbanc);

                            // create the new InhConnection object
                            Xom.Trace(
                                "XBancProxy",
                                LogLevel.L_NORMAL,
                                "XBancConnection.ChangeServerList: creating new InhConnection to Inh server "
                                + iNewServer.ToString()
                                + ", IP address "
                                +iface.IPAddressString);
                            
                            newConnections[iNewServer] = new XBancConnection(iface, e.ValueNew[iNewServer]);
                        }
                    }

                    // switch to the new connection list
                    _connections = newConnections;

                    // rearrange the bucket map
                    for (int iBucket = 0; iBucket < _bucketMap.Length; iBucket++)
                    {
                        _bucketMap[iBucket] = iIndexMap[_bucketMap[iBucket]];
                        if (_bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.XBANC_CODE_17, "Could not map bucket " + iBucket.ToString() + "to server.  Check config for consistency.");
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public static uint GetNumBuckets()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            uint cBuckets = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cBuckets = (uint)_bucketMap.Length;
            _rwlConnections.ReleaseReaderLock();
            return cBuckets;
        }

        public static uint GetNumServers()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            uint cServers = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cServers = (uint)_connections.Length;
            _rwlConnections.ReleaseReaderLock();
            return cServers;
        }

        public string GetServerName()
        {
            return _serverName;
        }

        public static XBancConnection GetInhConnection(uint bucketNum)
        {
            XBancConnection xbcRet = null;
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                int iServer = _bucketMap[bucketNum];
                if (iServer != -1)
                {
                    xbcRet = _connections[iServer];
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return xbcRet;
        }

        public static void ShutdownAll()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL, "XBancConnection.ShutdownAll: called");
                    foreach (XBancConnection inhConnection in _connections)
                    {
                        inhConnection.Shutdown(true);
                    }
                    Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL, "XBancConnection.ShutdownAll: complete");
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public XBancConnection(IInterfaceInfo interfaceInfo, string serverName)
        {
            // This contains the IP:port info we need to connect to the
            // INH server.
            _interfaceInfo = interfaceInfo;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Get a perf counter instance for this particular connection
            _instanceCounters = XBancConnectionCounters.Total[Config.ComponentName + " - " + _interfaceInfo.IPAddressString];

            // We call Connect() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails.
            try
            {
                Connect();
            }
            catch (SocketException)
            {
                // dont puke here if the server isnt up yet.
            }

            _shutdown = false;

            // This is a queue of requests to be sent to the INH server.
            _sendQueue = new FastQueue(10000, false);

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of requests which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            // Start the send thread
            _sendThread = new XboxLiveThread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            // Start the receive thread
            _receiveThread = new XboxLiveThread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            Xom.Trace(
                "XBancProxy",
                LogLevel.L_NORMAL,
                "XBancConnection.ctor: XBancConnection creation successful for "
                + _interfaceInfo.IPAddressString);
        }

        public void Shutdown()
        {
            Shutdown(true);
        }
        public void Shutdown(bool fWait)
        {
            Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL,
                "XBanc.Shutdown: Shutdown called for InhConnection to "
                + _interfaceInfo.IPAddressString);

            // set the shutdown flag, which will tell the send and receive
            // threads to begin shutting down
            _shutdown = true;

            if (fWait)
            {
                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
            }

            Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_LOW,
                "XBanc.Shutdown: InhConnection successfully shutdown for  "
                + _interfaceInfo.IPAddressString);
        }

        public bool IsValidConnection()
        {
            return (_socket != null && _socket.Connected);
        }

        public bool IsInFastFail()
        {
            return _fastFailHelper.InFastFailState(_interfaceInfo.IPAddressString);
        }

        // Gets the current socket connection, verifying the health of the socket
        // and (re)connecting it if required
        public void Connect()
        {
            if (IsValidConnection())
            {
                return;
            }
            
            try
            {
                _instanceCounters.ConnectionAttempts.Increment();
                XBancConnectionCounters.Total.ConnectionAttempts.Increment();
                
                // create a new socket
                Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL,
                    "XPNFD.InhConnection.GetSocket: creating new socket connection to "
                    + _interfaceInfo.IPAddressString);
                
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                    ProtocolType.Tcp);

                // connect to the specified INH server
                IPEndPoint ipEndPoint =
                    new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                _socket.Connect(ipEndPoint);
            }
            catch (SocketException se)
            {
                Disconnect();
                Xom.NtEvent(XEvent.Id.XBANC_CODE_18, se, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.");
            }
        }
        
        public void Disconnect()
        {
            lock (this)
            {
                if (_socket != null)
                {
                    try
                    {
                        _socket.Shutdown(SocketShutdown.Both);
                        _socket.Close();
                    }
                    catch (SocketException)
                    {
                        // eat any exception here.  we're closing anyway.
                    }
                    
                    _socket = null;
                }
            }
        }

        public bool Send(byte[] msg, uint seqNum)
        {
            bool fRetry = true;
            
            while ( IsValidConnection() )
            {
                try
                {
                    // break up msg into packets small enough to be received by the server.
                    int cbStart = 0;
                    int cbLeft = msg.Length;
                    while (cbLeft > 0)
                    {
                        int maxSize = (int)XBancDefs.XBANC_MAX_PACKET_SIZE;
                        
                        if (cbStart > 0)
                        {
                            // this isnt the first packet.  make a continuation header to send first.
                            XBancMessageHeader header = new XBancMessageHeader(XBANC_MSG_TYPES.XBMSG_CONTINUATION_REQ);

                            // the header contribuites to the packet size.
                            maxSize -= header.Size();
                            
                            header.dwMsgLen = (cbLeft > maxSize) ? XBancDefs.XBANC_MAX_PACKET_SIZE : (uint)(cbLeft + header.Size());
                            header.dwSeqNum = seqNum;

                            // cant use header.WriteStream() here because it overwrites dwMsgLen.
                            MemoryStream stream = new MemoryStream();
                            BinaryWriter writer = new BinaryWriter(stream);
                            writer.Write(header.dwProtocolVersion);
                            writer.Write(header.dwMsgType);
                            writer.Write(header.dwMsgLen);
                            writer.Write(header.dwSeqNum);

                            // send the header
                            _socket.Send(stream.ToArray());
                        }
                        
                        int cbSent = _socket.Send(
                            msg, 
                            cbStart, 
                            (cbLeft > maxSize) ? maxSize : cbLeft,
                            SocketFlags.None);

                        cbStart += cbSent;
                        cbLeft -= cbSent;
                    }
                    
                    return true;
                }
                catch (SocketException se)
                {
                    Xom.NtEvent(XEvent.Id.XBANC_CODE_19, se, "Unexpected exception caught " + (fRetry ? " Will attempt 1 retry." : ""));
                    
                    if (fRetry)
                    {
                        fRetry = false;
                        Disconnect();
                        Connect();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            
            Disconnect();
            return false;
        }

        public byte[] Recv()
        {
            if( IsValidConnection() )
            {
                try
                {
                    // buffer to receive header.
                    byte[] headerBuf = new byte[XBancDefs.XBANC_MESSAGE_HEADER_SIZE];

                    int cTotalBytes = 0;
                    while (cTotalBytes < headerBuf.Length)
                    {
                        int cBytes = _socket.Receive(headerBuf, cTotalBytes, headerBuf.Length - cTotalBytes, SocketFlags.None);
                        if (cBytes == 0)
                        {
                            throw new ApplicationException( "XBancConnection.Read(): Received 0 bytes");
                        }
                        else
                        {
                            cTotalBytes += cBytes;
                        }
                    }

                    XBancMessageHeader msgHeader = new XBancMessageHeader();
                    msgHeader.ReadBytes(headerBuf);
                    
                    // make a new buffer for header + data
                    byte[] buf = new byte[msgHeader.dwMsgLen];

                    // copy the header
                    for (int iHeader = 0; iHeader < headerBuf.Length; iHeader++)
                    {
                        buf[iHeader] = headerBuf[iHeader];
                    }
                    
                    while (cTotalBytes < buf.Length)
                    {
                        int cBytes = _socket.Receive(buf, cTotalBytes, buf.Length - cTotalBytes, SocketFlags.None);
                        if (cBytes == 0)
                        {
                            throw new ApplicationException( "XBancConnection.Read(): Received 0 bytes");
                        }
                        else
                        {
                            cTotalBytes += cBytes;
                        }
                    }

                    return buf;
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.XBANC_CODE_20, e, "Unexpected exception caught");
                }
            }
            
            Disconnect();
            return null;
        }

        protected uint GetNextSequenceNumber()
        {
            return (uint)Interlocked.Increment(ref _seqNum);
        }

        public static void SendToAllServers(XBancMessageHeader[] requests)
        {
            SendToAllServers(requests, false);
        }
        
        public static uint[] SendToAllServers(XBancMessageHeader[] requests, bool fWait)
        {
            int timeout = REPLY_TIMEOUT;
            uint[] retVals = null;
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // need a copy per server.
                if (requests.Length != _connections.Length)
                {
                    throw new ApplicationException( "XBancConnection.SendToAllServers(): incorrect number of servers specified.  This should only happen during an XBanc INH server list change.");
                }
                
                XBancContext context = new XBancContext(_connections.Length);

                // add all requests before sending any.
                for (uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    context.AddRequest(iServer, 0, requests[iServer]);
                }

                // now send the requests.
                for(uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    if (!(_connections[iServer].SendToServer(context._wtObjects[iServer])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iServer] = null;
                    }
                }

                if (fWait)
                {
                    if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
                    {
                        // timed out.  find all the missing replies and remove from waittables.
                        for (uint iServer = 0; iServer < context._wtObjects.Length; iServer++)
                        {
                            if ((context._wtObjects[iServer] != null) && (context._wtObjects[iServer]._response == null))
                            {
                                _connections[iServer].TimeoutWaitTableObject(context._wtObjects[iServer]);
                            }
                        }
                    }

                    retVals = new uint[_connections.Length];
                    for (uint iResponse = 0; iResponse < _connections.Length; iResponse++)
                    {
                        if ((context._wtObjects[iResponse] == null) || 
                            (context._wtObjects[iResponse]._response == null))
                        {
                            // If the key is null, request never got sent, an indicator of fastfail
                            retVals[iResponse] = (context._wtObjects[iResponse] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                        }
                        else
                        {
                            try
                            {
                                // parse the response.
                                XBancEmptyResponse response = new XBancEmptyResponse();
                                response.ReadBytes(context._wtObjects[iResponse]._response);

                                retVals[iResponse] = response.hr;
                            }
                            catch (Exception)
                            {
                                retVals[iResponse] = HResult.E_ABORT;
                            }                            
                        }
                    }
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return retVals;
        }

        public static void SendContext(XBancContext context)
        {
            int timeout = REPLY_TIMEOUT;
            try
            {
                timeout = Config.GetIntSetting(Setting.xbanc_replyTimeout);
                if (timeout == 0)
                {
                    // this means xbanc is disabled.  dont bother trying to send anything.
                    return;
                }
            }
            catch (Exception)
            {
                // eat this is if the setting doesnt exist.
            }
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
            {
                if (context._wtObjects[iKey] != null)
                {
                    XBancConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                    if (!(xbc.SendToServer(context._wtObjects[iKey])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iKey] = null;
                    }
                }
            }

            if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
            {
                // timed out.  find all the missing replies and remove from waittables.
                for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
                {
                    if ((context._wtObjects[iKey] != null) && (context._wtObjects[iKey]._response == null))
                    {
                        XBancConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                        xbc.TimeoutWaitTableObject(context._wtObjects[iKey]);
                    }
                }
            }
        }

        public bool SendToServer(XBancWaitTableObject wto)
        {
            // check fast fail first.
            if (IsInFastFail())
            {
                return false;
            }
            
            _instanceCounters.RequestRate.Increment();
            XBancConnectionCounters.Total.RequestRate.Increment();
            wto._waitTime = new XomRequestTimeElapsed();

            wto._seqnum = GetNextSequenceNumber();
            wto._request.dwSeqNum = wto._seqnum;
            _sendQueue.Enqueue(wto);
            _sendQueueEvent.Set();

            _instanceCounters.EnqueueRate.Increment();
            _instanceCounters.QueueSize.Increment();
            XBancConnectionCounters.Total.EnqueueRate.Increment();
            XBancConnectionCounters.Total.QueueSize.Increment();

            return true;
        }

        public void TimeoutWaitTableObject(XBancWaitTableObject wto)
        {
            // timed out waiting for a response.  remove it from the wait table.
            XBancWaitTableObject wtoRemoved;
            lock (_waitTable.SyncRoot)
            {
                wtoRemoved = (XBancWaitTableObject)_waitTable[wto._seqnum];
                _waitTable.Remove(wto._seqnum);
            }
            if (wtoRemoved != null)
            {
                _instanceCounters.WaitTableSize.Decrement();
                XBancConnectionCounters.Total.WaitTableSize.Decrement();
                _instanceCounters.ConcurrentRequests.Decrement();
                XBancConnectionCounters.Total.ConcurrentRequests.Decrement();
            }

            // report failure to fail fast.
            _fastFailHelper.ReportFailure(_interfaceInfo.IPAddressString, "Timed out.");

            _instanceCounters.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            _instanceCounters.RequestTimeAvgBase.Increment();
            XBancConnectionCounters.Total.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            XBancConnectionCounters.Total.RequestTimeAvgBase.Increment();
        }            

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                XBancWaitTableObject wto = (XBancWaitTableObject)_sendQueue.Dequeue();
                if (wto != null)
                {
                    bool fSent = false;
                    // queue is syncronized
                    try
                    {                        
                        // update the queue wait perf counters
                        long elapsed = wto._waitTime.TimeElapsed;
                        XBancConnectionCounters.Total.QueueWaitTimeAvg.IncrementBy(elapsed);
                        XBancConnectionCounters.Total.QueueWaitTimeAvgBase.Increment();
                        _instanceCounters.QueueWaitTimeAvg.IncrementBy(elapsed);
                        _instanceCounters.QueueWaitTimeAvgBase.Increment();

                        XBancConnectionCounters.Total.QueueSize.Decrement();
                        _instanceCounters.QueueSize.Decrement();

                        _instanceCounters.ConcurrentRequests.Increment();
                        XBancConnectionCounters.Total.ConcurrentRequests.Increment();
                        // if we are supposed to wait for a response from the
                        // INH server, then put this context into the wait
                        // table.
                        // We want to so this *before* we actually send,
                        // because the INH server could respond before we've 
                        // finished adding the context to the wait table.

                        // store the current time in the context
                        wto._waitTime = new XomRequestTimeElapsed();

                        _waitTable.Add(wto._seqnum, wto);

                        // update perf counters
                        XBancConnectionCounters.Total.WaitTableSize.Increment();
                        _instanceCounters.WaitTableSize.Increment();

                        // now do the send
                        Connect();
                        fSent = Send((byte[])(wto._request), wto._seqnum);
                    }
                    finally
                    {
                        if (!fSent)
                        {
                            _instanceCounters.ConcurrentRequests.Decrement();
                            XBancConnectionCounters.Total.ConcurrentRequests.Decrement();
                            
                            // removes the item from the wait table, regardless of if it's there or not.
                            XBancWaitTableObject wtoRemoved;
                            lock (_waitTable.SyncRoot)
                            {
                                wtoRemoved = (XBancWaitTableObject)_waitTable[wto._seqnum];
                                _waitTable.Remove(wto._seqnum);
                            }
                            if (wtoRemoved != null)
                            {
                                _instanceCounters.WaitTableSize.Decrement();
                                XBancConnectionCounters.Total.WaitTableSize.Decrement();
                            }

                            if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                            {
                                wto._context._event.Set();
                            }
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go back to sleep.
                    break;
                }
            }
        }

        public void SendThread()
        {
            try
            {
                // keep processing work items on the queue until we break out of
                // this loop because the _shutdown flag is set
                while (!_shutdown)
                {
                    try
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    catch (Exception e)
                    {
                        try
                        {
                            // we don't want an exception to cause this thread to
                            // terminate, so we catch it, log it, and move along
                            Xom.NtEvent(XEvent.Id.XBANC_CODE_19, e,
                                "Unexpected Exception thrown in SendThread for connection to INH at {0}",
                                _interfaceInfo.IPAddressString
                            );
                        }
                        catch (Exception)
                        {
                            // eat anything else that could possibly go wrong.
                        }
                    }
                }
            }
            finally
            {
                try
                {
                    // kill the socket. If we don't do this, the receive
                    // thread will never exit.
                    Disconnect();
                }
                catch (Exception)
                {
                    // eat anything else that could possibly go wrong.
                }
            }            
        }

        public void ReceiveMessage()
        {
            try
            {
                // read a response.
                byte[] rgbResp = Recv();
                if (rgbResp == null)
                {
                    return;
                }

                // get the sequence number
                XBancMessageHeader response = new XBancMessageHeader();
                response.ReadBytes(rgbResp);

                // find the matching Context in the wait table.
                XBancWaitTableObject wto;
                lock (_waitTable.SyncRoot)
                {
                    wto = (XBancWaitTableObject)_waitTable[response.dwSeqNum];
                    _waitTable.Remove(response.dwSeqNum);
                }

                if (wto == null)
                {
                    // this is expected for contexts that werent waiting (e.g. multi-server remove requests).  do nothing.
                }
                else
                {
                    _instanceCounters.ConcurrentRequests.Decrement();
                    XBancConnectionCounters.Total.ConcurrentRequests.Decrement();

                    wto._response = rgbResp;

                    // Update perf counters
                    long elapsed = wto._waitTime.TimeElapsed;
                    XBancConnectionCounters.Total.WaitTableSize.Decrement();
                    XBancConnectionCounters.Total.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    XBancConnectionCounters.Total.WaitTableWaitTimeAvgBase.Increment();
                    _instanceCounters.WaitTableSize.Decrement();
                    _instanceCounters.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    _instanceCounters.WaitTableWaitTimeAvgBase.Increment();
                    
                    _fastFailHelper.ReportSuccess(_interfaceInfo.IPAddressString);

                    if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                    {
                        wto._context._event.Set();
                    }
                }
            }
            catch (Exception)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular context, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!_shutdown)
                {
                    Disconnect();
                    throw;
                }
            }
        }

        public void ReceiveThread()
        {
            // keep receiving messages from the INH server until we break out of
            // this loop because the _shutdown flag is set
            while (!_shutdown)
            {
                try
                {
                    // dont try to receive if the socket is dead.
                    if (IsValidConnection())
                    {
                        ReceiveMessage();
                    }
                    else
                    {
                        Thread.Sleep(1000);
                    }
                }
                catch (Exception e)
                {
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.XBANC_CODE_20, e,
                            "Unexpected Exception thrown in ReceiveThread for InhConnection to {0}",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }

    }
    
    [XomPerformanceCounterCategoryAttr( "XBanc Proxy", "XBox Live XBanc Service Proxy: Connections to XBanc INH Servers", true )]
    public class XBancConnectionCounters : XomPerformanceCounterCategory
    {
        public virtual XBancConnectionCounters this[string instanceName]
        {
            get
            {
                return (XBancConnectionCounters) GetInstance(instanceName);
            }
        }

        static public XBancConnectionCounters Total = new XBancConnectionCounters();

        public XBancConnectionCounters() : base()
        {
            RequestRate.RawValue = 0;
            RequestTimeAvg.RawValue = 0;
            RequestTimeAvgBase.RawValue = 0;
            ConnectionAttempts.RawValue = 0;
            ConcurrentRequests.RawValue = 0;
            EnqueueRate.RawValue = 0;
            QueueSize.RawValue = 0;
            QueueWaitTimeAvg.RawValue = 0;
            QueueWaitTimeAvgBase.RawValue = 0;
            WaitTableSize.RawValue = 0;
            WaitTableWaitTimeAvg.RawValue = 0;
            WaitTableWaitTimeAvgBase.RawValue = 0;
        }

        [XomPerformanceCounterAttr(
            "Request Rate", 
            "Number of requests per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestRate;

        [XomPerformanceCounterAttr(
            "Request Time Average", 
            "Average time taken per request.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter RequestTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Request Time Average Base", 
            "Base for average time taken per request.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter RequestTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Connection attempts", 
            "Total number of attempts to connect this socket.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConnectionAttempts;

        [XomPerformanceCounterAttr(
            "Concurrent requests", 
            "Total number of requests waiting for a response.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConcurrentRequests;

        [XomPerformanceCounterAttr(
            "Enqueue Rate", 
            "Number of requests per second added to send queue waiting to be sent to the INH server", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnqueueRate;

        [XomPerformanceCounterAttr(
            "Queue Size", 
            "Total number of requests in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueueSize;

        [XomPerformanceCounterAttr(
            "Queue Wait Time Average", 
            "Average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter QueueWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Queue Wait Time Average Base", 
            "Base for average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter QueueWaitTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Wait Table Size", 
            "Total number of requests waiting in the wait table for a response from the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WaitTableSize;

        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average", 
            "Average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTableWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average Base", 
            "Base for average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTableWaitTimeAvgBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XboxLiveThread.cs ===
using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Globalization;

using STF.common.mgmt;

namespace STF.common.service 
{
   [ComVisible(false)]
   public sealed class XboxLiveThread {
      public XboxLiveThread(ParameterizedThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); })
         );
      }

      public XboxLiveThread(ThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); })
         );
      }
      
      public XboxLiveThread(ParameterizedThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); }), 
            maxStackSize);
      }

      public XboxLiveThread(ThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); }), 
            maxStackSize);
      }

      #region Arbitrated Thread Instance Members
      public void Abort() {
         InnerThread.Abort();
      }

      public void Abort(object stateInfo) {
         InnerThread.Abort(stateInfo);
      }

      public ApartmentState GetApartmentState() {
         return InnerThread.GetApartmentState();
      }

      [ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public CompressedStack GetCompressedStack() {
         return InnerThread.GetCompressedStack();
      }

      public void Interrupt() {
         InnerThread.Interrupt();
      }

      public void Join() {
         InnerThread.Join();
      }

      public bool Join(int millisecondsTimeout) {
         return InnerThread.Join(millisecondsTimeout);
      }

      public bool Join(TimeSpan timeout) {
         return InnerThread.Join(timeout);
      }

      [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Resume() {
         InnerThread.Resume();
      }

      public void SetApartmentState(ApartmentState state) {
         InnerThread.SetApartmentState(state);
      }

      [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public void SetCompressedStack(CompressedStack stack) {
         InnerThread.SetCompressedStack(stack);
      }

      public void Start() {
         InnerThread.Start();
      }

      public void Start(Object parameter) {
         InnerThread.Start(parameter);
      }

      [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Suspend() {
         InnerThread.Suspend();
      }

      public bool TrySetApartmentState(ApartmentState state) {
         return InnerThread.TrySetApartmentState(state);
      }

      [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)]
      public ApartmentState ApartmentState {
         get { return InnerThread.ApartmentState; }
         set { InnerThread.ApartmentState = value; }
      }

      public CultureInfo CurrentCulture {
         get { return InnerThread.CurrentCulture; }
         set { InnerThread.CurrentCulture = value; }
      }

      public CultureInfo CurrentUICulture {
         get { return InnerThread.CurrentUICulture; }
         set { InnerThread.CurrentUICulture = value; }
      }

      public ExecutionContext ExecutionContext {
         get { return InnerThread.ExecutionContext; }
      }

      public bool IsAlive {
         get { return InnerThread.IsAlive; }
      }

      public bool IsBackground {
         get { return InnerThread.IsBackground; }
         set { InnerThread.IsBackground = value; }
      }

      public bool IsThreadPoolThread {
         get { return InnerThread.IsThreadPoolThread; }
      }

      public int ManagedThreadId {
         get { return InnerThread.ManagedThreadId; }
      }

      public string Name {
         get { return InnerThread.Name; }
         set { InnerThread.Name = value; }
      }

      public ThreadPriority Priority {
         get { return InnerThread.Priority; }
         set { InnerThread.Priority = value; }
      }

      public ThreadState ThreadState {
         get { return InnerThread.ThreadState; }
      }
      #endregion

      #region Private Wrapper Members
      private void HandleException(Exception e) {
         try {
            Xom.NtEvent(XEvent.Id.UNHANDLED_THREAD_EXCEPTION, e,
               "XboxLiveThread - unhandled exception"
            );
         }
         catch (Exception) { /* crap */ }
      }

      private void ThreadWrapper(ThreadStart start) {
         try {
            start();
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }

      private void ThreadWrapper(ParameterizedThreadStart start, object obj) {
         try {
            start(obj);
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }
      #endregion

      public Thread InnerThread {
         get { return innerThread; }
      }

      public Exception ThreadException {
         get { return threadException; }
         set { threadException = value; }
      }

      private Thread innerThread;
      private Exception threadException;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XbosProtocol.cs ===
using System;


using STF.common.service;


namespace STF.common.protocol
{
    public enum OfferCatalogTypeEnum
    {
        Unknown     = 0,
        Xbox        = 1,
        Ems         = 2
    }

    public class AutoupdReferralRequest : XRLObject2
    {
        public ulong  machinePuid;
        public uint   titleId;
        public uint   baseVersion; // Base version (Dash only)

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/AutoupdReferral.ashx"; }
        }
    }

    public class ReferralLocation : WireData
    {
        public ushort rank;

        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string xrl;            // XRL to update package
    }

    public class AutoupdReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   titleVersion;   // Update version

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class ContentAvailableRequest : XRLObject2
    {
        public uint titleId =0;

        public int esrbRating =0;

        public uint bitFilter =0;

        public DateTime lastChangedDate = DateTime.UtcNow;

        public byte countryId = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentAvailable.ashx"; }
        }
    }

    public class ContentReferralRequest : XRLObject2
    {
        public ulong machinePuid;
        public ulong userPuid0;
        public ulong userPuid1;
        public ulong userPuid2;
        public ulong userPuid3;
        public uint  titleId;
        public ulong offerId;
        public uint  esrbRating;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentReferral.ashx"; }
        }
    }

    public class ContentReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   bitFlags;       // Package bit flags

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class OfferingCancelRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingCancel.ashx"; }
        }
    }

    public class OfferingDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetails.ashx"; }
        }
    }

    public class OfferingDetailsResponse : XRLObject2
    {
        public uint   instanceCount;

        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string isoCode;

        public uint   offeringDetails;

        public uint   detailsBlobLength;

        [WireInfo(SizeParam="detailsBlobLength")]
        public byte[] detailsBlob;
    }

    public class OfferingDetailsNoUserRequest : XRLObject2
    {
        public byte countryId;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetailsNoUser.ashx"; }
        }
    }

    public class OfferingEnumerateRequest : XRLObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public int         esrbRating;

        public DateTime    lastChangedDate = DateTime.UtcNow;

        public uint        offerType;

        public uint        bitFilter;

        public int         descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingEnumerate.ashx"; }
        }
    }

    public class OfferingEnumerateRecord : XRLObject2
    {
        public short  recordSize;

        public short  recordIndex;

        public ulong  offerId;

        public int    offerType;

        public int    bitFlags;

        public int    packageSize;

        public int    installSize;

        public DateTime activationDate;

        public int    esrbRating;

        public short  offerFlags;

        public int    titleSpecificDataSize;

        public int    titleSpecificDataOffset;

        [WireInfo(SizeParam="titleSpecificDataSize")]
        public byte[] enumBlob;
    }

    public class OfferingEnumerateResponse : XRLObject2
    {
        public short    recordCount;

        public short    flags;

        public DateTime lastChangedDate;

        [WireInfo(SizeParam="recordCount")]
        public OfferingEnumerateRecord[] records;
    }

    public class OfferingPurchaseRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingPurchase.ashx"; }
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentUpdateAccessTimesRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentUpdateAccessTimes.ashx";
            }
        }
    }

    public class ContentEnumerateRequest : XRLObject2WithFlags
    {
        static byte UserPlayedGameFilter        = 0x01;
        static byte UserHasPurchasedFilter      = 0x02;
        static byte NewContentOnlyFilter        = 0x04;
        static byte MatchRequiredTierFilter     = 0x08;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // content, points bundle, gamertag, etc

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public byte requestFlags; // userPlayedGameFilter, userHasPurchasedFilter

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public int genreID = 0;

        public bool userPlayedGameFilter
        {
            get
            {
                return IsFlagSet(UserPlayedGameFilter, requestFlags);
            }
            set
            {
                SetFlag(UserPlayedGameFilter, value, ref requestFlags);
            }
        }

        public bool userHasPurchasedFilter
        {
            get
            {
                return IsFlagSet(UserHasPurchasedFilter, requestFlags);
            }
            set
            {
                SetFlag(UserHasPurchasedFilter, value, ref requestFlags);
            }
        }

        public bool newContentOnlyFilter
        {
            get
            {
                return IsFlagSet(NewContentOnlyFilter, requestFlags);
            }
            set
            {
                SetFlag(NewContentOnlyFilter, value, ref requestFlags);
            }
        }

        public bool matchRequiredTierFilter
        {
            get
            {
                return IsFlagSet(MatchRequiredTierFilter, requestFlags);
            }
            set
            {
                SetFlag(MatchRequiredTierFilter, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentEnumerate2.ashx";
            }
        }
    }

    public class OfferPrice : WireData
    {
        public uint paymentType;

        public byte taxType;

        public int wholePrice;

        public int fractionalPrice;

        public ushort priceTextLength;

        [WireInfo(SizeParam="priceTextLength", NullTerminate=true)]
        public string priceText;
      }

    public class GamertagContentInfo : XRLObject2
    {
        public Guid offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam = "offerNameLength", NullTerminate = true)]
        public string offerName;

        public uint offerType;

        public int sellTextLength;

        [WireInfo(SizeParam = "sellTextLength", NullTerminate = true)]
        public string sellText;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize = false)]
        public System.DateTime maxStartDate;

        public byte pricesLength;

        [WireInfo(SizeParam = "pricesLength")]
        public OfferPrice[] prices;

    }

    public class BasicContentInfo : XRLObject2WithFlags
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort UserHasViewed             = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsRecentContent           = 0x0008;

        public BasicContentInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ulong previewOfferID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint licenseMask;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public byte tierRequired;

        public ushort gameRating;

        public ushort responseFlags; // userHasPurchased, userHasViewed, isUnrestricted

        public uint packageSize;

        public uint installSize;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint assetID;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint purchaseQuantity;

        public byte pricesLength;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.DateTime maxStartDate;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool userHasViewed
        {
            get
            {
                return IsFlagSet(UserHasViewed, responseFlags);
            }
            set
            {
                SetFlag(UserHasViewed, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isRecentContent
        {
            get
            {
                return IsFlagSet(IsRecentContent, responseFlags);
            }
            set
            {
                SetFlag(IsRecentContent, value, ref responseFlags);
            }
        }
    }

    public class GamertagEnumerateResult : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam = "offersReturned")]
        public GamertagContentInfo[] infos;

        public uint offersTotal;
    }

    public class ContentEnumerateResponse : XRLObject2, IMeasurable
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentInfo [] infos;

        public uint offersTotal;

        uint IMeasurable.GetSize()
        {
            uint size = 6;

            for (uint iInfo = 0; iInfo < offersReturned; iInfo++)
            {
                size += 90;
                size += infos[iInfo].offerNameLength;
                size += (uint)infos[iInfo].sellTextLength;
                size += infos[iInfo].titleNameLength;

                for (uint iPrice = 0; iPrice < infos[iInfo].pricesLength; iPrice++)
                {
                    size += 15;
                    size += infos[iInfo].prices[iPrice].priceTextLength;
                }
            }

            return size;
        }

        public ContentEnumerateResponse Copy()
        {
            ContentEnumerateResponse copy = new ContentEnumerateResponse();

            copy.offersReturned = offersReturned;
            copy.offersTotal = offersTotal;

            copy.infos = new BasicContentInfo[infos.Length];
            for (uint iInfo = 0; iInfo < infos.Length; iInfo++)
            {
                copy.infos[iInfo] = new BasicContentInfo();

                copy.infos[iInfo].offerID = infos[iInfo].offerID;
                copy.infos[iInfo].previewOfferID = infos[iInfo].previewOfferID;
                copy.infos[iInfo].offerNameLength = infos[iInfo].offerNameLength;
                copy.infos[iInfo].offerName = infos[iInfo].offerName;
                copy.infos[iInfo].offerType = infos[iInfo].offerType;
                copy.infos[iInfo].contentId = infos[iInfo].contentId;
                copy.infos[iInfo].licenseMask = infos[iInfo].licenseMask;
                copy.infos[iInfo].titleID = infos[iInfo].titleID;
                copy.infos[iInfo].titleCategory = infos[iInfo].titleCategory;
                copy.infos[iInfo].titleNameLength = infos[iInfo].titleNameLength;
                copy.infos[iInfo].titleName = infos[iInfo].titleName;
                copy.infos[iInfo].tierRequired = infos[iInfo].tierRequired;
                copy.infos[iInfo].gameRating = infos[iInfo].gameRating;
                copy.infos[iInfo].responseFlags = infos[iInfo].responseFlags;
                copy.infos[iInfo].packageSize = infos[iInfo].packageSize;
                copy.infos[iInfo].installSize = infos[iInfo].installSize;
                copy.infos[iInfo].sellTextLength = infos[iInfo].sellTextLength;
                copy.infos[iInfo].sellText = infos[iInfo].sellText;
                copy.infos[iInfo].assetID = infos[iInfo].assetID;
                copy.infos[iInfo].purchaseQuantity = infos[iInfo].purchaseQuantity;
                copy.infos[iInfo].pricesLength = infos[iInfo].pricesLength;
                copy.infos[iInfo].maxStartDate = infos[iInfo].maxStartDate;

                copy.infos[iInfo].prices = new OfferPrice[infos[iInfo].prices.Length];
                for (uint iPrice =0; iPrice < infos[iInfo].prices.Length; iPrice++)
                {
                    copy.infos[iInfo].prices[iPrice] = new OfferPrice();

                    copy.infos[iInfo].prices[iPrice].paymentType = infos[iInfo].prices[iPrice].paymentType;
                    copy.infos[iInfo].prices[iPrice].taxType = infos[iInfo].prices[iPrice].taxType;
                    copy.infos[iInfo].prices[iPrice].wholePrice = infos[iInfo].prices[iPrice].wholePrice;
                    copy.infos[iInfo].prices[iPrice].fractionalPrice = infos[iInfo].prices[iPrice].fractionalPrice;
                    copy.infos[iInfo].prices[iPrice].priceTextLength = infos[iInfo].prices[iPrice].priceTextLength;
                    copy.infos[iInfo].prices[iPrice].priceText = infos[iInfo].prices[iPrice].priceText;
                }
            }

            return copy;
        }
    }

    public class ContentDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offers;        // count of offers

        [WireInfo(HexString=true, SizeParam="offers", MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(HexString=true, MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;    // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentDetails.ashx";
            }
        }
    }

    public class ContentDetailsResponse : XRLObject2
    {
        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned", MinSchemaVersion="2.0")]
        public BasicContentInfo [] infos;

        [WireInfo(MaxSchemaVersion="1.0")]
        public BasicContentInfo basicInfo;
    }

    public class SubscriptionEnumerateRequest : XRLObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForRenewals                 = 0x0002;
        static ushort QueryForCurrent                  = 0x0004;
        static ushort QueryForExpired                  = 0x0008;
        static ushort QueryForSuspended                = 0x0010;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte userTier;

        public byte countryID;

        public ushort languageID;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // live, game, 24-hour, add-on

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // queryForEquivalent, queryForUpgrades, queryForDowngrades

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionEnumerate.ashx";
            }
        }

        public bool queryForNew
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool queryForRenewals
        {
            get
            {
                return IsFlagSet(QueryForRenewals, requestFlags);
            }
            set
            {
                SetFlag(QueryForRenewals, value, ref requestFlags);
            }
        }

        public bool queryForCurrent
        {
            get
            {
                return IsFlagSet(QueryForCurrent, requestFlags);
            }
            set
            {
                SetFlag(QueryForCurrent, value, ref requestFlags);
            }
        }

        public bool queryForExpired
        {
            get
            {
                return IsFlagSet(QueryForExpired, requestFlags);
            }
            set
            {
                SetFlag(QueryForExpired, value, ref requestFlags);
            }
        }

        public bool queryForSuspended
        {
            get
            {
                return IsFlagSet(QueryForSuspended, requestFlags);
            }
            set
            {
                SetFlag(QueryForSuspended, value, ref requestFlags);
            }
        }
    }

    public class BasicSubscriptionInfo : XRLObject2WithFlags
    {
        static ushort UserIsSubscribed          = 0x0001;
        static ushort UserHasCancelled          = 0x0002;

        public BasicSubscriptionInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        public byte relationType;

        public byte convertMode;

        public ushort instanceIDLength;

        [WireInfo(SizeParam="instanceIDLength", NullTerminate=true)]
        public string instanceID;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public ushort gameRating;

        public byte duration;

        public byte frequency;

        public byte tierProvided;

        public byte tierRequired;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        public ulong relatedOfferID;

        public ushort responseFlags; // userIsSubscribed | userHasCancelled

        public byte pricesLength;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        [WireInfo(Serialize=false)]
        public int subscriptionStatusID;

        public bool userIsSubscribed
        {
            get
            {
                return IsFlagSet(UserIsSubscribed, responseFlags);
            }
            set
            {
                SetFlag(UserIsSubscribed, value, ref responseFlags);
            }
        }

        public bool userHasCancelled
        {
            get
            {
                return IsFlagSet(UserHasCancelled, responseFlags);
            }
            set
            {
                SetFlag(UserHasCancelled, value, ref responseFlags);
            }
        }
    }


    public class SubscriptionEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicSubscriptionInfo [] infos;

        public int offersTotal;
    }

    public class SubscriptionDetailsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryID;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageID;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionDetails.ashx";
            }
        }
    }

    public class SubscriptionDetailsResponse : XRLObject2
    {
        public BasicSubscriptionInfo basicInfo;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeContentAvailableRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentAvailable.ashx";
            }
        }
    }

    public class XeContentAvailableResponse : XRLObject2
    {
        public byte newOffersLength = 32;

        [WireInfo(SizeParam="newOffersLength")]
        public uint [] newOffers;

        public byte totalOffersLength = 32;

        [WireInfo(SizeParam="totalOffersLength")]
        public uint [] totalOffers;
    }


    public class OfferExpectedPrice : XRLObject2
    {
        public Guid offerId;

        public uint expectedPrice;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class PurchaseOffersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam="offersLength")]
        public OfferExpectedPrice [] offers;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.3")]
        public uint storeId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseOffers.ashx";
            }
        }
    }

    public class OfferMediaTypeExpectedPrice : XRLObject2
    {
        public Guid offerId;

        public int mediaTypeId;

        public uint expectedPriceWhole;

        [WireInfo(MinSchemaVersion="5.2", Min=0, Max=99)]
        public uint expectedPriceFractional;
    }

    public class PurchaseMediaOffersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam="offersLength")]
        public OfferMediaTypeExpectedPrice [] offers;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.3")]
        public uint storeId = 1;

        [WireInfo(MinSchemaVersion = "6.4")]
        public SubscriptionPurchaseInfo subscriptionPurchaseInfo=null;

        [WireInfo(MinSchemaVersion="6.9")]
        public Guid trackingGuid = Guid.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseMediaOffers.ashx";
            }
        }
    }

    public class SubscriptionPurchaseInfo : XRLObject2
    {
        [WireInfo(MinSchemaVersion = "6.4")]
        public uint subscriptionTimeExtendedInMonths = 0;
    }

    public class XeOfferPurchaseRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint offerIDLength;

        [WireInfo(SizeParam="offerIDLength", HexString=true, MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.2")]
        public ushort encryptedPasswordLength; // for wholesale providers

        [WireInfo(SizeParam="encryptedPasswordLength", MinSchemaVersion="3.2")]
        public string encryptedPassword;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchase.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseGamertag.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagResponse : XRLObject2
    {
        public byte newKeyLength;

        [WireInfo(SizeParam="newKeyLength")]
        public byte [] newKey;
    }

    public class MusicItem : XRLObject2
    {
        public ushort mnetIDLength;

        [WireInfo(SizeParam="mnetIDLength")]
        public string mnetID;

        public uint componentType;

        public ushort artistNameLength;

        [WireInfo(SizeParam="artistNameLength")]
        public string artistName;

        public ushort titleFieldLength;

        [WireInfo(SizeParam="titleFieldLength")]
        public string titleField;

        public int retailPriceInPoints;

        public decimal retailPriceInCurrency;

        public decimal wholesalePriceInCurrency;
    }

    public class XeOfferPurchaseMusicRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort ipAddressLength;

        [WireInfo(SizeParam="ipAddressLength")]
        public string ipAddress;

        public ushort externalOrderIDLength;

        [WireInfo(SizeParam="externalOrderIDLength")]
        public string externalOrderID;

        public ushort itemCount;

        [WireInfo(SizeParam="itemCount")]
        public MusicItem [] items;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseMusic.ashx";
            }
        }
    }

    public class PointsPurchaseQuery : XRLObject2
    {
        public ushort purchaseType; // DMPPurchaseType

        public ushort orderIDType; // DMPOrderIDType

        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;
    }

    public class XeGetPointsPurchaseStatusRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort queryCount;

        [WireInfo(SizeParam="queryCount")]
        public PointsPurchaseQuery [] queries;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetPointsPurchaseStatus.ashx";
            }
        }
    }

    public class PointsPurchaseStatus : XRLObject2
    {
        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;

        public int status; // DMPTransacionStatus
    }

    public class XeGetPointsPurchaseStatusResponse : XRLObject2
    {
        public ushort statusCount;

        [WireInfo(SizeParam="statusCount")]
        public PointsPurchaseStatus [] statuses;
    }

    public class WMID : XRLObject2
    {
        public ushort wmidLength;

        [WireInfo(SizeParam="wmidLength")]
        public string wmid;

        public uint videoType;
    }


    public class XRLObject2WithFlags : XRLObject2
    {
        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte) (value | flag);
            else
                value = (byte) (value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort) (value | flag);
            else
                value = (ushort) (value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }
    }

    //
    // banner of the day protocol
    //

    public enum BannerListLevel : byte
    {
        BannerOnly = 1,
        HotList = 2
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class BannerListRequest : XRLObject2
    {
        public ulong userPuid;
        public uint langId;
        public byte level;
        public int  startingIndex;
        public int  maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeBannerGetList.ashx";
            }
        }
    }

    public enum BannerType : byte
    {
        Min = 0,
        Live_Blade_Billboard = 0,
        Live_Blade_Marketplace = 1,
        Marketplace_Storefront = 2,
        V1_Marketplace_Demos_and_Game_Videos = 3,
        V1_Marketplace_Games = 4,
        V1_Marketplace_Themes_and_Gamer_Pictures = 5,
        Games_Blade_Arcade_Banner = 6,
        V1_Marketplace_Arcade = 7,
        V1_Marketplace_Game_Demos = 8,
        V1_Marketplace_Trailers_and_Game_Videos = 9,
        V1_Marketplace_Gamer_Pictures = 10,
        V1_Marketplace_Media_and_Entertainment = 11,
        MediaMarketplace_Video_Main_Large = 12,
        MediaMarketplace_Video_Main_Small = 13,
        MediaMarketplace_Video_Movies_Main = 14,
        MediaMarketplace_Video_TV_Main = 15,
        MediaMarketplace_Video_Music_Videos_Main = 16,
        MediaMarketplace_Video_Viral_Main_Top = 17,
        MediaMarketplace_Video_Viral_Main_Middle = 18,
        MediaMarketpalce_Video_Viral_Main_Bottom = 19,
        V2_Marketplace_Demos_and_Game_Videos = 20,
        V2_Marketplace_Games = 21,
        V2_Marketplace_Themes_and_Gamer_Pictures = 22,
        V2_Marketplace_Arcade = 23,
        V2_Marketplace_Game_Demos = 24,
        V2_Marketplace_Trailers_and_Game_Videos = 25,
        V2_Marketplace_Gamer_Pictures = 26,
        V2_Marketplace_Media_and_Entertainment = 27,
        V2_Marketplace_Game_Trailers = 28,
        V2_Marketplace_Gaming_Community = 29,
        V2_Marketplace_Game_Tips_and_Support_Videos = 30,
        // Added in Spring 2007
        V2_Games_Blade_Title_Promo = 31,
        V2_Marketplace_Games_Small = 32,
        V2_Marketplace_Game_Arcade_Small = 33,
        V2_Marketplace_GameDemos_Small = 34,
        V2_Marketplace_ThemesGamerPic_Small = 35,
        V2_Marketplace_Video_GameVideo_US_Small = 36,
        V2_Marketplace_Video_GameVideo_US_Large = 37,
        V2_Marketplace_Video_NonUS_Small = 38,
        V2_Marketplace_Video_GameVideo_NonUS_Small = 39,
        // Added in Fall 2007
        XBLA = 40,
        Games_Blade_Featured_Title = 41,
        Feature_Item_Flag_Slot = 42,
        Free_TV = 43,
        Games_on_Demand_Small = 44,
        Games_on_Demand_Large = 45,
        V3_Featured_Items_1 = 46,
        V3_Featured_Items_2 = 47,
        V3_Featured_Items_3 = 48,
        V3_Featured_Items_4 = 49,
        V3_Featured_Items_5 = 50,
        V3_Featured_Items_6 = 51,
        V3_Featured_Items_7 = 52,
        V3_Featured_Items_8 = 53,
        V3_Featured_Items_9 = 54,
        V3_Featured_Items_10 = 55,
        Games_Lib_Featured_BDE = 56,
        Game_AddOns_Small = 57,
        Game_AddOns_Large = 58,
        Game_Related_Downloads_small = 59,
        Game_Related_Downloads_large = 60,
        New_Arrivals = 61,
        Billboard_Games_Blade = 62,
        Billboard_Media_Blade = 63,
        Marketplace_top_level_slot_A = 64,
        Marketplace_top_level_slot_B = 65,
        Marketplace_top_level_slot_C = 66,
        BDE_Parking = 67,
        // Begin Future Slots
        Future_slot_A = 68,
        Future_slot_B = 69,
        Future_slot_C = 70,
        Future_slot_D = 71,
        Future_slot_E = 72,
        Future_slot_F = 73,
        Future_slot_G = 74,
        Future_slot_H = 75,
        // End Future Slots
        Max,
    }

    public class XOnlineString : WireData
    {
        public ushort len;
        [WireInfo(SizeParam="len")]
        public string str;
    }

    public class BannerBaseListEntry : WireData
    {
        public byte bannerType;
        public bool isMyGame;  // whether banner shows on personalized pages
        public ushort width;
        public ushort height;
        public XOnlineString path = new XOnlineString();
    }

    public class BannerHotListEntry : BannerBaseListEntry
    {
        public uint titleId;
        public XOnlineString titleName = new XOnlineString();
        public ulong offerId;
        public XOnlineString offerName = new XOnlineString();
        public OfferPrice price;
        public DateTime dateApproved;
    }

    public class BannerListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerBaseListEntry[] bannerList = null;  // can be BannerHotListEntry[]
    }

    public class BannerHotListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerHotListEntry[] hotList = null;
    }


    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeGetTitleDetailsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint titleId;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public byte tierRequired;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetTitleDetails.ashx";
            }
        }
    }

    public class XeGetTitleDetailsResponse : XRLObject2, IMeasurable
    {
        [WireInfo(HexString=true)]
        public ushort gameRating;

        public ushort titleLength;
        [WireInfo(SizeParam="titleLength")]
        public string title;

        public ushort sellTextLength;
        [WireInfo(SizeParam="sellTextLength")]
        public string sellText;

        public ushort developerLength;
        [WireInfo(SizeParam="developerLength")]
        public string developer;

        public ushort publisherLength;
        [WireInfo(SizeParam="publisherLength")]
        public string publisher;

        public ushort genreLength;
        [WireInfo(SizeParam="genreLength")]
        public string genre;

        public bool subscriptionContent;
        public bool themeContent;
        public bool demoContent;
        public bool trailerContent;
        public bool played;

        uint IMeasurable.GetSize()
        {
            uint size = 12 + 5;

            size += (uint) (titleLength + sellTextLength + developerLength + publisherLength + genreLength);

            return size;
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateTitlesByFilterRequest : XRLObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForPlayed                 = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public int genreId = 0;

        public uint offerType = 0;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // new content filter, games played filter

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateTitlesByFilter.ashx";
            }
        }

        public bool gamesWithNewContentFilter
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool gamesPlayedFilter
        {
            get
            {
                return IsFlagSet(QueryForPlayed, requestFlags);
            }
            set
            {
                SetFlag(QueryForPlayed, value, ref requestFlags);
            }
        }
    }

    public class XeEnumerateTitlesByFilterResponse : XRLObject2, IMeasurable
    {
        public uint titlesReturned = 0;

        [WireInfo(SizeParam="titlesReturned")]
        public EnumeratedTitleInfo [] titles;

        public uint totalTitleCount = 0;

        uint IMeasurable.GetSize()
        {
            uint size = 8;

            for (uint iTitle = 0; iTitle < titlesReturned; iTitle++)
            {
                size += 16;
                size += titles[iTitle].titleNameLength;
            }

            return size;
        }
    }

    public class EnumeratedTitleInfo : XRLObject2
    {
        public ushort titleNameLength;
        [WireInfo(SizeParam="titleNameLength")]
        public string titleName;

        public uint titleId;

        public bool played;

        public uint purchasedContentCount;
        public uint totalContentCount;
        public bool newContentExists;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateGenresRequest : XRLObject2
    {
        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public uint offerType = 0;
        public int parentGenreId = 0;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateGenres.ashx";
            }
        }
    }

    public class XeEnumerateGenresResponse : XRLObject2
    {
        public ushort genresReturned = 0;

        [WireInfo(SizeParam="genresReturned")]
        public EnumeratedGenreInfo [] genres;

        public uint totalGenreCount = 0;
    }

    public class EnumeratedGenreInfo : XRLObject2
    {
        public int genreId = 0;

        public ushort localizedGenreLength = 0;

        [WireInfo(SizeParam="localizedGenreLength")]
        public string localizedGenreName = "";
    }


    [WireInfo(MaxSchemaVersion = "4.9")]
    public class XeContentReferralRequest : XRLObject2
    {
        public ulong userId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentReferral.ashx";
            }
        }
    }

    public class XeContentReferralLocation : XRLObject2
    {
        public ushort rank;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_XRL_MAX_LEN)]
        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string xrl;
    }

    public class XeContentReferralResponse : XRLObject2
    {
        public uint packageSize;

        public uint installSize;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LOCATIONS_MAX_COUNT)]
        public ushort locationsCount;

        [WireInfo(SizeParam="locationsCount")]
        public XeContentReferralLocation[] locations;
    }


    public class FindMediaInstanceUrlsRequest : XRLObject2
    {
        [WireInfo(Min=1, Max=20)]
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public override string Xrl
        {
            get
            {
                return "/xbos/FindMediaInstanceUrls.ashx";
            }
        }
    }

    public class GetMediaLicenseRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        public Guid offerId;

        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public uint clientInfoLength;
        [WireInfo(SizeParam = "clientInfoLength")]
        public string clientInfo;

        public override string Xrl { get { return "/xbos/GetMediaLicense.ashx"; } }
    }

    public class GetMediaLicenseResponse : XRLObject2
    {
        public HResult resultCode;

        public Guid offerId;

        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public uint licenseLength;

        [WireInfo(SizeParam = "licenseLength")]
        public string license;
    }

    public enum MediaUrlType : int
    {
        Video               = 1,
        VideoChapter        = 2,    // unsupported by XBOX client
        SAMI                = 3,
        Image               = 4,
        Music               = 5,
        GameContent         = 6,
        App                 = 7
    }

    public class TypedMediaUrl : WireData
    {
        public int type;

        [WireInfo(Min=1, Max=500)]
        public uint length;

        [WireInfo(SizeParam="length", NullTerminate=true)]
        public string url;
    }

    public class MediaInstanceUrl : WireData
    {
        [WireInfo(MinSchemaVersion = "4.1")]
        public Guid mediaId;

        public Guid mediaInstanceId;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong packageSize;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong installSize;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(MinSchemaVersion = "5.1")] // New in Summer 2009
        public uint packageType;

        [WireInfo(Max=10)]
        public uint fileCount;

        [WireInfo(SizeParam="fileCount")]
        public TypedMediaUrl[] urls;
    }

    public class FindMediaInstanceUrlsResponse : XRLObject2
    {
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public MediaInstanceUrl[] mediaInstanceUrls;
    }


    public class XeContentRefreshLicenseRequest : XRLObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentRefreshLicense.ashx";
            }
        }
    }

    public class XeContentRefreshLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }

    public class GetTitleActivationListRequest : XRLObject2
    {
        public const uint SIGNATUREFORMAT_LITTLE_ENDIAN = 0;
        public const uint SIGNATUREFORMAT_BIG_ENDIAN    = 1;

        // machinePuid or consoleId?
        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(HexString=true)]
        public UInt32 requestedTitleId;

        [WireInfo(Min=0, Max=1)]
        public UInt32 signatureFormat;

        public override string Xrl
        {
            get
            {
                return "/xbos/GetTitleActivationList.ashx";
            }
        }
    }

    public class GetTitleActivationListResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.TITLE_ACTIVATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        // Everything below here (the body) is signed

        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(Min=0, Max=XOn.TITLE_ACTIVATION_LIST_MAX_LEN)]
        public UInt32 titlesLength;

        [WireInfo(SizeParam="titlesLength")]
        public TitleLicenseInfo[] titles;

        // Not part of protocol...

        public uint GetBodySize()
        {
            return
                + 8
                + (XOn.XONLINE_MAX_LOGON_USERS * 8)
                + 4
                + 4
                + (titlesLength * 8);
        }

    }

    public class TitleLicenseInfo : WireData
    {
        public const uint LicenseFlags_GrantedUser1   = 0x01;
        public const uint LicenseFlags_GrantedUser2   = 0x02;
        public const uint LicenseFlags_GrantedUser3   = 0x04;
        public const uint LicenseFlags_GrantedUser4   = 0x08;
        public const uint LicenseFlags_GrantedMachine = 0x10;

        [WireInfo(HexString=true)]
        public UInt32 titleId;

        [WireInfo(HexString=true)]
        public UInt32 licenseFlags;
    }

    public class XeOfferingVerifyTokenRequest : XRLObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;

        [WireInfo(HexString=true, MinSchemaVersion="4.2")]
        public ulong userPuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/XeOfferingVerifyToken.ashx"; }
        }
    }

    public class XeOfferingVerifyTokenResponse : XRLObject2
    {
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeVerifyTokenRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public uint storeId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeVerifyToken.ashx";
            }
        }
    }

    public class XeXboxOfferInfo : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeEmsOfferInfo : XRLObject2
    {
        public Guid offerId;

        public Guid mediaId;

        public uint mediaType;
    }

    public class XeVerifyTokenResponse : XRLObject2
    {
        public ushort offerCatalogType;

        public XeXboxOfferInfo xboxOfferInfo = null;

        public XeEmsOfferInfo emsOfferInfo = null;
    }

    public class XeGetRevocationListRequest : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE)]
        public byte[] clientNonce;

        public override string Xrl
        {
            get { return "/xbos/GetRevocationList.ashx"; }
        }
    }

    public class XeGetRevocationListReply : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SERVER_NONCE_SIZE)]
        public byte[] serverNonce;

        [WireInfo(Max=XOn.REVOCATION_LIST_MAX_ENTRIES)]
        public uint numListEntries;

        [WireInfo(SizeParam="numListEntries")]
        public RevocationListEntry[] entries;
    }

    public class RevocationListEntry : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_ENTRY_DIGEST_SIZE)]
        public byte[] digest;
    }


    public class Asset : WireData
    {
        public uint     assetID;

        public int      quantity;        // signed quantity, may be negative during Consume
    }

    public class AssetEnumerateRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        [WireInfo(MinSchemaVersion = "6.9")]
        public bool signAssets = true;

        public uint     flags;          // unused

        public ushort   startingIndex;

        public ushort   maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetEnumerate.ashx";
            }
        }
    }

    // Signable asset structure.
    public class AssetPackage : WireData
    {
        public DateTime  dtAssets;

        public uint     cAssets;

        public uint     cTotalAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset[]  assets;
    }

    public class AssetEnumerateResponse : XRLObject2
    {
        public const int ASSET_SIGNATURE_SIZE = 256;

        [WireInfo(ArraySize=ASSET_SIGNATURE_SIZE)]
        public byte[]   signature;

        public AssetPackage package;
    }

    public class AssetConsumeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        [WireInfo(MinSchemaVersion = "6.9")]
        public Guid trackingGuid;

        public uint     cAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset []  assets;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetConsume.ashx";
            }
        }
    }

    public class AssetConsumeResponse : XRLObject2
    {

    }

    public class XeWmdrmCreateCertificateRequest : XRLObject2
    {
        public const int DEVICE_PUBLIC_KEY_LEN = 40;

        [WireInfo(Min=0, Max=0)]
        public uint flags;

        [WireInfo(ArraySize=DEVICE_PUBLIC_KEY_LEN)]
        public byte[] devicePublicKey;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeWmdrmCreateCertificate.ashx";
            }
        }
    }

    public class XeWmdrmCreateCertificateReply : XRLObject2
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_COUNT = 2;

        [WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;

        [WireInfo(SizeParam="certBlockCount")]
        public XeGenericBlock[] certBlocks;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentHistoryEnumerateRequest : XRLObject2WithFlags
    {
        static byte QueryForIsAcquirable = 0x0001;

        [WireInfo(HexString=true)]
        public ulong userPuid; // user's live XUID making the request

        [WireInfo(MinSchemaVersion = "3.0")]
        public ulong machinePuid;

        public byte countryID; // live Country

        public ushort languageID; // live Language

        [WireInfo(HexString=true)]
        public uint offerType; // content OfferTypes, or SyncCastWMIS

        [WireInfo(HexString=true)]
        public byte requestFlags; // isAcquirableOnlyFilter

        public int startingIndex;

        public int maxResults;

        public bool isAcquirableOnlyFilter
        {
            get
            {
                return IsFlagSet(QueryForIsAcquirable, requestFlags);
            }
            set
            {
                SetFlag(QueryForIsAcquirable, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentHistoryEnumerate.ashx";
            }
        }
    }

    public class ContentHistoryEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentHistoryInfo [] infos;

        public uint offersTotal;
    }

    public class BasicContentHistoryInfo : XRLObject2WithFlags
    {
        static ushort IsAcquirable = 0x0001;
        static ushort IsUnrestricted = 0x0002;

        public BasicContentHistoryInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID; // OfferID for Xbox-LIVE true/full Offers

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName; // Text-Name for the above offerID

        public uint offerType; // content OfferTypes, or SyncCastWMIS

        public uint titleID; // primary TitleID that the Offer belongs to

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName; // Text-Name for above titleID

        public ushort responseFlags; // isAcquirable, isUnrestricted

        public WMID wmid; // WMIS Guid/Type structure (movie/tv episode/tv season)

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licenseAcknowledged;

        [WireInfo(MinSchemaVersion = "3.0")]
        public DateTime licenseExpiration;

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licensedOnMachine;

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, responseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }
    }

    public class InGameOfferPrice : WireData
    {
        public uint paymentType;

        public int price;

        public ushort priceTextLength;

        [WireInfo(SizeParam="priceTextLength", NullTerminate=true)]
        public string priceText;
    }

    public class InGameContentInfo : XRLObject2WithFlags
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort IsAcquirable              = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsUnrated                 = 0x0008;

        public InGameContentInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        public uint licenseMask;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public byte tierRequired;

        public ushort emsGameRating;

        public ushort responseFlags; // userHasPurchased, IsAcquirable, isUnrestricted

        public uint packageSize;

        public uint installSize;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        public uint assetID;

        public uint purchaseQuantity;

        public byte pricesLength;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.DateTime maxStartDate;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.Guid emsOfferId;

        [WireInfo(SizeParam="pricesLength")]
        public InGameOfferPrice [] prices;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, responseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isUnrated
        {
            get
            {
                return IsFlagSet(IsUnrated, responseFlags);
            }
            set
            {
                SetFlag(IsUnrated, value, ref responseFlags);
            }
        }
    }



    public class InGameContentEnumerateRequest : XRLObject2WithFlags
    {
        static byte HideUnratedContentFilter    = 0x01;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryID;

        public ushort liveLanguageID;

        [WireInfo(HexString=true)]
        public ushort emsGameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // content, points bundle, gamertag, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public byte requestFlags; // hideUnratedContentFilter

        [WireInfo(Min = 0, Max = 100, MinSchemaVersion = "5.1")]
        public ushort offerIdsLength;

        [WireInfo(SizeParam = "offerIdsLength", MinSchemaVersion = "5.1")]
        public ulong[] offerIDs;

        [WireInfo(HexString=true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public bool hideUnratedContentFilter
        {
            get
            {
                return IsFlagSet(HideUnratedContentFilter, requestFlags);
            }
            set
            {
                SetFlag(HideUnratedContentFilter, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/InGameContentEnumerate.ashx";
            }
        }
    }

    public class InGameContentEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public InGameContentInfo [] infos;

        public uint offersTotal;
    }
    public class InGameContentAvailableRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort liveLanguageID;

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        public DateTime lastViewed = DateTime.UtcNow;

        [WireInfo(HexString=true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types

        public override string Xrl
        {
            get
            {
                return "/xbos/InGameContentAvailable.ashx";
            }
        }
    }

    public class InGameContentAvailableResponse : XRLObject2
    {
        public byte newOffersLength = 32;

        [WireInfo(SizeParam="newOffersLength")]
        public uint [] newOffers;

        public byte totalOffersLength = 32;

        [WireInfo(SizeParam="totalOffersLength")]
        public uint [] totalOffers;
    }

    /// <summary>
    /// Xrl request for Preview Product Purchase API
    /// </summary>
    public class PreviewProductPurchaseRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam = "offersLength")]
        public OfferProductInfo[] offers;

        [WireInfo(HexString = true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam = "paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public uint storeId = 1;

        [WireInfo(MinSchemaVersion = "6.6")]
        public ushort billingTokenLength=0;

        [WireInfo(SizeParam = "billingTokenLength", MinSchemaVersion = "6.6")]
        public string billingToken=string.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }
    }

    /// <summary>
    /// Offer Product Info class
    /// </summary>
    public class OfferProductInfo : XRLObject2
    {
        public Guid offerId;

        public int productTypeId;
    }

    public class PreviewProductPurchaseResponse : XRLObject2
    {
        public Guid offerId;

        public double offerPrice;

        public PreviewSubscriptionProductInfo previewSubscriptionInfo;

        public int taxTypeId;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }

    }

    public class PreviewSubscriptionProductInfo : XRLObject2
    {
        public Guid subscriptionId;

        public bool autoRenewal;

        public double nextChargeAmount;

        public DateTime nextChargeDate;

        public double netPrice;

        public double discount;

        public int timeExtendedinMonths;

        public Guid defaultRenewalOfferId = Guid.Empty;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xdelay.cs ===
/******************************************************************************
  
  Copyright (c) 2003 Microsoft Corporation
  
  xdelay.cs
  
  Server side support for client throttling. Provides a common way for services
  to add the X-Delay http header to their responses.
  
  
******************************************************************************/ 

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Web;
using System.Xml.XPath;

using STF.common.config;
using STF.common.mgmt;


namespace STF.common.service 
{
    // XDelay
    // Provides a common way for server applications to support client 
    // throttling though the X-Delay header.
    [ComVisible(false)]
    public class XDelay
    {
        
        static XDelay()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XDelay.OnControlRequest);
            Config.XdelaySettingsChange += new XdelaySettingsChangeEventHandler(XDelay.OnXdelaySettingsChange);
        }
        
        // AddDelayHeader
        // Add X-Delay header to the application's response. 
        //
        // Normally, this will automatically be called by XRLUtil.SetXRLResponse(), using
        // the current page name as the setting.
        //
        // Call this directly (*after*, or in leiu of, calling SetXRLResponse()) iif you 
        // want to set the delay to some custom setting.  
        //
        static public void AddDelayHeader(HttpResponse resp, uint uiTitleId, string reqType)
        {
            RequestParameters reqparam = null;
            bool usingDefaultParameters = false;
            
            if (_parameters == null)
            {
                lock(typeof(XDelay))
                {
                    if(_parameters == null)
                    {
                        LoadConfiguration();
                    }
                }
            }
            
            if (_parameters != null)        
            {        
                // Look for title specific configuration        
                reqparam = (RequestParameters) _parameters[new TitleIdRequestKey(uiTitleId, reqType)];        
                    
                if (reqparam == null)
                {        
                    // Try default configuration
                    reqparam = (RequestParameters) _parameters[new TitleIdRequestKey(0, reqType)];        
                    usingDefaultParameters = true;
                }        

                if(reqparam != null)
                {
                    if(reqparam.delay != 0)
                    {
                        if(!usingDefaultParameters ||     // Bug 34183 - don't use default delay on xbox 1
                           !SGInfo.IsXbox())
                        {
                            // Add Header        
                            resp.AppendHeader("X-Delay", reqparam.delay.ToString());       
                        }
                    }
                    
                    if(reqparam.sleep != 0 &&           // Bug 41972 - only sleep for xbox 1
                       SGInfo.IsXbox())
                    {
                        Thread.Sleep(reqparam.sleep);
                    }
                }
            }   
        }
        
        // LoadConfiguration
        // Loads or reloads configuration.
        static public void LoadConfiguration()
        {
            try
            {
                _parameters = LoadConfigurationFromNpdb();
            }
            catch(Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_276,
                    "Failed to process Xdelay settings", e);
            }
        }

        protected static Hashtable LoadConfigurationFromNpdb() 
        {
            SqlConnection sql       = null;
            SqlDataReader reader    = null;
            Hashtable parameters    = new Hashtable();
            StringCollection pages  = GetPageList();
            
            try
            {
                sql = new SqlConnection(Config.NpdbConnectionString);
                sql.Open();
    
                SqlCommand cmd = new SqlCommand("dbo.p_xdelay_get_settings", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = Config.ComponentName;
                reader = cmd.ExecuteReader();
                
                while(reader.Read())
                {
                    UInt32 titleId   = (UInt32) reader.GetInt32(0);
                    string request   = reader.GetString(1).ToLower();
                    
                    RequestParameters reqparam = new RequestParameters();
                    reqparam.delay = reader.GetInt32(2);
                    reqparam.sleep = reader.GetInt32(3);
                    
                    if (!pages.Contains(request))
                    {
                      Xom.NtEvent(XEvent.Id.COMMON_CONFIG_277, "Throttle setting " + request + " does not have a matching URL in web.config!");    
                    }    
                    
                    parameters[new TitleIdRequestKey(titleId, request)] = reqparam;
                }
                
                return parameters;
            }
            finally
            {
                if(reader != null)
                    reader.Close();
                    
                if(sql != null)
                    sql.Close();
            }
        }

        public static StringCollection GetPageList()
        {
            StringCollection pages = new StringCollection();
            XPathDocument doc = new XPathDocument(Path.GetDirectoryName( AppDomain.CurrentDomain.BaseDirectory ) + "\\web.config");
            
            XPathNavigator root = doc.CreateNavigator();
            XPathNodeIterator iter = root.Select("/configuration/system.webServer/handlers/add");
            
            while (iter.MoveNext())
            {
                pages.Add(Path.GetFileNameWithoutExtension(iter.Current.GetAttribute("path", "")).ToLower());
            }
            
            return pages;
            
        }
        
        static volatile protected Hashtable _parameters = null;
        // static public string _configFile = Path.GetDirectoryName( AppDomain.CurrentDomain.BaseDirectory ) + "\\throttling.ini";        

        
        // Common config will notify us when settings change in the database giving
        // us an opportunity to 
        public static void OnXdelaySettingsChange(object sender, EventArgs args)
        {
            LoadConfiguration();  
        }
        
        //
        // Control stuff
        //
    
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                case "help":
                    XomControlConnection.SendMessage("Throttling help:\r\n" +
                                " ReloadThrottleConfig (rtc) -- Reloads the throttling config settings.\r\n" +
                                " SetXDelay HexTitleID RequestName DelayInMS -- Manually sets XDelay for titleID/request pair.\r\n" +
                                "   Operations should always modify throttling.ini and use ReloadThrottleConfig.\r\n" +
                                "   SetXDelay is for test team usage only.\r\n",
                                args.RequestId);
                    
                    args.Handled = true;
                    break;
                    
                case "reloadthrottleconfig":
                case "rtc":
                    XomControlConnection.SendMessage(ProcessReloadConfig(args), args.RequestId);
                    args.Handled = true;
                    break;

                case "setxdelay":
                    XomControlConnection.SendMessage(ManuallySetXDelay(args), args.RequestId);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static string ProcessReloadConfig(ControlRequestEventArgs args)
        {
            try
            {
                LoadConfiguration();
                return "Throttling configuration reloaded.";
            }
            catch (Exception e)
            {
                return "Error reloading configuration!\r\n" + e.ToString();
            }    
                
        }
        
        public static string ManuallySetXDelay(ControlRequestEventArgs args)
        {
            try
            {
                if ( args.CommandArgs.Length < 3 )
                {
                    throw new Exception("Usage: SetXDelay HexTitleID RequestName DelayInMS [SleepInMS]");
                }
                
                StringCollection pages = GetPageList();
                    
                uint uiTitleId = 0;
                    
                uiTitleId = Convert.ToUInt32(args.CommandArgs[0], 16);

                string requestName = args.CommandArgs[1].ToLower();
                if (!pages.Contains(requestName))
                {
                    throw new Exception(requestName + " is not a valid URL prefix");
                }    
                
                // find the RequestParameters object for the titleid, 
                // requestName key pair so we can update it. If there is no 
                // such object, create a new one.
                
                TitleIdRequestKey key      = new TitleIdRequestKey(uiTitleId, requestName);
                RequestParameters reqparam  = (RequestParameters) _parameters[key];
                if(reqparam == null)
                {
                    reqparam = new RequestParameters();
                    _parameters[key] = reqparam;
                }

                // update delay
                int iDelay = Convert.ToInt32(args.CommandArgs[2]);
                
                if(iDelay < 0 || iDelay > 20000)
                {
                    throw new Exception("Invalid delay: " + iDelay);
                }

                reqparam.delay = iDelay;

                // update sleep
                if(args.CommandArgs.Length >= 4)
                {
                    int sleep = Convert.ToInt32(args.CommandArgs[3]);

                    if(sleep < 0 || sleep > 20000)
                    {
                        throw new Exception("Invalid sleep: " + sleep);
                    }

                    reqparam.sleep = sleep;
                }
                
                return string.Format("Manually Set XDelay for titleID {0} request {1} to delay {2}, sleep {3}",
                                     uiTitleId.ToString("X"), requestName, reqparam.delay.ToString(), reqparam.sleep.ToString());
            }
            catch (Exception e)
            {
                args.hr = HResult.E_FAIL;
                return "Error Manually Setting XDelay: " + e.ToString();
            }
        }
    
        
        // TitleIdRequestKey
        // Hashtable key made of uiTitleId + requestType
        protected struct TitleIdRequestKey
        {
            public TitleIdRequestKey(uint uiTitleId, string requestType)
            {
                _uiTitleId = uiTitleId;
                _iRequestType = requestType.ToLower().GetHashCode();
            }
            
            public override int GetHashCode() 
            {
                return ((int)_uiTitleId) + ((int)_iRequestType);
            }
    
            public override bool Equals(object obj)
            {
                TitleIdRequestKey otherObj = (TitleIdRequestKey) obj;
                return (otherObj._uiTitleId == _uiTitleId) &&
                    (otherObj._iRequestType == _iRequestType);
            }
            
            public uint     _uiTitleId;
            public int      _iRequestType;
        }

        // RequestParameters
        // Parameters for the request
        protected class RequestParameters
        {
            public int delay = 0;       // delay in milliseconds. Only one request can be made every delay period. the client is required to wait/delay the next request if the required time hasn't passed by.
            public int sleep = 0;       // sleep in milliseconds. The server will sleep for this period of time before returning the response to the request to the client. this only applies to xbox 1 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xcryptoprot.cs ===
using System;

using STF.common.service;

namespace STF.common.protocol
{
    public class XCryptoRequestBase : XRLObject2
    {
        public uint containerClass;
    }

    public class XCryptoData : WireData
    {
        [WireInfo(Min=1)]
        public uint dataLength;

        [WireInfo(SizeParam="dataLength")]
        public byte[] data;

        public XCryptoData()
        {
        }

        public XCryptoData(byte[] data)
            : this(data, data.Length)
        {
        }

        public XCryptoData(byte[] data, int dataLength)
        {
            this.data = data;
            this.dataLength = (uint)dataLength;
        }
    }

    public class XCryptoSignRequest : XCryptoRequestBase
    {
        public XCryptoData sha1;

        public override string Xrl { get { return "/xcrypto/XCryptoSign.ashx"; } }
    }

    public class XCryptoSignResponse : XRLObject2
    {
        public XCryptoData sig;
    }


    public class XCryptoVerifySignatureRequest : XCryptoRequestBase
    {
        public XCryptoData sha1;

        public XCryptoData sig;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifySignature.ashx"; } }
    }

    public class XCryptoVerifySignatureResponse : XRLObject2
    {
        public bool verified;
    }


    public class XCryptoVerifyConsolePakRequest : XCryptoRequestBase
    {
        public const int DATA_SIZE = 16;

        public UInt64 consoleId;

        public XCryptoData clear;

        public XCryptoData pakEncrypted;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifyConsolePak.ashx"; } }
    }

    public class XCryptoVerifyConsolePakResponse : XRLObject2
    {
        public bool verified;
    }

    public class XCryptoDecryptRequest : XCryptoRequestBase
    {
        public XCryptoData cipher;

        public override string Xrl { get { return "/xcrypto/XCryptoDecrypt.ashx"; } }
    }

    public class XCryptoDecryptResponse : XRLObject2
    {
        public XCryptoData clear;
    }

    public class XCryptoEncryptRequest : XCryptoRequestBase
    {
        public XCryptoData clear;

        public override string Xrl { get { return "/xcrypto/XCryptoEncrypt.ashx"; } }
    }

    public class XCryptoEncryptResponse : XRLObject2
    {
        public XCryptoData cipher;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XEvent.cs ===
using System;
using System.Diagnostics;

namespace STF.common.service {
    public partial class XEvent {
        public enum Severity : uint {
            Info    = 0x40000000,
            Warning = 0x80000000,
            Error   = 0xC0000000
        }

        public static Severity SeverityFromId(XEvent.Id eventId)
        {
            uint severity = ((uint) eventId) & 0xC0000000;
            Debug.Assert(severity != 0);
            return (Severity) severity;
        }

        public static ushort MessageFromId(XEvent.Id eventId)
        {
            return (ushort) (((uint) eventId) & 0xFFFF);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XmlUtil.cs ===
//
// XmlUtil.cs
//
// Pretty-print XML documents into a formatted string
//

using System.IO;
using System.Runtime.InteropServices;
using System.Xml;

namespace STF.common.utilities2
{
    //
    // XmlPrettyPrint
    //

    [ComVisible(false)]
    public class XmlUtil
    {
        public static string PrettyPrint(string xml)
        {
            return PrettyPrint(xml, 4);
        }

        public static string PrettyPrint(string xml, int indentLevel)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xml);
            return PrettyPrint(xmlDoc, indentLevel);
        }

        public static string PrettyPrint(XmlDocument xmlDoc)
        {
            return PrettyPrint(xmlDoc, 4);
        }

        public static string PrettyPrint(XmlDocument xmlDoc, int indentLevel)
        {
            StringWriter sw = new StringWriter();

            XmlTextWriter xw = new XmlTextWriter(sw);
            xw.Namespaces = true;
            xw.Formatting = Formatting.Indented;
            xw.Indentation = indentLevel;
            xw.QuoteChar = '\'';
            xmlDoc.WriteTo(xw);
            xw.Close();

            // return the pretty-printed XML string
            return sw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomAdmin.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections;

using STF.common.service;

namespace STF.common.mgmt
{
    // this class provides a simple, syncronous, way to issue xon management
    // commands remotely
    [ComVisible(false)]
    public class XomAdminSession
    {
        // this constant is taken from private\mgmt\inc\xomcontrolprot.h
        // don't change it unless you're chaning xomcontrolprot.h.
        // it came first, so it's the master copy
        const int XOMCTRL_ADMIN_PORT = 4100;

        private Socket m_socket;
        private NetworkStream m_networkStream;

        private StreamReader m_streamReader;
        private delegate int StreamReaderReadBlock(char[] rgc, int iIndex, int iMaxCount);
        private delegate string StreamReaderReadLine();
        private StreamReaderReadBlock m_delegateStreamReaderReadBlock;
        private StreamReaderReadLine m_delegateStreamReaderReadLine;

        private StreamWriter m_streamWriter;
        private delegate void StreamWriterWrite(string s);
        private StreamWriterWrite m_delegateStreamWriterWrite;

        // this is the constructor we expect to use most of the time, which knows
        // the port we're trying to connect to. The other constructor is useful
        // for unit testing purposes
        public XomAdminSession(IPAddress ipAddress) : this(ipAddress, XOMCTRL_ADMIN_PORT)
        {
        }

        public XomAdminSession(IPAddress ipAddress, int iPort)
        {
            m_socket = new Socket(
                ipAddress.AddressFamily, 
                SocketType.Stream, 
                ProtocolType.Tcp);

            IPEndPoint ipEndPoint = new IPEndPoint(ipAddress, iPort);

            m_socket.Connect(ipEndPoint);

            // new network stream to wrap the raw socket
            m_networkStream = new NetworkStream(m_socket);

            // a stream reader to wrap the network stream using ASCII encoding
            // the C++ code that implement xmgmtsrv uses char* with the expectation
            // that all messages are text, so ASCII is the right choice.
            m_streamReader = new StreamReader(m_networkStream, new ASCIIEncoding());
            
            // delgates for the stream reader methods we want to be able to call asyncronously
            m_delegateStreamReaderReadBlock = new StreamReaderReadBlock(m_streamReader.ReadBlock);
            m_delegateStreamReaderReadLine = new StreamReaderReadLine(m_streamReader.ReadLine);

            // a stream writer around the network stream using ASCII encoding
            m_streamWriter = new StreamWriter(m_networkStream, new ASCIIEncoding());

            // without this, our command doesn't get sent in a timely fashion, and
            // we'll timeout waiting for the reply to command that still sitting in
            // an output buffer on our machine!
            m_streamWriter.AutoFlush = true;

            // delgate for the stream writer method we want to be able to call asyncronously
            m_delegateStreamWriterWrite = new StreamWriterWrite(m_streamWriter.Write);
        }

        public void Close()
        {
            m_streamReader.Close();
            m_streamWriter.Close();
            m_networkStream.Close();
            m_socket.Shutdown(SocketShutdown.Both);
            m_socket.Close();
        }

        public void SendRequest(
            string sRequest,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out int hrResultCode
        )
        {
            HResult hr;
            SendRequest(sRequest, iTimeoutMilliseconds, out rgsResponses, out hr);
            hrResultCode = (int) (uint) hr;
        }
        
        public void SendRequest(
            string sRequest,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out HResult hrResultCode
        )
        {
            if (sRequest == null)
            {
                throw new ArgumentNullException("sRequest");
            }

            // add \r\n to the request string, if they are not already there...
            if (!sRequest.EndsWith("\r\n"))
            {
                sRequest += "\r\n";
            }

            WriteString(sRequest, iTimeoutMilliseconds);

            // reply is in the following format:
            // first comes zero or more response blocks
            // each response block is in the form of:
            // Size=<size-of-response-block-in-bytes>\r\n<response-block>
            // after all response blocks comes the result block
            // the result block is in the form of:
            // Result=<unsigned-32bit-result-code>\r\n

            ArrayList alResponses = new ArrayList();
            while(true)
            {
                // read a line
                string sLine = ReadLine(iTimeoutMilliseconds);

                // split the line into the token before the = 
                // and the value after the =
                string[] sLineSplit = sLine.Split('=');

                // make sure we have two parts
                if (sLineSplit.Length != 2)
                {
                    string sErr = "Format of admin command response is not correct. "
                        + "Admin command: " + sRequest
                        + "Invalid response fragment: " + sLine;
                    throw new XomException(sErr);
                }

                // let's be nice about accepting whitespace and case
                string sBlockType = sLineSplit[0].Trim().ToUpper();
                string sBlockData = sLineSplit[1].Trim().ToUpper();

                if (sBlockType == "SIZE")
                {
                    // how big is the response block?
                    int iSize;
                    try
                    {
                        iSize = (int)UInt32.Parse(sBlockData);
                    }
                    catch (Exception e)
                    {
                        string sErr = "Unable to parse size of admin command response. "
                            + "Admin command: " + sRequest
                            + "Invalid response fragment: " + sLine
                            + "Exception details: " + e.Message;
                        throw new XomException(sErr);
                    }

                    string sResponse = ReadString(iSize, iTimeoutMilliseconds);
                    alResponses.Add(sResponse);
                }
                else if (sBlockType == "RESULT")
                {
                    // parse the result code
                    try
                    {
                        hrResultCode = UInt32.Parse(sBlockData);
                    }
                    catch (Exception e)
                    {
                        string sErr = "Unable to parse result code in admin command response. "
                            + "Admin command: " + sRequest
                            + "Invalid response fragment: " + sLine
                            + "Exception details: " + e.Message;
                        throw new XomException(sErr);
                    }
                    // this marks the end of the command response, so break out of the loop
                    break;
                }
                else
                {
                    // only "Size" and "Result" are expected!
                    string sErr = "Unknown admin command response. "
                        + "Admin command: " + sRequest
                        + "Unknown response fragment: " + sLine;
                    throw new XomException(sErr);
                }
            }

            // translate the array list into an array to return
            rgsResponses = new string[alResponses.Count];
            alResponses.CopyTo(rgsResponses);
        }

        // a little wrapper around SendRequest that composes a command string
        public void SendCommand(
            string sProcess,
            string sComponent,
            string sCommand,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out int hrResultCode
        )
        {
            HResult hr;
            SendCommand(sProcess, sComponent, sCommand, iTimeoutMilliseconds, out rgsResponses, out hr);
            hrResultCode = (int) (uint) hr;
        }

        public void SendCommand(
            string sProcess,
            string sComponent,
            string sCommand,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out HResult hrResultCode
        )
        {
            // need to have either a process or a compoent to send the command to
            if (sProcess == null && sComponent == null)
            {
                throw new ArgumentNullException("sProcess and sComponent");
            }

            // need to have a command
            if (sCommand == null)
            {
                throw new ArgumentNullException("sCommand");
            }

            // assemble the request string
            string sRequest
                = "exec "
                + (sProcess == null ? String.Empty : sProcess)
                + ":"
                + (sComponent == null ? String.Empty : sComponent)
                + " "
                + sCommand;

            // send the request
            SendRequest(sRequest, iTimeoutMilliseconds, out rgsResponses, out hrResultCode);
        }

        // a wrapper to grab and parse the output of the list command into a
        // convenient form
        public XomProcessComponentPair[] List(int iTimeoutMilliseconds)
        {
            string[] rgsResponses = null;
            int hrResultCode = -1;
            SendRequest(
                "list",
                iTimeoutMilliseconds,
                out rgsResponses,
                out hrResultCode);
            if (hrResultCode != 0)
            {
                throw new XomException(
                    "non-zero hresult returned from 'list' request. hr=" 
                    + hrResultCode.ToString());
            }

            XomProcessComponentPair[] rgXomProcessComponentPairs 
                = new XomProcessComponentPair[rgsResponses.Length];
            for (int i = 0; i < rgsResponses.Length; ++i)
            {
                string sResponse = rgsResponses[i];

                // we expect one process / component pair per response
                // the expected format of each response is:
                // process-name(pid) component-name

                // trim the string, then split it on the space in the middle
                string[] rgsResponseSplit = sResponse.Trim().Split(' ');

                // we should only get two parts from the split
                if (rgsResponseSplit.Length != 2)
                {
                    throw new XomException("Unable to parse response to list command. Reponse fragment: "
                        + sResponse);
                }

                // the second part is the component name
                string sComponent = rgsResponseSplit[1];

                // if we split again on the '('character, we'll get the process name by itself
                string []rgsProcessSplit = rgsResponseSplit[0].Split('(');

                // again, we should only get two parts from the split
                if (rgsProcessSplit.Length != 2)
                {
                    throw new XomException("Unable to parse response to list command. Reponse fragment: "
                        + sResponse);
                }

                // the first part is the process name
                string sProcess = rgsProcessSplit[0];

                // now create the process component pair object in the array
                rgXomProcessComponentPairs[i] = new XomProcessComponentPair(sProcess, sComponent);
            }

            // done, return the array
            return rgXomProcessComponentPairs;
        }

        private string ReadLine(int iTimeoutMilliseconds)
        {
            IAsyncResult iAsyncResult = m_delegateStreamReaderReadLine.BeginInvoke(null, null);

            // wait for up to iTimeoutMilliseconds for the read operation
            // to complete
            bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
            if (!bSignal)
            {
                // the wait timed out!
                throw new XomException("Error: " 
                    + iTimeoutMilliseconds 
                    + " millisecond timeout expired waiting for response from admin server");
            }

            string sLine = m_delegateStreamReaderReadLine.EndInvoke(iAsyncResult);
            return sLine;
        }

        private string ReadString(int iLength, int iTimeoutMilliseconds)
        {
            int iTotalCharsRead = 0;
            char[] rgc = new char[iLength];

            while (iTotalCharsRead < iLength)
            {
                IAsyncResult iAsyncResult 
                    = m_delegateStreamReaderReadBlock.BeginInvoke(
                        rgc,
                        iTotalCharsRead, 
                        iLength - iTotalCharsRead,
                        null, 
                        null);

                // wait for up to iTimeoutMilliseconds for the read operation
                // to complete
                bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
                if (!bSignal)
                {
                    // the wait timed out!
                    throw new XomException("Error: " 
                        + iTimeoutMilliseconds 
                        + " millisecond timeout expired waiting for response from admin server");
                }

                iTotalCharsRead += m_delegateStreamReaderReadBlock.EndInvoke(iAsyncResult);
            }

            return new String(rgc);
        }

        private void WriteString(string s, int iTimeoutMilliseconds)
        {
            IAsyncResult iAsyncResult 
                = m_delegateStreamWriterWrite.BeginInvoke(
                    s,
                    null, 
                    null);

            // wait for up to iTimeoutMilliseconds for the read operation
            // to complete
            bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
            if (!bSignal)
            {
                // the wait timed out!
                throw new XomException("Error: " 
                    + iTimeoutMilliseconds 
                    + " millisecond timeout expired waiting for response from admin server");
            }

            m_delegateStreamWriterWrite.EndInvoke(iAsyncResult);
        }
    }


    [ComVisible(false)]
    public class XomProcessComponentPair
    {
        private string m_sProcess;
        private string m_sComponent;

        public string Process
        {
            get
            {
                return m_sProcess;
            }
        }

        public string Component
        {
            get
            {
                return m_sComponent;
            }
        }

        public XomProcessComponentPair(string sProcess, string sComponent)
        {
            if (sProcess == null)
            {
                throw new ArgumentNullException("sProcess");
            }
            if (sComponent == null)
            {
                throw new ArgumentNullException("sComponent");
            }

            m_sProcess = sProcess;
            m_sComponent = sComponent;
        }
    }

    [ComVisible(false)]
    public class XomException : ApplicationException
    {
        public XomException() : base() {}
        public XomException(string s) : base(s) {}
        protected XomException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public XomException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomControl.cs ===
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using STF.common.service;


namespace STF.common.mgmt
{
[ComVisible(false)]
public static class XomControl
{
    // 
    // event callback stuff
    //
    [ComVisible(false)]
    public delegate void ControlRequestEventHandler (object sender, ControlRequestEventArgs args);

    private static ControlRequestEventHandler eventHandler;

    public static event ControlRequestEventHandler ControlRequestEvent
    {
        [MethodImpl(MethodImplOptions.Synchronized)]
        add
        {
            ControlRequestEventHandler prev = eventHandler;
            eventHandler = (ControlRequestEventHandler)Delegate.Combine(eventHandler, value);

            // Only startup if this is the first entry to be added
            if (prev == null && eventHandler != null && _isXmgmtConnectionOn)
            {
                XomControlConnection.Startup();
            }
        }

        [MethodImpl(MethodImplOptions.Synchronized)]
        remove
        {
            ControlRequestEventHandler prev = eventHandler;
            eventHandler = (ControlRequestEventHandler)Delegate.Remove(eventHandler, value);

            if (prev != null && eventHandler == null && _isXmgmtConnectionOn)
            {
                XomControlConnection.Shutdown();
            }
        }
    }

    [MethodImpl(MethodImplOptions.Synchronized)]
    public static void OnControlRequest(ControlRequestEventArgs args)
    {
        if (!_isXmgmtConnectionOn)
            return;
        
        if (eventHandler != null)
        {
            eventHandler(null, args);
        }

        if (args.Handled == false)
        {
            XomControlConnection.SendMessage("Unknown command.\r\n", args.RequestId);
        }
    }

    public static bool ConnectToXmgmt
    {
        get { return _isXmgmtConnectionOn; }
        set { 
                if ( null == eventHandler ) // otherwise it's too late to turn the XMgmt Connection off
                    _isXmgmtConnectionOn = value;
            }
    }
    
    private static bool _isXmgmtConnectionOn = true;
}


[ComVisible(false)]
public class ControlRequestEventArgs : EventArgs
{
    public string FullCommand;
    public string Command;
    public string[] CommandArgs;
    public uint RequestId;

    private HResult _hr = HResult.S_OK;

    public HResult hr
    {
        get
        {
            return _hr;
        }
        set
        {
            if (_hr.IsOk())
            {
                // We're going to keep the first hr != S_OK
                _hr = value;
            }
        }
    }

    // NOTE: this should only be set by event handlers to true when 
    //       an event is responded to.    otherwise, don't set it!
    public bool Handled;
    
    public ControlRequestEventArgs (string message, uint requestId)
    {
        FullCommand = message.Trim();

        // BUGBUG: this won't accept spaces in params values
        string[] parts = FullCommand.Split(new char[] {' '});
        
        //  Remove any zero-length parameters
        ArrayList tempPartsArray = new ArrayList();
        foreach(string part in parts)
        {
            if(part.Length != 0)
                tempPartsArray.Add(part);
        }

        //  Copy to final array
        parts = new string[tempPartsArray.Count];
        tempPartsArray.CopyTo(parts);

        //  Process the command
        this.Command = parts[0].ToLower();
        this.CommandArgs = new string[parts.Length-1]; // Always make it safe for callers to check the length of this
        if (parts.Length > 1)
        {
            Array.Copy(parts, 1, this.CommandArgs, 0, parts.Length-1);
        }
        
        this.RequestId = requestId;
        this.Handled = false;
    }
}

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomDictionary.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Linq;

namespace STF.common.mgmt
{
    [ComVisible(false)]
    public class XomDictionary<TObject>
    {
        // IMPORTANT NOTE:
        //
        // This file follows this pattern when accessing _ObjectsByName:
        //
        // READ operations:
        //   1. Get local reference to _ObjectsByName
        //   2. Do read operation
        //
        // Note: if read operation requires a single reference to _ObjectsByName, there is 
        // no need to get a local reference.
        //
        // WRITE operations:
        //   1. Get local reference to _ObjectsByName
        //   2. Perform a copy of it
        //   3. Do write operation
        //   4. Assign _ObjectsByName to local reference
        //

        private volatile Dictionary<string, TObject>  _ObjectsByName;
        private object                                _WriterLock;

        public XomDictionary()
        {
            _ObjectsByName = new Dictionary<string, TObject>(StringComparer.InvariantCultureIgnoreCase);
            _WriterLock = new object();
        }

        public TObject this[string key]
        {
            get
            {
                // We're changing the expected behavior -- this will return null if the 
                // key does not exist. Dictionary would throw an exception, but the 
                // xmgmt code seems to expect a null.

                TObject obj;
                if (!_ObjectsByName.TryGetValue(key, out obj))
                {
                    obj = default(TObject);
                }
                return obj;
            }

            set
            {
                Add(key, value);
            }
        }

        public int Count
        {
            get { return _ObjectsByName.Count; }
        }

        public bool ContainsKey(string name)
        {
            return _ObjectsByName.ContainsKey(name);
        }

        public bool TryGetValue(string name, out TObject obj)
        {
            return _ObjectsByName.TryGetValue(name, out obj);
        }

        public void Add(string name, TObject obj)
        {
            // This is expected to be an infrequent operation. Every add requires O(n 
            // log n) time since we have to copy the existing dictionary and "re-sort" 
            // it.
            Dictionary<string, TObject> objects, newObjects;
            lock (_WriterLock)
            {
                objects = _ObjectsByName;

                newObjects = new Dictionary<string, TObject>(
                    _ObjectsByName, 
                    StringComparer.InvariantCultureIgnoreCase);
                newObjects[name] = obj;

                // plunk it back in
                _ObjectsByName = newObjects;
            }
        }

        public bool Remove(string name)
        {
            Dictionary<string, TObject> objects, newObjects;
            lock (_WriterLock)
            {
                objects = _ObjectsByName;
                
                // Shortcut - if object isn't in dictionary, bail out
                if (!objects.ContainsKey(name))
                {
                    return false;
                }

                newObjects = new Dictionary<string, TObject>(
                    objects, 
                    StringComparer.InvariantCultureIgnoreCase);
                bool ret = newObjects.Remove(name);

                // plunk it back in
                _ObjectsByName = newObjects;

                return ret;
            }
        }

        public void ForEach(Action<TObject> action)
        {
            // Must get local reference
            Dictionary<string, TObject> objects = _ObjectsByName;
            foreach (TObject obj in objects.Values)
            {
                action(obj);
            }
        }

        public void SortedForEach(Action<TObject> action)
        {
            // Must get local reference
            Dictionary<string, TObject> objects = _ObjectsByName;
            var sortedKeys = objects
                .Select(d => d.Key)
                .OrderBy(d => d, StringComparer.InvariantCultureIgnoreCase);

            foreach (string key in sortedKeys)
            {
                TObject obj = objects[key];
                // obj can't be null since the dictionary can't change from under us
                action(obj);
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xomlogarea.cs ===
using System;
using System.Runtime.InteropServices;

using STF.common.config;
using STF.common.service;

namespace STF.common.mgmt
{
    [ComVisible(false)]
    public class XomLogLevel
    {
        public const sbyte Muted = -1;
        public const sbyte Off = -1;
        public const sbyte Low = 0;
        public const sbyte On = 0;
        public const sbyte Yes = 0;
        public const sbyte Info = 1;
        public const sbyte Normal = 1;
        public const sbyte High = 2;
        public const sbyte Warning = 2;
        public const sbyte Error = 3;
        public const byte Max = 4;
    }


    [ComVisible(false)]
    public class XomLogArea
    {
        // ResetContextLogging
        // Called at the beggining of a request to reset the context logging flag
        // for the thread.
        public static void ResetContextLogging()
        {
            _threadContextLogStatus = false;
        }

        // SetContextLogging
        // Can be called anywhere to enable/disable context logging for the local
        // thread.
        public static void SetContextLogging(bool fLog)
        {
            _threadContextLogStatus = fLog;
        }

        public static bool GetContextLogging()
        {
            // Context logging is on if there is status is true
            return _threadContextLogStatus;
        }

        public static sbyte GetLevel(string level)
        {
            sbyte n;

            switch(level.ToLower())
            {
                case "-1":
                case "muted":
                case "off":
                case "no":
                    n = -1;
                    break;

                case "0":
                case "low":
                case "on":
                case "yes":
                    n = 0;
                    break;

                case "1":
                case "info":
                case "normal":
                    n = 1;
                    break;

                case "2":
                case "high":
                case "warning":
                    n = 2;
                    break;

                case "3":
                case "error":
                    n = 3;
                    break;

                // Level '4' is added to be consistent with the C++ implementation
                // It's the same thing as the '-1' or muted level
                case "4":
                    n = -1;
                    break;

                default:
                    throw new ArgumentOutOfRangeException("level", level, "Unrecognized value.");
            }

            return n;
        }

        public static bool ParseContextOnlySetting(string sw)
        {
            if (sw == "on" || sw == "true" || sw == "yes" || sw == "1")
            {
                return true;
            }
            else if (sw == "off" || sw == "false" || sw == "no" || sw == "0")
            {
                return false;
            }
            else
            {
                throw new ArgumentOutOfRangeException("Invalid value for ContextOnly area setting");
            }
        }


        //
        // Per-instance initialization
        //
        public XomLogArea( string name, string setting )
        {
            _name = name;
            _setting = setting;
        }

        public void Init( string settings )
        {
            //
            // Create a the parameter list
            //
            string[,] parameters = ConfigUtil.GetParams( settings );
            if ( parameters == null )
            {
                return;
            }

            for ( int n = 0; n < parameters.GetLength( 0 ); n++ )
            {
                switch( parameters[ n, 0 ] )
                {
                case "target":

                    string        targetName = parameters[ n, 1 ];
                    XomLogTarget  target = null;

                    //
                    // Find or build the target
                    //

                    if (!XomLoggingControl.Targets.TryGetValue(targetName, out target))
                    {
                        target = XomLoggingControl.CreateTarget( targetName );
                    }

                    //
                    // Insert the target into the list
                    //

                    if (target != null)
                    {
                        AddTarget( target );
                    }
                    else
                    {
                        throw new Exception(String.Format(
                            "The setting \"{0}\" for XMGMT area \"{1}\" specified an unknown target \"{2}\".",
                            Setting, Name, targetName));
                    }
                    break;

                case "enable":
                    _filterLevel = XomLogArea.GetLevel( parameters[ n, 1 ] );
                    break;

                case "contextonly":
                    _fContextOnly = XomLogArea.ParseContextOnlySetting(parameters[n,1]);
                    break;

                default:
                    throw new ArgumentOutOfRangeException( _name, parameters[ n, 0 ], "Unrecognized setting." );
                }
            }
        }

        //
        // Property accessors
        //
        public string Name
        {
            get { return _name; }
        }

        public string Setting
        {
            get { return _setting; }
        }

        public sbyte FilterLevel
        {
            get { return _filterLevel; }
            set { _filterLevel = value; }
        }

        public XomDictionary<XomLogTarget> Targets
        {
            get { return _logTargets; }
        }

        public bool ContextOnly
        {
            get { return _fContextOnly; }
            set { _fContextOnly = value; }
        }

        public bool Enabled
        {
            get { return FilterLevel > XomLogLevel.Muted && FilterLevel < XomLogLevel.Max && Targets.Count > 0; }
        }

        // RIP CtxLog. 2001 - 2009.
        // CtxLog is dead for managed. Not used, and won't be unless we fix it up. But it 
        // used to be here, if you want to reference it.

        // RIP macro-based logging. 2001 - 2009.

        // Log function used by new macro-free Xom logging.  This function only checks the 
        // areas themselves for the log level, it
        // no longer considers file+line overrides.  It is a combination of the Log() function above, plus the necessary code 
        // from the CanLog() function below.  Once all of the logging has switched to the new system, the Log() functions above
        // can be removed.
        public void Log(XomLogTargetContext msgCtx, sbyte level, ushort msgId, byte[] msgData, Exception e, string formatStr, params object[] args)
        {
            // Don't log if muted, or there are no targets
            if (!Enabled)
            {
                return;
            }

            // Don't log if message is below the area's level
            if(level < _filterLevel) {
                return;
            }

            try {
                _logTargets.ForEach(
                    delegate(XomLogTarget targ)
                    {
                        try {
                            // Format the string to be logged
                            string message = string.Format(formatStr, args);
                            targ.Log(msgCtx, _name, level, msgId, msgData, message, e);
                        }
                        catch {
                            // review: is there something we can do if an exception is caught??
                        }
                    });
            }
            catch {
                // exception thrown while logging?  OH NOES!!
            }
        }

        public void AddTarget(XomLogTarget target)
        {
            _logTargets.Add(target.Name, target);
            target.Startup( );
        }

        public bool RemoveTarget(XomLogTarget target)
        {
            bool ret = _logTargets.Remove(target.Name);
            return ret;
        }

        //
        // Helper methods
        //
        private bool CanLog( sbyte level, int line, string file, ref uint sig )
        {
            bool fCanLog = false;

            if( ( sig & 0xffff0000 ) == XomLoggingControl.LastChangeSignature )
            {
                // Use last CanLog result stored in the signature. That will save us from checking if the area is
                // enabled, has targets and stuff. However, if this area is marked as 'Context Only', we can only log
                // if the thread has the context logging flag on.
                fCanLog = ( 0 != ( sig & 0x0000ffff ) ) && (!_fContextOnly || XomLogArea.GetContextLogging());
            }
            else
            {
                uint uiLastChangeSig;

                do
                {
                    uiLastChangeSig = XomLoggingControl.LastChangeSignature;

                    //
                    // If not special-cased in the override list, the current level of the area
                    // determines if we should log or not.
                    //
                    if( !XomLoggingControl.CheckOverrideList( file, line, ref fCanLog ) )
                    {
                        fCanLog = (_filterLevel != XomLogLevel.Muted) && ( level >= _filterLevel );
                    }

                    //
                    // No matter how it got figured out, we only want to log if there's a destination
                    //
                    fCanLog = fCanLog && ( _logTargets.Count > 0 );

                }
                while( XomLoggingControl.LastChangeSignature != uiLastChangeSig );

                //
                // (Atomically?) update the caller's copy of the signature + flags uint
                //
                uint uiNewSig = uiLastChangeSig | ( fCanLog ? (uint)1 : (uint)0 );


                // Interlocked.Exchange( sig, uiNewSig );
                sig = uiNewSig;
            }

            return fCanLog;
        }

        //
        // Private data members
        //
        private string _name = "";
        private string _setting;
        private sbyte _filterLevel = XomLogLevel.Muted;
        private XomDictionary<XomLogTarget> _logTargets = new XomDictionary<XomLogTarget>();
        private bool _fContextOnly = false;

        // Thread local storage to keep track of thread context log status. We'll
        // use it to determine weather or not a context-only area should log or
        // not.
        [ThreadStaticAttribute]
        private static bool _threadContextLogStatus = false;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomControlConnection.cs ===
using System;
using System.IO;
using System.Text;
using SysDiag = System.Diagnostics ;
using System.Threading;
using System.Runtime.InteropServices;
using System.Security.Principal;

using STF.common.service;

namespace STF.common.mgmt
{
[ComVisible(false)]
public static class XomControlConnection
{

    const uint XOMCTRL_MAXPROCESSNAME = 256;
    const uint XOMCTRL_MAXCOMPONENTNAME = 256;
    const uint XOMCTRL_MAXMESSAGESIZE = 30720;
    const int PIPE_BUFFER_SIZE = (int)XOMCTRL_MAXMESSAGESIZE;

    const uint XOMCTRLMSGID_REGISTER = 0x01;
    const uint XOMCTRLMSGID_REQUEST = 0x02;
    const uint XOMCTRLMSGID_RESPONSE = 0x03;
    const uint XOMCTRLMSGID_RESPONSE_DONE = 0x04;

    class RegisterMsg
    {
        public uint Size = 12 + XOMCTRL_MAXPROCESSNAME + XOMCTRL_MAXCOMPONENTNAME;
        public uint Type = XomControlConnection.XOMCTRLMSGID_REGISTER;
        public uint ProcessId = 0;
        public string ProcessName = "";
        public string ComponentName = "";


        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            byte[] processNameBytes = enc.GetBytes(ProcessName);
            byte[] componentNameBytes = enc.GetBytes(ComponentName);

            pipe.Writer.Write(Size);
            pipe.Writer.Write(Type);
            pipe.Writer.Write(ProcessId);

            pipe.Writer.Write(processNameBytes);
            if (processNameBytes.Length < XOMCTRL_MAXPROCESSNAME)
            {
                pipe.Writer.Write(new byte[XOMCTRL_MAXPROCESSNAME - processNameBytes.Length]);
            }

            pipe.Writer.Write(componentNameBytes);
            if (componentNameBytes.Length < XOMCTRL_MAXPROCESSNAME)
            {
                pipe.Writer.Write(new byte[XOMCTRL_MAXCOMPONENTNAME - componentNameBytes.Length]);
            }

            pipe.Flush();

        }
    }

    class RequestMsg
    {
        public uint Size = 0;
        public uint Type = XomControlConnection.XOMCTRLMSGID_REQUEST;
        public uint RequestId;
        public string Message = "";

        public byte[] SizeBytes = new byte[4];

        public void Read(byte[] bytes, int cb, UTF8Encoding enc)
        {
            MemoryStream memstream = new MemoryStream(bytes);
            BinaryReader reader = new BinaryReader(memstream);

            if (cb <= 12)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_4, "Invalid control message received! Size=" + Size + "; Expected size > 12." );
                Type = 0;
                return;
            }

            Size = reader.ReadUInt32();
            if (Size != cb)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_5, "Invalid control message received! Size (" + Size + ") != msg size (" + cb + ")" );
                Type = 0;
                return;
            }

            Type = reader.ReadUInt32();
            if (Type != XomControlConnection.XOMCTRLMSGID_REQUEST)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_6, "Invalid control message received! Type=" + Type + "; Expected Type=" + XomControlConnection.XOMCTRLMSGID_REQUEST );
                Type = 0;
                return;
            }

            RequestId = reader.ReadUInt32();
            Message = enc.GetString(reader.ReadBytes((int)Size - 12));
        }

    }


    class ResponseMsg
    {
        public const uint ResponseMsgSize = 12;  // plus message body 

        public uint Type = XomControlConnection.XOMCTRLMSGID_RESPONSE;
        public uint RequestId = 0;
        public string Message = "";

        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            byte[] messageBytes = enc.GetBytes(Message);
            uint messageSize = (uint)messageBytes.Length;
            uint messageIndex = 0;  // once in a while, I miss pointers
            
            while (messageSize > 0)
            {
                // Don't exceed max message size, or else xmgmtsrv will fizzle and burn.
                uint bytesToSend = Math.Min(
                    messageSize, 
                    XomControlConnection.XOMCTRL_MAXMESSAGESIZE - ResponseMsgSize);

                pipe.Writer.Write(ResponseMsgSize + bytesToSend);
                pipe.Writer.Write(Type);
                pipe.Writer.Write(RequestId);
                pipe.Writer.Write(messageBytes, (int)messageIndex, (int)bytesToSend);

                messageSize -= bytesToSend;
                messageIndex += bytesToSend;
            }
            
            pipe.Flush();
        }
    }

    class ResponseDoneMsg
    {
        public uint Size = 16;
        public uint Type = XomControlConnection.XOMCTRLMSGID_RESPONSE_DONE;
        public uint RequestId = 0;
        public HResult hr = HResult.S_OK;

        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            pipe.Writer.Write(Size);
            pipe.Writer.Write(Type);
            pipe.Writer.Write(RequestId);
            pipe.Writer.Write(hr);
            pipe.Flush();
        }
    }

    public static void Startup()
    {
        Connect();
        _timer = new System.Threading.Timer(new TimerCallback(XmgmtWatchDogFunc), _id, 30 * 1000, 30 * 1000);
        _init = true;
    }

    private static void Connect()
    {
        if (_pipe != null)
        {
            return;
        }

        // Try to get a global lock, multiple timers events or callers
        // should be protected from multi-init problems
        lock (objectLock)
        {
            try
            {
                // Allow quick test above but serialize access to initialization
                // code path
                if(_pipe != null)
                {
                    return;
                }

                // Use a cached identity so that we can restart the xomcontrolconnection
                // from the health URL. This is required to reopen the pipe connection.
                // and property run the watchdog
                if(null == _id)
                {
                    _id = WindowsIdentity.GetCurrent();
                }
                else
                {
                    _id.Impersonate();
                }

                _pipe = new PipeStream("\\\\.\\pipe\\xmgmtsrvpipe", PIPE_BUFFER_SIZE);

                // register
                RegisterMsg msg = new RegisterMsg();
                msg.ProcessId = (uint) SysDiag.Process.GetCurrentProcess().Id;
                msg.ProcessName = SysDiag.Process.GetCurrentProcess().MainModule.ModuleName;
                msg.ComponentName = XomLoggingControl.AssemblyName;

                if (msg.ProcessName.EndsWith(".exe", StringComparison.InvariantCultureIgnoreCase))
                {
                    msg.ProcessName = msg.ProcessName.Substring(0, msg.ProcessName.Length - 4);
                }

                msg.Write(_pipe, _enc);

                StartReading();

                Xom.NtEvent( XEvent.Id.COMMON_INFO_46, "Connection with Xmgmtsrv is established."  );

            }
            catch(Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_252, e, "Failed to connect to Xmgmtsrv. No remote administration is available.");
                _pipe = null;
            }
        }
    }

    private static void StartReading()
    {
        try
        {
            lock (objectLock)
            {
                if( ( _pipe != null ) && _pipe.CanRead )
                {
                    byte[] buf= new byte[PIPE_BUFFER_SIZE];

                    _pipe.BeginRead(buf, 0, PIPE_BUFFER_SIZE, new AsyncCallback(XomControlConnection.ReadMessage), buf);
                }
            }
        }
        catch(Exception e)
        {
            Xom.NtEvent( XEvent.Id.MGMT_READ_FAILURE, e, "XomControlConnection.StartReading() failed to begin reading, the pipe connection will be released.");
            Disconnect();
        }
    }

    public static void ReadMessage(IAsyncResult ar)
    {
        int cb = 0;

        try
        {
            lock (objectLock)
            {
                cb = ( _pipe != null ) ? _pipe.EndRead(ar) : 0;

                if (cb==0)  // end of stream
                {
                    if (_pipe != null)
                    {
                        // Only fire this event if there is an unexpected shutdown of the connection, standard close (_pipe = null)
                        // is perfectly reasonable and should not be the cause of an event.
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_253, "Xmgmtsrv pipe closed. No remote administration is available.");
                    }
                    Disconnect();
                }
            }
        }
        catch ( Exception e )
        {
            Disconnect();
            Xom.NtEvent( XEvent.Id.COMMON_CONFIG_254, e, "Failed to read from Xmgmtsrv pipe. No remote administration is available.");
            cb = 0;
        }

        if (cb > 0)
        {
            RequestMsg msg = new RequestMsg();
            msg.Read((byte[])ar.AsyncState, cb, _enc);

            ControlRequestEventArgs args = new ControlRequestEventArgs(msg.Message, msg.RequestId);

            try
            {
                XomControl.OnControlRequest(args);
            }
            catch(Exception)
            {
                args.hr = HResult.E_FAIL;
            }

            ResponseDoneMsg msgDone = new ResponseDoneMsg();
            msgDone.RequestId = msg.RequestId;
            msgDone.hr = args.hr;

            
            try
            {
                lock (objectLock)
                {
                    if( _pipe != null )
                    {
                        // The service may have stopped after sending 'AdminSessionDied'
                        // at which point the pipe has been disposed. The write will fail
                        // if we don't handle this the containing process will crash
                        msgDone.Write(_pipe, _enc);
                    }
                }
            }
            catch( Exception e )
            {
                Disconnect();
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_PIPE_HANDLE_DISPOSED, e, "Xmgmtsrv pipe disposed, No remote administration is available.");
                cb = 0;
            }
        }

        // Only if all of the previous work resulted succeeded (bytes read and returned) should another read be scheduled.
        if (cb > 0)
        {
            StartReading();
        }
    }

    public static void SendMessage(string message, uint requestId)
    {
        ResponseMsg msg = new ResponseMsg();
        msg.RequestId = requestId;
        msg.Message = message;

        try
        {
            lock (objectLock)
            {
                msg.Write(_pipe, _enc);
            }
        }
        catch ( Exception e )
        {
            Disconnect();
            Xom.NtEvent( XEvent.Id.COMMON_CONFIG_255, e, "Failed to write to Xmgmtsrv pipe. No remote administration is available.");
        }
    }



    private static void Disconnect()
    {
        lock (objectLock)
        {
            // The watchdog timer serves to reconnect the pipe when it gets closed (by 
            // this function). Please don't also kill the watchdog function here. When you 
            // call _timer.Dispose(), it will NOT make a "final" callback.

            // Cleanup pipe
            try
            {
                if (_pipe != null)
                {
                    _pipe.Dispose();
                }
            }
            catch(Exception)
            {
            }
            finally
            {
                _pipe = null;
            }
        }
    }

    public static void Shutdown()
    {
        _init = false;
        if (_timer != null)
        {
            _timer.Dispose();
            _timer = null;
        }

        Disconnect();
    }
    public static void XmgmtWatchDogFunc(object o)
    {
        lock (objectLock)
        {
            if (_init)
            {
                Connect();
            }
        }
    }

    private static volatile bool _init = false;
    private static WindowsIdentity _id = null;
    private static Timer _timer = null;
    private static UTF8Encoding _enc = new UTF8Encoding();
    private static PipeStream _pipe;

    private static object objectLock = new object();
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomLoggingControl.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

using STF.common.config;
using STF.common.service;
using STF.common.mgmt;

//
// We always have one default area that's used by Xom.NtEvent and Xom.NtDataEvent statements
//
[assembly: XomAreaDefinition(XomAreaName.DefaultNtLog)]

[assembly: XomAreaDefinition(XomAreaName.XomInstrumentation)]

namespace STF.common.mgmt
{
    [ComVisible(false)]
public class XomLineOverride
{
    public XomLineOverride(
        string szFileName,
        uint uiLineNum,
        bool fLogIt )
    {
        szFile = szFileName;
        uiLine = uiLineNum;
        fCanLog = fLogIt;
    }

    public string szFile;
    public uint uiLine;
    public bool fCanLog;
}

[ComVisible(false)]
public class XomLoggingControl
{
    /// <summary>maximum length of string sent to event log</summary>
    public const int MaxEventLength = ConfigEventLogger.MaxEventLength;

    private static TargetDictionary _targets = new TargetDictionary();
    private static XomDictionary<XomLogArea> _areas = new XomDictionary<XomLogArea>();
    private static int _iLastChangeSignature = 0x10000;
    private static string _overrideAssemblyName;
    private static string _logRoot = null;
    private static string _defaultTargetSettings = null;

    private static ArrayList _overrides;

    private static DateTime _initTime;

    public static TargetDictionary Targets
    {
        get { return _targets; }
    }

    public static XomDictionary<XomLogArea> Areas
    {
        get { return _areas; }
    }

    public static uint LastChangeSignature
    {
        get { return( (uint) _iLastChangeSignature ); }
    }

    public static string OverrideAssemblyName
    {
        get { return _overrideAssemblyName; }
        set { _overrideAssemblyName = value; }
    }

    public static string AssemblyName
    {
        get
        {
            if (_overrideAssemblyName==null)
                return Path.GetFileNameWithoutExtension(Config.AssemblyPath);
            else
                return _overrideAssemblyName;
        }
    }

    public static string LogRoot
    {
        get { return _logRoot; }
    }

    public static string DefaultTargetSettings
    {
        get { return _defaultTargetSettings; }
    }

    public static TimeSpan UpTime
    {
        get { return DateTime.UtcNow - _initTime; }
    }

    public static void RegisterNewChange()
    {
        int iOldSig;

        do
        {
            iOldSig = _iLastChangeSignature;
        }
        while( Interlocked.CompareExchange(
                                ref _iLastChangeSignature,
                                (int)( ( (uint) iOldSig + 0x00010000) & 0xFFFF0000 ),
                                iOldSig ) != iOldSig );
    }

    static XomLoggingControl()
    {
        _overrides = ArrayList.Synchronized( new ArrayList() );
        _initTime = DateTime.UtcNow;
    }

    public static void WriteEarlyEvent(
        XEvent.Id eventId,
        string eventText)
    {
        // since log targets are not yet initialized, try writing directly to the event
        // log. We'll try to use the component name (name of the dll), but if that fails
        // for some reason, we'll use "xmgmt". We will also ensure the source has been
        // created.

        string source = "commonconfig";
        try
        {
            source = Config.ComponentName;
        }
        catch {};

        // Since the code isn't guaranteed to be running as an admin, we can't be nice and
        // create a source. So you're kinda screwed if you want to actually write an
        // event. instead of simply returning, let's try it and let an exception happen if
        // it happens.

        // 1=info, 2=warning, 3=error
        uint level = ((((uint) eventId) >> 30) & 0x3);
        EventLogEntryType entryType =
            level == 1 ? EventLogEntryType.Information :
            level == 2 ? EventLogEntryType.Warning :
            EventLogEntryType.Error;

        int start;
        int len;
        int maxIndex = eventText.Length - 1;

        for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
            len = Math.Min( eventText.Length - start, MaxEventLength );
            EventLog.WriteEntry(
                source,
                eventText.Substring( start, len ),
                entryType,
                (int) (((uint) eventId) & 0xFFFF));
        }
    }

    private static volatile bool _init = false;
    private static object _initLock = new object();

    public static void Init()
    {
        if (!_init)
        {
            lock (_initLock)
            {
                if (!_init)
                {
                    Init(Config.Assembly);

                    // initialize the Config-related xmgmt commands
                    ConfigXmgmtCmd.Init();
                    _init = true;
                }
            }
        }
    }

    private static void Init(Assembly assembly)
    {
        try
        {
            // Create default targets
            //
            XomLoggingControl.Targets.Add( "debugoutput", "type=debugoutput" );
            XomLoggingControl.Targets.Add( "ntlog", "type=ntlog;source=" + Config.ComponentName);
            XomLoggingControl.Targets.Add( "console", "type=console" );

        }
        catch (Exception e)
        {
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_256,
                "LoggingControl: An error occurred while constructing default targets: " + e);
            throw;
        }

        // Attempt to cache settings to be loaded:
        Config.TryCacheSettings(Setting.setup_logroot, Setting.xmgmt_default_target_settings);
        try
        {
            _logRoot = Config.GetSetting(Setting.setup_logroot);
        }
        catch (Exception e)
        {
            _logRoot = null;
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_257,
                "LoggingControl: An error occurred while retrieving the log root setting: " + e);
            throw;
        }

        try
        {
            _defaultTargetSettings = Config.GetSetting(Setting.xmgmt_default_target_settings);
        }
        catch (Exception e)
        {
            _defaultTargetSettings = null;
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_258,
                "LoggingControl: An error occurred while retrieving target settings: " + e);
            throw;
        }

        try
        {
            //
            // Do the necessary search and replace on the default target settings
            //

            if (_defaultTargetSettings != null)
            {
                //
                // The targetList specification is a concatenation of multiple,
                // comma delimited setting strings, each of which describes a single
                // target.  Each of these specifications may contain one or more
                // replacable string tokens (identified by surrounding '#'
                // characters) which can be computed from the machine name,
                // component name, or config setting
                //

                if ( _logRoot != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#LOGROOT#",
                        _logRoot
                        );
                }
                if ( Config.ComponentName != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#COMPONENT#",
                        Config.ComponentName
                        );
                }
                if ( Config.Server != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#MACHINE#",
                        Config.Server.ToLower()
                        );
                }
            }

            // register the application  assembly, this assembly (XblCore.dll, unless you've XLUSE_'d this feature),  and
            // all of the assemblies that it references
            RegisterAssembly(Assembly.GetExecutingAssembly());

            RegisterAssemblyAndReferences(assembly);

            //
            // Configure the target settings for our built-in area. This area is
            // added when we register the assembly, so we unfortunately can't
            // move these lines up to the top.
            //

            XomLogArea ntLogArea = XomLoggingControl.Areas[XomAreaName.DefaultNtLog];  // will throw if not exist
            ntLogArea.AddTarget(XomLoggingControl.Targets["ntlog"]);
            ntLogArea.AddTarget(XomLoggingControl.Targets["debugoutput"]);
            ntLogArea.FilterLevel = XomLogLevel.Low;

            Config.DefaultInstance.HandleLogEvent += OnConfigLogEvent;

            if ( 2 == XomLoggingControl.Targets.Count )
            {
              Xom.NtEvent( XEvent.Id.COMMON_CONFIG_260, "No new targets found." );
            }

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XomLoggingControl.OnControlRequest);

        }
        catch (Exception e)
        {
            WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_261, "XomLoggingControl: An error occurred while retrieving target settings: " + e.ToString());
        }
    }

    private static void OnConfigLogEvent(uint eventId, string message, string componentName)
    {
        // ComponentName is configured as part of the nt event infrastructure, so no need to specify here.
      Xom.NtEvent((XEvent.Id)eventId, message);
    }

    private static List<Assembly> _registeredAssemblies = new List<Assembly>();
    public static void RegisterAssembly(Assembly a)
    {
        // Don't register assembly if it's already been registered
        if( _registeredAssemblies.Contains(a)) {
            return;
        }
        _registeredAssemblies.Add(a);

        // Find all areas defined in this assembly using the XomAreaDefinition attribute
        List<string> xomAreaNames = new List<string>();
        object[] atts = a.GetCustomAttributes(false);
        for(int i = 0; i < atts.Length; i++) {
            XomAreaDefinitionAttribute xaa = atts[i] as XomAreaDefinitionAttribute;
            if(xaa != null) {
                if(xomAreaNames.Contains(xaa.Name) == false) {
                    xomAreaNames.Add(xaa.Name);
                }
            }
        }

        // Build list of area setting names and cache the settings
        List<string> areaSettingNames = new List<string>();
        foreach(string areaName in xomAreaNames) {
            areaSettingNames.Add("xmgmt_area_" + areaName);
        }
        Config.TryCacheSettings(areaSettingNames.ToArray());

        // Register areas found by XomAreaDefinition attribute
        foreach(string areaName in xomAreaNames) {
            string settingVarName = "xmgmt_area_" + areaName;

            // Get the config setting for the area
            Type t = typeof(STF.common.config.Setting);
            FieldInfo fi = t.GetField(settingVarName);
            if(fi == null) {
                WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_259,
                                string.Format("Failed to register XMGMT area \"{0}\" in assembly {1}. Field '{2}' not found in the STF.common.config.Setting class.",
                                              areaName, a.FullName, settingVarName));
            } else {
                string settingVal = (string)fi.GetValue(null);

                // Create an area and register it
                XomLogArea area = new XomLogArea(areaName, settingVal);
                XomLoggingControl.RegisterArea(area);
            }
        }
    }

    public static void RegisterAssemblyAndReferences(Assembly a)
    {
        RegisterAssembly(a);

        foreach (AssemblyName assemblyName in a.GetReferencedAssemblies())
        {
            try
            {
                RegisterAssembly(Assembly.Load(assemblyName));
            }
            catch (Exception e)
            {
                WriteEarlyEvent(XEvent.Id.XMGMT_FAILED_TO_REGISTER_ASSEMBLY, String.Format(
                    "XomLoggingControl: An error occurred while registering assembly {0} referenced " +
                    "by assembly {1}. This is likely not fatal. Exception: {2}",
                    assemblyName,
                    a,
                    e.Message));
            }
        }
    }

    public static void RegisterArea( XomLogArea theArea )
    {
        theArea.Init( Config.GetSetting( theArea.Setting ) );

        XomLoggingControl.Areas[ theArea.Name ] = theArea;
    }

    public static bool RegisterNewArea( string areaName, string areaSettings )
    {
        // Already exists? We won't do anything.

        XomLogArea area;
        if (XomLoggingControl.Areas.TryGetValue(areaName, out area))
        {
            return false;
        }

        // No NPDB setting name
        area = new XomLogArea(areaName, null);

        // But we have the settings passed into us
        area.Init(areaSettings);

        // Will throw if it already exists, for the rare race condition. But that's ok.
        XomLoggingControl.Areas.Add(area.Name, area);

        return true;
    }

    public static XomLogTarget CreateTarget( string theTarget )
    {
        string       targetSettings = null;
        XomLogTarget target = null;

        try
        {
            targetSettings = Config.GetSetting( "xmgmt_target_" + theTarget );
            if ( targetSettings != null )
            {
                //
                // The targetList specification is a concatenation of multiple,
                // comma delimited setting strings, each of which describes a
                // single target.  Each of these specifications may contain one
                // or more replacable string tokens (identified by surrounding
                // '#' characters) which can be computed from the machine name,
                // component name, or config setting
                //

                if ( LogRoot != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#LOGROOT#",
                        LogRoot
                        );
                }
                if ( Config.ComponentName != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#COMPONENT#",
                        Config.ComponentName
                        );
                }

                if ( Config.Server != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#MACHINE#",
                        Config.Server.ToLower()
                        );
                }

                // Debug.WriteLine("XMGMT: calling XomLoggingControl.Targets.Add(\"" + theTarget + "\", \"" + targetSettings + "\")...");
                try
                {
                    target = XomLoggingControl.Targets.Add(
                        theTarget,
                        targetSettings,
                        DefaultTargetSettings
                        );
                }
                catch (Exception e)
                {
                    WriteEarlyEvent(
                        XEvent.Id.COMMON_CONFIG_259,
                        String.Format("Failed to add target {0}, params {1}. Exception: {2}\r\n",
                            theTarget,
                            targetSettings,
                            e.Message
                                      )
                        );
                }
            }
        }
        catch (Exception e)
        {
            WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_261, "XomLoggingControl: An error occurred while creating a target: " + e.ToString());
        }
        return target;
    }

    public static void OnControlRequest(object sender, ControlRequestEventArgs args)
    {
        try
        {
            switch (args.Command)
            {
            case "h":
            case "help":
                ProcessHelpRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "gv":
            case "getversion":
                ProcessGetVersionRequest(args);
                args.Handled = true;
                break;

            case "la":
            case "listareas":
                ProcessListAreasRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "lt":
            case "listtargets":
                ProcessListTargetsRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "cal":
            case "changearealevel":
                ProcessChangeAreaLevelRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "nt":
            case "newtarget":
                ProcessNewTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "dt":
            case "deletetarget":
                ProcessDeleteTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "at":
            case "addtarget":
                ProcessAddTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "rt":
            case "removetarget":
                ProcessRemoveTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "rst":
            case "resettarget":
                ProcessResetTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "lo":
            case "listoverrides":
                ProcessListOverridesRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "so":
            case "setoverride":
                ProcessSetOverrideRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "ro":
            case "removeoverride":
                ProcessRemoveOverrideRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "sco":
            case "setcontextonly":
                ProcessSetContextOnlyRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "ut":
            case "uptime":
                ProcessUpTimeRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "na":
            case "newarea":
                ProcessNewAreaRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "da":
            case "deletearea":
                ProcessDeleteAreaRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "adminsessiondied":
                ProcessAdminSessionDiedRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;
            }
        }
        catch(Exception e)
        {
            XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
        }

    }

    public static void ProcessHelpRequest(string[] args, uint requestId)
    {
        // Note: NewArea and DeleteArea are not shown because no one should ever need to
        // run them. They are really only useful for testing.

        XomControlConnection.SendMessage(
            "Logging and tracing help:\r\n" +
            "  GetVersion\r\n" +
            "  UpTime\r\n" +
            "  ListAreas\r\n" +
            "  ListTargets\r\n" +
            //"  NewArea <area name> <settings>\r\n" +
            //"  DeleteArea <area name>\r\n" +
            "  ChangeAreaLevel <area name> <level = 0,1,2,3,4>\r\n" +
            "  NewTarget <target name> <target parameters>\r\n" +
            "    where <target parameters> can be:\r\n" +
            "       type=File;prefix=<filename prefix>;RotationTime=<time in minutes>;RotationSize=<size in bytes>\r\n" +
            "       type=Remote;address=<ip or hostname of rtrace terminal>\r\n" +
            "  DeleteTarget <target name>\r\n" +
            "  AddTarget <target name> <area name>\r\n" +
            "  RemoveTarget <target name> <area name>\r\n" +
            "  ResetTarget <target name>\r\n" +
            "  ListOverrides\r\n" +
            "  SetOverride <filename> <line> <log 0=no, 1=yes>\r\n" +
            "  RemoveOverride <override index>\r\n" +
            "  SetContextOnly <area name> <yes/no>\r\n\r\n", requestId);
    }

    public static void ProcessGetVersionRequest(ControlRequestEventArgs args)
    {
        try
        {
            Module mod = Config.Assembly.GetModules()[0];
            FileVersionInfo version = FileVersionInfo.GetVersionInfo(mod.FullyQualifiedName);
            XomControlConnection.SendMessage(version.FileVersion, args.RequestId);
        }
        catch(Exception)
        {
            args.hr = HResult.E_FAIL;
        }
    }

    public static void ProcessListAreasRequest(string[] args, uint requestId)
    {
        string areaFilter = args.Length > 0 ? args[0].ToLower() : null;

        StringBuilder strB = new StringBuilder();

        // It's nice when the areas are in sorted order, so we'll incur the more expensive
        // hit since this is a rare operation.
        XomLoggingControl.Areas.SortedForEach(
            delegate(XomLogArea area) {
                string areaName = area.Name.ToLower();
                if ( areaFilter == null || areaName.StartsWith(areaFilter, StringComparison.InvariantCultureIgnoreCase) )
                {
                    strB.Append("Area: ");
                    strB.Append(areaName.PadRight(22));
                    strB.Append(" Lvl: ");
                    strB.Append(area.FilterLevel.ToString().PadLeft(2));
                    strB.Append(" Targets: ");

                    area.Targets.ForEach(
                        delegate(XomLogTarget target)
                        {
                            strB.Append(target.Name);
                            strB.Append(" ");
                        });

                    if (area.ContextOnly)
                    {
                        strB.Append(" ContextOnly=Yes");
                    }

                    strB.Append("\r\n");
                }
            }
        );

        strB.Append("\r\n\r\n");
        XomControlConnection.SendMessage(strB.ToString(), requestId);
    }

    public static void ProcessListTargetsRequest(string[] args, uint requestId)
    {
        StringBuilder strB = new StringBuilder();

        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                strB.Append("Target: ");
                strB.Append(target.Name.PadRight(20));
                strB.Append(" Params: ");
                strB.Append(target.Params);
                strB.Append("\r\n");
            });

        strB.Append("\r\n\r\n");
        XomControlConnection.SendMessage(strB.ToString(), requestId);
    }

    public static void ProcessChangeAreaLevelRequest(string[] args, uint requestId)
    {
        XomLogArea area;
        sbyte oldLvl;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        area = Areas[args[0]];
        if (area == null)
        {
            XomControlConnection.SendMessage("Error: Area '" + args[0] + "' not found.", requestId);
            return;
        }

        oldLvl = area.FilterLevel;
        area.FilterLevel = XomLogArea.GetLevel(args[1]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Changed filter level of area '" + args[0] + "' from " + oldLvl + " to " + area.FilterLevel + "\r\n\r\n" , requestId);
    }


    public static void ProcessNewTargetRequest(string[] args, uint requestId)
    {
        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }
        XomLogTarget target = Targets[args[0]];

        if (target != null)
        {
            XomControlConnection.SendMessage("Target " + args[0] + " already exists, cannot replace.\r\n\r\n" , requestId);
        }
        else
        {
            Targets.Add(args[0], args[1], requestId);

            RegisterNewChange();

            XomControlConnection.SendMessage("Added target " + args[0] + "\r\n\r\n" , requestId);
        }
    }

    public static void ProcessDeleteTargetRequest(string[] args, uint requestId)
    {
        StringBuilder strB = new StringBuilder();
        bool found = false;

        //
        // remove from areas
        //
        XomLogTarget target = Targets[args[0]];

        if (target != null)
        {
            XomLoggingControl.Areas.ForEach(
                delegate(XomLogArea area)
                {
                    if (area.RemoveTarget(target))
                    {
                        strB.Append("Removed " + args[0] + " from " + area.Name + "\r\n");
                        found = true;
                    }
                }
            );

            if (Targets.Remove(target.Name))
            {
                strB.Append("Removed " + args[0] + " from targets list\r\n\r\n");
                found = true;
            }
        }

        if ( !found )
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
        }
        else
        {
            RegisterNewChange();

            XomControlConnection.SendMessage(strB.ToString() , requestId);
        }
    }

    public static void ProcessAddTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target;
        XomLogArea area;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        area = Areas[args[1]];
        if (area == null)
        {
            XomControlConnection.SendMessage("Error: Area '" + args[1] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target = Targets[args[0]];
        if (target == null)
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        area.AddTarget(target);

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' assigned to area '" + args[1] + "'\r\n\r\n" , requestId);
    }

    public static void ProcessRemoveTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target;
        XomLogArea area;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        if (!XomLoggingControl.Areas.TryGetValue(args[1], out area))
        {
            XomControlConnection.SendMessage("Error: Area '" + args[1] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target = Targets[args[0]];
        if (target == null)
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        area.RemoveTarget(target);

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' removed from area '" + args[1] + "'\r\n\r\n" , requestId);
    }

    public static void ProcessResetTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target = Targets[args[0]];

        if( target == null )
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target.Reset();

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' has been reset.\r\n\r\n" , requestId);
    }

    public static void ProcessListOverridesRequest( string[] args, uint requestId )
    {
        StringBuilder strB = new StringBuilder();

        IEnumerator overEnum = _overrides.GetEnumerator();
        int iOverride = 0;

        while( overEnum.MoveNext() )
        {
            XomLineOverride lo = (XomLineOverride) overEnum.Current;

            // "%d: F:%s L:%d On:%d\r\n"
            strB.Append( iOverride );
            strB.Append( ": F:" );
            strB.Append( lo.szFile );
            strB.Append( " L:" );
            strB.Append( lo.uiLine );
            strB.Append( " On:" );
            strB.Append( lo.fCanLog ? "1\r\n" : "0\r\n" );

            iOverride++;
        }

        if( 0 == iOverride )
        {
            strB.Append( "No overrides currently active\r\n" );
        }

        XomControlConnection.SendMessage( strB.ToString(), requestId );
    }

    public static void ProcessSetOverrideRequest( string[] args, uint requestId )
    {
        //
        // Find out what the caller wants to override
        //
        if( args.Length != 3 )
        {
            ProcessHelpRequest( args, requestId );
            return;
        }

        string szFile = args[ 0 ].ToLower();
        uint uiLine = Convert.ToUInt32( args[ 1 ] );
        bool fCanLog = true;

        try
        {
            fCanLog = Convert.ToBoolean( args[ 2 ] );
        }
        catch
        {
            fCanLog = ( Convert.ToInt32( args[ 2 ] ) != 0 );
        }

        //
        // See if this override already exists
        //
        XomLineOverride lo = null;
        IEnumerator overEnum = _overrides.GetEnumerator();
        int iOverride = 0;

        while( overEnum.MoveNext() )
        {
            lo = (XomLineOverride) overEnum.Current;

            if( ( lo.uiLine == uiLine ) && ( lo.szFile == szFile ) )
            {
                break;
            }

            lo = null;
            iOverride++;
        }

        if( lo != null )
        {
            lo.fCanLog = fCanLog;
        }
        else
        {
            lo = new XomLineOverride( szFile, uiLine, fCanLog );

            iOverride = _overrides.Add( lo );
        }

        RegisterNewChange();

        XomControlConnection.SendMessage(
                                "Override #" + iOverride + " added/altered\r\n",
                                requestId );
    }

    public static void ProcessRemoveOverrideRequest( string[] args, uint requestId )
    {
        if( args.Length != 1 )
        {
            ProcessHelpRequest( args, requestId );
            return;
        }

        int iIndex = Convert.ToInt32( args[ 0 ] );

        try
        {
            _overrides.RemoveAt( iIndex );
        }
        catch
        {
            XomControlConnection.SendMessage( "Override remove of index " + iIndex + " failed\r\n", requestId );
            return;
        }

        RegisterNewChange();

        XomControlConnection.SendMessage( "Override " + iIndex + " removed\r\n", requestId );
    }

    public static void ProcessSetContextOnlyRequest(string[] args, uint requestId)
    {
        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomLogArea area;
        if (!XomLoggingControl.Areas.TryGetValue(args[1], out area))
        {
            XomControlConnection.SendMessage("Error: Area '" + args[0] + "' not found.", requestId);
            return;
        }

        area.ContextOnly = XomLogArea.ParseContextOnlySetting(args[1]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area context only setting updated." , requestId);
    }

    private static void ProcessUpTimeRequest(string[] args, uint requestId)
    {
        if (args.Length != 0)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomControlConnection.SendMessage(UpTime.ToString() , requestId);
    }

    private static void ProcessNewAreaRequest(string[] args, uint requestId)
    {
        if (args.Length < 1 || args.Length > 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        bool fOk = RegisterNewArea(args[0], args.Length > 1 ? args[1] : null);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area \"" + args[0] + "\" " + (string)((fOk) ? "" : "not ") + "created.", requestId);
    }
    private static void ProcessDeleteAreaRequest(string[] args, uint requestId)
    {
        if (args.Length != 1)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomLoggingControl.Areas.Remove(args[0]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area \"" + args[0] + "\" removed.", requestId);
    }

    public static void ProcessAdminSessionDiedRequest(string[] args, uint requestId)
    {
        List<XomLogTarget> targets = new List<XomLogTarget>();

        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                if (target.Session == requestId)
                {
                    targets.Add(target);
                }
            });

        // If there is nothing to remove, cut out early.
        if (targets.Count == 0)
        {
            return;
        }

        foreach (XomLogTarget target in targets)
        {
            //
            // remove from areas
            //

            XomLoggingControl.Areas.ForEach(
                delegate(XomLogArea area)
                {
                    area.RemoveTarget(target);
                }
            );

            Targets.Remove(target.Name);
        }

        RegisterNewChange();
    }

    public static void Close()
    {
        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                target.Close();
            });

        XomControl.ControlRequestEvent -= new XomControl.ControlRequestEventHandler(XomLoggingControl.OnControlRequest);
    }

    public static bool CheckOverrideList( string szFile, int iLine, ref bool fCanLog )
    {
        //
        // See if this override already exists
        //
        XomLineOverride lo = null;
        IEnumerator overEnum = _overrides.GetEnumerator();

        bool fRet = false;
        int cchFile = 0;

        while( overEnum.MoveNext() )
        {
            lo = (XomLineOverride) overEnum.Current;

            if( lo.uiLine == iLine )
            {
                int cchPattern = lo.szFile.Length;

                if( 0 == cchFile )
                {
                    cchFile = szFile.Length;
                }

                if( ( cchFile >= cchPattern ) &&
                    ( szFile.Substring( cchFile - cchPattern ) == lo.szFile ) )
                {
                    fCanLog = lo.fCanLog;
                    fRet = true;
                    break;
                }
            }
        }

        return( fRet );
    }
}

//------------------------------------------------------------------------
// New public entrypoints for all Xom logging/tracing/eventing
//------------------------------------------------------------------------
public static class Xom
{
    //
    // XomTrace
    //

    public static void Trace(string areaName, XomLogTargetContext msgCtx, LogLevel level, string msgFormat, params object[] args)
    {
        // Lookup the area by name
        XomLogArea area = GetAreaByName(areaName);
        if(area == null) {
            return;
        }

        area.Log(msgCtx, (sbyte)level, 0, null, null, msgFormat, args);
    }

    public static void Trace(string areaName, LogLevel level, string msgFormat, params object[] args)
    {
        //Instrument(XomAreaName.DefaultNtLog);
        Trace(areaName, new XomLogTargetContext(Floken.Current), level, msgFormat, args);
    }

    //
    // XomLog
    //

    public static void Log(string areaName, XomLogTargetContext msgCtx, Exception e, string msgFormat, params object[] args)
    {
        // Lookup the area by name
        XomLogArea area = GetAreaByName(areaName);
        if(area == null) {
            return;
        }

        area.Log(msgCtx, (sbyte)LogLevel.L_NORMAL, 0, null, e, msgFormat, args);
    }

    public static void Log(string areaName, XomLogTargetContext msgCtx, string msgFormat, params object[] args)
    {
        Log(areaName, msgCtx, null, msgFormat, args);
    }

    public static void Log(string areaName, string msgFormat, params object[] args)
    {
        Instrument(areaName);
        Log(areaName, new XomLogTargetContext(Floken.Current), null, msgFormat, args);
    }

    public static void Log(string areaName, Exception ex, string msgFormat, params object[] args)
    {
        Instrument(areaName);
        Log(areaName, new XomLogTargetContext(Floken.Current), ex, msgFormat, args);
    }

    //
    // XomNtEvent
    //

    // Replacements for XomNtDataEvent
    public static void NtDataEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgData, msgFormat, args);
    }
    public static void NtDataEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        // Get the DefaultNtLog area
        XomLogArea area = GetAreaByName(XomAreaName.DefaultNtLog);
        if(area == null) {
            return;
        }

        // Pull the level out of the EventID
        sbyte level = (sbyte)((((uint)XEvent.SeverityFromId(eventId)) >> 30) & 0x3);

        // Log to the area
        area.Log(msgCtx, level, XEvent.MessageFromId(eventId), msgData, ex, msgFormat, args);
    }

    // Replacements for XomNtEvent
    public static void NtEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgFormat, args);
    }
    public static void NtEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, ex, null, msgFormat, args);
    }

    // Replacements for XomNtDataDynEvent
    public static void NtDataDynEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgData, "Dynamic Event: " + msgFormat, args);
    }
    public static void NtDataDynEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, ex, msgData, "Dynamic Event: " + msgFormat, args);
    }

    //
    // Non-flowtoken-providing overrides for events.
    //

    // Replacements for XomNtDataEvent
    public static void NtDataEvent(XEvent.Id eventId, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgData, msgFormat, args);
    }
    public static void NtDataEvent(XEvent.Id eventId, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, msgData, msgFormat, args);
    }

    // Replacements for XomNtEvent
    public static void NtEvent(XEvent.Id eventId, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgFormat, args);
    }
    public static void NtEvent(XEvent.Id eventId, Exception ex, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, null, msgFormat, args);
    }

    // Replacements for XomNtDataDynEvent
    public static void NtDataDynEvent(XEvent.Id eventId, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgData, "Dynamic Event: " + msgFormat, args);
    }
    public static void NtDataDynEvent(XEvent.Id eventId, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, msgData, "Dynamic Event: " + msgFormat, args);
    }

    public static XomLogArea GetAreaByName(string areaName)
    {
        XomLogArea area;
        if (!XomLoggingControl.Areas.TryGetValue(areaName, out area))
        {
            return null;
        }
        return area;
    }

    private static class Throttler
    {
        private class ThrottleInfo
        {
            public long Count;
            public DateTime LastReportTime;
        }

        private static Dictionary<string, ThrottleInfo> _ThrottledMessages = new Dictionary<string, ThrottleInfo>();
        private static object _ThrottledMessagesLock = new object();

        internal static bool ShouldSquelch(string key, out long count, int secondsToSquelch, bool resetCount)
        {
            count = 0;
            try
            {
                ThrottleInfo info;

                // Minimize lock time
                lock (_ThrottledMessagesLock)
                {
                    if (!_ThrottledMessages.TryGetValue(key, out info))
                    {
                        info = new ThrottleInfo();
                        info.Count = 0;
                        info.LastReportTime = DateTime.MinValue;
                        _ThrottledMessages[key] = info;
                    }
                }

                // Tick
                count = Interlocked.Increment(ref info.Count);
                TimeSpan elapsedTime = DateTime.Now - info.LastReportTime;

                // Time to report?
                if (elapsedTime.TotalSeconds >= secondsToSquelch)
                {
                    info.LastReportTime = DateTime.Now;
                    if (resetCount)
                    {
                        info.Count = 0;
                    }

                    // false = don't throttle
                    return false;
                }

                // true = throttle
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

    }

    [ThreadStatic]
    private static int _InstrumentCount = 0;

    private static void Instrument(string areaName)
    {
        try
        {
            if (++_InstrumentCount > 1)
            {
                // recursion FAIL!
                return;
            }

            // Write to our special area
            XomLogArea area = GetAreaByName(XomAreaName.XomInstrumentation);
            if (area == null) {
                return;
            }

            // No targets = feature shut off (as much as possible)
            if (area.Targets.Count <= 0)
            {
                return;
            }

            // Is SgInfo available?
            // Bail out for mainline cases
            string sgInfoState;
            if (AAInfo.IsCached)
            {
                sgInfoState = "aacache";
                //return;
            }
            else if (AAInfo.IsActiveAuthAvailable)
            {
                sgInfoState = "aaget";
            }
            else if (SGInfo.IsCached)
            {
                sgInfoState = "cache";
                //return;
            }
            else if (SGInfo.IsAvailable)
            {
                sgInfoState = "get";
            }
            else
            {
                sgInfoState = "none";
                //return;
            }

            // Get file and line number of the original Xom.Log / Xom.NtEvent call
            string srcFile;
            ushort srcLine;
            EventBuilder.GetStackSrc(new StackTrace(true), out srcFile, out srcLine);
            int pos = srcFile.IndexOf("\\private\\");
            if (pos > 0)
            {
                srcFile = srcFile.Substring(pos);
            }

            // Throttle messages...
            string key = srcFile + ":" + srcLine + ":" + sgInfoState;
            long count;

            // once per hour
            if (!Throttler.ShouldSquelch(key, out count, 3600, false))
            {
                // Log it
                area.Log(XomLogTargetContext.Empty, (sbyte)LogLevel.L_NORMAL, 0, null, null,
                         "SGINFOSTATE|{0}|{1}|{2}:{3}|{4}",
                         sgInfoState, areaName, srcFile, srcLine, count);
            }
        }
        catch (Exception)
        {
        }
        finally
        {
            _InstrumentCount--;
        }
    }
}

//------------------------------------------------------------------------
// Log level enumeration (matches levels used by old macros)
//------------------------------------------------------------------------
public enum LogLevel : sbyte {
    L_ON      = 0, L_LOW    = 0,
    L_INFO    = 1, L_NORMAL = 1,
    L_WARNING = 2, L_HIGH   = 2,
    L_ERROR   = 3,
    L_MUTED   = 4, L_OFF    = 4,
};

//------------------------------------------------------------------------
// Attrubite used to tag an assembly that defines a log area
//------------------------------------------------------------------------
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public class XomAreaDefinitionAttribute : Attribute
{
    public XomAreaDefinitionAttribute(string areaName)
    {
        this.Name = areaName;
    }

    public readonly string Name;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomLogTarget.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Web;

using STF.common.config;
using STF.common.service;
using STF.common.utilities2;

namespace STF.common.mgmt
{
[ComVisible(false)]
public abstract class XomLogTarget
{
    protected string _name;
    protected string _params;
    protected uint _session;

    //
    // Property accessors
    //
    public string Name
    {
        get { return _name; }
        set { _name = value; }
    }
    public string Params
    {
        get { return _params; }
        set { _params = value; }
    }

    public uint Session
    {
        get { return _session; }
        set { _session = value; }
    }

    public override bool Equals(object o)
    {
        return ( o is XomLogTarget ) && ( ((XomLogTarget) o).Name.Equals(_name, StringComparison.InvariantCultureIgnoreCase) ) ;
    }

    public override int GetHashCode()
    {
        return( _name.GetHashCode() );
    }

    public virtual void Init( string[,] parameters ) {}
    public abstract void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte[] msgData, string message, Exception e);
    public virtual void Close() {}
    public virtual void Reset() {}
    public virtual void Startup() {}

    protected virtual DateTime CurrentTime
    {
        get { return XDateTime.Now; }
    }

    protected static bool ParseBool(string paramName, string paramValue)
    {
        if (paramValue.Equals("true", StringComparison.OrdinalIgnoreCase) ||
            paramValue.Equals("on", StringComparison.OrdinalIgnoreCase) ||
            paramValue.Equals("1"))
        {
            return true;
        }
        else if (paramValue.Equals("false", StringComparison.OrdinalIgnoreCase) ||
                 paramValue.Equals("off", StringComparison.OrdinalIgnoreCase) ||
                 paramValue.Equals("0"))
        {
            return false;
        }
        else
        {
            throw new ArgumentOutOfRangeException(
                paramName, paramValue, 
                "Error converting parameter to boolean. Must be 'true/false', 'on/off', or '1/0'.");
        }
    }

}

[ComVisible(false)]
public struct XomLogTargetContext
{
    public readonly static XomLogTargetContext Empty = new XomLogTargetContext()
    {
        LogStringId = null,
        FlowToken = Floken.None,
        EventData = null,
        LineData = null
    };

    public XomLogTargetContext(Floken flowToken) : this()
    {
        FlowToken = flowToken;
    }

    public string LogStringId
    {
        get;
        set;
    }

    public Floken FlowToken
    {
        get;
        set;
    }

    public EtxEvent? EventData
    {
        get;
        set;
    }

    public SchematizedLine? LineData
    {
        get;
        set;
    }

    [ComVisible(false)]
    public struct EtxEvent
    {
        public Blob Fingerprint
        {
            get;
            set;
        }

        public byte HeaderVersion
        {
            get;
            set;
        }

        public uint WebRepGroupId
        {
            get;
            set;
        }
    }

    [ComVisible(false)]
    public struct SchematizedLine
    {
        public Blob Fingerprint
        {
            get;
            set;
        }

        public string Key
        {
            get;
            set;
        }

        public byte HeaderVersion
        {
            get;
            set;
        }
    }
}

[ComVisible(false)]
public class XomDebugOutputTarget : XomLogTarget
{
    public XomDebugOutputTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e)
    {
        string lvlStr;

        switch( level )
        {
        case XomLogLevel.Low:
            lvlStr = "VBS";
            break;

        case XomLogLevel.Info:
            lvlStr = "INF";
            break;

        case XomLogLevel.Warning:
            lvlStr = "WRN";
            break;

        case XomLogLevel.Error:
            lvlStr = "ERR";
            break;

        default:
            lvlStr = "";
            break;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        System.Diagnostics.Trace.WriteLine( lvlStr + "[" + area+ "] " + msgCtx.FlowToken.ToString() + ": " + message );
    }
}

[ComVisible(false)]
public class XomConsoleTarget : XomLogTarget
{
    public XomConsoleTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        string lvlStr;

        switch( level )
        {
        case XomLogLevel.Low:
            lvlStr = "VBS";
            break;

        case XomLogLevel.Info:
            lvlStr = "INF";
            break;

        case XomLogLevel.Warning:
            lvlStr = "WRN";
            break;

        case XomLogLevel.Error:
            lvlStr = "ERR";
            break;

        default:
            lvlStr = "";
            break;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        if (msgCtx.FlowToken.IsValid)
        {
            System.Console.WriteLine(lvlStr + "[" + area + "] " + msgCtx.FlowToken.ToString() + ": " + message);
        }
        else
        {
            System.Console.WriteLine( lvlStr + "[" + area+ "]: " + message );
        }
    }
}


[ComVisible(false)]
public class XomNtLogTarget : XomLogTarget
{
    public XomNtLogTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        string log = "Application";

        for( int n=0; n < parameters.GetLength(0); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "source":
                _source = parameters[ n, 1 ];
                break;

            case "log":
                log = parameters[ n, 1 ];
                break;

            default:
                parameters[n,0] = null;
                break;
            }
        }

        if( _source == null )
        {
            // no source specified, use the name of the assembly
            _source = Path.GetFileNameWithoutExtension( Config.AssemblyPath );
        }

        if( !System.Diagnostics.EventLog.SourceExists( _source ) )
        {
            System.Diagnostics.EventLog.CreateEventSource( _source, log );
        }
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        EventBuilder.LogEvent(msgCtx, area, level, msgId, msgData, message, e);

        // if we are handling an http request, then cache  the
        // last event id to put into the response header later

        HttpContext context = HttpContext.Current;
        if (context != null) context.Items["XEvent"] = msgId.ToString();
    }

    private string _source = null;
    private EventLogEntryType[] _typeMapping = {
            EventLogEntryType.Information,
            EventLogEntryType.Information,
            EventLogEntryType.Warning,
            EventLogEntryType.Error
        };
}


[ComVisible(false)]
public class XomRemoteTarget : XomLogTarget
{
    const int DEFAULT_REMOTE_PORT = 4101;

    public XomRemoteTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        string address = null;
        int port = DEFAULT_REMOTE_PORT;

        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "address":
                address = parameters[ n, 1 ];
                break;

            case "port":
                port = Convert.ToInt32( parameters[ n, 1 ] );
                break;

            default:
                parameters[n,0] = null;
                break;
            }

        }

        if( address == null )
        {
            throw new ArgumentNullException( "address", "Address not specified!" );
        }

        IPAddress remoteAddr;

        //  First try to parse the address as an IP address.  If
        //  that fails, then we'll try a DNS lookup.
        try
        {
            remoteAddr = IPAddress.Parse(address);
        }
        catch
        {
            remoteAddr = Dns.GetHostEntry( address ).AddressList[ 0 ];
        }

        _socket = new UdpClient();
        _socket.Connect( remoteAddr, port );

        // Cache frequently used items. These are non-trivial to retrieve, say, 10,000 
        // times per second.
        s_szProcessName = Process.GetCurrentProcess().ProcessName;
        s_szProcessId = Process.GetCurrentProcess().Id.ToString();
        s_szComponentName = Config.ComponentName;

        // Old:
        //s_szProcessName = Process.GetCurrentProcess().MainModule.ModuleName;
        //s_szCurrentDomain = AppDomain.CurrentDomain.ToString();
        //s_szAssemblyPath = Path.GetFileNameWithoutExtension(Config.AssemblyPath);
    }


    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte[] msgData, string message, Exception e)
    {
        byte[] dg;

        if (String.IsNullOrEmpty(s_szThreadId))
        {
            s_szThreadId = Thread.CurrentThread.ManagedThreadId.ToString();
        }

        string szLevel = level.ToString();

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        // These header values should probably match the ones in native code 
        // (xomremotetarget.cpp). And now they do.

        string header = s_szProcessName + ";" +
                        s_szProcessId + ";" +
                        s_szComponentName + ";" +
                        s_szThreadId + ";" +
                        area + ";" + 
                        szLevel + ";" + 
                        msgId + ";" +
                        msgCtx.FlowToken.ToString() + "::";

        dg = _enc.GetBytes(header + message);

        _socket.Send( dg, dg.Length );
    }

    public override void Close()
    {
        _socket.Close();
    }

    private static string s_szProcessName;
    private static string s_szProcessId;
    private static string s_szComponentName;

    [ThreadStatic]
    private static string s_szThreadId;

    private UdpClient _socket;
    private UTF8Encoding _enc = new UTF8Encoding();
}

[ComVisible(false)]
public class XomReportTarget : XomLogTarget
{
    private class Context
    {
        public Context(int queueSize)
        {
            DisconnectNotified = false;
            LastMessage = 0;
            LastReset = 0;

            ReportConnection = new ReportConnection(queueSize);
            ReportConnection.Startup();
        }

        public ReportConnection ReportConnection;
        public bool DisconnectNotified;
        public long LastMessage;
        public long LastReset;
    }
    
    public XomReportTarget( string[,] parameters )
    {
        _iConnectResetInterval = 0; // Default connection reset interval 0 ms - disabled        
        _iHeartBeatInterval = 15 * 1000; // Default heartbeat interval is 15 seconds
        _iKeepAliveInterval = 5 * 60 * 1000; // Default keep alive interval of 5 minutes
        _iQueueSize = 100000;  // Default max number of items in queue is 100,000
        _iConnectionCount = 1; // Default number of report connections        
        Init( parameters );

        _pConnections = null;       
        _threadHeartBeat = null;
        _iInitialized = 0;
        _iShutdown = 0;
        _hShutdown = new AutoResetEvent( false );
        _iConnectionIndex = 0;        
    }

    public override void Init( string[,] parameters )
    {
        bool checkConnections = false;
        bool checkQueueSize = false;
        int connectionCount = 0;
        
        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "connectionresetintervalsec":
                _iConnectResetInterval = Convert.ToInt32( parameters[n, 1] ) * 1000;
                break;
            
            case "heartbeatintervalsec":
                _iHeartBeatInterval = Convert.ToInt32( parameters[ n, 1 ] ) * 1000;
                break;

            case "keepaliveintervalsec":
                _iKeepAliveInterval = Convert.ToInt32( parameters[ n, 1 ] ) * 1000;
                break;

            case "queuesize":
                _iQueueSize = Convert.ToInt32( parameters[ n, 1 ] );
                checkQueueSize = true;
                break;

            case "connections":
                connectionCount = Math.Max(Convert.ToInt32(parameters[n, 1]), 1);
                checkConnections = true;
                break;

            default:
                parameters[n,0] = null;
                break;
            }

            if (_pConnections != null)
            {
                // Resize queues if neccessary
                for (int c = 0; c < _pConnections.Count && checkQueueSize; c++)
                {
                    _pConnections[c].ReportConnection.MaxQueueSize = _iQueueSize;
                }

                // Adjust connection counts if neccessary
                while (checkConnections && _pConnections.Count > connectionCount)
                {
                    int index = _pConnections.Count - 1;

                    Interlocked.Decrement(ref _iConnectionCount);

                    _pConnections[index].ReportConnection.Disconnect();

                    _pConnections.RemoveAt(index);
                }

                while (checkConnections && _pConnections.Count < connectionCount)
                {
                    _pConnections.Add(CreateContext());

                    Interlocked.Increment(ref _iConnectionCount);
                }

                if (checkConnections)
                {
                    _InternalConnect(false);
                }
            }
            else if (checkConnections)
            {
                _iConnectionCount = connectionCount;
            }
        }
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        WireData rptMsgDataWire;

        //
        // If we are shutdown or not initialized, just return
        //
        if( 1 == _iShutdown || 0 == _iInitialized )
        {
            return;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        //
        // Remove "naughties"
        //
        if (!String.IsNullOrEmpty(message))
        {
            message = message.ReplaceControlCharacters('#');
        }

        //
        // Fill the message header
        //

        if (msgCtx.EventData.HasValue)
        {
            ReportMessageData2 report;

            report = new ReportMessageData2();

            report.WebRepGroupId = msgCtx.EventData.Value.WebRepGroupId;
            report.LogStringId = msgCtx.LogStringId;
            report.EtxEventFingerprint = (byte[])msgCtx.EventData.Value.Fingerprint;
            report.EtxEventHeaderVersion = msgCtx.EventData.Value.HeaderVersion;
            report.szMessage = message;

            rptMsgDataWire = report;
        }
        else if (msgCtx.LineData.HasValue)
        {
            ReportMessageData3 report;

            report = new ReportMessageData3();

            report.LogStringId = msgCtx.LogStringId;
            report.EtxEventFingerprint = msgCtx.LineData.Value.Fingerprint;
            report.EtxEventHeaderVersion = msgCtx.LineData.Value.HeaderVersion;
            report.FileNameKey = msgCtx.LineData.Value.Key;
            report.szMessage = message;

            rptMsgDataWire = report;
        }
        else
        {
            ReportMessageData rptMsgData = new ReportMessageData();
            rptMsgData.szMessage = message;

            rptMsgDataWire = rptMsgData;
        }

        //
        // Send the message
        //
        try
        {
            Context context;

            int idx = (int)(Interlocked.Increment(ref _iConnectionIndex) % _iConnectionCount);
            context = _pConnections[idx];
            context.ReportConnection.Send(rptMsgDataWire);

            Interlocked.Exchange( ref context.LastMessage, DateTime.Now.Ticks );           
        }
        catch( Exception exc )
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_33, exc, "XomReportTarget::Log - ReportConnection::Send failed");
        }
    }

    public override void Close()
    {
        ReportMessageBase msgDisconnect;

        //
        // Return if we're not initialized
        //
        if( 0 == _iInitialized )
        {
            return;
        }

        //
        // Just return if we've already been called
        //
        if( 1 == Interlocked.Exchange( ref _iShutdown, 1 ) )
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            //
            // Send a disconnect message
            //
            msgDisconnect = new ReportMessageBase( );
            msgDisconnect.bMsgType = ( byte ) RPT_MSG_TYPE.RPT_MSG_DISCONNECT;        

            //
            // Send the disconnect message
            //
            try
            {
                context.ReportConnection.Send( msgDisconnect );
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_34, e, "XomReportTarget::Close - ReportConnection::Send failed");
            }
        }

        //
        // Abort the heartbeat thread
        //
        if( !_hShutdown.Set( ) )
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_35, "XomReportTarget::Close - Unable to signal thread to shutdown. Going to abort the thread." );
            _threadHeartBeat.Abort( );
        }

        //
        // Sleep a couple of seconds for the disconnect to get sent, then disconnect
        //
        Thread.Sleep( 2000 );

        ShutdownConnections();

        _pConnections = null;
        _iInitialized = 0;
        _threadHeartBeat = null;
    }

    private Context CreateContext()
    {
        Context context;

        //
        // Create and initialize individual report Context object.
        //
        context = new Context(_iQueueSize);

        //
        // Set server and component ID on the connection object
        //
        context.ReportConnection.ComponentID = _componentID;
        context.ReportConnection.Component = _component;

        return context;
    }

    public override void Startup()
    {
        IVirtualInterfaceInfo pVirtualInterface;

        //
        // Bail out if Component ID is not set
        //
        if (0 == Config.ReportMessageComponentId)
        {
            // 
            // Since this is a XomLogTarget Startup method the area may not be completely
            // established - so the ntlog target maynot be in place, in order to ensure
            // the message reaches the event logs this bootstrapping logging method will
            // be used instead
            // 
            XomLoggingControl.WriteEarlyEvent(
                XEvent.Id.MGMT_MISSING_REPORTING_COMPONENT_ID,
                "XomReportTarget::Startup component missing reporting component id, no reporting connection will be established.");

            return;
        }

        //
        // Just return if we've already been called
        //
        if( 1 == Interlocked.Exchange( ref _iInitialized, 1 ) )
        {
           return;
        }

        //
        // Retrieve the cleanser server information, and create the endpoint
        //
        try
        {
            _component = Config.ComponentName;
            _componentID = Config.ReportMessageComponentId;

            pVirtualInterface = Config.GetVirtualInterface( Config.ReportMessageCleanserVirtualInterface );
            _epCleanserHost = pVirtualInterface.IPAddressString;
            _epCleanserPort = pVirtualInterface.Port;

            //
            // Create instances of the ReportConnection object
            //
            _pConnections = new List<Context>();

            for (int c = 0; c < _iConnectionCount; c++)
            {
                _pConnections.Add(CreateContext());
            }            

            //
            // Connect to our desired server
            //
            try
            {
                _InternalConnect(false);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_COMM_9, e, "XomReportTarget::Startup - Reporting target was unable to connect to the cleanser {0}:{1}. We will keep trying.", _epCleanserHost, _epCleanserPort);
            }

            //
            // Create the heartbeat thread
            //
            _threadHeartBeat = new XboxLiveThread( new ThreadStart( this._HeartBeatThread ) );
            _threadHeartBeat.Start( );

            Config.VirtualInterfaceChange += new VirtualInterfaceChangeEventHandler( VirtualInterfaceChanged );
        }
        catch( Exception )
        {
            ShutdownConnections();

            _pConnections = null;
           
            Interlocked.Exchange( ref _iInitialized, 0 );
            
            throw;
        }
    }

    public void VirtualInterfaceChanged(object sender, VirtualInterfaceChangeEventArgs eventArgs)
    {
        IVirtualInterfaceInfo pInterface;

        if( ( eventArgs.Environment == Config.Environment ) &&
            ( eventArgs.VirtualInterface == Config.ReportMessageCleanserVirtualInterface ) )
        {
            pInterface = eventArgs.ValueNew;
            _epCleanserHost = pInterface.IPAddressString;
            _epCleanserPort = pInterface.Port;

            DisconnectConnections();
        }
    }

    private void ShutdownConnections()
    {
        if (null == _pConnections)
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            if (null == context || null == context.ReportConnection)
            {
                break;
            }

            context.ReportConnection.Disconnect();
            context.ReportConnection.Shutdown();
        }
    }

    private void DisconnectConnections()
    {
        if (null == _pConnections)
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            if (null == context || null == context.ReportConnection)
            {
                break;
            }

            context.ReportConnection.Disconnect();
        }
    }

    private void _InternalConnect(bool forced)
    {
        foreach (Context context in _pConnections)
        {
            _InternalConnect(context, forced);
        }
    }

    private void _InternalConnect(Context context, bool forced)
    {
        if (context.ReportConnection.IsConnected && !forced)
        {
            return;
        }

        //
        // Connect to our cleansing server
        //
        context.ReportConnection.AttachAndConnect(_epCleanserHost, _epCleanserPort);
        context.LastReset = DateTime.Now.Ticks;
    }
    

    private void _HeartBeatThread()
    {
        Restart:
        try
        {
            while( true )
            {
                int wait;

                wait = _iConnectResetInterval == 0 ? _iHeartBeatInterval : Math.Min(_iHeartBeatInterval, _iConnectResetInterval);

                if( ( _hShutdown.WaitOne( wait, false ) ) && ( _iShutdown == 1 ) )
                {
                
                    //
                    // Received a signal and the target is shutting down
                    //
                    break;
                }

                for (int index=0; index<_pConnections.Count; index++)
                {
                    ReportMessageBase msgKeepAlive;
                    Context context;
                    long tickNow;
                    long tickStored;

                    context = _pConnections[index];
               
                    //
                    // If we're not connected, reconnect
                    //
                    if (!context.ReportConnection.IsConnected)
                    {
                        if (!context.DisconnectNotified)
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_10, "XomReportTarget::_HeartBeatThread - Reporting target has lost connection to the cleansing server {0}:{1}. Attempting to reconnect", _epCleanserHost, _epCleanserPort);
                        }

                        try
                        {
                            _InternalConnect(context, false);
                        }
                        catch (Exception e)
                        {
                            if (!context.DisconnectNotified)
                            {
                                Xom.NtEvent(XEvent.Id.COMMON_COMM_11, e, "XomReportTarget::_HeartBeatThread - XomReportTarget::_InternalConnect failed to {0}:{1}", _epCleanserHost, _epCleanserPort);
                                context.DisconnectNotified = true;
                            }
                            continue;
                        }

                        //
                        // Force sending of a keepalive message to kick start the queue
                        //
                        if (context.DisconnectNotified)
                        {
                            Xom.NtEvent(XEvent.Id.REPORTINGTARGET_RECONNECTED, "XomReportTarget::_HeartBeatThread - Reporting target has reconnected to the cleansing server {0}:{1}.", _epCleanserHost, _epCleanserPort);
                            context.DisconnectNotified = false;
                        }
                        Interlocked.Exchange(ref context.LastMessage, (long)0);
                    }

                    //
                    // If sufficient time has elapsed without sending a prior message, trigger a connection reset
                    //
                    tickNow = DateTime.Now.Ticks;

                    tickStored = context.LastReset;

                    if (_iConnectResetInterval > 0)
                    {
                        if ((tickNow - tickStored) > ((long)_iConnectResetInterval * 10 * 1000))
                        {
                            _InternalConnect(context, true);
                        }
                    }

                    //
                    // If sufficient time has elapsed without sending a prior message, send a keep alive message
                    //
                    tickNow = DateTime.Now.Ticks;

                    tickStored = context.LastMessage;
                    
                    if ((tickNow - tickStored) <= ((long)_iKeepAliveInterval * 10 * 1000))
                    {
                        continue;
                    }

                    msgKeepAlive = new ReportMessageBase();
                    msgKeepAlive.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_KEEPALIVE;

                    //
                    // Send the keepalive message
                    //
                    try
                    {
                        context.ReportConnection.Send(msgKeepAlive);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CODE_36, e, "XomReportTarget::_HeartBeatThread - ReportConnection::Send failed ({0})", index);
                        continue;
                    }
                    Interlocked.Exchange(ref context.LastMessage, tickNow);
                }
            }
        }
        catch( ThreadAbortException threadExc )
        {
            //
            // We are being forced to shutdown
            //
            Xom.NtEvent( XEvent.Id.COMMON_CODE_37, threadExc, "XomReportTarget::_HeartBeatThread - Thread being aborted");
            goto lDone;
        }
        catch (Exception e)
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_38, e, "XomReportTarget::_HeartBeatThread - Restarting heartbeat logic from unexpected exception");
            goto Restart;
        }

    lDone:
        return;
    }

    string _epCleanserHost;
    int _epCleanserPort;

    Int32 _iConnectResetInterval;    
    Int32 _iHeartBeatInterval;
    Int32 _iKeepAliveInterval;
    Int32 _iQueueSize;
    Int64 _iConnectionIndex;  // need a 64-bit number so we don't roll into negative
    Int32 _iConnectionCount;

    List<Context> _pConnections;
    
    XboxLiveThread _threadHeartBeat;
    string _component;
    int _componentID;

    int _iInitialized;
    int _iShutdown;
    AutoResetEvent _hShutdown;
}

[ComVisible(false)]
public class XomFileTarget : XomLogTarget
{
    public XomFileTarget( string[,] parameters )
    {
        _dtNextRotation = CurrentTime;
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "prefix":
                _prefix = parameters[ n, 1 ];
                break;

            case "rotationtime":
                try
                {
                    _iRotationMinutes = Convert.ToInt32( parameters[ n, 1 ] );
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to signed int." );
                }
                break;

            case "rotationsize":
                try
                {
                    _iRotationSize = Convert.ToInt32( parameters[ n, 1 ] );
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to signed int." );
                }
                break;

            case "flushtime":
                try
                {
                    // get flush time in milliseconds
                    _flushDelay = Convert.ToInt32( parameters[ n, 1 ]);
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to unsigned int." );
                }
                break;

            case "emitthreadid":
                _emitThreadId = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            case "deleteempty":
                _deleteEmptyLogs = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            case "emitflowtoken":
                _emitFlowToken = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            default:
                parameters[n,0] = null;
                break;
            }

        }

    }

    public void LazyCreateFile( bool force )
    {
        //
        // Only proceed if a new file is needed
        //
        if( !( force ||
               ( _stream == null ) ||
               ( ( _iRotationMinutes != 0 ) && ( CurrentTime > _dtNextRotation ) ) ||
               ( ( _iRotationSize != 0 ) && ( _iBytesThisFile >= _iRotationSize ) ) ) )
        {
            return;
        }

        StreamWriter curStream = _stream;

        string newName;
        StreamWriter newStream = CreateNewLogFile( out newName );

        lock( _streamLock )
        {
            //
            // Either replace the current stream with the new one (if nothing's changed),
            // or get rid of the new one if we lost the race.
            //
            if( _stream == curStream )
            {
                Close();

                _stream = newStream;
                _streamFilename = newName;

                if(_iRotationMinutes != 0)
                {
                    ScheduleRotation(30);
                }
            }
            else
            {
                newStream.Close();
                newStream = null;

                try
                {
                    File.Delete( newName );
                }
                catch
                {
                }
            }
        }
    }

    protected void ScheduleRotation(int delaySeconds)
    {
        // Calculate next time to rotate the file
        long lRotationInTicks = ((long)_iRotationMinutes) * 60 * 10000000;
        _dtNextRotation = (new DateTime((CurrentTime.Ticks / lRotationInTicks) * lRotationInTicks)).AddMinutes(_iRotationMinutes);

        // This timer rotates files for "sparse" logs, where there isn't a constant stream 
        // of new loglines coming in, thus causing long spans where there isn't a 
        // rotation.
        // Schedule delaySeconds beyond the due time just so we don't run early.
        TimeSpan dueTime = (_dtNextRotation - CurrentTime) + TimeSpan.FromSeconds(delaySeconds);
        TimeSpan period = TimeSpan.FromMinutes(_iRotationMinutes);

        if (_rotationTimer == null)
        {
            _rotationTimer = new Timer(
                new TimerCallback(RotationThread),
                null,
                dueTime,
                period);
        }
        else
        {
            _rotationTimer.Change(dueTime, period);
        }
    }

    private void RotationThread(object param)
    {
        try
        {
            LazyCreateFile(false);
        }
        catch (Exception exc)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.LOGTARGET_CREATE_ERROR, exc, "Log file create failed in rotation timer");
            }
            catch (Exception)
            {
            }
        }
    }

    private StreamWriter CreateNewLogFile( out string filename )
    {
        StreamWriter sw = null;
        Exception    eCreate = null;
        DateTime     now = CurrentTime;

        //
        // Reset the file number every hour
        //
        int iCurHour = now.Hour;
        int iLastHour = _iLastHour;

        if( ( iCurHour != iLastHour ) &&
            ( Interlocked.CompareExchange( ref _iLastHour, iCurHour, iLastHour ) == iLastHour ) )
        {
            Interlocked.Exchange( ref _iFileNum, 0 );
        }

        //
        // Build filename using the prefix, the date and a hour-specific file number.
        //
        filename = "";

        int nNameTry = 0;

        for( int nFileTry = 0; ( sw == null ) && ( nFileTry < 1000 ); nFileTry++ )
        {
            for( ; nNameTry < 10000; nNameTry++ )
            {
                int iFileNum = Interlocked.Increment( ref _iFileNum );

                // _prefix may have time-related tokens. Replace them.
                string newPrefix = _prefix;

                // No padding for these, just plain ToString to maintain compatibility 
                // with what the Cleansers used to do. If we want padded versions, we'll 
                // have to make new tokens.
                newPrefix = newPrefix.Replace("#HOUR#", now.Day.ToString());
                newPrefix = newPrefix.Replace("#DAY#", now.Day.ToString());
                newPrefix = newPrefix.Replace("#MONTH#", now.Month.ToString());
                newPrefix = newPrefix.Replace("#YEAR#", now.Year.ToString());

                filename = newPrefix + now.ToString( "yyyyMMddHH" ) +  iFileNum.ToString( "d4" ) + ".log";

                string dir = Path.GetDirectoryName( filename );
                if( !Directory.Exists( dir ) )
                {
                    Directory.CreateDirectory( dir );
                }

                if( !File.Exists( filename ) )
                {
                    break;
                }
            }

            try
            {
                sw = File.CreateText( filename );
            }
            catch (Exception e)
            {
                sw = null;
                eCreate = e;
            }
        }

        //
        // Never return null from this function. If we failed, throw the first
        // exception we obtained
        //
        if (sw == null && eCreate != null)
        {
            throw eCreate;
        }
        return( sw );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        if (e != null)
        {
            message += "\r\n" + e.ToString();
        }

        //
        // Optionally roll over to new log file
        //
        try
        {
            LazyCreateFile( false );
        } catch (Exception exc)
        {
            Xom.NtEvent(XEvent.Id.LOGTARGET_CREATE_ERROR, exc, "Log file create failed");
            return;
        }

        //
        // Build the date/time line prefix string, count the bytes being written, and write them
        //
        string szDateTime = XDateTime.ToString(CurrentTime) + "|";

        // Add the ubiquitous flow token as param #2
        if (_emitFlowToken)
        {
            szDateTime = szDateTime + msgCtx.FlowToken.ToString() + "|";
        }

        // TODO: optionally log level if appropriate target param is set
        //      level.ToString()
        // @@@ kgoodier Warning: this changes the field # of the datetime & flowtoken.  
        // That's not good.
        //
        if (_emitThreadId)
        {
            szDateTime = Thread.CurrentThread.GetHashCode().ToString("X4") + "|" +  szDateTime;
        }

        //
        // Do the equivalent of the Win32 API InterlockedExchangeAdd to bump up the accumulated
        // file size
        //
        if( _iRotationSize > 0 )
        {
            int iLineBytes = szDateTime.Length + message.Length + 2;

            int iBytesThisFile = _iBytesThisFile;

            while( Interlocked.CompareExchange( ref _iBytesThisFile, iBytesThisFile + iLineBytes, iBytesThisFile ) != iBytesThisFile )
            {
                iBytesThisFile = _iBytesThisFile;
            }
        }

        lock( _streamLock )
        {
            try
            {
                // Make sure each line is prefaced with the same text so that any formatting the caller
                // has done with multiline output will look correct.
                // NOTE: We are ignoring text with \n embedded (i.e. not \r\n) as the file stream will ignore
                // them also.  Callers should always use \r\n as that works for all log targets.
                _stream.WriteLine( szDateTime + message.Replace( "\r\n", "\r\n" + szDateTime ) );
            }
            catch (Exception exc)
            {
                Close();
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_262, exc, "Log file write failed");
                return;
            }
        }

        //
        // See if we should flush the file contents to disk now, based on the configured interval
        //
        int lastFlushToLog = _lastFlush;
        int nowTicks = GetNowTicks();
        int msSinceLastFlush = nowTicks - lastFlushToLog;

        if ( msSinceLastFlush >= _flushDelay )
        {
            //
            // If we are the ones who bump up the last flush time, we are allowed to flush the file to disk
            //
            if( Interlocked.CompareExchange( ref _lastFlush, nowTicks, lastFlushToLog ) == lastFlushToLog )
            {
                lock( _streamLock )
                {
                    try
                    {
                        _stream.Flush();
                    }
                    catch(Exception exc)
                    {
                      Xom.NtEvent( XEvent.Id.COMMON_CONFIG_263, exc, "Log file flush failed");
                    }
                }
            }
        }

    }

    public override void Close()
    {
        if (_rotationTimer != null)
        {
            _rotationTimer.Dispose();
            _rotationTimer = null;
        }

        if( _stream != null )
        {
            string fileName;
            int fileSize;

            _stream.Close();

            fileSize = _iBytesThisFile;
            fileName = _streamFilename;

            _stream = null;
            _streamFilename = null;
            _iBytesThisFile = 0;

            if (_deleteEmptyLogs && fileSize == 0)
            {
                try
                {
                    // destroy empty files when that option is set
                    File.Delete(fileName);
                }
                catch { }
            }
        }
    }

    public override void Reset()
    {
        //
        // Force roll over to new log file
        //
        LazyCreateFile( true );
    }

    private int GetNowTicks()
    {
        // DateTime.Now is really slow
        // DateTime.UtcNow is slow
        // Environment.TickCount is fast if you can live with a 24.9 day rollover.
        return Environment.TickCount;
    }

    private int         _lastFlush          = 0;
    private int         _flushDelay         = 1000;                     //milliseconds.
    private int         _iRotationSize      = 0;     // Max log file size in bytes before rotating
    private int         _iBytesThisFile     = 0;
    private int         _iRotationMinutes   = 60;     // One hour default rotation time
    private DateTime    _dtNextRotation;
    private Timer       _rotationTimer      = null;
    private string      _prefix             = "C:\\log\\";
    private UTF8Encoding _enc               = new UTF8Encoding();
    private StreamWriter _stream            = null;
    private string       _streamFilename    = null;
    private object      _streamLock         = new object();

    private int         _iFileNum           = 0;
    private int         _iLastHour          = 24;
    private bool        _emitThreadId       = false;
    private bool        _deleteEmptyLogs    = true;
    private bool        _emitFlowToken      = false;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomAreaName.cs ===
namespace STF.common.mgmt
{
    //------------------------------------------------------------------------
    // Constant strings for all log areas
    //------------------------------------------------------------------------
    public class XomAreaName
    {
        public const string aainfo                      = "aainfo";
        public const string aamodule                    = "aamodule";
        public const string aamoduleLog                 = "aamoduleLog";
        public const string AccelerationProxy           = "AccelerationProxy";
        public const string atTrace                     = "atTrace";
        public const string audit                       = "audit";
        public const string authsglog                   = "authsglog";
        public const string authsgtrace                 = "authsgtrace";
        public const string bcfgtrace                   = "bcfgtrace";
        public const string catalog                     = "catalog";
        public const string catalogwatcherlog           = "catalogwatcherlog";
        public const string cfgtrace                    = "cfgtrace";
        public const string checkready                  = "checkready";
        public const string cleanclips                  = "cleanclips";
        public const string cleansermissingdata         = "cleansermissingdata";
        public const string cleansertrace               = "cleansertrace";
        public const string computil                    = "computil";
        public const string contentutiltrace            = "contentutiltrace";
        public const string crontest                    = "crontest";
        public const string crontrace                   = "crontrace";
        public const string cryptomgr                   = "cryptomgr";
        public const string cryptotools                 = "cryptotools";
        public const string ctpTransactionServiceLog    = "ctpTransactionServiceLog";
        public const string ctpTransactionServiceTrace  = "ctpTransactionServiceTrace";
        public const string ctxDebug                    = "ctxDebug";
        public const string deactivator                 = "deactivator";
        public const string DefaultNtLog                = "DefaultNtLog";
        public const string dmplog                      = "dmplog";
        public const string dmptrace                    = "dmptrace";
        public const string domTrace                    = "domTrace";
        public const string ElimEntrants                = "ElimEntrants";
        public const string ElimEvents                  = "ElimEvents";
        public const string Elimination                 = "Elimination";
        public const string elimtest                    = "elimtest";
        public const string enfTrace                    = "enfTrace";
        public const string enmrdfTrace                 = "enmrdfTrace";
        public const string espengine                   = "espengine";
        public const string EventService                = "EventService";
        public const string feedbacklog                 = "feedbacklog";
        public const string FeedbackProxy               = "FeedbackProxy";
        public const string feedbackTrace               = "feedbackTrace";
        public const string finbusLog                   = "finbusLog";
        public const string finbusTrace                 = "finbusTrace";
        public const string fseLog                      = "fseLog";
        public const string fseTrace                    = "fseTrace";
        public const string marketplacecatalog          = "marketplacecatalog";
        public const string geoFenceLog                 = "geoFenceLog";
        public const string geoFenceTrace               = "geoFenceTrace";
        public const string glcTrace                    = "glcTrace";
        public const string graduateUserTrace           = "graduateUserTrace";
        public const string gtqTrace                    = "gtqTrace";
        public const string kdcmanaged                  = "kdcmanaged";
        public const string lbsvrclient                 = "lbsvrclient";
        public const string listsTrace                  = "listsTrace";
        public const string livecachelog                = "livecachelog";
        public const string livecachetrace              = "livecachetrace";
        public const string livepxy                     = "livepxy";
        public const string livepxylog                  = "livepxylog";
        public const string log                         = "log";
        public const string LogCollectorModuleLog       = "LogCollectorModuleLog";
        public const string LogCollectorModuleTrace     = "LogCollectorModuleTrace";
        public const string matchdbtrace                = "matchdbtrace";
        public const string matchprestrace              = "matchprestrace";
        public const string MatchProxy                  = "MatchProxy";
        public const string matchtrace                  = "matchtrace";
        public const string MessageProxy                = "MessageProxy";
        public const string messagingfd                 = "messagingfd";
        public const string messagingfdLog              = "messagingfdLog";
        public const string metro                       = "metro";
        public const string mllog                       = "mllog";
        public const string mltrace                     = "mltrace";
        public const string msgmanager                  = "msgmanager";
        public const string msnrraggregationlog         = "msnrraggregationlog";
        public const string msnrraggregationtrace       = "msnrraggregationtrace";
        public const string msnrrLog                    = "msnrrLog";
        public const string msnrrTrace                  = "msnrrTrace";
        public const string musicnetLog                 = "musicnetLog";
        public const string musicnetTrace               = "musicnetTrace";
        public const string nametrace                   = "nametrace";
        public const string nrTrace                     = "nrTrace";
        public const string offer                       = "offer";
        public const string passportLog                 = "passportLog";
        public const string passportTrace               = "passportTrace";
        public const string pathTrace                   = "pathTrace";
        public const string plugintest                  = "plugintest";
        public const string PresenceFDDebug             = "PresenceFDDebug";
        public const string PresenceLog                 = "PresenceLog";
        public const string PresenceProxy               = "PresenceProxy";
        public const string PresenceRPDebug             = "PresenceRPDebug";
        public const string provisioning                = "provisioning";
        public const string progresslog                 = "progresslog";
        public const string profilelog                  = "profilelog";
        public const string pss                         = "pss";
        public const string puidmgr                     = "puidmgr";
        public const string QueryTest                   = "QueryTest";
        public const string ratingstrace                = "ratingstrace";
        public const string rdfTrace                    = "rdfTrace";
        public const string readsitekeys                = "readsitekeys";
        public const string replacePassportTrace        = "replacePassportTrace";
        public const string ReflectorFD                 = "ReflectorFD";
        public const string ReflectorFDLog              = "ReflectorFDLog";
        public const string ReportConnection            = "ReportConnection";
        public const string Reporting                   = "Reporting";
        public const string Reporting_v2                = "Reporting_v2";
        public const string rfhTrace                    = "rfhTrace";
        public const string rmfTrace                    = "rmfTrace";
        public const string selog                       = "selog";
        public const string serialnumber                = "serialnumber";
        public const string sginfotrace                 = "sginfotrace";
        public const string SGProxy                     = "SGProxy";
        public const string soaptrace                   = "soaptrace";
        public const string SocialCacheAPI              = "SocialCacheAPI";
        public const string SocialCacheConnection       = "SocialCacheConnection";
        public const string SocialCacheLog              = "SocialCacheLog";
        public const string socialqueryfd               = "socialqueryfd";
        public const string spslog                      = "spslog";
        public const string spsproxy                    = "spsproxy";
        public const string spsproxyLog                 = "spsproxyLog";
        public const string spsqueuetrace               = "spsqueuetrace";
        public const string spstrace                    = "spstrace";
        public const string sqltrace                    = "sqltrace";
        public const string statdb                      = "statdb";
        public const string statslog                    = "statslog";
        public const string stfdTrace                   = "stfdTrace";
        public const string stlog                       = "stlog";
        public const string storageHealthTrace          = "storageHealthTrace";
        public const string StorageModuleLog            = "StorageModuleLog";
        public const string storageModuleTrace          = "storageModuleTrace";
        public const string storageUtilsTrace           = "storageUtilsTrace";
        public const string stringLog                   = "stringLog";
        public const string StringProxy                 = "StringProxy";
        public const string stringSvrHealthTrace        = "stringSvrHealthTrace";
        public const string stringTrace                 = "stringTrace";
        public const string sts                         = "sts";
        public const string ststrace                    = "ststrace";
        public const string subcodemgr                  = "subcodemgr";
        public const string switchPassportTrace         = "switchPassportTrace";
        public const string TagRecycleCronJobs          = "TagRecycleCronJobs";
        public const string TeamProxy                   = "TeamProxy";
        public const string Test                        = "Test";
        public const string testfdtrace                 = "testfdtrace";
        public const string TestUtilities               = "TestUtilities";
        public const string title                       = "title";
        public const string titleConfig                 = "TitleConfig";
        public const string tmrlog                      = "tmrlog";
        public const string tokenTrace                  = "tokenTrace";
        public const string toolspslog                  = "toolspslog";
        public const string ToolsSrv                    = "ToolsSrv";
        public const string ToolsSrvLog                 = "ToolsSrvLog";
        public const string trace                       = "trace";
        public const string userbillinginfo             = "userbillinginfo";
        public const string user2                       = "user2";
        public const string VortexTrace                 = "VortexTrace";
        public const string VortexFlow                  = "VortexFlow";
        public const string VortexOutput                = "VortexOutput";
        public const string VortexOutputUnknown         = "VortexOutputUnknown";
        public const string voucher                     = "voucher";
        public const string wcgenerallog                = "wcgenerallog";
        public const string wcgeneraltrace              = "wcgeneraltrace";
        public const string wcMessagingLog              = "wcMessagingLog";
        public const string wcMessagingTrace            = "wcMessagingTrace";
        public const string wcmusiclog                  = "wcmusiclog";
        public const string wcpresencelog               = "wcpresencelog";
        public const string wcQueryLog                  = "wcQueryLog";
        public const string wcsignaturelog              = "wcsignaturelog";
        public const string wcstatscache                = "wcstatscache";
        public const string wcstatsdomain               = "wcstatsdomain";
        public const string wcstatslog                  = "wcstatslog";
        public const string wcstatstrace                = "wcstatstrace";
        public const string wcstoragelog                = "wcstoragelog";
        public const string wcteamslog                  = "wcteamslog";
        public const string wctoolsmgmtlog              = "wctoolsmgmtlog";
        public const string wctoolsmgmttrace            = "wctoolsmgmttrace";
        public const string wcuserslog                  = "wcuserslog";
        public const string wcutilitieslog              = "wcutilitieslog";
        public const string wcutilitiestrace            = "wcutilitiestrace";
        public const string WireDataBin                 = "WireDataBin";
        public const string WireDataTxt                 = "WireDataTxt";
        public const string wmisLog                     = "wmisLog";
        public const string wmisTrace                   = "wmisTrace";
        public const string wrfTrace                    = "wrfTrace";
        public const string wsttrace                    = "wsttrace";
        public const string xarblog                     = "xarblog";
        public const string XBancProxy                  = "XBancProxy";
        public const string XomInstrumentation          = "XomInstrumentation";
        public const string xbos                        = "xbos";
        public const string XCacheProxy                 = "XCacheProxy";
        public const string XCacheDatabase              = "XCacheDatabase";
        public const string XCacheLookup                = "XCacheLookup";
        public const string XCacheClient                = "XCacheClient";
        public const string XCacheLog                   = "XCacheLog";
        public const string XCacheService               = "XCacheService";
        public const string xcbk                        = "xcbk";
        public const string XConnSrvAPI                 = "XConnSrvAPI";
        public const string XConnSrvCache               = "XConnSrvCache";
        public const string XConnSrvConnection          = "XConnSrvConnection";
        public const string XConnSrvLog                 = "XConnSrvLog";
        public const string XConnSrvSubscription        = "XConnSrvSubscription";
        public const string XCrypto                     = "XCrypto";
        public const string xlastutil                   = "xlastutil";
        public const string xlisttrace                  = "xlisttrace";
        public const string xmachine                    = "xmachine";
        public const string xqry                        = "xqry";
        public const string xrltrace                    = "xrltrace";
        public const string xsig                        = "xsigv";
        public const string xsiglog                     = "xsiglog";
        public const string xsuppapi                    = "xsuppapi";
        public const string xsuppapiEmailSentLog        = "xsuppapiEmailSentLog";
        public const string xsuppapiLog                 = "xsuppapiLog";
        public const string xtou                        = "xtou";
        public const string xuacs                       = "xuacs";
        public const string xuser                       = "xuser";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xomperfctrs.cs ===
/*
NT Performance Counters

Declare your own class following like in the example:

    [XomPerformanceCounterCategoryAttr(
        "TestApp Counters", 
        "The counters for your nice test app",
        true  //If this is a Shared PerfCategory installed by more than one component
    )]
    public class TestAppCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Operations per second", 
            "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RatingsPerSecond;

        static public TestAppCounters Counters = new TestAppCounters();
    }

Then access the PerformanceCounter fields directly. E.g.:

    TestAppCounters.Counters.RatingsPerSecond.Increment();

For more information look for 'PerformanceCounter class' on MSDN. 

One more thing, if you're using counters then you will first have to install 
your assembly using InstallUtil.exe which is located in the .NET framework
directory: %WINDIR%\Microsoft.NET\Framework\vXXXX\InstallUtil.exe.

*/

using System;
using System.Collections;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Collections.Generic;

using STF.common.config;
using STF.common.service;

namespace STF.common.mgmt
{
    // Useful little class to use with AverageTimer counters. Just instantiate
    // one at the begining of the request and increment the counter at the end
    // of the request using the TimeElapsed field.

    [ComVisible(false)]
    public class XomRequestTimeElapsed
    {
        // Static constructor.  Gets the system timer frequency.
        
        static XomRequestTimeElapsed()
        {
            QueryPerformanceFrequency(ref _freq); 
            
            _msFreq = _freq / 1000;
        }
        
        // Constructor. Gets the current time for reference.                

        public XomRequestTimeElapsed()
        {
            QueryPerformanceCounter(ref _started);
        }

        // Returns the time elapsed since the object was constructed.

        public long TimeElapsed 
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);

                return now - _started;
            }
        }
        
        public long SecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);                

                return ((now - _started) / _freq);                
            }
        }
        
        public long MillisecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);                

                return (long)((now - _started) / _msFreq); 
            }
        }

        // Win32 imports

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceCounter(ref long time);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceFrequency(ref long freq);

        private long _started;
            // Time when object was instantiated.
            
        private static long _freq;
            // Nonchanging frequency of the high resolution system counter.    
            
        private static float _msFreq;
            // pre-calculated float divisor
    }

    // Performance Counter category attribute class used to define the name and 
    // the help text for that category.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class XomPerformanceCounterCategoryAttr : System.Attribute
    {
        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , false)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, bool isCommon)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , isCommon)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime)
        : this (ctgName , ctgHelp, ctrInstanceLifetime, false)
        {
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime , bool isCommon)
        {
            _isShared = isCommon;
            _ctgName = ctgName;
            _ctgHelp = ctgHelp;
            _ctrInstanceLifetime = ctrInstanceLifetime;
        }

        public bool IsShared
        {
            get { return _isShared; }
        }

        public string CtgName
        {
            get 
            { 
                // DANGER!  DANGER!  WILLL ROBINSON!  DANGER!  DANGER!

                // do not change this without first consulting the ops
                // team which looks for performance counters with this
                // specific formula (most notably the  leading  "XBL")

                return "XBL " + _ctgName; 

                // DANGER!  DANGER!  WILLL ROBINSON!  DANGER!  DANGER!
            }
        }

        public string CtgHelp
        {
            get { return _ctgHelp; }
        }

        public PerformanceCounterInstanceLifetime CtrInstanceLifetime
        {
            get { return _ctrInstanceLifetime; }
        }

        private bool   _isShared;
        private string _ctgName;
        private string _ctgHelp;
        private PerformanceCounterInstanceLifetime _ctrInstanceLifetime;  // applies to all counters & all instances in this category
        
    }


    // Performance Counter category attribute class used to define the name and the help 
    // text for that category. Uses the ConfigAttribute friendly component name in 
    // addition to a caller-supplied suffix.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class XomComponentPerformanceCounterCategoryAttr : XomPerformanceCounterCategoryAttr
    {
        public XomComponentPerformanceCounterCategoryAttr(string ctgSuffix, string ctgHelp)
            : base(
                ConfigAttribute.GetFriendlyComponent() + " - " + ctgSuffix, 
                ConfigAttribute.GetComponent() + ": " + ctgHelp, 
                PerformanceCounterInstanceLifetime.Global, 
                false)
        {
        }
    }

    
    // Performance counter attribute class used to define the name, help text
    // and counter type.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class XomPerformanceCounterAttr : System.Attribute
    {
        public XomPerformanceCounterAttr(string ctrName, string ctrHelp, PerformanceCounterType ctrType)
        {
            _ctrName = ctrName;
            _ctrHelp = ctrHelp;
            _ctrType = ctrType;
        }

        public string _ctrName;
        public string _ctrHelp;
        public PerformanceCounterType _ctrType;

        public bool Equals(XomPerformanceCounterAttr anotherInstance )
        {
            if (anotherInstance._ctrName != this._ctrName)
            {
                return false;
            }
            else if (anotherInstance._ctrHelp != this._ctrHelp)
            {
                return false;
            }
            else if (anotherInstance._ctrType != this._ctrType)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }
    
    // Performance counter category class. Declare one of this for each counter
    // category that your application needs. Declare counters of the type 
    // PerformanceCounter inside it.

    [ComVisible(false)]
    public class XomPerformanceCounterCategory
    {
        public const string DEFAULT_INSTANCE = "_Total_";

        [ThreadStaticAttribute]
        private static string _categoryInstanceName;

        // Gets the instance name associated with the current thread, or the default instance
        // if none is specified.
        
        private static string GetInstanceName() {
            return _categoryInstanceName ?? XomPerformanceCounterCategory.DEFAULT_INSTANCE;
        }

        private static void SetInstanceName(string instance) {
            _categoryInstanceName = instance;
        }
        
        public XomPerformanceCounterCategory() : this(false)
        {
        }
        public XomPerformanceCounterCategory(bool fInitToZero)
        {
            // Extract the name and the instanceLifeTime text from the class's custom attribute. 
            XomPerformanceCounterCategoryAttr catAttr = XomPerformanceCounterInstall.GetCategoryAttribute(GetType());

            string categoryName = catAttr.CtgName;
            string categoryHelp = catAttr.CtgHelp;

            _categoryName = categoryName;
            _instanceLifetime = catAttr.CtrInstanceLifetime;

            InitializeCategory(GetInstanceName(), fInitToZero);
        }
        
        // You can use this method to create/access other instances. The first
        // time you access the instance will create it. Since the method returns
        // an XomPerformanceCounterCategory object  you will have to cast it
        // to your own class before accessing its counters. One practical way of
        // doing it is to declare your own [] operator. Hmmm, maybe we should 
        // have a method that destroys an instance, huh?

        public XomPerformanceCounterCategory GetInstance(string instanceName)
        {
            XomPerformanceCounterCategory instance;
            
            // access to instance list must be protected against writes.
            
            _lockInstances.AcquireReaderLock(-1);

            try
            {
                // search for instance
            
                instance = (XomPerformanceCounterCategory) _instances[instanceName];

                if(instance == null)
                {
                    try {
                        // object instance will be actived with, the 
                        // XomPerformanceCounterCategory::ctor will catch the 
                        // correct counter instance names to initialize with
                        SetInstanceName(instanceName);
                        instance = (XomPerformanceCounterCategory)Activator.CreateInstance(GetType());
                    }
                    finally {
                        SetInstanceName(null);
                    }

                    // We need write access to the instance list to add this new
                    // instance
                    
                    LockCookie lockCookie = _lockInstances.UpgradeToWriterLock(-1);

                    try
                    {
                        // Now that we are inside, make sure that no other thread
                        // added the instance before us.

                        if(_instances[instanceName] == null)
                        {
                            // Add instance to instance list
                            
                            _instances[instanceName] = instance;
                        }
                        else
                        {
                            // Some other thread got here first. Well, let's use
                            // the object that is already there, then.
                            
                            instance = (XomPerformanceCounterCategory) _instances[instanceName];
                        }
                    }
                    finally
                    {
                        _lockInstances.DowngradeFromWriterLock(ref lockCookie);
                    }
                }
            }
            finally
            {
                _lockInstances.ReleaseReaderLock();
            }

            return instance;
        }

        #region Force Init Perf Counters

        // The goal of this static method is to force the initialization of all
        // perfctrs category objects in the assembly, as opposed to the usual
        // managed code behavior of initializing on demand. This method should 
        // be called upon the initialization of the assembly. In the case of 
        // ASP.NET, when the assembly is loaded by IIS.

        public static void InitPerfCtrs()
        {
            Assembly assembly = Config.Assembly;
            InitPerfCtrs(assembly);

            foreach (AssemblyName assemblyName in assembly.GetReferencedAssemblies()) {
                try {
                    assembly = Assembly.Load(assemblyName);
                    InitPerfCtrs(assembly);
                }
                catch (FileNotFoundException) {
                    // ignore
                }
            }
        }    

        public static void InitPerfCtrs(Assembly asm)
        {
            try
            {
                FieldInfo[] fields = GetAssemblyPerfCounters(asm);
                
                for (int i = 0; i < fields.Length; i++)
                {
                    fields[i].GetValue(null);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_264, e,
                    "Failed to initialize the performance counter categories in this "+
                    "application. This is the initial attempt and will be ignored. " + 
                    "However, problems may occur when the counters get used. " +
                    "Attached to this event should be the reason why it failed. " +
                    "If you cannot figure it out, write down the description and " +
                    "contact dev. After correcting the problem, recycling the service " +
                    "is probably a good idea."
                );
            }
        }

        

        // Same thing as InitPerfCtrs(), but initalizes a specific instance 
        public static void InitInstPerfCtrs(string instance)
        {
            InitInstPerfCtrs(Config.Assembly, instance);
        }
        public static void InitInstPerfCtrs(Assembly asm, string instance)
        {
        
            try
            {
                FieldInfo[] fields = GetAssemblyPerfCounters(asm);
                
                for (int i = 0; i < fields.Length; i++)
                {
                    // make sure the default instance is initalized
                    ((XomPerformanceCounterCategory)fields[i].GetValue(null)).GetInstance(DEFAULT_INSTANCE);
                    // as well as the requested instance
                    ((XomPerformanceCounterCategory)fields[i].GetValue(null)).GetInstance(instance);
                }    
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_265, e,
                    "Failed to initialize the performance counter categories in this "+
                    "application. This is the initial attempt and will be ignored. " + 
                    "However, problems may occur when the counters get used. " +
                    "Attached to this event should be the reason why it failed. " +
                    "If you cannot figure it out, write down the description and " +
                    "contact dev. After correcting the problem, recycling the service " +
                    "is probably a good idea."
                );
            }
        }

        private static FieldInfo[] GetAssemblyPerfCounters(Assembly asm)
        {

            FieldInfo[] fields;
            
            // check for field info in http cache.
            // this is useful as this cache automatically cleans up items that may not be
            // referenced often (like this) if/when necessary.
            //
            if (HttpContext.Current != null)
            {
                fields = (FieldInfo[])HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"];
                if (fields != null)
                {
                    return fields;
                }
            }
            
            // nothing found in the cache, so build the list
            //
            Type[] allTypes = asm.GetTypes();
            ArrayList fieldList = new ArrayList();
            
            foreach( Type t in allTypes )
            {
                if(XomPerformanceCounterInstall.IsValidPerformanceCounterCategory(t))
                {
                    // Query all the static/public fields from this class.
                    fields = t.GetFields(BindingFlags.Static | BindingFlags.Public);
    
                    foreach(FieldInfo field in fields)
                    {
                        // If the field has the same type as the class itself,
                        // then that's what we're looking for.
                        if( field.MemberType == MemberTypes.Field &&
                            field.ReflectedType == t)
                        {
                            fieldList.Add(field);
                        }
                    }
                }
            }
            
            fields = new FieldInfo[fieldList.Count];
            fieldList.CopyTo(fields, 0);
            
            
            if (HttpContext.Current != null)
            {
                HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"] = fields;
            }
            
            return fields;
        }

        #endregion Force Init Perf Counters

        // Verifies that a field is a valid perform counter field.
        // Validity requires that is the right type, and has the required attribute
        
        private bool IsValidPerformanceCounterField(FieldInfo field) {
            return 
                field.FieldType == typeof(PerformanceCounter) &&
                Attribute.IsDefined(field, typeof(XomPerformanceCounterAttr), false);
        }

        // Get the attribute from a performance counter field, it is assumed that
        // the field is valid
        
        private XomPerformanceCounterAttr GetPerformanceCounterAttr(FieldInfo field) {
            return field.GetCustomAttributes(
                typeof(XomPerformanceCounterAttr), 
                false)[0] as XomPerformanceCounterAttr;
        }

        // Enumerate all fields that are valid performance counter fields for this
        // class
        
        private FieldInfo[] EnumerateValidPerformanceCounterFields() {
            FieldInfo[]     fields;
            List<FieldInfo> validFields;

            fields      = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            validFields = new List<FieldInfo>(fields.Length);
            
            for (int c=0; c<fields.Length; c++) {
                if (IsValidPerformanceCounterField(fields[c]))
                    validFields.Add(fields[c]);
            }

            return validFields.ToArray();
        }
        
        // Loads all the performance counters for the valid performance counter fields
        
        private void InitializeCategory(string instanceName, bool fInitToZero) 
        {
            foreach (FieldInfo field in EnumerateValidPerformanceCounterFields()) {
                XomPerformanceCounterAttr attr = GetPerformanceCounterAttr(field);

                PerformanceCounter counter;

                counter = CreateCounter(
                    attr._ctrName,
                    instanceName);

                if (fInitToZero)
                {
                    counter.RawValue = 0;
                }

                field.SetValue(this, counter);
            }
        }

        // Creates a new performance counter object

        private PerformanceCounter CreateCounter(string counterName, string instanceName) {
            PerformanceCounter counter;
            long raw;

            try {
                counter = new PerformanceCounter();
                counter.CategoryName     = _categoryName;
                counter.CounterName      = counterName;
                counter.InstanceName     = instanceName;
                counter.ReadOnly         = false;
                counter.InstanceLifetime = _instanceLifetime;
                
                //force initialization of the counter
                raw = counter.RawValue;

                return counter;
            }
            catch (Exception e) {
                Xom.NtEvent(XEvent.Id.PERFORMANCE_COUNTERS_0, e, 
                    "Failed to create the performance counter '{0}' in category '{1}' " +
                    "for instance '{2}'. " +
                    "This may be due to an improper installation of the component, if so running " +
                    "installutil.exe against against this component may fix the issue.",
                    counterName, _categoryName, instanceName
                );

                throw;
            }
        }

        private string _categoryName = null; 
            // Name of the performance counter category

        private Hashtable _instances = new Hashtable();
            // Hash table to store the instance objects
            
        private ReaderWriterLock _lockInstances = new ReaderWriterLock();
            // Sync access to the _instances

        private PerformanceCounterInstanceLifetime _instanceLifetime = PerformanceCounterInstanceLifetime.Global;
            // How long do counter instances in this cateogory live?
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomPerformanceCounterLib.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Globalization;
using System.ComponentModel;
using Microsoft.Win32;

// This class is basically a copy of the internal PerformanceCounterLib class. Red Gate's 
// .NET Reflector was used to extract this code. There is a significant performance issue 
// with PerformanceCounterCategory.Create() in that it takes around 2 seconds per 
// category. The code below takes about 400ms per category.  
//
// The call to PerformanceCounterLib.CategoryExists() requires a cache to be built of all 
// performance counters in the system. This is what takes a while. 
//
// However, at the end of PerformanceCounterLib.RegisterCategory(), that cache is 
// destroyed. This presumably happens because you just added a new category, and rather 
// than add it to the existing cache, the developer decided to throw away the cache and 
// let it get rebuilt on the next call to CategoryExists().  
//
// This is what our code bypasses.
//
// The other major differences are:
// * We don't do any security checks
// * We don't check that this is an NT environment
// * We don't grab the global mutex "netfxperf.1.0"
// * And of course, we don't throw away the cache
//
// All we really do is add a few registry entries, build a temporary perf .h file and .ini 
// file, then launch lodctr.exe to import those. This is, believe it or not, what .Net 
// does under the hood. These are well-defined, well-documented files, and in fact this 
// process is exactly what you would have to do for native perf counters. Except you'd 
// have to do it by hand. 
//
// --kgoodier and paulram, July, 2009.

namespace STF.common.mgmt
{

    public static class XomPerformanceCounterLib
    {
        
        private static bool IsBaseCounter(PerformanceCounterType type)
        {
            if (((type != PerformanceCounterType.AverageBase) &&
              (type != PerformanceCounterType.CounterMultiBase)) &&
              (((int)type != 0x40030403) &&
              (type != PerformanceCounterType.SampleBase)))
            {
                return (type == PerformanceCounterType.SampleBase);
            }
            return true;
        }

        private static void CheckValidCounterLayout(CounterCreationDataCollection counterData)
        {
            Dictionary<String, Object> hashtable = new Dictionary<String, Object>();

            for (int i = 0; i < counterData.Count; i++)
            {
                if ((counterData[i].CounterName == null) || (counterData[i].CounterName.Length == 0))
                {
                    throw new ArgumentException("InvalidCounterName");
                }
                PerformanceCounterType counterType = (PerformanceCounterType)counterData[i].CounterType;
                switch (counterType)
                {
                    case PerformanceCounterType.AverageCount64:
                    case PerformanceCounterType.CounterMultiTimer100Ns:
                    case PerformanceCounterType.CounterMultiTimer100NsInverse:
                    case PerformanceCounterType.CounterMultiTimer:
                    case PerformanceCounterType.CounterMultiTimerInverse:
                    case PerformanceCounterType.RawFraction:
                    case PerformanceCounterType.SampleFraction:
                    case PerformanceCounterType.AverageTimer32:
                        if (counterData.Count <= (i + 1))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        if (!IsBaseCounter(counterData[i + 1].CounterType))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        break;

                    default:
                        if (IsBaseCounter(counterType))
                        {
                            if (i == 0)
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                            counterType = counterData[i - 1].CounterType;
                            if (((
                                (counterType != PerformanceCounterType.AverageCount64) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer100Ns)) &&
                                ((counterType != PerformanceCounterType.CounterMultiTimer100NsInverse) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer))) &&
                                (((counterType != PerformanceCounterType.CounterMultiTimerInverse) &&
                                (counterType != PerformanceCounterType.RawFraction)) &&
                                ((counterType != PerformanceCounterType.SampleFraction) &&
                                (counterType != PerformanceCounterType.AverageTimer32))))
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                        }
                        break;
                }
                if (hashtable.ContainsKey(counterData[i].CounterName))
                {
                    throw new ArgumentException(String.Format("DuplicateCounterName: {0}", counterData[i].CounterName));
                }
                hashtable.Add(counterData[i].CounterName, string.Empty);
                if ((counterData[i].CounterHelp == null) || (counterData[i].CounterHelp.Length == 0))
                {
                    counterData[i].CounterHelp = counterData[i].CounterName;
                }
            }
        }

        private static void CreateRegistryEntry(string categoryName, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData, ref bool iniRegistered)
        {
            RegistryKey key = null;
            RegistryKey key2 = null;
            RegistryKey key3 = null;

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Services", true);
                key2 = key.OpenSubKey(categoryName + @"\Performance", true);
                if (key2 == null)
                {
                    key2 = key.CreateSubKey(categoryName + @"\Performance");
                }
                key2.SetValue("Open", "OpenPerformanceData");
                key2.SetValue("Collect", "CollectPerformanceData");
                key2.SetValue("Close", "ClosePerformanceData");
                key2.SetValue("Library", "netfxperf.dll");
                key2.SetValue("IsMultiInstance", (int)categoryType, RegistryValueKind.DWord);
                key2.SetValue("CategoryOptions", 3, RegistryValueKind.DWord);
                string[] strArray = new string[creationData.Count];
                string[] strArray2 = new string[creationData.Count];
                for (int i = 0; i < creationData.Count; i++)
                {
                    strArray[i] = creationData[i].CounterName;
                    strArray2[i] = ((int)creationData[i].CounterType).ToString(CultureInfo.InvariantCulture);
                }
                key3 = key.OpenSubKey(categoryName + @"\Linkage", true);
                if (key3 == null)
                {
                    key3 = key.CreateSubKey(categoryName + @"\Linkage");
                }
                key3.SetValue("Export", new string[] { categoryName });
                key2.SetValue("Counter Types", strArray2);
                key2.SetValue("Counter Names", strArray);
                if (key2.GetValue("First Counter") != null)
                {
                    iniRegistered = true;
                }
                else
                {
                    iniRegistered = false;
                }
            }
            finally
            {
                if (key2 != null)
                {
                    key2.Close();
                }
                if (key3 != null)
                {
                    key3.Close();
                }
                if (key != null)
                {
                    key.Close();
                }
            }
        }

        private static void CreateIniFile(string IniFilePath, string SymbolFilePath, string categoryName, string categoryHelp, CounterCreationDataCollection creationData, string[] languageIds)
        {
            StreamWriter writer = new StreamWriter(IniFilePath, false, Encoding.Unicode);
            try
            {
                writer.WriteLine("");
                writer.WriteLine("[info]");
                writer.Write("drivername");
                writer.Write("=");
                writer.WriteLine(categoryName);
                writer.Write("symbolfile");
                writer.Write("=");
                writer.WriteLine(Path.GetFileName(SymbolFilePath));
                writer.WriteLine("");
                writer.WriteLine("[languages]");
                foreach (string str in languageIds)
                {
                    writer.Write(str);
                    writer.Write("=");
                    writer.Write("language");
                    writer.WriteLine(str);
                }
                writer.WriteLine("");
                writer.WriteLine("[objects]");
                foreach (string str2 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str2);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                }
                writer.WriteLine("");
                writer.WriteLine("[text]");
                foreach (string str3 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_HELP");
                    writer.Write("=");
                    if ((categoryHelp == null) || (categoryHelp == string.Empty))
                    {
                        writer.WriteLine("HelpNotAvailable");
                    }
                    else
                    {
                        writer.WriteLine(categoryHelp);
                    }
                    int num = 0;
                    foreach (CounterCreationData data in creationData)
                    {
                        num++;
                        writer.WriteLine("");
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_NAME");
                        writer.Write("=");
                        writer.WriteLine(data.CounterName);
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_HELP");
                        writer.Write("=");
                        writer.WriteLine(data.CounterHelp);
                    }
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static void CreateSymbolFile(String SymbolFilePath, CounterCreationDataCollection creationData)
        {
            StreamWriter writer = new StreamWriter(SymbolFilePath);
            try
            {
                writer.Write("#define");
                writer.Write(" ");
                writer.Write("OBJECT_");
                writer.WriteLine("1 0;");
                for (int i = 1; i <= creationData.Count; i++)
                {
                    writer.Write("#define");
                    writer.Write(" ");
                    writer.Write("DEVICE_COUNTER_");
                    writer.Write(i.ToString(CultureInfo.InvariantCulture));
                    writer.Write(" ");
                    writer.Write((i * 2).ToString(CultureInfo.InvariantCulture));
                    writer.WriteLine(";");
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static string[] GetLanguageIds()
        {
            RegistryKey key = null;
            string[] subKeyNames = new string[0];

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib");
                if (key != null)
                {
                    subKeyNames = key.GetSubKeyNames();
                }
            }
            finally
            {
                if (key != null)
                {
                    key.Close();
                }
            }
            return subKeyNames;
        }

        private static void RegisterFiles(string arg0, bool unregister)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.ErrorDialog = false;
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            startInfo.WorkingDirectory = Environment.SystemDirectory;
            if (unregister)
            {
                startInfo.FileName = Environment.SystemDirectory + @"\unlodctr.exe";
            }
            else
            {
                startInfo.FileName = Environment.SystemDirectory + @"\lodctr.exe";
            }
            int error = 0;

            startInfo.Arguments = "\"" + arg0 + "\"";
            Process process = Process.Start(startInfo);
            process.WaitForExit();
            error = process.ExitCode;


            if (unregister && (error == 2))
            {
                error = 0;
            }
            if (error != 0)
            {
                throw new Win32Exception(error);
            }
        }

        public static void CreateCategory(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData)
        {
            String tempFileName = Guid.NewGuid().ToString();
            String iniFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".ini");
            String symbolFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".h");

            CheckValidCounterLayout(creationData);
            try
            {
                bool iniRegistered = false;
                CreateRegistryEntry(categoryName, categoryType, creationData, ref iniRegistered);
                if (!iniRegistered)
                {
                    string[] languageIds = GetLanguageIds();
                    CreateIniFile(iniFilePath, symbolFilePath, categoryName, categoryHelp, creationData, languageIds);
                    CreateSymbolFile(symbolFilePath, creationData);
                    RegisterFiles(iniFilePath, false);
                }
            }
            finally
            {
                File.Delete(iniFilePath);
                File.Delete(symbolFilePath);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XomRequestContext.cs ===
/*==========================================================================
 *
 *  XomRequestContext.cs
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.Collections;
using System.Diagnostics;

using STF.common.service;

namespace STF.common.mgmt
{
    public interface IXomRequestPerfCounters
    {
        PerformanceCounter ExecPerSecond         { get; }
        PerformanceCounter ExecTotal             { get; }
        PerformanceCounter ExecFailedPerSecond   { get; }
        PerformanceCounter ExecFailedTotal       { get; }
        PerformanceCounter ExecTime              { get; }
        PerformanceCounter ExecTimeBase          { get; }
    }

    public class XomRequestPerfCounters
    {
        public static void AddRequestPerfCounters(string api, IXomRequestPerfCounters rpc)
        {
            _requestCountersTable.Add(api, rpc);
        }

        public static IXomRequestPerfCounters GetCounters(string api)
        {
            return (IXomRequestPerfCounters) _requestCountersTable[api];
        }

        private static Hashtable _requestCountersTable = new Hashtable();
    }

    public class XomRequestContext : IDisposable
    {
        public XomRequestContext(string apiName): this(apiName, null)
        {
        }

        public XomRequestContext(string apiName, XomLogArea traceArea)
        {
            _apiName = apiName;
            _hr = HResult.E_FAIL;
            _traceArea = traceArea;

            if ( _traceArea != null )
            {
                string msg = _apiName + ": entering...";
                _traceArea.Log(new XomLogTargetContext(Floken.Current), XomLogLevel.Low, 0, null, null, msg);
            }

            _timeElapsed = new XomRequestTimeElapsed();
        }

        public virtual void Close()
        {
            Dispose();
        }

        public virtual void Dispose()
        {
            if ( _traceArea != null )
            {
                string msg = _apiName + ": hr = " + _hr + ": completed in " + _timeElapsed.MillisecondsElapsed + " ms.";
                _traceArea.Log(new XomLogTargetContext(Floken.Current), XomLogLevel.Low, 0, null, null, msg);
            }
        }

        public string ApiName
        {
            get { return _apiName; }
        }

        public HResult HResult
        {
            get { return _hr; }
            set { _hr = value; }
        }

        protected string _apiName;
        protected HResult _hr;
        protected XomRequestTimeElapsed _timeElapsed = null;
        protected XomLogArea _traceArea = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xomperfctrsinstall.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Text;
using System.Security.Cryptography;
using System.Threading;

using STF.common.service;

namespace STF.common.mgmt
{
    using CounterCategoryDictionary = Dictionary<string, XomPerformanceCounterAttr>;

    // Installs the performance counters in the machine. Run InstallUtil.exe
    // against this assembly to get the counters installed before running the
    // service.
    
    [ComVisible(false)]
    [RunInstaller(true)]
    public class XomPerformanceCounterInstall : Installer
    {
        private const string XboxLiveRegistryKey = @"SOFTWARE\Microsoft\XboxLive";
        private const string CounterHashRegistryKeyName = "PerfCountersInstalled";
        private const string CounterHashRegistryKey = XboxLiveRegistryKey + @"\" + CounterHashRegistryKeyName;

        // Verifies that the type meets the inheritence and attribute requirements
        // of a XomPerformanceCounterCategory

        public static bool IsValidPerformanceCounterCategory(Type t)
        {
            return 
                t.IsSubclassOf(typeof(XomPerformanceCounterCategory)) &&
                t != typeof(XomPerformanceCounterCategory) &&
                Attribute.IsDefined(t, typeof(XomPerformanceCounterCategoryAttr));
        }

        // Non-static implementation can be overridden!
        public virtual bool IsInstallablePerformanceCounterCategory(Type t)
        {
            return XomPerformanceCounterInstall.IsValidPerformanceCounterCategory(t);
        }

        // Retrieves the performance counter category attribute from the type.
        // It is assumed that the type is a valid performance counter category
        // type.

        public static XomPerformanceCounterCategoryAttr GetCategoryAttribute(Type t) {
            return t.GetCustomAttributes(typeof(XomPerformanceCounterCategoryAttr), false)[0] 
               as XomPerformanceCounterCategoryAttr;
        }
        
        // Called by the installer on install. Builds the counters for all the
        // classes in the local assembly.
    
        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);

            // Log an event to setup the EventSource for this component. We do this at 
            //  install time since some of the users executing FD code may not have
            //  appropriate permissions to create EventSources. 
            // We don't want to init proper logging here because that is way too 
            //  heavyweight requiring communication with configdb, etc.

            EventLog.WriteEntry(
                STF.common.config.Config.ComponentName, 
                "Beginning Install of perfctrs for " + STF.common.config.Config.ComponentName, 
                EventLogEntryType.Information,
                (int) XEvent.MessageFromId(XEvent.Id.COMMON_INFO_47),
                0,
                null);

            LogMessage("Beginning Install of perfctrs for " + CounterRegistryName);
    
            // Enumerate through all the XomPerformanceCounterCategory derived 
            // classes in the local assembly (except for XomPerformanceCounterCategory
            // itself.

            Type[] allTypes = Assembly.GetAssembly(this.GetType()).GetTypes();

            // Go through all counters and get a hash of the list
            string countersHash = GetHashOnCounters(allTypes);

            // Check if counters hash exists in registry, if it is, we can skip the counters creation
            if (CheckCounterHashExistsInRegistry(countersHash))
            {
                LogMessage("Skipping counter installation, found matching counter hash token in registry for " + CounterRegistryName);
            }
            else
            {                
                foreach( Type t in allTypes )
                {
                    if(IsInstallablePerformanceCounterCategory(t)) 
                        InstallCategory(t);
                }

                // Drop counters hash token in registry after a successful install of counters.
                WriteCounterHashToRegistry(countersHash);
            }
        }
        
        // Called by the installer on uninstall. Removes all counters associated
        // to the classes of the local assembly.
    
        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);
            UninstallAllCategories(); 
        }

        // Called by the installer when this, or another, Install() fails. Try to remove 
        // all perf counters in this assembly.

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback(savedState);

            // Try to delete everything, even if we didn't actually install it. We could 
            // store this info in savedState, but this is quick and simple.
            UninstallAllCategories(); 
        }
    
        // Uninstall as many catgories as possible

        protected void UninstallAllCategories()
        {
            // To be safe, remove the registry key hash before attempting to uninstall
            DeleteCounterHashFromRegistry();

            // Enumerate through all the XomPerformanceCounterCategory derived classes in 
            // the local assembly (except for XomPerformanceCounterCategory
            // itself.                       

            Type[] allTypes = Assembly.GetAssembly(this.GetType()).GetTypes();

            int numFail = 0;
            int numTotal = 0;
            Exception lastException = null;
            foreach( Type t in allTypes )
            {
                if(IsInstallablePerformanceCounterCategory(t))
                {
                    try
                    {
                        numTotal++;
                        UninstallCategory(t);
                    }
                    catch (Exception e)
                    {
                        lastException = e;
                        numFail++;
                    }
                }
            }

            if (numFail > 0)
            {
                throw new Exception("Failed to uninstall " + numFail + " performance counter categories out of " + numTotal, lastException);
            }
        }

        // Uninstall logic used by the InstallCategory and UninstallCategory methods
        
        protected void UninstallCategoryHelper(XomPerformanceCounterCategoryAttr attr) {
            try {
                PerformanceCounterCategory.Delete(attr.CtgName);
                LogMessage("\t\tsuccessfully removed category.");
            }
            catch (InvalidOperationException e) { // category does not exist
                LogMessage("\t\tsuccessfully removed category. [" + e.Message + "]");
            }
            catch (Exception e) {
                LogMessage("\t\tfailed to remove category\n" + e.ToString());
                throw;
            }
        }

        // Given a category name, this function will return the performance counter category
        // associated with it, if that category does not exist null will be returned instead.

        protected PerformanceCounterCategory GetCategoryOrNull(string category) 
        {
            const int LoopCount = 15;

            for (int i = 0; i < LoopCount; ++i)
            {
                try
                {
                    PerformanceCounterCategory pcc = null;
                    string probe;

                    pcc = new PerformanceCounterCategory(category);
                    probe = pcc.CategoryHelp; //will raise exception if the category does not exist.

                    return pcc;
                }
                catch (FormatException)
                {
                    // This is the ugliest most hacktastic thing in the history of Xbox LIVE.
                    // Windows perf counters are stored in two locations - in a .dat file and in a blob in the registry
                    // There is a known race condition in the perf counter system that allows a reader to access the registry component of the perf counter system
                    // while NT is synchronizing the .dat file and the registry.  If the two aren't fully synchronized, the registry may appear corrupt.
                    // This loop will not solve registry corruption, which can only be resolved with lodctr /R, but will mitigate the timing issue
                    LogMessage(String.Format("Registry entry for performance counter {0} appears corrupted.  Retry {1} of {2} starting in 100ms", category, i + 1, LoopCount));
                    Thread.Sleep(100);
                    continue;
                }
                catch (InvalidOperationException)
                { // category does not exist
                    LogMessage("\t\tcategory is not present");
                    return null;
                }
                catch (Exception e)
                {
                    LogMessage("\t\tfailed to load category : " + e.ToString());
                    throw;
                }
            }

            throw new Exception(String.Format("Unable to load performance counter '{0}' - the registry is currently corrupted.  To resolve this, please run lodctr /R and rerun Octopus.", category));
        }
        
        // Uninstall the performance counter category from the system.  In the interest
        // of performance it will be assumed that the performance counters exist.
        
        protected void UninstallCategory(Type categoryType) {
            XomPerformanceCounterCategoryAttr attr;
            Stopwatch w = new Stopwatch();

            w.Start();
            attr = GetCategoryAttribute(categoryType);

            LogMessage("\tUninstall Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);

            if (!attr.IsShared)
                UninstallCategoryHelper(attr);
            else
                LogMessage("\t\tskipping removal of shared category.");

            w.Stop();
            
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds.ToString() + " ms.");
        }

        
        
        // Install the performance counter category to the system.  It is assumed that
        // the performance counters are already installed.  If that is false, or the
        // existing performance counters are wrong they will be re-installed.

        protected void InstallCategory(Type categoryType) {
            XomPerformanceCounterCategoryAttr attr;
            CounterCreationDataCollection     creation;
            PerformanceCounterCategory        category = null;
            CounterCategoryDictionary         newCounterSet;
            Stopwatch                         w = new Stopwatch();

            w.Start();
            
            attr = GetCategoryAttribute(categoryType);
            
            LogMessage("\t Installing Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);
            
            creation = new CounterCreationDataCollection();
            newCounterSet = new CounterCategoryDictionary();

            //Load New Counters for the category 
            LogMessage("\t\tReflecting counter configuration");
            LoadCountersInCategory(categoryType, out creation, out newCounterSet);

            LogMessage("\t\tFetch existing counter group");
            category = GetCategoryOrNull(attr.CtgName);
            LogMessage("\t\tDone");

            if (null != category) { // compare the existing
                if (IsCategoryRemovalRequired(category, newCounterSet)) {
                    category = null;
                    LogMessage("\t\tRemoving the group");
                    UninstallCategoryHelper(attr);
                }
            }

            if (null == category) { // create new categories
                try {
                    // perf ctr lib may falsely report that the category is not present
                    PerformanceCounterCategory.Delete(attr.CtgName);                    
                }
                catch (InvalidOperationException) { /* the category really isn't present */ }
                catch (Exception e) {
                    LogMessage("\t\twarning: error encountered deleting category, continuing : " + e.ToString());
                }

                try {
                    LogMessage("\t\tCreating category");
                    XomPerformanceCounterLib.CreateCategory(
                        attr.CtgName,
                        attr.CtgHelp,
                        PerformanceCounterCategoryType.MultiInstance,
                        creation);

                    LogMessage("\t\tsuccessfully created category.");
                }
                catch (Exception e) { // failed to create category
                    LogMessage("\t\tfailed to created category : " + e.ToString());
                    throw;
                }
            }

            // Verify perf category and counters. Throws exception if not valid.

            LogMessage("\t\tVerifying all counters in category");
            try
            {
                VerifyCategory(categoryType);
            }
            catch (Exception e) 
            {
                LogMessage("\t\tError: Failed to verify performance counters in " + attr.CtgName);
                LogMessage("\t\t" + e.ToString());
                throw;
            }

            w.Stop();
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds.ToString() + " ms.");


        }

        // Uses .Net libraries to open up each counter in the category. Should ensure 
        // everything exists.

        protected virtual void VerifyCategory(Type categoryType)
        {
            if (!IsInstallablePerformanceCounterCategory(categoryType)) 
            {
                LogMessage("\t\tNot a valid XomPerformanceCounterCategory type: " + categoryType.ToString());
                throw new InvalidOperationException("Not a valid category type");
            }

            XomPerformanceCounterCategory o = (XomPerformanceCounterCategory)Activator.CreateInstance(categoryType);

            // The XomPerformanceCounterCategory constructor initializes perf 
            // counters, which reads a value for each one. No exceptions == good to go

        }

        // Examines the old and new counter set for a specific category and reports
        // the differences between them

        protected void CalculateCategoryDifferences(
            PerformanceCounterCategory category,
            Dictionary<string, XomPerformanceCounterAttr> newCounters,
            List<string> missingSet /* counters in new set but not old set */,
            List<string> differenceSet /* counters in both sets but are different */,
            List<string> extraSet /* counters in old set but not new set */)
        {
            PerformanceCounter[] counters;
            List<string>         allCounters;
            string[]             instances;

            instances = category.GetInstanceNames();
            
            counters = (instances.Length > 0) ? 
                category.GetCounters(instances[0]) : //get the name instanced
                category.GetCounters(); //or not

            allCounters = new List<string>(newCounters.Keys);

            for (int c=0; c<counters.Length; c++) {
                string name = counters[c].CounterName;
                
                if (!newCounters.ContainsKey(name))
                    extraSet.Add(name);
                else {
                    XomPerformanceCounterAttr oldAttr, newAttr;

                    oldAttr = new XomPerformanceCounterAttr(name, counters[c].CounterHelp, counters[c].CounterType);
                    newAttr = newCounters[name];
                    
                    if (! newAttr.Equals(oldAttr) )
                        differenceSet.Add(name);
                    else
                        allCounters.Remove(name);
                }
            }

            missingSet.AddRange(allCounters);
        }
        
        // This function indicates whether not the perf counter installer should uninstall
        // an existing category.
        
        protected bool IsCategoryRemovalRequired(
            PerformanceCounterCategory category,
            Dictionary<string, XomPerformanceCounterAttr> newCounterSet)
        {
            List<string> missingSet = new List<string>();
            List<string> differenceSet = new List<string>();
            List<string> extraSet = new List<string>();

            CalculateCategoryDifferences(category, newCounterSet, missingSet, differenceSet, extraSet);
            
            if (missingSet.Count == 0 && differenceSet.Count == 0 && extraSet.Count == 0) {
               LogMessage("\t\tcategory matches existing definition, no removal neccessary.");
               return false;
            }
            else {
               LogMessage("\t\tcategory does not match existing definition.");

               if (missingSet.Count > 0) {
                  LogMessage("\t\told category definition missing the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", missingSet.ToArray()));
               }

               if (differenceSet.Count > 0) {
                  LogMessage("\t\told and new category defintion differ for the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
               }

               if (extraSet.Count > 0) {
                  LogMessage("\t\tnew category definition missing the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
               }

               return true;
            }
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XomPerformanceCounterAttr> newCounterSet)
        {
            return LoadCountersInCategory(categoryType, out counterCollection, out newCounterSet, true);
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XomPerformanceCounterAttr> newCounterSet, bool logMessages)
        {
            int count = 0;
            counterCollection = new CounterCreationDataCollection();
            newCounterSet = new Dictionary<string, XomPerformanceCounterAttr>();

            FieldInfo[] newFields = categoryType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

            
            foreach (FieldInfo newField in newFields)
            {
                if (newField.FieldType == typeof(PerformanceCounter))
                {
                    // Get the perf counter's attributes.                    
                    XomPerformanceCounterAttr[] xomCounterAttributes = ( XomPerformanceCounterAttr[]) newField.GetCustomAttributes(typeof(XomPerformanceCounterAttr), false);
                    if (xomCounterAttributes.Length <= 0)
                    {
                        string message = String.Format("Failed to initialize the performance counter. The counter does not have a valid attribute. Counter name = " + newField.Name);

                        //Xom.NtEvent(XEvent.Id.COMMON_CONFIG_265,message);

                        //The field MUST have a XomPerformanceCounterAttr attribute to it
                        throw (new System.ArgumentException(message));
                    }

                    XomPerformanceCounterAttr newCounterAttributes = xomCounterAttributes[0] as XomPerformanceCounterAttr;

                    if (logMessages)
                    {
                        LogMessage("\t\tCounter {0}:", count++);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrName);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrHelp);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrType);
                    }

                    newCounterSet.Add(newCounterAttributes._ctrName, newCounterAttributes);
                    counterCollection.Add(new CounterCreationData(newCounterAttributes._ctrName, newCounterAttributes._ctrHelp, newCounterAttributes._ctrType));
                }

            }
            return count;
        }

        private string GetHashOnCounters(Type[] allTypes)
        {
            StringBuilder countersString = new StringBuilder();

            // Go through all counters, combine them up into a string list.
            foreach (Type t in allTypes)
            {
                if (IsInstallablePerformanceCounterCategory(t))
                {
                    string categoryName = GetCategoryAttribute(t).CtgName;
                                        
                    CounterCreationDataCollection creation = new CounterCreationDataCollection();
                    CounterCategoryDictionary newCounterSet = new CounterCategoryDictionary();
                                        
                    LoadCountersInCategory(t, out creation, out newCounterSet, false /* don't log messages */);

                    foreach (string counterName in newCounterSet.Keys)
                    {
                        countersString.AppendLine(categoryName + "-" + counterName);
                    }
                }
            }

            // Get the MD5 hash from the counter string.
            byte[] hashData = MD5.Create().ComputeHash(Encoding.Default.GetBytes(countersString.ToString()));

            StringBuilder counterHash = new StringBuilder();
            foreach (byte b in hashData)
            {
                counterHash.Append(b.ToString("X2"));
            }

            return counterHash.ToString();
        }

        private bool CheckCounterHashExistsInRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                string registryValue = (string)regKey.GetValue(CounterRegistryName);

                return registryValue == null ? false : registryValue.Equals(countersHash);
            }
        }

        private void WriteCounterHashToRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                regKey.SetValue(CounterRegistryName, countersHash);
            }

            LogMessage("Counter hash written to registry for " + CounterRegistryName);
        }

        private void DeleteCounterHashFromRegistry()
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                regKey.DeleteValue(CounterRegistryName);
            }

            LogMessage("Counter hash deleted from registry for " + CounterRegistryName);
        }

        private string CounterRegistryName
        {
            get
            {
                return this.GetType().AssemblyQualifiedName;
            }
        }

        public void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                Replace("\n", "\n                             ");

            Context.LogMessage(stampedMessage);
        }

        public void LogMessage(String message, params Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(formattedMessage);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XRLTrace.cs ===
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.xrltrace)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XRLException.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace STF.common.service
{
    public interface ExceptionWithHResult {
        HResult HResult { get; set; }
    }

    public interface ExceptionWithoutEvent {
    }

    public interface ExceptionWithEvent {
        XEvent.Id EventId { get; set; }
    }
    
    /// <summary>
    /// This interface identifies retryable errors
    /// </summary>
    public interface IRetryableException
    {
        bool IsRetryable
        {
            get;
        }
    }


    [ComVisible(false)]
    public class XRLExceptionWithoutEvent : Exception, ExceptionWithHResult, ExceptionWithoutEvent,IRetryableException {

       bool _retryable=false;
       
        public XRLExceptionWithoutEvent(HResult hr, Exception innerException, string format, params object[] args)
            : base(String.Format(format, args), innerException)
        {
            HResult = hr;
        }

        public XRLExceptionWithoutEvent(HResult hr, string format, params object[] args)
            : base(String.Format(format, args))
        {
            HResult = hr;
        }
         public XRLExceptionWithoutEvent(HResult hr, Exception innerException, string format, bool isRetryable,params object[] args)
            : base(String.Format(format, args), innerException)
        {
            HResult = hr;
            _retryable=isRetryable;
        }

        public XRLExceptionWithoutEvent(HResult hr, string format, bool isRetryable,params object[] args)
            : base(String.Format(format, args))
        {
            HResult = hr;
            _retryable=isRetryable;
        }

        new public HResult HResult
        {
            get { return (HResult) ((uint) base.HResult); }
            set { base.HResult = (int) ((uint) value); }
        }
        
       public bool IsRetryable
        {
            get {return _retryable;}
            
        }
    }

    [ComVisible(false)]
    public class ExceptionWithEventId : Exception, ExceptionWithEvent,IRetryableException
    {
        XEvent.Id _EventId = XEvent.Id.MC_APPLICATION_ERROR_1;
        
		bool _retryable=false;
        
        public ExceptionWithEventId(XEvent.Id EventId, string message) : base(message)
        {
            _EventId = EventId;
        }


        public ExceptionWithEventId(XEvent.Id EventId, string message, Exception innerException) : base(message, innerException)
        {
            _EventId = EventId;
        }
        
        public ExceptionWithEventId(XEvent.Id EventId, string message, bool isRetryable) : base(message)
        {
            _EventId = EventId;
            _retryable=isRetryable;
        }

        public ExceptionWithEventId(XEvent.Id EventId, string message,bool isRetryable, Exception innerException) : base(message, innerException)
        {
            _EventId = EventId;
            _retryable=isRetryable;
        }

        public XEvent.Id EventId
        {
            get { return _EventId; }
            set { _EventId = value; }
        }

		public bool IsRetryable
        {
            get {return _retryable;}
            
        }
        
        public void AppendInfo(string str)
        {
            _info.Append(str + "\n");
        }

        public override string ToString()
        {
            return base.ToString() + "\nInfo:\n" + _info;
        }

        protected StringBuilder _info = new StringBuilder();
    }

    [ComVisible(false)]
    public class XRLException : ExceptionWithEventId, ExceptionWithHResult,IRetryableException
    {
        
        public XRLException(HResult hr, XEvent.Id EventId, string message) : base(EventId, message)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string message, Exception innerException) : base(EventId, message, innerException)
        {
            HResult = hr;
        }


        public XRLException(HResult hr, XEvent.Id EventId, string format, params object[] args)
            : this(hr, EventId, String.Format(format, args))
        {
        }

        public XRLException(HResult hr, XEvent.Id EventId, Exception innerException, string format, params object[] args)
            : this(hr, EventId, String.Format(format, args), innerException)
        {
        }

		public XRLException(HResult hr, XEvent.Id EventId,bool isRetryable,string message) : base(EventId,message,isRetryable)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string message,bool isRetryable,Exception innerException) : base(EventId, message, isRetryable,innerException)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string format,bool isRetryable, params object[] args)
            : this(hr, EventId, String.Format(format, isRetryable,args))
        {
        }

        public XRLException(HResult hr, XEvent.Id EventId, Exception innerException, string format,bool isRetryable, params object[] args)
            : this(hr, EventId, String.Format(format, args), isRetryable,innerException)
        {

        }

        new public HResult HResult
        {
            get { return (HResult)((uint) base.HResult); }
            set { base.HResult = (int)((uint) value); }
        }

        public static HResult ToHResult(Exception e, HResult hr)
        {
            if (e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult) e).HResult;
            }

            return hr;
        }

        public static HResult DeepToHResult(Exception e, HResult hr)
        {
            if (e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult)e).HResult;
            }
            else
            {
                HResult rawHr = (uint)Marshal.GetHRForException(e);
                if (rawHr.IsFailure())
                {
                    hr = rawHr;
                }
            }

            return hr;
        }

        public static XEvent.Id ToEventId(Exception e, XEvent.Id id)
        {
            if (e is ExceptionWithEventId)
            {
                id = ((ExceptionWithEventId)e).EventId;
            }
            return id;
        }
    }

    //Here is an exception that we would only use to communicate a peek char returning no value
    //This exception ususally would be caught and ignored
    public class PeekCharEndOfStreamException : Exception
    {
        public PeekCharEndOfStreamException() : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XonBdkHResult.cs ===
//
// XonBdkErrorAutoGen.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is an auto-generated file. Please don't modify directly.
//
// This file defines constants for all of the BDK errors returned by SCS APIs and
// indicates whether the error is retryable and includes the supplied description.
//
// It is generated from the BdkError.xml file contained in public\ext\xonline-ext\SCS\$(SCS_SDK)\inc.
//

using System;

namespace STF.common.service
{

    public partial struct HResult
    {
        // Null input parameter passed to a "ban" API.
        public const uint XONLINE_E_BILLING_BAN_NULL_INPUT_PARAMETER = 0x80167594;

        // Already banned.
        public const uint XONLINE_E_BILLING_ALREADY_BANNED = 0x80167599;

        // Not banned.
        public const uint XONLINE_E_BILLING_NOT_BANNED = 0x8016759E;

        // This account is banned.
        public const uint XONLINE_E_BILLING_BANNEDPERSON = 0x801675BC;

        // Country/currency/payment instrument type mismatch.
        public const uint XONLINE_E_BILLING_COUNTRY_CURRENCY_PI_MISMATCH = 0x801675C1;

        // Invalid payment instrument type.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x801675C8;

        // Invalid credit card type.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_TYPE = 0x801675CB;

        // Decryption failed. Verify that data is encrypted correctly.
        public const uint XONLINE_E_BILLING_DECRYPTION_FAILURE = 0x801675D0;

        // Payment instrument is banned.
        public const uint XONLINE_E_BILLING_BANNED_PAYMENT_INSTRUMENT = 0x801675C6;

        // Direct debit account validation failed.
        public const uint XONLINE_E_BILLING_INVALID_DD_ACCOUNT = 0x801675E4;

        // Concatenated direct debit account number exceeds 24 characters.
        public const uint XONLINE_E_BILLING_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x801675E9;

        // Invalid credit card number.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER = 0x80167530;

        // Credit card has already expired.
        public const uint XONLINE_E_BILLING_CREDIT_CARD_EXPIRED = 0x80167531;

        // Address verification failed.
        public const uint XONLINE_E_BILLING_AVS_FAILED = 0x8016760C;

        // Address verification through AVS did not provide a result.
        public const uint XONLINE_E_BILLING_NO_AVS_RESULT = 0x8016760D;

        // Payment Instrument authorization failed.
        public const uint XONLINE_E_BILLING_AUTHORIZATION_FAILED = 0x80167611;

        // Unable to connect to payment provider.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x8016761B;

        // Invalid country code.
        public const uint XONLINE_E_BILLING_DD_INVALID_COUNTRY = 0x8016762F;

        // Invalid account format.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_FORMAT = 0x80167634;

        // Invalid bank code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_FORMAT = 0x80167639;

        // Invalid branch code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_FORMAT = 0x8016763E;

        // Invalid check digit format.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_FORMAT = 0x80167643;

        // Account missing.
        public const uint XONLINE_E_BILLING_DD_ACCOUNT_MISSING = 0x80167648;

        // Bank code missing.
        public const uint XONLINE_E_BILLING_DD_BANKCODE_MISSING = 0x8016764D;

        // Branch code missing.
        public const uint XONLINE_E_BILLING_DD_BRANCHCODE_MISSING = 0x80167652;

        // Check digit missing.
        public const uint XONLINE_E_BILLING_DD_CHECKDIGIT_MISSING = 0x80167657;

        // Some fields have errors.
        public const uint XONLINE_E_BILLING_DD_ERROR_IN_FIELDS = 0x8016765C;

        // Invalid account code.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_VALUE = 0x80167661;

        // Invalid bank code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_VALUE = 0x80167666;

        // Invalid branch code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_VALUE = 0x8016766B;

        // Invalid check digit.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_VALUE = 0x80167670;

        // Account holder name not specified or it exceeds 35 characters.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x8016767A;

        // Soap call to provider failed.
        public const uint XONLINE_E_BILLING_DD_UNKNOWN_PROVIDER_FAILURE = 0x8016771F;

        // Payment provider connection timed out.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x8016767F;

        // Transaction declined by payment provider.
        public const uint XONLINE_E_BILLING_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 0x80167680;

        // Payment provider error.
        public const uint XONLINE_E_BILLING_INVALID_INITIATE_TRANSACTION_RESULT = 0x80167681;

        // The wholesale partner specified is invalid.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALE_PARTNER = 0x80167684;

        // PI Not Supported in this version
        public const uint XONLINE_E_BILLING_PI_NOT_SUPPORTED = 0x80167693;

        // A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.
        public const uint XONLINE_E_BILLING_UPS_NOT_UPDATED = 0x8016769D;

        // This branch will not support Direct Debit transactions.
        public const uint XONLINE_E_BILLING_DD_UNSUPPORTED = 0x801676A2;

        // Internal error, Return from MPF is not in XML format.
        public const uint XONLINE_E_BILLING_DD_MPF_NON_XML_RESPONSE = 0x801676A7;

        // Internal error, Return XML from MPF is not in correct format.
        public const uint XONLINE_E_BILLING_DD_MPF_INCORRECT_XML_FORMAT = 0x801676AC;

        // Global Collect error, Return from Global Collect is not in XML format.
        public const uint XONLINE_E_BILLING_DD_GC_NON_XML_RESPONSE = 0x801676B1;

        // Global Collect error, Return XML from Global Collect is not in correct format.
        public const uint XONLINE_E_BILLING_DD_GC_INCORRECT_XML_FORMAT = 0x801676B6;

        // Global collect failed to process this request, returned NOT OK result.
        public const uint XONLINE_E_BILLING_DD_GC_RETURNED_NOK_RESULT = 0x801676BB;

        // Direct Debit account Check performed by Global Collect is not complete for this account.
        public const uint XONLINE_E_BILLING_DD_GC_CHECK_INCOMPLETE = 0x801676C0;

        // Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.
        public const uint XONLINE_E_BILLING_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x801676C5;

        // Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.
        public const uint XONLINE_E_BILLING_DD_GC_XML_INVALID_CHECK_RESULT = 0x801676CA;

        // Global collect returned non null Reformatted Bank Code though the input Bank code was blank.
        public const uint XONLINE_E_BILLING_DD_GC_INVALID_RFBANKCODE = 0x801676CF;

        // Invalid payment instrument details.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x801676D9;

        // Invalid ban reason code.
        public const uint XONLINE_E_BILLING_INVALID_BAN_REASON_CODE = 0x801676DE;

        // Invalid encrypted CVM code.
        public const uint XONLINE_E_BILLING_INVALID_CVM_CODE = 0x801676E3;

        // Unexpected CVM response code.
        public const uint XONLINE_E_BILLING_UNEXPECTED_CVM_RESPONSE_CODE = 0x801676E8;

        // CVM check failed.
        public const uint XONLINE_E_BILLING_CVM_FAILED = 0x801676ED;

        // Immediate settlement failed
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLEMENT_FAILURE = 0x801676EE;

        // Frequency check failed.
        public const uint XONLINE_E_BILLING_FREQUENCY_CHECK_FAILED = 0x801676F2;

        // Invalid merchant index.
        public const uint XONLINE_E_BILLING_DD_INVALID_MERCHANT_INDEX = 0x801676F7;

        // Duplicate merchant reference.
        public const uint XONLINE_E_BILLING_DD_DUPLICATE_MRN = 0x801676FC;

        // Account validation failed.
        public const uint XONLINE_E_BILLING_DD_UNKNOWN_VALIDATION_FAILURE = 0x80167701;

        // Bank account type may not be specified for this country.
        public const uint XONLINE_E_BILLING_ROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 0x80167706;

        // Bank account type is required for this country.
        public const uint XONLINE_E_BILLING_ROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 0x8016770B;

        // Risk check failed.
        public const uint XONLINE_E_BILLING_DD_RISK_DECLINE = 0x80167715;

        // Unable to validate the tax ID.
        public const uint XONLINE_E_BILLING_UNABLE_TO_VALIDATE_TAX_ID = 0x80167724;

        // Number of updates allowed in a period has exceeded the maximum limit.
        public const uint XONLINE_E_BILLING_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 0x80167729;

        // External vendor error.
        public const uint XONLINE_E_BILLING_EXTERNAL_VENDOR_ERROR = 0x8016772E;

        // Object is already in the specified state.
        public const uint XONLINE_E_BILLING_ALREADY_IN_SPECIFIED_STATE = 0x80169C41;

        // Required search criteria field missing. Either a phone number or both first name and last name is required.
        public const uint XONLINE_E_BILLING_MISSING_SEARCH_CRITERIA = 0x80169C44;

        // Required field missing.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING = 0x80169C45;

        // The account has subscriptions.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS = 0x80169C46;

        // Unexpected field
        public const uint XONLINE_E_BILLING_UNEXPECTED_FIELD = 0x80169C47;

        // Invalid account source.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_SOUCE = 0x80169C4D;

        // Creation date/time cannot be later than current date/time.
        public const uint XONLINE_E_BILLING_INVALID_CREATION_DATE = 0x80169C4E;

        // No more tax exemptions are allowed for this account.
        public const uint XONLINE_E_BILLING_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80169C55;

        // Generating next ID.
        public const uint XONLINE_E_BILLING_GENERATE_NEXT_ID = 0x80169C59;

        // State invalid for the country.
        public const uint XONLINE_E_BILLING_INVALID_STATE_FOR_COUNTRY = 0x80169C5F;

        // Country for address provided does not match existing country for account.
        public const uint XONLINE_E_BILLING_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80169C61;

        // The offering requested is not available in the country of this account.
        public const uint XONLINE_E_BILLING_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80169C62;

        // Invalid account.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_ID = 0x80169CC2;

        // Invalid account status.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80169CC7;

        // Invalid phone type.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_TYPE = 0x80169CD6;

        // Invalid offering.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_ID = 0x80169CE5;

        // The combination of data passed to PurchaseOffering is invalid for the scenario.
        public const uint XONLINE_E_BILLING_INVALID_PURCHASE_INPUT_DATA = 0x80169CE6;

        // UPS profile is missing either FirstName, LastName, Country or PMN
        public const uint XONLINE_E_BILLING_PUID_MISSING_ATTRIBUTE = 0x80169CE7;

        // Invalid country code.
        public const uint XONLINE_E_BILLING_INVALID_COUNTRY_CODE = 0x80169CEA;

        // Invalid address ID.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESS_ID = 0x80169CEF;

        // Invalid payment instrument ID.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID = 0x80169CF9;

        // Cannot exceed max ownership for the payment instrument.
        public const uint XONLINE_E_BILLING_PI_EXECEED_MAX_OWNER_SHIP = 0x80169D03;

        // Subscription is already cancelled.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_ALREADY_CANCELED = 0x80169D08;

        // A delayed expire request is already pending and should not be requested again.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_ALREADY_PENDING = 0x80169D0A;

        // A delayed expire is not pending and cannot be undone.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_NOT_PENDING = 0x80169D0B;

        // A delayed expire is not support unless the subscription is active with no term commits.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_NOT_SUPPORTED = 0x80169D0C;

        // The value specified for the cancel option/date should be DELAYED_EXPIRE, UNDO_DELAYED_EXPIRE, IMMEDIATE_EXPIRE or IMMEDIATE_CANCEL.
        public const uint XONLINE_E_BILLING_INVALID_CANCEL_DATE = 0x80169D09;

        // Invalid subscription ID.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ID = 0x80169D0D;

        // Invalid period.
        public const uint XONLINE_E_BILLING_INVALID_PERIOD_TO_PROCESS = 0x80169D2B;

        // Invalid subscription status or invalid operation for the status.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS = 0x80169D3A;

        // Account is inactive.
        public const uint XONLINE_E_BILLING_NON_ACTIVE_ACCOUNT = 0x80169D94;

        // VATIDs do not have an expiration date.
        public const uint XONLINE_E_BILLING_VATID_DOESNOTHAVEEXPDATE = 0x80169D95;

        // Expiration date was not specified.
        public const uint XONLINE_E_BILLING_TAXID_EXPDATE = 0x80169D96;

        // Invalid tax exemption type.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_TYPE = 0x80169D97;

        // Invalid Tax Exempt Billable Account Id specified.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 0x80169D98;

        // No active subscription for adding a service instance.
        public const uint XONLINE_E_BILLING_NO_ACTIVE_SUBSCRIPTION = 0x80169D99;

        // Invalid service instance for adding a new user.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_INSTANCE = 0x80169D9E;

        // Failed to add a new user to a service instance.
        public const uint XONLINE_E_BILLING_ADD_USER_TO_SERVICE_INSTANCE = 0x80169DA3;

        // Status change not allowed.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLEACCTSTATUS = 0x80169DA8;

        // No service instances available for the billable account.
        public const uint XONLINE_E_BILLING_SERVICE_INSTANCES_NONE = 0x80169DBC;

        // Account is already closed.
        public const uint XONLINE_E_BILLING_ACCOUNT_CLOSED = 0x80169DD1;

        // Period is already past.
        public const uint XONLINE_E_BILLING_BILLINGPERIOD_PAST = 0x80169DD6;

        // Invalid adjustment GUID.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENTGUID = 0x80169DD7;

        // Adjustment not applicable to the specified period.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSMENT_FOR_PERIOD = 0x80169DD8;

        // Adjustment amount is too large.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOBIG = 0x80169DD9;

        // Adjustment amount is too small.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOSMALL = 0x80169DDB;

        // Invalid locale.
        public const uint XONLINE_E_BILLING_INVALID_LOCALE = 0x80169DE5;

        // Invalid customer type.
        public const uint XONLINE_E_BILLING_INVALID_CUSTOMER_TYPE = 0x80169DE6;

        // Invalid currency.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY = 0x80169DE7;

        // Date is already expired.
        public const uint XONLINE_E_BILLING_DATE_EXPIRED = 0x80169DE8;

        // GUID already exists.
        public const uint XONLINE_E_BILLING_GUID_EXISTS = 0x80169DEA;

        // Invalid violation ID.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION_ID = 0x80169DEC;

        // Violation ID is required.
        public const uint XONLINE_E_BILLING_MISSING_VIOLATION_ID = 0x80169DED;

        // De-provision service instances before proceeding.
        public const uint XONLINE_E_BILLING_NEEDTODEPROVISION = 0x80169DEF;

        // Partial conversion is already initiated.
        public const uint XONLINE_E_BILLING_PARTIALCONV_INITIATED = 0x80169DF0;

        // The currency of the account cannot be updated.
        public const uint XONLINE_E_BILLING_CANNOT_UPDATE_CURRENCY = 0x80169DF1;

        // Subscription is expected to be in the partial state.
        public const uint XONLINE_E_BILLING_PARTIALCONV_EXPECTED = 0x80169DF2;

        // Invalid category. Valid category name has a size limit of 50 characters.
        public const uint XONLINE_E_BILLING_INVALID_CATEGORY_NAME = 0x80169DF3;

        // Offering cannot be purchased.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PURCHASEABLE = 0x80169DF5;

        // Offering currency does not match account currency.
        public const uint XONLINE_E_BILLING_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80169DF6;

        // Offering does not support payment instrument type.
        public const uint XONLINE_E_BILLING_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169DF7;

        // Invalid date.
        public const uint XONLINE_E_BILLING_INVALID_DATE = 0x80169DF8;

        // Cannot exceed max ownership for the offering.
        public const uint XONLINE_E_BILLING_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80169DF9;

        // Invalid resource ID.
        public const uint XONLINE_E_BILLING_INVALID_RESOURCE_ID = 0x80169E02;

        // Unit of measure reported in the usage event does not match the one in SPS.
        public const uint XONLINE_E_BILLING_UNIT_OF_MEASURE_MISMATCH = 0x80169E03;

        // Event date is before the subscription purchase date.
        public const uint XONLINE_E_BILLING_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80169E04;

        // Offering invalid for the locale.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_FOR_LOCALE = 0x80169E05;

        // Offering is not a base offering.
        public const uint XONLINE_E_BILLING_NOT_A_BASE_OFFERING = 0x80169E06;

        // There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.
        public const uint XONLINE_E_BILLING_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169E08;

        // Offering is invalid for Country.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_FOR_COUNTRY = 0x80169E09;

        // The offering requested conflicts with an existing subscription on this account.
        public const uint XONLINE_E_BILLING_MEG_CONFLICT = 0x80169E0A;

        // Account state does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_STATUS = 0x80169E16;

        // Payment instrument has active subscriptions.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80169E1B;

        // The account has billing charges.
        public const uint XONLINE_E_BILLING_EXISTING_BILLING_ACTIVITY = 0x80169E1C;

        // Subscription is in an invalid state for this operation.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80169E20;

        // Primary phone required for payment instruments.
        public const uint XONLINE_E_BILLING_PRIMARY_PHONE_REQUIRED = 0x80169E25;

        // Account requires an e-mail address for this operation.
        public const uint XONLINE_E_BILLING_EMAIL_REQUIRED = 0x80169E2A;

        // To perform this operation, the account should be closed.
        public const uint XONLINE_E_BILLING_ACCOUNT_NOT_CLOSED = 0x80169E2B;

        // Invalid violation ID.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION = 0x80169E13;

        // Subscription is cancelled and cannot change status.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_IS_CANCELLED = 0x80169E14;

        // Subscription has no violations.
        public const uint XONLINE_E_BILLING_NO_VIOLATION = 0x80169E15;

        // Subscription has violations.
        public const uint XONLINE_E_BILLING_EXISTS_VIOLATION = 0x80169E17;

        // Invalid Service Component Id was passed.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_COMPONENT_ID = 0x80169E32;

        // End date is already past.
        public const uint XONLINE_E_BILLING_END_DATE_IN_THE_PAST = 0x80169E33;

        // End date passed in is later than the latest allowable end date for this subscription.
        public const uint XONLINE_E_BILLING_END_DATE_BEYOND_MAX = 0x80169E34;

        // Violation is already set.
        public const uint XONLINE_E_BILLING_VIOLATION_ALREADY_SET = 0x80169E3E;

        // Violation ID not set.
        public const uint XONLINE_E_BILLING_NO_VIOLATION_SET = 0x80169E43;

        // Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).
        public const uint XONLINE_E_BILLING_INVALID_CONVERSION = 0x80169E4D;

        // Subscription is not in the partial state.
        public const uint XONLINE_E_BILLING_SUBS_NOT_INTERMEDIATE = 0x80169E4E;

        // Offering is not published.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PUBLISHED = 0x80169E52;

        // Service instances must be de-provisioned to proceed.
        public const uint XONLINE_E_BILLING_CONVERSION_NEEDTODEPROVISION = 0x80169E53;

        // Invalid mandate status.
        public const uint XONLINE_E_BILLING_INVALID_MANDATE_STATUS = 0x80169E57;

        // Payment instrument status is already GOOD.
        public const uint XONLINE_E_BILLING_PI_ALREADY_GOOD = 0x80169E61;

        // Payment instrument status is already DECLINED.
        public const uint XONLINE_E_BILLING_PI_ALREADY_DECLINED = 0x80169E66;

        // Payment instrument status is DISABLED and cannot be changed.
        public const uint XONLINE_E_BILLING_PI_IS_DISABLED = 0x80169E6B;

        // SAP Number is required for Invoice PI.
        public const uint XONLINE_E_BILLING_INVOICEPI_SAP_NUMBER_REQUIRED = 0x80169E70;

        // Invoice XML was invalid.
        public const uint XONLINE_E_BILLING_INVALID_INVOICE_INFO_XML = 0x80169E71;

        // Max Limit for this PI Type within account reached.
        public const uint XONLINE_E_BILLING_MAX_PI_PER_ACCOUNT_REACHED = 0x8016AD81;

        // PI country does not match Account country.
        public const uint XONLINE_E_BILLING_PI_ACCOUNT_COUNTRY_MISMATCH = 0x80169E77;

        // An error occured. Try again later.
        public const uint XONLINE_E_BILLING_ERROR_OCCURRED_TRY_LATER = 0x80169E78;

        // An error occured.
        public const uint XONLINE_E_BILLING_ERROR_OCCURRED = 0x80169E79;

        // Payment instrument exists or the payment instrument status is invalid or does not allow the operation.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80169E7F;

        // Invalid offering GUID.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_GUID = 0x80169E84;

        // Offering requires a payment instrument.
        public const uint XONLINE_E_BILLING_OFFERING_REQUIRES_PI = 0x80169E89;

        // Offering cannot be purchased because it has delayed provisioning components.
        public const uint XONLINE_E_BILLING_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80169E93;

        // Invalid currency format.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY = 0x80169E99;

        // Invalid e-mail address.
        public const uint XONLINE_E_BILLING_INVALID_EMAIL_ADDRESS = 0x80169EA2;

        // Invalid tax exemption status.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_STATUS = 0x80169EAC;

        // No valid tax exemption certificates exist for the account.
        public const uint XONLINE_E_BILLING_NO_VALID_TAX_EXEMPTION = 0x80169EAD;

        // Invalid tax exemption status change.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_STATUS_CHANGE = 0x80169EB1;

        // The status of the old payment instrument does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80169EB6;

        // The specified start period is invalid.
        public const uint XONLINE_E_BILLING_INVALID_START_PERIOD = 0x80169EC4;

        // The specified end period is invalid.
        public const uint XONLINE_E_BILLING_INVALID_END_PERIOD = 0x80169EC5;

        // The specified Detailed level is invalid.
        public const uint XONLINE_E_BILLING_INVALID_DETAILEDLEVEL = 0x80169EC6;

        // Difference between BeginDate and EndDate is more than 6 months
        public const uint XONLINE_E_BILLING_EXCEED_DATERANGE_LIMIT = 0x80169EC7;

        // Begin Date can never be greater than EndDate
        public const uint XONLINE_E_BILLING_WRONG_DATERANGE = 0x80169EC8;

        // Begin date is not valid
        public const uint XONLINE_E_BILLING_INVALID_BEGIN_DATE = 0x80169EC9;

        // End date is not valid
        public const uint XONLINE_E_BILLING_INVALID_END_DATE = 0x80169ECB;

        // End date is greater than the current date
        public const uint XONLINE_E_BILLING_END_DATE_GREATER_THAN_CURRENT_DATE = 0x80169ECC;

        // SPS is in compute-only mode.
        public const uint XONLINE_E_BILLING_COMPUTE_ONLY = 0x80169ECA;

        // Detected that month(s) were missed in periodic processing.
        public const uint XONLINE_E_BILLING_MISSED_PROCESSING_PERIOD = 0x80169F33;

        // Subscription is not expired.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_EXPIRED = 0x80169F43;

        // Subscription can no longer be reinstated.
        public const uint XONLINE_E_BILLING_TOOLATE_REINSTATE = 0x80169F44;

        // Only a single Referral node may be passed in to this API.
        public const uint XONLINE_E_BILLING_EXTRA_REFERRAL_DATA = 0x80169F47;

        // bstrReferralIDSetXML parameter must be left empty for this API.
        public const uint XONLINE_E_BILLING_NO_REFERRAL_UPDATES_ALLOWED = 0x80169F4C;

        // Cannot schedule a new renewal because there exists already a free renewal on the subscription.
        public const uint XONLINE_E_BILLING_FREE_SCHEDULED_RENEWAL_EXISTS = 0x80169F4D;

        // Cannot convert a deal with multiple components with delayed provisioning.
        public const uint XONLINE_E_BILLING_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 0x80169F4E;

        // The specified cobrand is invalid.
        public const uint XONLINE_E_BILLING_INVALID_COBRAND = 0x80169F56;

        // This operation is not valid for wholesale subscriptions.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80169F65;

        // HCI not valid for Account Id.
        public const uint XONLINE_E_BILLING_HCI_NOT_VALID = 0x80169F83;

        // Taiwan users cannot opt out of hard copy tax invoices.
        public const uint XONLINE_E_BILLING_CANT_STOP_TAIWAN_TAXINV = 0x80169F85;

        // Adjusting a resource balance is not allowed for subscriptions that are not active.
        public const uint XONLINE_E_BILLING_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80169FB5;

        // The type of the token specified was invalid.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_TYPE = 0x8016A00A;

        // The token Id specified is not valid for the given offering.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_VALID_FOR_OFFERING = 0x8016A04B;

        // Deal Token mapping currently not present in the system to be marked as invalid.
        public const uint XONLINE_E_BILLING_DEAL_TOKEN_MAPPING_NOT_PRESENT = 0x8016A04C;

        // Maximum consumption count per user reached.
        public const uint XONLINE_E_BILLING_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 0x8016A00B;

        // Error in inserting a new row in table user_token_hash.
        public const uint XONLINE_E_BILLING_INSERTING_USER_TOKEN_HASH = 0x8016A00C;

        // A token Id and a payment instrument Id cannot both be specified.
        public const uint XONLINE_E_BILLING_TOKEN_AND_PI_BOTH_SPECIFIED = 0x8016A06E;

        // The token class is invalid or does not exist.
        public const uint XONLINE_E_BILLING_TOKEN_CLASS_INVALID = 0x8016A073;

        // The Input TokenClass Restriction Info Filter is Missing.
        public const uint XONLINE_E_BILLING_INPUT_FILTER_XML_MISSING = 0x8016A074;

        // Unable to find the token mapping to the specified token class.
        public const uint XONLINE_E_BILLING_TOKEN_CLASS_NOT_FOUND = 0x801613AB;

        // Invalid TokenClass Restriction Info Filter.
        public const uint XONLINE_E_BILLING_INVALID_INPUT_FILTER_XML = 0x8016A075;

        // A payment instrument cannot be specified.
        public const uint XONLINE_E_BILLING_PI_CANNOT_BE_SPECIFIED = 0x8016A078;

        // The subscription specified is not a PrePaid subscription.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_PREPAID = 0x8016A07D;

        // The total number of extended days cannot be less than zero.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x8016A082;

        // The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_DAYS = 0x8016A087;

        // The number of months specified is invalid, possibly because it is negative.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_MONTHS = 0x8016A088;

        // The total number of extended days is greater than the maximum allowed for the current subscription.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x8016A08C;

        // The deal specified requires a valid Prepaid Token Id to be specified.
        public const uint XONLINE_E_BILLING_PREPAID_TOKEN_IS_REQUIRED = 0x8016A096;

        // There are remaining cycles on the current term commit.
        public const uint XONLINE_E_BILLING_TERM_COMMIT_EXISTS = 0x8016A09B;

        // The specified token cannot be used for the current operation.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_APPLICABLE = 0x8016A0A0;

        // Renewal cannot be scheduled if there is already a token based renewal present.
        public const uint XONLINE_E_BILLING_TOKEN_RENEWAL_PRESENT = 0x8016A0A5;

        // Error subscription duration exceeds max duration.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAXIMUM_DURATION = 0x8016A0FA;

        // Error conversion credits were applied but the offer does not support conversion credits.
        public const uint XONLINE_E_BILLING_CONVERSION_CREDITS_NOT_ENABLED = 0x8016A104;

        // Only BillableAccountAdmin can add the PI.
        public const uint XONLINE_E_BILLING_INVALID_USERROLE_FOR_ADDPI = 0x8016A10E;

        // BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.
        public const uint XONLINE_E_BILLING_BLACKLIST_ACTION_NOT_PERFORMED = 0x8016A0AA;

        // BlacklistToken was called with invalid bstrSubscriptionAction parameter.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ACTION = 0x8016A0AF;

        // Invalid distribution channel specified for token class part number.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x8016A0B9;

        // Invalid length for token class part number.
        public const uint XONLINE_E_BILLING_INVALID_LEN_PART_NUMBER = 0x8016A0BE;

        // nvalid length for SAP customer name.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SAP_CUST_NAME = 0x8016A0C3;

        // Invalid length for Support Vendor name.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x8016A0C8;

        // Failed while inserting in partner_token_class table.
        public const uint XONLINE_E_BILLING_INSERING_TOKEN_CLASS_PARTNER = 0x8016A0CD;

        // Token Part Number is currently associated with other token class please remove the association from the other token class and try again.
        public const uint XONLINE_E_BILLING_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x8016A0D2;

        // A token is being delivered to the same service instance at this moment. Please retry.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DELIVERED = 0x8016148D;

        // A Token passed in does not have an associated Distribution batch.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_BATCH_INVALID = 0x80169DDA;

        // A Distribution Batch associated with the passed in Token is in inactive state.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 0x80169DDF;

        // A Distribution Program is in inactive state.
        public const uint XONLINE_E_BILLING_DISTRIBUTION_PROGRAM_INACTIVE = 0x80169DE9;

        // Failed while inserting in reconcile_history table.
        public const uint XONLINE_E_BILLING_INSERTING_RECONCILE_HISTORY = 0x801614BE;

        // Specified Token is already issued.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_ISSUED = 0x801614C3;

        // Specified Token is already unissued, can not unissue the same token again.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNISSUED = 0x801614C8;

        // Failed to update the token issue status in token_instance table.
        public const uint XONLINE_E_BILLING_TOKEN_ISSUE_UPDATE = 0x801614CD;

        // The input parameter combination does not match the system.
        public const uint XONLINE_E_BILLING_INVALID_COMBINATION = 0x801614D2;

        // Invalid Replacement Reason code specified.
        public const uint XONLINE_E_BILLING_INVALID_REPLACEMENT_REASON_CODE = 0x801614D7;

        // The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.
        public const uint XONLINE_E_BILLING_MAX_REPLACEMENT_REACHED = 0x801614DC;

        // Token Replacement failed due to unknown error.
        public const uint XONLINE_E_BILLING_TOKEN_REPLACEMENT_FAILED = 0x801614E1;

        // Failed to update Token Distribution status.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x801614E6;

        // Signature does not belong to specified Token.
        public const uint XONLINE_E_BILLING_SIGNATURE_TOKEN_MISMATCH = 0x801614EB;

        // Invalid Token Staus Name specified.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_NAME = 0x801614F0;

        // Invalid distribution status to issue token.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x801614F5;

        // Specified token is replaced token, can not provide replacement for Replaced Token.
        public const uint XONLINE_E_BILLING_ALREADY_REPLACED_TOKEN = 0x801614FA;

        // Invalid Partner specified or the partner does not have permission to take action on specified token.
        public const uint XONLINE_E_BILLING_TOKEN_ACTION_ACCESS_DENIED = 0x801614FF;

        // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x8016A604;

        // The begin billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_BAD_BEGIN_BILLING_PERIOD = 0x8016A609;

        // The end billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_INVALID_END_BILLING_PERIOD = 0x8016A60E;

        // The billing period value cannot be negative.
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_NEGATIVE = 0x8016A613;

        // The end period must be greater than start period.
        public const uint XONLINE_E_BILLING_BAD_START_END_BILLING_PERIOD = 0x8016A618;

        // The account history date cannot be greater than the current date.
        public const uint XONLINE_E_BILLING_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x8016A61D;

        // Cannot pass null for all parameters.
        public const uint XONLINE_E_BILLING_NO_NON_NULL_PARAMS = 0x8016A622;

        // The billing period value must be of the format YYYYMM (Y representing the year and M representing month).
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x8016A627;

        // The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x8016A62C;

        // The offering guid passed in does not match offering guid on subscription.
        public const uint XONLINE_E_BILLING_MISMATCH_SUB_ID_OFFER_GUID = 0x8016A6FE;

        // The event time stamp is too far in future.
        public const uint XONLINE_E_BILLING_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x8016A70D;

        // The policy GuidID/Version combination supplied does not exist.
        public const uint XONLINE_E_BILLING_INVALID_POLICY_ID = 0x80169F88;

        // The offering specified does not support the country of payment instrument being used.
        public const uint XONLINE_E_BILLING_OFFERING_PI_COUNTRY_MISMATCH = 0x80169F89;

        // Error inserting into table agreement_signature.
        public const uint XONLINE_E_BILLING_INSERT_AGREEMENT_SIGNATURE = 0x80169F8D;

        // Agreement for this subscription has already been signed by this user at a different time.
        public const uint XONLINE_E_BILLING_AGREEMENT_ALREADY_SIGNED = 0x80169F92;

        // The specified policy has not been localized in the specified locale.
        public const uint XONLINE_E_BILLING_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80169F9C;

        // The policy specified is valid but the version is incorrect.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_VERSION_MISMATCH = 0x80169F9E;

        // The policy specified exists but is not valid on the deal/country combination of the supplied subscription.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_COUNTRY_MISMATCH = 0x80169FA1;

        // The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.
        public const uint XONLINE_E_BILLING_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x8016A6D1;

        // A payment instrument cannot specified when the conversion mode is RENEW.
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_PI_DURING_RENEW = 0x8016A6D6;

        // Renewing from a perpetual offering is not allowed.
        public const uint XONLINE_E_BILLING_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x8016A6E5;

        // Tax Exempt Certificate Number is invalid.
        public const uint XONLINE_E_BILLING_INVALID_TECERTIFICATENUMBER = 0x8016A6EA;

        // Conversions between wholesale offers are not allowed.
        public const uint XONLINE_E_BILLING_NO_WHOLESALE_TO_WHOLESALE = 0x8016A708;

        // The status of the new payment instrument specified does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x8016A712;

        // Renewal does not exist.
        public const uint XONLINE_E_BILLING_INVALID_RENEWAL = 0x8016A71C;

        // The length of phone number is greater than expected.
        public const uint XONLINE_E_BILLING_ERROR_PHONE_STRING_TOOLONG = 0x8016A721;

        // The calling partner does not have access to the token class.
        public const uint XONLINE_E_BILLING_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x8016A72B;

        // Last administrator role on the account cannot be removed.
        public const uint XONLINE_E_BILLING_LAST_ADMIN_ROLE = 0x8016C3C3;

        // The PUID is already being used as BillableAccountAdmin.
        public const uint XONLINE_E_BILLING_PUID_USED_AS_BILLABLEACCOUNTADMIN = 0x8016C3C4;

        // Error updating member name.
        public const uint XONLINE_E_BILLING_UPDATING_MEMBERNAME = 0x8016C3C8;

        // Object can have a maximum of 2000 roles.
        public const uint XONLINE_E_BILLING_OBJECT_ROLE_LIMIT_EXCEEDED = 0x8016C3CD;

        // The allowable number of the delegate admins for an account has reached its limit.
        public const uint XONLINE_E_BILLING_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 0x8016C3CE;

        // Provisioning: Provision request malformed.
        public const uint XONLINE_E_BILLING_MALFORMED_REQUEST = 0x8016AB7D;

        // Provisioning: Wrong input parameters.
        public const uint XONLINE_E_BILLING_WRONG_INPUT_PARAMETERS = 0x8016AB7E;

        // Provisioning: Microsoft Provisioning Framework call failed. %1
        public const uint XONLINE_E_BILLING_MPF_CALL_FAILED = 0x8016AB7F;

        // Provisioning: Error during XML manipulation. %1
        public const uint XONLINE_E_BILLING_XML_OPERATION_ERROR = 0x8016AB80;

        // Provisioning: MPF client instantiation failed. %1
        public const uint XONLINE_E_BILLING_MPF_CREATE = 0x8016AB81;

        // Provisioning: General error in startup code. %1
        public const uint XONLINE_E_BILLING_CREATION = 0x8016AB82;

        // The number of service instances in the provisioning request exceeds the configured limit.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 0x8016ABA2;

        // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_DBBADZIP = 0x8016ABA3;

        // The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x8016ABA4;

        // The account requires additional attributes before performing the operation.
        public const uint XONLINE_E_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x8016ABA5;

        // The referrer has already reffered the customer to this offer.
        public const uint XONLINE_E_BILLING_ACCT_ALREADY_REFERRED = 0x8016ABCE;

        // There are no reward offers currently available in the system.
        public const uint XONLINE_E_BILLING_REWARD_OFFER_NOT_PURCHASABLE = 0x8016ABDA;

        // Need to sign the agreement before continuing with the call.
        public const uint XONLINE_E_BILLING_AGREEMENT_NOT_SIGNED = 0x8016AC79;

        // The user has a violation on their payment instrument.
        public const uint XONLINE_E_BILLING_ITEM_VIOLATION_EXISTS = 0x8016AC7A;

        // Title and/or category is not allowed for this offer.
        public const uint XONLINE_E_BILLING_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 0x8016AC7B;

        // Account has a pending transaction.
        public const uint XONLINE_E_BILLING_PENDING_TRANSACTION = 0x8016AC7C;

        // Cannot update total.
        public const uint XONLINE_E_BILLING_INCREMENT_TOTAL = 0x80164E39;

        // Resource does not belong to this object id.
        public const uint XONLINE_E_BILLING_RES_NOT_BELONG_TO_OBJECT = 0x80164E57;

        // Payment instrument on the current subscription has a declining balance.
        public const uint XONLINE_E_BILLING_DECLINING_BALANCE = 0x80164E5C;

        // Duplicate tracking GUID.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRACKING_GUID = 0x80164E75;

        // Invalid credit card expiration date.
        public const uint XONLINE_E_BILLING_INVALID_EXPIRATION_DATE = 0x80164EA7;

        // Invalid mandate status.
        public const uint XONLINE_E_BILLING_UNKNOWN_MANDATE_STATUS = 0x80164EAC;

        // Payment method of this type can't support the action
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_TYPE = 0x80164EB2;

        // Invalid input currency.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY2 = 0x80164EC0;

        // Invalid amount passed in as argument.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT = 0x80164EFC;

        // Invalid billing period.
        public const uint XONLINE_E_BILLING_INVALID_BILLING_PERIOD = 0x80164F42;

        // Invalid billing anniversary date.
        public const uint XONLINE_E_BILLING_INVALID_ANNIV = 0x80164F9C;

        // Invalid line item ID.
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID = 0x80164FF6;

        // The event type of the line item is invalid for this operation.
        public const uint XONLINE_E_BILLING_INVALID_EVENT_TYPE = 0x8016501E;

        // Line item ID not associated with an open record.
        public const uint XONLINE_E_BILLING_LINE_ITEM_ID_NOT_OPEN = 0x80165046;

        // Line item has already been offset.
        public const uint XONLINE_E_BILLING_LINEITEM_ALREADY_OFFSET = 0x8016504B;

        // Line item has already been Charged back.
        public const uint XONLINE_E_BILLING_LINEITEM_ALREADY_CHARGED_BACK = 0x8016504D;

        // Offset amount must be greater than zero but less than or equal to original amount. %1
        public const uint XONLINE_E_BILLING_INVALID_OFFSET_AMOUNT = 0x80165050;

        // Cannot offset line item that is soft- or hard-declined.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80165055;

        // Amount has not been collected, so it cannot be offset and immediately settled.
        public const uint XONLINE_E_BILLING_AMOUNT_NOT_COLLECTED_YET = 0x8016505A;

        // Cannot offset line item amount of zero.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_ZERO_AMOUNT = 0x8016505F;

        // The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.
        public const uint XONLINE_E_BILLING_AMOUNT_IN_PROCESS = 0x80165064;

        // Credit amount should not be zero.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_AMOUNT = 0x80165082;

        // Credit amount should not exceed the limit.
        public const uint XONLINE_E_BILLING_CREDIT_AMOUNT_OVER_LIMIT = 0x80165083;

        // Invalid amount for currency (JPY or KRW).
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80165084;

        // Same event id already been used, please create a new event id and retry.
        public const uint XONLINE_E_BILLING_DUPLICATE_EVENT_ID = 0x80165091;

        // Line items in the immediate_settle_in_progress state cannot be offset.
        public const uint XONLINE_E_BILLING_OFFSET_IMM_SETTLE_IN_PROG = 0x8016509B;

        // Line item with this settlement amount status cannot be offset.
        public const uint XONLINE_E_BILLING_SA_IN_STATE_UNOFFSETABLE = 0x801650A5;

        // this settlement amount status cannot be escheated.
        public const uint XONLINE_E_BILLING_SA_IN_STATE_UNESCHEATABLE = 0x801650A6;

        // Offset amount should never exceed the original item amount.
        public const uint XONLINE_E_BILLING_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x801650AA;

        // The subscription is not active. The resource usage event is still being reported for the subscription.
        public const uint XONLINE_E_BILLING_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x801650AF;

        // the payment instrument already has declines on it
        public const uint XONLINE_E_BILLING_PI_IN_DECLINE = 0x801650C8;

        // The operation is not allowed when there are Settlement Amounts in intermediate status.
        public const uint XONLINE_E_BILLING_SA_IN_INTERMEDIATE_STATUS = 0x801651D1;

        // The specified settlement amount id is invalid.
        public const uint XONLINE_E_BILLING_INVALID_SETTLEMENT_AMOUNT_ID = 0x801651D6;

        // This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.
        public const uint XONLINE_E_BILLING_MISMATCH_RATED_USAGE_TOTAL = 0x801651E5;

        // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x801651BD;

        // %1
        public const uint XONLINE_E_BILLING_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x801651EA;

        // Refund failed - line item was offset but original line item was never settled.
        public const uint XONLINE_E_BILLING_REFUND_LINEITEM_NOT_SETTLED = 0x80165217;

        // Specified resource balance has already been billed.
        public const uint XONLINE_E_BILLING_RESOURCE_BALANCE_INACTIVE = 0x80165226;

        // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_UNITS = 0x80165235;

        // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_CATEGORY = 0x8016523A;

        // The prepaid resource balance is not sufficient for this usage event.
        public const uint XONLINE_E_BILLING_INSUFFICIENT_PREPAID_BALANCE = 0x8016523F;

        // Financial reason code does not exist.
        public const uint XONLINE_E_BILLING_INVALID_FINANCIAL_REASON_CODE = 0x80165262;

        // Offset of offset is not permitted through this API.
        public const uint XONLINE_E_BILLING_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80165267;

        // If offset is not to be shown by getstatement, the offset amount must match the original amount.
        public const uint XONLINE_E_BILLING_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80165276;

        // Invalid financial reason code passed for the offset usage API.
        public const uint XONLINE_E_BILLING_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x8016527B;

        // The line item is associated with a non-offsettable event action.
        public const uint XONLINE_E_BILLING_EVENT_ACTION_NOT_OFFSETTABLE = 0x80165280;

        // Action is not permitted for immediate settle of usage offers.
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80165285;

        // Resource offset is only allowed for usage.
        public const uint XONLINE_E_BILLING_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x8016528A;

        // Invalid Tax Refund Code.
        public const uint XONLINE_E_BILLING_ERROR_PP_INVALID_TAX_REFUND_CODE = 0x801652AD;

        // The transaction confirmation number is already used on the account.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 0x801655FA;

        // The transaction does not exist.
        public const uint XONLINE_E_BILLING_TRANSACTION_NOT_EXIST = 0x80165609;

        // Invalid combination of cumulative authorized amount and cumulative reversed amount.
        public const uint XONLINE_E_BILLING_INVALID_CUMULATIVE_AMOUNT = 0x80165613;

        // The transaction event code is unknown.
        public const uint XONLINE_E_BILLING_TRANSACTION_EVENT_UNKNOWN = 0x80165618;

        // The transaction event code is not consistent.
        public const uint XONLINE_E_BILLING_TRANSACTION_EVENT_INCONSISTENT = 0x8016561D;

        // Invalid sequence number reported in transaction event.
        public const uint XONLINE_E_BILLING_INVALID_SEQUENCE_NUMBER = 0x80165622;

        // Invalid vendor internal transaction id.
        public const uint XONLINE_E_BILLING_INVALID_VENDOR_TRANSACTION_ID = 0x80165627;

        // Invalid rejection reason code.
        public const uint XONLINE_E_BILLING_INVALID_REJECTION_REASON_CODE = 0x8016562C;

        // Invalid transaction status.
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_STATUS = 0x80165659;

        // Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount.
        public const uint XONLINE_E_BILLING_INVALID_CUMULATIVE_TAX_AMOUNT = 0x8016566D;

        // Invalid merchant id.
        public const uint XONLINE_E_BILLING_UNKNOWN_MERCHANT_ID = 0x80165677;

        // Transaction has already been cancelled.
        public const uint XONLINE_E_BILLING_TRANSACTION_ALREADY_CANCELLED = 0x8016567C;

        // Passport member name could not be added.
        public const uint XONLINE_E_BILLING_PMN_INSERT_FAILURE = 0x801661BC;

        // Payment card number has been used multiple times.
        public const uint XONLINE_E_BILLING_BADSAMECARDUSEDMULTIPLETIMES = 0x801661D0;

        // Payment instrument already assigned to account.
        public const uint XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT = 0x801661DF;

        // Passport ID can have a maximum of 100 roles.
        public const uint XONLINE_E_BILLING_PUID_ROLE_LIMIT_EXCEEDED = 0x801661E4;

        // Too many fraud enticing purchases on the payment instrument
        public const uint XONLINE_E_BILLING_TOOMANY_FDE_PURCHASES = 0x801661E5;

        // Passport PUIDs associated with this tax Id has already reaches the maximum limit.
        public const uint XONLINE_E_BILLING_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 0x8016620C;

        // Access denied.
        public const uint XONLINE_E_BILLING_NOPERMISSION = 0x80162711;

        // Cannot remove self from object.
        public const uint XONLINE_E_BILLING_CANNOT_REMOVE_SELF = 0x80162712;

        // XML is either malformed or incorrect for this API.
        public const uint XONLINE_E_BILLING_BADXML = 0x80162713;

        // Comment text length must be between 1 and 512 characters.
        public const uint XONLINE_E_BILLING_INVALIDCOMMENTSIZE = 0x80162714;

        // Invalid cancellation mode.
        public const uint XONLINE_E_BILLING_BADCANCELMODE = 0x80162715;

        // Input parameter is the wrong size.
        public const uint XONLINE_E_BILLING_INVALID_BUF_SIZE = 0x80162716;

        // Invalid role.
        public const uint XONLINE_E_BILLING_INVALID_ROLE = 0x80162717;

        // Invalid Passport ID.
        public const uint XONLINE_E_BILLING_INVALID_PPORT_ID = 0x80162718;

        // Invalid argument.
        public const uint XONLINE_E_BILLING_INVALID_ARG = 0x8016271A;

        // Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
        public const uint XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE = 0x8016271F;

        // Status must be ENABLED or SUSPENDED.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_VALUE = 0x80162720;

        // Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.
        public const uint XONLINE_E_BILLING_INVALID_FILTER = 0x80162721;

        // Missing category.
        public const uint XONLINE_E_BILLING_MISSING_CATEGORY = 0x80162722;

        // Input field is too short.
        public const uint XONLINE_E_BILLING_FIELD_TOO_SHORT = 0x80162723;

        // Input field is too long.
        public const uint XONLINE_E_BILLING_FIELD_TOO_LONG = 0x80162724;

        // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_BADZIP = 0x80162725;

        // Only one of these nodes should be passed.
        public const uint XONLINE_E_BILLING_ONLYONENODE = 0x80162726;

        // Input field length does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_FIELD_LENGTH = 0x80162727;

        // Only customer service representatives can invoke this API.
        public const uint XONLINE_E_BILLING_CSR_AUTHZ_FAILED = 0x80162728;

        // Caller is not an account administrator.
        public const uint XONLINE_E_BILLING_NOT_ACCOUNT_ADMIN = 0x80162729;

        // Delegate ID entered was invalid or not specified.
        public const uint XONLINE_E_BILLING_DELEGATE_ID_UNSPECIFIED = 0x8016272A;

        // Requester Passport ID must be specified.
        public const uint XONLINE_E_BILLING_REQUESTER_ID_UNSPECIFIED = 0x8016272B;

        // Boolean value must be 0 or 1
        public const uint XONLINE_E_BILLING_INVALID_FLAG_VALUE = 0x8016272C;

        // Subscription service instance is inactive.
        public const uint XONLINE_E_BILLING_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x8016272D;

        // Invalid object.
        public const uint XONLINE_E_BILLING_INVALID_OBJECT_ID = 0x8016272E;

        // Input field length of first name does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_FIRSTNAME_FIELD_LENGTH = 0x8016272F;

        // Input field length of last name does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_LASTNAME_FIELD_LENGTH = 0x80162730;

        // Input field length of address does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESS_FIELD_LENGTH = 0x80162731;

        // Calling partner is not registered in SPS database.
        public const uint XONLINE_E_BILLING_PARTNERNOTINBILLING = 0x80162738;

        // Rating error has occurred. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_RATING_FAILURE = 0x8016273D;

        // BDKSVR2 started.
        public const uint XONLINE_E_BILLING_R2_STARTED = 0x80162742;

        // CSR call made.
        public const uint XONLINE_E_BILLING_R_API_CALL_MADE = 0x80162743;

        // CSR call attempt by non-CSR caller.
        public const uint XONLINE_E_BILLING_CSR_CALL_FROM_NONCSR = 0x80162744;

        // "From" and "to" payment instrument are not on the same account in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_MISMATCHING_ACCTS = 0x8016274C;

        // Invalid "to" payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_PI_INVALID = 0x80162751;

        // Cannot transfer to same payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_SAME_PI = 0x80162756;

        // Cannot transfer balances between payment instrument types.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_NOT_ALLOW = 0x8016275B;

        // Internal database inconsistencies detected.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR = 0x80162760;

        // Payment instrument has outstanding balance.
        public const uint XONLINE_E_BILLING_OUTSTANDING_BALANCE = 0x80162765;

        // Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).
        public const uint XONLINE_E_BILLING_INVALID_REFERRALDATA_XML = 0x8016276A;

        // Invalid GUID.
        public const uint XONLINE_E_BILLING_INVALID_GUID = 0x8016276F;

        // Payment instrument type not supported for SettleBalance.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80162774;

        // Subscription is inactive.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_INACTIVE = 0x80162779;

        // Payments can only be stopped for credit card and direct debit transactions.
        public const uint XONLINE_E_BILLING_INVALID_PM_FOR_STOP_PAYMENTS = 0x8016277E;

        // Excessive number of usage events reported in one ReportUsageEvent() call.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80162783;

        // Field cannot be updated.
        public const uint XONLINE_E_BILLING_FIELD_NOT_UPDATEABLE = 0x80162788;

        // Calling CancelSubscription with an end date and in compute-only mode is not supported.
        public const uint XONLINE_E_BILLING_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x8016278D;

        // The SETTLE event should be the last event in the event list for ImportSettleBillingItems.
        public const uint XONLINE_E_BILLING_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x8016278E;

        // Line item payment method is no longer valid.
        public const uint XONLINE_E_BILLING_PAYMENT_METHOD_NO_LONGER_VALID = 0x8016278F;

        // Failed to process all usage events.
        public const uint XONLINE_E_BILLING_PROCESS_USAGE_EVENTS = 0x80162790;

        // Object ID does not contain account and subscription information.
        public const uint XONLINE_E_BILLING_WRONG_OBJECT_ID_TYPE = 0x80162791;

        // Field contains invalid characters for a phone number.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_VALUE = 0x80162792;

        // Invalid amount.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_VALUE = 0x80162797;

        // Payment instrument ID and line item ID do not match.
        public const uint XONLINE_E_BILLING_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80162793;

        // InternalAddComment failed. Escalate error to SPG development.
        public const uint XONLINE_E_BILLING_INTERNAL_ADD_COMMENT_FAILED = 0x80162794;

        // Immediate settle flag value not supported.
        public const uint XONLINE_E_BILLING_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80162795;

        // No eligible records were found for this call.
        public const uint XONLINE_E_BILLING_NO_RECORDS_FOR_STOP_PAYMENTS = 0x8016279C;

        // Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.
        public const uint XONLINE_E_BILLING_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x801627A6;

        // The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.
        public const uint XONLINE_E_BILLING_INVALID_TELENUMERIC_STRING = 0x801627B0;

        // There are no matches for the requested information.
        public const uint XONLINE_E_BILLING_NO_MATCH = 0x801627BA;

        // There are multiple matches for the requested information.
        public const uint XONLINE_E_BILLING_MULTIPLE_MATCHES = 0x801627C4;

        // PUID entered was invalid.
        public const uint XONLINE_E_BILLING_BAD_PUID = 0x801627CE;

        // ObjectId length must be 16.
        public const uint XONLINE_E_BILLING_BAD_OBJECT_ID_LENGTH = 0x801627D9;

        // Start period can never be greater than End period.
        public const uint XONLINE_E_BILLING_END_PERIOD_LESS_THAN_START_PERIOD = 0x801627DA;

        // Billing period length must be 6.
        public const uint XONLINE_E_BILLING_BAD_BILLING_PERIOD_LENGTH = 0x801627DB;

        // Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET = 0x801627DC;

        // The usage event date specified was invalid.  One possible reason is that it is too far in the future.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_EVENT_DATE = 0x801627DF;

        // The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
        public const uint XONLINE_E_BILLING_NULL_DEFAULT_BILLING_PERIOD = 0x801627E0;

        // The start billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_BAD_START_BILLING_PERIOD = 0x801627E1;

        // The end billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_BAD_END_BILLING_PERIOD = 0x801627E2;

        // The new due date is in the past
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_IS_PAST = 0x801627E7;

        // The new due date is more than MAXIMUM DELAY days in the future than the original due date
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_THRESHOLD_PASSED = 0x801627EC;

        // If the applydeclineEffect is off, we need a new due date specified
        public const uint XONLINE_E_BILLING_NO_NEW_DUE_DATE_SPECIFIED = 0x801627F1;

        // Invalid transaction type
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_TYPE = 0x801627F6;

        // Invalid reason code
        public const uint XONLINE_E_BILLING_INVALID_REASON_CODE = 0x801627FB;

        // Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
        public const uint XONLINE_E_BILLING_GROUP_SID_INITIALIZATION_FAILED = 0x8016280B;

        // This operation is not valid for wholesale payment instruments.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x8016280C;

        // This operation is not valid for direct debit payment instrument.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x8016280D;

        // Adjustment amount exceeds the resource credit limit.
        public const uint XONLINE_E_BILLING_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x8016280E;

        // Adjusting a resource balance is not allowed for subscriptions that are not active.
        public const uint XONLINE_E_BILLING_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x8016280F;

        // Failed to create mail record for account: %1.
        public const uint XONLINE_E_BILLING_FAILED_TO_CREATE_MAIL_RECORD = 0x80162810;

        // This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
        public const uint XONLINE_E_BILLING_MSNIA_LATE_USAGE = 0x80162811;

        // Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
        public const uint XONLINE_E_BILLING_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80162812;

        // This offering is not configured as a referral offer.
        public const uint XONLINE_E_BILLING_INVALID_REFERRAL_OFFER = 0x8016ABCC;

        // Reward referral XML is required as this is a referral based offer.
        public const uint XONLINE_E_BILLING_REWARD_REFERRAL_XML_REQUIRED = 0x80162813;

        // Referral PUID not found.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_IN_SYSTEM = 0x80162814;

        // Referrer has exceeded the max number of referrals configured on the offer.
        public const uint XONLINE_E_BILLING_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80162815;

        // The referrer does not have an Active or Locked account in the system.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ACTIVE = 0x80162816;

        // The referrer cannot refer self for the offer.
        public const uint XONLINE_E_BILLING_CANNOT_REFER_SELF = 0x80162817;

        // The referral xml has reward referral info but the offer is not configured for reward referrals.
        public const uint XONLINE_E_BILLING_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80162818;

        // The reward referral schema in the referral xml is invalid.
        public const uint XONLINE_E_BILLING_INVALID_REWARD_REFFERAL_SCHEMA = 0x80162819;

        // The referrer does not have any eligible offers configured for the reward.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x8016281A;

        // Invalid mandate status for SettleBalance.
        public const uint XONLINE_E_BILLING_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x8016281B;

        // More than one usage event reported to ReportSingleUsageEvent API
        public const uint XONLINE_E_BILLING_MULTIPLE_USAGE_EVENTS_REPORTED = 0x8016281C;

        // The reported usage is below the threshold in immediate settle usage.
        public const uint XONLINE_E_BILLING_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x8016281D;

        // ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x8016281E;

        // ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_PREPAID = 0x8016281F;

        // ReportSingleUsage cannot be used with empty event set.
        public const uint XONLINE_E_BILLING_NO_USAGE_EVENT_REPORTED = 0x80162820;

        // The payment instrument type does not support immediate settlements
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80162821;

        // The reported resource and unit of measure do not match.
        public const uint XONLINE_E_BILLING_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80162822;

        // Invalid  data passed in RedirectInputInfoXML node.
        public const uint XONLINE_E_BILLING_INVALID_REDIRECT_INPUTINFO_XML = 0x80162823;

        // Transaction cannot be cancelled.
        public const uint XONLINE_E_BILLING_TRANSACTION_NOT_CANCELLABLE = 0x80162824;

        // No CDs found.
        public const uint XONLINE_E_BILLING_NO_CDS_FOUND = 0x80162825;

        // Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length
        public const uint XONLINE_E_BILLING_INVALID_CHARGE_DESCRIPTOR = 0x80162826;

        // This Wholesale payment instrument has no related wholesale partner.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALEPI = 0x801628A0;

        // This partner is not BOBO wholesale partner.
        public const uint XONLINE_E_BILLING_NOT_BOBOPARTNER = 0x801628A1;

        // This BOBO wholesale partner has no entitle endpoint.
        public const uint XONLINE_E_BILLING_INVALID_BOBOPARTNER = 0x801628A2;

        // The entitlement endpoint web service could not be reached
        public const uint XONLINE_E_BILLING_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 0x801628FA;

        // The entitlement endpoint returned a validation failure
        public const uint XONLINE_E_BILLING_ENTITLEMENT_VALIDATION_FAILED = 0x801628FB;

        // The entitlement endpoint is invalid
        public const uint XONLINE_E_BILLING_INVALID_ENTITLEMENT_ENDPOINT = 0x801628FC;

        // Calling partner does not have permissions to access the sandboxed object
        public const uint XONLINE_E_BILLING_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 0x80169D57;

        // Calling partner does not have permissions to call on behalf of this partner
        public const uint XONLINE_E_BILLING_UNABLE_TO_CALL_ON_BEHALF_OF = 0x80162828;

        // Taxware error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_TAXWARE_FAILURE = 0x8016EA60;

        // Address validation error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_ADDRESS_VALIDATION_FAILURE = 0x8016EA61;

        // VERAZIP: Invalid ZIP code.
        public const uint XONLINE_E_BILLING_ZIP_INVALID = 0x8016EA6B;

        // VERAZIP: Invalid state code.
        public const uint XONLINE_E_BILLING_STATE_INVALID = 0x8016EA6C;

        // VERAZIP: Missing ZIP code or city name.
        public const uint XONLINE_E_BILLING_ZIP_CITY_MISSING = 0x8016EA6D;

        // VERAZIP: Invalid state code/ZIP code combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_INVALID = 0x8016EA6E;

        // VERAZIP: Invalid state code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_CITY_INVALID = 0x8016EA6F;

        // VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID = 0x8016EA70;

        // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 = 0x8016EA71;

        // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 = 0x8016EA72;

        // VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 = 0x8016EA73;

        // VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_MULTIPLE_COUNTIES_FOUND = 0x8016EA7D;

        // VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
        public const uint XONLINE_E_BILLING_ZIP_INVALID_FOR_ENTERED_STATE = 0x8016EA7E;

        // VERAZIP: ZIP code has multiple city names.
        public const uint XONLINE_E_BILLING_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x8016EA89;

        // VERAZIP: City has multiple ZIP codes.
        public const uint XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND = 0x8016EA8A;

        // Incorrect city name length.
        public const uint XONLINE_E_BILLING_BAD_CITYNAME_LENGTH = 0x8016EA8B;

        // Incorrect country code length.
        public const uint XONLINE_E_BILLING_BAD_COUNTRYCODE_LENGTH = 0x8016EA8C;

        // Incorrect code length for state or province.
        public const uint XONLINE_E_BILLING_BAD_STATECODE_LENGTH = 0x8016EA8D;

        // Incorrect zip code length.
        public const uint XONLINE_E_BILLING_BAD_ZIPCODE_LENGTH = 0x8016EA8E;

        // Incorrect product code length.
        public const uint XONLINE_E_BILLING_BAD_PRODUCTCODE_LENGTH = 0x8016EA8F;

        // Incorrect business location code length.
        public const uint XONLINE_E_BILLING_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x8016EA90;

        // Incorrect transaction date length.
        public const uint XONLINE_E_BILLING_BAD_TRANSACTIONDATE_LENGTH = 0x8016EA91;

        // Incorrect VAT registration length.
        public const uint XONLINE_E_BILLING_BAD_VATREGISTRATION_LENGTH = 0x8016EA92;

        // Incorrect currency code length.
        public const uint XONLINE_E_BILLING_BAD_CURRENCYCODE_LENGTH = 0x8016EA93;

        // Incorrect WorldTax code length.
        public const uint XONLINE_E_BILLING_BAD_WTCODE_LENGTH = 0x8016EA94;

        // Invalid input parameter passed to TaxWare or VeraZip.
        public const uint XONLINE_E_BILLING_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x8016EA95;

        // The Vat ID provided is of invalid format.
        public const uint XONLINE_E_BILLING_INVALID_VATID_FORMAT = 0x8016EA97;

        // The Vat ID provided is invalid.
        public const uint XONLINE_E_BILLING_INVALID_VATID_INVALID = 0x8016EA98;

        // Input string contains unsupported characters.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_CHAR_EXIST = 0x8016EA9C;

        // Country code in Address does not match with the country code in Account Info.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_MISMATCH = 0x8016EAA1;

        // A Country code is required in Account Info.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_REQUIRED = 0x8016EAA6;

        // Token passed is Invalid.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_SPECIFIED = 0x8016138D;

        // The token is already blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_BLACKLISTED = 0x80161392;

        // The token is already un-blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNBLACKLISTED = 0x80161393;

        // The specified token has been blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_BLACKLISTED = 0x801613BF;

        // The specified token belongs to a blacklisted token range.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_BLACKLISTED = 0x801613C4;

        // The usage for the specified token has been exceeded.
        public const uint XONLINE_E_BILLING_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x801613C9;

        // Token Expiry date not set as may be duration based token was not activated correctly.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x801613CE;

        // Failed while consumption to create an entry in token_instance_deal_subscription table.
        public const uint XONLINE_E_BILLING_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x801613CF;

        // Not found non-active token range to be activated.
        public const uint XONLINE_E_BILLING_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x801613D3;

        // The specified token has expired.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRED = 0x801613F1;

        // The specified token cannot be used yet.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_STARTED = 0x801613F6;

        // The specified token has not been activated yet.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_NOT_ACTIVE = 0x801613FB;

        // The reason code specified is not valid.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x8016141E;

        // The specified action is in progress.
        public const uint XONLINE_E_BILLING_TRACKING_GUID_NODATA = 0x8016145A;

        // The specified tracking has already been used
        public const uint XONLINE_E_BILLING_DUPLICATE_TOKEN_TRACKING_GUID = 0x8016145F;

        // The specified token has already been activated
        public const uint XONLINE_E_BILLING_ALREADY_ACTIVATED = 0x8016146E;

        // Committed status is not valid for this API.
        public const uint XONLINE_E_BILLING_INVALID_COMMITTED_STATUS = 0x80161470;

        // The description specified is not valid.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80161473;

        // Blacklist Effective date passed was prior to the order creation date.
        public const uint XONLINE_E_BILLING_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80161478;

        // The Token has been consumed.
        public const uint XONLINE_E_BILLING_TOKEN_CONSUMED = 0x8016147D;

        // Part Number specified for the token import is not a valid part number for the associated token class.
        public const uint XONLINE_E_BILLING_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80161482;

        // External reference id is too long or invalid.
        public const uint XONLINE_E_BILLING_INVALID_EXTERNAL_REFERENCE_ID = 0x80161483;

        // The token is already deactivated.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DEACTIVATED = 0x80161487;

        // Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.
        public const uint XONLINE_E_BILLING_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80161491;

        // Null parameter was passed for Token Class GUID during token class access verification.
        public const uint XONLINE_E_BILLING_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 0x80161496;

        // The argument specified is not a valid bookmark.
        public const uint XONLINE_E_BILLING_INVALID_BOOKMARK = 0x80161484;

        // The max argument must be between 1 and 50.
        public const uint XONLINE_E_BILLING_INVALID_MAX = 0x80161485;

        // Internal inconsistency in Token Database.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR_TOKEN = 0x80161455;

        // Unable to retrieve event ID and billing impact for event.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x8016CD14;

        // Unable to find line item matching event.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x8016CD46;

        // Cannot process if there is an offset of an offset.
        public const uint XONLINE_E_BILLING_CANCELREFUND_OFFSET_OF_OFFSET = 0x8016CD78;

        // This can't happen, both line item and related line item in the active list.
        public const uint XONLINE_E_BILLING_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x8016CDAA;

        // The session key passed in does not pass validation checks.
        public const uint XONLINE_E_BILLING_INVALID_SESSION_KEY = 0x8016768E;

        // This object ID is not entitled to get a deliverable token.
        public const uint XONLINE_E_BILLING_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x8016A0B4;

        // The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
        public const uint XONLINE_E_BILLING_PRODUCT_KEY_NOT_AVAILABLE = 0x80161488;

        // Either PIN or Sequence number is required as input parameter to validate Token.
        public const uint XONLINE_E_BILLING_PIN_OR_SEQ_REQUIRED = 0x80161489;

        // Either Token Class Guid or Signature or Part Number should be specified for validating Token.
        public const uint XONLINE_E_BILLING_INPUT_PARAM_MALFORMED = 0x8016148A;

        // The offset must be between -1 and 365 inclusive.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENT_OFFSET = 0x8016CDB7;

        // Invalid item instance ID.
        public const uint XONLINE_E_BILLING_INVALID_ITEM_INSTANCE_ID = 0x8016CDDC;

        // Invalid reason for reverse operation.
        public const uint XONLINE_E_BILLING_INVALID_REVERSE_REASON = 0x8016CDDD;

        // Only 1 item can be purchased at once.
        public const uint XONLINE_E_BILLING_TOO_MANY_ITEMS_IN_PURCHASE = 0x8016CDE0;

        // PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers and the account must be specified, or free trial offer and account must not be specified.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_TYPE = 0x8016CDE1;

        // The price specified must be a positive value.
        public const uint XONLINE_E_BILLING_PRICE_IS_NEGATIVE = 0x8016CDE2;

        // Cannot pass in a price and/or currency because it is configured on the item.
        public const uint XONLINE_E_BILLING_DYNAMIC_PRICE_CONFIGURATION = 0x8016CDE3;

        // The maximum allowable DMP point balance is exceeded.
        public const uint XONLINE_E_BILLING_DMP_MAX_BALANCE_EXCEEDED = 0x8016CDE4;

        // Calling partner needs to add a currency because it is not pre-configured.
        public const uint XONLINE_E_BILLING_CURRENCY_MISSING = 0x8016CDE5;

        // The user already has a pending purchase for for this item that must first be cancelled or completed.
        public const uint XONLINE_E_BILLING_PENDING_ITEM_PURCHASE = 0x8016CDE6;

        // Unable to talk to DMP system.
        public const uint XONLINE_E_BILLING_DMP_FLOW_NOT_ENABLED = 0x8016CDE7;

        // Item has been already reversed.
        public const uint XONLINE_E_BILLING_ITEM_ALREADY_REVERSED = 0x8016CDE8;

        // Reversing an item that has not been fulfilled.
        public const uint XONLINE_E_BILLING_ITEM_NOT_FULFILLED = 0x8016CDE9;

        // Unknown DMP error has occurred.
        public const uint XONLINE_E_BILLING_DMP_UNKNOWN_ERROR = 0x8016CDEA;

        // Payment method type does not support operation.
        public const uint XONLINE_E_BILLING_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 0x8016CDEC;

        // Redirect vendor returned an invalid CancelTransaction result.
        public const uint XONLINE_E_BILLING_INVALID_CANCEL_TRANSACTION_RESULT = 0x8016CDED;

        // CVM code Missing
        public const uint XONLINE_E_BILLING_CVM_MISSING = 0x8016CDEE;

        // A fre Trial cannot be purchased using an account. Use only the PUID
        public const uint XONLINE_E_BILLING_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 0x8016CDEF;

        // Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch
        public const uint XONLINE_E_BILLING_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 0x8016CDF0;

        // The donor and the beneficiary are the same.
        public const uint XONLINE_E_BILLING_DONOR_BENEFICIARY_SAME = 0x8016CDF1;

        // The renewal does not exists.
        public const uint XONLINE_E_BILLING_RENEWAL_DOES_NOT_EXISTS = 0x8016AC9A;

        // The token schedule rennewal exists for this offer.
        public const uint XONLINE_E_BILLING_TOKEN_SCHEDULED_RENEWAL_EXISTS = 0x8016AC9C;

        // Specified Discount is invalid.
        public const uint XONLINE_E_BILLING_INVALID_DISCOUNT = 0x8016ACAD;

        // Could not insert into a discount table.
        public const uint XONLINE_E_BILLING_INSERT_DISCOUNT = 0x8016ACB2;

        // Only one discount permitted per subscription.
        public const uint XONLINE_E_BILLING_DISCOUNT_ALREADY_APPLIED = 0x8016ACB7;

        // Token is a discount coupon yet no discount was passed.
        public const uint XONLINE_E_BILLING_DISCOUNT_REQUIRED_FOR_TOKEN = 0x8016ACBC;

        // Token is a discount coupon and cannot be associated with a deal.
        public const uint XONLINE_E_BILLING_DISCOUNT_TOKEN = 0x8016ACC1;

        // Failed to insert record into discount_localize table.
        public const uint XONLINE_E_BILLING_INSERT_DISCOUNT_LOCALIZE = 0x8016ACC6;

        // Per Account Usage limit was exceeded for discount.
        public const uint XONLINE_E_BILLING_DISCOUNT_USAGE_EXCEEDED = 0x8016ACCB;

        // Token class and discount are not a valid combination.
        public const uint XONLINE_E_BILLING_DISCOUNT_TOKEN_CLASS_MISMATCH = 0x8016ACD0;

        // Partner does not have access to the specified customer type
        public const uint XONLINE_E_BILLING_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 0x8016AD18;

        // Category should not be null.
        public const uint XONLINE_E_BILLING_NULL_CATEGORY = 0x8016AC62;

        // Account ID cannot be null.
        public const uint XONLINE_E_BILLING_NULL_ACCOUNTID = 0x8016AC63;

        // Subscription Ref ID cannot be null.
        public const uint XONLINE_E_BILLING_NULL_SUBSCRIPTIONREFID = 0x8016AC64;

        // Invalid Survey Result Code.
        public const uint XONLINE_E_BILLING_INVALID_SURVEYRESULTCODE = 0x8016AC65;

        // CD not found.
        public const uint XONLINE_E_BILLING_CD_NOTFOUND = 0x8016AC66;

        // Invalid Account ID.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNTID = 0x8016AC67;

        // Invalid AnonymousInfo Xml.
        public const uint XONLINE_E_BILLING_INVALID_ANONYMOUS_INFO_XML = 0x8016AC68;

        // Unsupported object type.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_OBJECT_TYPE = 0x8016AC69;

        // Invalid Phone XML.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_XML = 0x8016AC6A;

        // Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.
        public const uint XONLINE_E_BILLING_INVALID_REQUESTOR_INFO = 0x8016AC6C;

        // There are pending transactions on this deal or subscription.
        public const uint XONLINE_E_BILLING_PENDING_TRANSACTIONS = 0x8016ACAA;

        // The lineitem id and settlement id do not match
        public const uint XONLINE_E_BILLING_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 0x801652D0;

        // Invalid original charge details
        public const uint XONLINE_E_BILLING_INVALID_ORIGINAL_CHARGE_DETAILS = 0x801652D5;

        // Partial Chargeback cannot be Processed
        public const uint XONLINE_E_BILLING_PARTIAL_CHAREGBACK = 0x801652D8;

        // Invalid lineitem id for reversal
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID_FOR_REVERSAL = 0x801652DA;

        // Invalid chargeback date. Chargeback date must greater or equals to original settlement date
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_DATE = 0x801652E9;

        // Invalid chargeback amount.
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_AMOUNT = 0x801652EE;

        // Tax was already offset for this line item.
        public const uint XONLINE_E_BILLING_ALREADY_OFFSET_TAX = 0x801652F1;

        // mappoint is not enabled for the country code.
        public const uint XONLINE_E_BILLING_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 0x80169CEB;

        // SCS had error connecting to mappoint due to some network problems.
        public const uint XONLINE_E_BILLING_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 0x8016CE4F;

        // SCS had some internal error connecting that is preventing connection to mappoint.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 0x8016CE50;

        // Mappoint returned 0 addresses.
        public const uint XONLINE_E_BILLING_ZERO_ADDRESSES_BY_MAPPOINT = 0x8016CE51;

        // UNKNOWN ERROR in MAPPOINT API.
        public const uint XONLINE_E_BILLING_UNKNOWN_ERROR = 0x8016CE52;

        // UNKNOWN ERROR ENCOUNTERED.
        public const uint XONLINE_E_BILLING_UPDATE_ADDRESS_UNKNOWN_ERROR = 0x8016ACA4;

        // Invalid AddressInfo Xml.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESSINFOXML = 0x8016CE54;

        // Mappoint does not support Post Box Addresses currently.
        public const uint XONLINE_E_BILLING_POST_BOX_ERROR_MAPPOINT = 0x8016CE55;

        // The connection to Mappoint has timed out.
        public const uint XONLINE_E_BILLING_MAPPOINT_CONNECTION_MAPPOINT = 0x8016CE56;

        // Invalid Chargeback details provided as input
        public const uint XONLINE_E_BILLING_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 0x8016D818;

        // Chargeback id not found
        public const uint XONLINE_E_BILLING_CHARGEBACK_NOT_FOUND = 0x8016D81D;

        // Chargeback id did not match
        public const uint XONLINE_E_BILLING_CHARGEBACK_NOT_MATCH = 0x8016D827;

        // Double chargeback
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK = 0x8016D836;

        // Invalid chargebacklineitem id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_LINEITEM_ID = 0x8016D83B;

        // Invalid reversal chargeback id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_REVERSAL_ID = 0x8016D84A;

        // Invalid chargeback for reversal chargeback id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 0x8016D84F;

        // invalid lineitem id for chargeback id
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 0x8016D854;

        // invalid lineitem id
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_TYPE = 0x8016D859;

        // Double chargeback for reversal
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK_FOR_REVERSAL = 0x8016D868;

        // The country of the address is not supported at this time
        public const uint XONLINE_E_BILLING_COUNTRY_NOT_SUPPORTED = 0x8016ACA5;

        // SCS has temporarily disabled MAPPOINT support for this country
        public const uint XONLINE_E_BILLING_COUNTRY_MAPPOINT_DISABLED = 0x8016ACA6;

        // The input parameter is incorrect
        public const uint XONLINE_E_BILLING_INVALID_PARAMETER = 0x8016ACA7;

        // Invalid ChargebackID Generation.
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_ID = 0x8016283C;

        // Error when Chargeback Processing Failure.
        public const uint XONLINE_E_BILLING_CHARGEBACK_PROCESSING_FAILURE = 0x8016283D;

        // Invalid Merchant Reference Number.
        public const uint XONLINE_E_BILLING_INVALID_MERCHANT_REFERENCE = 0x8016283E;

        // Error when any input details missing.
        public const uint XONLINE_E_BILLING_CHARGEBACK_INFO_MISSING = 0x8016283F;

        // Error while recording chargeback/reversal in Chargeback History table.
        public const uint XONLINE_E_BILLING_RECORD_CHARGEBACK_FAILED = 0x80162840;

        // Double Chargeback Reversal
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK_REVERSAL = 0x80162841;

        // Chargeback Processing Reversal
        public const uint XONLINE_E_BILLING_REVERSAL_OF_PROCESSED_CHARGEBACK = 0x80162842;

        // Payment instrument not associated with subscription
        public const uint XONLINE_E_BILLING_MISMATCH_PAYMENT_SUBSCRIPTION = 0x80162843;

        // Subscription already converted or renewed
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 0x80162844;

        // Merchant Reference Number missing
        public const uint XONLINE_E_BILLING_MERCHANT_REFERENCE_NUMBER_MISSING = 0x80162845;

        // Invalid Encrypt Account number
        public const uint XONLINE_E_BILLING_INVALID_ENCRYPT_ACCOUNT_NUMBER = 0x80162846;

        // Subscription has been scheduled to renew
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_SCHEDULED_RENEWAL = 0x80162847;

        // Account holder's profile already exists.
        public const uint XONLINE_E_BILLING_PROFILE_ALREADY_EXISTS = 0x80162848;

        // Account holder's profile does not exist.
        public const uint XONLINE_E_BILLING_PROFILE_DOES_NOT_EXIST = 0x80162849;

        // Account does not have an address associated with it.
        public const uint XONLINE_E_BILLING_ACCOUNT_WITHOUT_ADDRESS = 0x8016284A;

        // Payout preference (default) is not set.
        public const uint XONLINE_E_BILLING_NO_PAYOUT_PREFERENCE = 0x8016284B;

        // Payout preference (default) can not be deleted.
        public const uint XONLINE_E_BILLING_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 0x8016284C;

        // Invalid PayUserInfo XML.
        public const uint XONLINE_E_BILLING_INVALID_PAYUSERINFOXML = 0x8016284D;

        // Invalid UserProfile XML.
        public const uint XONLINE_E_BILLING_INVALID_USERPROFILEXML = 0x8016284E;

        // Account ID must not be specified.
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 0x8016284F;

        // Description length exceeded
        public const uint XONLINE_E_BILLING_DESCRIPTION_MAXLENGTH_EXCEEDED = 0x80162850;

        // RiME returns "Rejected"
        public const uint XONLINE_E_BILLING_RIME_REJECTED = 0x80162851;

        // Invalid Values were sent to RiME
        public const uint XONLINE_E_BILLING_RIME_INVALID_VALUE = 0x80162852;

        // Referral code not found in SCS database
        public const uint XONLINE_E_BILLING_REFERRAL_CODE_NOT_FOUND = 0x8016AC59;

        // There is no existing provisioning information to complete this call
        public const uint XONLINE_E_BILLING_MISSING_PROV_INFO = 0x8016D2FD;

        // Invalid Resource Type
        public const uint XONLINE_E_BILLING_INVALID_RESOURCE_TYPE = 0x8016AC5A;

        // fail when submit to payment provider
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_SUBMISSION_FAILED = 0x80164E2A;

        // declined when submit to payment provider
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 0x80164E2B;

        // fail to encrypt file
        public const uint XONLINE_E_BILLING_ENCRYPTION_FAILURE = 0x80164E2C;

        // BDK_E_DMP_FIRST
        public const uint XONLINE_E_BILLING_DMP_FIRST = 0x8016FA00;

        // BDK_E_DMP_LAST
        public const uint XONLINE_E_BILLING_DMP_LAST = 0x8016FDE7;

        // Invalid target user information specified
        public const uint XONLINE_E_BILLING_INVALID_TARGET_USER_INFORMATION = 0x80167918;

        // Invalid delegate user information
        public const uint XONLINE_E_BILLING_INVALID_DELEGATE_USER_INFORMATION = 0x80167919;

        // Invalid source information
        public const uint XONLINE_E_BILLING_INVALID_SOURCE_USER_INFORMATION = 0x8016791A;

        // Invalid transaction Id
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_INFORMATION = 0x8016791B;

        // Transaction information passed in does not match the information stored
        public const uint XONLINE_E_BILLING_NO_MATCHING_TRANSACTION = 0x8016791C;

        // Unable to find transaction in PENDING_PAYOUT state matching the input parameters
        public const uint XONLINE_E_BILLING_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 0x8016791D;

        // Unable to find transaction in PENDING state matching the input parameters
        public const uint XONLINE_E_BILLING_NO_MATCHING_PENDING_TRANSACTION = 0x8016791E;

        // BDK_E_ORDER_LAYER_FIRST
        public const uint XONLINE_E_BILLING_ORDER_LAYER_FIRST = 0x8016DAC1;

        // BDK_E_ORDER_LAYER_LAST
        public const uint XONLINE_E_BILLING_ORDER_LAYER_LAST = 0x8016DEA8;

        // BDK_E_TRANSACTION_LAYER_FIRST
        public const uint XONLINE_E_BILLING_TRANSACTION_LAYER_FIRST = 0x8016DEA9;

        // BDK_E_TRANSACTION_LAYER_LAST
        public const uint XONLINE_E_BILLING_TRANSACTION_LAYER_LAST = 0x8016E290;

        // SCS_E_CERT_INAVLID
        public const uint XONLINE_E_BILLING_CERT_INAVLID = 0x8016E678;

        // SCS_E_INAVLID_CALLING_PARTNER
        public const uint XONLINE_E_BILLING_INAVLID_CALLING_PARTNER = 0x8016E679;

        // BDK_E_RISK_EVALUATION_FAILED
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_FAILED = 0x8016FDE9;

        // BDK_E_RISK_EVALUATION_EXCEPTION
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_EXCEPTION = 0x8016FDEA;

        // BDK_E_RISK_EVALUATION_UNDEFINED
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_UNDEFINED = 0x8016FDEB;

        // BDK_E_RISK_CONFIGURATION_ERROR
        public const uint XONLINE_E_BILLING_RISK_CONFIGURATION_ERROR = 0x8016FDEC;

        // BDK_E_RISK_NEXT
        public const uint XONLINE_E_BILLING_RISK_NEXT = 0x8016FDED;

        // Apartment number missing or not found
        public const uint XONLINE_E_BILLING_DAV_APARTMENT = 0x8016FE4C;

        // Insufficient address information
        public const uint XONLINE_E_BILLING_DAV_INSUFFICIENT = 0x8016FE4D;

        // House number or PO box not found
        public const uint XONLINE_E_BILLING_DAV_ID = 0x8016FE4E;

        // Multiple address matches found
        public const uint XONLINE_E_BILLING_DAV_MULTIPLE = 0x8016FE4F;

        // PO box identifier out of range
        public const uint XONLINE_E_BILLING_DAV_POBOX = 0x8016FE50;

        // Route service identified out of range
        public const uint XONLINE_E_BILLING_DAV_ROUTE = 0x8016FE51;

        // Street name not found
        public const uint XONLINE_E_BILLING_DAV_STREET = 0x8016FE52;

        // Postal code not found
        public const uint XONLINE_E_BILLING_DAV_POSTAL = 0x8016FE53;

        // Genreal address error
        public const uint XONLINE_E_BILLING_DAV_GENERAL = 0x8016FE54;

        // Missing required address field(s)
        public const uint XONLINE_E_BILLING_DAV_MISSING_DATA = 0x8016FE55;

        // Invalid address field(s)
        public const uint XONLINE_E_BILLING_DAV_INVALID_DATA = 0x8016FE56;

        // System failure during address check
        public const uint XONLINE_E_BILLING_DAV_SYSTEM_FAILURE = 0x8016FE57;

        // Timeout during DAV check
        public const uint XONLINE_E_BILLING_DAV_TIMEOUT = 0x8016FE58;

        // Delivery Address Verification system is not available at this time
        public const uint XONLINE_E_BILLING_DAV_DISABLED = 0x8016FE59;

        // BDK_E_RISK_LAST
        public const uint XONLINE_E_BILLING_RISK_LAST = 0x8016FFFF;

     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XonCTPHResult.cs ===
using System;

namespace STF.common.service
{
    /// <summary>
    /// CTP Error codes
    /// If a new error code is added by CTP then corresponding HRESULT needs to be added here as well.
    /// </summary>
    public partial struct HResult
    {
        // "Null input parameter passed to a ban API."
        public const uint XONLINE_E_CTP_BDK_E_BAN_NULL_INPUT_PARAMETER = 0x80190001;
        // "Already banned."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_BANNED = 0x80190002;
        // "Not banned."
        public const uint XONLINE_E_CTP_BDK_E_NOT_BANNED = 0x80190003;
        // "This account is banned."
        public const uint XONLINE_E_CTP_BDK_E_BANNEDPERSON = 0x80190004;
        // "Country/currency/payment instrument type mismatch."
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_CURRENCY_PI_MISMATCH = 0x80190005;
        // "Invalid payment instrument type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x80190006;
        // "Invalid credit card type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_CARD_TYPE = 0x80190007;
        // "Decryption failed. Verify that data is encrypted correctly."
        public const uint XONLINE_E_CTP_BDK_E_DECRYPTION_FAILURE = 0x80190008;
        // "Payment instrument is banned."
        public const uint XONLINE_E_CTP_BDK_E_BANNED_PAYMENT_INSTRUMENT = 0x80190009;
        // "Direct debit account validation failed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DD_ACCOUNT = 0x80190010;
        // "Concatenated direct debit account number exceeds 24 characters."
        public const uint XONLINE_E_CTP_BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x80190011;
        // "Invalid credit card number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_CARD_NUMBER = 0x80190012;
        // "Credit card has already expired."
        public const uint XONLINE_E_CTP_BDK_E_CREDIT_CARD_EXPIRED = 0x80190013;
        // "Address verification failed."
        public const uint XONLINE_E_CTP_BDK_E_AVS_FAILED = 0x80190014;
        // "Address verification through AVS did not provide a result."
        public const uint XONLINE_E_CTP_BDK_E_NO_AVS_RESULT = 0x80190015;
        // "Payment Instrument authorization failed."
        public const uint XONLINE_E_CTP_BDK_E_AUTHORIZATION_FAILED = 0x80190016;
        // "Unable to connect to payment provider."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x80190017;
        // "Invalid country code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_COUNTRY = 0x80190018;
        // "Invalid account format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_FORMAT = 0x80190019;
        // "Invalid bank code format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BANKCODE_FORMAT = 0x80190020;
        // "Invalid branch code format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BRANCHCODE_FORMAT = 0x80190021;
        // "Invalid check digit format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_CHECKDIGIT_FORMAT = 0x80190022;
        // "Account missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_ACCOUNT_MISSING = 0x80190023;
        // "Bank code missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_BANKCODE_MISSING = 0x80190024;
        // "Branch code missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_BRANCHCODE_MISSING = 0x80190025;
        // "Check digit missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_CHECKDIGIT_MISSING = 0x80190026;
        // "Some fields have errors."
        public const uint XONLINE_E_CTP_BDK_E_DD_ERROR_IN_FIELDS = 0x80190027;
        // "Invalid account code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_VALUE = 0x80190028;
        // "Invalid bank code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BANKCODE_VALUE = 0x80190029;
        // "Invalid branch code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BRANCHCODE_VALUE = 0x80190030;
        // "Invalid check digit."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_CHECKDIGIT_VALUE = 0x80190031;
        // "Account holder name not specified or it exceeds 35 characters."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x80190032;
        // "Soap call to provider failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNKNOWN_PROVIDER_FAILURE = 0x80190033;
        // "Payment provider connection timed out."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x80190034;
        // "Transaction declined by payment provider."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 0x80190035;
        // "Payment provider error."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INITIATE_TRANSACTION_RESULT = 0x80190036;
        // "The wholesale partner specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_WHOLESALE_PARTNER = 0x80190037;
        // "PI Not Supported in this version"
        public const uint XONLINE_E_CTP_BDK_E_PI_NOT_SUPPORTED = 0x80190038;
        // "A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually."
        public const uint XONLINE_E_CTP_BDK_E_UPS_NOT_UPDATED = 0x80190039;
        // "This branch will not support Direct Debit transactions."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNSUPPORTED = 0x80190040;
        // "Internal error
        public const uint XONLINE_E_CTP_BDK_E_DD_MPF_NON_XML_RESPONSE = 0x80190041;
        // "Internal error
        public const uint XONLINE_E_CTP_BDK_E_DD_MPF_INCORRECT_XML_FORMAT = 0x80190042;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_NON_XML_RESPONSE = 0x80190043;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_INCORRECT_XML_FORMAT = 0x80190044;
        // "Global collect failed to process this request
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_RETURNED_NOK_RESULT = 0x80190045;
        // "Direct Debit account Check performed by Global Collect is not complete for this account."
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_CHECK_INCOMPLETE = 0x80190046;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x80190047;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_XML_INVALID_CHECK_RESULT = 0x80190048;
        // "Global collect returned non null Reformatted Bank Code though the input Bank code was blank."
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_INVALID_RFBANKCODE = 0x80190049;
        // "Invalid payment instrument details."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x80190050;
        // "Invalid ban reason code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BAN_REASON_CODE = 0x80190051;
        // "Invalid encrypted CVM code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CVM_CODE = 0x80190052;
        // "Unexpected CVM response code."
        public const uint XONLINE_E_CTP_BDK_E_UNEXPECTED_CVM_RESPONSE_CODE = 0x80190053;
        // "CVM check failed."
        public const uint XONLINE_E_CTP_BDK_E_CVM_FAILED = 0x80190054;
        // "Immediate settlement failed"
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLEMENT_FAILURE = 0x80190055;
        // "Frequency check failed."
        public const uint XONLINE_E_CTP_BDK_E_FREQUENCY_CHECK_FAILED = 0x80190056;
        // "Invalid merchant index."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_MERCHANT_INDEX = 0x80190057;
        // "Duplicate merchant reference."
        public const uint XONLINE_E_CTP_BDK_E_DD_DUPLICATE_MRN = 0x80190058;
        // "Account validation failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNKNOWN_VALIDATION_FAILURE = 0x80190059;
        // "Bank account type may not be specified for this country."
        public const uint XONLINE_E_CTP_BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 0x80190060;
        // "Bank account type is required for this country."
        public const uint XONLINE_E_CTP_BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 0x80190061;
        // "Risk check failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_RISK_DECLINE = 0x80190062;
        // "Unable to validate the tax ID."
        public const uint XONLINE_E_CTP_BDK_E_UNABLE_TO_VALIDATE_TAX_ID = 0x80190063;
        // "Number of updates allowed in a period has exceeded the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 0x80190064;
        // "External vendor error."
        public const uint XONLINE_E_CTP_BDK_E_EXTERNAL_VENDOR_ERROR = 0x80190065;
        // "Object is already in the specified state."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_IN_SPECIFIED_STATE = 0x80190066;
        // "Required search criteria field missing. Either a phone number or both first name and last name is required."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_SEARCH_CRITERIA = 0x80190067;
        // "Required field missing."
        public const uint XONLINE_E_CTP_BDK_E_REQUIRED_FIELD_MISSING = 0x80190068;
        // "The account has subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVE_SUBSCRIPTIONS = 0x80190069;
        // "Unexpected field"
        public const uint XONLINE_E_CTP_BDK_E_UNEXPECTED_FIELD = 0x80190070;
        // "Invalid account source."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNT_SOUCE = 0x80190071;
        // "Creation date/time cannot be later than current date/time."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREATION_DATE = 0x80190072;
        // "No more tax exemptions are allowed for this account."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80190073;
        // "Generating next ID."
        public const uint XONLINE_E_CTP_BDK_E_GENERATE_NEXT_ID = 0x80190074;
        // "State invalid for the country."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATE_FOR_COUNTRY = 0x80190075;
        // "Country for address provided does not match existing country for account."
        public const uint XONLINE_E_CTP_BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80190076;
        // "The offering requested is not available in the country of this account."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80190077;
        // "Invalid account."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLE_ACCOUNT_ID = 0x80190078;
        // "Invalid account status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80190079;
        // "Invalid phone type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_TYPE = 0x80190080;
        // "Invalid offering."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_ID = 0x80190081;
        // "The combination of data passed to PurchaseOffering is invalid for the scenario."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PURCHASE_INPUT_DATA = 0x80190082;
        // "UPS profile is missing either FirstName
        public const uint XONLINE_E_CTP_BDK_E_PUID_MISSING_ATTRIBUTE = 0x80190083;
        // "Invalid country code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COUNTRY_CODE = 0x80190084;
        // "Invalid address ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESS_ID = 0x80190085;
        // "Invalid payment instrument ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_METHOD_ID = 0x80190086;
        // "Cannot exceed max ownership for the payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_PI_EXECEED_MAX_OWNER_SHIP = 0x80190087;
        // "Subscription is already cancelled."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_ALREADY_CANCELED = 0x80190088;
        // "A delayed expire request is already pending and should not be requested again."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_ALREADY_PENDING = 0x80190089;
        // "A delayed expire is not pending and cannot be undone."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_NOT_PENDING = 0x80190090;
        // "A delayed expire is not support unless the subscription is active with no term commits."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED = 0x80190091;
        // "The value specified for the cancel option/date should be DELAYED_EXPIRE
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CANCEL_DATE = 0x80190092;
        // "Invalid subscription ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_ID = 0x80190093;
        // "Invalid period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PERIOD_TO_PROCESS = 0x80190094;
        // "Invalid subscription status or invalid operation for the status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_STATUS = 0x80190095;
        // "Account is inactive."
        public const uint XONLINE_E_CTP_BDK_E_NON_ACTIVE_ACCOUNT = 0x80190096;
        // "VATIDs do not have an expiration date."
        public const uint XONLINE_E_CTP_BDK_E_VATID_DOESNOTHAVEEXPDATE = 0x80190097;
        // "Expiration date was not specified."
        public const uint XONLINE_E_CTP_BDK_E_TAXID_EXPDATE = 0x80190098;
        // "Invalid tax exemption type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_TYPE = 0x80190099;
        // "Invalid Tax Exempt Billable Account Id specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 0x80190100;
        // "No active subscription for adding a service instance."
        public const uint XONLINE_E_CTP_BDK_E_NO_ACTIVE_SUBSCRIPTION = 0x80190101;
        // "Invalid service instance for adding a new user."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SERVICE_INSTANCE = 0x80190102;
        // "Failed to add a new user to a service instance."
        public const uint XONLINE_E_CTP_BDK_E_ADD_USER_TO_SERVICE_INSTANCE = 0x80190103;
        // "Status change not allowed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLEACCTSTATUS = 0x80190104;
        // "No service instances available for the billable account."
        public const uint XONLINE_E_CTP_BDK_E_SERVICE_INSTANCES_NONE = 0x80190105;
        // "Account is already closed."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_CLOSED = 0x80190106;
        // "Period is already past."
        public const uint XONLINE_E_CTP_BDK_E_BILLINGPERIOD_PAST = 0x80190107;
        // "Invalid adjustment GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSTMENTGUID = 0x80190108;
        // "Adjustment not applicable to the specified period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSMENT_FOR_PERIOD = 0x80190109;
        // "Adjustment amount is too large."
        public const uint XONLINE_E_CTP_BDK_E_ADJUSTMENT_TOOBIG = 0x80190110;
        // "Adjustment amount is too small."
        public const uint XONLINE_E_CTP_BDK_E_ADJUSTMENT_TOOSMALL = 0x80190111;
        // "Invalid locale."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LOCALE = 0x80190112;
        // "Invalid customer type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUSTOMER_TYPE = 0x80190113;
        // "Invalid currency."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CURRENCY = 0x80190114;
        // "Date is already expired."
        public const uint XONLINE_E_CTP_BDK_E_DATE_EXPIRED = 0x80190115;
        // "GUID already exists."
        public const uint XONLINE_E_CTP_BDK_E_GUID_EXISTS = 0x80190116;
        // "Invalid violation ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VIOLATION_ID = 0x80190117;
        // "Violation ID is required."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_VIOLATION_ID = 0x80190118;
        // "De-provision service instances before proceeding."
        public const uint XONLINE_E_CTP_BDK_E_NEEDTODEPROVISION = 0x80190119;
        // "Partial conversion is already initiated."
        public const uint XONLINE_E_CTP_BDK_E_PARTIALCONV_INITIATED = 0x80190120;
        // "The currency of the account cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_UPDATE_CURRENCY = 0x80190121;
        // "Subscription is expected to be in the partial state."
        public const uint XONLINE_E_CTP_BDK_E_PARTIALCONV_EXPECTED = 0x80190122;
        // "Invalid category. Valid category name has a size limit of 50 characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CATEGORY_NAME = 0x80190123;
        // "Offering cannot be purchased."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_NOT_PURCHASEABLE = 0x80190124;
        // "Offering currency does not match account currency."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80190125;
        // "Offering does not support payment instrument type."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80190126;
        // "Invalid date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DATE = 0x80190127;
        // "Cannot exceed max ownership for the offering."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80190128;
        // "Invalid resource ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RESOURCE_ID = 0x80190129;
        // "Unit of measure reported in the usage event does not match the one in SPS."
        public const uint XONLINE_E_CTP_BDK_E_UNIT_OF_MEASURE_MISMATCH = 0x80190130;
        // "Event date is before the subscription purchase date."
        public const uint XONLINE_E_CTP_BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80190131;
        // "Offering invalid for the locale."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_FOR_LOCALE = 0x80190132;
        // "Offering is not a base offering."
        public const uint XONLINE_E_CTP_BDK_E_NOT_A_BASE_OFFERING = 0x80190133;
        // "There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80190134;
        // "Offering is invalid for Country."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_FOR_COUNTRY = 0x80190135;
        // "The offering requested conflicts with an existing subscription on this account."
        public const uint XONLINE_E_CTP_BDK_E_MEG_CONFLICT = 0x80190136;
        // "Account state does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNT_STATUS = 0x80190137;
        // "Payment instrument has active subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80190138;
        // "The account has billing charges."
        public const uint XONLINE_E_CTP_BDK_E_EXISTING_BILLING_ACTIVITY = 0x80190139;
        // "Subscription is in an invalid state for this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80190140;
        // "Primary phone required for payment instruments."
        public const uint XONLINE_E_CTP_BDK_E_PRIMARY_PHONE_REQUIRED = 0x80190141;
        // "Account requires an e-mail address for this operation."
        public const uint XONLINE_E_CTP_BDK_E_EMAIL_REQUIRED = 0x80190142;
        // "To perform this operation
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_NOT_CLOSED = 0x80190143;
        // "Invalid violation ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VIOLATION = 0x80190144;
        // "Subscription is cancelled and cannot change status."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_IS_CANCELLED = 0x80190145;
        // "Subscription has no violations."
        public const uint XONLINE_E_CTP_BDK_E_NO_VIOLATION = 0x80190146;
        // "Subscription has violations."
        public const uint XONLINE_E_CTP_BDK_E_EXISTS_VIOLATION = 0x80190147;
        // "Invalid Service Component Id was passed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SERVICE_COMPONENT_ID = 0x80190148;
        // "End date is already past."
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_IN_THE_PAST = 0x80190149;
        // "End date passed in is later than the latest allowable end date for this subscription."
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_BEYOND_MAX = 0x80190150;
        // "Violation is already set."
        public const uint XONLINE_E_CTP_BDK_E_VIOLATION_ALREADY_SET = 0x80190151;
        // "Violation ID not set."
        public const uint XONLINE_E_CTP_BDK_E_NO_VIOLATION_SET = 0x80190152;
        // "Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CONVERSION = 0x80190153;
        // "Subscription is not in the partial state."
        public const uint XONLINE_E_CTP_BDK_E_SUBS_NOT_INTERMEDIATE = 0x80190154;
        // "Offering is not published."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_NOT_PUBLISHED = 0x80190155;
        // "Service instances must be de-provisioned to proceed."
        public const uint XONLINE_E_CTP_BDK_E_CONVERSION_NEEDTODEPROVISION = 0x80190156;
        // "Invalid mandate status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MANDATE_STATUS = 0x80190157;
        // "Payment instrument status is already GOOD."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_GOOD = 0x80190158;
        // "Payment instrument status is already DECLINED."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_DECLINED = 0x80190159;
        // "Payment instrument status is DISABLED and cannot be changed."
        public const uint XONLINE_E_CTP_BDK_E_PI_IS_DISABLED = 0x80190160;
        // "SAP Number is required for Invoice PI."
        public const uint XONLINE_E_CTP_BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED = 0x80190161;
        // "Invoice XML was invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INVOICE_INFO_XML = 0x80190162;
        // "Max Limit for this PI Type within account reached."
        public const uint XONLINE_E_CTP_BDK_E_MAX_PI_PER_ACCOUNT_REACHED = 0x80190163;
        // "PI country does not match Account country."
        public const uint XONLINE_E_CTP_BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH = 0x80190164;
        // "An error occured. Try again later."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_OCCURRED_TRY_LATER = 0x80190165;
        // "An error occured."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_OCCURRED = 0x80190166;
        // "Payment instrument exists or the payment instrument status is invalid or does not allow the operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80190167;
        // "Invalid offering GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_GUID = 0x80190168;
        // "Offering requires a payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_REQUIRES_PI = 0x80190169;
        // "Offering cannot be purchased because it has delayed provisioning components."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80190170;
        // "Invalid currency format."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_FOR_CURRENCY = 0x80190171;
        // "Invalid e-mail address."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EMAIL_ADDRESS = 0x80190172;
        // "Invalid tax exemption status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_STATUS = 0x80190173;
        // "No valid tax exemption certificates exist for the account."
        public const uint XONLINE_E_CTP_BDK_E_NO_VALID_TAX_EXEMPTION = 0x80190174;
        // "Invalid tax exemption status change."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE = 0x80190175;
        // "The status of the old payment instrument does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80190176;
        // "The specified start period is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_START_PERIOD = 0x80190177;
        // "The specified end period is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_PERIOD = 0x80190178;
        // "The specified Detailed level is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DETAILEDLEVEL = 0x80190179;
        // "Difference between BeginDate and EndDate is more than 6 months"
        public const uint XONLINE_E_CTP_BDK_E_EXCEED_DATERANGE_LIMIT = 0x80190180;
        // "Begin Date can never be greater than EndDate"
        public const uint XONLINE_E_CTP_BDK_E_WRONG_DATERANGE = 0x80190181;
        // "Begin date is not valid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BEGIN_DATE = 0x80190182;
        // "End date is not valid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_DATE = 0x80190183;
        // "End date is greater than the current date"
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE = 0x80190184;
        // "SPS is in compute-only mode."
        public const uint XONLINE_E_CTP_BDK_E_COMPUTE_ONLY = 0x80190185;
        // "Detected that month(s) were missed in periodic processing."
        public const uint XONLINE_E_CTP_BDK_E_MISSED_PROCESSING_PERIOD = 0x80190186;
        // "Subscription is not expired."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_NOT_EXPIRED = 0x80190187;
        // "Subscription can no longer be reinstated."
        public const uint XONLINE_E_CTP_BDK_E_TOOLATE_REINSTATE = 0x80190188;
        // "Only a single Referral node may be passed in to this API."
        public const uint XONLINE_E_CTP_BDK_E_EXTRA_REFERRAL_DATA = 0x80190189;
        // "bstrReferralIDSetXML parameter must be left empty for this API."
        public const uint XONLINE_E_CTP_BDK_E_NO_REFERRAL_UPDATES_ALLOWED = 0x80190190;
        // "Cannot schedule a new renewal because there exists already a free renewal on the subscription."
        public const uint XONLINE_E_CTP_BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS = 0x80190191;
        // "Cannot convert a deal with multiple components with delayed provisioning."
        public const uint XONLINE_E_CTP_BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 0x80190192;
        // "The specified cobrand is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COBRAND = 0x80190193;
        // "This operation is not valid for wholesale subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80190194;
        // "HCI not valid for Account Id."
        public const uint XONLINE_E_CTP_BDK_E_HCI_NOT_VALID = 0x80190195;
        // "Taiwan users cannot opt out of hard copy tax invoices."
        public const uint XONLINE_E_CTP_BDK_E_CANT_STOP_TAIWAN_TAXINV = 0x80190196;
        // "Adjusting a resource balance is not allowed for subscriptions that are not active."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80190197;
        // "The type of the token specified was invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_TYPE = 0x80190198;
        // "The token Id specified is not valid for the given offering."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_VALID_FOR_OFFERING = 0x80190199;
        // "Deal Token mapping currently not present in the system to be marked as invalid."
        public const uint XONLINE_E_CTP_BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT = 0x80190200;
        // "Maximum consumption count per user reached."
        public const uint XONLINE_E_CTP_BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 0x80190201;
        // "Error in inserting a new row in table user_token_hash."
        public const uint XONLINE_E_CTP_BDK_E_INSERTING_USER_TOKEN_HASH = 0x80190202;
        // "A token Id and a payment instrument Id cannot both be specified."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED = 0x80190203;
        // "The token class is invalid or does not exist."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CLASS_INVALID = 0x80190204;
        // "The Input TokenClass Restriction Info Filter is Missing."
        public const uint XONLINE_E_CTP_BDK_E_INPUT_FILTER_XML_MISSING = 0x80190205;
        // "Unable to find the token mapping to the specified token class."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CLASS_NOT_FOUND = 0x80190206;
        // "Invalid TokenClass Restriction Info Filter."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_FILTER_XML = 0x80190207;
        // "A payment instrument cannot be specified."
        public const uint XONLINE_E_CTP_BDK_E_PI_CANNOT_BE_SPECIFIED = 0x80190208;
        // "The subscription specified is not a PrePaid subscription."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_NOT_PREPAID = 0x80190209;
        // "The total number of extended days cannot be less than zero."
        public const uint XONLINE_E_CTP_BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x80190210;
        // "The number of days specified is invalid
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_DAYS = 0x80190211;
        // "The number of months specified is invalid
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_MONTHS = 0x80190212;
        // "The total number of extended days is greater than the maximum allowed for the current subscription."
        public const uint XONLINE_E_CTP_BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x80190213;
        // "The deal specified requires a valid Prepaid Token Id to be specified."
        public const uint XONLINE_E_CTP_BDK_E_PREPAID_TOKEN_IS_REQUIRED = 0x80190214;
        // "There are remaining cycles on the current term commit."
        public const uint XONLINE_E_CTP_BDK_E_TERM_COMMIT_EXISTS = 0x80190215;
        // "The specified token cannot be used for the current operation."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_APPLICABLE = 0x80190216;
        // "Renewal cannot be scheduled if there is already a token based renewal present."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RENEWAL_PRESENT = 0x80190217;
        // "Error subscription duration exceeds max duration."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAXIMUM_DURATION = 0x80190218;
        // "Error conversion credits were applied but the offer does not support conversion credits."
        public const uint XONLINE_E_CTP_BDK_E_CONVERSION_CREDITS_NOT_ENABLED = 0x80190219;
        // "Only BillableAccountAdmin can add the PI."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USERROLE_FOR_ADDPI = 0x80190220;
        // "Not authorized to use the tax rule configuration group."
        public const uint XONLINE_E_CTP_BDK_E_NOT_AUTHORIZED_TAX_RULE_CONFIG_GROUP = 0x80190221;
        // "BlacklistToken found actions to take
        public const uint XONLINE_E_CTP_BDK_E_BLACKLIST_ACTION_NOT_PERFORMED = 0x80190222;
        // "BlacklistToken was called with invalid bstrSubscriptionAction parameter."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_ACTION = 0x80190223;
        // "Invalid distribution channel specified for token class part number."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x80190224;
        // "Invalid length for token class part number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_PART_NUMBER = 0x80190225;
        // "nvalid length for SAP customer name."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_SAP_CUST_NAME = 0x80190226;
        // "Invalid length for Support Vendor name."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x80190227;
        // "Failed while inserting in partner_token_class table."
        public const uint XONLINE_E_CTP_BDK_E_INSERING_TOKEN_CLASS_PARTNER = 0x80190228;
        // "Token Part Number is currently associated with other token class please remove the association from the other token class and try again."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x80190229;
        // "A token is being delivered to the same service instance at this moment. Please retry."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_DELIVERED = 0x80190230;
        // "A Token passed in does not have an associated Distribution batch."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID = 0x80190231;
        // "A Distribution Batch associated with the passed in Token is in inactive state."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 0x80190232;
        // "A Distribution Program is in inactive state."
        public const uint XONLINE_E_CTP_BDK_E_DISTRIBUTION_PROGRAM_INACTIVE = 0x80190233;
        // "Failed while inserting in reconcile_history table."
        public const uint XONLINE_E_CTP_BDK_E_INSERTING_RECONCILE_HISTORY = 0x80190234;
        // "Specified Token is already issued."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_ISSUED = 0x80190235;
        // "Specified Token is already unissued
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_UNISSUED = 0x80190236;
        // "Failed to update the token issue status in token_instance table."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ISSUE_UPDATE = 0x80190237;
        // "The input parameter combination does not match the system."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COMBINATION = 0x80190238;
        // "Invalid Replacement Reason code specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REPLACEMENT_REASON_CODE = 0x80190239;
        // "The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value."
        public const uint XONLINE_E_CTP_BDK_E_MAX_REPLACEMENT_REACHED = 0x80190240;
        // "Token Replacement failed due to unknown error."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_REPLACEMENT_FAILED = 0x80190241;
        // "Failed to update Token Distribution status."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x80190242;
        // "Signature does not belong to specified Token."
        public const uint XONLINE_E_CTP_BDK_E_SIGNATURE_TOKEN_MISMATCH = 0x80190243;
        // "Invalid Token Staus Name specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATUS_NAME = 0x80190244;
        // "Invalid distribution status to issue token."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x80190245;
        // "Specified token is replaced token
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_REPLACED_TOKEN = 0x80190246;
        // "Invalid Partner specified or the partner does not have permission to take action on specified token."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ACTION_ACCESS_DENIED = 0x80190247;
        // "Specified partner does not exist."
        public const uint XONLINE_E_CTP_BDK_E_NOT_EXISTS_PARTNER = 0x80190248;
        // "Specified reseller PKPN is duplicated with the existing PKPN configured by PCT."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATED_PKPN_WITH_PCT = 0x80190249;
        // "Specified reseller token part number does not exist."
        public const uint XONLINE_E_CTP_BDK_E_NOT_EXISTS_PKPN = 0x80190250;
        // "Specified reseller token instance has already been blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_RESELLER_TOKEN_BLACKLISTED = 0x80190251;
        // "Specified reseller token instance has already been consumed."
        public const uint XONLINE_E_CTP_BDK_E_RESELLER_TOKEN_CONSUMED = 0x80190252;
        // "Server internal error occurred."
        public const uint XONLINE_E_CTP_BDK_E_SERVER_INTERNAL_ERROR = 0x80190253;
        // "Specified reseller channel SKU is duplicated with the existing channel SKU configured by PCT."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATED_CHANNELSKU_WITH_PCT = 0x80190254;
        // "Percentage on ChannelSKU-PKPN mapping cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_CHANNELSKU_PKPN_PERCENTAGE_CANNOT_UPDATE = 0x80190255;
        // "ChannelSKU-PKPN mappings cannot be added after setup."
        public const uint XONLINE_E_CTP_BKE_E_CHANNELSKU_PKPN_MAPPING_CANNOT_ADD = 0x80190256;
        // "Sum of all PKPNs' percentage under one channel sku should be less than or equal 1."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PKPN_ALLOCATION = 0x80190257;
        // "The input token number in batch exceeds max allowerd number."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_TOKEN_INSTANCE = 0x80190258;
        // "Value for returnStatementSet parameter must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x80190259;
        // "The begin billing period is not valid for this account."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BEGIN_BILLING_PERIOD = 0x80190260;
        // "The end billing period is not valid for this account."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_BILLING_PERIOD = 0x80190261;
        // "The billing period value cannot be negative."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_PERIOD_NEGATIVE = 0x80190262;
        // "The end period must be greater than start period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_START_END_BILLING_PERIOD = 0x80190263;
        // "The account history date cannot be greater than the current date."
        public const uint XONLINE_E_CTP_BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x80190264;
        // "Cannot pass null for all parameters."
        public const uint XONLINE_E_CTP_BDK_E_NO_NON_NULL_PARAMS = 0x80190265;
        // "The billing period value must be of the format YYYYMM (Y representing the year and M representing month)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x80190266;
        // "The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration)."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x80190267;
        // "The offering guid passed in does not match offering guid on subscription."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_SUB_ID_OFFER_GUID = 0x80190268;
        // "The event time stamp is too far in future."
        public const uint XONLINE_E_CTP_BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x80190269;
        // "The policy GuidID/Version combination supplied does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_POLICY_ID = 0x80190270;
        // "The offering specified does not support the country of payment instrument being used."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_PI_COUNTRY_MISMATCH = 0x80190271;
        // "Error inserting into table agreement_signature."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_AGREEMENT_SIGNATURE = 0x80190272;
        // "Agreement for this subscription has already been signed by this user at a different time."
        public const uint XONLINE_E_CTP_BDK_E_AGREEMENT_ALREADY_SIGNED = 0x80190273;
        // "The specified policy has not been localized in the specified locale."
        public const uint XONLINE_E_CTP_BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80190274;
        // "The policy specified is valid but the version is incorrect."
        public const uint XONLINE_E_CTP_BDK_E_POLICY_DEAL_VERSION_MISMATCH = 0x80190275;
        // "The policy specified exists but is not valid on the deal/country combination of the supplied subscription."
        public const uint XONLINE_E_CTP_BDK_E_POLICY_DEAL_COUNTRY_MISMATCH = 0x80190276;
        // "The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x80190277;
        // "A payment instrument cannot specified when the conversion mode is RENEW."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW = 0x80190278;
        // "Renewing from a perpetual offering is not allowed."
        public const uint XONLINE_E_CTP_BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x80190279;
        // "Tax Exempt Certificate Number is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TECERTIFICATENUMBER = 0x80190280;
        // "Conversions between wholesale offers are not allowed."
        public const uint XONLINE_E_CTP_BDK_E_NO_WHOLESALE_TO_WHOLESALE = 0x80190281;
        // "The status of the new payment instrument specified does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x80190282;
        // "Renewal does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RENEWAL = 0x80190283;
        // "The length of phone number is greater than expected."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_PHONE_STRING_TOOLONG = 0x80190284;
        // "The calling partner does not have access to the token class."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x80190285;
        // "Last administrator role on the account cannot be removed."
        public const uint XONLINE_E_CTP_BDK_E_LAST_ADMIN_ROLE = 0x80190286;
        // "The PUID is already being used as BillableAccountAdmin."
        public const uint XONLINE_E_CTP_BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN = 0x80190287;
        // "Error updating member name."
        public const uint XONLINE_E_CTP_BDK_E_UPDATING_MEMBERNAME = 0x80190288;
        // "Object can have a maximum of 2000 roles."
        public const uint XONLINE_E_CTP_BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED = 0x80190289;
        // "The allowable number of the delegate admins for an account has reached its limit."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 0x80190290;
        // "Provisioning: Provision request malformed."
        public const uint XONLINE_E_CTP_PROVISION_E_MALFORMED_REQUEST = 0x80190291;
        // "Provisioning: Wrong input parameters."
        public const uint XONLINE_E_CTP_PROVISION_E_WRONG_INPUT_PARAMETERS = 0x80190292;
        // "Provisioning: Microsoft Provisioning Framework call failed. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_MPF_CALL_FAILED = 0x80190293;
        // "Provisioning: Error during XML manipulation. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_XML_OPERATION_ERROR = 0x80190294;
        // "Provisioning: MPF client instantiation failed. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_MPF_CREATE = 0x80190295;
        // "Provisioning: General error in startup code. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_CREATION = 0x80190296;
        // "The number of service instances in the provisioning request exceeds the configured limit."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 0x80190297;
        // "Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_DBBADZIP = 0x80190298;
        // "The account has subscription(s) in non-cancelled state that require information that you are attempting to remove."
        public const uint XONLINE_E_CTP_BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x80190299;
        // "The account requires additional attributes before performing the operation."
        public const uint XONLINE_E_CTP_BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x80190300;
        // "The referrer has already reffered the customer to this offer."
        public const uint XONLINE_E_CTP_BDK_E_ACCT_ALREADY_REFERRED = 0x80190301;
        // "There are no reward offers currently available in the system."
        public const uint XONLINE_E_CTP_BDK_E_REWARD_OFFER_NOT_PURCHASABLE = 0x80190302;
        // "Need to sign the agreement before continuing with the call."
        public const uint XONLINE_E_CTP_BDK_E_AGREEMENT_NOT_SIGNED = 0x80190303;
        // "The user has a violation on their payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_VIOLATION_EXISTS = 0x80190304;
        // "Title and/or category is not allowed for this offer."
        public const uint XONLINE_E_CTP_BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 0x80190305;
        // "Account has a pending transaction."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_TRANSACTION = 0x80190306;
        // "Cannot update total."
        public const uint XONLINE_E_CTP_BDK_E_INCREMENT_TOTAL = 0x80190307;
        // "Resource does not belong to this object id."
        public const uint XONLINE_E_CTP_BDK_E_RES_NOT_BELONG_TO_OBJECT = 0x80190308;
        // "Payment instrument on the current subscription has a declining balance."
        public const uint XONLINE_E_CTP_BDK_E_DECLINING_BALANCE = 0x80190309;
        // "Duplicate tracking GUID."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TRACKING_GUID = 0x80190310;
        // "Invalid credit card expiration date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EXPIRATION_DATE = 0x80190311;
        // "Invalid mandate status."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_MANDATE_STATUS = 0x80190312;
        // "Payment method of this type can't support the action"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_METHOD_TYPE = 0x80190313;
        // "Invalid input currency."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CURRENCY2 = 0x80190314;
        // "Invalid amount passed in as argument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT = 0x80190315;
        // "Invalid billing period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_PERIOD = 0x80190316;
        // "Invalid billing anniversary date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ANNIV = 0x80190317;
        // "Invalid line item ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID = 0x80190318;
        // "Invalid line item status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_STATUS = 0x80190319;
        // "The event type of the line item is invalid for this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EVENT_TYPE = 0x80190320;
        // "Line item ID not associated with an open record."
        public const uint XONLINE_E_CTP_BDK_E_LINE_ITEM_ID_NOT_OPEN = 0x80190321;
        // "Line item has already been offset."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_OFFSET = 0x80190322;
        // "Line item has already been Charged back."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_CHARGED_BACK = 0x80190323;
        // "Offset amount must be greater than zero but less than or equal to original amount. %1"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFSET_AMOUNT = 0x80190324;
        // "Cannot offset line item that is soft- or hard-declined."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80190325;
        // "Cannot offset line item which is cross SA and BSS transfered."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 0x80190326;
        // "Amount has not been collected
        public const uint XONLINE_E_CTP_BDK_E_AMOUNT_NOT_COLLECTED_YET = 0x80190327;
        // "Cannot offset line item amount of zero."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_OFFSET_ZERO_AMOUNT = 0x80190328;
        // "The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection."
        public const uint XONLINE_E_CTP_BDK_E_AMOUNT_IN_PROCESS = 0x80190329;
        // "Credit amount should not be zero."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_AMOUNT = 0x80190330;
        // "Credit amount should not exceed the limit."
        public const uint XONLINE_E_CTP_BDK_E_CREDIT_AMOUNT_OVER_LIMIT = 0x80190331;
        // "The requested currency(JPY
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80190332;
        // "Same event id already been used
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_EVENT_ID = 0x80190333;
        // "Line items in the immediate_settle_in_progress state cannot be offset."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_IMM_SETTLE_IN_PROG = 0x80190334;
        // "Line item with this settlement amount status cannot be offset."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_STATE_UNOFFSETABLE = 0x80190335;
        // "this settlement amount status cannot be escheated."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_STATE_UNESCHEATABLE = 0x80190336;
        // "Offset amount should never exceed the original item amount."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x80190337;
        // "The subscription is not active. The resource usage event is still being reported for the subscription."
        public const uint XONLINE_E_CTP_BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80190338;
        // "the payment instrument already has declines on it"
        public const uint XONLINE_E_CTP_BDK_E_PI_IN_DECLINE = 0x80190339;
        // "The operation is not allowed when there are Settlement Amounts in intermediate status."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_INTERMEDIATE_STATUS = 0x80190340;
        // "The specified settlement amount id is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SETTLEMENT_AMOUNT_ID = 0x80190341;
        // "This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_RATED_USAGE_TOTAL = 0x80190342;
        // "Value for returnStatementSet parameter must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x80190343;
        // "%1"
        public const uint XONLINE_E_CTP_BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x80190344;
        // "Refund failed - line item was offset but original line item was never settled."
        public const uint XONLINE_E_CTP_BDK_E_REFUND_LINEITEM_NOT_SETTLED = 0x80190345;
        // "Specified resource balance has already been billed."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_BALANCE_INACTIVE = 0x80190346;
        // "The number of units specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_UNITS = 0x80190347;
        // "Usage category does not exist for this resource."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USAGE_CATEGORY = 0x80190348;
        // "The prepaid resource balance is not sufficient for this usage event."
        public const uint XONLINE_E_CTP_BDK_E_INSUFFICIENT_PREPAID_BALANCE = 0x80190349;
        // "Financial reason code does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FINANCIAL_REASON_CODE = 0x80190350;
        // "Offset of offset is not permitted through this API."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80190351;
        // "If offset is not to be shown by getstatement
        public const uint XONLINE_E_CTP_BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80190352;
        // "Invalid financial reason code passed for the offset usage API."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x80190353;
        // "The line item is associated with a non-offsettable event action."
        public const uint XONLINE_E_CTP_BDK_E_EVENT_ACTION_NOT_OFFSETTABLE = 0x80190354;
        // "Action is not permitted for immediate settle of usage offers."
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80190355;
        // "Resource offset is only allowed for usage."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x80190356;
        // "Invalid Tax Refund Code."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE = 0x80190357;
        // "The transaction confirmation number is already used on the account."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 0x80190358;
        // "The transaction does not exist."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_NOT_EXIST = 0x80190359;
        // "Invalid combination of cumulative authorized amount and cumulative reversed amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUMULATIVE_AMOUNT = 0x80190360;
        // "The transaction event code is unknown."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_EVENT_UNKNOWN = 0x80190361;
        // "The transaction event code is not consistent."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_EVENT_INCONSISTENT = 0x80190362;
        // "Invalid sequence number reported in transaction event."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SEQUENCE_NUMBER = 0x80190363;
        // "Invalid vendor internal transaction id."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VENDOR_TRANSACTION_ID = 0x80190364;
        // "Invalid rejection reason code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REJECTION_REASON_CODE = 0x80190365;
        // "Invalid transaction status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_STATUS = 0x80190366;
        // "Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT = 0x80190367;
        // "Invalid merchant id."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_MERCHANT_ID = 0x80190368;
        // "Transaction has already been cancelled."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_ALREADY_CANCELLED = 0x80190369;
        // "Passport member name could not be added."
        public const uint XONLINE_E_CTP_BDK_E_PMN_INSERT_FAILURE = 0x80190370;
        // "Payment card number has been used multiple times."
        public const uint XONLINE_E_CTP_BDK_E_BADSAMECARDUSEDMULTIPLETIMES = 0x80190371;
        // "Payment instrument already assigned to account."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_ON_ACCOUNT = 0x80190372;
        // "Passport ID can have a maximum of 100 roles."
        public const uint XONLINE_E_CTP_BDK_E_PUID_ROLE_LIMIT_EXCEEDED = 0x80190373;
        // "Too many fraud enticing purchases on the payment instrument"
        public const uint XONLINE_E_CTP_BDK_E_TOOMANY_FDE_PURCHASES = 0x80190374;
        // "Passport PUIDs associated with this tax Id has already reaches the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 0x80190375;
        // "Access denied."
        public const uint XONLINE_E_CTP_BDK_E_NOPERMISSION = 0x80190376;
        // "Cannot remove self from object."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_REMOVE_SELF = 0x80190377;
        // "XML is either malformed or incorrect for this API."
        public const uint XONLINE_E_CTP_BDK_E_BADXML = 0x80190378;
        // "Comment text length must be between 1 and 512 characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALIDCOMMENTSIZE = 0x80190379;
        // "Invalid cancellation mode."
        public const uint XONLINE_E_CTP_BDK_E_BADCANCELMODE = 0x80190380;
        // "Input parameter is the wrong size."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BUF_SIZE = 0x80190381;
        // "Invalid role."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ROLE = 0x80190382;
        // "Invalid Passport ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PPORT_ID = 0x80190383;
        // "Invalid argument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ARG = 0x80190384;
        // "Unknown server failure. API name: %2
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_SERVER_FAILURE = 0x80190385;
        // "Status must be ENABLED or SUSPENDED."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATUS_VALUE = 0x80190386;
        // "Filter must be BASE
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FILTER = 0x80190387;
        // "Missing category."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_CATEGORY = 0x80190388;
        // "Input field is too short."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_TOO_SHORT = 0x80190389;
        // "Input field is too long."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_TOO_LONG = 0x80190390;
        // "Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_BADZIP = 0x80190391;
        // "Only one of these nodes should be passed."
        public const uint XONLINE_E_CTP_BDK_E_ONLYONENODE = 0x80190392;
        // "Input field length does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIELD_LENGTH = 0x80190393;
        // "Only customer service representatives can invoke this API."
        public const uint XONLINE_E_CTP_BDK_E_CSR_AUTHZ_FAILED = 0x80190394;
        // "Caller is not an account administrator."
        public const uint XONLINE_E_CTP_BDK_E_NOT_ACCOUNT_ADMIN = 0x80190395;
        // "Delegate ID entered was invalid or not specified."
        public const uint XONLINE_E_CTP_BDK_E_DELEGATE_ID_UNSPECIFIED = 0x80190396;
        // "Requester Passport ID must be specified."
        public const uint XONLINE_E_CTP_BDK_E_REQUESTER_ID_UNSPECIFIED = 0x80190397;
        // "Boolean value must be 0 or 1"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FLAG_VALUE = 0x80190398;
        // "Subscription service instance is inactive."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x80190399;
        // "Invalid object."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OBJECT_ID = 0x80190400;
        // "Input field length of first name does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH = 0x80190401;
        // "Input field length of last name does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LASTNAME_FIELD_LENGTH = 0x80190402;
        // "Input field length of address does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESS_FIELD_LENGTH = 0x80190403;
        // "Calling partner is not registered in SPS database."
        public const uint XONLINE_E_CTP_BDK_E_PARTNERNOTINBILLING = 0x80190404;
        // "Rating error has occurred. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_RATING_FAILURE = 0x80190405;
        // "BDKSVR2 started."
        public const uint XONLINE_E_CTP_BDK_SVR2_STARTED = 0x80190406;
        // "CSR call made."
        public const uint XONLINE_E_CTP_BDK_CSR_API_CALL_MADE = 0x80190407;
        // "CSR call attempt by non-CSR caller."
        public const uint XONLINE_E_CTP_BDK_E_CSR_CALL_FROM_NONCSR = 0x80190408;
        // "From and to payment instrument are not on the same account in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS = 0x80190409;
        // "Invalid to payment instrument in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_TO_PI_INVALID = 0x80190410;
        // "Cannot transfer to same payment instrument in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_TO_SAME_PI = 0x80190411;
        // "Cannot transfer balances between payment instrument types."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_NOT_ALLOW = 0x80190412;
        // "Internal database inconsistencies detected."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR = 0x80190413;
        // "Payment instrument has outstanding balance."
        public const uint XONLINE_E_CTP_BDK_E_OUTSTANDING_BALANCE = 0x80190414;
        // "Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REFERRALDATA_XML = 0x80190415;
        // "Invalid GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_GUID = 0x80190416;
        // "Payment instrument type not supported for SettleBalance."
        public const uint XONLINE_E_CTP_E_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80190417;
        // "Subscription is inactive."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_INACTIVE = 0x80190418;
        // "Payments can only be stopped for credit card and direct debit transactions."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PM_FOR_STOP_PAYMENTS = 0x80190419;
        // "Excessive number of usage events reported in one ReportUsageEvent() call."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80190420;
        // "Field cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_NOT_UPDATEABLE = 0x80190421;
        // "Calling CancelSubscription with an end date and in compute-only mode is not supported."
        public const uint XONLINE_E_CTP_BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x80190422;
        // "The SETTLE event should be the last event in the event list for ImportSettleBillingItems."
        public const uint XONLINE_E_CTP_BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x80190423;
        // "Line item payment method is no longer valid."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_METHOD_NO_LONGER_VALID = 0x80190424;
        // "Failed to process all usage events."
        public const uint XONLINE_E_CTP_BDK_E_PROCESS_USAGE_EVENTS = 0x80190425;
        // "Object ID does not contain account and subscription information."
        public const uint XONLINE_E_CTP_BDK_E_WRONG_OBJECT_ID_TYPE = 0x80190426;
        // "Field contains invalid characters for a phone number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_VALUE = 0x80190427;
        // "Invalid amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_VALUE = 0x80190428;
        // "Payment instrument ID and line item ID do not match."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80190429;
        // "InternalAddComment failed. Escalate error to SPG development."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ADD_COMMENT_FAILED = 0x80190430;
        // "Immediate settle flag value not supported."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80190431;
        // "No eligible records were found for this call."
        public const uint XONLINE_E_CTP_BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS = 0x80190432;
        // "Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x80190433;
        // "The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TELENUMERIC_STRING = 0x80190434;
        // "There are no matches for the requested information."
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCH = 0x80190435;
        // "There are multiple matches for the requested information."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_MATCHES = 0x80190436;
        // "PUID entered was invalid."
        public const uint XONLINE_E_CTP_BDK_E_BAD_PUID = 0x80190437;
        // "ObjectId length must be 16."
        public const uint XONLINE_E_CTP_BDK_E_BAD_OBJECT_ID_LENGTH = 0x80190438;
        // "Start period can never be greater than End period."
        public const uint XONLINE_E_CTP_BDK_E_END_PERIOD_LESS_THAN_START_PERIOD = 0x80190439;
        // "Billing period length must be 6."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BILLING_PERIOD_LENGTH = 0x80190440;
        // "Value for returnStatementSet parameter for GetStatement API must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET = 0x80190441;
        // "The usage event date specified was invalid.  One possible reason is that it is too far in the future."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USAGE_EVENT_DATE = 0x80190442;
        // "The default billing period returned was null
        public const uint XONLINE_E_CTP_BDK_E_NULL_DEFAULT_BILLING_PERIOD = 0x80190443;
        // "The start billing period is less than the currently available billing period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_START_BILLING_PERIOD = 0x80190444;
        // "The end billing period is less than the currently available billing period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_END_BILLING_PERIOD = 0x80190445;
        // "The new due date is in the past"
        public const uint XONLINE_E_CTP_BDK_E_NEW_DUE_DATE_IS_PAST = 0x80190446;
        // "The new due date is more than MAXIMUM DELAY days in the future than the original due date"
        public const uint XONLINE_E_CTP_BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED = 0x80190447;
        // "If the applydeclineEffect is off
        public const uint XONLINE_E_CTP_BDK_E_NO_NEW_DUE_DATE_SPECIFIED = 0x80190448;
        // "Invalid transaction type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_TYPE = 0x80190449;
        // "Invalid reason code"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REASON_CODE = 0x80190450;
        // "Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure."
        public const uint XONLINE_E_CTP_BDK_E_GROUP_SID_INITIALIZATION_FAILED = 0x80190451;
        // "This operation is not valid for wholesale payment instruments."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x80190452;
        // "This operation is not valid for direct debit payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x80190453;
        // "Adjustment amount exceeds the resource credit limit."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x80190454;
        // "Adjusting a resource balance is not allowed for subscriptions that are not active."
        public const uint XONLINE_E_CTP_BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x80190455;
        // "Failed to create mail record for account: %1."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_TO_CREATE_MAIL_RECORD = 0x80190456;
        // "This MSNIA usage event is for a billing period that is not active
        public const uint XONLINE_E_CTP_BDK_E_MSNIA_LATE_USAGE = 0x80190457;
        // "Failed to write asynchronous immediate settlement failure into the audit db for account: %1."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80190458;
        // "This offering is not configured as a referral offer."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REFERRAL_OFFER = 0x80190459;
        // "Reward referral XML is required as this is a referral based offer."
        public const uint XONLINE_E_CTP_BDK_E_REWARD_REFERRAL_XML_REQUIRED = 0x80190460;
        // "Referral PUID not found."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_IN_SYSTEM = 0x80190461;
        // "Referrer has exceeded the max number of referrals configured on the offer."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80190462;
        // "The referrer does not have an Active or Locked account in the system."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_ACTIVE = 0x80190463;
        // "The referrer cannot refer self for the offer."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_REFER_SELF = 0x80190464;
        // "The referral xml has reward referral info but the offer is not configured for reward referrals."
        public const uint XONLINE_E_CTP_BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80190465;
        // "The reward referral schema in the referral xml is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REWARD_REFFERAL_SCHEMA = 0x80190466;
        // "The referrer does not have any eligible offers configured for the reward."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x80190467;
        // "Invalid mandate status for SettleBalance."
        public const uint XONLINE_E_CTP_BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x80190468;
        // "More than one usage event reported to ReportSingleUsageEvent API"
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED = 0x80190469;
        // "The reported usage is below the threshold in immediate settle usage."
        public const uint XONLINE_E_CTP_BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x80190470;
        // "ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage."
        public const uint XONLINE_E_CTP_BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x80190471;
        // "ReportUsage cannot be used for prepaid resource; use ReportSingleUsage."
        public const uint XONLINE_E_CTP_BDK_E_REPORT_USAGE_WITH_PREPAID = 0x80190472;
        // "ReportSingleUsage cannot be used with empty event set."
        public const uint XONLINE_E_CTP_BDK_E_NO_USAGE_EVENT_REPORTED = 0x80190473;
        // "The payment instrument type does not support immediate settlements"
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80190474;
        // "The reported resource and unit of measure do not match."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80190475;
        // "Invalid  data passed in RedirectInputInfoXML node."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REDIRECT_INPUTINFO_XML = 0x80190476;
        // "Transaction cannot be cancelled."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_NOT_CANCELLABLE = 0x80190477;
        // "No CDs found."
        public const uint XONLINE_E_CTP_BDK_E_NO_CDS_FOUND = 0x80190478;
        // "Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGE_DESCRIPTOR = 0x80190479;
        // "This Wholesale payment instrument has no related wholesale partner."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_WHOLESALEPI = 0x80190480;
        // "This partner is not BOBO wholesale partner."
        public const uint XONLINE_E_CTP_BDK_E_NOT_BOBOPARTNER = 0x80190481;
        // "This BOBO wholesale partner has no entitle endpoint."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BOBOPARTNER = 0x80190482;
        // "The entitlement endpoint web service could not be reached"
        public const uint XONLINE_E_CTP_BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 0x80190483;
        // "The entitlement endpoint returned a validation failure"
        public const uint XONLINE_E_CTP_BDK_E_ENTITLEMENT_VALIDATION_FAILED = 0x80190484;
        // "The entitlement endpoint is invalid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ENTITLEMENT_ENDPOINT = 0x80190485;
        // "Calling partner does not have permissions to access the sandboxed object"
        public const uint XONLINE_E_CTP_BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 0x80190486;
        // "Calling partner does not have permissions to call on behalf of this partner"
        public const uint XONLINE_E_CTP_BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF = 0x80190487;
        // "Taxware error. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_TAXWARE_FAILURE = 0x80190488;
        // "Address validation error. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_ADDRESS_VALIDATION_FAILURE = 0x80190489;
        // "VERAZIP: Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_INVALID = 0x80190490;
        // "VERAZIP: Invalid state code."
        public const uint XONLINE_E_CTP_BDK_E_STATE_INVALID = 0x80190491;
        // "VERAZIP: Missing ZIP code or city name."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_CITY_MISSING = 0x80190492;
        // "VERAZIP: Invalid state code/ZIP code combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_INVALID = 0x80190493;
        // "VERAZIP: Invalid state code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_CITY_INVALID = 0x80190494;
        // "VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID = 0x80190495;
        // "VERAZIP: Invalid state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID2 = 0x80190496;
        // "VERAZIP: Invalid state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID3 = 0x80190497;
        // "VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID4 = 0x80190498;
        // "Missing PayPalPayIn RedirectURL."
        public const uint XONLINE_E_CTP_BDK_E_REDIRECTURL_MISSING = 0x80190499;
        // "Invalid soft descriptor."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SOFT_DESCRIPTOR = 0x80190500;
        // "Failed to create billing agreement."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_CREATE_BILLING_AGREEMENT = 0x80190501;
        // "Failed to get payPal billing agreement details."
        public const uint XONLINE_E_CTP_BDK_E_GET_BADETAIL_FAILED = 0x80190502;
        // "Cannot update PayPalPayin payment method again."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_UPDATE_PAYPALPAYIN_PAYMENT_METHOD_AGAIN = 0x80190503;
        // "PayPal-Payin invalid filed value."
        public const uint XONLINE_E_CTP_BDK_E_PP_INVALID_FIELD_VALUE = 0x80190504;
        // "VERAZIP: Multiple counties exist for state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_COUNTIES_FOUND = 0x80190505;
        // "VERAZIP: Invalid state code for ZIP code. Changed to correct state code."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_INVALID_FOR_ENTERED_STATE = 0x80190506;
        // "VERAZIP: ZIP code has multiple city names."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x80190507;
        // "VERAZIP: City has multiple ZIP codes."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_CITIES_FOUND = 0x80190508;
        // "Incorrect city name length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_CITYNAME_LENGTH = 0x80190509;
        // "Incorrect country code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_COUNTRYCODE_LENGTH = 0x80190510;
        // "Incorrect code length for state or province."
        public const uint XONLINE_E_CTP_BDK_E_BAD_STATECODE_LENGTH = 0x80190511;
        // "Incorrect zip code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_ZIPCODE_LENGTH = 0x80190512;
        // "Incorrect product code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_PRODUCTCODE_LENGTH = 0x80190513;
        // "Incorrect business location code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x80190514;
        // "Incorrect transaction date length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_TRANSACTIONDATE_LENGTH = 0x80190515;
        // "Incorrect VAT registration length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_VATREGISTRATION_LENGTH = 0x80190516;
        // "Incorrect currency code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_CURRENCYCODE_LENGTH = 0x80190517;
        // "Incorrect WorldTax code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_WTCODE_LENGTH = 0x80190518;
        // "Invalid input parameter passed to TaxWare or VeraZip."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x80190519;
        // "The Vat ID provided is of invalid format."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VATID_FORMAT = 0x80190520;
        // "The Vat ID provided is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VATID_INVALID = 0x80190521;
        // "Input string contains unsupported characters."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_CHAR_EXIST = 0x80190522;
        // "Country code in Address does not match with the country code in Account Info."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_COUNTRYCODE_MISMATCH = 0x80190523;
        // "A Country code is required in Account Info."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_COUNTRYCODE_REQUIRED = 0x80190524;
        // "Token passed is Invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_SPECIFIED = 0x80190525;
        // "The token is already blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_BLACKLISTED = 0x80190526;
        // "The token is already un-blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_UNBLACKLISTED = 0x80190527;
        // "The specified token has been blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_BLACKLISTED = 0x80190528;
        // "The specified token belongs to a blacklisted token range."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RANGE_BLACKLISTED = 0x80190529;
        // "The usage for the specified token has been exceeded."
        public const uint XONLINE_E_CTP_BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x80190530;
        // "Token Expiry date not set as may be duration based token was not activated correctly."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x80190531;
        // "Failed while consumption to create an entry in token_instance_deal_subscription table."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x80190532;
        // "Not found non-active token range to be activated."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x80190533;
        // "The specified token has expired."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_EXPIRED = 0x80190534;
        // "The specified token cannot be used yet."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_STARTED = 0x80190535;
        // "The specified token has not been activated yet."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RANGE_NOT_ACTIVE = 0x80190536;
        // "The reason code specified is not valid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x80190537;
        // "The specified action is in progress."
        public const uint XONLINE_E_CTP_BDK_E_TRACKING_GUID_NODATA = 0x80190538;
        // "The specified tracking has already been used"
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TOKEN_TRACKING_GUID = 0x80190539;
        // "The specified token has already been activated"
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_ACTIVATED = 0x80190540;
        // "Committed status is not valid for this API."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COMMITTED_STATUS = 0x80190541;
        // "The description specified is not valid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80190542;
        // "Blacklist Effective date passed was prior to the order creation date."
        public const uint XONLINE_E_CTP_BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80190543;
        // "The Token has been consumed."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CONSUMED = 0x80190544;
        // "Part Number specified for the token import is not a valid part number for the associated token class."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80190545;
        // "External reference id is too long or invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EXTERNAL_REFERENCE_ID = 0x80190546;
        // "The token is already deactivated."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_DEACTIVATED = 0x80190547;
        // "Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID."
        public const uint XONLINE_E_CTP_BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80190548;
        // "Null parameter was passed for Token Class GUID during token class access verification."
        public const uint XONLINE_E_CTP_ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 0x80190549;
        // "The argument specified is not a valid bookmark."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BOOKMARK = 0x80190550;
        // "The max argument must be between 1 and 50."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MAX = 0x80190551;
        // "Internal inconsistency in Token Database."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR_TOKEN = 0x80190552;
        // "The version specified is not supported."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_VERSION = 0x80190553;
        // "The quantity specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_QUANTITY = 0x80190554;
        // "Invalid product type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PRODUCT_TYPE = 0x80190555;
        // "The input item external id is duplicate"
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_ITEM_EXTERNAL_ID = 0x80190556;
        // "No tax rule was returned for the specified country
        public const uint XONLINE_E_CTP_BDK_E_NO_TAX_RULE_CONFIGURED = 0x80190557;
        // "Fail to calculate tax"
        public const uint XONLINE_E_CTP_BDK_E_TAX_CALCULATION_FAILURE = 0x80190558;
        // "No tax info associated with the account"
        public const uint XONLINE_E_CTP_BDK_E_NO_ASSOCIATED_TAX_INFO = 0x80190559;
        // "Invalid tax calculation info."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_CALCULATION_INFO = 0x80190560;
        // "Tax inclusive calculation cannot be performed for US and CA."
        public const uint XONLINE_E_CTP_BDK_E_NO_TAX_INCLUSIVE_CALCULATION = 0x80190561;
        // "Invalid revenue sku."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REVENUE_SKU = 0x80190562;
        // "Invalid tax amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_AMOUNT = 0x80190563;
        // "Invalid tax rate."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_RATE = 0x80190564;
        // "Invalid billing mode."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_MODE = 0x80190565;
        // "Invalid item entry set."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ITEM_ENTRY_SET = 0x80190566;
        // "Failed to execute operation in billing component."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_FAILURE = 0x80190567;
        // "Failed to execute operation in billing component
        public const uint XONLINE_E_CTP_BDK_E_BILLING_RETRYABLE_FAILURE = 0x80190568;
        // "The original order is is not specified."
        public const uint XONLINE_E_CTP_BDK_E_ORIGINAL_ORDER_ID_NOT_SPECIFIED = 0x80190569;
        // "No matching billing configuration for the specified partner
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_BILLING_CONFIGURATION = 0x80190570;
        // "Invalid billing reference id."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_REFERENCE_ID = 0x80190571;
        // "The billing reference id has already been removed."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_REFERENCE_ID_ALREADY_REMOVED = 0x80190572;
        // "Unable to retrieve event ID and billing impact for event."
        public const uint XONLINE_E_CTP_BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x80190573;
        // "Unable to find line item matching event."
        public const uint XONLINE_E_CTP_BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x80190574;
        // "Cannot process if there is an offset of an offset."
        public const uint XONLINE_E_CTP_BDK_E_CANCELREFUND_OFFSET_OF_OFFSET = 0x80190575;
        // "This can't happen
        public const uint XONLINE_E_CTP_BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x80190575;
        // "The session key passed in does not pass validation checks."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SESSION_KEY = 0x80190577;
        // "This object ID is not entitled to get a deliverable token."
        public const uint XONLINE_E_CTP_BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x80190578;
        // "The token cannot be issued
        public const uint XONLINE_E_CTP_BDK_E_PRODUCT_KEY_NOT_AVAILABLE = 0x80190579;
        // "Either PIN or Sequence number is required as input parameter to validate Token."
        public const uint XONLINE_E_CTP_BDK_E_PIN_OR_SEQ_REQUIRED = 0x80190580;
        // "Either Token Class Guid or Signature or Part Number should be specified for validating Token."
        public const uint XONLINE_E_CTP_BDK_E_INPUT_PARAM_MALFORMED = 0x80190581;
        // "The offset must be between -1 and 365 inclusive."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSTMENT_OFFSET = 0x80190582;
        // "Invalid item instance ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ITEM_INSTANCE_ID = 0x80190583;
        // "Invalid reason for reverse operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REVERSE_REASON = 0x80190584;
        // "Only 1 item can be purchased at once."
        public const uint XONLINE_E_CTP_BDK_E_TOO_MANY_ITEMS_IN_PURCHASE = 0x80190585;
        // "PurchaseItem accepts only offers that are configured for item
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_TYPE = 0x80190586;
        // "The price specified must be a positive value."
        public const uint XONLINE_E_CTP_BDK_E_PRICE_IS_NEGATIVE = 0x80190587;
        // "Cannot pass in a price and/or currency because it is configured on the item."
        public const uint XONLINE_E_CTP_BDK_E_DYNAMIC_PRICE_CONFIGURATION = 0x80190588;
        // "The maximum allowable DMP point balance is exceeded."
        public const uint XONLINE_E_CTP_BDK_E_DMP_MAX_BALANCE_EXCEEDED = 0x80190589;
        // "Calling partner needs to add a currency because it is not pre-configured."
        public const uint XONLINE_E_CTP_BDK_E_CURRENCY_MISSING = 0x80190590;
        // "The user already has a pending purchase for for this item that must first be cancelled or completed."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_ITEM_PURCHASE = 0x80190591;
        // "Unable to talk to DMP system."
        public const uint XONLINE_E_CTP_BDK_E_DMP_FLOW_NOT_ENABLED = 0x80190592;
        // "Item has been already reversed."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_ALREADY_REVERSED = 0x80190593;
        // "Reversing an item that has not been fulfilled."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_NOT_FULFILLED = 0x80190594;
        // "Unknown DMP error has occurred."
        public const uint XONLINE_E_CTP_BDK_E_DMP_UNKNOWN_ERROR = 0x80190595;
        // "Payment method type does not support operation."
        public const uint XONLINE_E_CTP_BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 0x80190596;
        // "Redirect vendor returned an invalid CancelTransaction result."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CANCEL_TRANSACTION_RESULT = 0x80190597;
        // "CVM code Missing"
        public const uint XONLINE_E_CTP_BDK_E_CVM_MISSING = 0x80190598;
        // "A fre Trial cannot be purchased using an account. Use only the PUID"
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 0x80190599;
        // "Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch"
        public const uint XONLINE_E_CTP_BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 0x80190600;
        // "The donor and the beneficiary are the same."
        public const uint XONLINE_E_CTP_BDK_E_DONOR_BENEFICIARY_SAME = 0x80190601;
        // "The renewal does not exists."
        public const uint XONLINE_E_CTP_BDK_E_RENEWAL_DOES_NOT_EXISTS = 0x80190602;
        // "The token schedule rennewal exists for this offer."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS = 0x80190603;
        // "The event could not be queued to notification engine frequently."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_FREQUENTLY = 0x80190604;
        // "Unknown notification client error."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_UNKNOWN_ERROR = 0x80190605;
        // "Notification client initialization failure."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_INIT_FAIL = 0x80190606;
        // "Notification client queue option is not well configured in tower db."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_INVALID_QUEUE_OPTION = 0x80190607;
        // "Notification client performs too slow."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_TOO_SLOW = 0x80190608;
        // "The event could not be queued to notification engine but not happens frequently."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_NOT_FREQUENTLY = 0x80190609;
        // "The notification is not related to any partner subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_NO_RELATED_PARTNER_SUBS = 0x80190610;
        // "Specified Discount is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DISCOUNT = 0x80190611;
        // "Could not insert into a discount table."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_DISCOUNT = 0x80190612;
        // "Only one discount permitted per subscription."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_ALREADY_APPLIED = 0x80190613;
        // "Token is a discount coupon yet no discount was passed."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN = 0x80190614;
        // "Token is a discount coupon and cannot be associated with a deal."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_TOKEN = 0x80190615;
        // "Failed to insert record into discount_localize table."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_DISCOUNT_LOCALIZE = 0x80190616;
        // "Per Account Usage limit was exceeded for discount."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_USAGE_EXCEEDED = 0x80190617;
        // "Token class and discount are not a valid combination."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH = 0x80190618;
        // "Partner does not have access to the specified customer type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 0x80190619;
        // "Category should not be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_CATEGORY = 0x80190620;
        // "Account ID cannot be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_ACCOUNTID = 0x80190621;
        // "Subscription Ref ID cannot be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_SUBSCRIPTIONREFID = 0x80190622;
        // "Invalid Survey Result Code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SURVEYRESULTCODE = 0x80190623;
        // "CD not found."
        public const uint XONLINE_E_CTP_BDK_E_CD_NOTFOUND = 0x80190624;
        // "Invalid Account ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNTID = 0x80190625;
        // "Invalid AnonymousInfo Xml."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ANONYMOUS_INFO_XML = 0x80190626;
        // "Unsupported object type."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_OBJECT_TYPE = 0x80190627;
        // "Invalid Phone XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_XML = 0x80190628;
        // "Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REQUESTOR_INFO = 0x80190629;
        // "There are pending transactions on this deal or subscription."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_TRANSACTIONS = 0x80190630;
        // "The lineitem id and settlement id do not match"
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 0x80190631;
        // "Invalid original charge details"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS = 0x80190632;
        // "Partial Chargeback cannot be Processed"
        public const uint XONLINE_E_CTP_BDK_E_PARTIAL_CHAREGBACK = 0x80190633;
        // "Invalid lineitem id for reversal"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL = 0x80190634;
        // "Invalid chargeback date. Chargeback date must greater or equals to original settlement date"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_DATE = 0x80190635;
        // "Invalid chargeback amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_AMOUNT = 0x80190636;
        // "Tax was already offset for this line item."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_OFFSET_TAX = 0x80190637;
        // "mappoint is not enabled for the country code."
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 0x80190638;
        // "SCS had error connecting to mappoint due to some network problems."
        public const uint XONLINE_E_CTP_BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 0x80190639;
        // "SCS had some internal error connecting that is preventing connection to mappoint."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 0x80190640;
        // "Mappoint returned 0 addresses."
        public const uint XONLINE_E_CTP_BDK_E_ZERO_ADDRESSES_BY_MAPPOINT = 0x80190641;
        // "UNKNOWN ERROR in MAPPOINT API."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_ERROR = 0x80190642;
        // "UNKNOWN ERROR ENCOUNTERED."
        public const uint XONLINE_E_CTP_BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR = 0x80190643;
        // "Invalid AddressInfo Xml."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESSINFOXML = 0x80190644;
        // "Mappoint does not support Post Box Addresses currently."
        public const uint XONLINE_E_CTP_BDK_E_POST_BOX_ERROR_MAPPOINT = 0x80190645;
        // "The connection to Mappoint has timed out."
        public const uint XONLINE_E_CTP_BDK_E_MAPPOINT_CONNECTION_MAPPOINT = 0x80190646;
        // "Invalid Chargeback details provided as input"
        public const uint XONLINE_E_CTP_BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 0x80190647;
        // "Chargeback id not found"
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_NOT_FOUND = 0x80190648;
        // "Chargeback id did not match"
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_NOT_MATCH = 0x80190649;
        // "Double chargeback"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK = 0x80190650;
        // "Invalid chargebacklineitem id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_LINEITEM_ID = 0x80190651;
        // "Invalid reversal chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_REVERSAL_ID = 0x80190652;
        // "Invalid chargeback for reversal chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 0x80190653;
        // "invalid lineitem id for chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 0x80190654;
        // "invalid lineitem id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_TYPE = 0x80190655;
        // "Double chargeback for reversal"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL = 0x80190656;
        // "The country of the address is not supported at this time"
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_NOT_SUPPORTED = 0x80190657;
        // "SCS has temporarily disabled MAPPOINT support for this country"
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_MAPPOINT_DISABLED = 0x80190658;
        // "The input parameter is incorrect"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PARAMETER = 0x80190659;
        // "The input ratingrules is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_RATINGRULE_DATA = 0x80190660;
        // "Invalid time conversion ratio for time extension."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TIME_CONVERSION_RATIO = 0x80190661;
        // "Invalid round day boundary for time extension."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ROUND_DAY_BOUNDARY = 0x80190662;
        // "Time extension is not supported for target subscription."
        public const uint XONLINE_E_CTP_BDK_E_TIME_EXTENSION_NOT_SUPPORTED = 0x80190663;
        // "The subscription status is invalid for committing subscription conversion."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CONVERT = 0x80190664;
        // "The subscription status is invalid for committing subscription creation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CREATESUBS = 0x80190665;
        // "Tax code is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_CODE = 0x80190666;
        // "Multiple charge or proration rating rule found."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_RATING_RULE_FOUND = 0x80190667;
        // "The subscription status is invalid for abandoning subscription conversion."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CONVERT = 0x80190668;
        // "The subscription status is invalid for abandoning subscription creation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CREATESUBS = 0x80190669;
        // "Tax included info is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_INCLUDED = 0x80190670;
        // "Invalid description or price description."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DESCRIPTION_PRICEDESC = 0x80190671;
        // "Renew mode of subscription conversion is not supported."
        public const uint XONLINE_E_CTP_BDK_E_RENEW_SUBSCRIPTION_NOT_SUPPORTED = 0x80190672;
        // "Invalid ChargebackID Generation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_ID = 0x80190673;
        // "Error when Chargeback Processing Failure."
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_PROCESSING_FAILURE = 0x80190674;
        // "Invalid Merchant Reference Number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MERCHANT_REFERENCE = 0x80190675;
        // "Error when any input details missing."
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_INFO_MISSING = 0x80190676;
        // "Error while recording chargeback/reversal in Chargeback History table."
        public const uint XONLINE_E_CTP_BDK_E_RECORD_CHARGEBACK_FAILED = 0x80190677;
        // "Double Chargeback Reversal"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK_REVERSAL = 0x80190678;
        // "Chargeback Processing Reversal"
        public const uint XONLINE_E_CTP_BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK = 0x80190679;
        // "Payment instrument not associated with subscription"
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION = 0x80190680;
        // "Subscription already converted or renewed"
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 0x80190681;
        // "Merchant Reference Number missing"
        public const uint XONLINE_E_CTP_BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING = 0x80190682;
        // "Invalid Encrypt Account number"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER = 0x80190683;
        // "Subscription has been scheduled to renew"
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL = 0x80190684;
        // "Account holder's profile already exists."
        public const uint XONLINE_E_CTP_BDK_E_PROFILE_ALREADY_EXISTS = 0x80190685;
        // "Account holder's profile does not exist."
        public const uint XONLINE_E_CTP_BDK_E_PROFILE_DOES_NOT_EXIST = 0x80190686;
        // "Account does not have an address associated with it."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_WITHOUT_ADDRESS = 0x80190687;
        // "Payout preference (default) is not set."
        public const uint XONLINE_E_CTP_BDK_E_NO_PAYOUT_PREFERENCE = 0x80190688;
        // "Payout preference (default) can not be deleted."
        public const uint XONLINE_E_CTP_BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 0x80190689;
        // "Invalid PayUserInfo XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYUSERINFOXML = 0x80190690;
        // "Invalid UserProfile XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USERPROFILEXML = 0x80190691;
        // "Account ID must not be specified."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 0x80190692;
        // "Description length exceeded"
        public const uint XONLINE_E_CTP_BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED = 0x80190693;
        // "RiME returns Rejected"
        public const uint XONLINE_E_CTP_BDK_E_RIME_REJECTED = 0x80190694;
        // "Invalid Values were sent to RiME"
        public const uint XONLINE_E_CTP_BDK_E_RIME_INVALID_VALUE = 0x80190695;
        // "Referral code not found in SCS database"
        public const uint XONLINE_E_CTP_BDK_E_REFERRAL_CODE_NOT_FOUND = 0x80190696;
        // "Billing subsystem doesn't support line item id for processing chargeback"
        public const uint XONLINE_E_CTP_BDK_E_BSS_NOT_SUPPORTED_LINE_ITEM_ID = 0x80190697;
        // "Billing subsystem encountered internal error."
        public const uint XONLINE_E_CTP_BDK_E_BSS_INTERNAL_SERVER_ERROR = 0x80190698;
        // "Billing subsystem only
        public const uint XONLINE_E_CTP_BDK_E_BSS_INVALID_ORDER_STATUS = 0x80190699;
        // "Billing subsystem doesn't support partial chargeback."
        public const uint XONLINE_E_CTP_BDK_E_BSS_PARITAL_CHARGE_BACK = 0x80190700;
        // "Timeout when calling billing subsystem."
        public const uint XONLINE_E_CTP_BDK_E_BSS_TIMEOUT_ERROR = 0x80190701;
        // "There is no existing provisioning information to complete this call"
        public const uint XONLINE_E_CTP_ERROR_MISSING_PROV_INFO = 0x80190702;
        // "Invalid Resource Type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RESOURCE_TYPE = 0x80190703;
        // "fail when submit to payment provider"
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED = 0x80190704;
        // "declined when submit to payment provider"
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 0x80190705;
        // "fail to encrypt file"
        public const uint XONLINE_E_CTP_BDK_E_ENCRYPTION_FAILURE = 0x80190706;
        // "BDK_E_DMP_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_DMP_FIRST = 0x80190707;
        // "BDK_E_DMP_LAST"
        public const uint XONLINE_E_CTP_BDK_E_DMP_LAST = 0x80190708;
        // "Invalid target user information specified"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TARGET_USER_INFORMATION = 0x80190709;
        // "Invalid delegate user information"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DELEGATE_USER_INFORMATION = 0x80190710;
        // "Invalid source information"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SOURCE_USER_INFORMATION = 0x80190711;
        // "Invalid transaction Id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_INFORMATION = 0x80190712;
        // "Transaction information passed in does not match the information stored"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_TRANSACTION = 0x80190713;
        // "Unable to find transaction in PENDING_PAYOUT state matching the input parameters"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 0x80190714;
        // "Unable to find transaction in PENDING state matching the input parameters"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_PENDING_TRANSACTION = 0x80190715;
        // "BDK_E_ORDER_LAYER_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_ORDER_LAYER_FIRST = 0x80190716;
        // "BDK_E_ORDER_LAYER_LAST"
        public const uint XONLINE_E_CTP_BDK_E_ORDER_LAYER_LAST = 0x80190717;
        // "BDK_E_TRANSACTION_LAYER_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_LAYER_FIRST = 0x80190718;
        // "BDK_E_TRANSACTION_LAYER_LAST"
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_LAYER_LAST = 0x80190719;
        // "Provisioning call from MPF to endpoint failed."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_MPF_CALL_FAILED = 0x80190720;
        // "Invalid adjustment date offset."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INVALID_ADJUSTMENT_OFFSET = 0x80190721;
        // "Invalid arguments."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INVALID_ARG = 0x80190722;
        // "Response file received but no request file sent for it."
        public const uint XONLINE_E_CTP_AU_E_NO_REQUEST_SENT = 0x80190723;
        // "CC Account Updater already run for the current day."
        public const uint XONLINE_E_CTP_AU_E_DUPLICATE_RUN = 0x80190724;
        // "Batch files are not configured properly: input
        public const uint XONLINE_E_CTP_AU_E_BAD_BATCH_FORMAT = 0x80190725;
        // "Could not archive inquiry / response file."
        public const uint XONLINE_E_CTP_AU_E_FAIL_TO_ARCHIVE = 0x80190726;
        // "Cannot generate Inquiry file."
        public const uint XONLINE_E_CTP_AU_E_FAIL_TO_GENERATE_INQUIRY_FILE = 0x80190727;
        // "Task for inquiry file generation ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_INQUIRY_GENERATION_TASK_ENDED_UNSUCCESSFULLY = 0x80190728;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190729;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_UPDATE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190730;
        // "Task for request file sending ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_PP_E_REQUEST_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190731;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_PP_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190732;
        // "SCS_E_CERT_INAVLID"
        public const uint XONLINE_E_CTP_SCS_E_CERT_INAVLID = 0x80190733;
        // "SCS_E_INAVLID_CALLING_PARTNER"
        public const uint XONLINE_E_CTP_SCS_E_INAVLID_CALLING_PARTNER = 0x80190734;
        // "BDK_E_RISK_EVALUATION_FAILED"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_FAILED = 0x80190735;
        // "BDK_E_RISK_EVALUATION_EXCEPTION"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_EXCEPTION = 0x80190736;
        // "BDK_E_RISK_EVALUATION_UNDEFINED"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_UNDEFINED = 0x80190737;
        // "BDK_E_RISK_CONFIGURATION_ERROR"
        public const uint XONLINE_E_CTP_BDK_E_RISK_CONFIGURATION_ERROR = 0x80190738;
        // "BDK_E_RISK_NEXT"
        public const uint XONLINE_E_CTP_BDK_E_RISK_NEXT = 0x80190739;
        // "Risk Engine throw exception"
        public const uint XONLINE_E_CTP_BDK_E_RISK_ENGINE_EXCEPTION = 0x80190740;
        // "Risk Engine throw exception in argument validation"
        public const uint XONLINE_E_CTP_BDK_E_RISK_ARGUMENT_VALIDATION_FAILED = 0x80190741;
        // "Apartment number missing or not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_APARTMENT = 0x80190742;
        // "Insufficient address information"
        public const uint XONLINE_E_CTP_BDK_E_DAV_INSUFFICIENT = 0x80190743;
        // "House number or PO box not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_ID = 0x80190744;
        // "Multiple address matches found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_MULTIPLE = 0x80190745;
        // "PO box identifier out of range"
        public const uint XONLINE_E_CTP_BDK_E_DAV_POBOX = 0x80190746;
        // "Route service identified out of range"
        public const uint XONLINE_E_CTP_BDK_E_DAV_ROUTE = 0x80190747;
        // "Street name not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_STREET = 0x80190748;
        // "Postal code not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_POSTAL = 0x80190749;
        // "Genreal address error"
        public const uint XONLINE_E_CTP_BDK_E_DAV_GENERAL = 0x80190750;
        // "Missing required address field(s)"
        public const uint XONLINE_E_CTP_BDK_E_DAV_MISSING_DATA = 0x80190751;
        // "Invalid address field(s)"
        public const uint XONLINE_E_CTP_BDK_E_DAV_INVALID_DATA = 0x80190752;
        // "System failure during address check"
        public const uint XONLINE_E_CTP_BDK_E_DAV_SYSTEM_FAILURE = 0x80190753;
        // "Timeout during DAV check"
        public const uint XONLINE_E_CTP_BDK_E_DAV_TIMEOUT = 0x80190754;
        // "Delivery Address Verification system is not available at this time"
        public const uint XONLINE_E_CTP_BDK_E_DAV_DISABLED = 0x80190755;
        // "The character set used for this transaction is not supported by the address verification service."
        public const uint XONLINE_E_CTP_BDK_E_DAV_INVALID_CHARSET = 0x80190756;
        // "BDK_E_RISK_LAST"
        public const uint XONLINE_E_CTP_BDK_E_RISK_LAST = 0x80190757;
        // "Soap request is invalid
        public const uint XONLINE_E_CTP_DMP_E_VALIDATION_ERROR = 0x80190758;
        // "Unknown Server Error."
        public const uint XONLINE_E_CTP_DMP_E_UNKNOWNSERVER_ERROR = 0x80190759;
        // "Server Configuration Problem."
        public const uint XONLINE_E_CTP_DMP_E_CONFIGURATION_ERROR = 0x80190760;
        // "A system internal error has occured."
        public const uint XONLINE_E_CTP_DMP_E_SYSTEM_INTERNAL_ERROR = 0x80190761;
        // "Invalid tenant ID input."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TENANT = 0x80190762;
        // "The tracking guid does not match the api signature."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_API_SIGNATURE = 0x80190763;
        // "User already registered."
        public const uint XONLINE_E_CTP_DMP_E_USER_REGISTERED = 0x80190764;
        // "The request cannot be completed due to user state."
        public const uint XONLINE_E_CTP_DMP_E_REQUEST_CANNOT_BE_COMPLETED = 0x80190765;
        // "User is not registered."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_UNREGISTERED = 0x80190766;
        // "The NextHandle parameter is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_NEXTHANDLE = 0x80190767;
        // "Date Range is not supported in the system."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_DATE_RANGE = 0x80190768;
        // "There is not sufficient balance to support this transaction."
        public const uint XONLINE_E_CTP_DMP_E_INSUFFICIENT_BALANCE = 0x80190769;
        // "The input data length is over system size limit."
        public const uint XONLINE_E_CTP_DMP_E_DATA_OVERLIMIT_ERROR = 0x80190770;
        // "The input item ExternalId is not unique within the items array."
        public const uint XONLINE_E_CTP_DMP_E_ITEM_UNIQUENESS_ERROR = 0x80190771;
        // "The item string input has invalid values."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_ITEM_VALUE = 0x80190772;
        // "Not all items included in this request are eligible for credit
        public const uint XONLINE_E_CTP_DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_CREDIT = 0x80190773;
        // "The confirmation id is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_CONFIRMATION_ID = 0x80190774;
        // "The SKU code is not supported."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SKU = 0x80190775;
        // "The SKU Type is incorrect for the API."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SKU_TYPE = 0x80190776;
        // "The promotional SKU has expired."
        public const uint XONLINE_E_CTP_DMP_E_PROMO_EXPIRED = 0x80190777;
        // "The user status is in requested state already."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_NOT_CHANGED = 0x80190778;
        // "The user country is in requested state already."
        public const uint XONLINE_E_CTP_DMP_E_COUNTRY_NOT_CHANGED = 0x80190779;
        // "The transaction type passed in is not valid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TRANSACTION_TYPE = 0x80190780;
        // "The original transaction is not eligible for cancellation because it has all or partial credit on it."
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_HAS_CREDIT = 0x80190781;
        // "The result point balance will exceed the policy max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_EXCEEDED = 0x80190782;
        // "The point amount exceeds the policy max acquisition limit per transaction."
        public const uint XONLINE_E_CTP_DMP_E_MAX_ACQUISITION_EXCEEDED = 0x80190783;
        // "The user consumption per period of time would exceed the policy limit."
        public const uint XONLINE_E_CTP_DMP_E_MAX_CONSUMPTION_EXCEEDED = 0x80190784;
        // "There are no more points to distribute for this tenant sku combination."
        public const uint XONLINE_E_CTP_DMP_E_NO_MORE_PROMO_POINTS = 0x80190785;
        // "The system is busy
        public const uint XONLINE_E_CTP_DMP_E_PROMO_POINTS_UNAVAILIABLE = 0x80190786;
        // "The original record was not found
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND = 0x80190787;
        // "The original transaction already is already debited."
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_HAS_DEBIT = 0x80190788;
        // "The original transaction must be a PurchaseItem transaction type."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TRANSACTION_TO_CREDIT = 0x80190789;
        // "The supplied reason code is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_REASON_CODE = 0x80190790;
        // "The promotional points user obtained would exceed the sku limit."
        public const uint XONLINE_E_CTP_DMP_E_PROMOTION_LIMIT_LIFE_MAX = 0x80190791;
        // "The requested state change is not allowed."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_CHANGE_NOT_ALLOWED = 0x80190792;
        // "The property value did not change
        public const uint XONLINE_E_CTP_DMP_E_PROPERTY_VALUE_NOT_CHANGED = 0x80190793;
        // "Not all items eligible for offset."
        public const uint XONLINE_E_CTP_DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_OFFSET = 0x80190794;
        // "The confirmationId is required."
        public const uint XONLINE_E_CTP_DMP_E_MUST_SPECIFY_CONFIRMATION = 0x80190795;
        // "the confirmationId has to be null."
        public const uint XONLINE_E_CTP_DMP_E_CONFIRMATION_HAS_TO_BE_NULL = 0x80190796;
        // "Exchange type is not valid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_EXCHANGE_TYPE = 0x80190797;
        // "The original transaction for creditbalance call must not be a subscription."
        public const uint XONLINE_E_CTP_DMP_E_CANNOT_CREDIT_SUBSCRIPTION = 0x80190798;
        // "Exchange price supplied does not match system rates."
        public const uint XONLINE_E_CTP_DMP_E_EXCHANGE_PRICE_MISMATCH = 0x80190799;
        // "Source Account is not in Active State for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SOURCE_ACCOUNT = 0x80190800;
        // "Destination Account is not in Active State for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_DESTINATION_ACCOUNT = 0x80190801;
        // "Source and Transfer Puid's are same."
        public const uint XONLINE_E_CTP_DMP_E_SOURCE_TRANSFER_PUIDS_SAME = 0x80190802;
        // "Source and Destination country code mismatch."
        public const uint XONLINE_E_CTP_DMP_E_COUNTRY_CODE_MISMATCH = 0x80190803;
        // "TransferBalance initiated within the no transfer window for the source account."
        public const uint XONLINE_E_CTP_DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x80190804;
        // "TransferBalance initiated within the no transfer window for the target account."
        public const uint XONLINE_E_CTP_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x80190805;
        // "Transferred points balance exceeded the system transferred provisional max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED = 0x80190806;
        // "Transferred points balance exceeded the system transferred promotional max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_TRANSFER_PROMOTIONAL_EXCEEDED = 0x80190807;
        // "TransferBalance doesnot support partial transfer
        public const uint XONLINE_E_CTP_DMP_E_PARTIAL_TRANSFER = 0x80190808;
        // "Source Puid cannot be zero for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_SOURCE_ZERO = 0x80190809;
        // "Destination Puid cannot be zero for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_DESTINATION_ZERO = 0x80190810;
        // "DelegateUser is not supported in Transfer Balance API"
        public const uint XONLINE_E_CTP_DMP_E_DELEGATE_NOT_SUPPORTED = 0x80190811;
        // "PMN does not exist"
        public const uint XONLINE_E_CTP_DMP_E_INVALID_PMN = 0x80190812;
        // "Invalid points distribution program."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM = 0x80190813;
        // "Invalid points distribution program calling partner."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_CALLING_PARTNER = 0x80190814;
        // "Invalid points distribution program selling partner."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SELLING_PARTNER = 0x80190815;
        // "Invalid points distribution program SKU."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SKU = 0x80190816;
        // "Invalid points distribution program user."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_USER = 0x80190817;
        // "User is not enrolled in the distribution program."
        public const uint XONLINE_E_CTP_DMP_DP_USER_NOT_ENROLLED = 0x80190818;
        // "User is disabled."
        public const uint XONLINE_E_CTP_DMP_E_USER_DISABLED = 0x80190819;
        // "The point amount acquired per period of time would exceed the policy limit."
        public const uint XONLINE_E_CTP_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 0x80190820;
        // "Risk check rejected"
        public const uint XONLINE_E_CTP_TRANSACTION_E_AUTHORIZATION_FAILED = 0x80190821;
        // "Invalid Subscription component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_SUBS_RESPONSE = 0x80190822;
        // "The line item has already been refunded."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_REFUND = 0x80190823;
        // "The transaction status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_TRANSACTION_STATUS = 0x80190824;
        // "Either the request is not allowed of this partner or the partner information is invalid"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_CALLING_PARTER = 0x80190825;
        // "Invalid account status"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ACCOUNT_STATUS = 0x80190826;
        // "Server encountered unspecified error."
        public const uint XONLINE_E_CTP_BILLING_E_INTERNAL_SERVER_ERROR = 0x80190827;
        // "The partial charge back is not supported"
        public const uint XONLINE_E_CTP_BILLING_E_PARITAL_CHARGE_BACK = 0x80190828;
        // "The passed in line item event id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM_EVENT = 0x80190829;
        // "The passed in tracking guid is not consistent with the server side record"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_TRACKING_GUID = 0x80190830;
        // "Timeout when calling external component"
        public const uint XONLINE_E_CTP_TRANSACTION_E_EXTERNAL_TIMEOUT_ERROR = 0x80190831;
        // "The passed in tracking guid is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_TRACKING_GUID = 0x80190832;
        // "The payment method information is invalid or the action is not applicable for this payment method"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x80190833;
        // "The passed in line item is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM = 0x80190834;
        // "The balance status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_BALANCE_STATUS = 0x80190835;
        // "The partner payment reference is invalid"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_PARTNER_PAYMENT_REF = 0x80190836;
        // "Cannot get decline type for the decline code"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_DECLINE_CODE = 0x80190837;
        // "The line item has already been charged back."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_CHARGED_BACK = 0x80190838;
        // "The passed in balance id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_BALANCE_ID = 0x80190839;
        // "The order status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ORDER_STATUS = 0x80190840;
        // "Unsupported server operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_OPERATION = 0x80190841;
        // "Invalid Account component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ACCOUNT_RESPONSE = 0x80190842;
        // "Unsupported server operation."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_OPERATION = 0x80190843;
        // "Same trasaction was processed by other thread"
        public const uint XONLINE_E_CTP_TRANSACTION_E_TRANSACTION_RACE_CONDITION = 0x80190844;
        // "API request does not pass server side validation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ARGUMENT = 0x80190845;
        // "Invalid PaymentMethod component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PAYMENTMETHOD_RESPONSE = 0x80190846;
        // "The line item has already been transfered cross SA and BSS."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 0x80190847;
        // "The payment provider declined the transaction"
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_DECLINE = 0x80190848;
        // "Offset amount must be greater than zero but less than or equal to original amount"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_OFFSET_AMOUNT = 0x80190849;
        // "Server encountered unspecified error."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INTERNAL_SERVER_ERROR = 0x80190850;
        // "The line item status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM_STATUS = 0x80190851;
        // "Invalid DMP component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_DMP_RESPONSE = 0x80190852;
        // "The payment provider returned a retryable error."
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_RETRYABLE_ERROR = 0x80190853;
        // "Invalid soft descriptor."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_SOFT_DESCRIPTOR = 0x80190854;
        // "The payment event type is unexpected in server side."
        public const uint XONLINE_E_CTP_BILLING_E_UNEXPECTED_PAYMENT_EVENT = 0x80190855;
        // "The merchant reference number is invalid."
        public const uint XONLINE_E_CTP_BILLING_E_UNRECOGNIZED_MRN = 0x80190856;
        // "Invalid partner certificate"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PARTNER = 0x80190857;
        // "The payment provider returned an error."
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_ERROR = 0x80190858;
        // "Invalid Tax component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_TAX_RESPONSE = 0x80190859;
        // "Invalid risk check response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_RISK_RESPONSE = 0x80190860;
        // "API request does not pass server side validation."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ARGUMENT = 0x80190861;
        // "The passed in order id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ORDER_ID = 0x80190862;
        // "Invalid Billing component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_BILLING_RESPONSE = 0x80190863;
        // "Invalid payment instrument status"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80190864;
        // "Currently DirectDebit Purchase API only supports purchase one and at least one new subscription"
        public const uint XONLINE_E_CTP_TRANSACTION_E_UNSUPPORTED_DD_OPERATION = 0x8015309A;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XRLRequest.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

using STF.common.config;
using STF.common.mgmt;
using STF.common.diagnostics;

#if MOCK_NET
using STF.test.mock.system.net;
#else 
using System.Net;
#endif

#if MOCK_WEB
using STF.test.mock.system.web;
#else
using System.Web;
#endif


namespace STF.common.service
{
    [ComVisible(false)]
    public class XrlRequest
    {
        
        // Interface to send request to
        public string TargetInterface
        {
            get { return _targetInterface; }
            set 
            { 
                _targetInterface = value;
                _targetVirtualInterface = VirtualInterface.None; 
                _targetInterfaceInfo = null;
            }
        }
        
        // Virutal interface to send request to
        public string TargetVirtualInterface
        {
            get { return _targetVirtualInterface; }
            set 
            { 
                _targetVirtualInterface = value;
                _targetInterface = Interface.None; 
                _targetInterfaceInfo = null;
            }
        }

        public IInterfaceInfo TargetInterfaceInfo
        {
            get { return _targetInterfaceInfo; }
            set 
            { 
                _targetInterfaceInfo = value;
                _targetInterface = Interface.None; 
                _targetVirtualInterface = VirtualInterface.None; 
            }
        }

        public Uri TargetUrl
        {
            get { return _targetUrl; }
            set
            {
                _targetUrl = value;
                
                _targetVirtualInterface = VirtualInterface.None; 
                _targetInterface = Interface.None; 
                _targetInterfaceInfo = null;
            }
        }    
        
        
        // Path of request
        public string Path = null;
        
        
        public Uri Url
        {
            get 
            {
                UriBuilder uribldr = new UriBuilder();
                
                if (_targetVirtualInterface != VirtualInterface.None)
                {
                    uribldr = new UriBuilder();
                    IVirtualInterfaceInfo interfaceInfo = Config.GetVirtualInterface(_targetVirtualInterface, Site.main);
                    uribldr.Host = interfaceInfo.IPAddressString;
                    uribldr.Port = interfaceInfo.Port;
                    uribldr.Scheme = interfaceInfo.Protocol;
                }
                else if (_targetInterface != Interface.None)
                {
                    uribldr = new UriBuilder();
                    IInterfaceInfo interfaceInfo = Config.GetSingleInterface(_targetInterface);
                    uribldr.Host = interfaceInfo.IPAddressString;
                    uribldr.Port = interfaceInfo.Port;
                    uribldr.Scheme = interfaceInfo.Protocol;
                }
                else if (_targetInterfaceInfo != null)
                {
                    uribldr = new UriBuilder();
                    uribldr.Host = _targetInterfaceInfo.IPAddressString;
                    uribldr.Port = _targetInterfaceInfo.Port;
                    uribldr.Scheme = _targetInterfaceInfo.Protocol;
                }
                else
                {
                    Assert.IsTrue(_targetUrl != null, "TargetVirtualInterface, TargetInterface, or TargetInterfaceInfo must be set!");
                    
                    uribldr = new UriBuilder(_targetUrl);
                }
                            
                uribldr.Path = Path;
                
                return uribldr.Uri;
            }    
        }    

        public int ServiceId
        {
            get 
            {
                if (_targetVirtualInterface != VirtualInterface.None)
                {
                    IVirtualInterfaceInfo interfaceInfo = Config.GetVirtualInterface(_targetVirtualInterface, Site.main);
                    return interfaceInfo.ServiceId;
                }
                else if (_targetInterface != Interface.None)
                {
                    IInterfaceInfo interfaceInfo = Config.GetSingleInterface(_targetInterface);
                    return interfaceInfo.ServiceId;
                }
                else if (_targetInterfaceInfo != null)
                {
                    return _targetInterfaceInfo.ServiceId;
                }
                else
                {
                    // the caller may have set TargetUrl, return 0 which is the old behavior
                    return 0;
                }
            }    
        }

        // auth data to include HttpAuthData header of the
        // http request.
        // 
        // defaults to the auth data included in the existing
        // request.  If none exists, the current SG Auth data
        // is used for the header value.   If no SG Auth is 
        // availble, the header is null.   
        //
        public string AuthData = null;

        private bool _IsBundleAuth = false;// this tells whether the AuthData is a Bundle Auth or a plain AuthData

        public bool IsBundleAuth
        {
            get
            {
                return _IsBundleAuth;
            }

            set
            {
                _IsBundleAuth = value;
            }
        }

        // Platform type of the source of this request. optional
        //
        public byte? PlatformType
        {
            get 
            { 
                return _PlatformType; 
            }
            set
            {
                _PlatformType = value;
            }
        }

        private byte? _PlatformType;



        // binary post data to send.
        // 
        // This value can also be set via PostXrlObject.
        //
        public byte[] PostData = null;
        
        //
        // XRLObject2 to send.
        // 
        // Setting this also sets the value of Path.
        //
        public XRLObject2 RequestOb
        {
            get { return _postOb; }
            set 
            { 
                _postOb = value; 
                //Path = (Path != null ? Path : _postOb.GetXRL());
                SchemaVersion = _postOb.SchemaVersion;
            }    
        }

        // Default if RequestOb isn't used
        public uint SchemaVersion = WireData.CurrentSchemaVersion;

        // Override setting for the default "xon/xx" value.  If the default is specified, it
        // will be computed from the other parameters, so the value will be set to null.
        private string _contentType = null;
        public string ContentTypeOverride
        {
            get { return _contentType; }
            set { _contentType = (value == null || value.StartsWith("xon/")) ? null : value; }
        }
        
        // Other headers to include in the request.
        //
        public WebHeaderCollection RequestHeaders = new WebHeaderCollection();
        
        
        // Raw bytes received from posting the request
        //
        public byte[] ResponseData = null;

        // XRLObject2 to translate the response to. 
        // 
        // Set this before calling one of the Send*() 
        // methods to have the response automatically
        // converted to this type.
        //
        public XRLObject2 ResponseOb = null;

        public WebHeaderCollection ResponseHeaders = null;


        
        // HResult received from sending the request
        // 
        public HResult Hr = HResult.S_FALSE;
        
        
        // Exception thrown during async posting of the request
        // 
        public Exception AsyncException = null;
        
        // WaitHandle for async requests.  Handle is set when 
        // request is complete.  Valid only after calling
        // SendAsync()
        // 
        public ManualResetEvent AsyncWaitHandle = null;
        
        // True when an asynchrnous send request is completed.
        //
        public bool IsCompleted = false;
    

                
                
        //-----------------------------------------------------
        // Send
        //      
        //      Sends an http POST request to another server
        //      with xrl-compliant header information.
        //
        //      The HRESULT returned in the server response is
        //      returned. 
        //
        //      If the status code is 500, but no X-Err header is
        //      present in the response, an exception is thrown. 
        //      If the status code is anything else but 200, an
        //      exception is thrown. 
        //
        public HResult Send()
        {
            HResult hr;
            string xErr;
            string contentTypeOverride = _contentType;
            
            if (AuthData == null)
            {
                AuthData = SGInfo.ToBase64String();
            }

            if (_postOb != null)
            {
                PostData = (byte[])_postOb;
                
                // Override based on the xrl, since if specified will know the proper value
                contentTypeOverride = _postOb.ContentType;
            }    
            
            if (PostData == null)
            {
                PostData = new byte[0];
            }
            
            WebClient myWebClient = new WebClient();

            if (IsBundleAuth)
            {
                myWebClient.Headers.Add(XHttpHdr.BUNDLEDAUTHDATA, AuthData);
            }
            else
            {
                myWebClient.Headers.Add(XHttpHdr.HTTPAUTHDATA, AuthData);                
            }
            
            //
            // XRLScan looks at these two headers
            //
            string serviceId = ServiceId.ToString("x");
            
            if (_PlatformType != null)
            {
                myWebClient.Headers.Add(XHttpHdr.XPLT, _PlatformType.ToString());
            }
            myWebClient.Headers.Add("Content-Type", contentTypeOverride ?? "xon/"+serviceId);
            myWebClient.Headers.Add("User-Agent", (serviceId+"/1.0.4325"));
            myWebClient.Headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(SchemaVersion));                
            
            myWebClient.Headers.Add(RequestHeaders);
            
            try
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "POSTing " + PostData.Length + " bytes to " + this.Url + "...");
                
                ResponseData = myWebClient.UploadData(Url.ToString(), "POST", PostData);
                ResponseHeaders = myWebClient.ResponseHeaders;

                // if we have a response that contains an error and/or  an
                // event header, then get that info to make some decisions

                hr = HResult.S_OK;
                xErr = ResponseHeaders["X-Err"];
                string xEvent = ResponseHeaders["X-Event"];

                if (! string.IsNullOrEmpty(xErr))
                {
                    hr = HResult.Parse(xErr);
                }

                // if we have HttpContext and we get back  an  X-Event
                // header,  then propagate the value  between  servers

                if (HttpContext.Current != null)
                {
                    HttpContext context = HttpContext.Current;
                    if (! string.IsNullOrEmpty(xEvent)) context.Items["X-Event"] = xEvent;
                }
                
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, Url.ToString() + " returned hr = " + hr);
            }
            catch (WebException e)
            {
                xErr = null;

                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                    string xEvent = e.Response.Headers["X-Event"];

                    // if we have HttpContext and we get back  an  X-Event
                    // header,  then propagate the value  between  servers

                    if (HttpContext.Current != null)
                    {
                        HttpContext context = HttpContext.Current;
                        if (!string.IsNullOrEmpty(xEvent)) context.Items["XEvent"] = xEvent;
                    }
                }
                
                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available. 
                    HttpStatusCode status = (e.Response == null ? HttpStatusCode.BadRequest : ((HttpWebResponse)e.Response).StatusCode); 
                    
                    throw new XrlRequestException(Url.ToString(), e.Message, (System.Net.HttpStatusCode)status, PostData, e);
                }

                hr = HResult.Parse(xErr);
                ResponseData = null;
                
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, Url.ToString() + " returned hr = " + hr);
            }
            
            if (ResponseData != null && ResponseOb != null)
            {
                ResponseOb.ReadBytes(ResponseData);
            }    
            
            Hr = hr;
            return hr;
        }
        
        //-----------------------------------------------------
        // SendAsync
        //      
        //      Posts the XRL request asynchronously
        //      
        //
        
        public void SendAsync()
        {
            string contentTypeOverride = _contentType;
            
            if (AuthData == null)
            {
                AuthData = SGInfo.ToBase64String();
            }

            if (_postOb != null)
            {
                PostData = (byte[])_postOb;
                contentTypeOverride = _postOb.ContentType;
            }    
            
            
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Getting request stream to post to " + Url.ToString() + "...");
            
            HttpWebRequest req = (HttpWebRequest)WebRequest.Create(Url);
            req.UnsafeAuthenticatedConnectionSharing = true;
            if (_PlatformType != null)
            {
                req.Headers.Add(XHttpHdr.XPLT, _PlatformType.ToString());
            }
            req.Headers.Add(XHttpHdr.HTTPAUTHDATA, AuthData);
            req.Headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(SchemaVersion));                
            req.Method = "POST";
            req.ContentLength = PostData.Length;
            
            //
            // XRLScan looks at these two headers
            //
            string serviceId = ServiceId.ToString("x");

            req.ContentType = contentTypeOverride ?? "xon/" + serviceId;
            req.UserAgent = serviceId+"/1.0.4325";
            
            req.Headers.Add(RequestHeaders);
            
            _httpRequest = req;
            AsyncWaitHandle = new ManualResetEvent(false);
            IsCompleted = false;

            
            req.BeginGetRequestStream(new AsyncCallback(this.SendAsyncStreamCallback), null);
        }

        private void SendAsyncStreamCallback(IAsyncResult asyncResult)
        {
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Writing " + PostData.Length + " bytes to " + _httpRequest.RequestUri.ToString() + "...");
            
            Stream s = _httpRequest.EndGetRequestStream(asyncResult);
            s.Write(PostData, 0, PostData.Length);
            s.Close();
            
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "POSTing  to " + _httpRequest.RequestUri.ToString() + "...");
            _httpRequest.BeginGetResponse(new AsyncCallback(this.SendAsyncCallback), null);
        }
            
            
        
        private void SendAsyncCallback(IAsyncResult asyncResult)
        {
            HttpWebResponse httpResponse = null;
            
            try
            {
                httpResponse = (HttpWebResponse)_httpRequest.EndGetResponse(asyncResult);
                HttpStatusCode status = (httpResponse == null ? HttpStatusCode.BadRequest : httpResponse.StatusCode); 
    
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "Async POST to " + _httpRequest.RequestUri.ToString() + " completed!   Status " + status);
                Hr = HResult.S_OK;
                
                string xErr = httpResponse.Headers["X-Err"];
                if (xErr != null)
                {
                    Hr = HResult.Parse(xErr);
                }
                    
                if (status != HttpStatusCode.OK && Hr.IsOk())
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available. 
                    throw new XrlRequestException(_httpRequest.RequestUri.ToString(), "The asynchronous POST failed!", status,
                                null, null);
                }
                
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, _httpRequest.RequestUri.ToString() + " returned " + Hr + " (" + httpResponse.ContentLength + " bytes)");
                
                
                if (httpResponse.ContentLength > 0)
                {
                    BinaryReader reader = new BinaryReader(httpResponse.GetResponseStream());
                    ResponseData = reader.ReadBytes((int)httpResponse.ContentLength);
                    
                    if (ResponseOb != null)
                    {
                        ResponseOb.ReadBytes(ResponseData);
                    }    
                }        
                
                ResponseHeaders = httpResponse.Headers;
                
            }
            catch(Exception e)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_ERROR, "PostAsyncXrlRequestCallback encountered an error! " + e.ToString());
                AsyncException = e;
                Hr = HResult.XONLINE_E_RESPONSE_ERROR;
            }
            finally
            {
                if (httpResponse != null) httpResponse.Close();

                IsCompleted = true;    
                AsyncWaitHandle.Set();
            }
                
        }
        
        
        private string _targetInterface = Interface.None; 
        private string _targetVirtualInterface = VirtualInterface.None;
        private IInterfaceInfo _targetInterfaceInfo = null; 
        private Uri _targetUrl;

        private XRLObject2 _postOb = null;
   

        private HttpWebRequest _httpRequest;
        
    }
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xrlobject2.cs ===
using System;
using System.Web;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections.Specialized;
using System.Diagnostics;

using STF.common.mgmt;

namespace STF.common.service
{
    [ComVisible(false)]
    public class XRLObject2 : WireData
    {
        public virtual string ContentType
        {
            get { return null; }
        }

        //-----------------------------------------------------
        // ReadFromRequest
        //
        public virtual void ReadFromRequest(HttpRequest req)
        {
            Type t = this.GetType();

            BinaryReader reader = new BinaryReader(req.InputStream);

            Debug.Assert(req.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer..." );

            // Allow the base WireData class to read
            ReadStream(reader);

            // failures here can be ignored, this is just for logging purposes
            try
            {
                if (HttpContext.Current != null && HttpContext.Current.Items["XRLRequest"] == null)
                {
                    HttpContext.Current.Items["XRLRequest"] = this;
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_WARNING, "Error setting HttpContext.Current.Items[\"XRLRequest\"]: " + e.ToString());
            }
        }

        public virtual void ReadFromRequest(BinaryReader reader, UTF8Encoding enc, long len, NameValueCollection queryString)
        {
            Type t = this.GetType();

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer..." );

            // QueryString reading no longer supported
            if (len == 0 && queryString != null && queryString.Count != 0)
            {
                throw new Exception("XRLObject.ReadFromRequest: Post buffer empty!Read from QueryString no longer supported by XRLObject2");
            }

            // Allow the base WireData class to read
            ReadStream(reader);
        }

        //-----------------------------------------------------
        // WriteToResponse
        //
        //      this overrideable implementation uses reflection
        //      to find any instance fields, and writes
        //      most common types to the response stream in the
        //      order of declaration.
        //
        //      - strings are sent in UTF8.
        //      - DateTime is sent as a SYSTEMTIME struct as
        //      defined by windows.h(?)
        //
        public virtual void WriteToResponse(HttpResponse resp)
        {
            BinaryWriter writer = new BinaryWriter(resp.OutputStream);
            Debug.Assert(resp.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject.WriteToResponse: Writing " + GetType().ToString() + " to response...");
            WriteStream(writer);
        }


        public void WriteToResponse(BinaryWriter writer, UTF8Encoding enc)
        {
            // Allow the base WireData class to write
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject.WriteToResponse: Writing " + GetType().ToString() + " to response...");
            WriteStream(writer);
        }

        public virtual string Xrl
        {
            get
            {
                return String.Empty;
            }
        }

        public string GetXRL()
        {
            return Xrl;
        }

        public virtual byte[] GetBytes()
        {
            return (byte[])this;
        }

        public virtual void SetBytes(byte[] buf)
        {
            ReadBytes(buf);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XEvent.Id.cs ===
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES 
/////////////////////////////////////////////////////////////////////////////// 
 
using System; 
 
namespace STF.common.service 
{ 
    public partial class XEvent 
    { 
        public enum Id : uint 
        { 
            ACCELERATION_STARTUP_MGMT_INIT_FAILED = 20500 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_MGMT_REGISTER_FAILED = 20501 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_CONFIG_FAILED = 20502 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_PERF_COUNTERS_FAILED = 20503 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_BUFFER_POOL_FAILED = 20504 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_SWITCHBOARD_FAILED = 20505 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_MRU_LIST_FAILED = 20506 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_CHANGELIST_FAILED = 20507 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_LOOKUP_TABLE_FAILED = 20508 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_LISTENER_FAILED = 20509 | XEvent.Severity.Error,
            ACCELERATION_STARTUP_ALLOCATOR_FAILED = 20517 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_LISTENER_FAILED = 20510 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_SETTING_FAILED = 20511 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_OUT_OF_MEMORY = 20512 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_POST_COMPLETION_FAILED = 20513 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_WAIT_COMPLETION_FAILED = 20514 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_HEALTHINTEROP_CREATE = 20515 | XEvent.Severity.Error,
            ACCELERATION_CONFIG_HEALTHINTEROP_INIT = 20516 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_INIT_COMPLETION_PORT_FAILED = 20520 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_INIT_CREATE_INSTANCE_FAILED = 20521 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_INIT_FAILED = 20522 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_INIT_LISTEN_FAILED = 20523 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_ACCEPT_FAILED = 20524 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_SIZE_MISMATCH = 20525 | XEvent.Severity.Error,
            ACCELERATION_SOCKET_PROCESS_REQUEST_FAILED = 20526 | XEvent.Severity.Error,
            ACCELERATION_PROXY_BUCKET_MAP_FAILED = 20530 | XEvent.Severity.Error,
            ACCELERATION_PROXY_BUCKET_CHANGE_FAILED = 20531 | XEvent.Severity.Error,
            ACCELERATION_PROXY_SERVER_CHANGE_FAILED = 20532 | XEvent.Severity.Error,
            ACCELERATION_PROXY_CONNECT_FAILED = 20533 | XEvent.Severity.Error,
            ACCELERATION_PROXY_SEND_FAILED = 20534 | XEvent.Severity.Error,
            ACCELERATION_PROXY_RECEIVE_FAILED = 20535 | XEvent.Severity.Error,
            ACCELERATION_PROXY_CALLBACK_EXCEPTION = 20536 | XEvent.Severity.Error,
            ACCELERATION_PROXY_REMOVE_FAILED = 20537 | XEvent.Severity.Error,
            ACCELERATION_PROXY_REQUEST_FAILED = 20538 | XEvent.Severity.Error,
            ACCELERATION_PROXY_NOT_INITIALIZED = 20539 | XEvent.Severity.Error,
            ACCELERATION_PROXY_NOTIFICATION_FAILED = 20540 | XEvent.Severity.Error,
            ACCELERATION_UNSUPPORTED_MESSAGE = 20575 | XEvent.Severity.Error,
            ACCELERATION_SERVER_TOO_BUSY = 20576 | XEvent.Severity.Error,
            ACCELERATION_SERVER_BUFFERPOOL_OUTOFMEMORY = 20577 | XEvent.Severity.Error,
            ACCELERATION_WARN_0 = 20600 | XEvent.Severity.Warning,
            ACCELERATION_STARTED = 20700 | XEvent.Severity.Info,
            ACCELERATION_SHUTDOWN_STARTED = 20701 | XEvent.Severity.Info,
            ACCELERATION_SHUTDOWN_COMPLETE = 20702 | XEvent.Severity.Info,
            ACCELERATION_CONFIG_SETTING_CHANGED = 20703 | XEvent.Severity.Info,
            ACCELERATION_INFO_SERVER_RESUME = 20704 | XEvent.Severity.Info,
            AAGW_CONFIG_INVALID_ALLOWLISTENTRY = 15000 | XEvent.Severity.Error,
            AAM_UODB_DATABASE_ERROR = 63825 | XEvent.Severity.Error,
            AAM_HANDLEREQUEST_ERROR = 63826 | XEvent.Severity.Error,
            AAM_CONFIG_INFO = 63827 | XEvent.Severity.Info,
            AAM_CONFIG_WARNING = 63828 | XEvent.Severity.Warning,
            AAM_CONFIG_ERROR = 63829 | XEvent.Severity.Error,
            AAM_POLICY_RELOADED = 63830 | XEvent.Severity.Info,
            AAM_CONFIG_RPS_ERROR = 63831 | XEvent.Severity.Error,
            AAM_INFO_TRACKING_START = 63832 | XEvent.Severity.Warning,
            AAM_INFO_TRACKING_STOP = 63833 | XEvent.Severity.Info,
            AAM_INFO_THROTTLING_START = 63834 | XEvent.Severity.Warning,
            AAM_INFO_THROTTLING_STOP = 63835 | XEvent.Severity.Info,
            AAM_INFO_BLOCKING_START = 63836 | XEvent.Severity.Warning,
            AAM_INFO_BLOCKING_STOP = 63837 | XEvent.Severity.Info,
            AAM_ANTIDOS_LIMIT_EXCEEDED = 63838 | XEvent.Severity.Error,
            AAGW_HACK_URL = 63850 | XEvent.Severity.Error,
            AAGW_HACK_UNKNOWN_SERVICE = 63851 | XEvent.Severity.Error,
            AAGW_HACK_UNKNOWN_HTTP_METHOD = 63852 | XEvent.Severity.Error,
            AAGW_HACK_URL_TOO_LONG = 63853 | XEvent.Severity.Error,
            AAGW_HACK_QUERY_TOO_LONG = 63854 | XEvent.Severity.Error,
            AAGW_HACK_CONTENT_TOO_LONG = 63855 | XEvent.Severity.Error,
            AAGW_EXCEPTION_WITH_NO_RESPONSE = 63856 | XEvent.Severity.Error,
            AAGW_CONFIG_INVALID_SETTING = 63857 | XEvent.Severity.Error,
            AAGW_CONFIG_SERVICE_TABLE = 63858 | XEvent.Severity.Error,
            AAGW_CONFIG_INFO = 63859 | XEvent.Severity.Info,
            AAGW_INTERNAL_ERROR = 63860 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT = 50000 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_1 = 50001 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_2 = 50002 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_3 = 50003 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_4 = 50004 | XEvent.Severity.Error,
            XEVENTS_NULL_BUFFER = 50005 | XEvent.Severity.Error,
            XEVENTS_NULL_BUFFER_1 = 50006 | XEvent.Severity.Error,
            ALERTS_CODE_7 = 50007 | XEvent.Severity.Error,
            ALERTS_CODE_8 = 50008 | XEvent.Severity.Error,
            XEVENTS_BAD_PACKET = 50009 | XEvent.Severity.Error,
            XEVENTS_BAD_PACKET_1 = 50010 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_5 = 50011 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_6 = 50012 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_7 = 50013 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_8 = 50014 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_9 = 50015 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_10 = 50016 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_11 = 50017 | XEvent.Severity.Error,
            XEVENTS_FAIL_INIT_12 = 50018 | XEvent.Severity.Error,
            XEVENTS_RECEIVE_FAIL = 50050 | XEvent.Severity.Error,
            XEVENTS_RECEIVE_FAIL_1 = 50051 | XEvent.Severity.Error,
            ALERTS_COMM_2 = 50052 | XEvent.Severity.Error,
            ALERTS_COMM_3 = 50053 | XEvent.Severity.Error,
            ALERTS_COMM_4 = 50054 | XEvent.Severity.Error,
            ALERTS_COMM_5 = 50055 | XEvent.Severity.Error,
            ALERTS_COMM_6 = 50056 | XEvent.Severity.Error,
            ALERTS_COMM_7 = 50057 | XEvent.Severity.Error,
            ALERTS_COMM_8 = 50058 | XEvent.Severity.Error,
            ALERTS_COMM_9 = 50059 | XEvent.Severity.Error,
            ALERTS_CONFIG_0 = 50100 | XEvent.Severity.Error,
            ALERTS_CONFIG_1 = 50101 | XEvent.Severity.Error,
            ALERTS_CONFIG_2 = 50102 | XEvent.Severity.Error,
            ALERTS_CONFIG_3 = 50103 | XEvent.Severity.Error,
            ALERTS_CONFIG_4 = 50104 | XEvent.Severity.Error,
            ALERTS_CONFIG_5 = 50105 | XEvent.Severity.Error,
            ALERTS_CONFIG_6 = 50106 | XEvent.Severity.Error,
            ALERTS_CONFIG_7 = 50107 | XEvent.Severity.Error,
            ALERTS_INFO_0 = 50125 | XEvent.Severity.Info,
            ALERTS_INFO_1 = 50126 | XEvent.Severity.Info,
            ALERTS_INFO_2 = 50127 | XEvent.Severity.Info,
            ALERTS_INFO_3 = 50128 | XEvent.Severity.Info,
            ARBITRATION_INTERNAL_FATAL_ERROR = 50150 | XEvent.Severity.Error,
            ARBITRATION_INTERNAL_FATAL_ERROR_1 = 50151 | XEvent.Severity.Error,
            ARBITRATION_CODE_2 = 50152 | XEvent.Severity.Error,
            ARBITRATION_CODE_3 = 50153 | XEvent.Severity.Error,
            ARBITRATION_INTERNAL_FATAL_ERROR_2 = 50154 | XEvent.Severity.Error,
            ARBITRATION_CODE_5 = 50155 | XEvent.Severity.Error,
            ARBITRATION_CODE_6 = 50156 | XEvent.Severity.Error,
            ARBITRATION_CODE_7 = 50157 | XEvent.Severity.Error,
            ARBITRATION_INTERFACE_BUCKET_THREAD = 50158 | XEvent.Severity.Error,
            ARBITRATION_INTERFACE_BUCKET_UNABLE_TO_QUEUE_EVENT = 50159 | XEvent.Severity.Error,
            ARBITRATION_COMM_0 = 50175 | XEvent.Severity.Error,
            ARBITRATION_COMM_1 = 50176 | XEvent.Severity.Error,
            ARBITRATION_COMM_2 = 50177 | XEvent.Severity.Error,
            ARBITRATION_COMM_3 = 50178 | XEvent.Severity.Error,
            ARBITRATION_COMM_4 = 50179 | XEvent.Severity.Error,
            ARBITRATION_COMM_5 = 50180 | XEvent.Severity.Error,
            ARBITRATION_COMM_6 = 50181 | XEvent.Severity.Error,
            ARBITRATION_COMM_7 = 50182 | XEvent.Severity.Error,
            ARBITRATION_COMM_8 = 50183 | XEvent.Severity.Error,
            ARBITRATION_COMM_9 = 50184 | XEvent.Severity.Error,
            ARBITRATION_COMM_10 = 50185 | XEvent.Severity.Error,
            ARBITRATION_COMM_11 = 50186 | XEvent.Severity.Error,
            ARBITRATION_COMM_12 = 50187 | XEvent.Severity.Error,
            ARBITRATION_CONFIG_0 = 50225 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR = 50226 | XEvent.Severity.Warning,
            ARBITRATION_CONFIGURATION_ERROR_1 = 50227 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR_2 = 50228 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR_3 = 50229 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR_4 = 50230 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR_5 = 50231 | XEvent.Severity.Error,
            ARBITRATION_CONFIGURATION_ERROR_6 = 50232 | XEvent.Severity.Warning,
            ARBITRATION_CONFIGURATION_ERROR_7 = 50233 | XEvent.Severity.Error,
            ARBITRATION_CONFIG_9 = 50234 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT = 50275 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_1 = 50276 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_2 = 50277 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_3 = 50278 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_4 = 50279 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_5 = 50280 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_6 = 50281 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_7 = 50282 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_8 = 50283 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT = 50284 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_1 = 50285 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_2 = 50286 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_3 = 50287 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_9 = 50288 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_4 = 50289 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_5 = 50290 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_10 = 50291 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_11 = 50292 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_12 = 50293 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_6 = 50294 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_7 = 50295 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_13 = 50296 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_8 = 50297 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_9 = 50298 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_14 = 50299 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_10 = 50300 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_15 = 50301 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_11 = 50302 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_12 = 50303 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_13 = 50304 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_16 = 50305 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_17 = 50306 | XEvent.Severity.Warning,
            ARBITRATION_BAD_REQUEST_FROM_CLIENT_18 = 50307 | XEvent.Severity.Warning,
            ARBITRATION_HACKER_ALERT_14 = 50308 | XEvent.Severity.Warning,
            ARBITRATION_HACK_34 = 50309 | XEvent.Severity.Warning,
            ARBITRATION_HACK_35 = 50310 | XEvent.Severity.Warning,
            ARBITRATION_HACK_36 = 50311 | XEvent.Severity.Warning,
            ARBITRATION_HACK_37 = 50312 | XEvent.Severity.Warning,
            ARBITRATION_HACK_38 = 50313 | XEvent.Severity.Warning,
            ARBITRATION_HACK_39 = 50314 | XEvent.Severity.Warning,
            ARBITRATION_HACK_40 = 50315 | XEvent.Severity.Warning,
            ARBITRATION_HACK_41 = 50316 | XEvent.Severity.Warning,
            ARBITRATION_HACK_42 = 50317 | XEvent.Severity.Warning,
            ARBITRATION_HACK_43 = 50318 | XEvent.Severity.Warning,
            ARBITRATION_HACK_44 = 50319 | XEvent.Severity.Warning,
            ARBITRATION_HACK_45 = 50320 | XEvent.Severity.Warning,
            ARBITRATION_INFO_1 = 50376 | XEvent.Severity.Info,
            ARBITRATION_INFO_2 = 50377 | XEvent.Severity.Info,
            ARBITRATION_INFO_3 = 50378 | XEvent.Severity.Info,
            ARBITRATION_TITLEBUG_0 = 50400 | XEvent.Severity.Error,
            ARBITRATION_TITLEBUG_1 = 50401 | XEvent.Severity.Error,
            ASKDC_KDCMANAGED_WSREADER_ERROR_1 = 10000 | XEvent.Severity.Error,
            ASKDC_BAD_PARAMETER = 53225 | XEvent.Severity.Error,
            ASKDC_BAD_PARAMETER_1 = 53226 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY = 53227 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_1 = 53228 | XEvent.Severity.Error,
            KDC_BASE_BAD_KERBCRYPT = 53229 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_2 = 53230 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_3 = 53231 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_4 = 53232 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_NO_MEMORY_5 = 53233 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_NO_MEMORY_6 = 53234 | XEvent.Severity.Error,
            KDC_CODE_10 = 53235 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR = 53236 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_7 = 53237 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_1 = 53238 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_8 = 53239 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_2 = 53240 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_3 = 53241 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_4 = 53242 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_5 = 53243 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_6 = 53244 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_7 = 53245 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_9 = 53246 | XEvent.Severity.Error,
            KDC_CODE_22 = 53247 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_8 = 53248 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_10 = 53249 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_9 = 53250 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_11 = 53251 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_10 = 53252 | XEvent.Severity.Error,
            KDC_CODE_28 = 53253 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_11 = 53254 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_12 = 53255 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_13 = 53256 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_12 = 53257 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_13 = 53258 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_NO_MEMORY_14 = 53259 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_15 = 53260 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_16 = 53261 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_14 = 53262 | XEvent.Severity.Error,
            KDC_CODE_38 = 53263 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_15 = 53264 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_16 = 53265 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_17 = 53266 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_18 = 53267 | XEvent.Severity.Error,
            KDC_CODE_43 = 53268 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_WSREADER_ERROR_19 = 53269 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_BAD_PARAMETER_2 = 53270 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_17 = 53271 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_BAD_PARAMETER_3 = 53272 | XEvent.Severity.Error,
            KDC_CODE_48 = 53273 | XEvent.Severity.Error,
            KDC_CODE_49 = 53274 | XEvent.Severity.Error,
            DEPRACATED_KDC_CODE_50 = 53275 | XEvent.Severity.Error,
            DEPRACATED_KDC_CODE_51 = 53276 | XEvent.Severity.Error,
            KDC_CODE_52 = 53277 | XEvent.Severity.Error,
            KDC_CODE_53 = 53278 | XEvent.Severity.Error,
            KDC_CODE_54 = 53279 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_20 = 53280 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_21 = 53281 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_22 = 53282 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_18 = 53283 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_19 = 53284 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_23 = 53285 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_24 = 53286 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_20 = 53287 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_25 = 53288 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_26 = 53289 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_27 = 53290 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_28 = 53291 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_29 = 53292 | XEvent.Severity.Error,
            ASKDC_NO_CRYPTOHELPER = 53293 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_30 = 53294 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_21 = 53295 | XEvent.Severity.Error,
            ASKDC_WSREADER_ERROR_31 = 53296 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_22 = 53297 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_23 = 53298 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_24 = 53299 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_25 = 53300 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_26 = 53301 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_27 = 53302 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_28 = 53303 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_29 = 53304 | XEvent.Severity.Error,
            ASKDC_CODE_MEMORY_ALLOCATION_ERROR = 53664 | XEvent.Severity.Error,
            ASKDC_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE = 53665 | XEvent.Severity.Error,
            ASKDC_CODE_MEMORY_ALLOCATION_ERROR_2 = 53666 | XEvent.Severity.Error,
            ASKDC_CODE_FAILED_TO_ENCRYPT_REPLY = 53667 | XEvent.Severity.Error,
            ASKDC_CODE_FAILED_TO_PACK_REPLY = 53668 | XEvent.Severity.Error,
            ASKDC_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID = 53669 | XEvent.Severity.Error,
            ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID = 53672 | XEvent.Severity.Error,
            ASKDC_FAILED_TO_LOAD_ECHO_DATA_KEY = 53675 | XEvent.Severity.Error,
            ASKDC_BAD_PARAMETER_4 = 53676 | XEvent.Severity.Error,
            ASKDC_DOS_CACHE_TOO_SMALL = 54250 | XEvent.Severity.Error,
            ASKDC_DOS_CACHE_TOO_SMALL_1 = 54251 | XEvent.Severity.Error,
            ASKDC_REGISTER_FAILURE = 54252 | XEvent.Severity.Error,
            ASKDC_REGISTER_FAILURE_1 = 54253 | XEvent.Severity.Error,
            ASKDC_REGISTER_FAILURE_2 = 54254 | XEvent.Severity.Error,
            ASKDC_REGISTER_FAILURE_3 = 54255 | XEvent.Severity.Error,
            KDC_CONFIG_6 = 54256 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE = 54257 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE_1 = 54258 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE_2 = 54259 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE_3 = 54260 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE_4 = 54261 | XEvent.Severity.Error,
            DEPRACATED_ASKDC_INIT_FAILURE_5 = 54262 | XEvent.Severity.Error,
            ASKDC_INIT_WARNING = 54263 | XEvent.Severity.Warning,
            ASKDC_INIT_WARNING_1 = 54264 | XEvent.Severity.Warning,
            ASKDC_INIT_WARNING_2 = 54265 | XEvent.Severity.Warning,
            ASKDC_INIT_WARNING_3 = 54266 | XEvent.Severity.Warning,
            ASKDC_DECRYPTION_FAILED = 54267 | XEvent.Severity.Error,
            KDC_CONFIG_18 = 54268 | XEvent.Severity.Warning,
            ASKDC_INVALID_PASSPORT_KEY_VERSION = 54269 | XEvent.Severity.Error,
            DEPRACATED_KDC_CONFIG_20 = 54270 | XEvent.Severity.Error,
            ASKDC_SET_PASSPORT_KEY_VERSION = 54271 | XEvent.Severity.Error,
            KDC_CONFIG_22 = 54272 | XEvent.Severity.Error,
            ASKDC_TOO_MANY_USER_KEY_VERSIONS = 54273 | XEvent.Severity.Error,
            KDC_CONFIG_24 = 54274 | XEvent.Severity.Error,
            ASKDC_FAILED_TO_INITIALIZE_PASSPORT = 54368 | XEvent.Severity.Error,
            ASKDC_INIT_FAILURE_6 = 54372 | XEvent.Severity.Error,
            ASKDC_CRYPTO_FAILURE = 54373 | XEvent.Severity.Error,
            ASKDC_DOS_REPLAY = 54650 | XEvent.Severity.Warning,
            KDC_HACK_1 = 54651 | XEvent.Severity.Warning,
            KDC_HACK_2 = 54652 | XEvent.Severity.Warning,
            ASKDC_PPA_PADATA_MISSING = 54653 | XEvent.Severity.Warning,
            ASKDC_BAD_CLIENT_NAME = 54654 | XEvent.Severity.Warning,
            KDC_HACK_5 = 54655 | XEvent.Severity.Warning,
            ASKDC_HACK_INVALID_PRE_AUTH_TYPE = 54702 | XEvent.Severity.Warning,
            ASKDC_HACK_MALFORMED_PRE_AUTH = 54703 | XEvent.Severity.Warning,
            ASKDC_HACK_FAILED_TO_CRACK_PASSPORT_TICKET = 54704 | XEvent.Severity.Warning,
            ASKDC_HACK_INVALID_REQUEST = 54705 | XEvent.Severity.Warning,
            ASKDC_HACK_DOS_ATTACK = 54707 | XEvent.Severity.Warning,
            ASKDC_HACK_MALFORMED_PRE_AUTH_1 = 54715 | XEvent.Severity.Warning,
            ASKDC_UNKNOWN_SERVER_PRINCIPAL = 54716 | XEvent.Severity.Error,
            ASKDC_REGISTER_SUCCESS = 54750 | XEvent.Severity.Info,
            ASKDC_REGISTER_SUCCESS_1 = 54751 | XEvent.Severity.Info,
            ASKDC_INIT_SUCCESS = 54752 | XEvent.Severity.Info,
            ASKDC_TERM_SUCCESS = 54753 | XEvent.Severity.Info,
            ASKDC_RELOAD_SUCCESS = 54754 | XEvent.Severity.Info,
            DEPRACATED_ASKDC_PPA_LOADING_INFO = 54755 | XEvent.Severity.Info,
            DEPRACATED_ASKDC_PPA_LOADING_INFO_1 = 54756 | XEvent.Severity.Info,
            KDC_INFO_7 = 54757 | XEvent.Severity.Info,
            XCBK_NOTIFY_KEY_NOT_FOUND_IN_MESSAGE = 15000 | XEvent.Severity.Error,
            XCBK_NOTIFY_SETTING_NOT_FOUND = 15001 | XEvent.Severity.Error,
            XCBK_NOTIFY_UNAUTHORIZED_REQUEST = 15002 | XEvent.Severity.Error,
            XCBK_NOTIFY_UNKNOWN_ERROR = 15003 | XEvent.Severity.Error,
            PASSPORT_DELETE_CREDENTIAL_ERROR = 15004 | XEvent.Severity.Error,
            PASSPORT_ENUM_CREDENTIALS_BY_NAME_ERROR = 15005 | XEvent.Severity.Error,
            PASSPORT_FORCE_CREDENTIAL_RENAME_ERROR = 15006 | XEvent.Severity.Error,
            USER_PURCHASE_NOT_ELIGIBLE_FOR_FREE_GAMERTAG_CHANGE = 15007 | XEvent.Severity.Error,
            XCBK_NOTIFY_BILLING_NOTIFICATION_ADD_FAILURE = 15015 | XEvent.Severity.Error,
            XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ADD_FAILURE = 15016 | XEvent.Severity.Error,
            XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ACCOUNT_MISMATCH = 15017 | XEvent.Severity.Error,
            CTP_TRANSACTIONSERVICE_UNKNOWN_ERROR = 15008 | XEvent.Severity.Error,
            CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR = 15009 | XEvent.Severity.Error,
            CTP_NON_USER_EXCEPTION = 15010 | XEvent.Severity.Error,
            CTP_TRANSACTIONSERVICE_VALIDATION_PATH = 15011 | XEvent.Severity.Error,
            CTP_TRANSACTIONSERVICE_INVALID_SUBSCRIPTION_RESPONSE = 15012 | XEvent.Severity.Warning,
            CTP_TRANSACTIONSERVICE_INVALIDARGS = 15013 | XEvent.Severity.Error,
            PREVIEW_PRODUCT_PURCHASE_MEDIA_TYPE_MISMATCH = 15014 | XEvent.Severity.Error,
            CTP_PARTNER_CONFIGURATION_ERROR = 15018 | XEvent.Severity.Error,
            CATALOG_MEDIACLASS_SETTING_MALFORMATTED = 49991 | XEvent.Severity.Error,
            OFFER_REDUCED_PRICECHECK_MALFORMATTED = 49992 | XEvent.Severity.Error,
            VIDEOCATALOG_SETTINGS_MALFORMATTED = 49993 | XEvent.Severity.Error,
            STORECATALOG_DEFAULT_SETTINGS_MISSING = 49994 | XEvent.Severity.Error,
            STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_1 = 49995 | XEvent.Severity.Error,
            STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_2 = 49996 | XEvent.Severity.Error,
            STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_1 = 49997 | XEvent.Severity.Error,
            STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_2 = 49998 | XEvent.Severity.Error,
            STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_3 = 49999 | XEvent.Severity.Error,
            CERT_GRABBER_GET_CERT_FAILURE = 40000 | XEvent.Severity.Error,
            CERT_GRABBER_PARSE_CERT_FAILURE = 40001 | XEvent.Severity.Error,
            CERT_GRABBER_UPDATE_CERT_FAILURE = 40002 | XEvent.Severity.Error,
            PLUGIN_CERTGRABBER_CERTIFICATE_UPDATED = 40003 | XEvent.Severity.Info,
            OFFER_ID_LOOKUP_FAILURE = 40004 | XEvent.Severity.Error,
            REINSTATE_DELAYED_CANCEL_FAILURE = 40005 | XEvent.Severity.Error,
            XCBK_UNEXPECTED_REQUEST = 50426 | XEvent.Severity.Error,
            XCBK_UNKNOWN_ERROR = 50429 | XEvent.Severity.Error,
            XCBK_UNKNOWN_ERROR_1 = 50431 | XEvent.Severity.Error,
            XCBK_UNEXPECTED_REQUEST_1 = 50434 | XEvent.Severity.Error,
            XCBK_UNKNOWN_ERROR_2 = 50435 | XEvent.Severity.Error,
            XCBK_UNKNOWN_ERROR_3 = 50436 | XEvent.Severity.Error,
            XCBK_UNKNOWN_ERROR_4 = 50437 | XEvent.Severity.Error,
            MC_BAD_PARAMETER_3 = 50438 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_8 = 50440 | XEvent.Severity.Error,
            MC_SPS_UNRECOGNIZED_ERROR_1 = 50442 | XEvent.Severity.Error,
            FAIL_FAST_EXIT = 50455 | XEvent.Severity.Info,
            FAIL_FAST_ENTER = 50456 | XEvent.Severity.Error,
            DEPRECATED_BILLING_CODE_49 = 50474 | XEvent.Severity.Error,
            DEPRECATED_BILLING_CODE_50 = 50475 | XEvent.Severity.Error,
            DEPRECATED_BILLING_CODE_65 = 50490 | XEvent.Severity.Error,
            UNKOWN_OFFER_TYPE = 50493 | XEvent.Severity.Error,
            UNKOWN_PAYMENT_TYPE = 50494 | XEvent.Severity.Error,
            GEOFENCE_COMPONENT_RETURNED_NULL = 50495 | XEvent.Severity.Warning,
            GEOFENCE_COMPONENT_RETURNED_EXCEPTION = 50496 | XEvent.Severity.Error,
            DEPRECATED_GET_MACHINE_PART_NUMBER_FAILED = 50497 | XEvent.Severity.Error,
            DEPRECATED_TRANSFER_MACHINE_LICENSES_FAILED = 50498 | XEvent.Severity.Error,
            DEPRECATED_TRANSFER_MACHINE_LICENSES_ASSET_CHECK_FAILED = 50499 | XEvent.Severity.Error,
            GET_PUID_FROM_MEMBERNAME_ERROR = 50500 | XEvent.Severity.Error,
            XCBK_UNKNOWN_SERVICE_COMPONENT = 50526 | XEvent.Severity.Error,
            MC_SPS_TIMEOUT = 50527 | XEvent.Severity.Error,
            MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED = 50534 | XEvent.Severity.Error,
            BDK_BLOCKING_SCS_APIS_BAD_MULTISETTING = 50535 | XEvent.Severity.Error,
            CATALOG_MUSIC_MNETID_INVALID = 50536 | XEvent.Severity.Error,
            CATALOG_QUERY_ERROR = 50537 | XEvent.Severity.Error,
            XCBK_DATABASE_UNAVAILABLE = 50550 | XEvent.Severity.Error,
            XCBK_DATABASE_UNAVAILABLE_1 = 50551 | XEvent.Severity.Error,
            MC_SPS_OFFER_MISCONFIGURATION_3 = 50553 | XEvent.Severity.Error,
            MC_SPS_OFFER_MISCONFIGURATION_4 = 50554 | XEvent.Severity.Error,
            MC_SPS_OFFER_MISCONFIGURATION_5 = 50555 | XEvent.Severity.Error,
            MC_BILLING_PROVIDER_INIT_ERROR = 50556 | XEvent.Severity.Error,
            UODB_ACCESS_ERROR = 50567 | XEvent.Severity.Error,
            MC_SPS_IS_OFF = 50568 | XEvent.Severity.Warning,
            MC_BILLING_PROVIDER_INIT_ERROR_1 = 50582 | XEvent.Severity.Error,
            XCBK_SUBSCRIPTION_EXPIRATION_MESSAGE_FAILED = 50583 | XEvent.Severity.Error,
            DEPRECATED_BILLING_OFFERING_GEOAPI_INIT_FAILED = 50588 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_UPDATE_ERROR = 50679 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_QUEUE_ERROR = 50680 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_QUEUE_TIMER_ERROR = 50681 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_DEQUEUE_ERROR = 50682 | XEvent.Severity.Error,
            GRADUATE_USER_QUEUE_GET_PENDING_ERROR = 50687 | XEvent.Severity.Error,
            MC_CANNOT_COMPLETE_PURCHASE_COMMIT = 50705 | XEvent.Severity.Info,
            MC_SPS_UNRECOGNIZED_ERROR = 50825 | XEvent.Severity.Error,
            COMMON_CODE_1 = 50826 | XEvent.Severity.Error,
            COMMON_CODE_2 = 50827 | XEvent.Severity.Error,
            MC_SPS_INVALID_SUBSCRIPTION_ID = 50828 | XEvent.Severity.Error,
            MC_SPS_INELIGIBLE_FOR_OFFER = 50829 | XEvent.Severity.Error,
            MC_SPS_INELIGIBLE_FOR_OFFER_1 = 50830 | XEvent.Severity.Error,
            MC_SPS_INVALID_PUID = 50831 | XEvent.Severity.Error,
            COMMON_CODE_7 = 50832 | XEvent.Severity.Error,
            COMMON_CODE_8 = 50833 | XEvent.Severity.Error,
            COMMON_CODE_9 = 50834 | XEvent.Severity.Error,
            COMMON_CODE_10 = 50835 | XEvent.Severity.Error,
            COMMON_CODE_11 = 50836 | XEvent.Severity.Error,
            MC_SPS_TOO_MANY_SERVICE_COMPONENTS = 50837 | XEvent.Severity.Error,
            COMMON_CODE_13 = 50838 | XEvent.Severity.Error,
            COMMON_CODE_14 = 50839 | XEvent.Severity.Error,
            COMMON_CODE_15 = 50840 | XEvent.Severity.Error,
            MC_CANNOT_RECORD_TRANSACTION = 50841 | XEvent.Severity.Error,
            MC_CANNOT_RECORD_TRANSACTION_1 = 50842 | XEvent.Severity.Error,
            MC_CANNOT_RECORD_TRANSACTION_2 = 50843 | XEvent.Severity.Error,
            MC_CANNOT_RECORD_TRANSACTION_3 = 50844 | XEvent.Severity.Error,
            COMMON_CODE_123 = 50948 | XEvent.Severity.Error,
            COMMON_CODE_124 = 50949 | XEvent.Severity.Error,
            COMMON_CODE_125 = 50950 | XEvent.Severity.Error,
            COMMON_CODE_126 = 50951 | XEvent.Severity.Error,
            COMMON_CODE_127 = 50952 | XEvent.Severity.Error,
            COMMON_CODE_128 = 50953 | XEvent.Severity.Error,
            COMMON_CODE_129 = 50954 | XEvent.Severity.Error,
            COMMON_CODE_130 = 50955 | XEvent.Severity.Error,
            COMMON_CODE_131 = 50956 | XEvent.Severity.Error,
            COMMON_CODE_132 = 50957 | XEvent.Severity.Error,
            COMMON_CODE_134 = 50959 | XEvent.Severity.Error,
            COMMON_CODE_135 = 50960 | XEvent.Severity.Error,
            COMMON_CODE_136 = 50961 | XEvent.Severity.Error,
            COMMON_CODE_137 = 50962 | XEvent.Severity.Error,
            COMMON_CODE_138 = 50963 | XEvent.Severity.Error,
            COMMON_CODE_139 = 50964 | XEvent.Severity.Error,
            COMMON_CODE_140 = 50965 | XEvent.Severity.Error,
            COMMON_CODE_141 = 50966 | XEvent.Severity.Error,
            COMMON_CODE_142 = 50967 | XEvent.Severity.Error,
            COMMON_CODE_143 = 50968 | XEvent.Severity.Error,
            COMMON_CODE_144 = 50969 | XEvent.Severity.Error,
            COMMON_CODE_145 = 50970 | XEvent.Severity.Error,
            COMMON_CODE_201 = 51026 | XEvent.Severity.Error,
            COMMON_CODE_202 = 51027 | XEvent.Severity.Error,
            COMMON_CODE_203 = 51028 | XEvent.Severity.Error,
            COMMON_CODE_204 = 51029 | XEvent.Severity.Error,
            COMMON_COMM_0 = 51225 | XEvent.Severity.Error,
            COMMON_COMM_1 = 51226 | XEvent.Severity.Error,
            COMMON_COMM_2 = 51227 | XEvent.Severity.Error,
            MC_SPS_PROVISIONING_FAILURE = 51228 | XEvent.Severity.Error,
            COMMON_COMM_4 = 51229 | XEvent.Severity.Error,
            COMMON_COMM_5 = 51230 | XEvent.Severity.Error,
            COMMON_CONFIG_0 = 51325 | XEvent.Severity.Warning,
            COMMON_CONFIG_1 = 51326 | XEvent.Severity.Error,
            COMMON_CONFIG_2 = 51327 | XEvent.Severity.Error,
            COMMON_CONFIG_3 = 51328 | XEvent.Severity.Error,
            COMMON_CONFIG_4 = 51329 | XEvent.Severity.Error,
            COMMON_CONFIG_5 = 51330 | XEvent.Severity.Error,
            COMMON_CONFIG_6 = 51331 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA = 51332 | XEvent.Severity.Error,
            COMMON_CONFIG_8 = 51333 | XEvent.Severity.Error,
            COMMON_CONFIG_9 = 51334 | XEvent.Severity.Error,
            COMMON_CONFIG_10 = 51335 | XEvent.Severity.Error,
            COMMON_CONFIG_11 = 51336 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_1 = 51337 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_2 = 51338 | XEvent.Severity.Error,
            COMMON_CONFIG_14 = 51339 | XEvent.Severity.Error,
            COMMON_CONFIG_15 = 51340 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_3 = 51341 | XEvent.Severity.Error,
            COMMON_CONFIG_17 = 51342 | XEvent.Severity.Error,
            COMMON_CONFIG_18 = 51343 | XEvent.Severity.Error,
            MC_SPS_INVALID_OFFER_ID = 51344 | XEvent.Severity.Error,
            MC_SPS_INVALID_OFFER_ID_1 = 51345 | XEvent.Severity.Error,
            MC_SPS_QUEUE_ERROR = 51346 | XEvent.Severity.Error,
            MC_SPS_QUEUE_ERROR_1 = 51347 | XEvent.Severity.Error,
            MC_SPS_QUEUE_ERROR_2 = 51348 | XEvent.Severity.Error,
            COMMON_CONFIG_24 = 51349 | XEvent.Severity.Error,
            COMMON_CONFIG_25 = 51350 | XEvent.Severity.Warning,
            COMMON_CONFIG_26 = 51351 | XEvent.Severity.Error,
            COMMON_CONFIG_27 = 51352 | XEvent.Severity.Error,
            COMMON_CONFIG_28 = 51353 | XEvent.Severity.Error,
            COMMON_CONFIG_30 = 51355 | XEvent.Severity.Error,
            COMMON_CONFIG_31 = 51356 | XEvent.Severity.Error,
            QUEUE_FAILURE_AUTO_FIX = 51357 | XEvent.Severity.Error,
            COMMON_CONFIG_33 = 51358 | XEvent.Severity.Error,
            COMMON_CONFIG_34 = 51359 | XEvent.Severity.Error,
            COMMON_CONFIG_35 = 51360 | XEvent.Severity.Error,
            COMMON_CONFIG_36 = 51361 | XEvent.Severity.Error,
            COMMON_CONFIG_37 = 51362 | XEvent.Severity.Error,
            COMMON_CONFIG_38 = 51363 | XEvent.Severity.Error,
            COMMON_CONFIG_39 = 51364 | XEvent.Severity.Error,
            COMMON_CONFIG_40 = 51365 | XEvent.Severity.Error,
            COMMON_CONFIG_41 = 51366 | XEvent.Severity.Error,
            COMMON_CONFIG_42 = 51367 | XEvent.Severity.Error,
            COMMON_CONFIG_43 = 51368 | XEvent.Severity.Error,
            COMMON_CONFIG_44 = 51369 | XEvent.Severity.Error,
            COMMON_CONFIG_45 = 51370 | XEvent.Severity.Error,
            COMMON_CONFIG_46 = 51371 | XEvent.Severity.Error,
            COMMON_CONFIG_47 = 51372 | XEvent.Severity.Error,
            COMMON_CONFIG_48 = 51373 | XEvent.Severity.Error,
            COMMON_CONFIG_49 = 51374 | XEvent.Severity.Warning,
            COMMON_CONFIG_50 = 51375 | XEvent.Severity.Warning,
            MC_SPS_OFFER_MISCONFIGURATION = 51376 | XEvent.Severity.Error,
            COMMON_CONFIG_52 = 51377 | XEvent.Severity.Error,
            COMMON_CONFIG_53 = 51378 | XEvent.Severity.Error,
            COMMON_CONFIG_54 = 51379 | XEvent.Severity.Error,
            COMMON_CONFIG_55 = 51380 | XEvent.Severity.Error,
            COMMON_CONFIG_56 = 51381 | XEvent.Severity.Error,
            COMMON_CONFIG_57 = 51382 | XEvent.Severity.Error,
            COMMON_CONFIG_58 = 51383 | XEvent.Severity.Error,
            COMMON_CONFIG_59 = 51384 | XEvent.Severity.Error,
            COMMON_CONFIG_60 = 51385 | XEvent.Severity.Error,
            COMMON_CONFIG_61 = 51386 | XEvent.Severity.Error,
            COMMON_CONFIG_62 = 51387 | XEvent.Severity.Error,
            COMMON_CONFIG_63 = 51388 | XEvent.Severity.Error,
            MC_SPS_OFFER_MISCONFIGURATION_1 = 51389 | XEvent.Severity.Error,
            COMMON_CONFIG_65 = 51390 | XEvent.Severity.Error,
            COMMON_CONFIG_66 = 51391 | XEvent.Severity.Warning,
            COMMON_CONFIG_67 = 51392 | XEvent.Severity.Warning,
            COMMON_CONFIG_68 = 51393 | XEvent.Severity.Error,
            COMMON_CONFIG_267 = 51592 | XEvent.Severity.Error,
            MC_SPS_OFFER_MISCONFIGURATION_2 = 51594 | XEvent.Severity.Error,
            MC_AMBIGUOUS_OFFER_CONFIGURATION = 51673 | XEvent.Severity.Error,
            COMMON_HACK_0 = 52325 | XEvent.Severity.Warning,
            COMMON_HACK_1 = 52326 | XEvent.Severity.Warning,
            COMMON_HACK_2 = 52327 | XEvent.Severity.Warning,
            COMMON_HACK_3 = 52328 | XEvent.Severity.Warning,
            COMMON_INFO_0 = 52525 | XEvent.Severity.Info,
            COMMON_INFO_1 = 52526 | XEvent.Severity.Info,
            COMMON_INFO_2 = 52527 | XEvent.Severity.Info,
            COMMON_INFO_3 = 52528 | XEvent.Severity.Info,
            BILLING_SWITCH_USER_PASSPORT_QUEUE_DEQUEUE_ERROR = 62805 | XEvent.Severity.Error,
            BILLING_SWITCH_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR = 62806 | XEvent.Severity.Error,
            BILLING_SWITCH_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR = 62807 | XEvent.Severity.Error,
            BILLING_QUEUE_GET_PENDING_ERROR = 62819 | XEvent.Severity.Error,
            SWITCH_USER_PASSPORT_QUEUE_GET_PENDING_ERROR = 62821 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_0 = 62825 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_1 = 62826 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_2 = 62827 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_3 = 62828 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_4 = 62829 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_5 = 62830 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_6 = 62831 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_7 = 62832 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_8 = 62833 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_9 = 62834 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_10 = 62835 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_11 = 62836 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_12 = 62837 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_13 = 62838 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_14 = 62839 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_15 = 62840 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_16 = 62841 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_17 = 62842 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_18 = 62843 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_19 = 62844 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_20 = 62845 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_21 = 62846 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_22 = 62847 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_23 = 62848 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_24 = 62849 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_25 = 62850 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_26 = 62851 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_27 = 62852 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_28 = 62853 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_29 = 62854 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_30 = 62855 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_31 = 62856 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_32 = 62857 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_33 = 62858 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_34 = 62859 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_35 = 62860 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_36 = 62861 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_37 = 62862 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_38 = 62863 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_39 = 62864 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_40 = 62865 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_41 = 62866 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_42 = 62867 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_43 = 62868 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_44 = 62869 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_45 = 62870 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_46 = 62871 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_47 = 62872 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_48 = 62873 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_49 = 62874 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_50 = 62875 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_51 = 62876 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_52 = 62877 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_53 = 62878 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_54 = 62879 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_55 = 62880 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_56 = 62881 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_57 = 62882 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_58 = 62883 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_59 = 62884 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_60 = 62885 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_61 = 62886 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_62 = 62887 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_63 = 62888 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_64 = 62889 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_65 = 62890 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_66 = 62891 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_67 = 62892 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_68 = 62893 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_69 = 62894 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_70 = 62895 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_71 = 62896 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_72 = 62897 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_73 = 62898 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_74 = 62899 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_75 = 62900 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_76 = 62901 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_77 = 62902 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_78 = 62903 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_79 = 62904 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_80 = 62905 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_81 = 62906 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_82 = 62907 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_83 = 62908 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_84 = 62909 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_85 = 62910 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_86 = 62911 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_87 = 62912 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_88 = 62913 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_89 = 62914 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_90 = 62915 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_91 = 62916 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_92 = 62917 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_93 = 62918 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_94 = 62919 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_95 = 62920 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_96 = 62921 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_97 = 62922 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_98 = 62923 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_99 = 62924 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_100 = 62925 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_101 = 62926 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_102 = 62927 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_103 = 62928 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_104 = 62929 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_105 = 62930 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_106 = 62931 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_107 = 62932 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_108 = 62933 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_109 = 62934 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_110 = 62935 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_111 = 62936 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_112 = 62937 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_113 = 62938 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_114 = 62939 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_115 = 62940 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_116 = 62941 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_117 = 62942 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_118 = 62943 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_119 = 62944 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_120 = 62945 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_121 = 62946 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_122 = 62947 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_123 = 62948 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_124 = 62949 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_125 = 62950 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_126 = 62951 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_127 = 62952 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_128 = 62953 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_129 = 62954 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_130 = 62955 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_131 = 62956 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_132 = 62957 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_133 = 62958 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_134 = 62959 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_135 = 62960 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_136 = 62961 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_137 = 62962 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_138 = 62963 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_139 = 62964 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_140 = 62965 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_141 = 62966 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_142 = 62967 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_143 = 62968 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_144 = 62969 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_145 = 62970 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_146 = 62971 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_147 = 62972 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_148 = 62973 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_149 = 62974 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_150 = 62975 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_151 = 62976 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_152 = 62977 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_153 = 62978 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_154 = 62979 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_155 = 62980 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_156 = 62981 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_157 = 62982 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_158 = 62983 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_159 = 62984 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_160 = 62985 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_161 = 62986 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_162 = 62987 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_163 = 62988 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_164 = 62989 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_165 = 62990 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_166 = 62991 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_167 = 62992 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_168 = 62993 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_169 = 62994 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_170 = 62995 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_171 = 62996 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_172 = 62997 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_173 = 62998 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_174 = 62999 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_175 = 63000 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_176 = 63001 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_177 = 63002 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_178 = 63003 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_179 = 63004 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_180 = 63005 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_181 = 63006 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_182 = 63007 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_183 = 63008 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_184 = 63009 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_185 = 63010 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_186 = 63011 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_187 = 63012 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_188 = 63013 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_189 = 63014 | XEvent.Severity.Error,
            DMP_EXTERNAL_EXCEPTION = 63015 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_191 = 63016 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_192 = 63017 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_193 = 63018 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_194 = 63019 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_195 = 63020 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_196 = 63021 | XEvent.Severity.Error,
            PASSPORT_CREATE_ERROR = 63022 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_198 = 63023 | XEvent.Severity.Error,
            PASSPORT_CHANGE_PASSWORD_ERROR = 63024 | XEvent.Severity.Error,
            PASSPORT_LOGIN_ERROR = 63025 | XEvent.Severity.Error,
            PASSPORT_CREATE_PROFILE_ERROR = 63026 | XEvent.Severity.Error,
            PASSPORT_UPDATE_PROFILE_ERROR = 63027 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_203 = 63028 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_204 = 63029 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_205 = 63030 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_206 = 63031 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_207 = 63032 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_208 = 63033 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_209 = 63034 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_210 = 63035 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_211 = 63036 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_212 = 63037 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_213 = 63038 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_214 = 63039 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_215 = 63040 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_216 = 63041 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_217 = 63042 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_218 = 63043 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_219 = 63044 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_220 = 63045 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_221 = 63046 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_222 = 63047 | XEvent.Severity.Error,
            DEPRECATED_COMMON_BILLING_CODE_223 = 63048 | XEvent.Severity.Error,
            COMMON_BILLING_SCS_API_BLOCKED = 63049 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_224 = 63050 | XEvent.Severity.Error,
            COMMON_PASSPORT_API_BLOCKED = 63051 | XEvent.Severity.Error,
            COMMON_BILLING_QUEUED_ACCOUNT_NOT_FOUND = 63052 | XEvent.Severity.Error,
            COMMON_BILLING_NOT_CONNECTED_TO_BILLING = 63053 | XEvent.Severity.Error,
            COMMON_FSE_NO_BOOKMARK_SETTING = 63054 | XEvent.Severity.Error,
            COMMON_FSE_INVALID_BOOKMARK_SETTING = 63055 | XEvent.Severity.Error,
            COMMON_BILLING_TEST_SETTING_WARNING = 63056 | XEvent.Severity.Warning,
            COMMON_BILLING_TITLEID_FORMAT = 63057 | XEvent.Severity.Warning,
            COMMON_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 63058 | XEvent.Severity.Error,
            COMMON_BILLING_MOVE_SUBSCRIPTION_FAILED = 63059 | XEvent.Severity.Error,
            COMMON_BILLING_CHANGE_SUBSCRIPTION_STATE_FAILED = 63060 | XEvent.Severity.Error,
            COMMON_BILLING_CONTENT_TOKEN_OFFER_MISCONFIGURED = 63061 | XEvent.Severity.Error,
            COMMON_FSE_CACHE_QUERY_ERROR = 63062 | XEvent.Severity.Error,
            COMMON_FSE_CACHE_INSERT_ERROR = 63063 | XEvent.Severity.Error,
            COMMON_FSE_CACHE_RESERVE_ERROR = 63064 | XEvent.Severity.Error,
            COMMON_FSE_UNHANDLED_ERROR = 63065 | XEvent.Severity.Error,
            COMMON_BILLING_UPS_API_BLOCKED = 63066 | XEvent.Severity.Error,
            COMMON_FSE_CONFIGURATION_ERROR = 63067 | XEvent.Severity.Error,
            PASSPORT_INVALID_RESPONSE = 63068 | XEvent.Severity.Error,
            COMMON_UPS_ERROR = 63069 | XEvent.Severity.Error,
            COMMON_UPS_GET_PROFILE_ERROR = 63070 | XEvent.Severity.Error,
            COMMON_UPS_UPDATE_PROFILE_ERROR = 63071 | XEvent.Severity.Error,
            PASSPORT_GET_MEMBER_NAME_ERROR = 63072 | XEvent.Severity.Error,
            PASSPORT_GET_MEMBER_NAME_AND_CID_ERROR = 63073 | XEvent.Severity.Error,
            PASSPORT_GET_PUID_ERROR = 63074 | XEvent.Severity.Error,
            PASSPORT_SET_NO_AGE_OUT_ERROR = 63075 | XEvent.Severity.Error,
            PASSPORT_GET_NO_AGE_OUT_ERROR = 63076 | XEvent.Severity.Error,
            PASSPORT_CREATE_PROFILE = 63077 | XEvent.Severity.Error,
            PASSPORT_UPDATE_PROFILE = 63078 | XEvent.Severity.Error,
            CATALOG_WATCHER_EXTRACTOR_INVALID_MEDIAID_LCID = 20000 | XEvent.Severity.Error,
            CATALOG_WATCHER_WATCHER_TIME_OUT = 20001 | XEvent.Severity.Error,
            CATALOG_WATCHER_PRODUCER_EXCEPTION = 20002 | XEvent.Severity.Error,
            CATALOG_WATCHER_WATCHER_EXCEPTION = 20003 | XEvent.Severity.Error,
            CATALOG_WATCHER_PUBLISHER_EXCEPTION = 20004 | XEvent.Severity.Error,
            CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR = 20005 | XEvent.Severity.Error,
            CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING = 20006 | XEvent.Severity.Warning,
            CATALOG_WATCHER_ESPPUBLISHER_EXCEPTION = 20007 | XEvent.Severity.Warning,
            CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR = 20008 | XEvent.Severity.Warning,
            CATALOG_WATCHER_MEDIA_PRODUCER_ERROR = 20009 | XEvent.Severity.Warning,
            CATALOG_WATCHER_MEDIA_DOCUMENT_TOO_LARGE = 20010 | XEvent.Severity.Error,
            CATALOG_WATCHER_PROCESSOR_EXCEPTION = 20011 | XEvent.Severity.Error,
            CATALOG_WATCHER_VIDEO_PRODUCER_ERROR = 20012 | XEvent.Severity.Warning,
            CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION = 20013 | XEvent.Severity.Warning,
            CATALOG_WATCHER_SPEECH_PRODUCER_ERROR = 20014 | XEvent.Severity.Warning,
            CLEANSER_ETX_WRITE_FAIL = 15000 | XEvent.Severity.Error,
            CLEANSER_ETX_ADD_FAIL = 15001 | XEvent.Severity.Error,
            CLEANSER_BAD_PROTOCOL_FOR_DATA_REQ = 15002 | XEvent.Severity.Error,
            CLEANSER_BAD_PROTOCOL_FOR_DISCONNECT_REQ = 15003 | XEvent.Severity.Error,
            CLEANSER_MESSAGE_ENDOFSTREAM = 15004 | XEvent.Severity.Error,
            CLEANSER_CODE_0 = 50725 | XEvent.Severity.Error,
            CLEANSER_CODE_1 = 50726 | XEvent.Severity.Error,
            CLEANSER_CODE_2 = 50727 | XEvent.Severity.Error,
            CLEANSER_CODE_3 = 50728 | XEvent.Severity.Error,
            CLEANSER_CODE_4 = 50729 | XEvent.Severity.Error,
            CLEANSER_CODE_5 = 50730 | XEvent.Severity.Error,
            CLEANSER_COMM_0 = 50750 | XEvent.Severity.Error,
            CLEANSER_COMM_1 = 50751 | XEvent.Severity.Error,
            CLEANSER_COMM_2 = 50752 | XEvent.Severity.Error,
            CLEANSER_CONFIG_0 = 50775 | XEvent.Severity.Error,
            CLEANSER_CONFIG_1 = 50776 | XEvent.Severity.Error,
            CLEANSER_CONFIG_2 = 50777 | XEvent.Severity.Error,
            CLEANSER_CONFIG_3 = 50778 | XEvent.Severity.Error,
            CLEANSER_INFO_0 = 50800 | XEvent.Severity.Info,
            CLEANSER_INFO_1 = 50801 | XEvent.Severity.Info,
            CLEANSER_INFO_2 = 50802 | XEvent.Severity.Info,
            CLEANSER_INFO_3 = 50803 | XEvent.Severity.Info,
            CLEANSER_INFO_4 = 50804 | XEvent.Severity.Info,
            SGINFO_CALL_SOURCE_INVALID = 40001 | XEvent.Severity.Error,
            SGINFO_VERIFY_PRIVILEGE = 40002 | XEvent.Severity.Error,
            XMGMT_FAILED_TO_REGISTER_ASSEMBLY = 40050 | XEvent.Severity.Warning,
            HEALTH_REQUEST_FAILED = 40051 | XEvent.Severity.Error,
            HEALTH_INITIALIZE_INTEROP_FAILED = 40052 | XEvent.Severity.Error,
            HEALTH_REGISTERNATIVEHEALTHBLOCK_FAILED = 40053 | XEvent.Severity.Error,
            HEALTH_LISTENER_CALLBACK_REQUEST_FAILED = 40054 | XEvent.Severity.Error,
            HEALTH_LISTENER_CALLBACK_FAILED = 40055 | XEvent.Severity.Error,
            MSNRR_EXTERNAL_EXCEPTION = 40056 | XEvent.Severity.Error,
            SCS_NON_USER_EXCEPTION = 40057 | XEvent.Severity.Error,
            FAST_FAIL_DUPLICATE_RESOURCE = 40058 | XEvent.Severity.Warning,
            FAST_FAIL_ENABLED_DISABLED_TOGGLE = 40059 | XEvent.Severity.Info,
            FAST_FAIL_BUCKET_COUNT_CHANGE = 40060 | XEvent.Severity.Info,
            HEALTH_INITIALIZE_BLOCK_FAILED = 40061 | XEvent.Severity.Warning,
            SERVICE_KEY_LOAD_ERROR = 40062 | XEvent.Severity.Error,
            SERVICE_KEY_SAVE_ERROR = 40063 | XEvent.Severity.Error,
            SERVICE_KEY_NOT_FOUND = 40064 | XEvent.Severity.Error,
            GEOFENCE_TERRITORY_MAPPING_INVALID = 40065 | XEvent.Severity.Error,
            GEOFENCE_TERRITORY_MAPPING_AMBIGUOUS = 40066 | XEvent.Severity.Error,
            GEOFENCE_TERRITORY_MAPPING_DUPLICATE = 40067 | XEvent.Severity.Info,
            WIREDATA_DECRYPTION_ERROR = 40068 | XEvent.Severity.Warning,
            ACCELERATION_END_OF_STREAM = 40069 | XEvent.Severity.Warning,
            XBANC_END_OF_STREAM = 40070 | XEvent.Severity.Warning,
            SERVICE_KEY_IMPORT_ERROR = 40071 | XEvent.Severity.Error,
            WIREDATA_DESERIALIZATION_ERROR = 40072 | XEvent.Severity.Warning,
            LSPLIB_DATABASE_ERROR = 40073 | XEvent.Severity.Error,
            LOGTARGET_CREATE_ERROR = 40074 | XEvent.Severity.Error,
            SCS_QUEUE_FAILED_TO_UNCONSUME_TOKEN = 40075 | XEvent.Severity.Error,
            ACCOUNTS_HISTORY_GET_ERROR = 40076 | XEvent.Severity.Error,
            ACCOUNTS_HISTORY_LOG_ERROR = 40077 | XEvent.Severity.Error,
            ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR = 40078 | XEvent.Severity.Error,
            ACCOUNTS_USER_GAMERTAG_THRESHOLD_EXCEEDED = 40079 | XEvent.Severity.Warning,
            ACCOUNTS_MACHINE_GAMERTAG_THRESHOLD_EXCEEDED = 40080 | XEvent.Severity.Warning,
            ACCOUNTS_PASSPORT_HISTORY_LOG_ERROR = 40081 | XEvent.Severity.Error,
            ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED = 40082 | XEvent.Severity.Warning,
            ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED = 40083 | XEvent.Severity.Warning,
            ACCOUNTS_RECOVERY_HISTORY_LOG_ERROR = 40084 | XEvent.Severity.Error,
            ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED = 40085 | XEvent.Severity.Warning,
            ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED = 40086 | XEvent.Severity.Warning,
            ACCOUNTS_HIJACKING_WARNING = 40087 | XEvent.Severity.Warning,
            ACCOUNTS_HIJACKING_ERROR = 40088 | XEvent.Severity.Error,
            XCACHECONNECTION_NO_RECEIVETIMEOUT_SETTING = 40089 | XEvent.Severity.Error,
            XCACHECONNECTION_NO_SENDTIMEOUT_SETTING = 40090 | XEvent.Severity.Error,
            AUTHDATA_NO_MORE_SERVICES_ERROR = 40091 | XEvent.Severity.Error,
            AAINFO_DATA_VERIFICATION_ERROR = 40092 | XEvent.Severity.Error,
            AAINFO_DATA_VERIFICATION_WARNING = 40093 | XEvent.Severity.Warning,
            USER_FAMILY_DATA_MISSING = 40094 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_CHANGE_STATE = 40095 | XEvent.Severity.Error,
            COMMON_BILLING_CODE_CHANGE_BILLING_STATE = 40096 | XEvent.Severity.Error,
            ACCOUNTS_FAMILY_HISTORY_LOG_ERROR = 40097 | XEvent.Severity.Error,
            FINBUS_RECORD_TRANSACTION_INTENT_FAILURE = 40098 | XEvent.Severity.Error,
            FINBUS_RECORD_TRANSACTION_SUCESS_FAILURE = 40099 | XEvent.Severity.Error,
            FINBUS_RECORD_TRANSACTION_RESULT_FAILURE = 40100 | XEvent.Severity.Error,
            FINBUS_RECORD_TRANSACTION_PREINTENT_FAILURE = 40101 | XEvent.Severity.Error,
            FINBUS_GET_RETRY_COUNT_FAILURE = 40102 | XEvent.Severity.Error,
            FINBUS_GET_ITEM_FOR_RETRY_FAILURE = 40103 | XEvent.Severity.Error,
            FINBUS_TOKEN_REDEMPTION_ITEM_RETRY_FAILURE = 40104 | XEvent.Severity.Error,
            FINBUS_PURCHASE_ORDER_ITEM_RETRY_FAILURE = 40105 | XEvent.Severity.Error,
            FINBUS_TRANSACTION_RESPONSE_IS_INVALID = 40106 | XEvent.Severity.Error,
            FINBUS_MISSING_XNA_CREATOR_ID_ERROR = 40107 | XEvent.Severity.Error,
            FINBUS_QUEUE_TIMER_RESET_ERROR = 40108 | XEvent.Severity.Error,
            FINBUS_QUEUE_IMPERSONATION_UNDO_ERROR = 40109 | XEvent.Severity.Error,
            FINBUS_QUEUE_PUMP_ERROR = 40110 | XEvent.Severity.Error,
            FINBUS_QUEUE_GET_RETRYABLE_COUNT_ERROR = 40111 | XEvent.Severity.Error,
            FINBUS_QUEUE_GET_ITEM_FOR_RETRY_ERROR = 40112 | XEvent.Severity.Error,
            FINBUS_QUEUE_RETRY_ITEM_ERROR = 40113 | XEvent.Severity.Error,
            FINBUS_QUEUE_COMMUNICATION_ERROR = 40114 | XEvent.Severity.Error,
            MGMT_MISSING_REPORTING_COMPONENT_ID = 40115 | XEvent.Severity.Error,
            THREADPOOL_CONTEXT_EXCEPTION = 40116 | XEvent.Severity.Error,
            THREADPOOL_THREAD_EXCEPTION = 40117 | XEvent.Severity.Error,
            FINBUS_QUEUE_ITEM_FAILED = 40118 | XEvent.Severity.Warning,
            ETX_EVENT_HEADER_VERSION_MISSING = 40119 | XEvent.Severity.Error,
            ACCOUNT_MOVE_SUBSCRIPTION_ERROR = 40120 | XEvent.Severity.Error,
            SUBSCRIPTION_BAD_CREDITVALUE_ERROR = 40121 | XEvent.Severity.Error,
            PASSPORT_GET_PROFILE_ERROR = 40122 | XEvent.Severity.Error,
            TRACKED_API_CALL_DATABASE_ERROR = 40123 | XEvent.Severity.Error,
            TRACKED_API_CALL_UCDB_DATABASE_ERROR = 40124 | XEvent.Severity.Error,
            COMMON_CODE_20 = 50845 | XEvent.Severity.Error,
            CRYPTO_GENERAL_ERROR = 50846 | XEvent.Severity.Error,
            COMMON_CODE_22 = 50847 | XEvent.Severity.Error,
            COMMON_CODE_23 = 50848 | XEvent.Severity.Error,
            COMMON_CODE_24 = 50849 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR = 50850 | XEvent.Severity.Error,
            COMMON_CODE_26 = 50851 | XEvent.Severity.Error,
            COMMON_CODE_27 = 50852 | XEvent.Severity.Error,
            COMMON_CODE_28 = 50853 | XEvent.Severity.Error,
            COMMON_CODE_29 = 50854 | XEvent.Severity.Error,
            COMMON_CODE_30 = 50855 | XEvent.Severity.Error,
            COMMON_CODE_31 = 50856 | XEvent.Severity.Error,
            COMMON_CODE_32 = 50857 | XEvent.Severity.Error,
            COMMON_CODE_33 = 50858 | XEvent.Severity.Error,
            COMMON_CODE_34 = 50859 | XEvent.Severity.Error,
            COMMON_CODE_35 = 50860 | XEvent.Severity.Error,
            COMMON_CODE_36 = 50861 | XEvent.Severity.Error,
            COMMON_CODE_37 = 50862 | XEvent.Severity.Error,
            COMMON_CODE_38 = 50863 | XEvent.Severity.Error,
            MC_PLUGIN_ERROR = 50864 | XEvent.Severity.Error,
            MC_PLUGIN_ERROR_1 = 50865 | XEvent.Severity.Error,
            COMMON_CODE_41 = 50866 | XEvent.Severity.Error,
            COMMON_CODE_42 = 50867 | XEvent.Severity.Error,
            COMMON_CODE_43 = 50868 | XEvent.Severity.Error,
            COMMON_CODE_46 = 50871 | XEvent.Severity.Error,
            COMMON_CODE_48 = 50873 | XEvent.Severity.Error,
            QUERY_BAD_PARAMETER = 50876 | XEvent.Severity.Error,
            QUERY_BAD_PARAMETER_1 = 50877 | XEvent.Severity.Error,
            COMMON_CODE_53 = 50878 | XEvent.Severity.Error,
            COMMON_CODE_54 = 50879 | XEvent.Severity.Error,
            COMMON_CODE_55 = 50880 | XEvent.Severity.Error,
            COMMON_CODE_56 = 50881 | XEvent.Severity.Error,
            COMMON_CODE_57 = 50882 | XEvent.Severity.Error,
            COMMON_CODE_58 = 50883 | XEvent.Severity.Error,
            COMMON_CODE_59 = 50884 | XEvent.Severity.Error,
            MC_BAD_PARAMETER = 50885 | XEvent.Severity.Error,
            MC_BAD_PARAMETER_1 = 50886 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_1 = 50887 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_2 = 50888 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_3 = 50889 | XEvent.Severity.Error,
            MC_BAD_PARAMETER_2 = 50890 | XEvent.Severity.Error,
            COMMON_CODE_66 = 50891 | XEvent.Severity.Error,
            MC_BAD_CODE = 50892 | XEvent.Severity.Error,
            MC_BAD_CODE_1 = 50893 | XEvent.Severity.Error,
            MC_BAD_CODE_2 = 50894 | XEvent.Severity.Error,
            MC_BAD_CODE_3 = 50895 | XEvent.Severity.Error,
            MC_BAD_CODE_4 = 50896 | XEvent.Severity.Error,
            MC_BAD_CODE_5 = 50897 | XEvent.Severity.Error,
            MC_BAD_CODE_6 = 50898 | XEvent.Severity.Error,
            COMMON_CODE_74 = 50899 | XEvent.Severity.Error,
            COMMON_CODE_75 = 50900 | XEvent.Severity.Error,
            COMMON_CODE_76 = 50901 | XEvent.Severity.Error,
            MC_BAD_CODE_7 = 50902 | XEvent.Severity.Error,
            MC_BAD_CODE_8 = 50903 | XEvent.Severity.Error,
            MC_BAD_CODE_9 = 50904 | XEvent.Severity.Error,
            MC_BAD_CODE_10 = 50905 | XEvent.Severity.Error,
            MC_BAD_CODE_11 = 50906 | XEvent.Severity.Error,
            MC_BAD_CODE_12 = 50907 | XEvent.Severity.Error,
            MC_BAD_CODE_13 = 50908 | XEvent.Severity.Error,
            MC_BAD_CODE_14 = 50909 | XEvent.Severity.Error,
            COMMON_CODE_85 = 50910 | XEvent.Severity.Error,
            COMMON_CODE_86 = 50911 | XEvent.Severity.Error,
            FORBIDDEN_NAMES_LOAD_FAILURE = 50912 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_5 = 50913 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_6 = 50914 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_7 = 50915 | XEvent.Severity.Error,
            COMMON_CODE_91 = 50916 | XEvent.Severity.Error,
            COMMON_CODE_92 = 50917 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR = 50918 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_1 = 50919 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_2 = 50920 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_3 = 50921 | XEvent.Severity.Error,
            COMMON_CODE_97 = 50922 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_4 = 50923 | XEvent.Severity.Error,
            COMMON_CODE_99 = 50924 | XEvent.Severity.Error,
            COMMON_CODE_100 = 50925 | XEvent.Severity.Error,
            COMMON_CODE_101 = 50926 | XEvent.Severity.Error,
            COMMON_CODE_102 = 50927 | XEvent.Severity.Error,
            COMMON_CODE_103 = 50928 | XEvent.Severity.Error,
            COMMON_CODE_104 = 50929 | XEvent.Severity.Error,
            COMMON_CODE_105 = 50930 | XEvent.Severity.Error,
            COMMON_CODE_106 = 50931 | XEvent.Severity.Error,
            COMMON_CODE_107 = 50932 | XEvent.Severity.Error,
            COMMON_CODE_108 = 50933 | XEvent.Severity.Error,
            COMMON_CODE_109 = 50934 | XEvent.Severity.Error,
            HEALTH_GENERIC_ERROR_1 = 50935 | XEvent.Severity.Error,
            SQL_EXECUTE_READER = 50936 | XEvent.Severity.Error,
            SQL_EXECUTE_READER_BEHAVIOR = 50937 | XEvent.Severity.Error,
            SQL_EXECUTE_NON_QUERY = 50938 | XEvent.Severity.Error,
            SQL_EXECUTE_SCALAR = 50939 | XEvent.Severity.Error,
            COUNTRY_LIST_MISSING = 50940 | XEvent.Severity.Error,
            COMMON_CODE_117 = 50942 | XEvent.Severity.Error,
            COMMON_CODE_118 = 50943 | XEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_119 = 50944 | XEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_120 = 50945 | XEvent.Severity.Error,
            COMMON_CODE_121 = 50946 | XEvent.Severity.Error,
            COMMON_CODE_122 = 50947 | XEvent.Severity.Error,
            CRYPTO_TOO_MANY_USER_KEYS = 50948 | XEvent.Severity.Warning,
            CRYPTO_FAILED_GET_USER_KEYS = 50949 | XEvent.Severity.Error,
            MUSICNET_EXTERNAL_EXCEPTION = 50958 | XEvent.Severity.Error,
            COMMON_CODE_146 = 50971 | XEvent.Severity.Error,
            COMMON_CODE_147 = 50972 | XEvent.Severity.Error,
            COMMON_CODE_148 = 50973 | XEvent.Severity.Error,
            COMMON_CODE_149 = 50974 | XEvent.Severity.Error,
            COMMON_CODE_150 = 50975 | XEvent.Severity.Error,
            COMMON_CODE_151 = 50976 | XEvent.Severity.Error,
            COMMON_CODE_152 = 50977 | XEvent.Severity.Error,
            COMMON_CODE_153 = 50978 | XEvent.Severity.Error,
            COMMON_CODE_154 = 50979 | XEvent.Severity.Error,
            COMMON_CODE_155 = 50980 | XEvent.Severity.Error,
            COMMON_CODE_156 = 50981 | XEvent.Severity.Error,
            COMMON_CODE_157 = 50982 | XEvent.Severity.Error,
            COMMON_CODE_158 = 50983 | XEvent.Severity.Error,
            COMMON_CODE_159 = 50984 | XEvent.Severity.Error,
            COMMON_CODE_160 = 50985 | XEvent.Severity.Error,
            COMMON_CODE_161 = 50986 | XEvent.Severity.Error,
            COMMON_CODE_162 = 50987 | XEvent.Severity.Error,
            COMMON_CODE_163 = 50988 | XEvent.Severity.Error,
            COMMON_CODE_164 = 50989 | XEvent.Severity.Error,
            COMMON_CODE_165 = 50990 | XEvent.Severity.Error,
            COMMON_CODE_166 = 50991 | XEvent.Severity.Error,
            COMMON_CODE_167 = 50992 | XEvent.Severity.Error,
            COMMON_CODE_168 = 50993 | XEvent.Severity.Error,
            COMMON_CODE_169 = 50994 | XEvent.Severity.Error,
            COMMON_CODE_170 = 50995 | XEvent.Severity.Error,
            COMMON_CODE_171 = 50996 | XEvent.Severity.Error,
            COMMON_CODE_172 = 50997 | XEvent.Severity.Error,
            COMMON_CODE_173 = 50998 | XEvent.Severity.Error,
            COMMON_CODE_174 = 50999 | XEvent.Severity.Error,
            COMMON_CODE_175 = 51000 | XEvent.Severity.Error,
            COMMON_CODE_176 = 51001 | XEvent.Severity.Error,
            COMMON_CODE_177 = 51002 | XEvent.Severity.Error,
            COMMON_CODE_178 = 51003 | XEvent.Severity.Error,
            COMMON_CODE_179 = 51004 | XEvent.Severity.Error,
            COMMON_CODE_180 = 51005 | XEvent.Severity.Error,
            COMMON_CODE_181 = 51006 | XEvent.Severity.Error,
            COMMON_CODE_182 = 51007 | XEvent.Severity.Error,
            COMMON_CODE_183 = 51008 | XEvent.Severity.Error,
            COMMON_CODE_184 = 51009 | XEvent.Severity.Error,
            COMMON_CODE_185 = 51010 | XEvent.Severity.Error,
            WEBSTORE_EXECUTE_ERROR = 51011 | XEvent.Severity.Error,
            WEBSTORE_EXECUTE_TIMEOUT_ERROR = 51012 | XEvent.Severity.Error,
            WEBSTORE_EXECUTE_DEADLOCK_ERROR = 51013 | XEvent.Severity.Error,
            COMMON_CODE_189 = 51014 | XEvent.Severity.Error,
            COMMON_CODE_190 = 51015 | XEvent.Severity.Error,
            COMMON_CODE_191 = 51016 | XEvent.Severity.Error,
            COMMON_CODE_192 = 51017 | XEvent.Severity.Error,
            COMMON_CODE_193 = 51018 | XEvent.Severity.Error,
            COMMON_CODE_194 = 51019 | XEvent.Severity.Error,
            COMMON_CODE_195 = 51020 | XEvent.Severity.Error,
            COMMON_CODE_196 = 51021 | XEvent.Severity.Error,
            COMMON_CODE_197 = 51022 | XEvent.Severity.Error,
            COMMON_CODE_198 = 51023 | XEvent.Severity.Error,
            COMMON_CODE_199 = 51024 | XEvent.Severity.Error,
            COMMON_CODE_200 = 51025 | XEvent.Severity.Error,
            DEPRECATED_SYNCCAST_EXTERNAL_EXCEPTION = 51030 | XEvent.Severity.Error,
            COMMON_CODE_208 = 51033 | XEvent.Severity.Error,
            COMMON_CODE_209 = 51034 | XEvent.Severity.Error,
            COMMON_CODE_210 = 51035 | XEvent.Severity.Error,
            COMMON_CODE_211 = 51036 | XEvent.Severity.Error,
            COMMON_CODE_212 = 51037 | XEvent.Severity.Error,
            COMMON_CODE_213 = 51038 | XEvent.Severity.Error,
            COMMON_CODE_214 = 51039 | XEvent.Severity.Error,
            COMMON_CODE_215 = 51040 | XEvent.Severity.Error,
            COMMON_CODE_216 = 51041 | XEvent.Severity.Error,
            COMMON_CODE_217 = 51042 | XEvent.Severity.Error,
            COMMON_CODE_218 = 51043 | XEvent.Severity.Error,
            COMMON_CODE_219 = 51044 | XEvent.Severity.Error,
            COMMON_CODE_220 = 51045 | XEvent.Severity.Error,
            COMMON_CODE_221 = 51046 | XEvent.Severity.Error,
            COMMON_CODE_222 = 51047 | XEvent.Severity.Error,
            COMMON_CODE_223 = 51048 | XEvent.Severity.Error,
            COMMON_CODE_224 = 51049 | XEvent.Severity.Error,
            COMMON_CODE_225 = 51050 | XEvent.Severity.Error,
            COMMON_CODE_226 = 51051 | XEvent.Severity.Error,
            COMMON_CODE_227 = 51052 | XEvent.Severity.Error,
            COMMON_CODE_228 = 51053 | XEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_229 = 51054 | XEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_230 = 51055 | XEvent.Severity.Error,
            COMMON_CODE_231 = 51056 | XEvent.Severity.Error,
            COMMON_CODE_232 = 51057 | XEvent.Severity.Error,
            WMIS_EXTERNAL_EXCEPTION = 51058 | XEvent.Severity.Error,
            COMMON_CODE_MATCH_STARTMIGRATE_FAILED = 51059 | XEvent.Severity.Error,
            COMMON_CODE_MATCH_MIGRATESTATUS_FAILED_SPROC = 51060 | XEvent.Severity.Error,
            COMMON_CODE_MATCH_UPDLTC_TV_FAILED = 51061 | XEvent.Severity.Error,
            COMMON_CODE_MATCH_UPDLTC_NPDB_FAILED = 51062 | XEvent.Severity.Error,
            COMMON_CODE_LSPLIB_SQLEXCEPTION = 51063 | XEvent.Severity.Error,
            HEALTH_REPORT_RED = 51064 | XEvent.Severity.Error,
            HEALTH_ENGINE_FAILURE = 51065 | XEvent.Severity.Error,
            FEAPP_INITIALIZATION_METHOD_FAILED = 51066 | XEvent.Severity.Error,
            FEAPP_INITIALIZATION_METHOD_NOT_FOUND = 51067 | XEvent.Severity.Error,
            FAST_FAIL_MISSING_COUNTERS = 51068 | XEvent.Severity.Error,
            FAST_FAIL_MISSING_RESOURCE = 51069 | XEvent.Severity.Error,
            FEAPP_COMPRESSION_ERROR = 51070 | XEvent.Severity.Error,
            UNHANDLED_THREAD_EXCEPTION = 51071 | XEvent.Severity.Error,
            FEAPP_INIT_FAILURE = 51072 | XEvent.Severity.Error,
            FORBIDDEN_NAMES_EXCLUDED_TITLES_CONFIG_ERROR = 51073 | XEvent.Severity.Error,
            COMMON_COMM_6 = 51231 | XEvent.Severity.Error,
            COMMON_COMM_7 = 51232 | XEvent.Severity.Error,
            COMMON_COMM_8 = 51233 | XEvent.Severity.Error,
            COMMON_COMM_9 = 51234 | XEvent.Severity.Error,
            COMMON_COMM_10 = 51235 | XEvent.Severity.Error,
            COMMON_COMM_11 = 51236 | XEvent.Severity.Error,
            COMMON_COMM_12 = 51237 | XEvent.Severity.Error,
            COMMON_COMM_13 = 51238 | XEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE = 51239 | XEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_1 = 51240 | XEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_2 = 51241 | XEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_3 = 51242 | XEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_4 = 51243 | XEvent.Severity.Error,
            XCACHE_SERVER_BUSY = 51244 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE = 51245 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_1 = 51246 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_2 = 51247 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_3 = 51248 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_4 = 51249 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_5 = 51250 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_6 = 51251 | XEvent.Severity.Error,
            PIPE_FAILURE = 51252 | XEvent.Severity.Error,
            PIPE_FAILURE_1 = 51253 | XEvent.Severity.Error,
            PIPE_FAILURE_2 = 51254 | XEvent.Severity.Error,
            AUTHDATA_SG_COMMUNICATION_ERROR = 51255 | XEvent.Severity.Error,
            COMMON_COMM_31 = 51256 | XEvent.Severity.Error,
            AUTHDATA_SG_COMMUNICATION_ERROR_1 = 51257 | XEvent.Severity.Error,
            MC_XRL_REQUEST_ERROR = 51258 | XEvent.Severity.Error,
            COMMON_COMM_34 = 51259 | XEvent.Severity.Error,
            COMMON_COMM_35 = 51260 | XEvent.Severity.Error,
            COMMON_COMM_36 = 51261 | XEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_7 = 51262 | XEvent.Severity.Error,
            XCACHE_INVALID_RESPONSE_1 = 51263 | XEvent.Severity.Error,
            FORBIDDEN_NAMES_LOAD_SUCCESS = 51264 | XEvent.Severity.Info,
            FORBIDDEN_NAMES_UNVETTED_STRING = 51265 | XEvent.Severity.Error,
            MUSICNET_ACCOUNT_CREATE_FAILED = 51354 | XEvent.Severity.Error,
            COMMON_CONFIG_69 = 51394 | XEvent.Severity.Warning,
            COMMON_CONFIG_70 = 51395 | XEvent.Severity.Error,
            COMMON_CONFIG_71 = 51396 | XEvent.Severity.Warning,
            COMMON_CONFIG_72 = 51397 | XEvent.Severity.Warning,
            COMMON_CONFIG_73 = 51398 | XEvent.Severity.Warning,
            COMMON_CONFIG_74 = 51399 | XEvent.Severity.Warning,
            COMMON_CONFIG_75 = 51400 | XEvent.Severity.Warning,
            COMMON_CONFIG_76 = 51401 | XEvent.Severity.Warning,
            COMMON_CONFIG_77 = 51402 | XEvent.Severity.Warning,
            COMMON_CONFIG_78 = 51403 | XEvent.Severity.Error,
            COMMON_CONFIG_79 = 51404 | XEvent.Severity.Warning,
            COMMON_CONFIG_80 = 51405 | XEvent.Severity.Warning,
            COMMON_CONFIG_81 = 51406 | XEvent.Severity.Warning,
            COMMON_CONFIG_82 = 51407 | XEvent.Severity.Warning,
            COMMON_CONFIG_83 = 51408 | XEvent.Severity.Warning,
            COMMON_CONFIG_84 = 51409 | XEvent.Severity.Error,
            COMMON_CONFIG_85 = 51410 | XEvent.Severity.Error,
            COMMON_CONFIG_86 = 51411 | XEvent.Severity.Error,
            COMMON_CONFIG_87 = 51412 | XEvent.Severity.Error,
            COMMON_CONFIG_88 = 51413 | XEvent.Severity.Error,
            COMMON_CONFIG_89 = 51414 | XEvent.Severity.Error,
            COMMON_CONFIG_90 = 51415 | XEvent.Severity.Error,
            COMMON_CONFIG_91 = 51416 | XEvent.Severity.Error,
            COMMON_CONFIG_92 = 51417 | XEvent.Severity.Error,
            COMMON_CONFIG_93 = 51418 | XEvent.Severity.Error,
            COMMON_CONFIG_94 = 51419 | XEvent.Severity.Error,
            COMMON_CONFIG_95 = 51420 | XEvent.Severity.Error,
            COMMON_CONFIG_96 = 51421 | XEvent.Severity.Error,
            COMMON_CONFIG_97 = 51422 | XEvent.Severity.Error,
            COMMON_CONFIG_98 = 51423 | XEvent.Severity.Error,
            COMMON_CONFIG_99 = 51424 | XEvent.Severity.Error,
            COMMON_CONFIG_100 = 51425 | XEvent.Severity.Error,
            COMMON_CONFIG_101 = 51426 | XEvent.Severity.Error,
            COMMON_CONFIG_102 = 51427 | XEvent.Severity.Error,
            COMMON_CONFIG_103 = 51428 | XEvent.Severity.Error,
            COMMON_CONFIG_104 = 51429 | XEvent.Severity.Error,
            COMMON_CONFIG_105 = 51430 | XEvent.Severity.Error,
            COMMON_CONFIG_106 = 51431 | XEvent.Severity.Error,
            COMMON_CONFIG_107 = 51432 | XEvent.Severity.Error,
            COMMON_CONFIG_108 = 51433 | XEvent.Severity.Error,
            COMMON_CONFIG_109 = 51434 | XEvent.Severity.Warning,
            COMMON_CONFIG_110 = 51435 | XEvent.Severity.Error,
            COMMON_CONFIG_111 = 51436 | XEvent.Severity.Error,
            COMMON_CONFIG_112 = 51437 | XEvent.Severity.Error,
            COMMON_CONFIG_113 = 51438 | XEvent.Severity.Error,
            COMMON_CONFIG_114 = 51439 | XEvent.Severity.Error,
            COMMON_CONFIG_115 = 51440 | XEvent.Severity.Error,
            COMMON_CONFIG_116 = 51441 | XEvent.Severity.Error,
            COMMON_CONFIG_117 = 51442 | XEvent.Severity.Error,
            COMMON_CONFIG_118 = 51443 | XEvent.Severity.Error,
            COMMON_CONFIG_119 = 51444 | XEvent.Severity.Error,
            COMMON_CONFIG_120 = 51445 | XEvent.Severity.Error,
            COMMON_CONFIG_121 = 51446 | XEvent.Severity.Error,
            COMMON_CONFIG_122 = 51447 | XEvent.Severity.Error,
            COMMON_CONFIG_123 = 51448 | XEvent.Severity.Error,
            COMMON_CONFIG_124 = 51449 | XEvent.Severity.Error,
            COMMON_CONFIG_125 = 51450 | XEvent.Severity.Error,
            COMMON_CONFIG_126 = 51451 | XEvent.Severity.Error,
            COMMON_CONFIG_127 = 51452 | XEvent.Severity.Error,
            COMMON_CONFIG_128 = 51453 | XEvent.Severity.Error,
            COMMON_CONFIG_129 = 51454 | XEvent.Severity.Error,
            COMMON_CONFIG_130 = 51455 | XEvent.Severity.Error,
            COMMON_CONFIG_131 = 51456 | XEvent.Severity.Error,
            COMMON_CONFIG_132 = 51457 | XEvent.Severity.Error,
            COMMON_CONFIG_133 = 51458 | XEvent.Severity.Error,
            COMMON_CONFIG_134 = 51459 | XEvent.Severity.Warning,
            COMMON_CONFIG_135 = 51460 | XEvent.Severity.Error,
            COMMON_CONFIG_136 = 51461 | XEvent.Severity.Error,
            COMMON_CONFIG_137 = 51462 | XEvent.Severity.Error,
            COMMON_CONFIG_138 = 51463 | XEvent.Severity.Error,
            COMMON_CONFIG_139 = 51464 | XEvent.Severity.Error,
            COMMON_CONFIG_140 = 51465 | XEvent.Severity.Error,
            COMMON_CONFIG_141 = 51466 | XEvent.Severity.Error,
            COMMON_CONFIG_142 = 51467 | XEvent.Severity.Error,
            COMMON_CONFIG_143 = 51468 | XEvent.Severity.Error,
            COMMON_CONFIG_144 = 51469 | XEvent.Severity.Error,
            COMMON_CONFIG_145 = 51470 | XEvent.Severity.Error,
            COMMON_CONFIG_146 = 51471 | XEvent.Severity.Warning,
            COMMON_CONFIG_147 = 51472 | XEvent.Severity.Error,
            COMMON_CONFIG_148 = 51473 | XEvent.Severity.Error,
            COMMON_CONFIG_149 = 51474 | XEvent.Severity.Error,
            COMMON_CONFIG_150 = 51475 | XEvent.Severity.Error,
            COMMON_CONFIG_151 = 51476 | XEvent.Severity.Error,
            COMMON_CONFIG_152 = 51477 | XEvent.Severity.Error,
            COMMON_CONFIG_153 = 51478 | XEvent.Severity.Error,
            COMMON_CONFIG_154 = 51479 | XEvent.Severity.Error,
            COMMON_CONFIG_155 = 51480 | XEvent.Severity.Error,
            COMMON_CONFIG_156 = 51481 | XEvent.Severity.Error,
            COMMON_CONFIG_157 = 51482 | XEvent.Severity.Error,
            COMMON_CONFIG_158 = 51483 | XEvent.Severity.Error,
            COMMON_CONFIG_159 = 51484 | XEvent.Severity.Error,
            COMMON_CONFIG_160 = 51485 | XEvent.Severity.Error,
            COMMON_CONFIG_161 = 51486 | XEvent.Severity.Error,
            COMMON_CONFIG_162 = 51487 | XEvent.Severity.Error,
            COMMON_CONFIG_163 = 51488 | XEvent.Severity.Error,
            COMMON_CONFIG_164 = 51489 | XEvent.Severity.Error,
            COMMON_CONFIG_165 = 51490 | XEvent.Severity.Error,
            COMMON_CONFIG_166 = 51491 | XEvent.Severity.Error,
            COMMON_CONFIG_167 = 51492 | XEvent.Severity.Error,
            COMMON_CONFIG_168 = 51493 | XEvent.Severity.Error,
            COMMON_CONFIG_169 = 51494 | XEvent.Severity.Error,
            COMMON_CONFIG_170 = 51495 | XEvent.Severity.Warning,
            COMMON_CONFIG_171 = 51496 | XEvent.Severity.Error,
            COMMON_CONFIG_172 = 51497 | XEvent.Severity.Error,
            COMMON_CONFIG_173 = 51498 | XEvent.Severity.Error,
            COMMON_CONFIG_174 = 51499 | XEvent.Severity.Warning,
            COMMON_CONFIG_175 = 51500 | XEvent.Severity.Error,
            COMMON_CONFIG_176 = 51501 | XEvent.Severity.Error,
            COMMON_CONFIG_177 = 51502 | XEvent.Severity.Warning,
            COMMON_CONFIG_178 = 51503 | XEvent.Severity.Error,
            COMMON_CONFIG_179 = 51504 | XEvent.Severity.Error,
            COMMON_CONFIG_180 = 51505 | XEvent.Severity.Warning,
            COMMON_CONFIG_181 = 51506 | XEvent.Severity.Error,
            COMMON_CONFIG_182 = 51507 | XEvent.Severity.Error,
            COMMON_CONFIG_183 = 51508 | XEvent.Severity.Error,
            COMMON_CONFIG_184 = 51509 | XEvent.Severity.Error,
            COMMON_CONFIG_185 = 51510 | XEvent.Severity.Error,
            COMMON_CONFIG_186 = 51511 | XEvent.Severity.Error,
            COMMON_CONFIG_187 = 51512 | XEvent.Severity.Error,
            COMMON_CONFIG_188 = 51513 | XEvent.Severity.Error,
            COMMON_CONFIG_189 = 51514 | XEvent.Severity.Error,
            COMMON_CONFIG_190 = 51515 | XEvent.Severity.Error,
            COMMON_CONFIG_191 = 51516 | XEvent.Severity.Error,
            COMMON_CONFIG_192 = 51517 | XEvent.Severity.Error,
            COMMON_CONFIG_193 = 51518 | XEvent.Severity.Error,
            COMMON_CONFIG_194 = 51519 | XEvent.Severity.Error,
            COMMON_CONFIG_195 = 51520 | XEvent.Severity.Error,
            COMMON_CONFIG_196 = 51521 | XEvent.Severity.Error,
            COMMON_CONFIG_197 = 51522 | XEvent.Severity.Error,
            COMMON_CONFIG_198 = 51523 | XEvent.Severity.Error,
            COMMON_CONFIG_199 = 51524 | XEvent.Severity.Error,
            COMMON_CONFIG_200 = 51525 | XEvent.Severity.Error,
            COMMON_CONFIG_201 = 51526 | XEvent.Severity.Error,
            COMMON_CONFIG_202 = 51527 | XEvent.Severity.Error,
            COMMON_CONFIG_203 = 51528 | XEvent.Severity.Error,
            COMMON_CONFIG_204 = 51529 | XEvent.Severity.Error,
            COMMON_CONFIG_205 = 51530 | XEvent.Severity.Error,
            COMMON_CONFIG_206 = 51531 | XEvent.Severity.Error,
            COMMON_CONFIG_207 = 51532 | XEvent.Severity.Error,
            COMMON_CONFIG_208 = 51533 | XEvent.Severity.Error,
            COMMON_CONFIG_209 = 51534 | XEvent.Severity.Error,
            COMMON_CONFIG_210 = 51535 | XEvent.Severity.Error,
            COMMON_CONFIG_211 = 51536 | XEvent.Severity.Error,
            COMMON_CONFIG_212 = 51537 | XEvent.Severity.Error,
            COMMON_CONFIG_213 = 51538 | XEvent.Severity.Error,
            COMMON_CONFIG_214 = 51539 | XEvent.Severity.Error,
            COMMON_CONFIG_215 = 51540 | XEvent.Severity.Error,
            COMMON_CONFIG_216 = 51541 | XEvent.Severity.Error,
            COMMON_CONFIG_217 = 51542 | XEvent.Severity.Error,
            COMMON_CONFIG_218 = 51543 | XEvent.Severity.Error,
            COMMON_CONFIG_219 = 51544 | XEvent.Severity.Error,
            COMMON_CONFIG_220 = 51545 | XEvent.Severity.Error,
            COMMON_CONFIG_221 = 51546 | XEvent.Severity.Error,
            COMMON_CONFIG_222 = 51547 | XEvent.Severity.Error,
            COMMON_CONFIG_223 = 51548 | XEvent.Severity.Error,
            COMMON_CONFIG_224 = 51549 | XEvent.Severity.Error,
            COMMON_CONFIG_225 = 51550 | XEvent.Severity.Error,
            COMMON_CONFIG_226 = 51551 | XEvent.Severity.Error,
            COMMON_CONFIG_227 = 51552 | XEvent.Severity.Error,
            COMMON_CONFIG_228 = 51553 | XEvent.Severity.Error,
            COMMON_CONFIG_229 = 51554 | XEvent.Severity.Error,
            COMMON_CONFIG_230 = 51555 | XEvent.Severity.Error,
            COMMON_CONFIG_231 = 51556 | XEvent.Severity.Error,
            COMMON_CONFIG_232 = 51557 | XEvent.Severity.Error,
            COMMON_CONFIG_233 = 51558 | XEvent.Severity.Error,
            COMMON_CONFIG_234 = 51559 | XEvent.Severity.Error,
            COMMON_CONFIG_235 = 51560 | XEvent.Severity.Error,
            COMMON_CONFIG_236 = 51561 | XEvent.Severity.Error,
            COMMON_CONFIG_237 = 51562 | XEvent.Severity.Error,
            COMMON_CONFIG_238 = 51563 | XEvent.Severity.Error,
            COMMON_CONFIG_239 = 51564 | XEvent.Severity.Error,
            COMMON_CONFIG_240 = 51565 | XEvent.Severity.Error,
            COMMON_CONFIG_241 = 51566 | XEvent.Severity.Error,
            COMMON_CONFIG_242 = 51567 | XEvent.Severity.Error,
            COMMON_CONFIG_243 = 51568 | XEvent.Severity.Error,
            COMMON_CONFIG_244 = 51569 | XEvent.Severity.Error,
            COMMON_CONFIG_245 = 51570 | XEvent.Severity.Warning,
            COMMON_CONFIG_246 = 51571 | XEvent.Severity.Warning,
            COMMON_CONFIG_247 = 51572 | XEvent.Severity.Error,
            COMMON_CONFIG_248 = 51573 | XEvent.Severity.Error,
            COMMON_CONFIG_249 = 51574 | XEvent.Severity.Error,
            COMMON_CONFIG_250 = 51575 | XEvent.Severity.Error,
            DEPRECATED_COMMON_CONFIG_251 = 51576 | XEvent.Severity.Error,
            COMMON_CONFIG_252 = 51577 | XEvent.Severity.Error,
            COMMON_CONFIG_253 = 51578 | XEvent.Severity.Warning,
            COMMON_CONFIG_254 = 51579 | XEvent.Severity.Error,
            COMMON_CONFIG_255 = 51580 | XEvent.Severity.Error,
            COMMON_CONFIG_256 = 51581 | XEvent.Severity.Error,
            COMMON_CONFIG_257 = 51582 | XEvent.Severity.Error,
            COMMON_CONFIG_258 = 51583 | XEvent.Severity.Error,
            COMMON_CONFIG_259 = 51584 | XEvent.Severity.Warning,
            COMMON_CONFIG_260 = 51585 | XEvent.Severity.Warning,
            COMMON_CONFIG_261 = 51586 | XEvent.Severity.Error,
            COMMON_CONFIG_262 = 51587 | XEvent.Severity.Error,
            COMMON_CONFIG_263 = 51588 | XEvent.Severity.Error,
            COMMON_CONFIG_264 = 51589 | XEvent.Severity.Error,
            COMMON_CONFIG_265 = 51590 | XEvent.Severity.Error,
            COMMON_CONFIG_266 = 51591 | XEvent.Severity.Warning,
            COMMON_CONFIG_PIPE_HANDLE_DISPOSED = 51593 | XEvent.Severity.Error,
            COMMON_CONFIG_270 = 51595 | XEvent.Severity.Error,
            COMMON_CONFIG_272 = 51597 | XEvent.Severity.Error,
            COMMON_CONFIG_274 = 51599 | XEvent.Severity.Error,
            MC_SGINFO_IS_OFF = 51600 | XEvent.Severity.Warning,
            COMMON_CONFIG_276 = 51601 | XEvent.Severity.Error,
            COMMON_CONFIG_277 = 51602 | XEvent.Severity.Error,
            COMMON_CONFIG_278 = 51603 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_4 = 51604 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_5 = 51605 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_6 = 51606 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_7 = 51607 | XEvent.Severity.Error,
            COMMON_CONFIG_283 = 51608 | XEvent.Severity.Error,
            COMMON_CONFIG_284 = 51609 | XEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_8 = 51610 | XEvent.Severity.Error,
            COMMON_CONFIG_286 = 51611 | XEvent.Severity.Error,
            COMMON_CONFIG_287 = 51612 | XEvent.Severity.Error,
            COMMON_CONFIG_288 = 51613 | XEvent.Severity.Error,
            MGMT_CRITICAL_ERROR = 51614 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE = 51615 | XEvent.Severity.Error,
            COMMON_CONFIG_291 = 51616 | XEvent.Severity.Error,
            COMMON_CONFIG_292 = 51617 | XEvent.Severity.Error,
            COMMON_CONFIG_293 = 51618 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_1 = 51619 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_2 = 51620 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_3 = 51621 | XEvent.Severity.Error,
            MGMT_INIT_WARNING = 51622 | XEvent.Severity.Warning,
            MGMT_INIT_FAILURE_4 = 51623 | XEvent.Severity.Error,
            MGMT_SRV_DISCONNECT = 51624 | XEvent.Severity.Error,
            MGMT_SRV_DISCONNECT_1 = 51625 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_5 = 51626 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_6 = 51627 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING = 51628 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_1 = 51629 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_2 = 51630 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_3 = 51631 | XEvent.Severity.Error,
            COMMON_CONFIG_307 = 51632 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_4 = 51633 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_5 = 51634 | XEvent.Severity.Error,
            COMMON_CONFIG_310 = 51635 | XEvent.Severity.Error,
            COMMON_CONFIG_311 = 51636 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_6 = 51637 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_7 = 51638 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_8 = 51639 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_9 = 51640 | XEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_10 = 51641 | XEvent.Severity.Error,
            MGMT_REMOTE_TARGET_WARNING = 51642 | XEvent.Severity.Warning,
            COMMON_CONFIG_318 = 51643 | XEvent.Severity.Error,
            COMMON_CONFIG_319 = 51644 | XEvent.Severity.Error,
            COMMON_CONFIG_320 = 51645 | XEvent.Severity.Error,
            COMMON_CONFIG_321 = 51646 | XEvent.Severity.Error,
            COMMON_CONFIG_322 = 51647 | XEvent.Severity.Error,
            COMMON_CONFIG_323 = 51648 | XEvent.Severity.Error,
            COMMON_CONFIG_324 = 51649 | XEvent.Severity.Error,
            COMMON_CONFIG_325 = 51650 | XEvent.Severity.Error,
            COMMON_CONFIG_326 = 51651 | XEvent.Severity.Error,
            COMMON_CONFIG_327 = 51652 | XEvent.Severity.Error,
            COMMON_CONFIG_328 = 51653 | XEvent.Severity.Error,
            COMMON_CONFIG_329 = 51654 | XEvent.Severity.Error,
            COMMON_CONFIG_330 = 51655 | XEvent.Severity.Error,
            COMMON_CONFIG_331 = 51656 | XEvent.Severity.Error,
            COMMON_CONFIG_332 = 51657 | XEvent.Severity.Error,
            COMMON_CONFIG_333 = 51658 | XEvent.Severity.Error,
            COMMON_CONFIG_334 = 51659 | XEvent.Severity.Error,
            COMMON_CONFIG_335 = 51660 | XEvent.Severity.Error,
            COMMON_CONFIG_336 = 51661 | XEvent.Severity.Error,
            COMMON_CONFIG_337 = 51662 | XEvent.Severity.Error,
            COMMON_CONFIG_338 = 51663 | XEvent.Severity.Error,
            COMMON_CONFIG_339 = 51664 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_7 = 51665 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_8 = 51666 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_9 = 51667 | XEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_REPORTMESSAGECOMPONENTID_FAILURE = 51668 | XEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_ADDREPORTMESSAGECOMPONENTIDMAPPING_FAILURE = 51669 | XEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_REPORTMESSAGECLEANSERVIRTUALINTERFACE_FAILURE = 51670 | XEvent.Severity.Error,
            COMMON_CONFIG_340 = 51671 | XEvent.Severity.Error,
            MGMT_READ_FAILURE = 51672 | XEvent.Severity.Error,
            COMMON_CONFIG_BAD_XLAST_FILE = 51674 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC = 51675 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_1 = 51676 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_2 = 51677 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_OUTOFSYNC = 51678 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_UNEXPECTED_MODE_IN_XLAST = 51679 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_MISSING_MODE_IN_XLAST = 51680 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_NONEXT = 51681 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_MISSING_BUCKET = 51682 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_EXPMIGRATE_FAILED_NOTSTARTED = 51683 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_LTC_TIB_OUTOFSYNC = 51684 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ADDRR_FAILED_MISSING_BUCKET = 51685 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ADDRR_FAILED_DUPE_SERVER = 51686 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_UPDLTC_INVALID_LTC = 51687 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_DEFAULTBUCKETS_OVERWRITE = 51688 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_CONFIRMSERVER_BADSERVER = 51689 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_PREPLTC_TID_MISMATCH = 51690 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_NO_PARTMAP = 51691 | XEvent.Severity.Error,
            COMMON_CONFIG_MATCH_PREPCONFIG_TID_MISMATCH = 51692 | XEvent.Severity.Error,
            COMMON_CONFIG_GET_REFRESH_FUNCTIONS = 51693 | XEvent.Severity.Error,
            COMMON_CONFIG_HEALTH_CHANGE = 51694 | XEvent.Severity.Error,
            COMMON_SETTING_BATCH_CONSTRUCTION = 51695 | XEvent.Severity.Error,
            COMMON_SETTING_BATCH_QUERY = 51696 | XEvent.Severity.Error,
            COMMON_SETTING_BATCH_SETTING_DELETED = 51697 | XEvent.Severity.Error,
            COMMON_CONFIG_REGISTER_DYNAMIC_SETTING_FAILURE = 51698 | XEvent.Severity.Error,
            COMMON_BUCKETS_BATCH_CONSTRUCTION = 51699 | XEvent.Severity.Error,
            COMMON_BUCKET_BATCH_QUERY = 51700 | XEvent.Severity.Error,
            COMMON_BUCKET_BATCH_DELETED = 51701 | XEvent.Severity.Error,
            COMMON_CONFIG_LIVE_REGISTRY_SETTINGS_CHANGE = 51702 | XEvent.Severity.Error,
            PERFORMANCE_COUNTERS_0 = 51703 | XEvent.Severity.Error,
            COMMON_HACK_4 = 52329 | XEvent.Severity.Warning,
            COMMON_HACK_5 = 52330 | XEvent.Severity.Warning,
            COMMON_HACK_6 = 52331 | XEvent.Severity.Warning,
            COMMON_HACK_7 = 52332 | XEvent.Severity.Warning,
            COMMON_HACK_8 = 52333 | XEvent.Severity.Warning,
            COMMON_HACK_9 = 52334 | XEvent.Severity.Warning,
            COMMON_HACK_10 = 52335 | XEvent.Severity.Warning,
            COMMON_HACK_11 = 52336 | XEvent.Severity.Warning,
            COMMON_HACK_12 = 52337 | XEvent.Severity.Warning,
            COMMON_HACK_13 = 52338 | XEvent.Severity.Warning,
            COMMON_HACK_14 = 52339 | XEvent.Severity.Warning,
            COMMON_HACK_15 = 52340 | XEvent.Severity.Warning,
            COMMON_HACK_16 = 52341 | XEvent.Severity.Warning,
            COMMON_HACK_17 = 52342 | XEvent.Severity.Warning,
            COMMON_HACK_18 = 52343 | XEvent.Severity.Warning,
            COMMON_HACK_19 = 52344 | XEvent.Severity.Warning,
            COMMON_HACK_20 = 52345 | XEvent.Severity.Warning,
            COMMON_HACK_21 = 52346 | XEvent.Severity.Warning,
            COMMON_HACK_22 = 52347 | XEvent.Severity.Warning,
            COMMON_HACK_23 = 52348 | XEvent.Severity.Warning,
            COMMON_HACK_24 = 52349 | XEvent.Severity.Warning,
            COMMON_HACK_25 = 52350 | XEvent.Severity.Warning,
            COMMON_HACK_26 = 52351 | XEvent.Severity.Warning,
            COMMON_HACK_27 = 52352 | XEvent.Severity.Warning,
            COMMON_HACK_28 = 52353 | XEvent.Severity.Warning,
            COMMON_HACK_33 = 52358 | XEvent.Severity.Warning,
            COMMON_HACK_34 = 52359 | XEvent.Severity.Warning,
            COMMON_HACK_40 = 52365 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS = 52366 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_1 = 52367 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_2 = 52368 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_3 = 52369 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_4 = 52370 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_5 = 52371 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_6 = 52372 | XEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_7 = 52373 | XEvent.Severity.Warning,
            AUTHDATA_BAD_BUNDLED_AUTHDATA = 52374 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR = 52375 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_1 = 52376 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_2 = 52377 | XEvent.Severity.Warning,
            AUTHDATA_BAD_HTTP_AUTHDATA = 52378 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA = 52379 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_1 = 52380 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_2 = 52381 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_3 = 52382 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_4 = 52383 | XEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_5 = 52384 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_3 = 52385 | XEvent.Severity.Warning,
            COMMON_HACK_61 = 52386 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_4 = 52387 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_5 = 52388 | XEvent.Severity.Warning,
            COMMON_HACK_64 = 52389 | XEvent.Severity.Warning,
            COMMON_HACK_65 = 52390 | XEvent.Severity.Warning,
            COMMON_HACK_66 = 52391 | XEvent.Severity.Warning,
            COMMON_HACK_67 = 52392 | XEvent.Severity.Warning,
            COMMON_HACK_68 = 52393 | XEvent.Severity.Warning,
            COMMON_HACK_69 = 52394 | XEvent.Severity.Warning,
            COMMON_HACK_70 = 52395 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_6 = 52396 | XEvent.Severity.Warning,
            COMMON_HACK_72 = 52397 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_7 = 52398 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_8 = 52399 | XEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_9 = 52400 | XEvent.Severity.Warning,
            COMMON_HACK_76 = 52401 | XEvent.Severity.Warning,
            WIREDATA_END_OF_STREAM = 52402 | XEvent.Severity.Warning,
            COMMON_HACK_78 = 52403 | XEvent.Severity.Warning,
            COMMON_HACK_79 = 52404 | XEvent.Severity.Warning,
            COMMON_HACK_80 = 52405 | XEvent.Severity.Warning,
            HACK_CONTENT_NOT_FOUND = 52406 | XEvent.Severity.Warning,
            USER_AGENT_MISSING = 52412 | XEvent.Severity.Error,
            USER_AGENT_INVALID = 52413 | XEvent.Severity.Error,
            AAINFO_INVALID_REQUEST = 52414 | XEvent.Severity.Error,
            COMMON_HACK_81 = 52415 | XEvent.Severity.Error,
            AUTHDATA_VERIFICATION_ERROR_10 = 52416 | XEvent.Severity.Error,
            COMMON_INFO_4 = 52529 | XEvent.Severity.Info,
            COMMON_INFO_5 = 52530 | XEvent.Severity.Info,
            COMMON_INFO_6 = 52531 | XEvent.Severity.Info,
            COMMON_INFO_7 = 52532 | XEvent.Severity.Info,
            COMMON_INFO_8 = 52533 | XEvent.Severity.Info,
            COMMON_INFO_9 = 52534 | XEvent.Severity.Info,
            COMMON_INFO_10 = 52535 | XEvent.Severity.Info,
            COMMON_INFO_11 = 52536 | XEvent.Severity.Info,
            COMMON_INFO_12 = 52537 | XEvent.Severity.Info,
            COMMON_INFO_13 = 52538 | XEvent.Severity.Info,
            COMMON_INFO_14 = 52539 | XEvent.Severity.Info,
            COMMON_INFO_15 = 52540 | XEvent.Severity.Info,
            COMMON_INFO_16 = 52541 | XEvent.Severity.Info,
            COMMON_INFO_17 = 52542 | XEvent.Severity.Info,
            COMMON_INFO_18 = 52543 | XEvent.Severity.Info,
            COMMON_INFO_19 = 52544 | XEvent.Severity.Info,
            COMMON_INFO_20 = 52545 | XEvent.Severity.Info,
            COMMON_INFO_21 = 52546 | XEvent.Severity.Info,
            COMMON_INFO_22 = 52547 | XEvent.Severity.Info,
            COMMON_INFO_23 = 52548 | XEvent.Severity.Info,
            COMMON_INFO_24 = 52549 | XEvent.Severity.Info,
            COMMON_INFO_25 = 52550 | XEvent.Severity.Info,
            COMMON_INFO_26 = 52551 | XEvent.Severity.Info,
            COMMON_INFO_27 = 52552 | XEvent.Severity.Info,
            COMMON_INFO_28 = 52553 | XEvent.Severity.Info,
            COMMON_INFO_29 = 52554 | XEvent.Severity.Info,
            COMMON_INFO_30 = 52555 | XEvent.Severity.Info,
            COMMON_INFO_31 = 52556 | XEvent.Severity.Info,
            COMMON_INFO_32 = 52557 | XEvent.Severity.Info,
            COMMON_INFO_33 = 52558 | XEvent.Severity.Info,
            COMMON_INFO_34 = 52559 | XEvent.Severity.Info,
            COMMON_INFO_35 = 52560 | XEvent.Severity.Info,
            COMMON_INFO_36 = 52561 | XEvent.Severity.Info,
            COMMON_INFO_37 = 52562 | XEvent.Severity.Info,
            COMMON_INFO_38 = 52563 | XEvent.Severity.Info,
            COMMON_INFO_39 = 52564 | XEvent.Severity.Info,
            COMMON_INFO_40 = 52565 | XEvent.Severity.Info,
            MC_APPDOMAIN_STARTED = 52566 | XEvent.Severity.Info,
            MC_APPDOMAIN_STARTED_1 = 52567 | XEvent.Severity.Info,
            COMMON_INFO_43 = 52568 | XEvent.Severity.Info,
            COMMON_INFO_44 = 52569 | XEvent.Severity.Info,
            COMMON_INFO_45 = 52570 | XEvent.Severity.Info,
            COMMON_INFO_46 = 52571 | XEvent.Severity.Info,
            COMMON_INFO_47 = 52572 | XEvent.Severity.Info,
            COMMON_INFO_48 = 52573 | XEvent.Severity.Info,
            MGMT_SRV_CONNECTED = 52574 | XEvent.Severity.Info,
            REPORTINGTARGET_RECONNECTED = 52575 | XEvent.Severity.Info,
            CONFIG_CHANGE_PROCESSED = 52576 | XEvent.Severity.Info,
            HEALTH_REPORT_GREEN = 52577 | XEvent.Severity.Info,
            COMMON_CONFIG_INFO_HEALTH_CHANGE = 52578 | XEvent.Severity.Info,
            COMMON_SETTING_BATCH_COUNT = 52579 | XEvent.Severity.Info,
            COMMON_BUCKET_COUNT = 52580 | XEvent.Severity.Info,
            COMMON_CONFIG_INFO_LIVE_REGISTRY_SETTINGS_CHANGE = 52581 | XEvent.Severity.Info,
            COMMON_WARNING_0 = 52725 | XEvent.Severity.Warning,
            HEALTH_REPORT_YELLOW = 52726 | XEvent.Severity.Warning,
            AUDIT_INVALID_SUBSYSTEM = 63800 | XEvent.Severity.Error,
            AUDIT_NO_SETTING = 63801 | XEvent.Severity.Error,
            AUDIT_LOG_FAILURE = 63802 | XEvent.Severity.Error,
            MIX_COMMON_UNKNOWN_ERROR = 63083 | XEvent.Severity.Error,
            MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR = 63084 | XEvent.Severity.Error,
            MC_BAD_CODE_15 = 63085 | XEvent.Severity.Error,
            MC_BAD_CODE_16 = 63086 | XEvent.Severity.Error,
            COMMON_USER_1 = 63087 | XEvent.Severity.Error,
            COMMON_USER_2 = 63089 | XEvent.Severity.Error,
            COMMON_USER_3 = 63090 | XEvent.Severity.Error,
            COMMON_CATALOG_1 = 63091 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR = 52750 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_1 = 52751 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_2 = 52752 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_3 = 52753 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_4 = 52754 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_5 = 52755 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_6 = 52756 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_7 = 52757 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_8 = 52758 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_9 = 52759 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_10 = 52760 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_11 = 52761 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_12 = 52762 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_13 = 52763 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_14 = 52764 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_15 = 52765 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_16 = 52766 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_17 = 52767 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_18 = 52768 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_19 = 52769 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_20 = 52770 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_21 = 52771 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_22 = 52772 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_23 = 52773 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_24 = 52774 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_25 = 52775 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_26 = 52776 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_27 = 52777 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_28 = 52778 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_29 = 52779 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_30 = 52780 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_31 = 52781 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_32 = 52782 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_33 = 52783 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_34 = 52784 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_35 = 52785 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_36 = 52786 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_37 = 52787 | XEvent.Severity.Error,
            MC_BAD_PARAMETER_4 = 52788 | XEvent.Severity.Error,
            MC_BAD_PARAMETER_5 = 52789 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_38 = 52790 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_39 = 52791 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_40 = 52792 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_41 = 52793 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_42 = 52794 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_43 = 52795 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_44 = 52796 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_ERROR_45 = 52797 | XEvent.Severity.Error,
            COMPS_CODE_48 = 52798 | XEvent.Severity.Error,
            COMPS_CODE_49 = 52799 | XEvent.Severity.Error,
            COMPS_CODE_50 = 52800 | XEvent.Severity.Error,
            COMPS_CODE_51 = 52801 | XEvent.Severity.Error,
            MC_XRL_REQUEST_ERROR_1 = 52850 | XEvent.Severity.Error,
            MC_XRL_REQUEST_ERROR_2 = 52851 | XEvent.Severity.Error,
            MC_XRL_REQUEST_ERROR_3 = 52852 | XEvent.Severity.Error,
            QUERY_BAD_DATA = 52875 | XEvent.Severity.Error,
            QUERY_BAD_DATA_1 = 52876 | XEvent.Severity.Error,
            QUERY_SERVER_HEALTH_WARNING = 52877 | XEvent.Severity.Warning,
            QUERY_BAD_DATA_2 = 52878 | XEvent.Severity.Error,
            QUERY_PLUGIN_CONFIG_ERROR = 52879 | XEvent.Severity.Error,
            QUERY_PLUGIN_CONFIG_ERROR_1 = 52880 | XEvent.Severity.Error,
            QUERY_BAD_DATA_3 = 52881 | XEvent.Severity.Error,
            QUERY_BAD_DATA_4 = 52882 | XEvent.Severity.Error,
            QUERY_BAD_DATA_5 = 52883 | XEvent.Severity.Error,
            QUERY_BAD_DATA_6 = 52884 | XEvent.Severity.Error,
            COMPS_CONFIG_10 = 52885 | XEvent.Severity.Error,
            MGMT_TITLE_LOG_ERROR = 52886 | XEvent.Severity.Error,
            MGMT_TITLE_LOG_ERROR_1 = 52887 | XEvent.Severity.Error,
            CRON_CONFIG_FAILURE = 52888 | XEvent.Severity.Error,
            CRON_CONFIG_FAILURE_1 = 52889 | XEvent.Severity.Error,
            QUERY_SERVER_HEALTH_WARNING_1 = 52890 | XEvent.Severity.Warning,
            QUERY_PLUGIN_CONFIG_ERROR_2 = 52891 | XEvent.Severity.Error,
            QUERY_BAD_DATA_7 = 52892 | XEvent.Severity.Error,
            QUERY_BAD_DATA_8 = 52893 | XEvent.Severity.Error,
            QUERY_PLUGIN_DATA_INFO = 52925 | XEvent.Severity.Info,
            COMPS_TITLEBUG_0 = 52950 | XEvent.Severity.Error,
            CRON_JOB_FAILURE = 15000 | XEvent.Severity.Error,
            CRON_PLUGIN_XMGMT_REGISTRATION_FAILURE = 15001 | XEvent.Severity.Warning,
            CRON_UNEXPECTED_ERROR = 52975 | XEvent.Severity.Error,
            CRON_UNEXPECTED_ERROR_1 = 52976 | XEvent.Severity.Error,
            CRON_CODE_2 = 52977 | XEvent.Severity.Error,
            CRON_CODE_3 = 52978 | XEvent.Severity.Error,
            CRON_DB_FAILURE = 53000 | XEvent.Severity.Error,
            CRON_DB_FAILURE_1 = 53001 | XEvent.Severity.Error,
            CRON_DB_FAILURE_2 = 53002 | XEvent.Severity.Error,
            CRON_DB_FAILURE_3 = 53003 | XEvent.Severity.Error,
            CRON_DB_FAILURE_4 = 53004 | XEvent.Severity.Error,
            CRON_DB_FAILURE_5 = 53005 | XEvent.Severity.Error,
            CRON_DB_FAILURE_6 = 53006 | XEvent.Severity.Error,
            CRON_DB_FAILURE_7 = 53007 | XEvent.Severity.Error,
            CRON_CONFIG_FAILURE_2 = 53025 | XEvent.Severity.Error,
            CRON_CONFIG_FAILURE_3 = 53026 | XEvent.Severity.Error,
            CRON_CONFIG_FAILURE_4 = 53027 | XEvent.Severity.Error,
            QUERY_PLUGIN_CREATION_ERROR = 53028 | XEvent.Severity.Error,
            CRUX_CODE_1 = 62550 | XEvent.Severity.Warning,
            CRUX_CODE_2 = 62551 | XEvent.Severity.Warning,
            CRUX_MUSICNET_KEY_LOAD_ERROR = 62552 | XEvent.Severity.Error,
            EVENTSINK_CODE_0 = 53050 | XEvent.Severity.Error,
            EVENTSINK_CODE_1 = 53051 | XEvent.Severity.Error,
            EVENTSINK_CODE_2 = 53052 | XEvent.Severity.Error,
            EVENTSINK_COMM_0 = 53075 | XEvent.Severity.Error,
            ESP_ENGINE_EXCEPTION = 1001 | XEvent.Severity.Error,
            FEEDBACK_CODE_0 = 53100 | XEvent.Severity.Error,
            FEEDBACK_CODE_1 = 53101 | XEvent.Severity.Error,
            FEEDBACK_CODE_2 = 53102 | XEvent.Severity.Error,
            FEEDBACK_CODE_3 = 53103 | XEvent.Severity.Error,
            FEEDBACK_CODE_4 = 53104 | XEvent.Severity.Error,
            FEEDBACK_CODE_5 = 53105 | XEvent.Severity.Error,
            FEEDBACK_CODE_6 = 53106 | XEvent.Severity.Error,
            FEEDBACK_CODE_7 = 53107 | XEvent.Severity.Error,
            FEEDBACK_CONFIG_0 = 53125 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_1 = 53126 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_2 = 53127 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_3 = 53128 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_4 = 53129 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_5 = 53130 | XEvent.Severity.Warning,
            FEEDBACK_CONFIG_6 = 53131 | XEvent.Severity.Warning,
            FEEDBACK_HACK_0 = 53150 | XEvent.Severity.Warning,
            FEEDBACK_HACK_1 = 53151 | XEvent.Severity.Warning,
            FEEDBACK_HACK_2 = 53152 | XEvent.Severity.Warning,
            FEEDBACK_HACK_3 = 53153 | XEvent.Severity.Warning,
            FEEDBACK_HACK_4 = 53154 | XEvent.Severity.Warning,
            FEEDBACK_HACK_5 = 53155 | XEvent.Severity.Warning,
            FEEDBACK_HACK_6 = 53156 | XEvent.Severity.Warning,
            FEEDBACK_HACK_7 = 53157 | XEvent.Severity.Warning,
            FEEDBACK_HACK_8 = 53158 | XEvent.Severity.Warning,
            FEEDBACK_HACK_9 = 53159 | XEvent.Severity.Warning,
            FEEDBACK_HACK_10 = 53160 | XEvent.Severity.Warning,
            FEEDBACK_HACK_11 = 53161 | XEvent.Severity.Warning,
            FEEDBACK_HACK_12 = 53162 | XEvent.Severity.Warning,
            FEEDBACK_HACK_13 = 53163 | XEvent.Severity.Warning,
            FEEDBACK_HACK_14 = 53164 | XEvent.Severity.Warning,
            FEEDBACK_INFO_0 = 53200 | XEvent.Severity.Info,
            FEEDBACK_INFO_1 = 53201 | XEvent.Severity.Info,
            FINBUS_PUBLISHER_STARTED = 15000 | XEvent.Severity.Info,
            FINBUS_PUBLISHER_SHUTDOWN_STARTED = 15001 | XEvent.Severity.Info,
            FINBUS_PUBLISHER_SHUTDOWN_COMPLETE = 15002 | XEvent.Severity.Info,
            FINBUS_PUBLISHER_STARTUP_ERROR = 15003 | XEvent.Severity.Error,
            FINBUS_PUBLISHER_SHUTDOWN_ERROR = 15004 | XEvent.Severity.Error,
            FINBUS_PUBLISHER_PUBLISH_MESSAGE_ERROR = 15005 | XEvent.Severity.Error,
            FINBUS_PUBLISHER_GET_PENDING_ITEMS_ERROR = 15006 | XEvent.Severity.Error,
            FINBUS_PUBLISHER_RECORD_ITEM_FAILURE_ERROR = 15007 | XEvent.Severity.Error,
            FINBUS_PUBLISHER_UNHANDLED_EXCEPTION_ERROR = 15008 | XEvent.Severity.Error,
            KDC_CONFIG_KDCMANAGEDPROXY_INIT = 10000 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_1 = 10001 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_2 = 10002 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_3 = 10003 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_4 = 10004 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_5 = 10005 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_6 = 10006 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_7 = 10007 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_8 = 10008 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_9 = 10009 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_10 = 10010 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_11 = 10011 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_12 = 10012 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_13 = 10013 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_14 = 10014 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_15 = 10015 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_16 = 10016 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_17 = 10017 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_18 = 10018 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_19 = 10019 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_20 = 10020 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_21 = 10021 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_22 = 10022 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_23 = 10023 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_24 = 10024 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_25 = 10025 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_26 = 10026 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_27 = 10027 | XEvent.Severity.Error,
            KDC_CONFIG_HEALTHINTEROP_CREATE = 10028 | XEvent.Severity.Error,
            KDC_CONFIG_HEALTHINTEROP_INIT = 10029 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_BAD_OFFER_XML = 10030 | XEvent.Severity.Warning,
            KDC_KDCMANAGEDPROXY_FAILED_SET_CONSOLE_REGION = 10031 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_28 = 10032 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_29 = 10033 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_30 = 10034 | XEvent.Severity.Error,
            KDC_KDCMANAGEDPROXY_INTEROP_31 = 10035 | XEvent.Severity.Error,
            KDC_BASE_AUDIT_TICKET_RENEWAL = 53305 | XEvent.Severity.Error,
            KDC_BASE_BAD_KERBCRYPT_1 = 53306 | XEvent.Severity.Error,
            KDC_BASE_BAD_ETYPE = 53307 | XEvent.Severity.Error,
            KDC_CODE_83 = 53308 | XEvent.Severity.Error,
            KDC_CODE_84 = 53309 | XEvent.Severity.Error,
            KDC_CODE_85 = 53310 | XEvent.Severity.Error,
            KDC_BASE_NO_MEMORY = 53311 | XEvent.Severity.Error,
            KDC_BASE_NO_MEMORY_1 = 53312 | XEvent.Severity.Error,
            KDC_CODE_88 = 53313 | XEvent.Severity.Error,
            KDC_CODE_89 = 53314 | XEvent.Severity.Error,
            KDC_CODE_90 = 53315 | XEvent.Severity.Error,
            KDC_BASE_PATYPE_UNEXPECTED = 53673 | XEvent.Severity.Error,
            KDC_BASE_PATYPE_NOTFOUND = 53674 | XEvent.Severity.Error,
            KDC_PERFCOUNTER_INIT_ERROR = 54233 | XEvent.Severity.Error,
            KDC_CONFIG_25 = 54275 | XEvent.Severity.Error,
            KDC_CONFIG_26 = 54276 | XEvent.Severity.Error,
            KDC_CONFIG_27 = 54277 | XEvent.Severity.Error,
            KDC_CONFIG_28 = 54278 | XEvent.Severity.Error,
            KDC_CONFIG_29 = 54279 | XEvent.Severity.Error,
            KDC_CONFIG_30 = 54280 | XEvent.Severity.Error,
            KDC_CONFIG_31 = 54281 | XEvent.Severity.Error,
            KDC_FAILED_TO_CONFIG_DOS_DETECTION = 54370 | XEvent.Severity.Error,
            KDC_HACK_6 = 54656 | XEvent.Severity.Warning,
            KDC_HACK_7 = 54657 | XEvent.Severity.Warning,
            KDC_HACK_8 = 54658 | XEvent.Severity.Warning,
            KDC_BASE_UODB_CONNECTION_ESTABLISHED = 54758 | XEvent.Severity.Info,
            KDC_INFO_9 = 54759 | XEvent.Severity.Info,
            LISTS_LOAD_SUCCESS = 63950 | XEvent.Severity.Info,
            LISTS_LOAD_FAILURE = 63951 | XEvent.Severity.Error,
            LISTS_PROTOCOL_ERROR = 63952 | XEvent.Severity.Error,
            LISTS_XML_ERROR = 63953 | XEvent.Severity.Error,
            LISTS_NONEXISTENT_LIST_TYPE = 63954 | XEvent.Severity.Error,
            LISTS_NONEXISTENT_LIST_ID = 63955 | XEvent.Severity.Error,
            LISTS_DATA_DRIVEN_ERROR = 63956 | XEvent.Severity.Warning,
            LISTS_API_MISMATCH = 63957 | XEvent.Severity.Error,
            LIVECACHE_CODE_0 = 54850 | XEvent.Severity.Error,
            LIVECACHE_CODE_1 = 54851 | XEvent.Severity.Error,
            LIVECACHE_CODE_2 = 54852 | XEvent.Severity.Error,
            LIVECACHE_CODE_3 = 54853 | XEvent.Severity.Error,
            LIVECACHE_COMM_0 = 54875 | XEvent.Severity.Error,
            LIVECACHE_CONFIG_0 = 54900 | XEvent.Severity.Error,
            LIVECACHE_CONFIG_1 = 54901 | XEvent.Severity.Error,
            LIVECACHE_HACK_0 = 54925 | XEvent.Severity.Warning,
            LIVECACHE_HACK_1 = 54926 | XEvent.Severity.Warning,
            LIVECACHE_HACK_2 = 54927 | XEvent.Severity.Warning,
            LIVECACHE_HACK_3 = 54928 | XEvent.Severity.Warning,
            LIVECACHE_HACK_4 = 54929 | XEvent.Severity.Warning,
            GET_NETWORK_AUTHORIZATION_LIST_ERROR = 15000 | XEvent.Severity.Error,
            GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR = 15001 | XEvent.Severity.Error,
            GET_NETWORK_AUTHORIZATION_LIST_TITLE_NOT_ALLOWED = 15002 | XEvent.Severity.Error,
            LIVEINFO_CLIENT_ERROR = 40000 | XEvent.Severity.Error,
            LIVEINFO_HIVE_HACK_ERROR_PROCESSING_REQUEST = 63975 | XEvent.Severity.Error,
            LIVEINFO_HIVE_CONFIG_ERROR_LOADING = 63976 | XEvent.Severity.Error,
            LIVEINFO_HIVE_CONFIG_ERROR_EMPTY_RESPONSE = 63977 | XEvent.Severity.Error,
            LIVEINFO_HIVE_CONFIG_ERROR_TOO_LARGE_RESPONSE = 63978 | XEvent.Severity.Error,
            LIVEINFO_HIVE_CONFIG_ERROR_BAD_CONFIG_NAME = 63979 | XEvent.Severity.Error,
            WEBCACHE_CONTROL_REQUEST_ERROR = 53613 | XEvent.Severity.Error,
            MARKETPLACECATALOG_PARAMETER_MISSING = 35001 | XEvent.Severity.Error,
            MARKETPLACECATALOG_ERROR = 35002 | XEvent.Severity.Error,
            MARKETPLACECATALOG_GUID_ERROR = 35003 | XEvent.Severity.Warning,
            MARKETPLACECATALOG_DETAIL_LEVEL_MISSING = 35004 | XEvent.Severity.Error,
            XMATCHFD_WARN_GEN = 50869 | XEvent.Severity.Error,
            XMATCHFD_WARN_GEN_1 = 50870 | XEvent.Severity.Error,
            XMATCHFD_WARN_GEN_2 = 50872 | XEvent.Severity.Error,
            XMATCHFD_WARN_GEN_3 = 50874 | XEvent.Severity.Error,
            XMATCHFD_WARN_GEN_4 = 50875 | XEvent.Severity.Error,
            MATCH_CODE_0 = 54950 | XEvent.Severity.Error,
            MATCH_CODE_1 = 54951 | XEvent.Severity.Error,
            MATCH_CODE_2 = 54952 | XEvent.Severity.Error,
            MATCH_CODE_3 = 54953 | XEvent.Severity.Error,
            MATCH_CODE_4 = 54954 | XEvent.Severity.Error,
            MATCH_CODE_5 = 54955 | XEvent.Severity.Error,
            MATCH_CODE_6 = 54956 | XEvent.Severity.Error,
            MATCH_CODE_7 = 54957 | XEvent.Severity.Error,
            MATCH_CODE_8 = 54958 | XEvent.Severity.Error,
            MATCH_CODE_9 = 54959 | XEvent.Severity.Error,
            MATCH_CODE_10 = 54960 | XEvent.Severity.Error,
            MATCH_CODE_11 = 54961 | XEvent.Severity.Error,
            MATCH_CODE_12 = 54962 | XEvent.Severity.Error,
            MATCH_CODE_13 = 54963 | XEvent.Severity.Error,
            MATCH_CODE_14 = 54964 | XEvent.Severity.Error,
            MATCH_CODE_15 = 54965 | XEvent.Severity.Error,
            MATCH_CODE_16 = 54966 | XEvent.Severity.Error,
            MATCH_CODE_17 = 54967 | XEvent.Severity.Error,
            MATCH_CODE_18 = 54968 | XEvent.Severity.Error,
            MATCH_CODE_19 = 54969 | XEvent.Severity.Error,
            MATCH_CODE_20 = 54970 | XEvent.Severity.Error,
            MATCH_CODE_21 = 54971 | XEvent.Severity.Error,
            MATCH_CODE_22 = 54972 | XEvent.Severity.Error,
            MATCH_CODE_23 = 54973 | XEvent.Severity.Error,
            MATCH_CODE_24 = 54974 | XEvent.Severity.Error,
            MATCH_CODE_25 = 54975 | XEvent.Severity.Error,
            MATCH_CODE_26 = 54976 | XEvent.Severity.Error,
            MATCH_CODE_27 = 54977 | XEvent.Severity.Error,
            MATCH_CODE_28 = 54978 | XEvent.Severity.Error,
            MATCH_CODE_29 = 54979 | XEvent.Severity.Error,
            MATCH_CODE_30 = 54980 | XEvent.Severity.Error,
            MATCH_CODE_31 = 54981 | XEvent.Severity.Error,
            MATCH_CODE_32 = 54982 | XEvent.Severity.Error,
            MATCH_CODE_33 = 54983 | XEvent.Severity.Error,
            MATCH_CODE_34 = 54984 | XEvent.Severity.Error,
            MATCH_CODE_35 = 54985 | XEvent.Severity.Error,
            MATCH_CODE_36 = 54986 | XEvent.Severity.Error,
            MATCH_CODE_TITLECHANGE_ERROR = 54987 | XEvent.Severity.Error,
            MATCH_CODE_SESSION_LIMIT_EXCEEDED = 54988 | XEvent.Severity.Error,
            MATCH_CODE_SESSION_LIMIT_APPROACHING = 54989 | XEvent.Severity.Error,
            MATCH_COMM_0 = 55050 | XEvent.Severity.Error,
            MATCH_COMM_1 = 55051 | XEvent.Severity.Error,
            MATCH_COMM_FASTFAIL = 55052 | XEvent.Severity.Error,
            MATCH_COMM_OPEN_CONNECTION_FOR_INSERT = 55053 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_INSERT = 55054 | XEvent.Severity.Error,
            MATCH_COMM_UPDATE = 55055 | XEvent.Severity.Error,
            MATCH_COMM_DELETE = 55056 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_FIND_XBOX = 55057 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_FINDBYID_XENON = 55058 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_FINDRANKED_XENON = 55059 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_GET_NON_AFFILIATE_RESULTS = 55060 | XEvent.Severity.Error,
            MATCH_COMM_OPEN_CONNECTION = 55061 | XEvent.Severity.Error,
            MATCH_COMM_EXECUTE_GET_AFFILIATE_RESULTS = 55062 | XEvent.Severity.Error,
            MATCH_CONFIG_0 = 55075 | XEvent.Severity.Error,
            MATCH_CONFIG_1 = 55076 | XEvent.Severity.Error,
            MATCH_CONFIG_2 = 55077 | XEvent.Severity.Error,
            MATCH_CONFIG_3 = 55078 | XEvent.Severity.Error,
            MATCH_CONFIG_4 = 55079 | XEvent.Severity.Error,
            MATCH_CONFIG_5 = 55080 | XEvent.Severity.Error,
            MATCH_CONFIG_6 = 55081 | XEvent.Severity.Error,
            MATCH_CONFIG_7 = 55082 | XEvent.Severity.Error,
            MATCH_CONFIG_8 = 55083 | XEvent.Severity.Error,
            MATCH_CONFIG_9 = 55084 | XEvent.Severity.Error,
            MATCH_CONFIG_10 = 55085 | XEvent.Severity.Error,
            MATCH_CONFIG_11 = 55086 | XEvent.Severity.Error,
            MATCH_CONFIG_12 = 55087 | XEvent.Severity.Error,
            MATCH_CONFIG_13 = 55088 | XEvent.Severity.Error,
            MATCH_CONFIG_14 = 55089 | XEvent.Severity.Error,
            MATCH_CONFIG_15 = 55090 | XEvent.Severity.Error,
            MATCH_CONFIG_16 = 55091 | XEvent.Severity.Error,
            MATCH_CONFIG_17 = 55092 | XEvent.Severity.Error,
            MATCH_CONFIG_18 = 55093 | XEvent.Severity.Error,
            MATCH_CONFIG_19 = 55094 | XEvent.Severity.Error,
            MATCH_CONFIG_20 = 55095 | XEvent.Severity.Error,
            MATCH_CONFIG_21 = 55096 | XEvent.Severity.Error,
            MATCH_CONFIG_22 = 55097 | XEvent.Severity.Error,
            MATCH_CONFIG_23 = 55098 | XEvent.Severity.Error,
            MATCH_CONFIG_24 = 55099 | XEvent.Severity.Error,
            MATCH_CONFIG_25 = 55100 | XEvent.Severity.Error,
            MATCH_CONFIG_26 = 55101 | XEvent.Severity.Error,
            MATCH_CONFIG_27 = 55102 | XEvent.Severity.Error,
            MATCH_CONFIG_28 = 55103 | XEvent.Severity.Error,
            MATCH_CONFIG_29 = 55104 | XEvent.Severity.Error,
            MATCH_CONFIG_30 = 55105 | XEvent.Severity.Error,
            MATCH_CONFIG_31 = 55106 | XEvent.Severity.Error,
            MATCH_CONFIG_32 = 55107 | XEvent.Severity.Error,
            MATCH_CONFIG_33 = 55108 | XEvent.Severity.Error,
            MATCH_CONFIG_34 = 55109 | XEvent.Severity.Error,
            MATCH_CONFIG_35 = 55110 | XEvent.Severity.Error,
            MATCH_CONFIG_36 = 55111 | XEvent.Severity.Error,
            MATCH_CONFIG_37 = 55112 | XEvent.Severity.Error,
            MATCH_CONFIG_38 = 55113 | XEvent.Severity.Error,
            MATCH_CONFIG_39 = 55114 | XEvent.Severity.Error,
            MATCH_CONFIG_40 = 55115 | XEvent.Severity.Error,
            MATCH_CONFIG_41 = 55116 | XEvent.Severity.Error,
            MATCH_CONFIG_42 = 55117 | XEvent.Severity.Error,
            MATCH_CONFIG_43 = 55118 | XEvent.Severity.Error,
            MATCH_CONFIG_44 = 55119 | XEvent.Severity.Error,
            MATCH_CONFIG_45 = 55120 | XEvent.Severity.Error,
            MATCH_CONFIG_46 = 55121 | XEvent.Severity.Error,
            MATCH_CONFIG_47 = 55122 | XEvent.Severity.Error,
            MATCH_CONFIG_48 = 55123 | XEvent.Severity.Error,
            MATCH_CONFIG_49 = 55124 | XEvent.Severity.Error,
            MATCH_CONFIG_50 = 55125 | XEvent.Severity.Error,
            MATCH_CONFIG_51 = 55126 | XEvent.Severity.Error,
            MATCH_CONFIG_52 = 55127 | XEvent.Severity.Error,
            MATCH_CONFIG_53 = 55128 | XEvent.Severity.Error,
            MATCH_CONFIG_54 = 55129 | XEvent.Severity.Error,
            MATCH_CONFIG_55 = 55130 | XEvent.Severity.Error,
            MATCH_CONFIG_56 = 55131 | XEvent.Severity.Error,
            MATCH_CONFIG_57 = 55132 | XEvent.Severity.Error,
            MATCH_CONFIG_58 = 55133 | XEvent.Severity.Error,
            MATCH_CONFIG_59 = 55134 | XEvent.Severity.Error,
            MATCH_CONFIG_60 = 55135 | XEvent.Severity.Error,
            MATCH_CONFIG_61 = 55136 | XEvent.Severity.Error,
            MATCH_CONFIG_62 = 55137 | XEvent.Severity.Error,
            MATCH_CONFIG_63 = 55138 | XEvent.Severity.Error,
            MATCH_CONFIG_64 = 55139 | XEvent.Severity.Error,
            MATCH_CONFIG_65 = 55140 | XEvent.Severity.Error,
            MATCH_CONFIG_66 = 55141 | XEvent.Severity.Error,
            MATCH_CONFIG_67 = 55142 | XEvent.Severity.Error,
            MATCH_CONFIG_68 = 55143 | XEvent.Severity.Error,
            MATCH_CONFIG_69 = 55144 | XEvent.Severity.Error,
            MATCH_CONFIG_70 = 55145 | XEvent.Severity.Error,
            MATCH_CONFIG_71 = 55152 | XEvent.Severity.Error,
            MATCH_CONFIG_72 = 55153 | XEvent.Severity.Error,
            MATCH_CONFIG_73 = 55154 | XEvent.Severity.Error,
            MATCH_CONFIG_TOO_MANY_CROSS_PLATFORM_NODES = 55155 | XEvent.Severity.Error,
            MATCH_CONFIG_LTC_ELEMENT_MISSING = 55156 | XEvent.Severity.Error,
            MATCH_CONFIG_LTC_ELEMENT_TOO_MANY = 55157 | XEvent.Severity.Error,
            MATCH_CONFIG_LTC_ELEMENT_EMPTY = 55158 | XEvent.Severity.Error,
            MATCH_CONFIG_LTC_ELEMENT_PARSE_FAILED = 55159 | XEvent.Severity.Error,
            MATCH_HACK_0 = 55275 | XEvent.Severity.Warning,
            MATCH_HACK_1 = 55276 | XEvent.Severity.Warning,
            MATCH_HACK_2 = 55277 | XEvent.Severity.Warning,
            MATCH_HACK_3 = 55278 | XEvent.Severity.Warning,
            MATCH_HACK_4 = 55279 | XEvent.Severity.Warning,
            MATCH_HACK_5 = 55280 | XEvent.Severity.Warning,
            MATCH_HACK_6 = 55281 | XEvent.Severity.Warning,
            MATCH_HACK_7 = 55282 | XEvent.Severity.Warning,
            MATCH_HACK_8 = 55283 | XEvent.Severity.Warning,
            MATCH_HACK_9 = 55284 | XEvent.Severity.Warning,
            MATCH_HACK_10 = 55285 | XEvent.Severity.Warning,
            MATCH_HACK_11 = 55286 | XEvent.Severity.Warning,
            MATCH_HACK_12 = 55287 | XEvent.Severity.Warning,
            MATCH_HACK_13 = 55288 | XEvent.Severity.Warning,
            MATCH_HACK_14 = 55289 | XEvent.Severity.Warning,
            MATCH_HACK_15 = 55290 | XEvent.Severity.Warning,
            MATCH_HACK_16 = 55291 | XEvent.Severity.Warning,
            MATCH_HACK_17 = 55292 | XEvent.Severity.Warning,
            MATCH_HACK_18 = 55293 | XEvent.Severity.Warning,
            MATCH_HACK_19 = 55294 | XEvent.Severity.Warning,
            MATCH_HACK_20 = 55295 | XEvent.Severity.Warning,
            MATCH_HACK_21 = 55296 | XEvent.Severity.Warning,
            MATCH_HACK_22 = 55297 | XEvent.Severity.Warning,
            MATCH_HACK_23 = 55298 | XEvent.Severity.Warning,
            MATCH_HACK_24 = 55299 | XEvent.Severity.Warning,
            MATCH_HACK_25 = 55300 | XEvent.Severity.Warning,
            MATCH_HACK_26 = 55301 | XEvent.Severity.Warning,
            MATCH_HACK_27 = 55302 | XEvent.Severity.Warning,
            MATCH_HACK_28 = 55303 | XEvent.Severity.Warning,
            MATCH_HACK_29 = 55304 | XEvent.Severity.Warning,
            MATCH_HACK_30 = 55305 | XEvent.Severity.Warning,
            MATCH_HACK_31 = 55306 | XEvent.Severity.Warning,
            MATCH_HACK_32 = 55307 | XEvent.Severity.Warning,
            MATCH_HACK_33 = 55308 | XEvent.Severity.Warning,
            MATCH_HACK_SPLIT_NUM_ATTR = 55309 | XEvent.Severity.Warning,
            MATCH_HACK_SPLIT_END_OF_STREAM = 55310 | XEvent.Severity.Warning,
            MATCH_HACK_SESSION_NUM_ATTR = 55311 | XEvent.Severity.Warning,
            MATCH_HACK_SESSION_END_OF_STREAM = 55312 | XEvent.Severity.Warning,
            MATCH_HACK_SEARCH_NUM_PARAMS = 55313 | XEvent.Severity.Warning,
            MATCH_HACK_SEARCH_END_OF_STREAM = 55314 | XEvent.Severity.Warning,
            MATCH_HACK_MISMATCH_LANGUAGE_ATTR = 55315 | XEvent.Severity.Warning,
            MATCH_HACK_MISMATCH_CLIENT_IPADDR = 55316 | XEvent.Severity.Warning,
            MATCH_HACK_SPLIT_SIZE_OVERFLOW = 55317 | XEvent.Severity.Warning,
            MATCH_HACK_XBOX1_PLATFORM_ATTRIBS = 55318 | XEvent.Severity.Warning,
            MATCH_INFO_0 = 55375 | XEvent.Severity.Info,
            MATCH_TITLEBUG_0 = 55400 | XEvent.Severity.Error,
            MATCH_TITLEBUG_1 = 55401 | XEvent.Severity.Error,
            MATCH_TITLEBUG_2 = 55402 | XEvent.Severity.Error,
            MATCH_TITLEBUG_3 = 55403 | XEvent.Severity.Error,
            MATCH_TITLEBUG_4 = 55404 | XEvent.Severity.Error,
            MATCH_TITLEBUG_5 = 55405 | XEvent.Severity.Error,
            MATCH_TITLEBUG_6 = 55406 | XEvent.Severity.Error,
            MATCH_TITLEBUG_7 = 55407 | XEvent.Severity.Error,
            MATCH_TITLEBUG_8 = 55408 | XEvent.Severity.Error,
            MATCH_TITLEBUG_9 = 55409 | XEvent.Severity.Error,
            MATCH_TITLEBUG_10 = 55410 | XEvent.Severity.Error,
            MATCH_TITLEBUG_11 = 55411 | XEvent.Severity.Error,
            MATCH_TITLEBUG_12 = 55412 | XEvent.Severity.Error,
            MATCH_TITLEBUG_13 = 55413 | XEvent.Severity.Error,
            MATCH_TITLEBUG_14 = 55414 | XEvent.Severity.Error,
            MATCH_TITLEBUG_15 = 55415 | XEvent.Severity.Error,
            MATCH_TITLEBUG_16 = 55416 | XEvent.Severity.Error,
            MATCH_TITLEBUG_17 = 55417 | XEvent.Severity.Error,
            MATCH_TITLEBUG_18 = 55418 | XEvent.Severity.Error,
            MATCH_TITLEBUG_19 = 55419 | XEvent.Severity.Error,
            MATCH_TITLEBUG_20 = 55420 | XEvent.Severity.Error,
            MATCH_TITLEBUG_21 = 55421 | XEvent.Severity.Error,
            MATCH_TITLEBUG_22 = 55422 | XEvent.Severity.Error,
            MATCH_TITLEBUG_23 = 55423 | XEvent.Severity.Error,
            MATCH_TITLEBUG_24 = 55424 | XEvent.Severity.Error,
            MATCH_TITLEBUG_25 = 55425 | XEvent.Severity.Error,
            MATCH_TITLEBUG_26 = 55426 | XEvent.Severity.Error,
            MATCH_TITLEBUG_27 = 55427 | XEvent.Severity.Error,
            MATCH_TITLEBUG_28 = 55428 | XEvent.Severity.Error,
            MATCH_TITLEBUG_29 = 55429 | XEvent.Severity.Error,
            MATCH_TITLEBUG_30 = 55430 | XEvent.Severity.Error,
            MATCH_TITLEBUG_31 = 55431 | XEvent.Severity.Error,
            MATCH_TITLEBUG_32 = 55432 | XEvent.Severity.Error,
            MATCH_TITLEBUG_33 = 55433 | XEvent.Severity.Error,
            MATCH_TITLEBUG_34 = 55434 | XEvent.Severity.Error,
            MATCH_TITLEBUG_35 = 55435 | XEvent.Severity.Error,
            MATCH_TITLEBUG_36 = 55436 | XEvent.Severity.Error,
            MATCH_TITLEBUG_37 = 55437 | XEvent.Severity.Error,
            MATCH_TITLEBUG_38 = 55438 | XEvent.Severity.Error,
            MATCH_TITLEBUG_39 = 55439 | XEvent.Severity.Error,
            MATCH_TITLEBUG_40 = 55440 | XEvent.Severity.Error,
            MATCH_TITLEBUG_41 = 55441 | XEvent.Severity.Error,
            MATCH_TITLEBUG_42 = 55442 | XEvent.Severity.Error,
            MATCH_TITLEBUG_43 = 55443 | XEvent.Severity.Error,
            MATCH_TITLEBUG_44 = 55444 | XEvent.Severity.Error,
            MATCH_TITLEBUG_45 = 55445 | XEvent.Severity.Error,
            MATCH_TITLEBUG_46 = 55446 | XEvent.Severity.Error,
            MATCH_TITLEBUG_47 = 55447 | XEvent.Severity.Error,
            MATCH_TITLEBUG_48 = 55448 | XEvent.Severity.Error,
            MATCH_TITLEBUG_49 = 55449 | XEvent.Severity.Error,
            MATCH_TITLEBUG_50 = 55450 | XEvent.Severity.Error,
            MATCH_TITLEBUG_51 = 55451 | XEvent.Severity.Error,
            MATCH_TITLEBUG_52 = 55452 | XEvent.Severity.Error,
            MATCH_TITLEBUG_FINDBYIDS_INVALID_SESSIONID = 55453 | XEvent.Severity.Error,
            MATCH_TITLEBUG_FINDBYIDS_INVALID_BLOB_PARAM = 55454 | XEvent.Severity.Error,
            MIX_WEBSGVALIDATION_HEADERMISSING = 15000 | XEvent.Severity.Error,
            MIX_WEBSGVALIDATION_HEADERINVALID = 15001 | XEvent.Severity.Error,
            MIX_STATS_INVALID_TITLE_ID = 15002 | XEvent.Severity.Info,
            MIX_STATS_INVALID_LEADERBOARD_ID = 15003 | XEvent.Severity.Info,
            MIX_STATS_SUCCESS = 15004 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_INVALID_TITLE_ID = 15005 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_SUCCESS = 15006 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_INVALID_XLAST = 15007 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_DECOMPRESSION_ERROR = 15008 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_INVALID_VERSION = 15009 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_INVALID_PLATFORM = 15010 | XEvent.Severity.Info,
            MIX_MATCH_SUCCESS = 15011 | XEvent.Severity.Info,
            MIX_STORAGE_SUCCESS = 15012 | XEvent.Severity.Info,
            MIX_STORAGE_INVALID_FILE_TYPE = 15013 | XEvent.Severity.Info,
            MIX_STORAGE_INVALID_GUID = 15014 | XEvent.Severity.Info,
            MIX_TITLEMANAGEMENT_INVALID_GUID = 15015 | XEvent.Severity.Info,
            MIX_MATCH_NEW_MODE_FOUND = 15016 | XEvent.Severity.Error,
            MIX_BETAMANAGEMENT_SUCCESS = 15017 | XEvent.Severity.Info,
            MIX_BETAMANAGEMENT_INVALID_GUID = 15018 | XEvent.Severity.Info,
            MIX_BETAMANAGEMENT_INVALID_FLASH_VERSION = 15019 | XEvent.Severity.Info,
            MIX_BETAMANAGEMENT_NULL_ARGUMENT = 15020 | XEvent.Severity.Info,
            MIX_STATS_FORBIDDEN_ENVIRONMENT = 15021 | XEvent.Severity.Info,
            MIX_CONCURRENCY_ERROR = 15022 | XEvent.Severity.Error,
            MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR = 15023 | XEvent.Severity.Error,
            MIX_SUBSCRIPTION_FAMILY_CREATE_ERROR = 15024 | XEvent.Severity.Error,
            MIX_SUBSCRIPTION_FAMILY_GET_ERROR = 15025 | XEvent.Severity.Error,
            MIX_BETAMANAGEMENT_INVALID_TITLE_VERSION = 15026 | XEvent.Severity.Info,
            MIX_BETAMANAGEMENT_INVALID_TITLE_ID = 15027 | XEvent.Severity.Info,
            MIX_SETTINGS_INVALID_ARGUMENT = 15028 | XEvent.Severity.Error,
            MIX_STATS_CUSTOMER_IMPACT = 15029 | XEvent.Severity.Info,
            MIX_BETAMANAGEMENT_INVALID_ARGUMENT = 15030 | XEvent.Severity.Error,
            MIX_STATS_FORCE_REQUIRED = 15031 | XEvent.Severity.Error,
            MIX_MATCH_MISSING_REMOVE_MODE = 15032 | XEvent.Severity.Error,
            MIX_MATCH_SQL_EXCEPTION = 15033 | XEvent.Severity.Error,
            MIX_BETAMANAGEMENT_GROUP_MUST_BE_EMPTY = 15034 | XEvent.Severity.Error,
            MIX_BETAMANAGEMENT_XKDC_RELOAD_FAILED = 15035 | XEvent.Severity.Warning,
            MIX_BETAMANAGEMENT_HIVE_RELOAD_FAILED = 15036 | XEvent.Severity.Warning,
            MIX_BETAMANAGEMENT_CANNOT_MIGRATE_TO_SELF = 15037 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_NULL_ARGUMENT = 15038 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_INVALID_ARGUMENT = 15039 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE = 15040 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_RANK_LOCATION = 15041 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR = 15042 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_XBOS_RELOAD_FAILED = 15043 | XEvent.Severity.Warning,
            MIX_TOKEN_FILE_NOT_FOUND = 15044 | XEvent.Severity.Error,
            MIX_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND = 15045 | XEvent.Severity.Error,
            MIX_TOKEN_MALFORMED_5X5_TOKEN_CODE_FOUND = 15046 | XEvent.Severity.Error,
            MIX_TOKEN_FILE_DECRYPTION_ERROR = 15047 | XEvent.Severity.Error,
            MIX_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED = 15048 | XEvent.Severity.Error,
            MIX_TOKEN_JOB_NOT_IN_REQUIRED_STATE = 15049 | XEvent.Severity.Error,
            MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_XRL_LOCATION = 15050 | XEvent.Severity.Error,
            MIX_COMMON_FRONT_DOOR_RESET_ERROR = 15051 | XEvent.Severity.Error,
            MIX_SETTINGS_ERROR_INGESTING_ETX_MANIFEST = 15052 | XEvent.Severity.Error,
            MIX_TOKEN_MANAGEMENT_SERIALIZATION_ERROR = 15053 | XEvent.Severity.Error,
            MIX_BETA_MANAGEMENT_DUPLICATE_APP_ERROR = 15054 | XEvent.Severity.Error,
            MIX_COMMON_INVALID_LOGGING_FIELD = 15055 | XEvent.Severity.Warning,
            MIX_STS_CONFIGURATION_RELOAD_FAILED = 15056 | XEvent.Severity.Warning,
            MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED = 15057 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_PARTNER_DOES_NOT_EXIST = 15058 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_TITLE_NOT_ASSOCIATED = 15059 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_APPLIES_TO_DOES_NOT_EXIST = 15060 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR = 15061 | XEvent.Severity.Error,
            MIX_TITLE_MANAGEMENT_ERROR_SETTING_NACL_PRIVILEGE = 15062 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_UNSUPPORTED_TOKEN_TYPE = 15063 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_UNSUPPORTED_ENDPOINT_PROTOCOL = 15064 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_INVALID_CLAIM_TYPE = 15065 | XEvent.Severity.Error,
            MIX_STS_CONFIGURATION_PRIVATE_CLAIM_TYPE = 15066 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR = 55500 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_1 = 55501 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_2 = 55502 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_5 = 55503 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_6 = 55504 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_7 = 55505 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_8 = 55506 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_9 = 55507 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_10 = 55508 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_11 = 55509 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_12 = 55510 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_13 = 55511 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_14 = 55512 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_15 = 55513 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_16 = 55514 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_17 = 55515 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_18 = 55516 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_19 = 55517 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_20 = 55518 | XEvent.Severity.Error,
            MGMT_GENERIC_ERROR_21 = 55519 | XEvent.Severity.Error,
            MGMT_PING_ERROR = 55550 | XEvent.Severity.Error,
            MGMT_PING_ERROR_1 = 55551 | XEvent.Severity.Error,
            MGMT_PING_ERROR_2 = 55552 | XEvent.Severity.Error,
            MGMT_PING_ERROR_3 = 55553 | XEvent.Severity.Error,
            MGMT_PING_ERROR_4 = 55554 | XEvent.Severity.Error,
            MGMT_PING_ERROR_5 = 55555 | XEvent.Severity.Error,
            MGMT_PING_ERROR_6 = 55556 | XEvent.Severity.Error,
            MGMT_PING_ERROR_7 = 55557 | XEvent.Severity.Error,
            MGMT_INIT_WARNING_1 = 55575 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_2 = 55576 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_3 = 55577 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_4 = 55578 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_5 = 55579 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_6 = 55580 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_7 = 55581 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_8 = 55582 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_9 = 55583 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_10 = 55584 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_11 = 55585 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_12 = 55586 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_13 = 55587 | XEvent.Severity.Warning,
            MGMT_INIT_FAILURE_10 = 55588 | XEvent.Severity.Error,
            MGMT_INIT_WARNING_14 = 55589 | XEvent.Severity.Warning,
            MGMT_CONFIG_15 = 55590 | XEvent.Severity.Warning,
            MGMT_CONFIG_16 = 55591 | XEvent.Severity.Error,
            MGMT_CONFIG_17 = 55592 | XEvent.Severity.Error,
            MGMT_CONFIG_18 = 55593 | XEvent.Severity.Error,
            MGMT_CONFIG_19 = 55594 | XEvent.Severity.Error,
            MGMT_CONFIG_20 = 55595 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_11 = 55596 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_12 = 55597 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_13 = 55598 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_14 = 55599 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_15 = 55600 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_16 = 55601 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_17 = 55602 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_18 = 55603 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_19 = 55604 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_20 = 55605 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_21 = 55606 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_22 = 55607 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_23 = 55608 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_24 = 55609 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_25 = 55610 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_26 = 55611 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_27 = 55612 | XEvent.Severity.Error,
            MGMT_INIT_FAILURE_28 = 55613 | XEvent.Severity.Error,
            MGMT_INIT_ACCEPT_FAILURE = 55614 | XEvent.Severity.Error,
            MGMT_INIT_CONNECT_PIPE_FAILURE = 55615 | XEvent.Severity.Error,
            MGMT_HACK_0 = 55675 | XEvent.Severity.Warning,
            MGMT_HACK_1 = 55676 | XEvent.Severity.Warning,
            MGMT_INIT_SUCCESS = 55700 | XEvent.Severity.Info,
            MGMT_INIT_SUCCESS_1 = 55701 | XEvent.Severity.Info,
            MC_APPDOMAIN_STARTED_2 = 55702 | XEvent.Severity.Info,
            MC_APPDOMAIN_STOPPED = 55703 | XEvent.Severity.Info,
            MGMT_ADMIN_COMMAND = 55704 | XEvent.Severity.Info,
            PRESENCE_HEADER_TRUNCATED = 15000 | XEvent.Severity.Warning,
            PRESENCE_REQUEST_TRUNCATED = 15001 | XEvent.Severity.Warning,
            PRESENCE_NO_VINTERFACE = 15002 | XEvent.Severity.Warning,
            PRESENCE_BAD_CONTENT_TYPE = 15003 | XEvent.Severity.Warning,
            PRESENCE_NOTIFICATION_MESSAGE_TRUNCATED = 15004 | XEvent.Severity.Warning,
            PRESENCE_INVALID_USERID = 15005 | XEvent.Severity.Error,
            PRESENCE_INVALID_DC_MESSAGE_TYPE = 15006 | XEvent.Severity.Warning,
            PRESENCE_INVALID_CLIENT_MESSAGE_TYPE = 15007 | XEvent.Severity.Warning,
            PRESENCE_UNKNOWN_MESSAGE_TYPE = 15008 | XEvent.Severity.Warning,
            PRESENCE_DO_NOT_LOG_EVENT = 15009 | XEvent.Severity.Info,
            PRESENCE_SGINFO_INVALID_PUID = 15010 | XEvent.Severity.Error,
            PRESENCE_ALIVE_INVALID_TITLEID = 15020 | XEvent.Severity.Warning,
            PRESENCE_ALIVE_GAMERTAG_TOO_BIG = 15021 | XEvent.Severity.Warning,
            PRESENCE_ALIVE_DB_READ_ERROR = 15022 | XEvent.Severity.Error,
            PRESENCE_LOGIN_NAME_MISMATCH = 15023 | XEvent.Severity.Error,
            PRESENCE_LICENSE_MIGRATION_ERROR = 15024 | XEvent.Severity.Error,
            PRESENCE_WELCOME_MESSAGE_ERROR = 15025 | XEvent.Severity.Error,
            PRESENCE_INVALID_GAMERTAG = 15030 | XEvent.Severity.Error,
            PRESENCE_FRIEND_NOT_SPECIFIED = 15031 | XEvent.Severity.Error,
            PRESENCE_FRIEND_IS_SENDER = 15032 | XEvent.Severity.Error,
            PRESENCE_DATA_MISMATCH = 15033 | XEvent.Severity.Error,
            PRESENCE_FRIEND_LIST_ACCESS_DENIED = 15034 | XEvent.Severity.Warning,
            PRESENCE_CACHE_NOTFOUND = 15040 | XEvent.Severity.Error,
            PRESENCE_CONFIG_PRESENCE_BLACKLIST = 15041 | XEvent.Severity.Warning,
            PRESENCE_INVALID_QUEUE_TYPE = 15050 | XEvent.Severity.Error,
            PRESENCE_UNSUPPORTED_QUEUE_TYPE = 15051 | XEvent.Severity.Error,
            PRESENCE_INVITE_SENDER_INVALID_USERID = 15070 | XEvent.Severity.Error,
            PRESENCE_INVITE_SENDER_IS_OFFLINE = 15071 | XEvent.Severity.Error,
            PRESENCE_INVITE_MISSING_SESSION_ID = 15072 | XEvent.Severity.Error,
            PRESENCE_INVITE_BAD_NUMBER_INVITEES = 15073 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_INVALID_HOSTID = 15080 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_INVALID_SESSIONID = 15081 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_INVALID_ANSWER = 15082 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_INVALID_USERID = 15083 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_SENDER_IS_OFFLINE = 15084 | XEvent.Severity.Error,
            PRESENCE_INVITEANSWER_REVOKE_FAILED = 15085 | XEvent.Severity.Error,
            PRESENCE_CANCELINVITE_INVALID_SESSIONID = 15090 | XEvent.Severity.Error,
            PRESENCE_CANCELINVITE_INVALID_USERID = 15091 | XEvent.Severity.Error,
            PRESENCE_CANCELINVITE_SENDER_IS_OFFLINE = 15092 | XEvent.Severity.Error,
            PRESENCE_CANCELINVITE_REVOKE_FAILED = 15093 | XEvent.Severity.Error,
            PRESENCE_MUTELIST_ADD_ERROR = 15100 | XEvent.Severity.Error,
            PRESENCE_MUTELIST_DELETE_ERROR = 15101 | XEvent.Severity.Error,
            PRESENCE_NEVERLIST_ADD_ERROR = 15102 | XEvent.Severity.Error,
            PRESENCE_NEVERLIST_DELETE_ERROR = 15103 | XEvent.Severity.Error,
            PRESENCE_NEVERLIST_INVALID_USER = 15104 | XEvent.Severity.Error,
            PRESENCE_INVALIDATE_USER_UNKNOWN_USER = 15110 | XEvent.Severity.Error,
            PRESENCE_KICK_UNKNOWN_USER = 15120 | XEvent.Severity.Error,
            PRESENCE_PURGE_USER_TARGET_IS_ONLINE = 15130 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_ZERO_AFFILIATES = 15140 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_TOO_MANY_AFFILIATES = 15141 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_MULTIPLE_LISTS = 15142 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_INVALID_LIST = 15143 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_NO_BATCHING = 15144 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_ADDING_SELF = 15145 | XEvent.Severity.Error,
            PRESENCE_ADD_AFFILIATES_ADDING_ZERO_XUID = 15146 | XEvent.Severity.Error,
            PRESENCE_QUERY_AFFILIATES_NO_LISTS = 15150 | XEvent.Severity.Error,
            PRESENCE_QUERY_AFFILIATES_MULTIPLE_LIST_LIMIT = 15151 | XEvent.Severity.Error,
            PRESENCE_IS_AFFILIATE_ZERO_AFFILIATE_ID = 15160 | XEvent.Severity.Error,
            PRESENCE_IS_AFFILIATE_TO_SELF = 15161 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_NO_GAMECONFIGPROJECT = 15170 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_NO_LOCALIZEDSTRINGS = 15171 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_NO_SUPPORTEDLOCALE = 15172 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_NO_PRESENCEMODE = 15173 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_PARSE_FAILED = 15174 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_NO_CONTEXT = 15175 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_NO_CONTEXTVALUE = 15176 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_BAD_FILE = 15177 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_SQL_LOAD_FAILED = 15178 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_NO_SCHEMA = 15179 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_LODEGAMECONFIGPROC_FAILED = 15180 | XEvent.Severity.Error,
            PRESENCE_TITLECONFIG_TRANSLATION_NOT_FOUND = 15181 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_SCHEMA_NOT_LOADED = 15182 | XEvent.Severity.Warning,
            PRESENCE_TITLECONFIG_PARSE_SUCCESS = 15183 | XEvent.Severity.Info,
            PRESENCE_RICHPRESENCE_FORMAT_NOT_FOUND = 15190 | XEvent.Severity.Warning,
            PRESENCE_RICHPRESENCE_CONTEXT_LABEL_NOT_FOUND = 15191 | XEvent.Severity.Warning,
            PRESENCE_RICHPRESENCE_CONTEXT_NOT_FOUND = 15192 | XEvent.Severity.Warning,
            PRESENCE_RICHPRESENCE_FORMAT_FAILED = 15193 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_INVALID_SERVICEID = 15200 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_REQUEST_TOO_SMALL = 15201 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_REQUEST_INVALID_LENGTH = 15202 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_LENGTH = 15203 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_TYPE = 15204 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYDELETE_UNEXPECTED_FAILURE = 15205 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_INVALID_SERVICEID = 15210 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_REQUEST_TOO_SMALL = 15211 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_LENGTH = 15212 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_HEADER = 15213 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_LENGTH = 15214 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_TYPE = 15215 | XEvent.Severity.Error,
            PRESENCE_SGNOTIFYUPDATE_UNEXPECTED_FAILURE = 15216 | XEvent.Severity.Error,
            PRESENCE_STATE_UNKNOWN_USER = 15217 | XEvent.Severity.Error,
            PRESENCE_WEBALIVE_UNKNOWN_USER = 15220 | XEvent.Severity.Error,
            PRESENCE_INFO_INVALID_USER_COUNT = 15230 | XEvent.Severity.Error,
            QUERY_BAD_DATA_9 = 57700 | XEvent.Severity.Error,
            QUERY_LSP_BACKCOMPAT_UNSUPPORTED_ATTRIBUTE = 57701 | XEvent.Severity.Error,
            QUERY_INVALID_SETTING_LSPBACKCOMPTITLES = 57702 | XEvent.Severity.Error,
            QUERYLIB_CODE_0 = 57725 | XEvent.Severity.Error,
            QUERY_SERVER_HEALTH_ERROR = 57750 | XEvent.Severity.Error,
            QUERY_BAD_DATA_10 = 57775 | XEvent.Severity.Error,
            QUERY_BAD_DATA_11 = 57776 | XEvent.Severity.Error,
            QUERY_BAD_DATA_12 = 57777 | XEvent.Severity.Error,
            QUERY_BAD_DATA_13 = 57778 | XEvent.Severity.Error,
            QUERY_BAD_DATA_14 = 57779 | XEvent.Severity.Error,
            QUERY_BAD_DATA_15 = 57780 | XEvent.Severity.Error,
            QUERY_BAD_DATA_16 = 57781 | XEvent.Severity.Error,
            QUERY_BAD_DATA_17 = 57782 | XEvent.Severity.Error,
            QUERY_BAD_DATA_18 = 57783 | XEvent.Severity.Error,
            MC_QUERY_TRUST_IS_OFF = 57784 | XEvent.Severity.Warning,
            QUERY_DATASET_CONFIG_ERROR = 57785 | XEvent.Severity.Error,
            QUERY_DATASET_CONFIG_ERROR_1 = 57786 | XEvent.Severity.Error,
            QUERY_PLUGIN_CREATION_ERROR_1 = 57787 | XEvent.Severity.Error,
            QUERYLIB_CONFIG_13 = 57788 | XEvent.Severity.Error,
            QUERYLIB_CONFIG_14 = 57789 | XEvent.Severity.Error,
            QUERYLIB_CONFIG_15 = 57790 | XEvent.Severity.Error,
            QUERYLIB_CONFIG_16 = 57791 | XEvent.Severity.Error,
            QUERY_PLUGIN_CREATION_ERROR_2 = 57792 | XEvent.Severity.Error,
            SOCIALCACHE_STARTED = 20000 | XEvent.Severity.Info,
            SOCIALCACHE_SHUTDOWN = 20001 | XEvent.Severity.Info,
            SOCIALCACHE_STARTUP_FAILURE = 20002 | XEvent.Severity.Error,
            SOCIALCACHE_PROTOCOL_VERSION_MISMATCH = 20003 | XEvent.Severity.Error,
            SOCIALCACHE_MSGTYPE_UNKNOWN = 20004 | XEvent.Severity.Error,
            SOCIALCACHE_MSG_BEFORE_CONNECT = 20005 | XEvent.Severity.Error,
            SOCIALCACHE_USER_INDEX_MISMATCH = 20006 | XEvent.Severity.Error,
            SOCIALCACHE_MSG_TOO_SMALL = 20007 | XEvent.Severity.Error,
            SOCIALCACHE_INVALID_USER_FLAGS = 20008 | XEvent.Severity.Error,
            SOCIALCACHE_TOO_MANY_USER_FLAGS = 20009 | XEvent.Severity.Error,
            SOCIALCACHE_NUM_USER_FLAGS_MISMATCH = 20010 | XEvent.Severity.Error,
            SOCIALCACHE_MSGTYPE_UNSUPPORTED = 20011 | XEvent.Severity.Error,
            SOCIALCACHE_MSG_TOO_BIG = 20012 | XEvent.Severity.Error,
            SOCIALCACHE_SGINFO_ERROR = 20013 | XEvent.Severity.Error,
            SOCIALCACHE_USER_NOT_PRESENT = 20014 | XEvent.Severity.Error,
            SOCIALCACHE_CONTEXT_EXCEPTION = 20015 | XEvent.Severity.Error,
            SOCIALCACHE_DATA_TOO_SMALL = 20016 | XEvent.Severity.Error,
            SOCIALCACHE_DATA_INTEGRITY_ERROR = 20017 | XEvent.Severity.Error,
            SOCIALCACHE_TOO_MANY_OBJECTS = 20019 | XEvent.Severity.Error,
            SOCIALCACHE_TOO_MANY_SUBSCRIPTIONS = 20020 | XEvent.Severity.Error,
            SOCIALCACHE_EXCEPTION_WOULD_DEADLOCK = 20021 | XEvent.Severity.Warning,
            SOCIALCACHE_THREADPOOL_EXCEPTION = 20022 | XEvent.Severity.Warning,
            SOCIALCACHE_NOTIFICATION_FORMATTING_ERROR = 20023 | XEvent.Severity.Error,
            SOCIALCACHE_DUPLICATE_USER = 20024 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_CONNECT_FAILED = 20025 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_SEND_FAILED = 20026 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_RECEIVE_FAILED = 20027 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_SERVER_CHANGE_FAILED = 20028 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_BUCKET_MAP_FAILED = 20029 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_BUCKET_CHANGE_FAILED = 20030 | XEvent.Severity.Error,
            SOCIALCACHE_PROXY_REQUEST_FAILED = 20031 | XEvent.Severity.Error,
            XBOX_AVATAR_ASSETS_NOT_SUPPORTED = 15000 | XEvent.Severity.Error,
            XBOX360_AVATAR_ASSETS_NOT_SUPPORTED = 15001 | XEvent.Severity.Error,
            PC_AVATAR_ASSETS_NOT_SUPPORTED = 15002 | XEvent.Severity.Error,
            UNKNOWN_PLATFORM_AVATAR_ASSETS_NOT_SUPPORTED = 15003 | XEvent.Severity.Error,
            CONSOLE_AUDIT_LIST_NOT_SUPPORTED = 15004 | XEvent.Severity.Error,
            CONSOLE_AUDIT_LIST_EMPTY = 15005 | XEvent.Severity.Error,
            AVATAR_ASSET_VALIDATION_FAILED = 15006 | XEvent.Severity.Error,
            STATS_MISSING_SERVER_INFO = 15007 | XEvent.Severity.Warning,
            MOBILE_ACHIEVEMENTS_NOT_SUPPORTED = 15008 | XEvent.Severity.Error,
            WEB_GAMES_ACHIEVEMENTS_NOT_SUPPORTED = 15009 | XEvent.Severity.Error,
            MOBILE_AVATAR_ASSETS_NOT_SUPPORTED = 15010 | XEvent.Severity.Error,
            WEB_GAMES_AVATAR_ASSETS_NOT_SUPPORTED = 15011 | XEvent.Severity.Error,
            STATS_PLATFORM_VISIBLE_LEADERBOARDS_GET_ALL_FAILURE = 15012 | XEvent.Severity.Error,
            STATS_PLATFORM_VISIBLE_LEADERBOARDS_ADD_TO_MAP_FAILURE = 15013 | XEvent.Severity.Error,
            STATS_PLATFORM_VISIBLE_LEADERBOARDS_LOAD_FAILURE = 15014 | XEvent.Severity.Error,
            STATS_CODE_PERF_CREATE_FAILED = 20000 | XEvent.Severity.Error,
            STATS_CODE_HEALTHINTEROP_CREATE_FAILED = 20001 | XEvent.Severity.Error,
            STATS_CODE_HEALTHINTEROP_INIT_FAILED = 20002 | XEvent.Severity.Error,
            STFD_MISSING_OR_BAD_CONFIG = 51596 | XEvent.Severity.Error,
            STFD_MISSING_OR_BAD_CONFIG_1 = 51598 | XEvent.Severity.Error,
            XSTATSFD_INVALID_REQUEST = 52354 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_1 = 52355 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_2 = 52356 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_3 = 52357 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_4 = 52360 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_5 = 52361 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_6 = 52362 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_7 = 52363 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_8 = 52364 | XEvent.Severity.Warning,
            STATS_CODE_0 = 58050 | XEvent.Severity.Error,
            STATS_CODE_1 = 58051 | XEvent.Severity.Error,
            STATS_CODE_2 = 58052 | XEvent.Severity.Error,
            STATS_CODE_3 = 58053 | XEvent.Severity.Error,
            STATS_CODE_4 = 58054 | XEvent.Severity.Error,
            STATS_CODE_5 = 58055 | XEvent.Severity.Error,
            STATS_CODE_6 = 58056 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_9 = 58057 | XEvent.Severity.Error,
            STATS_CODE_8 = 58058 | XEvent.Severity.Error,
            STATS_CODE_9 = 58059 | XEvent.Severity.Error,
            STATS_CODE_10 = 58060 | XEvent.Severity.Error,
            STATS_CODE_11 = 58061 | XEvent.Severity.Error,
            XSTATSFD_DATABASE_ERROR = 58062 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_10 = 58063 | XEvent.Severity.Error,
            STATS_CODE_14 = 58064 | XEvent.Severity.Error,
            STATS_CODE_15 = 58065 | XEvent.Severity.Error,
            STATS_CODE_16 = 58066 | XEvent.Severity.Error,
            STATS_CODE_17 = 58067 | XEvent.Severity.Error,
            STATS_CODE_18 = 58068 | XEvent.Severity.Error,
            STATS_CODE_19 = 58069 | XEvent.Severity.Error,
            XSTATSFD_INVALID_ATTACHMENT = 58070 | XEvent.Severity.Error,
            XSTATSFD_DATABASE_ERROR_1 = 58071 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_11 = 58072 | XEvent.Severity.Error,
            MC_APPLICATION_ERROR_12 = 58073 | XEvent.Severity.Error,
            STATS_CODE_24 = 58074 | XEvent.Severity.Error,
            XSTATSFD_DATABASE_ERROR_2 = 58075 | XEvent.Severity.Error,
            STATS_CODE_26 = 58076 | XEvent.Severity.Error,
            STATS_CODE_27 = 58077 | XEvent.Severity.Error,
            STATS_CODE_28 = 58078 | XEvent.Severity.Error,
            STATS_CODE_29 = 58079 | XEvent.Severity.Error,
            STATS_CODE_30 = 58080 | XEvent.Severity.Error,
            STATS_CODE_31 = 58081 | XEvent.Severity.Error,
            STATS_CODE_32 = 58082 | XEvent.Severity.Error,
            STATS_CODE_33 = 58083 | XEvent.Severity.Error,
            STATS_CODE_34 = 58084 | XEvent.Severity.Error,
            STATS_CODE_35 = 58085 | XEvent.Severity.Error,
            STATS_CODE_36 = 58086 | XEvent.Severity.Error,
            STATS_CODE_37 = 58087 | XEvent.Severity.Error,
            STATS_CODE_38 = 58088 | XEvent.Severity.Error,
            STATS_CODE_39 = 58089 | XEvent.Severity.Error,
            STATS_CODE_40 = 58090 | XEvent.Severity.Error,
            STATS_CODE_41 = 58091 | XEvent.Severity.Error,
            STATS_CODE_42 = 58092 | XEvent.Severity.Error,
            STATS_CODE_43 = 58093 | XEvent.Severity.Error,
            XSMT_UNEXPECTED = 58094 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_1 = 58095 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_2 = 58096 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_3 = 58097 | XEvent.Severity.Error,
            XSMT_MEMORY_ERROR = 58098 | XEvent.Severity.Error,
            STATS_CODE_49 = 58099 | XEvent.Severity.Error,
            STATS_CODE_50 = 58100 | XEvent.Severity.Error,
            STATS_CODE_51 = 58101 | XEvent.Severity.Error,
            STATS_CODE_52 = 58102 | XEvent.Severity.Error,
            STATS_CODE_53 = 58103 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_4 = 58104 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_5 = 58105 | XEvent.Severity.Error,
            STATS_CODE_56 = 58106 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_6 = 58107 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_7 = 58108 | XEvent.Severity.Error,
            STATS_CODE_59 = 58109 | XEvent.Severity.Error,
            STATS_CODE_60 = 58110 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_8 = 58111 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_9 = 58112 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_10 = 58113 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_11 = 58114 | XEvent.Severity.Error,
            STATS_CODE_65 = 58115 | XEvent.Severity.Error,
            STATS_CODE_66 = 58116 | XEvent.Severity.Error,
            STATS_CODE_67 = 58117 | XEvent.Severity.Error,
            STATS_CODE_68 = 58118 | XEvent.Severity.Error,
            STATS_CODE_69 = 58119 | XEvent.Severity.Error,
            STATS_CODE_70 = 58120 | XEvent.Severity.Error,
            STATS_CODE_71 = 58121 | XEvent.Severity.Error,
            STATS_CODE_72 = 58122 | XEvent.Severity.Error,
            STATS_CODE_73 = 58123 | XEvent.Severity.Error,
            STATS_CODE_74 = 58124 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_12 = 58125 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_13 = 58126 | XEvent.Severity.Error,
            STATS_CODE_77 = 58127 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_14 = 58128 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_15 = 58129 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_16 = 58130 | XEvent.Severity.Error,
            STATS_CODE_81 = 58131 | XEvent.Severity.Error,
            STATS_CODE_82 = 58132 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_17 = 58133 | XEvent.Severity.Error,
            XSMT_UNEXPECTED_18 = 58134 | XEvent.Severity.Error,
            STATS_CODE_85 = 58135 | XEvent.Severity.Error,
            STATS_CODE_86 = 58136 | XEvent.Severity.Error,
            STATS_CODE_87 = 58137 | XEvent.Severity.Error,
            STATS_CODE_88 = 58138 | XEvent.Severity.Error,
            STATS_CODE_89 = 58139 | XEvent.Severity.Error,
            STATS_CODE_90 = 58140 | XEvent.Severity.Error,
            STATS_CODE_91 = 58141 | XEvent.Severity.Error,
            STATS_CODE_92 = 58142 | XEvent.Severity.Error,
            STATS_CODE_93 = 58143 | XEvent.Severity.Error,
            STATS_CODE_94 = 58144 | XEvent.Severity.Error,
            STATS_CODE_95 = 58145 | XEvent.Severity.Error,
            STATS_CODE_96 = 58146 | XEvent.Severity.Error,
            STATS_CODE_97 = 58147 | XEvent.Severity.Error,
            STATS_CODE_98 = 58148 | XEvent.Severity.Error,
            STATS_CODE_99 = 58149 | XEvent.Severity.Error,
            STATS_CODE_100 = 58150 | XEvent.Severity.Error,
            STATS_CODE_101 = 58151 | XEvent.Severity.Error,
            STATS_CODE_102 = 58152 | XEvent.Severity.Error,
            STATS_CODE_103 = 58153 | XEvent.Severity.Error,
            STATS_CODE_104 = 58154 | XEvent.Severity.Error,
            STATS_CODE_105 = 58155 | XEvent.Severity.Error,
            STATS_CODE_106 = 58156 | XEvent.Severity.Error,
            STATS_CODE_107 = 58157 | XEvent.Severity.Error,
            STATS_CODE_108 = 58158 | XEvent.Severity.Error,
            XBOX_ACHIEVEMENTS_NOT_SUPPORTED = 58159 | XEvent.Severity.Error,
            XBOX360_ACHIEVEMENTS_NOT_SUPPORTED = 58160 | XEvent.Severity.Error,
            PC_ACHIEVEMENTS_NOT_SUPPORTED = 58161 | XEvent.Severity.Error,
            UNKNOWN_PLATFORM_ACHIEVEMENTS_NOT_SUPPORTED = 58162 | XEvent.Severity.Error,
            STATS_COMM_0 = 58250 | XEvent.Severity.Error,
            STATS_COMM_1 = 58251 | XEvent.Severity.Error,
            STATS_COMM_2 = 58252 | XEvent.Severity.Error,
            STATS_COMM_3 = 58253 | XEvent.Severity.Error,
            STATS_COMM_4 = 58254 | XEvent.Severity.Error,
            STATS_COMM_5 = 58255 | XEvent.Severity.Error,
            STATS_COMM_6 = 58256 | XEvent.Severity.Error,
            STATS_COMM_7 = 58257 | XEvent.Severity.Error,
            STATS_COMM_8 = 58258 | XEvent.Severity.Error,
            XSTATSFD_SQL_CONNECT_FAILED = 58259 | XEvent.Severity.Error,
            STATS_COMM_10 = 58260 | XEvent.Severity.Error,
            STATS_COMM_11 = 58261 | XEvent.Severity.Error,
            STATS_COMM_12 = 58262 | XEvent.Severity.Error,
            STATS_COMM_13 = 58263 | XEvent.Severity.Error,
            LBS_NETWORK_ERROR = 58264 | XEvent.Severity.Error,
            LBS_FATAL_ERROR = 58265 | XEvent.Severity.Error,
            LBS_NETWORK_ERROR_1 = 58266 | XEvent.Severity.Error,
            LBS_LOAD_THREAD_ERROR_1 = 58267 | XEvent.Severity.Error,
            LBS_LOAD_THREAD_WARNING_1 = 58268 | XEvent.Severity.Warning,
            STATS_CONFIG_0 = 58300 | XEvent.Severity.Error,
            STATS_CONFIG_1 = 58301 | XEvent.Severity.Error,
            STATS_CONFIG_2 = 58302 | XEvent.Severity.Error,
            STATS_CONFIG_3 = 58303 | XEvent.Severity.Error,
            STATS_CONFIG_4 = 58304 | XEvent.Severity.Error,
            STATS_CONFIG_5 = 58305 | XEvent.Severity.Error,
            XSTATSFD_MISSING_DB_MAPPING = 58306 | XEvent.Severity.Error,
            XSTATSFD_MISSING_DB_MAPPING_1 = 58307 | XEvent.Severity.Error,
            XSTATSFD_MISSING_DB_MAPPING_2 = 58308 | XEvent.Severity.Error,
            STATS_CONFIG_9 = 58309 | XEvent.Severity.Error,
            XSTATSFD_LEADERBOARD_READONLY = 58310 | XEvent.Severity.Warning,
            STATS_CONFIG_11 = 58311 | XEvent.Severity.Warning,
            STATS_CONFIG_12 = 58312 | XEvent.Severity.Warning,
            STATS_CONFIG_13 = 58313 | XEvent.Severity.Warning,
            STATS_CONFIG_14 = 58314 | XEvent.Severity.Warning,
            STATS_CONFIG_15 = 58315 | XEvent.Severity.Warning,
            STATS_CONFIG_16 = 58316 | XEvent.Severity.Warning,
            STATS_CONFIG_17 = 58317 | XEvent.Severity.Error,
            STATS_CONFIG_18 = 58318 | XEvent.Severity.Error,
            STATS_CONFIG_19 = 58319 | XEvent.Severity.Error,
            STATS_CONFIG_20 = 58320 | XEvent.Severity.Error,
            XSTATSFD_ALLOW_UNVERIFIED_STAT_WRITE_IS_ON = 58321 | XEvent.Severity.Warning,
            STATS_CONFIG_22 = 58322 | XEvent.Severity.Warning,
            STATS_CONFIG_23 = 58323 | XEvent.Severity.Warning,
            STATS_CONFIG_24 = 58324 | XEvent.Severity.Warning,
            STATS_CONFIG_25 = 58325 | XEvent.Severity.Warning,
            STATS_CONFIG_26 = 58326 | XEvent.Severity.Error,
            XSMT_INIT_FAILED = 58327 | XEvent.Severity.Error,
            XSMT_INIT_FAILED_1 = 58328 | XEvent.Severity.Error,
            STATS_CONFIG_29 = 58329 | XEvent.Severity.Error,
            STATS_CONFIG_30 = 58330 | XEvent.Severity.Error,
            STATS_CONFIG_31 = 58331 | XEvent.Severity.Error,
            STATS_CONFIG_32 = 58332 | XEvent.Severity.Error,
            STATS_CONFIG_33 = 58333 | XEvent.Severity.Error,
            STATS_CONFIG_34 = 58334 | XEvent.Severity.Error,
            STATS_CONFIG_35 = 58335 | XEvent.Severity.Error,
            STATS_CONFIG_36 = 58336 | XEvent.Severity.Error,
            STATS_CONFIG_37 = 58337 | XEvent.Severity.Error,
            STATS_CONFIG_38 = 58338 | XEvent.Severity.Error,
            STATS_CONFIG_39 = 58339 | XEvent.Severity.Error,
            STATS_CONFIG_40 = 58340 | XEvent.Severity.Error,
            STATS_CONFIG_41 = 58341 | XEvent.Severity.Error,
            STATS_CONFIG_42 = 58342 | XEvent.Severity.Error,
            STATS_CONFIG_43 = 58343 | XEvent.Severity.Error,
            STATS_NO_XLAST_IN_TITLE_SYNC = 58344 | XEvent.Severity.Warning,
            STATS_HACK_0 = 58400 | XEvent.Severity.Warning,
            STATS_HACK_1 = 58401 | XEvent.Severity.Warning,
            STATS_HACK_2 = 58402 | XEvent.Severity.Warning,
            STATS_HACK_3 = 58403 | XEvent.Severity.Warning,
            STATS_HACK_4 = 58404 | XEvent.Severity.Warning,
            STATS_HACK_5 = 58405 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_9 = 58406 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_10 = 58407 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_11 = 58408 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_12 = 58409 | XEvent.Severity.Warning,
            STATS_HACK_10 = 58410 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_13 = 58411 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_14 = 58412 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_15 = 58413 | XEvent.Severity.Warning,
            STATS_HACK_14 = 58414 | XEvent.Severity.Warning,
            STATS_HACK_15 = 58415 | XEvent.Severity.Warning,
            STATS_HACK_16 = 58416 | XEvent.Severity.Warning,
            STATS_HACK_17 = 58417 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_16 = 58418 | XEvent.Severity.Warning,
            STATS_HACK_19 = 58419 | XEvent.Severity.Warning,
            STATS_HACK_20 = 58420 | XEvent.Severity.Warning,
            STATS_HACK_21 = 58421 | XEvent.Severity.Warning,
            STATS_HACK_22 = 58422 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_17 = 58423 | XEvent.Severity.Warning,
            STATS_HACK_24 = 58424 | XEvent.Severity.Warning,
            STATS_HACK_25 = 58425 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_18 = 58426 | XEvent.Severity.Warning,
            STATS_HACK_27 = 58427 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_19 = 58428 | XEvent.Severity.Warning,
            STATS_HACK_29 = 58429 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_20 = 58430 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_21 = 58431 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_22 = 58432 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_23 = 58433 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_24 = 58434 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_25 = 58435 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_26 = 58436 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_27 = 58437 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_28 = 58438 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_29 = 58439 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_30 = 58440 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_31 = 58441 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_32 = 58442 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_33 = 58443 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_34 = 58444 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_35 = 58445 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_36 = 58446 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_37 = 58447 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_38 = 58448 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_39 = 58449 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_40 = 58450 | XEvent.Severity.Warning,
            STATS_HACK_51 = 58451 | XEvent.Severity.Warning,
            XSTATSFD_RESET_CHECK_FAILED = 58452 | XEvent.Severity.Warning,
            STATS_HACK_53 = 58453 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_41 = 58454 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_42 = 58455 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_43 = 58456 | XEvent.Severity.Warning,
            STATS_HACK_57 = 58457 | XEvent.Severity.Warning,
            STATS_HACK_58 = 58458 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_44 = 58459 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_45 = 58460 | XEvent.Severity.Warning,
            STATS_HACK_61 = 58461 | XEvent.Severity.Warning,
            STATS_HACK_62 = 58462 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_46 = 58463 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_47 = 58464 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_48 = 58465 | XEvent.Severity.Warning,
            STATS_HACK_66 = 58466 | XEvent.Severity.Warning,
            STATS_HACK_67 = 58467 | XEvent.Severity.Warning,
            STATS_HACK_68 = 58468 | XEvent.Severity.Warning,
            STATS_HACK_69 = 58469 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_49 = 58470 | XEvent.Severity.Warning,
            STATS_HACK_71 = 58471 | XEvent.Severity.Warning,
            STATS_HACK_72 = 58472 | XEvent.Severity.Warning,
            STATS_HACK_73 = 58473 | XEvent.Severity.Warning,
            STATS_HACK_74 = 58474 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_50 = 58475 | XEvent.Severity.Warning,
            STATS_HACK_76 = 58476 | XEvent.Severity.Warning,
            STATS_HACK_77 = 58477 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_51 = 58478 | XEvent.Severity.Warning,
            STATS_HACK_79 = 58479 | XEvent.Severity.Warning,
            STATS_HACK_80 = 58480 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_52 = 58481 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_53 = 58482 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_54 = 58483 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_55 = 58484 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_56 = 58485 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_57 = 58486 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_58 = 58487 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_59 = 58488 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_60 = 58489 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_61 = 58490 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_62 = 58491 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_63 = 58492 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_64 = 58493 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_65 = 58494 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_66 = 58495 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_67 = 58496 | XEvent.Severity.Warning,
            STATS_HACK_97 = 58497 | XEvent.Severity.Warning,
            STATS_HACK_98 = 58498 | XEvent.Severity.Warning,
            STATS_HACK_99 = 58499 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_68 = 58500 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_69 = 58501 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_70 = 58502 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_71 = 58503 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_72 = 58504 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_73 = 58505 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_74 = 58506 | XEvent.Severity.Warning,
            STATS_HACK_100 = 58507 | XEvent.Severity.Warning,
            STATS_HACK_101 = 58508 | XEvent.Severity.Warning,
            STATS_HACK_102 = 58509 | XEvent.Severity.Warning,
            STATS_MUSIGMA_ARITHMETIC_NAN_1 = 58510 | XEvent.Severity.Warning,
            STATS_MUSIGMA_ARITHMETIC_NAN_2 = 58511 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_75 = 58512 | XEvent.Severity.Warning,
            XSTATSFD_MUSIGMA_NOT_GAME_MODE_1 = 58513 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_76 = 58514 | XEvent.Severity.Warning,
            XSTATSFD_INVALID_REQUEST_77 = 58515 | XEvent.Severity.Warning,
            XSTATSFD_ESTIMATE_RANK_ERROR_1 = 58516 | XEvent.Severity.Warning,
            XSTATSFD_ESTIMATE_RANK_ERROR_2 = 58517 | XEvent.Severity.Warning,
            XSTATSFD_STATDB_INVALID_ATTACHMENT_SIZE_1 = 58518 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_RETRIEVE_STAT = 58519 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_READ = 58520 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_GETNEXTROW = 58521 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_STATS_UPDATE = 58522 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_STATS_REMOVE = 58523 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_LOAD_STATS = 58524 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_CALL_REMOVE_LB = 58525 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_GET_PHYSICAL_PARTITION_COUNT = 58526 | XEvent.Severity.Warning,
            LB_WS_INTEROP_UNABLE_TO_GET_LOGICAL_PARTITION_COUNT = 58527 | XEvent.Severity.Warning,
            STATS_INFO_0 = 58800 | XEvent.Severity.Info,
            STATS_INFO_1 = 58801 | XEvent.Severity.Info,
            STATS_INFO_2 = 58802 | XEvent.Severity.Info,
            STATS_INFO_3 = 58803 | XEvent.Severity.Info,
            STATS_INFO_4 = 58804 | XEvent.Severity.Info,
            STATS_INFO_5 = 58805 | XEvent.Severity.Info,
            STATS_INFO_6 = 58806 | XEvent.Severity.Info,
            STATS_INFO_7 = 58807 | XEvent.Severity.Info,
            STATS_INFO_8 = 58808 | XEvent.Severity.Info,
            STATS_INFO_9 = 58809 | XEvent.Severity.Info,
            STATS_INFO_10 = 58810 | XEvent.Severity.Info,
            STATS_INFO_11 = 58811 | XEvent.Severity.Info,
            STATS_INFO_12 = 58812 | XEvent.Severity.Info,
            STATS_INFO_13 = 58813 | XEvent.Severity.Info,
            STATS_INFO_14 = 58814 | XEvent.Severity.Info,
            STATS_INFO_15 = 58815 | XEvent.Severity.Info,
            STATS_INFO_16 = 58816 | XEvent.Severity.Info,
            STATS_INFO_17 = 58817 | XEvent.Severity.Info,
            STATS_INFO_18 = 58818 | XEvent.Severity.Info,
            STATS_INFO_19 = 58819 | XEvent.Severity.Info,
            STATS_INFO_20 = 58820 | XEvent.Severity.Info,
            STATS_INFO_21 = 58821 | XEvent.Severity.Info,
            STATS_INFO_22 = 58822 | XEvent.Severity.Info,
            STATS_INFO_23 = 58823 | XEvent.Severity.Info,
            STATS_INFO_24 = 58824 | XEvent.Severity.Info,
            STATS_INFO_25 = 58825 | XEvent.Severity.Info,
            STATS_INFO_26 = 58826 | XEvent.Severity.Info,
            LBSVR_LOAD_SUCCESS_INFO_1 = 58827 | XEvent.Severity.Info,
            LBSVR_DB_LOAD_NUM_RETRY_SETTING = 58828 | XEvent.Severity.Info,
            LBSVR_DB_LOAD_INTERVAL_SECONDS_SETTING = 58829 | XEvent.Severity.Info,
            XSTATSFD_FORBIDDEN_CERT_REQUEST = 58900 | XEvent.Severity.Error,
            XSTATSFD_BAD_PARTIAL_PLAY = 58901 | XEvent.Severity.Error,
            XSTATSFD_BAD_SKILL_LEARNING_FACTOR = 58902 | XEvent.Severity.Error,
            XSTATSFD_BAD_BETA_OVERRIDE = 58903 | XEvent.Severity.Error,
            XSTATSFD_BAD_TAU_OVERRIDE = 58904 | XEvent.Severity.Error,
            XSTATSFD_BAD_DRAW_PROBABILITY_OVERRIDE = 58905 | XEvent.Severity.Error,
            STFD_PATHNAME_BROKEN_LINK_REPORT = 58975 | XEvent.Severity.Error,
            STFD_PATHNAME_UNKNOWN_DOMAIN = 58976 | XEvent.Severity.Error,
            STFD_MISSING_OR_BAD_CONFIG_2 = 58977 | XEvent.Severity.Error,
            STFD_MISSING_OR_BAD_CONFIG_3 = 58979 | XEvent.Severity.Error,
            STFD_SECURITY_ERROR = 59003 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_1 = 59009 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_2 = 59010 | XEvent.Severity.Warning,
            STFD_INVALID_REQUEST = 59016 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_3 = 59018 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_4 = 59020 | XEvent.Severity.Warning,
            STFD_INVALID_REQUEST_1 = 59022 | XEvent.Severity.Warning,
            STFD_INVALID_REQUEST_2 = 59028 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_5 = 59030 | XEvent.Severity.Warning,
            STFD_SECURITY_ERROR_6 = 59032 | XEvent.Severity.Warning,
            STFD_INVALID_REQUEST_3 = 59033 | XEvent.Severity.Warning,
            STFD_FILE_TOO_BIG = 59100 | XEvent.Severity.Error,
            STFD_FILE_TOO_BIG_1 = 59101 | XEvent.Severity.Error,
            STFD_READTITLEFILES_ERROR = 15000 | XEvent.Severity.Error,
            STORAGE_CODE_0 = 58925 | XEvent.Severity.Error,
            STORAGE_CODE_1 = 58926 | XEvent.Severity.Error,
            STORAGE_CODE_2 = 58927 | XEvent.Severity.Error,
            STORAGE_CODE_3 = 58928 | XEvent.Severity.Error,
            STORAGE_CODE_4 = 58929 | XEvent.Severity.Error,
            STORAGE_CODE_5 = 58930 | XEvent.Severity.Error,
            STORAGE_CODE_6 = 58931 | XEvent.Severity.Error,
            STORAGE_CODE_7 = 58932 | XEvent.Severity.Error,
            STORAGE_CODE_8 = 58933 | XEvent.Severity.Error,
            STORAGE_CODE_9 = 58934 | XEvent.Severity.Error,
            STORAGE_CODE_10 = 58935 | XEvent.Severity.Error,
            STORAGE_CODE_11 = 58936 | XEvent.Severity.Error,
            STORAGE_CODE_12 = 58937 | XEvent.Severity.Error,
            STORAGE_CODE_13 = 58938 | XEvent.Severity.Error,
            STORAGE_CODE_14 = 58939 | XEvent.Severity.Error,
            STORAGE_COMM_0 = 58950 | XEvent.Severity.Error,
            STORAGE_DEFAULT_EVENT = 58951 | XEvent.Severity.Error,
            STORAGE_CONFIG_3 = 58978 | XEvent.Severity.Error,
            STORAGE_INVALID_PATH = 58980 | XEvent.Severity.Warning,
            STORAGE_INVALID_INPUT = 58981 | XEvent.Severity.Warning,
            STORAGE_HACK_0 = 59000 | XEvent.Severity.Warning,
            STORAGE_HACK_1 = 59001 | XEvent.Severity.Warning,
            STORAGE_HACK_2 = 59002 | XEvent.Severity.Warning,
            STORAGE_HACK_4 = 59004 | XEvent.Severity.Warning,
            STORAGE_HACK_5 = 59005 | XEvent.Severity.Warning,
            STORAGE_HACK_6 = 59006 | XEvent.Severity.Warning,
            STORAGE_HACK_7 = 59007 | XEvent.Severity.Warning,
            STORAGE_HACK_8 = 59008 | XEvent.Severity.Warning,
            STORAGE_HACK_11 = 59011 | XEvent.Severity.Warning,
            STORAGE_HACK_12 = 59012 | XEvent.Severity.Warning,
            STORAGE_HACK_13 = 59013 | XEvent.Severity.Warning,
            STORAGE_HACK_14 = 59014 | XEvent.Severity.Warning,
            STORAGE_HACK_15 = 59015 | XEvent.Severity.Warning,
            STORAGE_HACK_17 = 59017 | XEvent.Severity.Warning,
            STORAGE_HACK_19 = 59019 | XEvent.Severity.Warning,
            STORAGE_HACK_21 = 59021 | XEvent.Severity.Warning,
            AUTHDATA_CALL_SOURCE_CHECK = 59023 | XEvent.Severity.Warning,
            STORAGE_HACK_24 = 59024 | XEvent.Severity.Warning,
            STORAGE_HACK_25 = 59025 | XEvent.Severity.Warning,
            STORAGE_HACK_26 = 59026 | XEvent.Severity.Warning,
            STORAGE_HACK_27 = 59027 | XEvent.Severity.Warning,
            STORAGE_HACK_29 = 59029 | XEvent.Severity.Warning,
            STORAGE_HACK_31 = 59031 | XEvent.Severity.Warning,
            STORAGE_HACK_34 = 59034 | XEvent.Severity.Warning,
            STORAGE_MODULE_INVALID_CONFIGURATION = 59035 | XEvent.Severity.Error,
            STORAGE_MODULE_CONFIG_INFO = 59036 | XEvent.Severity.Info,
            STORAGE_MODULE_XBANC_ERROR = 59037 | XEvent.Severity.Error,
            STORAGE_MODULE_INTERNAL_ERROR = 59038 | XEvent.Severity.Error,
            LOGCOLLECTOR_MODULE_INVALID_CONFIGURATION = 15000 | XEvent.Severity.Error,
            LOGCOLLECTOR_MODULE_CONFIG_INFO = 15001 | XEvent.Severity.Info,
            LOGCOLLECTOR_MODULE_INTERNAL_ERROR = 15002 | XEvent.Severity.Error,
            LOGCOLLECTOR_DEFAULT_EVENT = 15003 | XEvent.Severity.Error,
            STRINGSVR_CODE_0 = 59125 | XEvent.Severity.Error,
            STRINGSVR_CODE_1 = 59126 | XEvent.Severity.Error,
            STRINGSVR_CODE_2 = 59127 | XEvent.Severity.Error,
            STRINGSVR_CODE_3 = 59128 | XEvent.Severity.Error,
            STRINGSVR_INVALID_MEASUREMENT_LINE = 59129 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_0 = 59150 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_1 = 59151 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_2 = 59152 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_3 = 59153 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_PREFIX_LINE_MISSING_PREFIX = 59154 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_PREFIX_LINE_MISSING_TYPE = 59155 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_PREFIX_LINE_INVALID = 59156 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_PREFIX_LINE_BAD_THRESHOLD = 59157 | XEvent.Severity.Error,
            STRINGSVR_CONFIG_DUPLICATE_PREFIX = 59158 | XEvent.Severity.Error,
            STRINGSVR_HACK_0 = 59175 | XEvent.Severity.Warning,
            STRINGSVR_HACK_1 = 59176 | XEvent.Severity.Warning,
            STRINGSVR_HACK_2 = 59177 | XEvent.Severity.Warning,
            STRINGSVR_HACK_3 = 59178 | XEvent.Severity.Warning,
            LOGCOLLECTOR_MODULE_URL_PROCESSING_FAILED = 59179 | XEvent.Severity.Error,
            SUPPORT_GETXMLFROMXNAME_GENERIC_FAILURE = 40000 | XEvent.Severity.Error,
            SUPPORT_GETXMLFROMXNAME_XNAME_FAILURE = 40001 | XEvent.Severity.Error,
            SUPPORT_GETXMLFROMXNAME_USER_LOAD_FAILURE = 40002 | XEvent.Severity.Error,
            SUPPORT_GETXMLFROMXNAME_WRITE_XML_FAILURE = 40003 | XEvent.Severity.Error,
            XSUPPAPI_EXCEPTION = 59200 | XEvent.Severity.Error,
            SUPPORT_CODE_1 = 59201 | XEvent.Severity.Error,
            SUPPORT_CODE_2 = 59202 | XEvent.Severity.Error,
            SUPPORT_CODE_3 = 59203 | XEvent.Severity.Error,
            SUPPORT_CODE_4 = 59204 | XEvent.Severity.Error,
            SUPPORT_CODE_5 = 59205 | XEvent.Severity.Error,
            SUPPORT_CODE_6 = 59206 | XEvent.Severity.Error,
            SUPPORT_CODE_7 = 59207 | XEvent.Severity.Error,
            SUPPORT_CODE_8 = 59208 | XEvent.Severity.Error,
            SUPPORT_CODE_9 = 59209 | XEvent.Severity.Error,
            SUPPORT_CODE_10 = 59210 | XEvent.Severity.Error,
            SUPPORT_CODE_11 = 59211 | XEvent.Severity.Error,
            SUPPORT_CODE_12 = 59212 | XEvent.Severity.Error,
            SUPPORT_CODE_13 = 59213 | XEvent.Severity.Error,
            SUPPORT_CODE_14 = 59214 | XEvent.Severity.Error,
            SUPPORT_CODE_15 = 59215 | XEvent.Severity.Error,
            SUPPORT_INCREMENT_MAXIMUM_LICENSE_COUNT_FAILURE = 59216 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_0 = 59250 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_1 = 59251 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_2 = 59252 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_3 = 59253 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_4 = 59254 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_5 = 59255 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_6 = 59256 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_7 = 59257 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_8 = 59258 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_9 = 59259 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_10 = 59260 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_11 = 59261 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_12 = 59262 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_13 = 59263 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_14 = 59264 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_15 = 59265 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_16 = 59266 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_17 = 59267 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_18 = 59268 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_19 = 59269 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_20 = 59270 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_21 = 59271 | XEvent.Severity.Error,
            SVCTUNNEL_CODE_22 = 59272 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_0 = 59275 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_1 = 59276 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_2 = 59277 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_3 = 59278 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_4 = 59279 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_5 = 59280 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_6 = 59281 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_7 = 59282 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_8 = 59283 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_9 = 59284 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_10 = 59285 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_11 = 59286 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_12 = 59287 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_13 = 59288 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_14 = 59289 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_15 = 59290 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_16 = 59291 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_17 = 59292 | XEvent.Severity.Error,
            SVCTUNNEL_COMM_18 = 59293 | XEvent.Severity.Error,
            SVCTUNNEL_INFO_0 = 59325 | XEvent.Severity.Info,
            SVCTUNNEL_INFO_1 = 59326 | XEvent.Severity.Info,
            SVCTUNNEL_PARTNER_0 = 59350 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_1 = 59351 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_2 = 59352 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_3 = 59353 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_4 = 59354 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_5 = 59355 | XEvent.Severity.Error,
            SVCTUNNEL_PARTNER_6 = 59356 | XEvent.Severity.Error,
            TAG_RECYCLE_JOB_ERROR = 35001 | XEvent.Severity.Error,
            XP_WARN_GEN = 59375 | XEvent.Severity.Error,
            XP_WARN_GEN_1 = 59376 | XEvent.Severity.Error,
            XP_WARN_GEN_2 = 59377 | XEvent.Severity.Error,
            XP_WARN_GEN_3 = 59378 | XEvent.Severity.Error,
            TEST_CODE_4 = 59379 | XEvent.Severity.Error,
            TEST_COMM_0 = 59575 | XEvent.Severity.Error,
            TEST_COMM_1 = 59576 | XEvent.Severity.Error,
            TEST_COMM_2 = 59577 | XEvent.Severity.Error,
            TEST_COMM_3 = 59578 | XEvent.Severity.Error,
            TEST_COMM_4 = 59579 | XEvent.Severity.Error,
            TEST_COMM_5 = 59580 | XEvent.Severity.Error,
            TEST_COMM_6 = 59581 | XEvent.Severity.Error,
            TEST_COMM_7 = 59582 | XEvent.Severity.Error,
            TEST_COMM_8 = 59583 | XEvent.Severity.Error,
            TEST_COMM_9 = 59584 | XEvent.Severity.Error,
            TEST_COMM_10 = 59585 | XEvent.Severity.Error,
            TEST_COMM_11 = 59586 | XEvent.Severity.Error,
            TEST_COMM_12 = 59587 | XEvent.Severity.Error,
            TEST_COMM_13 = 59588 | XEvent.Severity.Error,
            TEST_COMM_14 = 59589 | XEvent.Severity.Error,
            TEST_COMM_15 = 59590 | XEvent.Severity.Error,
            TEST_COMM_16 = 59591 | XEvent.Severity.Error,
            TEST_COMM_17 = 59592 | XEvent.Severity.Error,
            TEST_COMM_18 = 59593 | XEvent.Severity.Error,
            TEST_COMM_19 = 59594 | XEvent.Severity.Error,
            TEST_COMM_20 = 59595 | XEvent.Severity.Error,
            TEST_COMM_21 = 59596 | XEvent.Severity.Error,
            TEST_COMM_22 = 59597 | XEvent.Severity.Error,
            TEST_COMM_23 = 59598 | XEvent.Severity.Error,
            TEST_COMM_24 = 59599 | XEvent.Severity.Error,
            TEST_COMM_25 = 59600 | XEvent.Severity.Error,
            TEST_COMM_26 = 59601 | XEvent.Severity.Error,
            TEST_COMM_27 = 59602 | XEvent.Severity.Error,
            TEST_COMM_28 = 59603 | XEvent.Severity.Error,
            TEST_COMM_29 = 59604 | XEvent.Severity.Error,
            TEST_COMM_30 = 59605 | XEvent.Severity.Error,
            TEST_COMM_31 = 59606 | XEvent.Severity.Error,
            TEST_COMM_32 = 59607 | XEvent.Severity.Error,
            TEST_COMM_33 = 59608 | XEvent.Severity.Error,
            TEST_COMM_34 = 59609 | XEvent.Severity.Error,
            TEST_COMM_35 = 59610 | XEvent.Severity.Error,
            TEST_COMM_36 = 59611 | XEvent.Severity.Error,
            TEST_COMM_37 = 59612 | XEvent.Severity.Error,
            TEST_COMM_38 = 59613 | XEvent.Severity.Error,
            TEST_COMM_39 = 59614 | XEvent.Severity.Error,
            TEST_COMM_40 = 59615 | XEvent.Severity.Error,
            TEST_COMM_41 = 59616 | XEvent.Severity.Error,
            TEST_COMM_42 = 59617 | XEvent.Severity.Error,
            TEST_COMM_43 = 59618 | XEvent.Severity.Error,
            TEST_COMM_44 = 59619 | XEvent.Severity.Error,
            TEST_COMM_45 = 59620 | XEvent.Severity.Error,
            TEST_COMM_46 = 59621 | XEvent.Severity.Error,
            TEST_CONFIG_3 = 59678 | XEvent.Severity.Warning,
            TEST_CONFIG_4 = 59679 | XEvent.Severity.Error,
            TEST_CONFIG_5 = 59680 | XEvent.Severity.Error,
            TEST_CONFIG_6 = 59681 | XEvent.Severity.Error,
            TEST_CONFIG_7 = 59682 | XEvent.Severity.Error,
            TEST_CONFIG_8 = 59683 | XEvent.Severity.Error,
            TEST_CONFIG_9 = 59684 | XEvent.Severity.Error,
            TEST_CONFIG_10 = 59685 | XEvent.Severity.Error,
            TEST_CONFIG_11 = 59686 | XEvent.Severity.Error,
            TEST_CONFIG_12 = 59687 | XEvent.Severity.Error,
            TEST_CONFIG_13 = 59688 | XEvent.Severity.Error,
            TEST_CONFIG_14 = 59689 | XEvent.Severity.Error,
            TEST_CONFIG_15 = 59690 | XEvent.Severity.Error,
            TEST_CONFIG_16 = 59691 | XEvent.Severity.Error,
            TEST_CONFIG_17 = 59692 | XEvent.Severity.Error,
            TEST_CONFIG_18 = 59693 | XEvent.Severity.Error,
            TEST_CONFIG_19 = 59694 | XEvent.Severity.Error,
            TEST_CONFIG_20 = 59695 | XEvent.Severity.Error,
            TEST_CONFIG_21 = 59696 | XEvent.Severity.Error,
            TEST_CONFIG_22 = 59697 | XEvent.Severity.Error,
            TEST_CONFIG_23 = 59698 | XEvent.Severity.Error,
            TEST_CONFIG_24 = 59699 | XEvent.Severity.Error,
            TEST_CONFIG_25 = 59700 | XEvent.Severity.Error,
            TEST_CONFIG_26 = 59701 | XEvent.Severity.Error,
            TEST_CONFIG_27 = 59702 | XEvent.Severity.Warning,
            TEST_CONFIG_28 = 59703 | XEvent.Severity.Error,
            TEST_CONFIG_29 = 59704 | XEvent.Severity.Error,
            TEST_CONFIG_30 = 59705 | XEvent.Severity.Error,
            TEST_CONFIG_31 = 59706 | XEvent.Severity.Error,
            TEST_CONFIG_32 = 59707 | XEvent.Severity.Error,
            TEST_CONFIG_33 = 59708 | XEvent.Severity.Error,
            TEST_CONFIG_34 = 59709 | XEvent.Severity.Error,
            TEST_CONFIG_35 = 59710 | XEvent.Severity.Error,
            TEST_CONFIG_36 = 59711 | XEvent.Severity.Error,
            TEST_CONFIG_37 = 59712 | XEvent.Severity.Error,
            TEST_CONFIG_38 = 59713 | XEvent.Severity.Error,
            TEST_CONFIG_39 = 59714 | XEvent.Severity.Error,
            TEST_CONFIG_40 = 59715 | XEvent.Severity.Error,
            TEST_CONFIG_41 = 59716 | XEvent.Severity.Error,
            TEST_CONFIG_42 = 59717 | XEvent.Severity.Error,
            TEST_CONFIG_43 = 59718 | XEvent.Severity.Error,
            TEST_CONFIG_44 = 59719 | XEvent.Severity.Error,
            TEST_CONFIG_45 = 59720 | XEvent.Severity.Error,
            TEST_CONFIG_46 = 59721 | XEvent.Severity.Error,
            TEST_CONFIG_47 = 59722 | XEvent.Severity.Error,
            TEST_CONFIG_48 = 59723 | XEvent.Severity.Error,
            TEST_CONFIG_49 = 59724 | XEvent.Severity.Error,
            TEST_CONFIG_50 = 59725 | XEvent.Severity.Error,
            TEST_CONFIG_51 = 59726 | XEvent.Severity.Error,
            TEST_CONFIG_52 = 59727 | XEvent.Severity.Error,
            TEST_CONFIG_53 = 59728 | XEvent.Severity.Error,
            TEST_CONFIG_54 = 59729 | XEvent.Severity.Error,
            TEST_CONFIG_55 = 59730 | XEvent.Severity.Error,
            TEST_CONFIG_56 = 59731 | XEvent.Severity.Error,
            TEST_CONFIG_57 = 59732 | XEvent.Severity.Error,
            TEST_CONFIG_58 = 59733 | XEvent.Severity.Error,
            TEST_CONFIG_59 = 59734 | XEvent.Severity.Error,
            TEST_CONFIG_60 = 59735 | XEvent.Severity.Warning,
            TEST_CONFIG_61 = 59736 | XEvent.Severity.Error,
            TEST_CONFIG_62 = 59737 | XEvent.Severity.Error,
            TEST_CONFIG_63 = 59738 | XEvent.Severity.Error,
            TEST_CONFIG_64 = 59739 | XEvent.Severity.Error,
            TEST_CONFIG_65 = 59740 | XEvent.Severity.Error,
            TEST_CONFIG_66 = 59741 | XEvent.Severity.Error,
            TEST_CONFIG_67 = 59742 | XEvent.Severity.Error,
            TEST_CONFIG_68 = 59743 | XEvent.Severity.Error,
            TEST_CONFIG_69 = 59744 | XEvent.Severity.Error,
            TEST_CONFIG_70 = 59745 | XEvent.Severity.Error,
            TEST_CONFIG_71 = 59746 | XEvent.Severity.Error,
            TEST_CONFIG_72 = 59747 | XEvent.Severity.Error,
            TEST_CONFIG_73 = 59748 | XEvent.Severity.Error,
            TEST_CONFIG_74 = 59749 | XEvent.Severity.Error,
            TEST_CONFIG_75 = 59750 | XEvent.Severity.Error,
            TEST_CONFIG_76 = 59751 | XEvent.Severity.Error,
            TEST_CONFIG_77 = 59752 | XEvent.Severity.Error,
            TEST_CONFIG_78 = 59753 | XEvent.Severity.Error,
            TEST_CONFIG_79 = 59754 | XEvent.Severity.Error,
            TEST_CONFIG_80 = 59755 | XEvent.Severity.Error,
            TEST_CONFIG_81 = 59756 | XEvent.Severity.Error,
            TEST_CONFIG_82 = 59757 | XEvent.Severity.Error,
            TEST_CONFIG_83 = 59758 | XEvent.Severity.Warning,
            TEST_CONFIG_84 = 59759 | XEvent.Severity.Warning,
            TEST_CONFIG_85 = 59760 | XEvent.Severity.Error,
            TEST_CONFIG_86 = 59761 | XEvent.Severity.Error,
            TEST_CONFIG_87 = 59762 | XEvent.Severity.Error,
            TEST_CONFIG_88 = 59763 | XEvent.Severity.Error,
            TEST_CONFIG_89 = 59764 | XEvent.Severity.Error,
            TEST_CONFIG_90 = 59765 | XEvent.Severity.Error,
            TEST_CONFIG_91 = 59766 | XEvent.Severity.Error,
            TEST_CONFIG_92 = 59767 | XEvent.Severity.Error,
            TEST_CONFIG_93 = 59768 | XEvent.Severity.Error,
            TEST_CONFIG_94 = 59769 | XEvent.Severity.Error,
            TEST_CONFIG_95 = 59770 | XEvent.Severity.Error,
            TEST_CONFIG_96 = 59771 | XEvent.Severity.Error,
            TEST_CONFIG_97 = 59772 | XEvent.Severity.Error,
            TEST_CONFIG_98 = 59773 | XEvent.Severity.Error,
            TEST_CONFIG_99 = 59774 | XEvent.Severity.Error,
            TEST_CONFIG_100 = 59775 | XEvent.Severity.Warning,
            TEST_CONFIG_101 = 59776 | XEvent.Severity.Error,
            TEST_CONFIG_102 = 59777 | XEvent.Severity.Error,
            TEST_CONFIG_103 = 59778 | XEvent.Severity.Error,
            TEST_CONFIG_104 = 59779 | XEvent.Severity.Error,
            TEST_CONFIG_105 = 59780 | XEvent.Severity.Error,
            TEST_CONFIG_106 = 59781 | XEvent.Severity.Error,
            TEST_CONFIG_107 = 59782 | XEvent.Severity.Error,
            TEST_CONFIG_108 = 59783 | XEvent.Severity.Warning,
            TEST_CONFIG_109 = 59784 | XEvent.Severity.Error,
            TEST_CONFIG_110 = 59785 | XEvent.Severity.Error,
            TEST_CONFIG_111 = 59786 | XEvent.Severity.Error,
            TEST_CONFIG_112 = 59787 | XEvent.Severity.Error,
            TEST_CONFIG_113 = 59788 | XEvent.Severity.Warning,
            TEST_CONFIG_114 = 59789 | XEvent.Severity.Warning,
            TEST_CONFIG_115 = 59790 | XEvent.Severity.Error,
            TEST_CONFIG_116 = 59791 | XEvent.Severity.Error,
            TEST_CONFIG_117 = 59792 | XEvent.Severity.Error,
            TEST_CONFIG_118 = 59793 | XEvent.Severity.Error,
            TEST_CONFIG_119 = 59794 | XEvent.Severity.Error,
            TEST_CONFIG_120 = 59795 | XEvent.Severity.Error,
            TEST_CONFIG_121 = 59796 | XEvent.Severity.Error,
            TEST_CONFIG_122 = 59797 | XEvent.Severity.Error,
            TEST_CONFIG_123 = 59798 | XEvent.Severity.Error,
            TEST_CONFIG_124 = 59799 | XEvent.Severity.Error,
            TEST_CONFIG_125 = 59800 | XEvent.Severity.Error,
            TEST_CONFIG_126 = 59801 | XEvent.Severity.Error,
            TEST_CONFIG_127 = 59802 | XEvent.Severity.Error,
            TEST_CONFIG_128 = 59803 | XEvent.Severity.Error,
            TEST_CONFIG_129 = 59804 | XEvent.Severity.Error,
            TEST_CONFIG_130 = 59805 | XEvent.Severity.Error,
            TEST_CONFIG_131 = 59806 | XEvent.Severity.Error,
            TEST_CONFIG_132 = 59807 | XEvent.Severity.Error,
            TEST_CONFIG_133 = 59808 | XEvent.Severity.Error,
            TEST_CONFIG_134 = 59809 | XEvent.Severity.Error,
            TEST_CONFIG_135 = 59810 | XEvent.Severity.Error,
            TEST_CONFIG_136 = 59811 | XEvent.Severity.Error,
            TEST_CONFIG_137 = 59812 | XEvent.Severity.Error,
            TEST_CONFIG_138 = 59813 | XEvent.Severity.Error,
            TEST_CONFIG_139 = 59814 | XEvent.Severity.Error,
            TEST_CONFIG_140 = 59815 | XEvent.Severity.Error,
            TEST_CONFIG_141 = 59816 | XEvent.Severity.Error,
            TEST_CONFIG_142 = 59817 | XEvent.Severity.Error,
            TEST_CONFIG_143 = 59818 | XEvent.Severity.Error,
            TEST_CONFIG_144 = 59819 | XEvent.Severity.Error,
            TEST_CONFIG_145 = 59820 | XEvent.Severity.Error,
            TEST_CONFIG_146 = 59821 | XEvent.Severity.Error,
            TEST_CONFIG_147 = 59822 | XEvent.Severity.Error,
            TEST_CONFIG_148 = 59823 | XEvent.Severity.Error,
            TEST_CONFIG_149 = 59824 | XEvent.Severity.Error,
            TEST_CONFIG_150 = 59825 | XEvent.Severity.Warning,
            TEST_CONFIG_151 = 59826 | XEvent.Severity.Error,
            TEST_CONFIG_152 = 59827 | XEvent.Severity.Error,
            TEST_CONFIG_153 = 59828 | XEvent.Severity.Error,
            TEST_CONFIG_154 = 59829 | XEvent.Severity.Error,
            TEST_CONFIG_155 = 59830 | XEvent.Severity.Error,
            TEST_CONFIG_156 = 59831 | XEvent.Severity.Error,
            TEST_CONFIG_157 = 59832 | XEvent.Severity.Warning,
            TEST_CONFIG_158 = 59833 | XEvent.Severity.Error,
            TEST_CONFIG_159 = 59834 | XEvent.Severity.Error,
            TEST_CONFIG_160 = 59835 | XEvent.Severity.Error,
            TEST_CONFIG_161 = 59836 | XEvent.Severity.Error,
            TEST_CONFIG_162 = 59837 | XEvent.Severity.Warning,
            XSTORAGE_SESSION_INSERT_FAILED = 59840 | XEvent.Severity.Error,
            XSTORAGE_SESSION_UPDATE_FAILED = 59841 | XEvent.Severity.Error,
            XSTORAGE_SESSION_DELETE_FAILED = 59842 | XEvent.Severity.Error,
            TEST_HACK_0 = 60075 | XEvent.Severity.Warning,
            TEST_HACK_1 = 60076 | XEvent.Severity.Warning,
            TEST_HACK_2 = 60077 | XEvent.Severity.Warning,
            TEST_HACK_3 = 60078 | XEvent.Severity.Warning,
            TEST_HACK_4 = 60079 | XEvent.Severity.Warning,
            TEST_HACK_5 = 60080 | XEvent.Severity.Warning,
            TEST_HACK_6 = 60081 | XEvent.Severity.Warning,
            TEST_HACK_7 = 60082 | XEvent.Severity.Warning,
            TEST_HACK_8 = 60083 | XEvent.Severity.Warning,
            TEST_INFO_0 = 60100 | XEvent.Severity.Info,
            TEST_INFO_1 = 60101 | XEvent.Severity.Info,
            TEST_INFO_2 = 60102 | XEvent.Severity.Info,
            TEST_INFO_3 = 60103 | XEvent.Severity.Info,
            TEST_INFO_4 = 60104 | XEvent.Severity.Info,
            TEST_INFO_5 = 60105 | XEvent.Severity.Info,
            TEST_INFO_6 = 60106 | XEvent.Severity.Info,
            TEST_INFO_7 = 60107 | XEvent.Severity.Info,
            TEST_INFO_8 = 60108 | XEvent.Severity.Info,
            TEST_INFO_9 = 60109 | XEvent.Severity.Info,
            TEST_INFO_10 = 60110 | XEvent.Severity.Info,
            TEST_INFO_11 = 60111 | XEvent.Severity.Info,
            TEST_INFO_12 = 60112 | XEvent.Severity.Info,
            TEST_INFO_13 = 60113 | XEvent.Severity.Info,
            TEST_INFO_14 = 60114 | XEvent.Severity.Info,
            TEST_INFO_15 = 60115 | XEvent.Severity.Info,
            TEST_INFO_16 = 60116 | XEvent.Severity.Info,
            TEST_INFO_17 = 60117 | XEvent.Severity.Info,
            TEST_INFO_18 = 60118 | XEvent.Severity.Info,
            TEST_INFO_19 = 60119 | XEvent.Severity.Info,
            TEST_INFO_20 = 60120 | XEvent.Severity.Info,
            TEST_INFO_21 = 60121 | XEvent.Severity.Info,
            TEST_INFO_22 = 60122 | XEvent.Severity.Info,
            TEST_INFO_23 = 60123 | XEvent.Severity.Info,
            TEST_INFO_24 = 60124 | XEvent.Severity.Info,
            TEST_INFO_25 = 60125 | XEvent.Severity.Info,
            TEST_INFO_26 = 60126 | XEvent.Severity.Info,
            TEST_INFO_27 = 60127 | XEvent.Severity.Info,
            TEST_INFO_28 = 60128 | XEvent.Severity.Info,
            TEST_INFO_29 = 60129 | XEvent.Severity.Info,
            TEST_INFO_30 = 60130 | XEvent.Severity.Info,
            TEST_INFO_31 = 60131 | XEvent.Severity.Info,
            TEST_INFO_32 = 60132 | XEvent.Severity.Info,
            TEST_INFO_33 = 60133 | XEvent.Severity.Info,
            TEST_INFO_34 = 60134 | XEvent.Severity.Info,
            TEST_INFO_35 = 60135 | XEvent.Severity.Info,
            TOKEN_GENERATION_INVALID_CRON_JOB_PARAMETER = 10001 | XEvent.Severity.Error,
            TOKEN_GENERATION_CRON_JOB_FAILED = 10002 | XEvent.Severity.Error,
            TOKEN_GENERATION_RECORD_TOKEN_JOB_FAILURE_FAILED = 10003 | XEvent.Severity.Error,
            TOKEN_GENERATION_TOKENDB_ADD_TOKENS_FAILED = 10004 | XEvent.Severity.Error,
            TOKEN_GENERATION_GET_SEQUENCE_NUMBER_FOR_PKPN_FAILURE = 10005 | XEvent.Severity.Error,
            TOKEN_KEY_ENCRYPTION_KEY_LOAD_FAILURE = 10006 | XEvent.Severity.Error,
            TOKEN_NOT_YET_REDEEMABLE = 10007 | XEvent.Severity.Error,
            TOKEN_LOAD_SCS_UNKNOWN_ERROR = 10008 | XEvent.Severity.Error,
            LIVEMATCH_DRAINRR_FAILED_MIGRATION_UNDERWAY = 40000 | XEvent.Severity.Error,
            LIVEMATCH_DRAINRR_FAILED_NO_ELIGIBLE_BUCKETS = 40001 | XEvent.Severity.Error,
            LIVEMATCH_DRAINRR_FAILED_NO_BUCKETS_FOUND = 40002 | XEvent.Severity.Error,
            LIVEMATCH_REMOVERR_FAILED_MIGRATION_UNDERWAY = 40003 | XEvent.Severity.Error,
            LIVEMATCH_REMOVERR_FAILED_NO_ELIGIBLE_BUCKETS = 40004 | XEvent.Severity.Error,
            LIVEMATCH_REMOVERR_FAILED_NO_BUCKETS_FOUND = 40005 | XEvent.Severity.Error,
            LIVEMATCH_REMOVERR_FAILED_NOT_DRAINING = 40006 | XEvent.Severity.Warning,
            FIXTRACES_OUTPUT_RANGE_CHECK = 50941 | XEvent.Severity.Error,
            COMMON_CODE_206 = 51031 | XEvent.Severity.Error,
            COMMON_CODE_207 = 51032 | XEvent.Severity.Error,
            TEST_CODE_5 = 59380 | XEvent.Severity.Error,
            TEST_CODE_6 = 59381 | XEvent.Severity.Error,
            TEST_CODE_7 = 59382 | XEvent.Severity.Error,
            TEST_CODE_8 = 59383 | XEvent.Severity.Error,
            TEST_CODE_9 = 59384 | XEvent.Severity.Error,
            TEST_CODE_10 = 59385 | XEvent.Severity.Error,
            TEST_CODE_11 = 59386 | XEvent.Severity.Error,
            TEST_CODE_12 = 59387 | XEvent.Severity.Error,
            TEST_CONFIG_0 = 59675 | XEvent.Severity.Warning,
            TEST_CONFIG_1 = 59676 | XEvent.Severity.Error,
            TEST_CONFIG_2 = 59677 | XEvent.Severity.Error,
            MGMT_INIT_WARNING_15 = 59838 | XEvent.Severity.Warning,
            MGMT_INIT_WARNING_16 = 59839 | XEvent.Severity.Warning,
            BATMAN_REQUIRED_FIX = 60200 | XEvent.Severity.Error,
            BATMAN_REQUIRED_FIX_1 = 60201 | XEvent.Severity.Error,
            TOOLS_CODE_2 = 60202 | XEvent.Severity.Error,
            TOOLS_CODE_3 = 60203 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY = 60204 | XEvent.Severity.Error,
            GENEALOGY_ERROR_CALL_SPROC = 60205 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_1 = 60206 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_2 = 60207 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_3 = 60208 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_4 = 60209 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_5 = 60210 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_6 = 60211 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_7 = 60212 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DESTROYING_KEY_HANDLE = 60213 | XEvent.Severity.Error,
            GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT = 60214 | XEvent.Severity.Error,
            GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT = 60215 | XEvent.Severity.Error,
            GENEALOGY_ERROR_GET_USER_KEY = 60216 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED = 60217 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_CLOSE_EEPROM_DAT_FILE = 60218 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED_1 = 60219 | XEvent.Severity.Error,
            GENEALOGY_ERROR_CALL_SPROC_1 = 60220 | XEvent.Severity.Error,
            GENEALOGY_ERROR_CALL_SPROC_2 = 60221 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_8 = 60222 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_9 = 60223 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_10 = 60224 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED = 60225 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_1 = 60226 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_2 = 60227 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_3 = 60228 | XEvent.Severity.Error,
            TOOLS_CODE_29 = 60229 | XEvent.Severity.Error,
            GENEALOGY_OUT_OF_MEMORY_11 = 60230 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_4 = 60231 | XEvent.Severity.Error,
            TOOLS_CODE_32 = 60232 | XEvent.Severity.Error,
            TOOLS_CODE_33 = 60233 | XEvent.Severity.Error,
            TOOLS_CODE_34 = 60234 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_5 = 60235 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_6 = 60236 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_7 = 60237 | XEvent.Severity.Error,
            GENEALOGY_SET_STATUS_FAILED_8 = 60238 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DESTROYING_KEY_HANDLE_1 = 60239 | XEvent.Severity.Error,
            GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT_1 = 60240 | XEvent.Severity.Error,
            GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT_1 = 60241 | XEvent.Severity.Error,
            GENEALOGY_ERROR_GET_USER_KEY_1 = 60242 | XEvent.Severity.Error,
            GENEALOGY_ERROR_FILE_READ = 60243 | XEvent.Severity.Error,
            TOOLS_CODE_44 = 60244 | XEvent.Severity.Error,
            TOOLS_CODE_45 = 60245 | XEvent.Severity.Error,
            MB_BAN_FAILED = 60246 | XEvent.Severity.Error,
            MB_UNBAN_FAILED = 60247 | XEvent.Severity.Error,
            TOOLS_CODE_48 = 60248 | XEvent.Severity.Error,
            PROXIMITY_W_GENERIC = 60249 | XEvent.Severity.Error,
            PROXIMITY_E_GENERIC = 60250 | XEvent.Severity.Error,
            PROXIMITY_E_ABORTED = 60251 | XEvent.Severity.Error,
            TOOLS_CODE_52 = 60252 | XEvent.Severity.Error,
            TOOLS_CODE_53 = 60253 | XEvent.Severity.Error,
            TOOLS_CODE_54 = 60254 | XEvent.Severity.Error,
            SPSPROXY_EXCEPTION = 60255 | XEvent.Severity.Error,
            SPUT_GENERAL_ERROR = 60256 | XEvent.Severity.Error,
            TITLEMGR_GENERAL_ERROR = 60257 | XEvent.Severity.Error,
            TOOLS_CODE_58 = 60258 | XEvent.Severity.Error,
            TOOLS_CODE_59 = 60259 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR = 60260 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_1 = 60261 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_2 = 60262 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_3 = 60263 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_4 = 60264 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING = 60265 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_1 = 60266 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_2 = 60267 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_3 = 60268 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_4 = 60269 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_5 = 60270 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_6 = 60271 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_7 = 60272 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_8 = 60273 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_9 = 60274 | XEvent.Severity.Error,
            KDC_BASE_NO_MEMORY_2 = 60275 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_5 = 60276 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_10 = 60277 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_11 = 60278 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_12 = 60279 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_13 = 60280 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_14 = 60281 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_15 = 60282 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_16 = 60283 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_17 = 60284 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_6 = 60285 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_7 = 60286 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_18 = 60287 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_19 = 60288 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_20 = 60289 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_21 = 60290 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_8 = 60291 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_9 = 60292 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_22 = 60293 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_23 = 60294 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_24 = 60295 | XEvent.Severity.Error,
            XWIRETAP_CAP_FILE_WRITE_FAILED = 60296 | XEvent.Severity.Error,
            XWIRETAP_CAP_FILE_WRITE_FAILED_1 = 60297 | XEvent.Severity.Error,
            XWIRETAP_CAP_FILE_WRITE_FAILED_2 = 60298 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_25 = 60299 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_10 = 60300 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_26 = 60301 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_27 = 60302 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL = 60303 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_28 = 60304 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_29 = 60305 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_1 = 60306 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_30 = 60307 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_31 = 60308 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_32 = 60309 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_33 = 60310 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_34 = 60311 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_2 = 60312 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_3 = 60313 | XEvent.Severity.Error,
            XWIRETAP_TERM_FAIL = 60314 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_35 = 60315 | XEvent.Severity.Error,
            XWIRETAP_TERM_FAIL_1 = 60316 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_11 = 60317 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_12 = 60318 | XEvent.Severity.Error,
            TOOLS_CODE_119 = 60319 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_4 = 60320 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_5 = 60321 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_36 = 60322 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_37 = 60323 | XEvent.Severity.Error,
            XWIRETAP_TAP_CLOSE_ERROR = 60324 | XEvent.Severity.Error,
            XWIRETAP_TAP_CLOSE_ERROR_1 = 60325 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_38 = 60326 | XEvent.Severity.Error,
            XWIRETAP_VLAN_ERROR = 60327 | XEvent.Severity.Error,
            XWIRETAP_TAP_CLOSE_ERROR_2 = 60328 | XEvent.Severity.Error,
            XWIRETAP_TAP_CLOSE_ERROR_3 = 60329 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_39 = 60330 | XEvent.Severity.Error,
            XWIRETAP_MEMORY_WARNING_40 = 60331 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_13 = 60332 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_14 = 60333 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_15 = 60334 | XEvent.Severity.Error,
            XWIRETAP_GENERIC_ERROR_16 = 60335 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_6 = 60336 | XEvent.Severity.Error,
            XWIRETAP_INIT_FAIL_7 = 60337 | XEvent.Severity.Error,
            TOOLS_CODE_138 = 60338 | XEvent.Severity.Error,
            TOOLS_CODE_139 = 60339 | XEvent.Severity.Error,
            TOOLS_CODE_140 = 60340 | XEvent.Severity.Error,
            TOOLS_CODE_141 = 60341 | XEvent.Severity.Error,
            TOOLS_CODE_142 = 60342 | XEvent.Severity.Error,
            TOOLS_CODE_143 = 60343 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR = 60344 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_1 = 60345 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_2 = 60346 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_3 = 60347 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_4 = 60348 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_5 = 60349 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_6 = 60350 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_7 = 60351 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_8 = 60352 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_9 = 60353 | XEvent.Severity.Error,
            UDPADPT_INIT_FAILURE = 60354 | XEvent.Severity.Error,
            UDPADPT_INIT_FAILURE_1 = 60355 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_10 = 60356 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_11 = 60357 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_12 = 60358 | XEvent.Severity.Error,
            UDPADPT_WINHTTP_ERROR = 60359 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_13 = 60360 | XEvent.Severity.Error,
            UDPADPT_UDPMGR_ERROR = 60361 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_14 = 60362 | XEvent.Severity.Error,
            UDPADPT_TERM_FAIL = 60363 | XEvent.Severity.Error,
            TOOLS_CODE_164 = 60364 | XEvent.Severity.Error,
            TOOLS_CODE_165 = 60365 | XEvent.Severity.Error,
            TOOLS_CODE_166 = 60366 | XEvent.Severity.Error,
            TOOLS_CODE_167 = 60367 | XEvent.Severity.Error,
            TOOLS_CODE_168 = 60368 | XEvent.Severity.Error,
            TOOLS_CODE_169 = 60369 | XEvent.Severity.Error,
            UDPADPT_GENERIC_ERROR_15 = 60370 | XEvent.Severity.Error,
            UDPADPT_INIT_FAILURE_2 = 60371 | XEvent.Severity.Error,
            TOOLS_CODE_172 = 60372 | XEvent.Severity.Error,
            TOOLS_CODE_173 = 60373 | XEvent.Severity.Error,
            TOOLS_CODE_174 = 60374 | XEvent.Severity.Error,
            TOOLS_CODE_175 = 60375 | XEvent.Severity.Error,
            VOUCHERMGR_INVALID_OFFER = 60376 | XEvent.Severity.Error,
            VOUCHERMGR_FAILED_ATTEMPT = 60377 | XEvent.Severity.Error,
            VOUCHERMGR_FAILED_COMPLETE = 60384 | XEvent.Severity.Warning,
            GENERIC_TOOLS_ERROR = 60385 | XEvent.Severity.Warning,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY = 60600 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG = 60601 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE = 60602 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_1 = 60603 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_2 = 60604 | XEvent.Severity.Error,
            GENEALOGY_WARN_TITLE_ROW_DISCARDED = 60605 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY = 60606 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_3 = 60607 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG = 60608 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_WRONG_NUMBER_BYTES_READ = 60609 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_CREATING_SERIAL_NUMBER = 60610 | XEvent.Severity.Error,
            GENEALOGY_ERROR_INVALID_PART_NUMBER = 60611 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_WRONG_STRING_LENGTH = 60612 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_BAD_STRING_DATA = 60613 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_RC4_DECRYPT = 60614 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_COMPUTE_PPA = 60615 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE = 60616 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE = 60617 | XEvent.Severity.Error,
            GENEALOGY_ERROR_GET_NEXT_ROW = 60618 | XEvent.Severity.Error,
            GENEALOGY_SERIAL_NUMBER_NOT_FOUND = 60619 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DB_INIT_STRING_CREATE = 60620 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DB_OPEN_FAILED = 60621 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DECODE_ONLINE_KEY = 60622 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DECRYPT_ONLINE_KEY = 60623 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_1 = 60624 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_4 = 60625 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG_1 = 60626 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_2 = 60627 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_5 = 60628 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_6 = 60629 | XEvent.Severity.Error,
            GENEALOGY_WARN_TITLE_ROW_DISCARDED_1 = 60630 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY_1 = 60631 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_7 = 60632 | XEvent.Severity.Error,
            GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG_1 = 60633 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DB_INIT_STRING_CREATE_1 = 60634 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DB_OPEN_FAILED_1 = 60635 | XEvent.Severity.Error,
            GENEALOGY_ERROR_INVALID_PART_NUMBER_1 = 60636 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_WRONG_STRING_LENGTH_1 = 60637 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_BAD_STRING_DATA_1 = 60638 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_COMPUTE_PPA_1 = 60639 | XEvent.Severity.Error,
            GENEALOGY_ERROR_MISSING_PPA_DATA_IN_ROW = 60640 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE_1 = 60641 | XEvent.Severity.Error,
            GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE_1 = 60642 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DECODE_ONLINE_KEY_1 = 60643 | XEvent.Severity.Error,
            GENEALOGY_ERROR_DECRYPT_ONLINE_KEY_1 = 60644 | XEvent.Severity.Error,
            TOOLS_COMM_45 = 60645 | XEvent.Severity.Error,
            TOOLS_COMM_46 = 60646 | XEvent.Severity.Error,
            TOOLS_COMM_47 = 60647 | XEvent.Severity.Error,
            TOOLS_COMM_48 = 60648 | XEvent.Severity.Error,
            KDC_BASE_WINHTTP_ERROR = 60649 | XEvent.Severity.Error,
            TOOLS_COMM_50 = 60650 | XEvent.Severity.Error,
            TOOLS_COMM_51 = 60651 | XEvent.Severity.Error,
            TOOLS_COMM_52 = 60652 | XEvent.Severity.Error,
            TOOLSSRV_TMR_FILE_UNLOCK_FAILED = 60653 | XEvent.Severity.Error,
            TOOLSSRV_TMR_FILE_LOCK_FAILED = 60654 | XEvent.Severity.Error,
            TOOLS_COMM_55 = 60655 | XEvent.Severity.Error,
            XWIRETAP_SG_COMMUNICATION_FAILURE = 60656 | XEvent.Severity.Error,
            XWIRETAP_SG_COMMUNICATION_FAILURE_1 = 60657 | XEvent.Severity.Error,
            XWIRETAP_SG_COMMUNICATION_FAILURE_2 = 60658 | XEvent.Severity.Error,
            TOOLS_COMM_59 = 60659 | XEvent.Severity.Error,
            TOOLS_COMM_60 = 60660 | XEvent.Severity.Error,
            TOOLS_COMM_61 = 60661 | XEvent.Severity.Error,
            TOOLS_COMM_62 = 60662 | XEvent.Severity.Error,
            TOOLS_CONFIG_0 = 60800 | XEvent.Severity.Warning,
            XMACS_INVALID_PRINCIPAL_9 = 60801 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_10 = 60802 | XEvent.Severity.Error,
            GENEALOGY_ERROR_SETUP_TABLE_BINDINGS = 60803 | XEvent.Severity.Error,
            GENEALOGY_ERROR_OPEN_FILE = 60804 | XEvent.Severity.Error,
            GENEALOGY_ERROR_GET_SETTING = 60805 | XEvent.Severity.Error,
            GENEALOGY_ERROR_XMGMT_INIT_FAIL = 60806 | XEvent.Severity.Error,
            GENEALOGY_ERROR_OPEN_FILE_1 = 60807 | XEvent.Severity.Error,
            TOOLS_CONFIG_8 = 60808 | XEvent.Severity.Error,
            TOOLS_CONFIG_9 = 60809 | XEvent.Severity.Error,
            TOOLS_CONFIG_10 = 60810 | XEvent.Severity.Error,
            GENEALOGY_SERVICE_START_FAILED = 60811 | XEvent.Severity.Error,
            GENEALOGY_SERVICE_START_FAILED_1 = 60812 | XEvent.Severity.Error,
            TOOLS_CONFIG_13 = 60813 | XEvent.Severity.Error,
            TOOLS_CONFIG_14 = 60814 | XEvent.Severity.Error,
            TOOLS_CONFIG_15 = 60815 | XEvent.Severity.Error,
            TOOLS_CONFIG_16 = 60816 | XEvent.Severity.Error,
            TOOLS_CONFIG_17 = 60817 | XEvent.Severity.Error,
            TOOLS_CONFIG_18 = 60818 | XEvent.Severity.Error,
            TOOLS_CONFIG_19 = 60819 | XEvent.Severity.Error,
            TOOLS_CONFIG_20 = 60820 | XEvent.Severity.Error,
            TOOLS_CONFIG_21 = 60821 | XEvent.Severity.Error,
            TOOLS_CONFIG_22 = 60822 | XEvent.Severity.Warning,
            GENEALOGY_SERVICE_START_FAILED_2 = 60823 | XEvent.Severity.Error,
            GENEALOGY_SERVICE_START_FAILED_3 = 60824 | XEvent.Severity.Error,
            TOOLS_CONFIG_25 = 60825 | XEvent.Severity.Error,
            TOOLS_CONFIG_26 = 60826 | XEvent.Severity.Error,
            TOOLS_CONFIG_27 = 60827 | XEvent.Severity.Error,
            TOOLS_CONFIG_28 = 60828 | XEvent.Severity.Error,
            GENEALOGY_ERROR_OPEN_FILE_2 = 60829 | XEvent.Severity.Error,
            GENEALOGY_ERROR_GET_SETTING_1 = 60830 | XEvent.Severity.Error,
            TOOLS_CONFIG_31 = 60831 | XEvent.Severity.Error,
            TOOLS_CONFIG_32 = 60832 | XEvent.Severity.Error,
            GENEALOGY_ERROR_XMGMT_INIT_FAIL_1 = 60833 | XEvent.Severity.Error,
            TOOLS_CONFIG_34 = 60834 | XEvent.Severity.Error,
            TOOLS_CONFIG_35 = 60835 | XEvent.Severity.Error,
            XKDC_BAD_TITLEID_2 = 60836 | XEvent.Severity.Error,
            XKDC_BAD_TITLEID_3 = 60837 | XEvent.Severity.Error,
            XKDC_BAD_SERVICEID = 60838 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_11 = 60839 | XEvent.Severity.Error,
            TOOLSSRV_TASKS_CANCELED = 60840 | XEvent.Severity.Warning,
            TOOLS_CONFIG_41 = 60841 | XEvent.Severity.Error,
            TOOLS_CONFIG_42 = 60842 | XEvent.Severity.Error,
            TOOLS_CONFIG_43 = 60843 | XEvent.Severity.Error,
            XWIRETAP_XMGMT_CONNECTION_FAILED = 60844 | XEvent.Severity.Error,
            XWIRETAP_XMGMT_CONNECTION_FAILED_1 = 60845 | XEvent.Severity.Error,
            XWIRETAP_TAP_CREATION_ERROR = 60846 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_1 = 60847 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_2 = 60848 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_3 = 60849 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_4 = 60850 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_5 = 60851 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_6 = 60852 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_7 = 60853 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_8 = 60854 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_9 = 60855 | XEvent.Severity.Warning,
            XWIRETAP_CAP_FILE_CREATION_FAILED = 60856 | XEvent.Severity.Error,
            XWIRETAP_CAP_FILE_CREATION_FAILED_1 = 60857 | XEvent.Severity.Error,
            TOOLS_CONFIG_58 = 60858 | XEvent.Severity.Error,
            TOOLS_CONFIG_59 = 60859 | XEvent.Severity.Error,
            TOOLS_CONFIG_60 = 60860 | XEvent.Severity.Error,
            XWIRETAP_INVALID_SETTING = 60861 | XEvent.Severity.Error,
            XWIRETAP_TAP_CREATION_ERROR_10 = 60862 | XEvent.Severity.Warning,
            XWIRETAP_TAP_CREATION_ERROR_11 = 60863 | XEvent.Severity.Warning,
            TOOLS_CONFIG_64 = 60864 | XEvent.Severity.Error,
            TOOLS_CONFIG_65 = 60865 | XEvent.Severity.Error,
            TOOLS_CONFIG_66 = 60866 | XEvent.Severity.Error,
            TOOLS_CONFIG_67 = 60867 | XEvent.Severity.Error,
            TOOLS_CONFIG_68 = 60868 | XEvent.Severity.Error,
            TOOLS_CONFIG_69 = 60869 | XEvent.Severity.Error,
            TOOLS_CONFIG_70 = 60870 | XEvent.Severity.Warning,
            XWIRETAP_INVALID_SETTING_1 = 60871 | XEvent.Severity.Error,
            XWIRETAP_INVALID_SETTING_2 = 60872 | XEvent.Severity.Error,
            TOOLS_CONFIG_73 = 60873 | XEvent.Severity.Error,
            TOOLS_CONFIG_74 = 60874 | XEvent.Severity.Error,
            TOOLS_CONFIG_75 = 60875 | XEvent.Severity.Error,
            TOOLS_CONFIG_76 = 60876 | XEvent.Severity.Error,
            TOOLS_CONFIG_77 = 60877 | XEvent.Severity.Error,
            TOOLS_CONFIG_78 = 60878 | XEvent.Severity.Error,
            TOOLS_CONFIG_79 = 60879 | XEvent.Severity.Error,
            TOOLS_CONFIG_80 = 60880 | XEvent.Severity.Warning,
            UDPADPT_INVALID_PORT_LIST_WARNING = 60881 | XEvent.Severity.Warning,
            TOOLS_CONFIG_82 = 60882 | XEvent.Severity.Error,
            REGCLIENTAUTO_CONFIG_ERROR = 60883 | XEvent.Severity.Error,
            TOOLS_HACK_0 = 61000 | XEvent.Severity.Warning,
            TOOLS_HACK_1 = 61001 | XEvent.Severity.Warning,
            TOOLS_HACK_2 = 61002 | XEvent.Severity.Warning,
            TOOLS_HACK_3 = 61003 | XEvent.Severity.Warning,
            TOOLS_HACK_4 = 61004 | XEvent.Severity.Warning,
            TOOLS_HACK_5 = 61005 | XEvent.Severity.Warning,
            TOOLS_HACK_6 = 61006 | XEvent.Severity.Warning,
            TOOLS_HACK_7 = 61007 | XEvent.Severity.Warning,
            TOOLS_HACK_8 = 61008 | XEvent.Severity.Warning,
            TOOLS_HACK_9 = 61009 | XEvent.Severity.Warning,
            TOOLS_HACK_10 = 61010 | XEvent.Severity.Warning,
            TOOLS_HACK_11 = 61011 | XEvent.Severity.Warning,
            TOOLS_HACK_12 = 61012 | XEvent.Severity.Warning,
            TOOLS_HACK_13 = 61013 | XEvent.Severity.Warning,
            TOOLS_HACK_14 = 61014 | XEvent.Severity.Warning,
            TOOLS_HACK_15 = 61015 | XEvent.Severity.Warning,
            ASKDC_DOS_EXISTING_CLIENT = 61016 | XEvent.Severity.Warning,
            XKDC_DOS_REPLAY = 61017 | XEvent.Severity.Warning,
            XMACS_INACTIVE_XBOX_1 = 61018 | XEvent.Severity.Warning,
            XMACS_DOS_MAXIMUM_ALLOWANCE = 61019 | XEvent.Severity.Warning,
            TOOLS_INFO_0 = 61050 | XEvent.Severity.Info,
            TOOLS_INFO_1 = 61051 | XEvent.Severity.Info,
            TOOLS_INFO_2 = 61052 | XEvent.Severity.Info,
            TOOLS_INFO_3 = 61053 | XEvent.Severity.Info,
            TOOLS_INFO_4 = 61054 | XEvent.Severity.Info,
            TOOLS_INFO_5 = 61055 | XEvent.Severity.Info,
            TOOLS_INFO_6 = 61056 | XEvent.Severity.Info,
            TOOLS_INFO_7 = 61057 | XEvent.Severity.Info,
            TOOLS_INFO_8 = 61058 | XEvent.Severity.Info,
            TOOLS_INFO_9 = 61059 | XEvent.Severity.Info,
            GENEALOGY_INFO_EEPROM_VERIFY_COMPLETE = 61060 | XEvent.Severity.Info,
            GENEALOGY_INFO_APP_START = 61061 | XEvent.Severity.Info,
            GENEALOGY_INFO_UPDATE_COMPLETE = 61062 | XEvent.Severity.Info,
            GENEALOGY_SERVICE_STOPPED = 61063 | XEvent.Severity.Info,
            GENEALOGY_SERVICE_STARTED = 61064 | XEvent.Severity.Info,
            GENEALOGY_INFO_FILES_IN_DROP_DIR = 61065 | XEvent.Severity.Info,
            GENEALOGY_SERVICE_STOPPED_1 = 61066 | XEvent.Severity.Info,
            GENEALOGY_INFO_UPDATE_COMPLETE_1 = 61067 | XEvent.Severity.Info,
            GENEALOGY_INFO_UPDATE_COMPLETE_2 = 61068 | XEvent.Severity.Info,
            XMACS_PPALOADER_LOADING_INFO_2 = 61069 | XEvent.Severity.Info,
            XMACS_PUID_ATTAINED_NEW_BLOCK_1 = 61070 | XEvent.Severity.Info,
            XMACS_NONUNIQUE_SERIALNUMBER_REQUEST_1 = 61071 | XEvent.Severity.Info,
            XMACS_PPALOADER_LOADING_INFO_3 = 61072 | XEvent.Severity.Info,
            MB_MACHINE_ACCOUNT_BANNED = 61073 | XEvent.Severity.Info,
            MB_MACHINE_ACCOUNT_UNBANNED = 61074 | XEvent.Severity.Info,
            TOOLSSRV_SHUTDOWN_COMPLETED = 61075 | XEvent.Severity.Info,
            TOOLSSRV_STARTUP_COMPLETED = 61076 | XEvent.Severity.Info,
            TOOLS_INFO_27 = 61077 | XEvent.Severity.Info,
            TOOLS_INFO_28 = 61078 | XEvent.Severity.Info,
            TOOLS_INFO_29 = 61079 | XEvent.Severity.Info,
            TOOLS_INFO_30 = 61080 | XEvent.Severity.Info,
            TOOLS_INFO_31 = 61081 | XEvent.Severity.Info,
            TOOLS_INFO_32 = 61082 | XEvent.Severity.Info,
            TOOLS_INFO_33 = 61083 | XEvent.Severity.Info,
            TOOLS_INFO_34 = 61084 | XEvent.Severity.Info,
            TOOLS_INFO_35 = 61085 | XEvent.Severity.Info,
            TOOLS_INFO_36 = 61086 | XEvent.Severity.Info,
            TOOLS_INFO_37 = 61087 | XEvent.Severity.Info,
            TOOLS_INFO_38 = 61088 | XEvent.Severity.Info,
            XWIRETAP_TAP_CLOSE = 61089 | XEvent.Severity.Info,
            XWIRETAP_INIT_SUCCESS = 61090 | XEvent.Severity.Info,
            XWIRETAP_TERM_SUCCESS = 61091 | XEvent.Severity.Info,
            TOOLS_INFO_42 = 61092 | XEvent.Severity.Info,
            TOOLS_INFO_43 = 61093 | XEvent.Severity.Info,
            TOOLS_INFO_44 = 61094 | XEvent.Severity.Info,
            UDPADPT_INIT_SUCCESS = 61095 | XEvent.Severity.Info,
            UDPADPT_TERM_SUCCESS = 61096 | XEvent.Severity.Info,
            VOUCHERMGR_COMPLETION = 61097 | XEvent.Severity.Info,
            GENERIC_TOOLS_SUCCESS = 61104 | XEvent.Severity.Info,
            REPORTING_CUBE_INSTALL_FAILED = 62575 | XEvent.Severity.Warning,
            REPORTING_WMIS_SQL_TICK_CODE_ERROR = 62576 | XEvent.Severity.Error,
            REPORTING_WMIS_RECORD_TICK_CODE_ERROR = 62577 | XEvent.Severity.Error,
            REPORTING_WMIS_ENUMERATE_WEB_CODE_ERROR = 62578 | XEvent.Severity.Error,
            REPORTING_WMIS_DELETE_CODE_ERROR = 62579 | XEvent.Severity.Error,
            REPORTING_WMIS_FILE_DOWNLOAD_ERROR = 62580 | XEvent.Severity.Error,
            REPORTING_WMIS_DOWNLOAD_CODE_ERROR = 62581 | XEvent.Severity.Error,
            REPORTING_WMIS_TICK_CODE_ERROR = 62582 | XEvent.Severity.Error,
            REPORTING_WMIS_TICK_WRITE_ERROR = 62583 | XEvent.Severity.Error,
            REPORTING_OLAPAUTOBUILD_ERROR = 62584 | XEvent.Severity.Error,
            REPORTING_SSASQUERYCUBE_ERROR = 62585 | XEvent.Severity.Error,
            REPORTING_WMIS_SQL_TICK_SQL_ERROR = 62600 | XEvent.Severity.Error,
            REPORTING_WMIS_RECORD_TICK_SQL_ERROR = 62601 | XEvent.Severity.Error,
            REPORTING_WMIS_ENUMERATE_WEB_ERROR = 62602 | XEvent.Severity.Error,
            REPORTING_WMIS_NO_FILES_FOUND = 62603 | XEvent.Severity.Error,
            REPORTING_WMIS_FILE_DOWNLOAD_WEB_ERROR = 62604 | XEvent.Severity.Error,
            REPORTING_WMIS_NO_NEW_FILE = 62625 | XEvent.Severity.Info,
            REPORTING_WMIS_SYNC_SUCCESS = 62626 | XEvent.Severity.Info,
            REPORTING_OLAPAUTOBUILD_SUCCESS = 62627 | XEvent.Severity.Info,
            REPORTING_OLAPAUTOBUILD_INFO = 62628 | XEvent.Severity.Info,
            REPORTING_SSASQUERYCUBE_INFO = 62629 | XEvent.Severity.Info,
            REPORTING_WMIS_DELETE_PATH_NOT_FOUND = 62650 | XEvent.Severity.Error,
            REPORTING_WMIS_DELETE_NO_ACCESS = 62651 | XEvent.Severity.Error,
            REPORTING_WMIS_DOWNLOAD_PATH_NOT_FOUND = 62652 | XEvent.Severity.Error,
            REPORTING_WMIS_DOWNLOAD_PATH_NO_ACCESS = 62653 | XEvent.Severity.Error,
            REPORTING_WMIS_TICK_PATH_NOT_FOUND = 62654 | XEvent.Severity.Error,
            REPORTING_WMIS_TICK_PATH_NO_ACCESS = 62655 | XEvent.Severity.Error,
            REPORTING_WMIS_CERTIFICATE_ERROR = 62656 | XEvent.Severity.Error,
            PARTITION_TOOL_ERROR = 63225 | XEvent.Severity.Error,
            PARTITION_TOOL_LOG_NON_ERROR = 63226 | XEvent.Severity.Info,
            PARTITION_TOOL_INFO = 63227 | XEvent.Severity.Info,
            WCQUERY_WEBALIVE_CODE_1 = 15001 | XEvent.Severity.Error,
            WCQUERY_WEBALIVE_CODE_2 = 15002 | XEvent.Severity.Error,
            WCQUERY_WEBALIVE_CODE_3 = 15003 | XEvent.Severity.Error,
            WEBCACHE_BULK_USER_ERROR = 15000 | XEvent.Severity.Error,
            WEBCACHE_CREATE_BULK_USER_ERROR = 15001 | XEvent.Severity.Error,
            WEBCACHE_BULKUSER_GAMERTAG_ERROR = 15002 | XEvent.Severity.Error,
            WEBCACHE_REWARDS_ELIGIBILITY_ERROR = 15003 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_3 = 61150 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_4 = 61151 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_5 = 61152 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_6 = 61153 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_7 = 61154 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_8 = 61155 | XEvent.Severity.Error,
            WEBCACHE_WEBSG_ERROR = 61156 | XEvent.Severity.Error,
            WEBCACHE_MANAGEMENT_COMMAND_ERROR = 61157 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_9 = 61158 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_10 = 61159 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_11 = 61160 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_12 = 61161 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_13 = 61162 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_14 = 61163 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_15 = 61164 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_16 = 61165 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_17 = 61166 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_18 = 61167 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_19 = 61168 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_20 = 61169 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_NONFATAL_ERROR = 61170 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_21 = 61171 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_22 = 61172 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_23 = 61173 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_24 = 61174 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_25 = 61175 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_26 = 61176 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_27 = 61177 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_28 = 61178 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_29 = 61179 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_30 = 61180 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_31 = 61181 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_32 = 61182 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_33 = 61183 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_34 = 61184 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_35 = 61185 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_36 = 61186 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_37 = 61187 | XEvent.Severity.Error,
            WEBCACHE_CODE_38 = 61188 | XEvent.Severity.Error,
            WEBCACHE_CODE_39 = 61189 | XEvent.Severity.Error,
            WEBCACHE_CODE_40 = 61190 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_38 = 61191 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_39 = 61192 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_40 = 61193 | XEvent.Severity.Error,
            WEBCACHE_CODE_44 = 61194 | XEvent.Severity.Error,
            WEBCACHE_CODE_45 = 61195 | XEvent.Severity.Error,
            WEBCACHE_CODE_46 = 61196 | XEvent.Severity.Error,
            WEBCACHE_CODE_47 = 61197 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_NONFATAL_ERROR_1 = 61198 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_NONFATAL_ERROR_2 = 61199 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_41 = 61200 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_42 = 61201 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_43 = 61202 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_44 = 61203 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_45 = 61204 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_46 = 61205 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_47 = 61206 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_48 = 61207 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_49 = 61208 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_50 = 61209 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_51 = 61210 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_52 = 61211 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_53 = 61212 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_54 = 61213 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_55 = 61214 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_56 = 61215 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_57 = 61216 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_58 = 61217 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_59 = 61218 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_60 = 61219 | XEvent.Severity.Error,
            WEBCACHE_CODE_70 = 61220 | XEvent.Severity.Error,
            WEBCACHE_CODE_71 = 61221 | XEvent.Severity.Error,
            WEBCACHE_CODE_72 = 61222 | XEvent.Severity.Error,
            WEBCACHE_CODE_73 = 61223 | XEvent.Severity.Error,
            WEBCACHE_CODE_74 = 61224 | XEvent.Severity.Error,
            WEBCACHE_CODE_75 = 61225 | XEvent.Severity.Error,
            WEBCACHE_CODE_76 = 61226 | XEvent.Severity.Error,
            WEBCACHE_CODE_77 = 61227 | XEvent.Severity.Error,
            WEBCACHE_CODE_78 = 61228 | XEvent.Severity.Error,
            WEBCACHE_CODE_79 = 61229 | XEvent.Severity.Error,
            WEBCACHE_CODE_80 = 61230 | XEvent.Severity.Error,
            WEBCACHE_CODE_81 = 61231 | XEvent.Severity.Error,
            WEBCACHE_CODE_82 = 61232 | XEvent.Severity.Error,
            WEBCACHE_CODE_83 = 61233 | XEvent.Severity.Error,
            WEBCACHE_CODE_84 = 61234 | XEvent.Severity.Error,
            WEBCACHE_CODE_85 = 61235 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_61 = 61236 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_62 = 61237 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_63 = 61238 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_64 = 61239 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_65 = 61240 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_66 = 61241 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_67 = 61242 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_68 = 61243 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_69 = 61244 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_70 = 61245 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_71 = 61246 | XEvent.Severity.Error,
            WEBCACHE_CODE_97 = 61247 | XEvent.Severity.Error,
            WEBCACHE_CODE_98 = 61248 | XEvent.Severity.Error,
            WEBCACHE_CODE_99 = 61249 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_NONFATAL_ERROR_3 = 61250 | XEvent.Severity.Error,
            WEBCACHE_CODE_101 = 61251 | XEvent.Severity.Error,
            WEBCACHE_CODE_102 = 61252 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_72 = 61253 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_73 = 61254 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_74 = 61255 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_75 = 61256 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_76 = 61257 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_77 = 61258 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_78 = 61259 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_79 = 61260 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_80 = 61261 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_81 = 61262 | XEvent.Severity.Error,
            WEBCACHE_CODE_113 = 61263 | XEvent.Severity.Error,
            WEBCACHE_CODE_114 = 61264 | XEvent.Severity.Error,
            WEBCACHE_CODE_115 = 61265 | XEvent.Severity.Error,
            WEBCACHE_CODE_116 = 61266 | XEvent.Severity.Error,
            WEBCACHE_CODE_117 = 61267 | XEvent.Severity.Error,
            WEBCACHE_CODE_118 = 61268 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_82 = 61269 | XEvent.Severity.Error,
            WEBCACHE_CODE_120 = 61270 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_83 = 61271 | XEvent.Severity.Error,
            WEBCACHE_CODE_122 = 61272 | XEvent.Severity.Error,
            WEBCACHE_CODE_123 = 61273 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_84 = 61274 | XEvent.Severity.Error,
            WEBCACHE_CODE_125 = 61275 | XEvent.Severity.Error,
            WEBCACHE_CODE_126 = 61276 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_85 = 61277 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_86 = 61278 | XEvent.Severity.Error,
            WEBCACHE_CODE_129 = 61279 | XEvent.Severity.Error,
            WEBCACHE_CODE_130 = 61280 | XEvent.Severity.Error,
            WEBCACHE_CODE_131 = 61281 | XEvent.Severity.Error,
            WEBCACHE_CODE_132 = 61282 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_87 = 61283 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_88 = 61284 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_89 = 61285 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_90 = 61286 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_91 = 61287 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_92 = 61288 | XEvent.Severity.Error,
            WEBCACHE_UNKNOWN_ERROR_93 = 61289 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_NONFATAL_ERROR_4 = 61290 | XEvent.Severity.Error,
            WEBCACHE_CODE_133 = 61291 | XEvent.Severity.Error,
            WEBCACHE_CODE_134 = 61292 | XEvent.Severity.Error,
            WEBCACHE_CODE_135 = 61293 | XEvent.Severity.Info,
            WEBCACHE_CODE_136 = 61294 | XEvent.Severity.Error,
            WEBCACHE_CODE_137 = 61295 | XEvent.Severity.Error,
            WEBCACHE_CODE_138 = 61296 | XEvent.Severity.Error,
            WEBCACHE_CODE_139 = 61297 | XEvent.Severity.Error,
            WEBCACHE_CODE_140 = 61298 | XEvent.Severity.Error,
            WEBCACHE_CODE_141 = 61299 | XEvent.Severity.Error,
            WEBCACHE_CODE_142 = 61300 | XEvent.Severity.Error,
            WEBCACHE_CODE_143 = 61301 | XEvent.Severity.Error,
            WEBCACHE_CODE_144 = 61302 | XEvent.Severity.Error,
            WEBCACHE_CODE_145 = 61303 | XEvent.Severity.Error,
            WEBCACHE_CODE_146 = 61304 | XEvent.Severity.Error,
            WEBCACHE_CODE_147 = 61305 | XEvent.Severity.Error,
            WEBCACHE_CODE_159 = 61309 | XEvent.Severity.Error,
            WEBCACHE_CODE_48 = 61310 | XEvent.Severity.Error,
            WEBCACHE_CODE_49 = 61311 | XEvent.Severity.Error,
            WEBCACHE_CODE_50 = 61312 | XEvent.Severity.Error,
            WEBCACHE_CODE_51 = 61313 | XEvent.Severity.Error,
            WEBCACHE_CODE_52 = 61314 | XEvent.Severity.Error,
            WEBCACHE_CODE_53 = 61315 | XEvent.Severity.Error,
            WEBCACHE_CODE_54 = 61316 | XEvent.Severity.Error,
            WEBCACHE_CODE_55 = 61317 | XEvent.Severity.Error,
            WEBCACHE_CODE_56 = 61318 | XEvent.Severity.Error,
            WEBCACHE_CODE_57 = 61319 | XEvent.Severity.Error,
            WEBCACHE_CODE_58 = 61320 | XEvent.Severity.Error,
            WEBCACHE_CODE_59 = 61321 | XEvent.Severity.Error,
            WEBCACHE_CODE_60 = 61322 | XEvent.Severity.Error,
            WEBCACHE_CODE_61 = 61323 | XEvent.Severity.Error,
            WEBCACHE_CODE_62 = 61324 | XEvent.Severity.Error,
            WEBCACHE_CODE_63 = 61325 | XEvent.Severity.Error,
            WEBCACHE_CODE_64 = 61326 | XEvent.Severity.Error,
            WEBCACHE_CODE_65 = 61327 | XEvent.Severity.Error,
            WEBCACHE_WHOLESALE_PARTNER_ERROR = 61328 | XEvent.Severity.Error,
            WEBCACHE_WHOLESALE_ERROR = 61329 | XEvent.Severity.Error,
            WEBCACHE_WHOLESALE_PASSPORT_ERROR = 61330 | XEvent.Severity.Error,
            WEBCACHE_WHOLESALE_GAMERTAG_ERROR = 61331 | XEvent.Severity.Error,
            WEBCACHE_WHOLESALE_ACCOUNT_ERROR = 61332 | XEvent.Severity.Error,
            WEBCACHE_COMM_0 = 61550 | XEvent.Severity.Error,
            WEBCACHE_COMM_1 = 61551 | XEvent.Severity.Error,
            WEBCACHE_COMM_2 = 61552 | XEvent.Severity.Error,
            WEBCACHE_COMM_3 = 61553 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_ERROR = 61554 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_ERROR_1 = 61555 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_ERROR_2 = 61556 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_ERROR_3 = 61557 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_INTERNAL_ERROR = 61558 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_1 = 61559 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_2 = 61560 | XEvent.Severity.Error,
            WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_3 = 61561 | XEvent.Severity.Error,
            WEBCACHE_COMM_12 = 61562 | XEvent.Severity.Error,
            WEBCACHE_COMM_13 = 61563 | XEvent.Severity.Error,
            WEBCACHE_COMM_14 = 61564 | XEvent.Severity.Error,
            WEBCACHE_COMM_15 = 61565 | XEvent.Severity.Error,
            WEBCACHE_COMM_16 = 61566 | XEvent.Severity.Error,
            WEBCACHE_COMM_17 = 61567 | XEvent.Severity.Error,
            WEBCACHE_UNLINK_GAMERTAG_ERROR = 61568 | XEvent.Severity.Error,
            WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID = 61569 | XEvent.Severity.Error,
            WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID_FOR_ALL_LB = 61570 | XEvent.Severity.Error,
            WEBCACHE_CONFIG_0 = 61600 | XEvent.Severity.Error,
            WEBCACHE_CONFIG_1 = 61601 | XEvent.Severity.Error,
            WEBCACHE_CONFIG_2 = 61602 | XEvent.Severity.Error,
            WEBCACHE_CONFIG_3 = 61603 | XEvent.Severity.Error,
            WEBCACHE_PROFILE_HACK_1 = 61604 | XEvent.Severity.Error,
            WEBCACHE_PROFILE_BUG_1 = 61605 | XEvent.Severity.Error,
            WEBCACHE_PROFILE_BUG_2 = 61606 | XEvent.Severity.Error,
            WEBCACHE_PROFILE_BUG_3 = 61607 | XEvent.Severity.Error,
            WEBCACHE_PROFILE_BUG_4 = 61608 | XEvent.Severity.Error,
            WCDEBUGTEST_INITIALIZATION_1 = 61609 | XEvent.Severity.Error,
            WCDEBUGTEST_HACK_2 = 61611 | XEvent.Severity.Error,
            WCDEBUGTEST_UNEXPECTED_ERROR_1 = 61612 | XEvent.Severity.Error,
            WEBCACHE_HACK_0 = 61625 | XEvent.Severity.Warning,
            LIVEPROXY_INVALID_MSGFORMAT = 61626 | XEvent.Severity.Warning,
            LIVEPROXY_INVALID_MSGFORMAT_1 = 61627 | XEvent.Severity.Warning,
            LIVEPROXY_INVALID_MSGFORMAT_2 = 61628 | XEvent.Severity.Warning,
            WEBCACHE_HACK_4 = 61629 | XEvent.Severity.Warning,
            WEBCACHE_HACK_5 = 61630 | XEvent.Severity.Warning,
            WEBCACHE_HACK_6 = 61631 | XEvent.Severity.Warning,
            WEBCACHE_HACK_7 = 61632 | XEvent.Severity.Warning,
            WEBCACHE_HACK_8 = 61633 | XEvent.Severity.Warning,
            WEBCACHE_HACK_9 = 61634 | XEvent.Severity.Warning,
            WEBCACHE_HACK_10 = 61635 | XEvent.Severity.Warning,
            WEBCACHE_HACK_11 = 61636 | XEvent.Severity.Warning,
            WEBCACHE_HACK_12 = 61637 | XEvent.Severity.Warning,
            WEBCACHE_HACK_13 = 61638 | XEvent.Severity.Warning,
            WEBCACHE_HACK_14 = 61639 | XEvent.Severity.Warning,
            WEBCACHE_HACK_15 = 61640 | XEvent.Severity.Warning,
            WEBCACHE_HACK_16 = 61641 | XEvent.Severity.Warning,
            WEBCACHE_HACK_17 = 61642 | XEvent.Severity.Warning,
            WEBCACHE_HACK_18 = 61643 | XEvent.Severity.Warning,
            WEBCACHE_HACK_19 = 61644 | XEvent.Severity.Warning,
            WEBCACHE_HACK_20 = 61645 | XEvent.Severity.Warning,
            LIVEPROXY_INVALID_CHARACTER_SUBMISSION = 61646 | XEvent.Severity.Warning,
            WEBCACHE_HACK_22 = 61647 | XEvent.Severity.Warning,
            WCDEBUGTEST_HACK_1 = 61648 | XEvent.Severity.Error,
            WEBCACHE_INFO_0 = 61675 | XEvent.Severity.Info,
            WEBCACHE_INFO_1 = 61676 | XEvent.Severity.Info,
            WEBCACHE_INFO_2 = 61677 | XEvent.Severity.Info,
            WEBCACHE_BAD_REQUEST_FROM_PARTNER = 61700 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_NOT_FOUND_ERROR = 61701 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_NOT_FOUND_ERROR_1 = 61702 | XEvent.Severity.Error,
            WEBCACHE_API_NOT_ALLOWED_ERROR = 61703 | XEvent.Severity.Error,
            WEBCACHE_API_NOT_ALLOWED_ERROR_1 = 61704 | XEvent.Severity.Error,
            WEBCACHE_TITLE_NOT_ALLOWED_ERROR = 61705 | XEvent.Severity.Error,
            WEBCACHE_TITLE_NOT_ALLOWED_ERROR_1 = 61706 | XEvent.Severity.Error,
            WEBCACHE_INVALID_IP_ERROR = 61707 | XEvent.Severity.Error,
            WEBCACHE_INVALID_IP_ERROR_1 = 61708 | XEvent.Severity.Error,
            WEBCACHE_TOO_MANY_SIGNATURES = 61709 | XEvent.Severity.Error,
            WEBCACHE_INVALID_DIGEST_SIZE = 61710 | XEvent.Severity.Error,
            WEBCACHE_TOO_MANY_SIGNATURES_1 = 61711 | XEvent.Severity.Error,
            WEBCACHE_BAD_REQUEST_FROM_PARTNER_1 = 61712 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_NOT_FOUND_ERROR_2 = 61713 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_14 = 61714 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_15 = 61715 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_16 = 61716 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_17 = 61717 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_18 = 61718 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_19 = 61719 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_20 = 61720 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_21 = 61721 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_22 = 61722 | XEvent.Severity.Error,
            WEBCACHE_PARTNER_23 = 61723 | XEvent.Severity.Error,
            WEBCACHE_INTERNAL_ERROR = 61724 | XEvent.Severity.Error,
            WEBCACHE_LICENSE_TRANSFER_COMMIT_FAILED = 61726 | XEvent.Severity.Error,
            DEPRECATED_WEBCACHE_LICENSE_TRANSFER_CONSOLE_REGISTRATION_FAILED = 61727 | XEvent.Severity.Error,
            WEBSG_CAPTUREUPDATE_FAILED = 10000 | XEvent.Severity.Warning,
            WEBSG_WINHTTP_ERROR = 61750 | XEvent.Severity.Error,
            WEBSG_CODE_1 = 61751 | XEvent.Severity.Error,
            WEBSG_WINHTTP_ERROR_1 = 61752 | XEvent.Severity.Error,
            WEBSG_SEND_ERROR_PAGE = 61775 | XEvent.Severity.Error,
            WEBSG_COMM_1 = 61776 | XEvent.Severity.Error,
            WEBSG_COMM_2 = 61777 | XEvent.Severity.Error,
            WEBSG_COMM_3 = 61778 | XEvent.Severity.Error,
            WEBSG_COMM_4 = 61779 | XEvent.Severity.Error,
            WEBSG_COMM_5 = 61780 | XEvent.Severity.Error,
            WEBSG_FAIL_TO_GET_WEBCACHE_RESPONSE_DATA = 61781 | XEvent.Severity.Error,
            WEBSG_CONFIG_ERROR = 61800 | XEvent.Severity.Error,
            WEBSG_CONFIG_ERROR_1 = 61801 | XEvent.Severity.Error,
            WEBSG_CONFIG_ERROR_2 = 61802 | XEvent.Severity.Error,
            WEBSG_INVALID_CRYPTO_HANDLE = 61803 | XEvent.Severity.Error,
            WEBSG_CONFIG_ERROR_3 = 61804 | XEvent.Severity.Error,
            WEBSG_CONFIG_5 = 61805 | XEvent.Severity.Error,
            WEBSG_CONFIG_6 = 61806 | XEvent.Severity.Error,
            WEBSG_CONFIG_7 = 61807 | XEvent.Severity.Error,
            WEBSG_CONFIG_8 = 61808 | XEvent.Severity.Error,
            DEPRECATED_WEBSG_CONFIG_9 = 61809 | XEvent.Severity.Error,
            DEPRECATED_WEBSG_CONFIG_10 = 61810 | XEvent.Severity.Error,
            WEBSG_CONFIG_11 = 61811 | XEvent.Severity.Error,
            WEBSG_CONFIG_12 = 61812 | XEvent.Severity.Error,
            WEBSG_CONFIG_13 = 61813 | XEvent.Severity.Error,
            WEBSG_CONFIG_14 = 61814 | XEvent.Severity.Error,
            WEBSG_CONFIG_15 = 61815 | XEvent.Severity.Error,
            WEBSG_CONFIG_16 = 61816 | XEvent.Severity.Error,
            WEBSG_CONFIG_17 = 61817 | XEvent.Severity.Error,
            WEBSG_CONFIG_18 = 61818 | XEvent.Severity.Error,
            WEBSG_CONFIG_19 = 61819 | XEvent.Severity.Error,
            WEBSG_NO_WEBCACHE = 61820 | XEvent.Severity.Error,
            WEBSG_UNSUPPORTED_METHOD = 61850 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER = 61851 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_1 = 61852 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_2 = 61853 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_3 = 61854 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_4 = 61855 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_5 = 61856 | XEvent.Severity.Warning,
            WEBSG_WEBCLIENT_INVALID_HEADER_6 = 61857 | XEvent.Severity.Warning,
            XBANC_CONFIG_HEALTHINTEROP_CREATE = 20000 | XEvent.Severity.Error,
            XBANC_CONFIG_HEALTHINTEROP_INIT = 20001 | XEvent.Severity.Error,
            XBANC_CODE_0 = 63500 | XEvent.Severity.Error,
            XBANC_CODE_1 = 63501 | XEvent.Severity.Error,
            XBANC_CODE_2 = 63502 | XEvent.Severity.Error,
            XBANC_CODE_3 = 63503 | XEvent.Severity.Error,
            XBANC_CODE_4 = 63504 | XEvent.Severity.Error,
            XBANC_CODE_5 = 63505 | XEvent.Severity.Error,
            XBANC_CODE_6 = 63506 | XEvent.Severity.Error,
            XBANC_CODE_7 = 63507 | XEvent.Severity.Error,
            XBANC_CODE_8 = 63508 | XEvent.Severity.Error,
            XBANC_CODE_9 = 63509 | XEvent.Severity.Error,
            XBANC_CODE_10 = 63510 | XEvent.Severity.Error,
            XBANC_CODE_11 = 63511 | XEvent.Severity.Error,
            XBANC_CODE_12 = 63512 | XEvent.Severity.Error,
            XBANC_CODE_13 = 63513 | XEvent.Severity.Error,
            XBANC_CODE_14 = 63514 | XEvent.Severity.Error,
            XBANC_CODE_15 = 63515 | XEvent.Severity.Error,
            XBANC_CODE_16 = 63516 | XEvent.Severity.Error,
            XBANC_CODE_17 = 63517 | XEvent.Severity.Error,
            XBANC_CODE_18 = 63518 | XEvent.Severity.Error,
            XBANC_CODE_19 = 63519 | XEvent.Severity.Error,
            XBANC_CODE_20 = 63520 | XEvent.Severity.Error,
            XBANC_CODE_21 = 63521 | XEvent.Severity.Error,
            XBANC_CODE_22 = 63522 | XEvent.Severity.Error,
            XBANC_CODE_23 = 63523 | XEvent.Severity.Error,
            XBANC_CODE_24 = 63524 | XEvent.Severity.Error,
            XBANC_CODE_25 = 63525 | XEvent.Severity.Error,
            XBANC_CODE_26 = 63526 | XEvent.Severity.Error,
            XBANC_CODE_27 = 63527 | XEvent.Severity.Error,
            XBANC_SERVER_TOO_BUSY = 63528 | XEvent.Severity.Error,
            XBANC_PROXY_NOT_INITIALIZED = 63529 | XEvent.Severity.Error,
            XBANC_CODE_30 = 63530 | XEvent.Severity.Error,
            XBANC_CODE_31 = 63531 | XEvent.Severity.Error,
            XBANC_CODE_32 = 63532 | XEvent.Severity.Error,
            XBANC_INFO_0 = 63700 | XEvent.Severity.Info,
            XBANC_INFO_1 = 63701 | XEvent.Severity.Info,
            XBANC_INFO_2 = 63702 | XEvent.Severity.Info,
            XBANC_INFO_SETTINGS_CHANGE = 63703 | XEvent.Severity.Info,
            XBANC_INFO_SERVER_RESUME = 63704 | XEvent.Severity.Info,
            XBANC_WARN_0 = 63750 | XEvent.Severity.Warning,
            XBOS_ACTIVEAUTH_CANCEL_SUBSCRIPTION_NOT_ALLOWED = 15000 | XEvent.Severity.Error,
            XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_COUNTRY_CODE_FOUND = 15001 | XEvent.Severity.Error,
            XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_MEDIA_TYPE_FOUND = 15002 | XEvent.Severity.Error,
            XBOS_SCS_RECORD_MEDIA_PURCHASE_INTENT_FAILURE = 15003 | XEvent.Severity.Error,
            XBOS_SCS_RECORD_MEDIA_PURCHASE_SUCCESS_FAILURE = 15004 | XEvent.Severity.Error,
            XBOS_SCS_RECORD_MEDIA_PURCHASE_FAILURE_FAILURE = 15005 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_WEB_EXCEPTION = 15006 | XEvent.Severity.Error,
            XBOS_PURCHASE_MEDIA_OFFERS_ERROR = 15007 | XEvent.Severity.Error,
            XBOS_SCS_GET_PENDING_COUNT_FAILURE = 15008 | XEvent.Severity.Error,
            XBOS_SCS_GET_PENDING_TRANSACTION_FAILURE = 15009 | XEvent.Severity.Error,
            XBOS_SCS_GET_PENDING_SUBMIT_ORDER_FAILURE = 15010 | XEvent.Severity.Error,
            XBOS_SCS_GET_PENDING_OFFSET_ORDER_FAILURE = 15011 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_QUEUE_TIMER_RESET_ERROR = 15012 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_QUEUE_PUMP_ERROR = 15013 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_QUEUE_IMPERSONATION_UNDO_ERROR = 15014 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_QUEUE_SUBMIT_ORDER_ERROR = 15015 | XEvent.Severity.Error,
            XBOS_SCS_SUBMIT_ORDER_QUEUE_OFFSET_ORDER_ERROR = 15016 | XEvent.Severity.Error,
            XBOS_INVALID_LIMITED_CHILD_PURCHASE_OFFER_TYPE_FOUND = 15017 | XEvent.Severity.Error,
            XBOS_INVALID_LIMITED_CHILD_OFFER_PURCHASE_COUNTRY_CODE_FOUND = 15018 | XEvent.Severity.Error,
            XBOS_IN_GAME_CONTENT_AVAILABLE_ERROR = 15019 | XEvent.Severity.Error,
            XBOS_IN_GAME_CONTENT_ENUMERATE_ERROR = 15020 | XEvent.Severity.Error,
            XBOS_OFFER_PURCHASE_ERROR = 15021 | XEvent.Severity.Error,
            XBOS_SUBSCRIPTION_DETAILS_ERROR = 15022 | XEvent.Severity.Error,
            XBOS_VERIFY_TOKEN_ERROR = 15023 | XEvent.Severity.Error,
            XBOS_CONTENT_AVAILABLE_ERROR = 15024 | XEvent.Severity.Error,
            XBOS_CONTENT_DETAILS_ERROR = 15025 | XEvent.Severity.Error,
            XBOS_CONTENT_ENUMERATE_ERROR = 15026 | XEvent.Severity.Error,
            XBOS_CONTENT_REFERRAL_ERROR = 15027 | XEvent.Severity.Error,
            XBOS_VERIFY_NICKNAME_ERROR = 15028 | XEvent.Severity.Error,
            XBOS_AUTOUPD_REFERRAL_ERROR = 15029 | XEvent.Severity.Error,
            XBOS_OFFERING_DETAILS_ERROR = 15030 | XEvent.Severity.Error,
            XBOS_OFFERING_DETAILS_NO_USER_ERROR = 15031 | XEvent.Severity.Error,
            XBOS_ASSET_CONSUME_ERROR = 15032 | XEvent.Severity.Error,
            XBOS_ASSET_ENUMERATE_ERROR = 15033 | XEvent.Severity.Error,
            XBOS_FIND_MEDIA_INSTANCE_URLS_ERROR = 15034 | XEvent.Severity.Error,
            XBOS_OFFER_PURCHASE_GAMERTAG_ERROR = 15035 | XEvent.Severity.Error,
            XBOS_CONTENT_REFRESH_LICENSE_ERROR = 15036 | XEvent.Severity.Error,
            XBOS_GET_TITLE_ACTIVATION_LIST_ERROR = 15037 | XEvent.Severity.Error,
            XBOS_GET_TITLE_DETAILS_ERROR = 15038 | XEvent.Severity.Error,
            XBOS_CONTENT_UPDATE_ACCESS_TIMES_ERROR = 15039 | XEvent.Severity.Error,
            XBOS_CONTENT_HISTORY_ENUMERATE_ERROR = 15040 | XEvent.Severity.Error,
            XBOS_ENUMERATE_GENRES_ERROR = 15041 | XEvent.Severity.Error,
            XBOS_ENUMERATE_TITLES_BY_FILTER_ERROR = 15042 | XEvent.Severity.Error,
            XBOS_GET_REVOCATION_LIST_ERROR = 15043 | XEvent.Severity.Error,
            XBOS_OFFERING_VERIFY_TOKEN_ERROR = 15044 | XEvent.Severity.Error,
            XBOS_SIGN_ASSETS_ERROR = 15045 | XEvent.Severity.Error,
            XBOS_CREATE_CERTIFICATE_ERROR = 15046 | XEvent.Severity.Error,
            XBOS_GET_POINTS_PURCHASE_STATUS_ERROR = 15047 | XEvent.Severity.Error,
            XBOS_OFFER_PURCHASE_PLATFORM_ERROR = 15048 | XEvent.Severity.Error,
            XBOS_OFFER_PURCHASE_OFFERID_ERROR = 15049 | XEvent.Severity.Error,
            XBOS_OFFER_PURCHASE_DEVICEID_ERROR = 15050 | XEvent.Severity.Error,
            XBOS_SCS_GET_FAILED_SUBMIT_ORDER_FAILURE = 15051 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_GET_PENDING_TRANSACTION_FAILURE = 15052 | XEvent.Severity.Error,
            XBOS_CTP_QUEUE_RETRY_FAILED = 15053 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_QUEUE_IMPERSONATION_UNDO_ERROR = 15054 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_QUEUE_PUMP_ERROR = 15055 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_QUEUE_TIMER_RESET_ERROR = 15056 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_QUEUE_GET_RETRY_COUNT_FAILURE = 15057 | XEvent.Severity.Error,
            XBOS_CTP_PURCHASE_QUEUE_UPDATE_STATUS_FAILURE = 15058 | XEvent.Severity.Error,
            XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE = 15059 | XEvent.Severity.Error,
            XONLINE_E_BILLING_SUBSCRIPTION_UTILS_ERROR = 15061 | XEvent.Severity.Error,
            XONLINE_E_SUBSCRIPTION_ENUMERATE_FLUSH_ERROR = 15060 | XEvent.Severity.Error,
            BILLING_CODE_0 = 50425 | XEvent.Severity.Error,
            BILLING_CODE_2 = 50427 | XEvent.Severity.Error,
            BILLING_CODE_3 = 50428 | XEvent.Severity.Error,
            BILLING_CODE_5 = 50430 | XEvent.Severity.Error,
            BILLING_CODE_7 = 50432 | XEvent.Severity.Error,
            BILLING_CODE_8 = 50433 | XEvent.Severity.Error,
            BILLING_CODE_14 = 50439 | XEvent.Severity.Error,
            BILLING_CODE_16 = 50441 | XEvent.Severity.Error,
            BILLING_CODE_18 = 50443 | XEvent.Severity.Error,
            BILLING_CODE_19 = 50444 | XEvent.Severity.Error,
            BILLING_CODE_20 = 50445 | XEvent.Severity.Error,
            BILLING_CODE_21 = 50446 | XEvent.Severity.Error,
            BILLING_CODE_22 = 50447 | XEvent.Severity.Error,
            BILLING_CODE_23 = 50448 | XEvent.Severity.Error,
            BILLING_CODE_24 = 50449 | XEvent.Severity.Error,
            BILLING_CODE_25 = 50450 | XEvent.Severity.Error,
            BILLING_CODE_26 = 50451 | XEvent.Severity.Error,
            BILLING_CODE_27 = 50452 | XEvent.Severity.Error,
            BILLING_CODE_28 = 50453 | XEvent.Severity.Error,
            BILLING_CODE_29 = 50454 | XEvent.Severity.Error,
            BILLING_CODE_32 = 50457 | XEvent.Severity.Error,
            BILLING_CODE_33 = 50458 | XEvent.Severity.Error,
            BILLING_CODE_34 = 50459 | XEvent.Severity.Error,
            BILLING_CODE_35 = 50460 | XEvent.Severity.Error,
            BILLING_CODE_36 = 50461 | XEvent.Severity.Error,
            BILLING_CODE_37 = 50462 | XEvent.Severity.Error,
            BILLING_CODE_38 = 50463 | XEvent.Severity.Error,
            BILLING_CODE_39 = 50464 | XEvent.Severity.Error,
            BILLING_CODE_40 = 50465 | XEvent.Severity.Error,
            BILLING_CODE_41 = 50466 | XEvent.Severity.Error,
            BILLING_CODE_42 = 50467 | XEvent.Severity.Error,
            BILLING_CODE_43 = 50468 | XEvent.Severity.Error,
            BILLING_CODE_44 = 50469 | XEvent.Severity.Error,
            BILLING_CODE_45 = 50470 | XEvent.Severity.Error,
            BILLING_CODE_46 = 50471 | XEvent.Severity.Error,
            BILLING_CODE_47 = 50472 | XEvent.Severity.Error,
            BILLING_CODE_48 = 50473 | XEvent.Severity.Error,
            BILLING_CODE_51 = 50476 | XEvent.Severity.Error,
            BILLING_CODE_52 = 50477 | XEvent.Severity.Error,
            BILLING_CODE_53 = 50478 | XEvent.Severity.Error,
            BILLING_CODE_54 = 50479 | XEvent.Severity.Error,
            BILLING_CODE_55 = 50480 | XEvent.Severity.Error,
            BILLING_CODE_56 = 50481 | XEvent.Severity.Error,
            BILLING_CODE_57 = 50482 | XEvent.Severity.Error,
            BILLING_CODE_58 = 50483 | XEvent.Severity.Error,
            BILLING_CODE_59 = 50484 | XEvent.Severity.Error,
            BILLING_CODE_60 = 50485 | XEvent.Severity.Error,
            BILLING_CODE_61 = 50486 | XEvent.Severity.Error,
            BILLING_CODE_62 = 50487 | XEvent.Severity.Error,
            BILLING_CODE_63 = 50488 | XEvent.Severity.Error,
            BILLING_CODE_64 = 50489 | XEvent.Severity.Error,
            BILLING_CODE_66 = 50491 | XEvent.Severity.Error,
            BILLING_CODE_67 = 50492 | XEvent.Severity.Error,
            PURCHASE_OFFERS_CLIENT_PRICE_MISMATCH = 50501 | XEvent.Severity.Error,
            PURCHASE_OFFERS_MEDIA_INSTANCE_NOT_ACQUIRABLE = 50502 | XEvent.Severity.Error,
            PURCHASE_OFFERS_INVALID_ARG = 50503 | XEvent.Severity.Error,
            BILLING_NOT_XENON_USER = 50504 | XEvent.Severity.Error,
            PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION = 50505 | XEvent.Severity.Error,
            BILLING_AUTHDATA_VERIFICATION_ERROR_1 = 50506 | XEvent.Severity.Error,
            BILLING_AUTHDATA_VERIFICATION_ERROR_2 = 50507 | XEvent.Severity.Error,
            PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED = 50508 | XEvent.Severity.Error,
            PURCHASE_OFFERS_TOO_MANY_ZERO_POINT_EDITORIAL_PURCHASES = 50509 | XEvent.Severity.Error,
            OFFER_PURCHASE_INVALID_PAYMENT_TYPE = 50510 | XEvent.Severity.Error,
            PURCHASE_OFFERS_MEDIA_TYPE_MISMATCH = 50511 | XEvent.Severity.Error,
            PURCHASE_HISTORY_FLUSH_ERROR = 50512 | XEvent.Severity.Error,
            OFFER_PURCHASE_INVALID_PLATFORM_TYPE = 50513 | XEvent.Severity.Error,
            BILLING_COMM_0 = 50525 | XEvent.Severity.Error,
            BILLING_COMM_3 = 50528 | XEvent.Severity.Error,
            BILLING_COMM_4 = 50529 | XEvent.Severity.Error,
            BILLING_COMM_5 = 50530 | XEvent.Severity.Error,
            BILLING_COMM_7 = 50532 | XEvent.Severity.Error,
            BILLING_COMM_8 = 50533 | XEvent.Severity.Error,
            XBOS_AUTOUPD_REFERRAL_NO_LOCATIONS = 50552 | XEvent.Severity.Error,
            BILLING_CONFIG_7 = 50557 | XEvent.Severity.Error,
            BILLING_CONFIG_8 = 50558 | XEvent.Severity.Error,
            BILLING_CONFIG_9 = 50559 | XEvent.Severity.Error,
            BILLING_CONFIG_11 = 50561 | XEvent.Severity.Error,
            BILLING_CONFIG_12 = 50562 | XEvent.Severity.Error,
            BILLING_CONFIG_13 = 50563 | XEvent.Severity.Warning,
            BILLING_CONFIG_14 = 50564 | XEvent.Severity.Warning,
            BILLING_CONFIG_15 = 50565 | XEvent.Severity.Error,
            BILLING_CONFIG_19 = 50569 | XEvent.Severity.Warning,
            BILLING_CONFIG_20 = 50570 | XEvent.Severity.Error,
            BILLING_CONFIG_21 = 50571 | XEvent.Severity.Error,
            BILLING_CONFIG_22 = 50572 | XEvent.Severity.Error,
            BILLING_CONFIG_23 = 50573 | XEvent.Severity.Warning,
            BILLING_CONFIG_24 = 50574 | XEvent.Severity.Error,
            BILLING_CONFIG_26 = 50576 | XEvent.Severity.Error,
            BILLING_CONFIG_27 = 50577 | XEvent.Severity.Warning,
            BILLING_CONFIG_28 = 50578 | XEvent.Severity.Warning,
            BILLING_CONFIG_29 = 50579 | XEvent.Severity.Error,
            BILLING_CONFIG_30 = 50580 | XEvent.Severity.Error,
            BILLING_CONFIG_31 = 50581 | XEvent.Severity.Error,
            BILLING_OFFERING_DMP_INIT_FAILED = 50584 | XEvent.Severity.Error,
            BILLING_OFFERING_WMIS_INIT_FAILED = 50585 | XEvent.Severity.Error,
            BILLING_OFFERING_XBOSMGMT_INIT_FAILED = 50586 | XEvent.Severity.Error,
            BILLING_OFFERING_MUSICNET_INIT_FAILED = 50587 | XEvent.Severity.Error,
            BILLING_OFFERING_BANNER_LIST_INIT_FAILED = 50589 | XEvent.Severity.Error,
            XBOS_PURCHASE_HACK = 50650 | XEvent.Severity.Warning,
            BILLING_HACK_1 = 50651 | XEvent.Severity.Warning,
            BILLING_HACK_2 = 50652 | XEvent.Severity.Warning,
            BILLING_HACK_3 = 50653 | XEvent.Severity.Warning,
            BILLING_HACK_4 = 50654 | XEvent.Severity.Warning,
            BILLING_HACK_7 = 50657 | XEvent.Severity.Warning,
            BILLING_HACK_14 = 50664 | XEvent.Severity.Warning,
            BILLING_HACK_15 = 50665 | XEvent.Severity.Warning,
            BILLING_HACK_16 = 50666 | XEvent.Severity.Warning,
            BILLING_HACK_17 = 50667 | XEvent.Severity.Warning,
            BILLING_HACK_18 = 50668 | XEvent.Severity.Warning,
            BILLING_HACK_19 = 50669 | XEvent.Severity.Warning,
            BILLING_HACK_20 = 50670 | XEvent.Severity.Warning,
            BILLING_HACK_UNKNOWN_OFFER_TYPE = 50671 | XEvent.Severity.Warning,
            BILLING_HACK_UNKNOWN_PAYMENT_TYPE = 50672 | XEvent.Severity.Warning,
            BILLING_INFO_0 = 50700 | XEvent.Severity.Info,
            BILLING_INFO_1 = 50701 | XEvent.Severity.Info,
            XBOS_OFFER_INELIGIBLE_FOR_PURCHASE = 50702 | XEvent.Severity.Info,
            XBOS_OFFER_INELIGIBLE_FOR_PURCHASE_1 = 50703 | XEvent.Severity.Info,
            BILLING_INFO_4 = 50704 | XEvent.Severity.Info,
            BILLING_OFFERING_CANCEL_ERROR = 64000 | XEvent.Severity.Error,
            BILLING_OFFERING_PURCHASE_OFFERS_ERROR = 64001 | XEvent.Severity.Error,
            BILLING_OFFERING_PURCHASE_BILLING_OFFER_ERROR = 64002 | XEvent.Severity.Error,
            BILLING_OFFERING_SUBSCRIPTION_ENUMERATE_ERROR = 64003 | XEvent.Severity.Error,
            BILLING_OFFERING_UPDATE_PROFILE_ERROR = 64004 | XEvent.Severity.Error,
            PURCHASE_OFFERS_INVALID_OFFER_TYPE = 64005 | XEvent.Severity.Error,
            PURCHASE_OFFERS_CTP_TRANSACTIONSERVICE_TIMEOUT = 64006 | XEvent.Severity.Error,
            PURCHASE_OFFERS_INVALID_RENEWAL_PATH = 64007 | XEvent.Severity.Error,
            PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_TIMEEXTENSION = 64008 | XEvent.Severity.Error,
            PURCHASE_OFFERS_SUBSCRIPTION_REINSTATE_ERROR = 64009 | XEvent.Severity.Error,
            PURCHASE_OFFERS_SUBSCRIPTION_PENDINGMOVE_ERROR = 64010 | XEvent.Severity.Error,
            PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_PRICE = 64011 | XEvent.Severity.Error,
            PURCHASE_OFFERS_SUBSCRIPTION_PENDING_MOVE_ERROR = 64012 | XEvent.Severity.Error,
            XCACHE_STARTED = 20010 | XEvent.Severity.Info,
            XCACHE_SHUTDOWN = 20011 | XEvent.Severity.Info,
            XCACHE_STARTUP_FAILURE = 20012 | XEvent.Severity.Error,
            XCACHE_SHUTDOWN_STARTED = 20013 | XEvent.Severity.Info,
            XCACHE_SHUTDOWN_FAILURE = 20014 | XEvent.Severity.Info,
            XCACHE_MSG_TOO_BIG = 20020 | XEvent.Severity.Error,
            XCACHE_PROTOCOL_ERROR = 20021 | XEvent.Severity.Error,
            XCACHE_UNKNOWN_LOOKUP_TYPE = 20022 | XEvent.Severity.Error,
            XCACHE_CONTEXT_EXCEPTION = 20030 | XEvent.Severity.Error,
            XCACHE_THREADPOOL_EXCEPTION = 20031 | XEvent.Severity.Warning,
            XCACHE_DBREADER_INIT_FAIL = 20040 | XEvent.Severity.Error,
            XCACHE_DBREADER_INVALID_PARTITION_COUNT = 20041 | XEvent.Severity.Error,
            XCACHE_DBREADER_READ_FAIL = 20042 | XEvent.Severity.Error,
            XCACHE_DBTHREAD_EXCEPTION = 20043 | XEvent.Severity.Warning,
            XCACHE_INIT_COMPLETE = 61900 | XEvent.Severity.Info,
            XCONNSRV_STARTED = 20000 | XEvent.Severity.Info,
            XCONNSRV_SHUTDOWN = 20001 | XEvent.Severity.Info,
            XCONNSRV_STARTUP_FAILURE = 20002 | XEvent.Severity.Error,
            XCONNSRV_PROTOCOL_VERSION_MISMATCH = 20003 | XEvent.Severity.Error,
            XCONNSRV_MSGTYPE_UNKNOWN = 20004 | XEvent.Severity.Error,
            XCONNSRV_MSG_BEFORE_CONNECT = 20005 | XEvent.Severity.Error,
            XCONNSRV_USER_INDEX_MISMATCH = 20006 | XEvent.Severity.Error,
            XCONNSRV_MSG_TOO_SMALL = 20007 | XEvent.Severity.Error,
            XCONNSRV_INVALID_USER_FLAGS = 20008 | XEvent.Severity.Error,
            XCONNSRV_TOO_MANY_USER_FLAGS = 20009 | XEvent.Severity.Error,
            XCONNSRV_NUM_USER_FLAGS_MISMATCH = 20010 | XEvent.Severity.Error,
            XCONNSRV_MSGTYPE_UNSUPPORTED = 20011 | XEvent.Severity.Error,
            XCONNSRV_MSG_TOO_BIG = 20012 | XEvent.Severity.Error,
            XCONNSRV_SGINFO_ERROR = 20013 | XEvent.Severity.Error,
            XCONNSRV_USER_NOT_PRESENT = 20014 | XEvent.Severity.Error,
            XCONNSRV_CONTEXT_EXCEPTION = 20015 | XEvent.Severity.Error,
            XCONNSRV_DATA_TOO_SMALL = 20016 | XEvent.Severity.Error,
            XCONNSRV_DATA_INTEGRITY_ERROR = 20017 | XEvent.Severity.Error,
            XCONNSRV_VELOCITY_NOTIFICATION_FAILURE = 20018 | XEvent.Severity.Error,
            XCONNSRV_TOO_MANY_OBJECTS = 20019 | XEvent.Severity.Error,
            XCONNSRV_TOO_MANY_SUBSCRIPTIONS = 20020 | XEvent.Severity.Error,
            XCONNSRV_EXCEPTION_WOULD_DEADLOCK = 20021 | XEvent.Severity.Warning,
            XCONNSRV_THREADPOOL_EXCEPTION = 20022 | XEvent.Severity.Warning,
            XCONNSRV_NOTIFICATION_FORMATTING_ERROR = 20023 | XEvent.Severity.Error,
            XCONNSRV_DUPLICATE_USER = 20024 | XEvent.Severity.Error,
            XCRYPTO_INIT_SUCCESS = 40000 | XEvent.Severity.Info,
            XCRYPTO_CONFIG_ERROR = 40001 | XEvent.Severity.Error,
            XCRYPTO_REQUEST_FAILED = 40002 | XEvent.Severity.Error,
            XCRYPTO_CRYPTO_KEY_ERROR = 63875 | XEvent.Severity.Error,
            XCRYPTO_GENERIC_ERROR = 63876 | XEvent.Severity.Error,
            XCRYPTO_NCIPHER_ERROR = 63877 | XEvent.Severity.Error,
            XCRYPTO_PROXY_FAILED = 63900 | XEvent.Severity.Error,
            XCRYPTO_PROXY_BUFFER_TOO_SMALL = 63901 | XEvent.Severity.Error,
            XKDC_FLASH_VERSION_ROLLED_BACK = 10000 | XEvent.Severity.Warning,
            XKDC_CONSOLE_REGION_CHANGED = 10001 | XEvent.Severity.Warning,
            XKDC_FLASH_MULTIPLE_GROUPS = 10002 | XEvent.Severity.Error,
            XKDC_TITLE_MULTIPLE_GROUPS = 10003 | XEvent.Severity.Error,
            XKDC_SERVICE_ID_INVALID = 10004 | XEvent.Severity.Error,
            XKDC_TITLE_BAD_START_END_TIME = 10005 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_PARSE_HEX_VALUES = 10006 | XEvent.Severity.Error,
            XKDC_FAILURE_PARSE_LEGACY_PC_TITLES = 10007 | XEvent.Severity.Error,
            XKDC_INVALID_SERVICE_REQUEST_VERSION = 10008 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER = 53316 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_1 = 53317 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_2 = 53318 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_3 = 53319 | XEvent.Severity.Error,
            KDC_CODE_95 = 53320 | XEvent.Severity.Error,
            KDC_CODE_96 = 53321 | XEvent.Severity.Error,
            XKDC_NO_MEMORY = 53322 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_1 = 53323 | XEvent.Severity.Error,
            KDC_CODE_99 = 53324 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_4 = 53325 | XEvent.Severity.Error,
            XKDC_CHECKSUM_OVERFLOW = 53326 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_2 = 53327 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_3 = 53328 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_4 = 53329 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_5 = 53330 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_5 = 53331 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_6 = 53332 | XEvent.Severity.Error,
            KDC_CODE_108 = 53333 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_7 = 53334 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR = 53335 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_1 = 53336 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_2 = 53337 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_3 = 53338 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_4 = 53339 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_5 = 53340 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_6 = 53341 | XEvent.Severity.Error,
            XKDC_UODB_MISMATCH = 53342 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_7 = 53343 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_8 = 53344 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_9 = 53345 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_10 = 53346 | XEvent.Severity.Error,
            KDC_CODE_125 = 53350 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_8 = 53351 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_9 = 53352 | XEvent.Severity.Error,
            KDC_CODE_128 = 53353 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_10 = 53354 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_11 = 53355 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_30 = 53356 | XEvent.Severity.Error,
            KDC_CODE_132 = 53357 | XEvent.Severity.Error,
            KDC_CODE_133 = 53358 | XEvent.Severity.Error,
            XKDC_POLICY_BAD_PARAMETER = 53359 | XEvent.Severity.Error,
            XKDC_DB_GETMACHINEAUTH_NOTFOUND = 53360 | XEvent.Severity.Error,
            XKDC_DB_GETUSERAUTH_NOTFOUND = 53361 | XEvent.Severity.Error,
            XKDC_DB_GETMACHINEAUTH_ERROR = 53362 | XEvent.Severity.Error,
            XKDC_DB_GETUSERAUTH_ERROR = 53363 | XEvent.Severity.Error,
            XKDC_DOSCACHE_NORECORD = 53364 | XEvent.Severity.Error,
            XKDC_DOSCACHE_RELEASE_ERROR = 53365 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_12 = 53417 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_13 = 53418 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_14 = 53419 | XEvent.Severity.Error,
            KDC_CODE_195 = 53420 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_15 = 53421 | XEvent.Severity.Error,
            KDC_CODE_197 = 53422 | XEvent.Severity.Error,
            KDC_CODE_198 = 53423 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_16 = 53424 | XEvent.Severity.Error,
            KDC_CODE_200 = 53425 | XEvent.Severity.Error,
            KDC_CODE_201 = 53426 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_6 = 53427 | XEvent.Severity.Error,
            KDC_CODE_203 = 53428 | XEvent.Severity.Error,
            KDC_CODE_204 = 53429 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_17 = 53430 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_18 = 53431 | XEvent.Severity.Error,
            KDC_CODE_207 = 53432 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_19 = 53433 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_20 = 53434 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_7 = 53435 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_8 = 53436 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_9 = 53437 | XEvent.Severity.Error,
            KDC_CODE_213 = 53438 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_10 = 53439 | XEvent.Severity.Error,
            KDC_CODE_215 = 53440 | XEvent.Severity.Error,
            KDC_CODE_216 = 53441 | XEvent.Severity.Error,
            KDC_CODE_217 = 53442 | XEvent.Severity.Error,
            KDC_CODE_218 = 53443 | XEvent.Severity.Error,
            KDC_CODE_219 = 53444 | XEvent.Severity.Error,
            KDC_CODE_220 = 53445 | XEvent.Severity.Error,
            KDC_CODE_221 = 53446 | XEvent.Severity.Error,
            KDC_CODE_222 = 53447 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_21 = 53448 | XEvent.Severity.Error,
            KDC_CODE_224 = 53449 | XEvent.Severity.Error,
            KDC_CODE_225 = 53450 | XEvent.Severity.Error,
            KDC_CODE_226 = 53451 | XEvent.Severity.Error,
            KDC_CODE_227 = 53452 | XEvent.Severity.Error,
            KDC_CODE_228 = 53453 | XEvent.Severity.Error,
            KDC_CODE_229 = 53454 | XEvent.Severity.Error,
            KDC_CODE_230 = 53455 | XEvent.Severity.Error,
            KDC_CODE_231 = 53456 | XEvent.Severity.Error,
            KDC_CODE_232 = 53457 | XEvent.Severity.Error,
            KDC_CODE_233 = 53458 | XEvent.Severity.Error,
            KDC_CODE_234 = 53459 | XEvent.Severity.Error,
            KDC_CODE_235 = 53460 | XEvent.Severity.Error,
            KDC_CODE_236 = 53461 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_22 = 53462 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_11 = 53463 | XEvent.Severity.Error,
            KDC_CODE_239 = 53464 | XEvent.Severity.Error,
            KDC_CODE_240 = 53465 | XEvent.Severity.Error,
            KDC_CODE_241 = 53466 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_31 = 53467 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_11 = 53468 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_12 = 53469 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_12 = 53470 | XEvent.Severity.Error,
            XKDC_UODB_MISMATCH_1 = 53471 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_13 = 53472 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_13 = 53473 | XEvent.Severity.Error,
            XKDC_UODB_MISMATCH_2 = 53474 | XEvent.Severity.Error,
            KDC_CODE_250 = 53475 | XEvent.Severity.Error,
            KDC_CODE_251 = 53476 | XEvent.Severity.Error,
            ASKDC_NO_MEMORY_32 = 53477 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_14 = 53478 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_14 = 53479 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_15 = 53480 | XEvent.Severity.Error,
            XKDC_UODB_MISMATCH_3 = 53481 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_16 = 53482 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_15 = 53483 | XEvent.Severity.Error,
            KDC_CODE_259 = 53484 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_17 = 53485 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_18 = 53486 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_19 = 53487 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_20 = 53488 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_21 = 53489 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_22 = 53490 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_23 = 53491 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_24 = 53492 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_25 = 53493 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_26 = 53494 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_27 = 53495 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_28 = 53496 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_29 = 53497 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_30 = 53498 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_31 = 53499 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_32 = 53500 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_33 = 53501 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_34 = 53502 | XEvent.Severity.Error,
            KDC_CODE_278 = 53503 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_35 = 53504 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_36 = 53505 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_37 = 53506 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_38 = 53507 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_39 = 53508 | XEvent.Severity.Error,
            XKDC_WSREADER_ERROR_40 = 53509 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_16 = 53510 | XEvent.Severity.Error,
            KDC_CODE_286 = 53511 | XEvent.Severity.Error,
            KDC_CODE_287 = 53512 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_23 = 53513 | XEvent.Severity.Error,
            KDC_CODE_289 = 53514 | XEvent.Severity.Error,
            KDC_CODE_290 = 53515 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_24 = 53516 | XEvent.Severity.Error,
            KDC_CODE_292 = 53517 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_25 = 53518 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_17 = 53519 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_26 = 53520 | XEvent.Severity.Error,
            XKDC_BAD_PARAMETER_27 = 53521 | XEvent.Severity.Error,
            XKDC_CODE_TOO_MANY_DWORD_SERVICES = 53671 | XEvent.Severity.Error,
            XKDC_REQUEST_INVALID_1 = 53677 | XEvent.Severity.Error,
            XKDC_INIT_WARNING = 54225 | XEvent.Severity.Error,
            XKDC_INIT_WARNING_1 = 54226 | XEvent.Severity.Error,
            XKDC_RELOAD_FAIL = 54234 | XEvent.Severity.Error,
            KDC_CONFIG_32 = 54282 | XEvent.Severity.Error,
            XKDC_DOS_CACHE_TOO_SMALL = 54283 | XEvent.Severity.Error,
            XKDC_DOS_CACHE_TOO_SMALL_1 = 54284 | XEvent.Severity.Error,
            XKDC_UNKNOWN_XBOX = 54285 | XEvent.Severity.Warning,
            KDC_CONFIG_36 = 54286 | XEvent.Severity.Error,
            KDC_CONFIG_37 = 54287 | XEvent.Severity.Error,
            DEPRECATED_XKDC_BAD_TITLEID = 54288 | XEvent.Severity.Error,
            KDC_CONFIG_39 = 54289 | XEvent.Severity.Error,
            KDC_CONFIG_40 = 54290 | XEvent.Severity.Error,
            XKDC_REGISTER_FAILURE = 54291 | XEvent.Severity.Error,
            XKDC_REGISTER_FAILURE_1 = 54292 | XEvent.Severity.Error,
            XKDC_REGISTER_FAILURE_2 = 54293 | XEvent.Severity.Error,
            XKDC_REGISTER_FAILURE_3 = 54294 | XEvent.Severity.Error,
            KDC_CONFIG_45 = 54295 | XEvent.Severity.Error,
            XKDC_INIT_FAILURE = 54296 | XEvent.Severity.Error,
            XKDC_INIT_FAILURE_1 = 54297 | XEvent.Severity.Error,
            KDC_CONFIG_48 = 54298 | XEvent.Severity.Error,
            XKDC_INIT_FAILURE_2 = 54299 | XEvent.Severity.Error,
            XKDC_INIT_FAILURE_3 = 54300 | XEvent.Severity.Error,
            DEPRECATED_XKDC_INIT_FAILURE_4 = 54301 | XEvent.Severity.Error,
            XKDC_BAD_TITLEID_1 = 54302 | XEvent.Severity.Error,
            KDC_CONFIG_53 = 54303 | XEvent.Severity.Error,
            XKDC_DECRYPTION_FAILED = 54304 | XEvent.Severity.Error,
            XKDC_MISMATCHED_CLIENT_VERSION = 54371 | XEvent.Severity.Error,
            XKDC_DYNAMIC_CONFIG_INIT_ERROR = 54374 | XEvent.Severity.Error,
            XKDC_NO_MEMORY_18 = 54375 | XEvent.Severity.Error,
            XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IPSTR = 54376 | XEvent.Severity.Error,
            XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IP = 54377 | XEvent.Severity.Error,
            XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_NONE = 54378 | XEvent.Severity.Error,
            XKDC_FAILED_TO_PARSE_SITE1_IPSTR = 54379 | XEvent.Severity.Error,
            XKDC_FAILED_TO_PARSE_SITE1_IP = 54380 | XEvent.Severity.Error,
            XKDC_INFO_SITE1_IPS = 54381 | XEvent.Severity.Info,
            XKDC_NO_MEMORY_SITE1_IPS = 54382 | XEvent.Severity.Error,
            KDC_HACK_9 = 54659 | XEvent.Severity.Warning,
            KDC_HACK_10 = 54660 | XEvent.Severity.Warning,
            KDC_HACK_11 = 54661 | XEvent.Severity.Warning,
            KDC_HACK_12 = 54662 | XEvent.Severity.Warning,
            KDC_HACK_13 = 54663 | XEvent.Severity.Warning,
            XKDC_NO_SERVICES = 54664 | XEvent.Severity.Warning,
            KDC_HACK_15 = 54665 | XEvent.Severity.Warning,
            KDC_HACK_16 = 54666 | XEvent.Severity.Warning,
            XKDC_AS_REQUEST = 54667 | XEvent.Severity.Warning,
            KDC_HACK_18 = 54668 | XEvent.Severity.Warning,
            XKDC_BAD_REQUEST = 54669 | XEvent.Severity.Warning,
            XKDC_NO_SERVICES_1 = 54670 | XEvent.Severity.Warning,
            KDC_HACK_21 = 54671 | XEvent.Severity.Warning,
            KDC_HACK_22 = 54672 | XEvent.Severity.Warning,
            KDC_HACK_23 = 54673 | XEvent.Severity.Warning,
            KDC_HACK_24 = 54674 | XEvent.Severity.Warning,
            XKDC_AS_REQUEST_1 = 54675 | XEvent.Severity.Warning,
            KDC_HACK_26 = 54676 | XEvent.Severity.Warning,
            KDC_HACK_27 = 54677 | XEvent.Severity.Warning,
            KDC_HACK_28 = 54678 | XEvent.Severity.Warning,
            KDC_HACK_29 = 54679 | XEvent.Severity.Warning,
            XKDC_HACK_DOS_ATTACK = 54708 | XEvent.Severity.Warning,
            XKDC_HACK_INVALID_PRE_AUTH_TYPE = 54714 | XEvent.Severity.Warning,
            XKDC_REGISTER_SUCCESS = 54760 | XEvent.Severity.Info,
            XKDC_REGISTER_SUCCESS_1 = 54761 | XEvent.Severity.Info,
            XKDC_INIT_SUCCESS = 54762 | XEvent.Severity.Info,
            XKDC_TERM_SUCCESS = 54763 | XEvent.Severity.Info,
            XKDC_RELOAD_SUCCESS = 54764 | XEvent.Severity.Info,
            KDC_INFO_15 = 54765 | XEvent.Severity.Info,
            XDS_CONFIG_HEALTHINTEROP_CREATE = 20000 | XEvent.Severity.Error,
            XDS_CONFIG_HEALTHINTEROP_INIT = 20001 | XEvent.Severity.Error,
            XDS_CODE_0 = 62100 | XEvent.Severity.Error,
            XDS_CODE_1 = 62101 | XEvent.Severity.Error,
            XDS_CODE_2 = 62102 | XEvent.Severity.Error,
            XDS_CODE_3 = 62103 | XEvent.Severity.Error,
            XDS_CODE_4 = 62104 | XEvent.Severity.Error,
            XDS_CODE_5 = 62105 | XEvent.Severity.Error,
            XDS_CODE_6 = 62106 | XEvent.Severity.Error,
            XDS_CODE_7 = 62107 | XEvent.Severity.Error,
            XDS_CODE_8 = 62108 | XEvent.Severity.Error,
            XDS_CODE_9 = 62109 | XEvent.Severity.Error,
            XDS_CODE_10 = 62110 | XEvent.Severity.Error,
            XDS_CODE_11 = 62111 | XEvent.Severity.Error,
            XDS_CODE_12 = 62112 | XEvent.Severity.Error,
            XDS_CODE_13 = 62113 | XEvent.Severity.Error,
            XDS_CODE_14 = 62114 | XEvent.Severity.Error,
            XDS_CODE_15 = 62115 | XEvent.Severity.Error,
            XDS_CODE_16 = 62116 | XEvent.Severity.Error,
            XDS_CODE_17 = 62117 | XEvent.Severity.Error,
            XDS_CODE_18 = 62118 | XEvent.Severity.Error,
            XDS_CODE_19 = 62119 | XEvent.Severity.Error,
            XDS_CODE_20 = 62120 | XEvent.Severity.Error,
            XDS_CODE_21 = 62121 | XEvent.Severity.Error,
            XDS_CODE_22 = 62122 | XEvent.Severity.Error,
            XDS_CODE_23 = 62123 | XEvent.Severity.Error,
            XDS_CODE_24 = 62124 | XEvent.Severity.Error,
            XDS_CODE_25 = 62125 | XEvent.Severity.Error,
            XDS_CODE_26 = 62126 | XEvent.Severity.Error,
            XDS_CODE_27 = 62127 | XEvent.Severity.Error,
            XDS_CODE_28 = 62128 | XEvent.Severity.Error,
            XDS_CODE_29 = 62129 | XEvent.Severity.Error,
            XDS_CODE_30 = 62130 | XEvent.Severity.Error,
            XDS_CODE_31 = 62131 | XEvent.Severity.Error,
            XDS_CODE_32 = 62132 | XEvent.Severity.Error,
            XDS_CODE_33 = 62133 | XEvent.Severity.Error,
            XDS_CODE_34 = 62134 | XEvent.Severity.Error,
            XDS_CODE_35 = 62135 | XEvent.Severity.Error,
            XDS_CODE_36 = 62136 | XEvent.Severity.Error,
            XDS_CODE_37 = 62137 | XEvent.Severity.Error,
            XDS_CODE_38 = 62138 | XEvent.Severity.Error,
            XDS_CODE_39 = 62139 | XEvent.Severity.Error,
            XDS_CODE_40 = 62140 | XEvent.Severity.Error,
            XDS_CODE_41 = 62141 | XEvent.Severity.Error,
            XDS_CODE_42 = 62142 | XEvent.Severity.Error,
            XDS_CODE_43 = 62143 | XEvent.Severity.Error,
            XDS_CODE_44 = 62144 | XEvent.Severity.Error,
            XDS_CODE_45 = 62145 | XEvent.Severity.Error,
            XDS_CODE_46 = 62146 | XEvent.Severity.Error,
            XDS_CODE_47 = 62147 | XEvent.Severity.Error,
            XDS_CODE_48 = 62148 | XEvent.Severity.Error,
            XDS_CODE_49 = 62149 | XEvent.Severity.Error,
            XDS_CODE_50 = 62150 | XEvent.Severity.Error,
            XDS_CODE_51 = 62151 | XEvent.Severity.Error,
            XDS_CODE_52 = 62152 | XEvent.Severity.Error,
            XDS_CODE_53 = 62153 | XEvent.Severity.Error,
            XDS_CODE_54 = 62154 | XEvent.Severity.Error,
            XDS_CODE_55 = 62155 | XEvent.Severity.Error,
            XDS_CODE_56 = 62156 | XEvent.Severity.Error,
            XDS_CODE_57 = 62157 | XEvent.Severity.Error,
            XDS_CODE_58 = 62158 | XEvent.Severity.Error,
            XDS_CODE_59 = 62159 | XEvent.Severity.Error,
            XDS_CODE_60 = 62160 | XEvent.Severity.Error,
            XDS_COMM_0 = 62300 | XEvent.Severity.Error,
            XDS_CONFIG_0 = 62325 | XEvent.Severity.Error,
            XDS_CONFIG_1 = 62326 | XEvent.Severity.Error,
            XDS_CONFIG_2 = 62327 | XEvent.Severity.Error,
            XDS_CONFIG_3 = 62328 | XEvent.Severity.Error,
            XDS_CONFIG_4 = 62329 | XEvent.Severity.Error,
            XDS_CONFIG_5 = 62330 | XEvent.Severity.Error,
            XDS_HACK_0 = 62350 | XEvent.Severity.Warning,
            XDS_HACK_1 = 62351 | XEvent.Severity.Warning,
            XDS_HACK_2 = 62352 | XEvent.Severity.Warning,
            XDS_HACK_3 = 62353 | XEvent.Severity.Warning,
            XDS_HACK_4 = 62354 | XEvent.Severity.Warning,
            XDS_HACK_5 = 62355 | XEvent.Severity.Warning,
            XDS_HACK_6 = 62356 | XEvent.Severity.Warning,
            XDS_HACK_7 = 62357 | XEvent.Severity.Warning,
            XDS_HACK_8 = 62358 | XEvent.Severity.Warning,
            XDS_HACK_9 = 62359 | XEvent.Severity.Warning,
            XDS_HACK_10 = 62360 | XEvent.Severity.Warning,
            XDS_HACK_11 = 62361 | XEvent.Severity.Warning,
            XDS_HACK_12 = 62362 | XEvent.Severity.Warning,
            XDS_HACK_13 = 62363 | XEvent.Severity.Warning,
            XDS_HACK_14 = 62364 | XEvent.Severity.Warning,
            XDS_HACK_15 = 62365 | XEvent.Severity.Warning,
            XDS_HACK_16 = 62366 | XEvent.Severity.Warning,
            XDS_HACK_17 = 62367 | XEvent.Severity.Warning,
            XDS_HACK_18 = 62368 | XEvent.Severity.Warning,
            XDS_HACK_19 = 62369 | XEvent.Severity.Warning,
            XDS_HACK_20 = 62370 | XEvent.Severity.Warning,
            XDS_HACK_21 = 62371 | XEvent.Severity.Warning,
            XDS_HACK_22 = 62372 | XEvent.Severity.Warning,
            XDS_HACK_23 = 62373 | XEvent.Severity.Warning,
            XDS_HACK_24 = 62374 | XEvent.Severity.Warning,
            XDS_HACK_25 = 62375 | XEvent.Severity.Warning,
            XDS_HACK_26 = 62376 | XEvent.Severity.Warning,
            XDS_HACK_27 = 62377 | XEvent.Severity.Warning,
            XDS_HACK_28 = 62378 | XEvent.Severity.Warning,
            XDS_HACK_29 = 62379 | XEvent.Severity.Warning,
            XDS_HACK_30 = 62380 | XEvent.Severity.Warning,
            XDS_INFO_0 = 62450 | XEvent.Severity.Info,
            XDS_INFO_1 = 62451 | XEvent.Severity.Info,
            XMACS_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID = 10000 | XEvent.Severity.Warning,
            XMACS_DB_USE_VOUCHER_ERROR = 10001 | XEvent.Severity.Error,
            XMACS_DB_ACTIVATE_MACHINE_ERROR = 10002 | XEvent.Severity.Error,
            XMACS_DB_ACTIVATE_USER_ERROR = 10003 | XEvent.Severity.Error,
            XMACS_WSREADER_ERROR_1 = 10004 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING = 53522 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_1 = 53523 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_2 = 53524 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_3 = 53525 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_4 = 53526 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_5 = 53527 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_6 = 53528 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_7 = 53529 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_8 = 53530 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_9 = 53531 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_10 = 53532 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_11 = 53533 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_12 = 53534 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_13 = 53535 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_14 = 53536 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_15 = 53537 | XEvent.Severity.Error,
            XMACS_PREAUTH_DATA_CORRUPTION_WARNING = 53538 | XEvent.Severity.Error,
            XMACS_PREAUTH_DATA_CORRUPTION_WARNING_1 = 53539 | XEvent.Severity.Error,
            KDC_CODE_315 = 53540 | XEvent.Severity.Error,
            KDC_CODE_316 = 53541 | XEvent.Severity.Error,
            KDC_CODE_317 = 53542 | XEvent.Severity.Error,
            KDC_CODE_318 = 53543 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_16 = 53544 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_17 = 53545 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_18 = 53546 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_19 = 53547 | XEvent.Severity.Error,
            KDC_CODE_323 = 53548 | XEvent.Severity.Error,
            KDC_CODE_324 = 53549 | XEvent.Severity.Error,
            KDC_CODE_325 = 53550 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_20 = 53551 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_21 = 53552 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_22 = 53553 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_23 = 53554 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_24 = 53555 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_25 = 53556 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_26 = 53557 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_27 = 53558 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_28 = 53559 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_29 = 53560 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_30 = 53561 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_31 = 53562 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_32 = 53563 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_33 = 53564 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_34 = 53565 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_35 = 53566 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_36 = 53567 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_37 = 53568 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_38 = 53569 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_39 = 53570 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_40 = 53571 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_41 = 53572 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_42 = 53573 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_43 = 53574 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_44 = 53575 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_45 = 53576 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_46 = 53577 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_47 = 53578 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_48 = 53579 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_49 = 53580 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_50 = 53581 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_51 = 53582 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_52 = 53583 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_53 = 53584 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_54 = 53585 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_55 = 53586 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_56 = 53587 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_57 = 53588 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_58 = 53589 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_59 = 53590 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_60 = 53591 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_61 = 53592 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_62 = 53593 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_63 = 53594 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_64 = 53595 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_65 = 53596 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_66 = 53597 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_67 = 53598 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_68 = 53599 | XEvent.Severity.Error,
            XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE = 53600 | XEvent.Severity.Error,
            XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE_1 = 53601 | XEvent.Severity.Error,
            KDC_CODE_377 = 53602 | XEvent.Severity.Error,
            KDC_CODE_378 = 53603 | XEvent.Severity.Error,
            KDC_CODE_379 = 53604 | XEvent.Severity.Error,
            KDC_CODE_380 = 53605 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_69 = 53606 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_70 = 53607 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_71 = 53608 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_72 = 53609 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_73 = 53610 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_74 = 53611 | XEvent.Severity.Error,
            XMACS_HASH_TABLE_RESOURCE_WARNING = 53612 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_75 = 53613 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_76 = 53614 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_77 = 53615 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_78 = 53616 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_79 = 53617 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_80 = 53618 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_81 = 53619 | XEvent.Severity.Error,
            XMACS_NCIPHER_NOT_FUNCTIONING = 53620 | XEvent.Severity.Error,
            XMACS_NCIPHER_NOT_FUNCTIONING_1 = 53621 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR = 53622 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_82 = 53623 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR_1 = 53624 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR_2 = 53625 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR_3 = 53626 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_83 = 53627 | XEvent.Severity.Error,
            DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_84 = 53628 | XEvent.Severity.Error,
            DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_85 = 53629 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_86 = 53630 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_87 = 53631 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_88 = 53632 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR_4 = 53633 | XEvent.Severity.Error,
            KDC_CODE_409 = 53634 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_89 = 53635 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_90 = 53636 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_91 = 53637 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_92 = 53638 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_93 = 53639 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_94 = 53640 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_95 = 53641 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_96 = 53642 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_97 = 53643 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_98 = 53644 | XEvent.Severity.Error,
            XMACS_HASH_TABLE_RESOURCE_WARNING_1 = 53645 | XEvent.Severity.Error,
            KDC_CODE_421 = 53646 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_99 = 53647 | XEvent.Severity.Error,
            XMACS_HASH_TABLE_RESOURCE_WARNING_2 = 53648 | XEvent.Severity.Error,
            XMACS_PPALOADER_THREAD_ERROR = 53649 | XEvent.Severity.Error,
            XMACS_PPALOADER_THREAD_ERROR_1 = 53650 | XEvent.Severity.Error,
            XMACS_PPALOADER_THREAD_ERROR_2 = 53651 | XEvent.Severity.Error,
            XMACS_PUID_THREAD_ERROR_5 = 53652 | XEvent.Severity.Error,
            XMACS_GENERIC_RESOURCE_WARNING_100 = 53653 | XEvent.Severity.Error,
            KDC_CODE_429 = 53654 | XEvent.Severity.Error,
            KDC_CODE_430 = 53655 | XEvent.Severity.Error,
            KDC_CODE_431 = 53656 | XEvent.Severity.Error,
            KDC_CODE_432 = 53657 | XEvent.Severity.Error,
            XMACS_CODE_MEMORY_ALLOCATION_ERROR = 53658 | XEvent.Severity.Error,
            XMACS_CODE_FAILED_TO_ENCRYPT_REPLY = 53659 | XEvent.Severity.Error,
            XMACS_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE = 53660 | XEvent.Severity.Error,
            XMACS_CODE_MEMORY_ALLOCATION_ERROR_2 = 53661 | XEvent.Severity.Error,
            XMACS_CODE_FAILED_TO_PACK_REPLY = 53662 | XEvent.Severity.Error,
            XMACS_PC_ACCOUNT_CREATION_FAILED = 53663 | XEvent.Severity.Error,
            XMACS_FAILED_TO_INSTANTIATE_WSPARAMETERS = 53670 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_FD = 54227 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_FD_1 = 54228 | XEvent.Severity.Error,
            XMACS_GENEALOGY_ERROR = 54229 | XEvent.Severity.Error,
            XMACS_DB_PC_ACCOUNT_LOOKUP_ERROR = 54230 | XEvent.Severity.Error,
            XMACS_DB_PC_ACCOUNT_CREATE_ERROR = 54231 | XEvent.Severity.Error,
            XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR = 54232 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL = 54305 | XEvent.Severity.Error,
            KDC_CONFIG_56 = 54306 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_GENEALOGY = 54307 | XEvent.Severity.Error,
            XMACS_INVALID_GENEALOGY_DATA = 54308 | XEvent.Severity.Error,
            XMACS_REGISTER_FAILURE = 54309 | XEvent.Severity.Error,
            XMACS_REGISTER_FAILURE_1 = 54310 | XEvent.Severity.Error,
            KDC_CONFIG_61 = 54311 | XEvent.Severity.Error,
            XMACS_REGISTER_FAILURE_2 = 54312 | XEvent.Severity.Error,
            XMACS_REGISTER_FAILURE_3 = 54313 | XEvent.Severity.Error,
            KDC_CONFIG_64 = 54314 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE = 54315 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_1 = 54316 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_2 = 54317 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_3 = 54318 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_4 = 54319 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_5 = 54320 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_6 = 54321 | XEvent.Severity.Error,
            KDC_CONFIG_72 = 54322 | XEvent.Severity.Error,
            KDC_CONFIG_73 = 54323 | XEvent.Severity.Error,
            KDC_CONFIG_74 = 54324 | XEvent.Severity.Error,
            KDC_CONFIG_75 = 54325 | XEvent.Severity.Error,
            KDC_CONFIG_76 = 54326 | XEvent.Severity.Warning,
            KDC_CONFIG_77 = 54327 | XEvent.Severity.Error,
            KDC_CONFIG_78 = 54328 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_7 = 54329 | XEvent.Severity.Error,
            KDC_CONFIG_80 = 54330 | XEvent.Severity.Error,
            XMACS_INIT_FAILURE_8 = 54331 | XEvent.Severity.Error,
            KDC_CONFIG_82 = 54332 | XEvent.Severity.Warning,
            KDC_CONFIG_83 = 54333 | XEvent.Severity.Error,
            KDC_CONFIG_84 = 54334 | XEvent.Severity.Error,
            KDC_CONFIG_85 = 54335 | XEvent.Severity.Error,
            KDC_CONFIG_86 = 54336 | XEvent.Severity.Error,
            KDC_CONFIG_87 = 54337 | XEvent.Severity.Error,
            KDC_CONFIG_88 = 54338 | XEvent.Severity.Error,
            KDC_CONFIG_89 = 54339 | XEvent.Severity.Error,
            XMACS_INIT_WARNING = 54340 | XEvent.Severity.Warning,
            XMACS_INIT_FAILURE_9 = 54341 | XEvent.Severity.Error,
            KDC_CONFIG_92 = 54342 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_1 = 54343 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_2 = 54344 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_3 = 54345 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_4 = 54346 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_5 = 54347 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_6 = 54348 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_7 = 54349 | XEvent.Severity.Error,
            XMACS_INVALID_PRINCIPAL_8 = 54350 | XEvent.Severity.Error,
            KDC_CONFIG_101 = 54351 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_GENEALOGY_1 = 54352 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_GENEALOGY_2 = 54353 | XEvent.Severity.Error,
            KDC_CONFIG_104 = 54354 | XEvent.Severity.Error,
            KDC_CONFIG_105 = 54355 | XEvent.Severity.Error,
            XMACS_INVALID_GENEALOGY_DATA_1 = 54356 | XEvent.Severity.Error,
            XMACS_FAILED_NCIPHER_DECRYPTION = 54357 | XEvent.Severity.Error,
            XMACS_FAILED_NCIPHER_DECRYPTION_1 = 54358 | XEvent.Severity.Error,
            KDC_CONFIG_109 = 54359 | XEvent.Severity.Error,
            XMACS_SERVICE_KEY_FAILURE = 54360 | XEvent.Severity.Error,
            XMACS_SERVICE_KEY_FAILURE_1 = 54361 | XEvent.Severity.Error,
            XMACS_SERVICE_KEY_FAILURE_2 = 54362 | XEvent.Severity.Error,
            XMACS_SERVICE_KEY_FAILURE_3 = 54363 | XEvent.Severity.Error,
            XMACS_NO_CONNECT_GENEALOGY_3 = 54364 | XEvent.Severity.Error,
            XMACS_INVALID_GENEALOGY_DATA_2 = 54365 | XEvent.Severity.Error,
            XMACS_INVALID_GENEALOGY_DATA_3 = 54366 | XEvent.Severity.Error,
            XMACS_INVALID_GENEALOGY_DATA_4 = 54367 | XEvent.Severity.Error,
            XMACS_FAILED_TO_INITIALIZE_PASSPORT = 54369 | XEvent.Severity.Error,
            XMACS_INACTIVE_XBOX = 54680 | XEvent.Severity.Warning,
            KDC_HACK_31 = 54681 | XEvent.Severity.Warning,
            KDC_HACK_32 = 54682 | XEvent.Severity.Warning,
            KDC_HACK_33 = 54683 | XEvent.Severity.Warning,
            KDC_HACK_34 = 54684 | XEvent.Severity.Warning,
            KDC_HACK_35 = 54685 | XEvent.Severity.Warning,
            KDC_HACK_36 = 54686 | XEvent.Severity.Warning,
            KDC_HACK_37 = 54687 | XEvent.Severity.Warning,
            KDC_HACK_38 = 54688 | XEvent.Severity.Warning,
            KDC_HACK_39 = 54689 | XEvent.Severity.Warning,
            KDC_HACK_40 = 54690 | XEvent.Severity.Warning,
            KDC_HACK_41 = 54691 | XEvent.Severity.Warning,
            KDC_HACK_42 = 54692 | XEvent.Severity.Warning,
            KDC_HACK_43 = 54693 | XEvent.Severity.Warning,
            KDC_HACK_44 = 54694 | XEvent.Severity.Warning,
            KDC_HACK_45 = 54695 | XEvent.Severity.Warning,
            KDC_HACK_46 = 54696 | XEvent.Severity.Warning,
            XMACS_HACK_INVALID_PRE_AUTH_TYPE = 54697 | XEvent.Severity.Warning,
            XMACS_HACK_MALFORMED_PRE_AUTH = 54698 | XEvent.Severity.Warning,
            XMACS_HACK_FAILED_TO_CRACK_PASSPORT_TICKET = 54699 | XEvent.Severity.Warning,
            XMACS_HACK_INVALID_CLIENT_NAME = 54700 | XEvent.Severity.Warning,
            XMACS_HACK_INVALID_SERVER_NAME = 54701 | XEvent.Severity.Warning,
            XMACS_HACK_DOS_ATTACK = 54706 | XEvent.Severity.Warning,
            XMACS_HACK_CONSOLE_TYPE_NOT_ALLOWED = 54709 | XEvent.Severity.Warning,
            XMACS_HACK_TESTKIT_NOT_ALLOWED = 54710 | XEvent.Severity.Warning,
            XMACS_HACK_MALFORMED_PRE_AUTH_2 = 54711 | XEvent.Severity.Warning,
            XMACS_HACK_MALFORMED_PRE_AUTH_3 = 54712 | XEvent.Severity.Warning,
            XMACS_HACK_MALFORMED_PRE_AUTH_4 = 54713 | XEvent.Severity.Warning,
            XMACS_NONUNIQUE_SERIALNUMBER_REQUEST = 54766 | XEvent.Severity.Info,
            XMACS_REGISTER_SUCCESS = 54767 | XEvent.Severity.Info,
            XMACS_REGISTER_SUCCESS_1 = 54768 | XEvent.Severity.Info,
            XMACS_INIT_SUCCESS = 54769 | XEvent.Severity.Info,
            XMACS_TERM_SUCCESS = 54770 | XEvent.Severity.Info,
            XMACS_STOPPING = 54771 | XEvent.Severity.Info,
            XMACS_RELOAD_SUCCESS = 54772 | XEvent.Severity.Info,
            KDC_INFO_23 = 54773 | XEvent.Severity.Info,
            KDC_INFO_24 = 54774 | XEvent.Severity.Info,
            KDC_INFO_25 = 54775 | XEvent.Severity.Info,
            KDC_INFO_26 = 54776 | XEvent.Severity.Info,
            XMACS_CONNECT_GENEALOGY = 54777 | XEvent.Severity.Info,
            KDC_INFO_28 = 54778 | XEvent.Severity.Info,
            XMACS_PUID_ATTAINED_NEW_BLOCK = 54779 | XEvent.Severity.Info,
            XMACS_PPALOADER_LOADING_INFO = 54780 | XEvent.Severity.Info,
            XMACS_PPALOADER_LOADING_INFO_1 = 54781 | XEvent.Severity.Info,
            XRLSCAN_PUT_COMPONENTNAME_FAILED = 10000 | XEvent.Severity.Warning,
            XRLSCAN_GETNEXTROWSET_FAILED = 10001 | XEvent.Severity.Warning,
            XRLSCAN_SETBINDINGS_FAILED = 10002 | XEvent.Severity.Warning,
            XRLSCAN_GETROWS_FAILED = 10003 | XEvent.Severity.Warning,
            XRLSCAN_LOADCONTENTTYPES_FAILED = 10004 | XEvent.Severity.Warning,
            XRLSCAN_CONFIG_0 = 62475 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_1 = 62476 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_2 = 62477 | XEvent.Severity.Error,
            DEPRECATED_XRLSCAN_CONFIG_3 = 62478 | XEvent.Severity.Error,
            DEPRECATED_XRLSCAN_CONFIG_4 = 62479 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_5 = 62480 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_6 = 62481 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_7 = 62482 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_8 = 62483 | XEvent.Severity.Error,
            XRLSCAN_CONFIG_9 = 62484 | XEvent.Severity.Error,
            XRLSCAN_HACK_0 = 62525 | XEvent.Severity.Warning,
            XRLSCAN_E_INVALID_URL = 62526 | XEvent.Severity.Warning,
            XRLSCAN_E_INVALID_URL_1 = 62527 | XEvent.Severity.Warning,
            XRLSCAN_LIMITED_NO_SGINFO = 62528 | XEvent.Severity.Warning,
            SIGNATURE_GETSECUREBLOB_ERROR = 15000 | XEvent.Severity.Error,
            SIGNATURE_VALIDATE_CERTIFICATE_ERROR = 15001 | XEvent.Severity.Error,
            PLAYREADY_DEVICE_CERT_EMPTY = 15002 | XEvent.Severity.Error,
            PLAYREADY_DEVICE_CERT_TOO_LONG = 15003 | XEvent.Severity.Error,
            PLAYREADY_DEVICE_CERT_GENERATION_FAILURE = 15004 | XEvent.Severity.Error,
            PLAYREADY_DEVICE_CERT_GENERAL_ERROR = 15005 | XEvent.Severity.Error,
            PLAYREADY_DEVICE_CERT_INVALID_DEVICE = 15006 | XEvent.Severity.Error,
            SIGNATURE_CODE_0 = 57950 | XEvent.Severity.Error,
            SIGNATURE_CODE_1 = 57951 | XEvent.Severity.Error,
            SIGNATURE_CODE_2 = 57952 | XEvent.Severity.Error,
            SIGNATURE_CODE_3 = 57953 | XEvent.Severity.Error,
            SIGNATURE_CODE_4 = 57954 | XEvent.Severity.Error,
            SIGNATURE_CODE_5 = 57955 | XEvent.Severity.Error,
            SIGNATURE_CONFIG_0 = 57975 | XEvent.Severity.Error,
            SIGNATURE_CONFIG_1 = 57976 | XEvent.Severity.Error,
            SIGNATURE_CONFIG_2 = 57977 | XEvent.Severity.Error,
            SIGNATURE_CONFIG_3 = 57978 | XEvent.Severity.Error,
            SIGNATURE_CONFIG_CALLSOURCE = 57979 | XEvent.Severity.Error,
            SIGNATURE_HACK_0 = 58000 | XEvent.Severity.Warning,
            SIGNATURE_INFO_0 = 58025 | XEvent.Severity.Info,
            SIGNATURE_INFO_1 = 58026 | XEvent.Severity.Info,
            SIGNATURE_INFO_2 = 58027 | XEvent.Severity.Info,
            LICENSE_GENERAL = 58028 | XEvent.Severity.Error,
            LICENSE_INVALID_REQUEST = 58029 | XEvent.Severity.Error,
            LICENSE_XML_ERROR = 58030 | XEvent.Severity.Error,
            DEPRECATED_XSIG_APP_FAILED_GEOFENCING_INIT = 58031 | XEvent.Severity.Error,
            DEPRECATED_GEO_DB_FILE_TOO_OLD = 58032 | XEvent.Severity.Error,
            XSIG_BLACKLIST_DIGEST_FAILURE = 58033 | XEvent.Severity.Error,
            LICENSE_AUTHDATA_VERIFICATION_FAILED = 58034 | XEvent.Severity.Error,
            XMSTV_CA = 57956 | XEvent.Severity.Error,
            XMSTV_CERT_REQUEST_CHECK = 57957 | XEvent.Severity.Error,
            XMSTV_GENERAL = 57958 | XEvent.Severity.Error,
            AAINFO_GETAAINFO_GENERAL = 57959 | XEvent.Severity.Error,
            CASVC_INVALID_REQUEST = 57960 | XEvent.Severity.Error,
            WEBCACHE_SIGNATURE_BLACKLIST_DIGEST_WRONG_SIZE = 61725 | XEvent.Severity.Error,
            XUACS_SUBSCRIPTION_NOT_FOUND = 15000 | XEvent.Severity.Error,
            XUACS_REPLACE_USER_PASSPORT_QUEUE_DEQUEUE_ERROR = 15001 | XEvent.Severity.Error,
            XUACS_REPLACE_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR = 15002 | XEvent.Severity.Error,
            XUACS_REPLACE_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR = 15003 | XEvent.Severity.Error,
            XUACS_REPLACE_USER_PASSPORT_QUEUE_GET_PENDING_ERROR = 15004 | XEvent.Severity.Error,
            XUACS_REPLACE_OWNER_PASSPORT_ERROR = 15005 | XEvent.Severity.Error,
            XUACS_REPLACE_USER_PASSPORT_ERROR = 15006 | XEvent.Severity.Error,
            XUACS_GET_USER_TENURE_ERROR = 15007 | XEvent.Severity.Error,
            XUACS_GET_USER_TENURE_DATABASE_ERROR = 15008 | XEvent.Severity.Error,
            XUACS_GET_USER_TENURE_CONFIG_ERROR = 15009 | XEvent.Severity.Error,
            XUACS_UPS_GET_BIRTHDATE_ERROR = 15010 | XEvent.Severity.Info,
            XUACS_RECOVERY_USER_THRESHOLD_EXCEEDED = 15011 | XEvent.Severity.Warning,
            XUACS_RECOVERY_MACHINE_THRESHOLD_EXCEEDED = 15012 | XEvent.Severity.Warning,
            BILLING_ACCOUNTS_GET_SUBSCRIPTION_INFO_ERROR = 15013 | XEvent.Severity.Error,
            XUACS_SWITCH_USER_DATE_OF_BIRTH_ERROR = 15014 | XEvent.Severity.Error,
            XUACS_SWITCH_OWNER_PASSPORT_ERROR = 15015 | XEvent.Severity.Error,
            XUACS_MAX_ACCOUNTS_PER_MACHINEID_REACHED = 15016 | XEvent.Severity.Warning,
            XUACS_ACCEPT_TERMS_OF_SERVICE_ERROR = 15017 | XEvent.Severity.Warning,
            XUACS_SET_CONSOLE_TRUST_LEVEL_ERROR = 15019 | XEvent.Severity.Warning,
            XUACS_ENUM_FAMILY_MEMBERS_ERROR = 15020 | XEvent.Severity.Warning,
            XUACS_ADD_DEPENDENT_ERROR = 15021 | XEvent.Severity.Warning,
            XUACS_ADD_DEPENDENT_INVALID_SIGNED_PASSPORT_PUID = 15022 | XEvent.Severity.Warning,
            XUACS_GAMERTAG_HISTORY_GET_ERROR = 15023 | XEvent.Severity.Error,
            XUACS_USER_HISTORY_GET_ERROR = 15024 | XEvent.Severity.Error,
            XUACS_MACHINE_HISTORY_GET_ERROR = 15025 | XEvent.Severity.Error,
            XUACS_FAMILY_SUB_GOLD_USER_COUNT_ERROR = 15026 | XEvent.Severity.Warning,
            XUACS_FAMILY_SUB_ASSIGN_GOLD_USER_ERROR = 15027 | XEvent.Severity.Warning,
            XUACS_FAMILY_SUB_REMOVE_GOLD_USER_ERROR = 15028 | XEvent.Severity.Warning,
            XUACS_REMOVE_DEPENDENT_ERROR = 15029 | XEvent.Severity.Warning,
            XUACS_GET_PARENTAL_CONTROLS_ERROR = 15030 | XEvent.Severity.Warning,
            XUACS_MISSING_OR_BAD_CONFIG_PASSPORTCREATEGNERATED = 15031 | XEvent.Severity.Error,
            XUACS_GET_DEPENDENT_SIGNED_PUID_ERROR = 15032 | XEvent.Severity.Warning,
            XUACS_CONSOLE_APPLICATIONS_GET_ERROR = 15033 | XEvent.Severity.Error,
            XUACS_SWITCH_USER_COUNTRY_ERROR = 15034 | XEvent.Severity.Error,
            XUACS_GET_PARENTAL_CONTROL_GROUP_TEMPLATES_ERROR = 15035 | XEvent.Severity.Warning,
            XUACS_GET_USER_PARENTAL_CONTROL_GROUP_ERROR = 15036 | XEvent.Severity.Warning,
            XUACS_UPDATE_PARENTAL_CONTROL_GROUP_ERROR = 15037 | XEvent.Severity.Warning,
            BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE = 15038 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_ERROR_POINTS_TRANSFER = 15039 | XEvent.Severity.Error,
            XUACS_ACCOUNTS_RESERVE_GAMERTAG_ERROR = 15040 | XEvent.Severity.Error,
            XUACS_OFFLINE_XUID_ALREADY_REGISTERED = 15041 | XEvent.Severity.Error,
            XUACS_SWITCH_USER_COUNTRY_DATABASE_ERROR = 15042 | XEvent.Severity.Warning,
            XUACS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER = 15043 | XEvent.Severity.Warning,
            XUACS_SWITCH_USER_COUNTRY_MIGRATE_ACCOUNT_TIMEOUT = 15044 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_ERROR_GET_DEPENDENT_POINTS = 15045 | XEvent.Severity.Error,
            XUACS_CREATEUSERANDBILLABLEACCOUNT_ERROR = 15046 | XEvent.Severity.Error,
            XUACS_MIGRATE_COM_USER_GET_OFFERINSTANCE_ERROR = 15047 | XEvent.Severity.Error,
            XONLINE_E_ACCOUNTS_USER_GET_AGE_ERROR = 15048 | XEvent.Severity.Error,
            XONLINE_E_ACCOUNTS_USER_GET_AGE_GROUP_ERROR = 15049 | XEvent.Severity.Error,
            XUACS_CREATEBULKUSER_ERROR = 15050 | XEvent.Severity.Error,
            XUACS_MERGE_USER_ENTITLEMENTS_ERROR = 15051 | XEvent.Severity.Error,
            XUACS_PREVIEW_SWITCH_USER_COUNTRY_ERROR = 15052 | XEvent.Severity.Error,
            XUACS_SWITCH_USER_PASSPORT_ERROR = 15053 | XEvent.Severity.Error,
            XUACS_HCP_SERVICE_CALL_FAILURE = 15054 | XEvent.Severity.Error,
            TEST_ENCRYPTION_ERROR = 19999 | XEvent.Severity.Error,
            XUACS_UNABLE_TO_COMPLETE_RENEWAL = 50531 | XEvent.Severity.Error,
            XUACS_MISSING_OR_BAD_CONFIG = 50560 | XEvent.Severity.Error,
            XUACS_MISSING_OR_BAD_CONFIG_1 = 50566 | XEvent.Severity.Error,
            XUACS_UODB_ACCESS_ERROR_1 = 50575 | XEvent.Severity.Error,
            XUACS_UNEXPECTED_REQUEST = 50655 | XEvent.Severity.Warning,
            XUACS_UNEXPECTED_REQUEST_1 = 50656 | XEvent.Severity.Warning,
            XUACS_LINK_WEB_ACCOUNT_BLOCKED = 50658 | XEvent.Severity.Warning,
            XUACS_SUSPICIOUS_CLIENT = 50659 | XEvent.Severity.Warning,
            XUACS_SUSPICIOUS_CLIENT_1 = 50660 | XEvent.Severity.Warning,
            XUACS_RESTORE_ACCOUNT_BLOCKED = 50661 | XEvent.Severity.Warning,
            XUACS_RESTORE_ACCOUNT_BLOCKED_1 = 50662 | XEvent.Severity.Warning,
            XUACS_UNEXPECTED_REQUEST_2 = 50663 | XEvent.Severity.Warning,
            XUACS_GRADUATE_USER_NO_PRIVILEGE = 50673 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_NOT_CHILD = 50674 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_NOT_ADULT = 50675 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_NO_PI = 50676 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_ADD_PI_ERROR = 50677 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_ALREADY = 50678 | XEvent.Severity.Error,
            XUACS_GRADUATE_USER_IMPERSONATION_ERROR = 50683 | XEvent.Severity.Error,
            XUACS_CLIENT_TYPE_MISSING = 50684 | XEvent.Severity.Error,
            XUACS_CLIENT_TYPE_INVALID = 50685 | XEvent.Severity.Error,
            XUACS_CLIENT_TYPE_CONFIG_ERROR = 50686 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_0 = 62675 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_1 = 62676 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_2 = 62677 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_3 = 62678 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_4 = 62679 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_5 = 62680 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_6 = 62681 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_7 = 62682 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_8 = 62683 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_9 = 62684 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_10 = 62685 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_11 = 62686 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_12 = 62687 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_13 = 62688 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_14 = 62689 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_15 = 62690 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_16 = 62691 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_17 = 62692 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_18 = 62693 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_19 = 62694 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_20 = 62695 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_21 = 62696 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_22 = 62697 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_23 = 62698 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_24 = 62699 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_25 = 62700 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_26 = 62701 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_27 = 62702 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_28 = 62703 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_29 = 62704 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_30 = 62705 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_31 = 62706 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_32 = 62707 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_33 = 62708 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_34 = 62709 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_35 = 62710 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_36 = 62711 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_37 = 62712 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_38 = 62713 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_39 = 62714 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_40 = 62715 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_41 = 62716 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_42 = 62717 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_43 = 62718 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_44 = 62719 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_45 = 62720 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_46 = 62721 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_47 = 62722 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_48 = 62723 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_49 = 62724 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_50 = 62725 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_51 = 62726 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_52 = 62727 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_53 = 62728 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_54 = 62729 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_55 = 62730 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_56 = 62731 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_57 = 62732 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_58 = 62733 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_59 = 62734 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_60 = 62735 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_61 = 62736 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_62 = 62737 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_63 = 62738 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_64 = 62739 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_65 = 62740 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_66 = 62741 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_67 = 62742 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_68 = 62743 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_69 = 62744 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_70 = 62745 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_71 = 62746 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_72 = 62747 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_73 = 62748 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_74 = 62749 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_75 = 62750 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_76 = 62751 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_77 = 62752 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_78 = 62753 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_79 = 62754 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_80 = 62755 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_81 = 62756 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_82 = 62757 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_83 = 62758 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_84 = 62759 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_85 = 62760 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_86 = 62761 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_87 = 62762 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_88 = 62763 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_89 = 62764 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_90 = 62765 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_91 = 62766 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_92 = 62767 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_93 = 62768 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_94 = 62769 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_95 = 62770 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_96 = 62771 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_97 = 62772 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_98 = 62773 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_99 = 62774 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_100 = 62775 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_101 = 62776 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_102 = 62777 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_103 = 62778 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_104 = 62779 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_105 = 62780 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_NOT_CONNECTED_106 = 62781 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_107 = 62782 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_108 = 62783 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_109 = 62784 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_110 = 62785 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_111 = 62786 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_112 = 62787 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_113 = 62788 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_114 = 62789 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_115 = 62790 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_116 = 62791 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_117 = 62792 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_118 = 62793 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_119 = 62794 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_120 = 62795 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_121 = 62796 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CODE_122 = 62797 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_FRIEND_PMN_ERROR = 62798 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_BUDDY_GAMERTAG_ERROR = 62799 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_0 = 62800 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_1 = 62801 | XEvent.Severity.Error,
            BILLING_SWITCH_USER_PASSPORT_NOT_LINKED = 62802 | XEvent.Severity.Error,
            BILLING_SWITCH_USER_PASSPORT_LOAD_USER_FAILED = 62803 | XEvent.Severity.Error,
            BILLING_SWITCH_USER_PASSPORT_INVALID_USER = 62804 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_ADDITION_RESTRICTED = 62808 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_REMOVAL_RESTRICTED = 62809 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED = 62810 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_PASSPORT_SWITCHING_RESTRICTED = 62811 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_INVALID_CLIENT = 62812 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_USER_NOT_FOUND = 62813 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_PUID_TO_ANID_FAILED = 62814 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_MUSICNET_FAILURE = 62815 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER = 62816 | XEvent.Severity.Error,
            BILLING_USERACCOUNT_AUTHDATA_VERIFICATION_ERROR = 62817 | XEvent.Severity.Error,
            BILLING_CREATE_ACCOUNT_TWO_PASSPORTS = 62818 | XEvent.Severity.Error,
            BILLING_QUEUE_RESET_ITEMS_ERROR = 62820 | XEvent.Severity.Error,
            BILLING_QUEUED_ACCOUNT_NOT_FOUND_123 = 62822 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_VERIFY_BILLING_INFO_ERROR = 64256 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_SET_NO_AGE_OUT_QUEUE_ERROR = 64257 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_SET_NO_AGE_OUT_IMPERSONATION_ERROR = 64258 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_SET_NO_AGE_OUT_DEQUEUE_ERROR = 64259 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_SET_NO_AGE_OUT_GET_PENDING_ERROR = 64260 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_SET_NO_AGE_OUT_TIMER_ERROR = 64261 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_GET_NO_AGE_OUT_BLOCKED = 64262 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_UPS_UPDATE_PROFILE_FAILED = 64263 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_GET_POINTS_BALANCE_ERROR = 64264 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR = 64265 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR = 64266 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR = 64267 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_CHANGE_PAYMENT_INSTURMENT_ERROR = 64268 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_GET_ACCOUNT_INFO_ERROR = 64269 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_PAYPAL_UNSUPPORTED_COUNTRY = 64270 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_ADD_PAYPAL_PAYIN_ERROR = 64271 | XEvent.Severity.Error,
            BILLING_ACCOUNTS_BILLING_NOT_CONNECTED = 64272 | XEvent.Severity.Error,
            BILLING_DECLINE_NOTIFICATION_VALUE_NEGATIVE = 64273 | XEvent.Severity.Warning,
            XUACS_FAMILY_HISTORY_GET_ERROR = 64274 | XEvent.Severity.Error,
            XUACS_SET_FREE_GAMERTAG_ELIGIBLE_ERROR = 64275 | XEvent.Severity.Error,
            XUACS_SET_FAMILY_GOLD_SEAT_EXEMPTION_ERROR = 64276 | XEvent.Severity.Error,
            RATINGS_FD_SUBMITRATING = 15550 | XEvent.Severity.Error,
            RATINGS_PROTOCOL_ERROR = 15551 | XEvent.Severity.Error,
            RATINGS_COMMON_MEDIA = 15552 | XEvent.Severity.Error,
            RATINGS_UNKNOWN_RATING_ERROR = 15553 | XEvent.Severity.Error,
            RATINGS_INVALID_ARGS = 15554 | XEvent.Severity.Error,
            RATINGS_MSN_ERROR = 15555 | XEvent.Severity.Error,
            RATINGS_CONFIG_MULTISETTINGS_ERROR = 15556 | XEvent.Severity.Error,
            RATINGS_CONFIG_MULTISETTINGS_LOAD = 15557 | XEvent.Severity.Info,
            XONLINE_E_RATINGS_CONTENTTYPE_LOAD = 15558 | XEvent.Severity.Info,
            RATINGS_FD_GETRATING = 15559 | XEvent.Severity.Error,
            XONLINE_E_RATINGS_CRON_ERROR = 15560 | XEvent.Severity.Error,
            RATINGS_CONFIG_SETTINGS_LOAD = 15561 | XEvent.Severity.Info,
            XONLINE_E_RATINGS_CRON_JOB_FAILED = 15562 | XEvent.Severity.Error,
            XONLINE_E_RATINGS_CRON_JOB_SUCCESS = 15563 | XEvent.Severity.Info,
            XONLINE_E_RATINGS_HACK_1 = 15564 | XEvent.Severity.Warning,
            XONLINE_E_RATINGS_HACK_2 = 15565 | XEvent.Severity.Warning,
            CONTENTINGESTION_ERROR_UNKNOWN = 15001 | XEvent.Severity.Error,
            CONTENTINGESTION_ERROR_INTERFACE = 15002 | XEvent.Severity.Error,
            CONTENTINGESTION_ERROR_WEBCONFIGURATION = 15003 | XEvent.Severity.Warning,
            CONTENTINGESTION_INVALID_ARGS = 15004 | XEvent.Severity.Error,
            STS_FD_ERROR = 15000 | XEvent.Severity.Error,
            STS_FD_CONFIGERROR = 15001 | XEvent.Severity.Error,
            STS_GETSECURITYTICKET_ERROR = 15002 | XEvent.Severity.Error,
            KDC_POLICYCHECK_TITLEID_MULTIPLEGROUPS = 40000 | XEvent.Severity.Warning,
            KDC_DUPLICATE_TITLEKEY = 40001 | XEvent.Severity.Error,
            TEST_FD_GENERIC = 15000 | XEvent.Severity.Error,
            TESTREFL_STARTED = 15100 | XEvent.Severity.Info,
            TESTREFL_SHUTDOWN = 15101 | XEvent.Severity.Info,
            TESTREFL_STARTUP_FAILURE = 15102 | XEvent.Severity.Error,
            TESTREFL_THREAD_FAILURE = 15103 | XEvent.Severity.Error,
            MESSAGING_HEADER_TRUNCATED = 15000 | XEvent.Severity.Warning,
            MESSAGING_REQUEST_TRUNCATED = 15001 | XEvent.Severity.Warning,
            MESSAGING_NO_VINTERFACE = 15002 | XEvent.Severity.Warning,
            MESSAGING_BAD_CONTENT_TYPE = 15003 | XEvent.Severity.Warning,
            MESSAGING_NOTIFICATION_MESSAGE_TRUNCATED = 15004 | XEvent.Severity.Warning,
            MESSAGING_INVALID_USERID = 15005 | XEvent.Severity.Error,
            MESSAGING_INVALID_DC_MESSAGE_TYPE = 15006 | XEvent.Severity.Warning,
            MESSAGING_INVALID_CLIENT_MESSAGE_TYPE = 15007 | XEvent.Severity.Warning,
            MESSAGING_DO_NOT_LOG_EVENT = 15008 | XEvent.Severity.Info,
            MESSAGING_SGINFO_INVALID_PUID = 15009 | XEvent.Severity.Error,
            MESSAGING_UNKNOWN_MESSAGE_TYPE = 15010 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGESUMMARY_INVALID_USERID = 15020 | XEvent.Severity.Error,
            MESSAGING_GETMESSAGESUMMARY_INVALID_MESSAGEID = 15021 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGESUMMARY_MESSAGEID_FROM_FAILED_SEND = 15022 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGEDETAILS_INVALID_USERID = 15030 | XEvent.Severity.Error,
            MESSAGING_GETMESSAGEDETAILS_SETUNSET_SAME_FLAGS = 15031 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGEDETAILS_SET_INVALID_FLAGS = 15032 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGEDETAILS_UNSET_INVALID_FLAGS = 15033 | XEvent.Severity.Warning,
            MESSAGING_GETMESSAGEDETAILS_INVALID_MESSAGEID = 15034 | XEvent.Severity.Warning,
            MESSAGING_ENUMERATEMESSAGES_INVALID_USERID = 15040 | XEvent.Severity.Error,
            MESSAGING_DELETEMESSAGE_INVALID_USERID = 15050 | XEvent.Severity.Error,
            MESSAGING_DELETEMESSAGE_INVALID_FLAGS = 15051 | XEvent.Severity.Warning,
            MESSAGING_DELETEMESSAGE_MESSAGEID_FROM_FAILED_SEND = 15052 | XEvent.Severity.Warning,
            MESSAGING_DELETEMESSAGE_INVALID_MESSAGEID = 15053 | XEvent.Severity.Warning,
            MESSAGING_GETSYSTEMMESSAGEDETAILS_INVALID_MESSAGEID = 15060 | XEvent.Severity.Warning,
            MESSAGING_GETSYSTEMMESSAGEDETAILS_MESSAGE_NOT_FOUND = 15061 | XEvent.Severity.Warning,
            MESSAGING_DELETESYSTEMMESSAGE_INVALID_MESSAGEID = 15070 | XEvent.Severity.Warning,
            MESSAGING_DELETESYSTEMMESSAGE_MESSAGE_NOT_FOUND = 15071 | XEvent.Severity.Warning,
            MESSAGING_MESSAGEFLAGS_INVALID_USERID = 15080 | XEvent.Severity.Error,
            MESSAGING_MESSAGEFLAGS_SET_AND_UNSET = 15081 | XEvent.Severity.Error,
            MESSAGING_MESSAGEFLAGS_FLAG_NOT_SETABLE = 15082 | XEvent.Severity.Error,
            MESSAGING_MESSAGEFLAGS_FLAG_NOT_UNSETABLE = 15083 | XEvent.Severity.Error,
            MESSAGING_MESSAGEFLAGS_MESSAGEID_FROM_FAILED_SEND = 15084 | XEvent.Severity.Warning,
            MESSAGING_MESSAGEFLAGS_INVALID_MESSAGEID = 15085 | XEvent.Severity.Warning,
            MESSAGING_REVOKEMESSAGE_TOO_MANY_RECIPIENTS = 15090 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_PROP_SIZE_TOO_LARGE = 15091 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_BLOCK_SENDER_NOT_SPECIFIED = 15092 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_CANT_BLOCK_MORE_THAN_ONE = 15093 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_NO_RECIPIENTS = 15094 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_RECIPIENT_ID_ZERO = 15095 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_SENDER_ID_ZERO = 15096 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_BAD_SENDER_CONTEXT = 15097 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_MISSING_USE_TYPE = 15098 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_CANT_REVOKE_PERSISTENT_BY_PROP = 15099 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_BAD_PROP_TAG = 15100 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_BAD_MESSAGE_TYPE = 15101 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_USE_TYPE_OR_USE_ID_MUST_BE_SET = 15102 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_USING_RESERVED_FLAGS = 15103 | XEvent.Severity.Error,
            MESSAGING_REVOKEMESSAGE_INVALID_MESSAGE_ID = 15104 | XEvent.Severity.Error,
            MESSAGING_SENDMESSAGE_INVALID_USERID = 15110 | XEvent.Severity.Error,
            MESSAGING_SENDMESSAGE_INVALID_MESSAGE = 15111 | XEvent.Severity.Error,
            MESSAGING_SENDMESSAGE_INSUFFICIENT_PRIVILEGES = 15112 | XEvent.Severity.Error,
            MESSAGING_SENDMESSAGE_BAD_MESSAGE_TYPE = 15113 | XEvent.Severity.Error,
            MESSAGING_SENDSYSTEMMESSAGE_DATABASE_FAILURE = 15120 | XEvent.Severity.Error,
            MESSAGING_SENDSYSTEMMESSAGE_SPROC_ERROR = 15121 | XEvent.Severity.Error,
            MESSAGING_SENDSYSTEMMESSAGE_SYSID_ERROR = 15122 | XEvent.Severity.Error,
            MESSAGING_SENDSYSTEMMESSAGE_INVALID_MESSAGE = 15123 | XEvent.Severity.Error,
            XTOU_GETTERMSOFUSE_GENERIC_ERROR = 15000 | XEvent.Severity.Error,
            XTOU_GETTERMSOFUSE_PARSE_ERROR = 15001 | XEvent.Severity.Error,
            XTOU_GETTERMOFUSE_GET_FILE_ERROR = 15002 | XEvent.Severity.Error,
            XTOU_GETLANGUAGESFORCOUNTRY_GENERIC_ERROR = 15003 | XEvent.Severity.Error,
            VORTEX_PERFCOUNTER_FAILURE = 15000 | XEvent.Severity.Error,
            VORTEX_HTTPLISTENER_CALLBACK = 15001 | XEvent.Severity.Error,
            VORTEX_HTTPLISTENER_NEXTREQUEST = 15002 | XEvent.Severity.Error,
            VORTEX_HTTPLISTENER_PROCESSREQUEST = 15003 | XEvent.Severity.Warning,
            VORTEX_EVENTPROVIDER_MAKECALLBACK = 15004 | XEvent.Severity.Warning,
            VORTEX_SI_QUERY_START = 15005 | XEvent.Severity.Error,
            VORTEX_SI_QUERY_LOAD = 15006 | XEvent.Severity.Error,
            VORTEX_SI_QUERYTEMPLATE_LOAD = 15007 | XEvent.Severity.Error,
            VORTEX_CONFIG_NPDB = 15008 | XEvent.Severity.Warning,
            VORTEX_CONFIG_LOCAL = 15009 | XEvent.Severity.Warning,
            VORTEX_CONFIG_SAVE = 15010 | XEvent.Severity.Warning,
            VORTEX_SERVICE_INIT_WARNING = 15011 | XEvent.Severity.Warning,
            VORTEX_SERVICE_INIT_ERROR = 15012 | XEvent.Severity.Error,
            VORTEX_VXINPUTADAPTER_START = 15013 | XEvent.Severity.Info,
            VORTEX_VXINPUTADAPTER_RESUME = 15014 | XEvent.Severity.Info,
            VORTEX_VXINPUTADAPTER_DISPOSE = 15015 | XEvent.Severity.Info,
            VORTEX_VXINPUTADAPTER_STOP = 15016 | XEvent.Severity.Info,
            VORTEX_VXINPUTADAPTER_PAUSE = 15017 | XEvent.Severity.Info,
            VORTEX_VXINPUTADAPTER_CREATEEVENT = 15018 | XEvent.Severity.Warning,
            VORTEX_VXINPUTADAPTER_FAIL = 15019 | XEvent.Severity.Error,
            VORTEX_CONFIG_RELOAD = 15020 | XEvent.Severity.Error,
            VORTEX_VEI_ADAPTER_UPDATE_SUCCESS = 15021 | XEvent.Severity.Info,
            VORTEX_VEI_ADAPTER_UPDATE_FAILURE = 15022 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_TEMPLATE_LOAD_ERROR = 15023 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_LOG_LOAD_ERROR = 15024 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_QUERY_LOAD_ERROR = 15025 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_SCHEMA_VALIDATOR_ERROR = 15026 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_DUPLICATE_OBJECT_MAPPER_FIELD = 15027 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_TEMPLATE_REFERENCE_MISSING = 15028 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_DUPLICATE_STREAM_NAME = 15029 | XEvent.Severity.Error,
            VORTEX_VEI_CONFIG_DUPLICATE_SINK_NAME = 15030 | XEvent.Severity.Error,
            VORTEX_VEI_INPUT_ADAPTER_START = 15031 | XEvent.Severity.Info,
            VORTEX_VEI_INPUT_ADAPTER_RESUME = 15032 | XEvent.Severity.Info,
            VORTEX_VEI_INPUT_ADAPTER_CONSUMPTION_ERROR = 15033 | XEvent.Severity.Error,
            VORTEX_VEI_EVENT_BUILDER_FIELD_MISSING = 15034 | XEvent.Severity.Error,
            VORTEX_VEI_SINK_BUILDER_FIELD_MISSING = 15035 | XEvent.Severity.Error,
            VORTEX_VEI_OUTPUT_ADAPTER_NO_SINKS = 15036 | XEvent.Severity.Warning,
            VORTEX_VEI_OUTPUT_ADAPTER_INVALID_SINK = 15037 | XEvent.Severity.Error,
            VORTEX_UDPLISTENER_CALLBACK = 15038 | XEvent.Severity.Error,
            VORTEX_UDPLISTENER_NEXTREQUEST = 15039 | XEvent.Severity.Error,
            VORTEX_UDPLISTENER_PROCESSREQUEST = 15040 | XEvent.Severity.Warning,
            VORTEX_SINKBUILDER_NO_INITIALIZE = 15041 | XEvent.Severity.Warning,
            VORTEX_SERVICE_STOP_ERROR = 15042 | XEvent.Severity.Error,
            VORTEX_CONFIG_ETX = 15043 | XEvent.Severity.Error,
            VORTEX_REQUEST_AAINFO_ERROR = 15044 | XEvent.Severity.Warning,
            VORTEX_REQUEST_SGINFO_ERROR = 15045 | XEvent.Severity.Warning,
            VORTEX_REQUEST_UNHANDLED_ERROR = 15046 | XEvent.Severity.Error,
            VORTEX_HTTPLISTENER_FAILED_VALIDATION = 15047 | XEvent.Severity.Warning,
            VORTEX_CONFIG_XRL_MAPPINGS = 15048 | XEvent.Severity.Warning,
            XLFS_ADMIN_INIT_PERF_COUNTER_FAILURE = 15000 | XEvent.Severity.Error,
            XLFS_INIT_PERF_COUNTER_FAILURE = 15000 | XEvent.Severity.Error,
            XLFS_MON_SUCCEEDED = 15000 | XEvent.Severity.Info,
            XLFS_MON_SAML_FAILED = 15001 | XEvent.Severity.Error,
            XLFS_MON_UPLOAD_BEGIN_FAILED = 15002 | XEvent.Severity.Error,
            XLFS_MON_XLFS_SYNC_FAILED = 15003 | XEvent.Severity.Error,
            XLFS_MON_UPLOAD_END_FAILED = 15004 | XEvent.Severity.Error,
            XLFS_INTERNAL_FAILURE = 15005 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_FAILED = 15006 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_START_FAILED = 15007 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_FILE_NOT_FOUND = 15008 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_FILE_NOT_DELETED = 15009 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED = 15010 | XEvent.Severity.Error,
            XLFS_MON_DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED = 15011 | XEvent.Severity.Error,
            XSTS_GET_OUTPUT_CLAIMS_IDENTITY_PROVIDER_ERROR = 15000 | XEvent.Severity.Error,
            XSTS_SERVICE_HOST_OPENED_ERROR = 15001 | XEvent.Severity.Error,
            XSTS_FD_SERVICE_HOST_CLOSED_ERROR = 15002 | XEvent.Severity.Error,
            XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR = 15003 | XEvent.Severity.Error,
            XSTS_CONFIG_CP_DUPLICATE_CLAIM_TYPE = 15004 | XEvent.Severity.Error,
            XSTS_CONFIG_CP_NO_PROVIDER_FOR_CLAIM_TYPE = 15005 | XEvent.Severity.Error,
            XSTS_CONFIG_RP_CLAIM_TYPE_NOT_SUPPORTED = 15006 | XEvent.Severity.Error,
            XSTS_CP_OPEN_ERROR = 15007 | XEvent.Severity.Error,
            XSTS_CP_UNLOAD_ERROR = 15008 | XEvent.Severity.Error,
            XSTS_CONFIG_RP_USE_OF_PRIVATE_CLAIM_TYPE_INVALID = 15009 | XEvent.Severity.Error,
            XSTS_MXA_EVENT_AUTHENTICATE_ERROR = 15010 | XEvent.Severity.Error,
            XSTS_CONFIG_DUPLICATE_BUSINESSPARTNER_CERTIFICATE_SUBJECTNAME = 15011 | XEvent.Severity.Error,
 
           // AUTOGENERATED - do not add ids here 
        } 
    } 
} 
 
/////////////////////////////////////////////////////////////////////////////// 
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XSubNotiProt.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;



namespace STF.common.protocol.SubNoti
{
    // Schema identifier for messages.
    public enum MESSAGE_TYPES : uint
    {
        /* IF YOU ADD ANYTHING HERE, ALSO ADD TO SubNotiDefs.MessageTypeToString() BELOW! */
        
        // MIN_REQUEST_TYPE
        eConnect = 100,
        eDisconnect = 101,
        eSubscribe = 102,
        eUnsubscribe = 103,
        eQuery = 104,
        ePublish = 105,
        // MAX_REQUEST_TYPE

        // MIN_REPLY_TYPE
        eErrorReply = 300,
        eConnectReply = 301,
        eDisconnectReply = 302,
        eSubscribeReply = 303,
        eUnsubscribeReply = 304,
        eQueryReply = 305,
        ePublishReply = 306,
        // MAX_REPLY_TYPE

        // MIN_NOTIFICATION_TYPE
        eDataNotification = 500
        // MAX_NOTIFICATION_TYPE
    };

    public class SubNotiDefs
    {
        // protocol version.
        public const int CURRENT_PROTOCOL_VERSION = 1;
        public const uint MIN_REQUEST_TYPE = 100;
        public const uint MAX_REQUEST_TYPE = 105;
        public const uint MIN_REPLY_TYPE = 300;
        public const uint MAX_REPLY_TYPE = 306;
        public const uint MIN_NOTIFICATION_TYPE = 500;
        public const uint MAX_NOTIFICATION_TYPE = 500;
        public const ushort MIN_DATA_TYPE = 1000;
        public const ushort MAX_DATA_TYPE = 1008;
        public const ushort MIN_INTERNAL_DATA_TYPE = 2000;
        public const ushort MAX_INTERNAL_DATA_TYPE = 2008;

        // message header flags.
        public const int XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC = 0x1;
        public const int XONLINE_CONNSRV_CONNECT_RECONNECT = 0x1;

        public static uint UserIndicesToFlags(int[] rgUserIndices)
        {
            uint dwUserIndexFlags = 0;
            for (int iIndex = 0; iIndex < rgUserIndices.Length; iIndex++)
            {
                dwUserIndexFlags |= (uint)(1 << rgUserIndices[iIndex]);
            }

            return dwUserIndexFlags;
        }

        public static int[] UserFlagsToIndices(uint dwUserIndexFlags)
        {
            ArrayList alIndices = new ArrayList();
            
            int index = 0;
            while (dwUserIndexFlags > 0)
            {
                if ((dwUserIndexFlags & 1) != 0)
                {
                    alIndices.Add(index);
                }
                
                dwUserIndexFlags >>= 1;
                index += 1;
            }

            return (int[])(alIndices.ToArray(typeof(int)));
        }

        public static string MessageTypeToString(uint dwMessageType)
        {
            switch (dwMessageType)
            {
                case (uint)MESSAGE_TYPES.eConnect: return "eConnect";
                case (uint)MESSAGE_TYPES.eDisconnect: return "eDisconnect";
                case (uint)MESSAGE_TYPES.eSubscribe: return "eSubscribe";
                case (uint)MESSAGE_TYPES.eUnsubscribe: return "eUnsubscribe";
                case (uint)MESSAGE_TYPES.eQuery: return "eQuery";
                case (uint)MESSAGE_TYPES.ePublish: return "ePublish";
                case (uint)MESSAGE_TYPES.eErrorReply: return "eErrorReply";
                case (uint)MESSAGE_TYPES.eConnectReply: return "eConnectReply";
                case (uint)MESSAGE_TYPES.eDisconnectReply: return "eDisconnectReply";
                case (uint)MESSAGE_TYPES.eSubscribeReply: return "eSubscribeReply";
                case (uint)MESSAGE_TYPES.eUnsubscribeReply: return "eUnsubscribeReply";
                case (uint)MESSAGE_TYPES.eQueryReply: return "eQueryReply";
                case (uint)MESSAGE_TYPES.ePublishReply: return "ePublishReply";
                case (uint)MESSAGE_TYPES.eDataNotification: return "eDataNotification";
                default: return dwMessageType.ToString();
            }
        }

    };

    // header for all API message types in the subscription/notification system.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct BASE_MESSAGE_HEADER
    {
        // Protocol version identifier.
        public uint dwProtocolVersion;
        
        // API identifier.  see MESSAGE_TYPES.
        public uint dwMessageType;

        // Sequence number.
        public uint dwSeqNum;

        // User index map for users to which this message applies.
        // 1 << (user index)
        public uint dwUserIndexFlags;

        // Total size of the message, including sizeof(BASE_MESSAGE_HEADER).
        public uint dwTotalSize;

        // Extra flags for this message.
        public uint dwHeaderFlags;
    };

    // Generic error response.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct ERROR_REPLY_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // return code.
        public int hr;
    };

    // API to log on to the XSubNoti system.
    // This message contains everything the system needs to know about a user in order to service that user's requests.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct CONNECT_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // Number of connected users.
        public ushort wNumUsers;

        // ulong rgUserIDs[wNumUsers];
    };

    // response to CONNECT_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct CONNECT_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to log off from the XSubNoti system.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct DISCONNECT_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // reason for disconnection?
        public uint dwReason;
    };

    // response to DISCONECT_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct DISCONNECT_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to create a subscription to specified data objects.
    // The current state of each subscribed object will be returned.  Additional changes made to subscribed objects
    // will be sent in further NOTIFICATION_MESSAGE packets until the objects are unsubscribed.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct SUBSCRIBE_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to SUBSCRIBE_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct SUBSCRIBE_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // API to tear down subscriptions to specified data objects.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct UNSUBSCRIBE_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to UNSUBSCRIBE_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct UNSUBSCRIBE_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to receive one-time value of specified data objects.  no subscription is made.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct QUERY_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to QUERY_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct QUERY_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // API to publish value of specified data objects.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct PUBLISH_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object data.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // response to PUBLISH_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct PUBLISH_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    }
    
    // message sent from server to client containing subscribed data objects that have changed.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct NOTIFICATION_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XTOUProtocol.cs ===
using STF.common.service;       // XRLObject2

namespace STF.common.protocol
{
    public class GetLanguagesForCountryRequest : XRLObject2
    {
        public byte countryId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xtou/GetLanguagesForCountry.ashx"; }
        }
    }

    public class XtouLanguageDefinition : XRLObject2
    {
        public int languageId;

        public ushort languageNameLength = 0;

        [WireInfo(SizeParam = "languageNameLength")]
        public string languageName;
    }

    public class GetLanguagesForCountryResponse : XRLObject2
    {
        public ushort count;

        [WireInfo(SizeParam="count")]
        public XtouLanguageDefinition[] languageDefinitions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\STFSoapHttpClientProtocol.cs ===
//This takes a SoapHttpClientProtocol and automatically sets the URL based on the current environment.

//        !!
//!! SUPER IMPORTANT !!
//        !!
//After you generate the reference.cs file, you MUST do 2 things:

//1: change the base class from System.Web.Services.Protocols.SoapHttpClientProtocol to ServerTestFramework.Web.STFSoapHttpClientProtocol

//2: Alter the this.Url line to use ComputeUrl.
//For example:
//  this.Url = "http://xewbcaiis001:12000/signature/signature.asmx";
//becomes:
//  this.ComputeUrl("wcsignature", "/signature/signature.asmx");

//3: Add the correct namespace 
// namespace ServerTestFramework.Web.<YourComponent>

using ServerTestFramework;

namespace ServerTestFramework.Web
{
    public class STFSoapHttpClientProtocol: System.Web.Services.Protocols.SoapHttpClientProtocol
    {
        public void ComputeUrl(string component, string path)
        {
            System.Net.IPEndPoint ep=Global.XEnv.GetVirtualInterface(component);
            string serverName="http://"+ep.Address+":"+ep.Port;

            Url=serverName+path;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\XRLUtil.cs ===
using System;
using System.Net;
using System.IO;
using System.Web;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Diagnostics;

using STF.common.config;
using STF.common.mgmt;


namespace STF.common.service
{
    [ComVisible(false)]
    public class XRLUtil
    {

        //-----------------------------------------------------
        // SetXRLResponse
        //
        //      Sets up the response header and (optionally)
        //      the body in accordace with the XRL spec.
        //
        public static void SetXRLResponse(HttpResponse resp, XOService svc, HResult hr)
        {

            SetXRLResponse(resp, svc, GetCurrentTitleId(), hr);
        }


        //-----------------------------------------------------
        // SetXRLResponse
        //
        //      Sets up the response header and (optionally)
        //      the body in accordace with the XRL spec.
        //
        //      use this version if you don't want to load SGInfo to get titleId.
        //
        public static void SetXRLResponse(HttpResponse resp, XOService svc, uint titleId, HResult hr)
        {
            SetXRLResponse(HttpContext.Current, resp, svc, titleId, hr);
        }

        public static void SetXRLResponse(HttpContext ctx, HttpResponse resp, XOService svc, uint titleId, HResult hr)
        {
            resp.ClearContent();
            resp.ClearHeaders();

            resp.ContentType = "xon/" + ((int)svc).ToString("x");
            resp.StatusCode = (HResult.Succeeded(hr) ? 200 : 500);

//          The following line has been commented out due to a change in behavior in Win2k3 SP1, which no
//          longer updates Content-Length if it is ever explicitly set
//
//          resp.AppendHeader("Content-Length", "0");

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLUtil.SetXRLResponse: Returning hr = " + hr);

            // add the X-Err header only if there's a non S_OK
            // result.
            //
            if (hr != HResult.S_OK)
            {
                // the xerr header is hex but the client is not expecting a
                // leading 0x, so we convert to uint and then do a ToString

                resp.AppendHeader("X-Err", ((uint) hr).ToString("x08"));
                resp.AppendToLog("X-Err(" + hr + ")");

                // this shouldn't fail, but if it does oh well
                try
                {
                    ctx.Items["XErr"] = hr;
                }
                catch {}

                // If this is a Xbox 360 console, also include the X-Server
                // header in the response.

                if (SGInfo.IsAvailableInContext(ctx) && SGInfo.Current._IsXbox360())
                {
                    resp.AppendHeader("X-Server", Environment.MachineName);
                }

                // if it is not an Xbox1, and there was an event logged
                // under this context, then include an  X-Event  header

                if (!SGInfo.IsAvailableInContext(ctx) || !SGInfo.Current._IsXbox())
                {
                    if ((ctx.Items["XEvent"] != null) && (ctx.Response.Headers["X-Event"] == null))
                    {
                        resp.AppendHeader("X-Event", (string)ctx.Items["XEvent"]);
                    }
                }
            }

            XDelay.AddDelayHeader(resp, titleId, GetCurrentPageName(ctx.Request));
        }


        //-----------------------------------------------------
        // SetXRLResponse
        //
        //      Sets up the response header and (optionally)
        //      the body in accordace with the XRL spec.
        //
        public static void SetXRLResponse(HttpResponse resp, XOService svc, HResult hr, XRLObject2 data)
        {
            SetXRLResponse(resp, svc, GetCurrentTitleId(), hr, data);
        }

        //-----------------------------------------------------
        // SetXRLResponse
        //
        //      Sets up the response header and (optionally)
        //      the body in accordace with the XRL spec.
        //
        public static void SetXRLResponse(HttpResponse resp, XOService svc, uint titleId, HResult hr, XRLObject2 data)
        {
            SetXRLResponse(resp, svc, titleId, hr);

            if (data != null)
            {
                data.WriteToResponse(resp);

                // this shouldn't fail, but if it does oh well
                try
                {
                    HttpContext.Current.Items["XRLResponse"] = data;
                }
                catch {}


                //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLUtil.SetXRLResponse: Returning hr = " + hr + ", response:" + LogBinary(data));
            }
        }

        public static void SetXRLResponse(HttpResponse resp, XOService svc, HResult hr, byte[] response)
        {
            SetXRLResponse(resp, svc, hr);

            if (response != null)
            {
                BinaryWriter writer = new BinaryWriter(resp.OutputStream);
                writer.Write(response);

                //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLUtil.SetXRLResponse: Returning hr = " + hr + ", response:" + LogBinary(response));
            }
        }

        public static void SetXRLResponse(HttpResponse resp, XOService svc, uint titleId, HResult hr, byte[] response)
        {
            SetXRLResponse(HttpContext.Current, resp, svc, titleId, hr, response);
        }

        public static void SetXRLResponse(HttpContext ctx, HttpResponse resp, XOService svc, uint titleId, HResult hr, byte[] response)
        {
            SetXRLResponse(ctx, resp, svc, titleId, hr);

            if (response != null)
            {
                BinaryWriter writer = new BinaryWriter(resp.OutputStream);
                writer.Write(response);

                //Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLUtil.SetXRLResponse: Returning hr = " + hr + ", response:" + LogBinary(response));
            }
        }

        public static uint GetCurrentTitleId()
        {
            // this should create an sginfo if it doesn't exist
            // in the case that the interface requires "real" sg, it will make the request
            // in the case where the httpauthdata header is sent, it will use the titleid from there
            // in the case where no authdata was sent at all, it will return 0

            if (AuthToggle.Off)
                return 0;

            return SGInfo.Current.TitleId;
        }

        public static string GetCurrentPageName(HttpRequest req)
        {
            return Path.GetFileNameWithoutExtension(req.FilePath);
        }


        //-----------------------------------------------------
        // SetNoPostBufferInErrorLog
        //
        //      Call this at the start of any ProcessRequest
        //      calls, for requests that contain sensitive
        //      information that shouldn't be shown in the
        //      event log in the case of an error.
        //
        public static void SetNoPostBufferInErrorLog()
        {
            HttpContext.Current.Items["NoPostBufferLog"] = true;
        }

        public static void AddErrorPerfCounters(params PerformanceCounter[] ctrs)
        {
            AddErrorPerfCounters(ctrs, XOn.ERROR_PERF_COUNTERS);
        }

        public static void AddErrorPerfCounters(PerformanceCounter[] ctrs, string ctrsName)
        {
            PerformanceCounter[] newPerfCtrs = ctrs;
            PerformanceCounter[] curPerfCtrs = (PerformanceCounter[])HttpContext.Current.Items[ctrsName];
            if (curPerfCtrs != null)
            {
                newPerfCtrs = new PerformanceCounter[curPerfCtrs.Length + ctrs.Length];
                curPerfCtrs.CopyTo(newPerfCtrs, 0);
                ctrs.CopyTo(newPerfCtrs, curPerfCtrs.Length);
            }

            HttpContext.Current.Items[ctrsName] = newPerfCtrs;
        }


        public static bool IsFromBrowser()
        {
            if (HttpContext.Current==null)
                return false;

            if (HttpContext.Current.Request.UserAgent == null)
                return false;

            return (HttpContext.Current.Request.UserAgent.IndexOf("MSIE") != -1);

        }

        //------------------------------------------------------
        // GetServiceID
        //
        //      Retrieve the XOnline Service ID from the HTTP
        //      request.  The Content-Type header is in the form
        //      xon/<service ID>.
        //
        public static XOService GetServiceID(HttpRequest request)
        {
            // If the Content-Type header doesn't start with 'xon/' it is not
            // a valid XOnline request.
            //
            if (0 != System.String.Compare(request.ContentType, 0, "xon/", 0, 4, true))
            {
                return XOService.InvalidService;
            }

            return (XOService)System.UInt32.Parse(request.ContentType.Substring(4), NumberStyles.AllowHexSpecifier);
        }

        //------------------------------------------------------
        // ParseUserAgent
        //
        //      Break a user agent string into substrings.
        //
        public static string[] ParseUserAgent(HttpRequest request)
        {
            if (request.UserAgent == null)
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.USER_AGENT_MISSING, "User-Agent header not found!");

            string[] strings = request.UserAgent.Split(new char[] { '/', '.' });

            // 3 or 4 part user agent strings accepted. The Build Number is optional.
            if ((strings.Length < 3) || (strings.Length > 5))
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.USER_AGENT_INVALID, "Invalid format for user agent! (not like 6/1.0.4567) '" + request.UserAgent + "'");

            return(strings);
        }

        //------------------------------------------------------
        // GetMajorVersion
        //
        //      Retrieve the XOnline major version from the HTTP
        //      request.  The User-Agent header is in the form
        //      <service ID>/<vermajor>.<verminor>.<build>.
        //
        public static uint GetMajorVersion(HttpRequest request)
        {
            string[] strings = ParseUserAgent(request);

            return System.UInt32.Parse(strings[1]);
        }

        //------------------------------------------------------
        // GetMinorVersion
        //
        //      Retrieve the XOnline minor version from the HTTP
        //      request.  The User-Agent header is in the form
        //      <service ID>/<vermajor>.<verminor>.<build>.
        //
        public static uint GetMinorVersion(HttpRequest request)
        {
            string[] strings = ParseUserAgent(request);

            return System.UInt32.Parse(strings[2]);
        }

        //------------------------------------------------------
        // GetClientBuild
        //
        //      Retrieve the XOnline client build from the HTTP
        //      request.  The User-Agent header is in the form
        //      <service ID>/<vermajor>.<verminor>.<build>.
        //
        public static uint GetClientBuild(HttpRequest request)
        {
            string[] strings = ParseUserAgent(request);

            return System.UInt32.Parse(strings[3]);
        }

        //------------------------------------------------------
        // IsValidXOnlineRequest
        //
        //      Makes sure that the service identified in the request
        //      header is the one desired by this service.
        //
        public static bool IsValidXOnlineRequest(HttpRequest request, XOService service)
        {
            string[] strings = ParseUserAgent(request);

            if (GetServiceID(request) != service ||
                (XOService)System.UInt32.Parse(strings[0], NumberStyles.AllowHexSpecifier) != service
                )
            {
                return false;
            }

            return true;
        }


        //-----------------------------------------------------
        // VerifyParam
        //
        //      Simple helper to throw an exception if
        //      the provided test is false. Handy when doing lots
        //      of param checks.
        //
        public static void VerifyParam(bool test, string message)
        {
            if (test == false)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER_2, message);
            }
        }

        //-----------------------------------------------------
        // IsTeamPuid
        //
        //      Simple helper to see if a puid is a team or user
        //      puid.
        //
        public static bool IsTeamPuid(ulong puid)
        {
            return ((0xFEFE000000000000 & puid) == 0xFEFE000000000000);
        }



        //-----------------------------------------------------
        // GetServiceAddress
        //
        //      Returns an address from the service configuration
        //      that can be used to contact the given service id.
        //
        public static string GetServiceAddress( XOService service )
        {
            string                  viface;
            IVirtualInterfaceInfo   fdInfo;

            switch (service)
            {
            case XOService.PresNotification:  viface = VirtualInterface.xpnfd_presence_int; break;
            case XOService.StringService:     viface = VirtualInterface.stringsvr_int; break;
            //case XOService.Auto_Update:       viface = VirtualInterface.xbos_autoupdate; break; // no internal interface
            //case XOService.Base_Subscription:  viface = VirtualInterface.xbos_base_subscription; break; // no internal interface
            case XOService.User_Account:      viface = VirtualInterface.xuacs_int; break;
            case XOService.Matchmaking:       viface = VirtualInterface.xmatchfd_int; break;
            case XOService.Stats:             viface = VirtualInterface.xstatsfd_int; break;
            case XOService.Feedback:          viface = VirtualInterface.fbserver_int; break;
            case XOService.Billing_Offering:  viface = VirtualInterface.xbos_int; break;
            case XOService.Lists:             viface = VirtualInterface.Lists_int; break;
            case XOService.Signature_Server:  viface = VirtualInterface.xsig_int; break;
            case XOService.Query:             viface = VirtualInterface.xqry_int; break;
            case XOService.Name_Resolution:   viface = VirtualInterface.stfd_name_resolution_int; break;    // should this have an XdnsIIS VirtualInterface?
            case XOService.Storage:           viface = VirtualInterface.stfd_storage_int; break;
            case XOService.Arbitration:       viface = VirtualInterface.xarb_int; break;
            case XOService.Cron:              viface = VirtualInterface.cron_int; break;
            case XOService.MessagingService:  viface = VirtualInterface.xpnfd_messaging_int; break;
            case XOService.Teams:             viface = VirtualInterface.xpnfd_teams_int; break;
            case XOService.Liveinfo:          viface = VirtualInterface.liveinfo_int; break;
            case XOService.Connection_Server: viface = VirtualInterface.XConnSrv; break;
            case XOService.Profile:           viface = VirtualInterface.profilefd_int; break;
            case XOService.Progress:          viface = VirtualInterface.progressfd_int; break;

            default:
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.COMMON_CODE_66, "Internal virtual interface for service " + service + " not found!   Add it to XRLUtil::GetServiceAddress.");
            }

            fdInfo = Config.GetVirtualInterface(viface, 1);
            if (fdInfo == null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR, XEvent.Id.COMMON_CONFIG_278, "Virtual interface for service " + viface.ToString() + " not found!  Check the config file.");
            }

            return String.Format("{0}://{1}:{2}", fdInfo.Protocol, fdInfo.IPAddressString, fdInfo.Port);
        }



        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Sends an http POST request to the given service
        //      id,  with xrl-compliant header information.
        //
        //      NOTE: error hresults returned in the X-Err header
        //      of the response are returned without exception.
        //      If no x-err is found, and the status is not 200,
        //      then an exception is thrown.
        //
        public static HResult PostXrlRequest( XOService service, string url, string authData, byte[] postData, WebHeaderCollection headers, out byte[] responseData )
        {
            Version ver = Assembly.GetExecutingAssembly().GetName().Version;
            HResult hr;
            string  xErr;

            WebClient myWebClient = new WebClient();
            if (authData != null)
            {
                myWebClient.Headers.Add(XHttpHdr.HTTPAUTHDATA, authData);
            }
            myWebClient.Headers.Add("Content-Type", "xon/"+((int)service).ToString("x"));
            // TODO: Ensure the assembly is versioned and use the right version
            myWebClient.Headers.Add("User-Agent", ((int)service).ToString("x")+"/1.0.4325");
            if ((headers == null) || (headers["X-Schema-Ver"] == null))
            {
                myWebClient.Headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(WireData.CurrentSchemaVersion));
            }
            if (headers != null)
            {
                myWebClient.Headers.Add(headers);
            }

            // If any behavior injections have requested to be passed along, do so.
            RequestHeaderBehaviorInjectionMgr.AddPassThroughBehaviorInjections(myWebClient.Headers);

            try
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "POSTing " + postData.Length+ " bytes to " + url + "...");

                responseData = myWebClient.UploadData(url, "POST", postData);
                hr = HResult.S_OK;

                xErr = myWebClient.ResponseHeaders["X-Err"];
                if (xErr != null)
                {
                    hr = HResult.Parse(xErr);
                }

                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, url + " returned " + hr);

            }
            catch (WebException e)
            {
                xErr = null;
                if (e.Response != null && e.Response.Headers != null)
                {
                    xErr = e.Response.Headers["X-Err"];
                }

                if (xErr == null)
                {
                    // not a normal failure, so throw
                    // default to BadRequest if no response is available.
                    HttpStatusCode status = (e.Response == null ? HttpStatusCode.BadRequest : ((HttpWebResponse)e.Response).StatusCode);

                    throw new XrlRequestException(url, e.Message, status, postData, e);
                }

                hr = HResult.Parse(xErr);
                responseData = null;

                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, url + " returned " + hr);
            }

            return hr;
        }

        public static HResult PostXrlRequest( string viface, string path, string authData, byte[] postData, WebHeaderCollection headers, out byte[] responseData )
        {
            IVirtualInterfaceInfo   fdInfo = Config.GetVirtualInterface(viface, 1);
            XOService               service = XOService.InvalidService;
            UriBuilder              uribldr;

            uribldr = new UriBuilder(fdInfo.Protocol, fdInfo.IPAddressString, fdInfo.Port, path);

            service = (XOService)fdInfo.ServiceId;

            if (XOService.InvalidService == service)
            {
                throw new XrlRequestException(uribldr.ToString(), "PostXrlRequest can't find XOService for VirtualInterface '" + viface.ToString() + "'", HttpStatusCode.BadRequest, postData, null);
            }

            if (fdInfo.Protocol.ToLower() != "http")
            {
                throw new XrlRequestException(uribldr.ToString(), "PostXrlRequest only supports 'http' scheme", HttpStatusCode.BadRequest, postData, null);
            }

            return PostXrlRequest( service, uribldr.ToString(), authData, postData, headers, out responseData);
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically and allows custom auth data.
        //
        //
        public static HResult PostXrlRequest( string viface, string path, string authData, XRLObject2 postOb, WebHeaderCollection headers, ref XRLObject2 respOb )
        {
            HResult hr;
            byte[] respData;

            if ( headers == null )
            {
                headers = new WebHeaderCollection();
            }

            headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(postOb.SchemaVersion));

            hr = PostXrlRequest(viface, path, authData, (byte[]) postOb, headers, out respData);

            if( respOb != null && respData != null && respData.Length != 0 )
            {
                respOb.ReadBytes(respData);
            }

            return hr;
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically and allows custom auth data.
        //
        //
        public static HResult PostXrlRequest( string viface, string path, string authData, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            WebHeaderCollection headers = null;
            return PostXrlRequest( viface, path, authData, postOb, headers, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically and allows custom auth data.
        //
        //
        public static HResult PostXrlRequest( string viface, string path, XRLObject2 postOb )
        {
            XRLObject2 respOb = null;

            return PostXrlRequest( viface, path, SGInfo.ToBase64String(), postOb, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but allows for XRLObject2 response object
        //
        //
        public static HResult PostXrlRequest( string viface, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return PostXrlRequest( viface, path, SGInfo.ToBase64String(), postOb, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same as above but this method will use the port specified in the
        //      config file if -1 is specified for the port. If no
        //      port is specified in the config file, the default service
        //      port 8080 is used.
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, int port, string authData, byte[] postData, WebHeaderCollection headers, out byte[] responseData )
        {
            UriBuilder uribldr;

            uribldr = new UriBuilder(GetServiceAddress(service));

            if (port != -1)
            {
                uribldr.Port = port;
            }

            if (uribldr.Port == -1)
            {
                uribldr.Port = 8080;
            }

            uribldr.Path = path;
            uribldr.Scheme = "http";

            return PostXrlRequest( service, uribldr.ToString(), authData, postData, headers, out responseData);
        }

        public static HResult PostXrlRequest( XOService service, string path, int port, string authData, byte[] postData, out byte[] responseData )
        {
            return PostXrlRequest(service, path, port, authData, postData, null, out responseData);
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but uses default authdata
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, byte[] postData, out byte[] responseData )
        {
            return PostXrlRequest(service, path, -1, SGInfo.ToBase64String(), postData, null, out responseData);
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically and allows custom auth data.
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, string authData, XRLObject2 postOb, WebHeaderCollection headers, ref XRLObject2 respOb )
        {
            HResult hr;
            byte[] respData;

            if ( headers == null )
            {
                headers = new WebHeaderCollection();
            }

            headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(postOb.SchemaVersion));

            hr = PostXrlRequest( service, path, -1, authData, (byte[]) postOb, headers, out respData );

            if( respOb != null && respData != null && respData.Length != 0 )
            {
                respOb.ReadBytes(respData);
            }

            return hr;
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically and allows custom auth data.
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, string authData, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            WebHeaderCollection headers = null;
            return PostXrlRequest( service, path, authData, postOb, headers, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      Same thing as above, but marshalls XRLOjbect2s
        //      automatically.
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return PostXrlRequest( service, path, SGInfo.ToBase64String(), postOb, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequest
        //
        //      no reponse object version
        //
        //
        public static HResult PostXrlRequest( XOService service, string path, XRLObject2 postOb )
        {
            XRLObject2 respOb = null;

            return PostXrlRequest( service, path, SGInfo.ToBase64String(), postOb, ref respOb );
        }

        //-----------------------------------------------------
        // PostXrlRequestToAlternate
        //
        // This version allows the caller to specify an url directly, bypassing
        // interface lookups from npdb. This shouldn't be allowed in production,
        // but is useful in test environments so we can point our front doors
        // at emulators during stress runs.
        //
        // If the setting xrlutil_allowAlternateUrl is false, then calling this
        // method will throw an exception with an event id of XEvent.Id.COMMON_HACK_78.
        // Presuming the service is not misconfigured, this means that a hacker
        // may be trying to mess with a production environment by sending alternate
        // destination headers.
        //
        public static HResult PostXrlRequestToAlternate(
            XOService service,
            string url,
            string authData,
            XRLObject2 postOb,
            WebHeaderCollection headers,
            XRLObject2 respOb)
        {
            if (!Config.GetBoolSetting(Setting.xrlutil_allowAlternateUrl))
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.COMMON_HACK_79,
                    "PostXrlRequestToAlternate called when xrlutil_allowAlternateUrl setting is false");
            }

            HResult hr;
            byte[] respData;

            hr = PostXrlRequest(service, url, authData, (byte[]) postOb, headers, out respData);

            if( respOb != null && respData != null && respData.Length != 0 )
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(respData));
                respOb.ReadBytes(respData);
            }

            return hr;
        }

        private static string LogBinary(byte[] bytes)
        {
            string result = "";

            if ( bytes != null )
            {
                string[] lines = ByteConvert.ToFormattedStrings(bytes);
                foreach (string s in lines)
                {
                    Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, s);
                }
            }
            else
            {
                result = "(null)";
            }

            return result;
        }

        private static string LogBinary(XRLObject2 xrlo)
        {
            if (xrlo != null)
            {
                return LogBinary((byte[])xrlo);
            }

            return "(null)";
        }

        //------------------------------------------------------
        // GetClientInfo
        //
        //      Retrieve the ip address and machine id from the SG Info
        //      or Active Auth info
        //
        public static void GetClientInfo(out string ipAddress, out ulong machineId)
        {
            ipAddress = string.Empty;
            machineId = 0;

            if (AAInfo.IsActiveAuthAvailable)
            {
                if (AAInfo.Current.XblSamlToken != null &&
                    !ulong.TryParse(AAInfo.Current.XblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid), out machineId))
                {
                    Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, "GetClientInfo: Failed to parse name_attribute_machineid attribute '{0}'",
                        AAInfo.Current.XblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid));
                }
                ipAddress = AAInfo.Current.IpAddressInternet;
            }
            else if (SGInfo.IsAvailable)
            {
                machineId = SGInfo.Current.MachineId;
                ipAddress = SGInfo.Current.ClientIP.ToString();
            }
        }
    }

    [ComVisible(false)]
    public class XrlRequestException : ExceptionWithEventId
    {

        public XrlRequestException(string url, string message, HttpStatusCode statusCode, byte[] postData, Exception innerException) :
                base(XEvent.Id.MC_XRL_REQUEST_ERROR, "Error hitting URL " + url + "!!\r\n" + message + "\r\nStatus: " + statusCode + "\r\nPost data:" + ByteConvert.ToString(postData), innerException)
        {
            _url        = url;
            _statusCode = statusCode;
            _postData   = postData;
        }


        public string Url
        {
            get { return _url; }
        }

        public byte[] PostData
        {
            get { return _postData; }
        }

        public HttpStatusCode StatusCode
        {
            get { return _statusCode; }
        }


        private string         _url;
        private byte[]         _postData;
        private HttpStatusCode _statusCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xon.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Reflection;

namespace STF.common.service
{
    [ComVisible(false)]
    public class XOn
    {


        public const uint UTF8_MULT = 3;

        // Since most dateimes on the server are FILETIMEs on the
        // client, the miniumus are different and one causes
        // an overflow of the other.   So use this instead.
        // (look familiar?)
        public static DateTime MinDateTime = new DateTime(2002, 11, 15);



        //
        // special title ids
        //

        public const uint WEB_TITLE_ID               = 0xFFED0000;
        public const uint DASH_TITLE_ID              = 0xFFFE0000;
        public const uint XENON_DASH_TITLE_ID        = 0xFFFE07D1;
        public const uint XENON_LIVE_SIGNUP_TITLE_ID = 0xFFFE07DE;
        public const uint FUSION_TITLE_ID            = 0xFFFE07D2;
        public const uint XENON_LAUNCHER_TITLE_ID    = 0xFFFE07FF;
        public const uint TITLE_FAMILY_MASK          = 0xffff0000;
        public const uint XARCADE_TITLE_FAMILY       = 0x58410000;
        public const uint X_CUSTOM_PICTURE_TITLEID   = 0xFFFE0700;
        public const uint X_AVATAR_PICTURE_TITLEID   = 0xFFFE0854;
        public const uint PC_DASH_TITLE_ID           = 0x585207d1;
        public const uint MOBILE_TITLE_ID            = 0x4D5308EC;

        // this is the title id used by crux for music subscriptions, wcmusic security checks,
        // and crux video offers modeled in t_offers
        public const uint CRUX_TITLE_ID              = 0xFFFE0777;
        public const uint ZUNE_TITLE_ID              = 0xFFFD0000;

        //
        // general globals
        //
        public const uint MAX_TITLE_NAME_LEN                       = 255;
        public const uint XONLINE_MAX_LOGON_USERS                  = 4;
        public const uint XONLINE_MAX_ALTERNATE_TITLE_ID           = 4;
        public const uint XONLINE_MAX_DWORD_SERVICEIDS             = 4;
        public const uint XONLINE_GAMERTAG_SIZE                    = 16;
        public const uint MAX_TEAM_NAME_SIZE                       = 16;
        public const uint XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH = 12;

        //
        // offer types
        //
        public const uint XONLINE_OFFERING_SUBSCRIPTION = 1;
        public const uint XONLINE_OFFERING_CONTENT      = 2;
        public const uint XONLINE_OFFERING_RENEWAL      = 4;

        //
        //  Ticket flags
        //

        public const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        public const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        public const uint XONLINE_USER_NICKNAME_NOT_ALLOWED = 0x00040000;

        //
        // Parental control groups
        //
        public const int PARENTAL_CONTROL_GROUP_OPEN       = 0;
        public const int PARENTAL_CONTROL_GROUP_MEDIUM     = 1;
        public const int PARENTAL_CONTROL_GROUP_RESTRICTED = 2;


        // privilege bits
        ///////////////////////////////////////////////////////////////////////

        public const int XONLINE_MAX_PRIVILEGE_ID              = 256;
        public const int XONLINE_NUM_PRIVILEGE_DWORDS          = 8;
        public const int XONLINE_NUM_BASE_SERVICES_DWORDS      = 4;
        public const int XONLINE_NUM_MACHINE_PRIVILEGES_DWORDS = 1;
        public const int XONLINE_NUM_COMMON_PRIVILEGES_DWORDS  = 5; // Sum of machine privileges + base privileges
        public const int XONLINE_NUM_USER_PRIVILEGES_DWORDS    = 3;

        // machine privileges
        ///////////////////////////////////////////////////////////////////////

        public const int MPRIVILEGE_MIN                   = 128;
        public const int MPRIVILEGE_XONWATCH              = 128;
        public const int MPRIVILEGE_EDITORIAL             = 129;
        public const int MPRIVILEGE_NULL_ENCRYPTION       = 130;
        public const int MPRIVILEGE_CHALLENGE_BYPASS      = 131;
        public const int MPRIVILEGE_GEOFENCE_EXEMPT       = 132;
        public const int MPRIVILEGE_NETWORK_AUTH_LIST     = 133;
        public const int MPRIVILEGE_MAX                   = 160;

        // user privilege bits
        ///////////////////////////////////////////////////////////////////////

        public const int XPRIVILEGE_MAX = 255;
        public const int XPRIVILEGE_MIN = 209;

        // Add Friends
        public const byte XPRIVILEGE_ADD_FRIEND                                 = 255;

        // Sessions
        public const byte XPRIVILEGE_MULTIPLAYER_SESSIONS                       = 254;
        public const byte XPRIVILEGE_MULTIPLAYER_ENABLED_BY_TIER                = 253;

        // Communications
        public const byte XPRIVILEGE_COMMUNICATIONS                             = 252;
        public const byte XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY                = 251;

        // sending video messages is restricted by tier and needs a second bit
        public const byte XPRIVILEGE_VIDEO_MESSAGING_SEND                       = 250;

        // Profile
        public const byte XPRIVILEGE_PROFILE_VIEWING                            = 249;
        public const byte XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY               = 248;

        // Viewing of User Created Content
        public const byte XPRIVILEGE_USER_CREATED_CONTENT                       = 247;
        public const byte XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY          = 246;

        // Premium Content Purchases
        public const byte XPRIVILEGE_PURCHASE_CONTENT                           = 245;

        // Presence
        public const byte XPRIVILEGE_PRESENCE                                   = 244;
        public const byte XPRIVILEGE_PRESENCE_FRIENDS_ONLY                      = 243;

        // Xbox1 Live Access
        public const byte XPRIVILEGE_XBOX1_LIVE_ACCESS                          = 242;

        // Cross platform gameplay (PCs <-> Consoles)
        public const byte XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER                 = 241;

        // Cross platform system communication (PCs <-> Consoles)
        public const byte XPRIVILEGE_CROSS_PLATFORM_SYSTEM_COMMUNICATION        = 240;

        // Only users on consoles flagged for selective updates will have this
        public const byte XPRIVILEGE_PREVIOUS_LIVE_PROTOCOLS                    = 239;

        // Player-to-player trading
        public const byte XPRIVILEGE_TRADE_CONTENT                              = 238;

        // Argo explicit content
        public const byte XPRIVILEGE_MUSIC_EXPLICIT_CONTENT                     = 237;

        // Ability to test beta Live features
        public const byte XPRIVILEGE_TESTER_ACCESS                              = 236; // on (allow) | off (disallow)

        // Video Communications
        public const byte XPRIVILEGE_VIDEO_COMMUNICATIONS                       = 235;
        public const byte XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY          = 234;

        // Discoverability - let XBL-Friends send me a WL-Buddy request
        public const byte XPRIVILEGE_SHARE_WLID_WITH_FRIENDS                    = 233; // on (allow) | off (disallow)

        // Discoverability - let WL-Buddies send me an XBL-Friend request
        public const byte XPRIVILEGE_SHARE_GAMERTAG_WITH_BUDDIES                = 232; // on (allow) | off (disallow)

        public const byte XPRIVILEGE_METRO_ACCESS                               = 231; // on (allow) | off (disallow)

        public const byte XPRIVILEGE_SHARE_FRIENDS_LIST                         = 230; // on (allow) | off (disallow)
        public const byte XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY            = 229; // on (allow) | off (disallow)

        // Allow passport switching
        public const byte XPRIVILEGE_PASSPORT_SWITCHING                         = 228; // on (allow) | off (disallow)

        // Allow user to manage their payment instruments
        public const byte XPRIVILEGE_BILLING_SWITCHING                          = 227; // on (allow) | off (disallow)

        // Use of dedicated servers for multiplayer games (mainly PCs)
        public const byte XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER               = 226; // on (allow) | off (disallow)

        // user has a child account and is eligible to graduate
        public const byte XPRIVILEGE_USER_GRADUATION                            = 225; // on (allow) | off (disallow)

        // access to Netflix app
        public const byte XPRIVILEGE_PREMIUM_VIDEO                              = 224; // on (allow) | off (disallow)

        // access to Xbox Live Primetime (Server-Backed Games)
        public const byte XPRIVILEGE_PRIMETIME                                  = 223; // on (allow) | off (disallow)

        // user can publish content to their console
        public const byte XPRIVILEGE_CONTENT_AUTHOR                             = 222; // on (allow) | off (disallow)

        // user can query user PII
        public const byte XPRIVILEGE_PII_ACCESS                                 = 221; // on (allow) | off (disallow)

        // user can change their social network discoverability
        public const byte XPRIVILEGE_SOCIAL_NETWORK_SHARING                     = 220; // on (allow) | off (disallow)

        // user has subscription title privilege
        public const byte XPRIVILEGE_SUBSCRIPTION_TITLE                         = 219; // true | false

        // user has subscription content privilege   
        public const byte XPRIVILEGE_SUBSCRIPTION_CONTENT                       = 218; // true | false

        // purchase privilege can be onbtained with pin
        public const byte XPRIVILEGE_PURCHASE_CONTENT_REQUIRES_PIN              = 217; // true | false

        // passport switching can be obtained with pin
        public const byte XPRIVILEGE_PASSPORT_SWITCHING_REQUIRES_PIN            = 216; // true | false

        // billing switching can be obtain with pin
        public const byte XPRIVILEGE_BILLING_SWITCHING_REQUIRES_PIN             = 215; // true | false

        // user is entitled to premium content
        public const byte XPRIVILEGE_PREMIUM_CONTENT                            = 214; // true | false

        // user is entitled to family subscription functionality (family center)
        public const byte XPRIVILEGE_FAMILY                                     = 213; // true | false

        // unsafe or family programming for the user.
        public const byte XPRIVILEGE_UNSAFE_PROGRAMMING                         = 212; // on (regular programming) | off (family programming)

        // user is allowed to upload content to external providers
        public const byte XPRIVILEGE_SHARE_CONTENT                              = 211; // on (allow) | off (disallow)

        // used by customer support personnel to override default behaviour
        public const byte XPRIVILEGE_SUPPORT_OVERRIDE                           = 210; // on (allow) | off (disallow)

        // user is allowed to save games in cloud storage
        public const byte XPRIVILEGE_CLOUD_SAVED_GAMES                          = 209; // on (allow) | off (disallow)

        //
        //  User status flags
        //

        public const uint XONLINE_USER_STATUS_ACTIVE            = ((ushort)0x0001);
        public const uint XONLINE_USER_STATUS_LOCKED_OUT        = ((ushort)0x0002);
        public const uint XONLINE_USER_STATUS_MUST_CHANGE_NAME  = ((ushort)0x0004);

        //
        // User Machine Trust Level
        // 
        public const int  XONLINE_USER_MACHINE_TRUST_LEVEL_UNKNOWN_MACHINE = -2;
        public const int  XONLINE_USER_MACHINE_TRUST_LEVEL_UNKNOWN         = -1;
        public const int  XONLINE_USER_MACHINE_TRUST_LEVEL_NOT_TRUSTED     = 0;
        public const int  XONLINE_USER_MACHINE_TRUST_LEVEL_TRUSTED         = 1;

        //
        // Presence
        //

        public const uint XONLINE_MAX_FRIEND_COUNT        = 100;


        //
        // Supported Dash languages
        //

        public const uint XONLINE_LANGUAGE_MIN = 1;
        public const uint XONLINE_LANGUAGE_MAX = 12;

        //
        // XONLINEP_USER fields
        //

        public const uint XONLINE_NAME_SIZE               = 16;
        public const uint XONLINE_NAME_MAX_SIZE           = 15;
        public const uint XONLINE_KINGDOM_SIZE            = 12;
        public const uint XONLINE_KINGDOM_MAX_SIZE        = 11;
        public const uint XONLINE_PIN_LENGTH              = 4;
        public const uint XONLINE_MAX_STORED_ONLINE_USERS = 8;
        public const uint XONLINE_USER_SIGNATURE_LENGTH   = 8;
        public const uint XONLINE_USERDOMAIN_SIZE         = 20;
        public const uint XONLINE_REALM_NAME_SIZE         = 24;
        public const uint XONLINE_KEY_LENGTH              = 16;

        public const uint XONLINE_NICKNAME_MAX_SIZE       = 63;

        public const string XONLINE_REALM_NAME            = "PASSPORT.NET";


        //
        // USER_ACCOUNT_INFO fields
        //
        public const int MAX_FIRSTNAME_SIZE              = 64;
        public const int MAX_LASTNAME_SIZE               = 64;
        public const int MAX_EMAIL_SIZE                  = 129;
        public const int MAX_PHONE_PREFIX_SIZE           = 12;
        public const int MAX_PHONE_NUMBER_SIZE           = 12;
        public const int MAX_PHONE_EXTENSION_SIZE        = 12;
        public const int MAX_STREET_SIZE                 = 128;
        public const int MAX_CITY_SIZE                   = 64;
        public const int MAX_DISTRICT_SIZE               = 64;
        public const int MAX_STATE_SIZE                  = 64;
        public const int MAX_COUNTRYCODE_SIZE            = 2;
        public const int MAX_POSTALCODE_SIZE             = 16;
        public const int MAX_CC_NAME_SIZE                = 64;
        public const int MAX_CC_TYPE_SIZE                = 32;
        public const int MAX_CC_NUMBER_SIZE              = 24;
        public const int MAX_CC_EXPIRATION_SIZE          = 6;
        public const int MAX_BANK_CODE_SIZE              = 64;
        public const int MAX_BRANCH_CODE_SIZE            = 64;
        public const int MAX_CHECK_DIGITS_SIZE           = 64;

        public const int PRIVILEGE_DWORD_LENGTH          = 8;
        public const int ACCOUNT_PIN_LENGTH              = 4;
        public const int ACTIVATION_CODE_LENGTH          = 25;

        //
        // Number of XC_LANGUAGE_ defines in xbox.h (eg XC_LANGUAGE_ENGLISH).
        // Also the number of v1LanguageId members.
        //
        public const uint MAX_DASH_LANG_ID = 12;

        //
        // Passport
        //
        public const int XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN           = 113;
        public const int XONLINE_PASSPORT_PASSWORD_MAX_LEN              = 32;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN       = 5;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN       = 64;
        public const int XONLINE_PASSPORT_SECRET_ANSWER_MIN_LEN         = 5;
        public const int XONLINE_PASSPORT_SECRET_ANSWER_MAX_LEN         = 64;
        public const int XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN   = 2000;
        public const int XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN    = 128;
        public const int XONLINE_PASSPORT_SESSION_TOKEN_LEN             = 28;
        public const int XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN    = 384;
        public const int XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN = 128;
        public const int XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN         = 20;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT     = 10;
        public const int XONLINE_PASSPORT_LOGIN_NONCE_MIN_LEN           = 32;
        public const int XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN           = 32;
        public const int XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN    = 8192;
        public const int XONLINE_PASSPORT_LOGIN_SERVICE_ID_MIN          = 0;
        public const int XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID       = 0;
        public const int XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID     = 1;
        public const int XONLINE_PASSPORT_LOGIN_MESSENGER_SERVICE_ID    = 2;
        public const int XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX          = 2;
        public const ulong XONLINE_PASSPORT_INVALID_ID                  = 0xFFFFFFFFFFFFFFFF;

        //
        // Content
        //
        public const uint XONLINE_CONTENT_ID_LEN              = 20;
        public const uint XONLINE_CONTENT_SYMMETRIC_KEY_LEN   = 16;
        public const uint XONLINE_CONTENT_PUBLIC_KEY_LEN      = 284;
        public const uint XONLINE_CONTENT_XRL_MAX_LEN         = 256;
        public const uint XONLINE_CONTENT_LOCATIONS_MAX_COUNT = 10;
        public const uint XONLINE_CONTENT_LICENSE_MAX_LEN     = 2048;

        //
        // Diet Orange
        //
        public const uint REVOCATION_LIST_CLIENT_NONCE_SIZE   = 16;
        public const uint REVOCATION_LIST_SIGNATURE_SIZE      = 256;
        public const uint REVOCATION_LIST_SERVER_NONCE_SIZE   = 16;
        public const uint REVOCATION_LIST_MAX_ENTRIES         = 400;
        public const uint REVOCATION_LIST_ENTRY_DIGEST_SIZE   = 20;

        //
        // Title activation (China)
        //
        public const uint TITLE_ACTIVATION_LIST_SIGNATURE_SIZE = 256;
        public const uint TITLE_ACTIVATION_LIST_MAX_LEN        = 200; // arbitrary

        //
        // Storage
        //
        public const int  MAX_STORAGE_PATHNAME_LENGTH        = 255;
        public const int  MAX_STORAGE_PATHNAME_DOMAIN_LENGTH = 63;

        //
        // Query
        //
        public const int XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN = 400;
        public const int XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN   = 800;
        public const int XONLINE_QUERY_MAX_PAGE                 = 255;
        public const int XONLINE_QUERY_MAX_PAGE_SIZE            = 1024;
        public const int XONLINE_QUERY_MAX_SPECS                = 255;
        public const int XONLINE_QUERY_MAX_ATTRIBUTES           = 255;


        public const int X_ATTRIBUTE_DATATYPE_MASK              = 0x00F00000;
        public const int X_ATTRIBUTE_DATATYPE_INTEGER           = 0x00000000;
        public const int X_ATTRIBUTE_DATATYPE_STRING            = 0x00100000;
        public const int X_ATTRIBUTE_DATATYPE_BLOB              = 0x00200000;
        public const int X_ATTRIBUTE_DATATYPE_NULL              = 0x00F00000;

        public const int X_ATTRIBUTE_DATAFLAG_MASK              = 0x07000000;
        public const int X_ATTRIBUTE_DATAFLAG_MAPPED            = 0x01000000;
        public const int X_ATTRIBUTE_DATAFLAG_PARAM             = 0x02000000;
        public const int X_ATTRIBUTE_DATAFLAG_CONSTANT          = 0x04000000;

        public const uint XONLINE_TITLELOG_ATTR_DATE            = 0x8000000a;
        public const uint XONLINE_TITLELOG_ATTR_SERVICE         = 0x8000000b;
        public const uint XONLINE_TITLELOG_ATTR_SEVERITY        = 0x8000000c;
        public const uint XONLINE_TITLELOG_ATTR_MESSAGE         = 0x8010000d;
        public const uint XONLINE_TITLELOG_DATASET_ID           = 0xffff;

        //
        // Cron
        //
        public const int XONLINE_CRON_MIN_INTERVAL_SECS         = 60;

        //
        // event IDs - MUST MATCH VALUES IN xeventids.h
        //
        public const uint XeventStatusInfo                    = 0x40000001;
        public const uint XeventCodeError                     = 0xC0000002;
        public const uint XeventConfigError                   = 0xC0000003;
        public const uint XeventConfigWarning                 = 0x80000004;
        public const uint XeventCommFailedError               = 0xC0000005;
        public const uint XeventCommUnexpectedError           = 0xC0000006;
        public const uint XeventHackWarning                   = 0x80000007;
        public const uint XeventGameError                     = 0xC0000008;
        public const uint XeventPartnerError                  = 0xC0000009;


        //
        // protocol version number - MUST MATCH VALUES IN STF.x !!!
        //
        public const uint XONLINE_MATCHMAKING_SERVICE_VER         = 0x00010000;
        public const uint XONLINE_STATISTICS_SERVICE_VER          = 0x00010000;
        public const uint XONLINE_FEEDBACK_SERVICE_VER            = 0x00010000;
        public const uint XONLINE_BILLING_OFFERING_SERVICE_VER    = 0x00010000;
        public const uint XONLINE_PRESENCE_SERVICE_VER            = 0x00010000;
        public const uint XONLINE_MESSAGE_SERVICE_VER             = 0x00010000;
        public const uint XONLINE_AUTO_UPDATE_SERVICE_VER         = 0x00010000;
        public const uint XONLINE_BASE_SUBSCRIPTION_SERVICE_VER   = 0x00010000;
        public const uint XONLINE_USER_ACCOUNT_SERVICE_VER        = 0x00010000;

        public static uint ParseMajorVersion(uint uiversion)
        {
            return (uiversion >> 16);
        }

        public static uint ParseMinorVersion(uint uiversion)
        {
            return (uiversion & 0x0000ffff);
        }

        //
        // message types - required or recommended
        //
        public const uint XONLINE_MSGTYPE_RECOMMENDED       = 0;
        public const uint XONLINE_MSGTYPE_REQUIRED          = 1;

        //
        // message ids - these correspond to messages that can be put into a users message queue
        //
        public const uint XONLINE_MSGID_VOICEBAN_1_DAY      = 1;
        public const uint XONLINE_MSGID_VOICEBAN_1_WEEK     = 2;
        public const uint XONLINE_MSGID_VOICEBAN_2_WEEKS    = 3;
        public const uint XONLINE_MSGID_VOICEBAN_PERMANENT  = 4;
        public const uint XONLINE_MSGID_GAMECLIP_REMOVED    = 5;
        public const uint XONLINE_MSGID_RENEWAL             = 6;

        // key in httpcontext used to track error performance counters
        public const string ERROR_PERF_COUNTERS = "ErrorPerformanceCounters";
        public const string SOAP_ERROR_PERF_COUNTERS = "SoapErrorPerfCtrs";

        // From xbox.x, used by the String server and Messaging widget
        public const ushort XC_LANGUAGE_UNKNOWN             = 0;
        public const ushort XC_LANGUAGE_ENGLISH             = 1;
        public const ushort XC_LANGUAGE_JAPANESE            = 2;
        public const ushort XC_LANGUAGE_GERMAN              = 3;
        public const ushort XC_LANGUAGE_FRENCH              = 4;
        public const ushort XC_LANGUAGE_SPANISH             = 5;
        public const ushort XC_LANGUAGE_ITALIAN             = 6;
        public const ushort XC_LANGUAGE_KOREAN              = 7;
        public const ushort XC_LANGUAGE_TCHINESE            = 8;
        public const ushort XC_LANGUAGE_PORTUGUESE          = 9;
        public const ushort XC_LANGUAGE_SCHINESE            = 10;
        public const ushort XC_LANGUAGE_POLISH              = 11;
        public const ushort XC_LANGUAGE_RUSSIAN             = 12;

        //
        // Country Codes
        //
        public const uint XONLINE_COUNTRY_UNITED_ARAB_EMIRATES = 1;
        public const uint XONLINE_COUNTRY_ALBANIA              = 2;
        public const uint XONLINE_COUNTRY_ARMENIA              = 3;
        public const uint XONLINE_COUNTRY_ARGENTINA            = 4;
        public const uint XONLINE_COUNTRY_AUSTRIA              = 5;
        public const uint XONLINE_COUNTRY_AUSTRALIA            = 6;
        public const uint XONLINE_COUNTRY_AZERBAIJAN           = 7;
        public const uint XONLINE_COUNTRY_BELGIUM              = 8;
        public const uint XONLINE_COUNTRY_BULGARIA             = 9;
        public const uint XONLINE_COUNTRY_BAHRAIN              = 10;
        public const uint XONLINE_COUNTRY_BRUNEI_DARUSSALAM    = 11;
        public const uint XONLINE_COUNTRY_BOLIVIA              = 12;
        public const uint XONLINE_COUNTRY_BRAZIL               = 13;
        public const uint XONLINE_COUNTRY_BELARUS              = 14;
        public const uint XONLINE_COUNTRY_BELIZE               = 15;
        public const uint XONLINE_COUNTRY_CANADA               = 16;
        public const uint XONLINE_COUNTRY_SWITZERLAND          = 18;
        public const uint XONLINE_COUNTRY_CHILE                = 19;
        public const uint XONLINE_COUNTRY_CHINA                = 20;
        public const uint XONLINE_COUNTRY_COLOMBIA             = 21;
        public const uint XONLINE_COUNTRY_COSTA_RICA           = 22;
        public const uint XONLINE_COUNTRY_CZECH_REPUBLIC       = 23;
        public const uint XONLINE_COUNTRY_GERMANY              = 24;
        public const uint XONLINE_COUNTRY_DENMARK              = 25;
        public const uint XONLINE_COUNTRY_DOMINICAN_REPUBLIC   = 26;
        public const uint XONLINE_COUNTRY_ALGERIA              = 27;
        public const uint XONLINE_COUNTRY_ECUADOR              = 28;
        public const uint XONLINE_COUNTRY_ESTONIA              = 29;
        public const uint XONLINE_COUNTRY_EGYPT                = 30;
        public const uint XONLINE_COUNTRY_SPAIN                = 31;
        public const uint XONLINE_COUNTRY_FINLAND              = 32;
        public const uint XONLINE_COUNTRY_FAROE_ISLANDS        = 33;
        public const uint XONLINE_COUNTRY_FRANCE               = 34;
        public const uint XONLINE_COUNTRY_GREAT_BRITAIN        = 35;
        public const uint XONLINE_COUNTRY_GEORGIA              = 36;
        public const uint XONLINE_COUNTRY_GREECE               = 37;
        public const uint XONLINE_COUNTRY_GUATEMALA            = 38;
        public const uint XONLINE_COUNTRY_HONG_KONG            = 39;
        public const uint XONLINE_COUNTRY_HONDURAS             = 40;
        public const uint XONLINE_COUNTRY_CROATIA              = 41;
        public const uint XONLINE_COUNTRY_HUNGARY              = 42;
        public const uint XONLINE_COUNTRY_INDONESIA            = 43;
        public const uint XONLINE_COUNTRY_IRELAND              = 44;
        public const uint XONLINE_COUNTRY_ISRAEL               = 45;
        public const uint XONLINE_COUNTRY_INDIA                = 46;
        public const uint XONLINE_COUNTRY_IRAQ                 = 47;
        public const uint XONLINE_COUNTRY_IRAN                 = 48;
        public const uint XONLINE_COUNTRY_ICELAND              = 49;
        public const uint XONLINE_COUNTRY_ITALY                = 50;
        public const uint XONLINE_COUNTRY_JAMAICA              = 51;
        public const uint XONLINE_COUNTRY_JORDAN               = 52;
        public const uint XONLINE_COUNTRY_JAPAN                = 53;
        public const uint XONLINE_COUNTRY_KENYA                = 54;
        public const uint XONLINE_COUNTRY_KYRGYZSTAN           = 55;
        public const uint XONLINE_COUNTRY_KOREA                = 56;
        public const uint XONLINE_COUNTRY_KUWAIT               = 57;
        public const uint XONLINE_COUNTRY_KAZAKHSTAN           = 58;
        public const uint XONLINE_COUNTRY_LEBANON              = 59;
        public const uint XONLINE_COUNTRY_LIECHTENSTEIN        = 60;
        public const uint XONLINE_COUNTRY_LITHUANIA            = 61;
        public const uint XONLINE_COUNTRY_LUXEMBOURG           = 62;
        public const uint XONLINE_COUNTRY_LATVIA               = 63;
        public const uint XONLINE_COUNTRY_LIBYA                = 64;
        public const uint XONLINE_COUNTRY_MOROCCO              = 65;
        public const uint XONLINE_COUNTRY_MONACO               = 66;
        public const uint XONLINE_COUNTRY_MACEDONIA            = 67;
        public const uint XONLINE_COUNTRY_MONGOLIA             = 68;
        public const uint XONLINE_COUNTRY_MACAU                = 69;
        public const uint XONLINE_COUNTRY_MALDIVES             = 70;
        public const uint XONLINE_COUNTRY_MEXICO               = 71;
        public const uint XONLINE_COUNTRY_MALAYSIA             = 72;
        public const uint XONLINE_COUNTRY_NICARAGUA            = 73;
        public const uint XONLINE_COUNTRY_NETHERLANDS          = 74;
        public const uint XONLINE_COUNTRY_NORWAY               = 75;
        public const uint XONLINE_COUNTRY_NEW_ZEALAND          = 76;
        public const uint XONLINE_COUNTRY_OMAN                 = 77;
        public const uint XONLINE_COUNTRY_PANAMA               = 78;
        public const uint XONLINE_COUNTRY_PERU                 = 79;
        public const uint XONLINE_COUNTRY_PHILIPPINES          = 80;
        public const uint XONLINE_COUNTRY_PAKISTAN             = 81;
        public const uint XONLINE_COUNTRY_POLAND               = 82;
        public const uint XONLINE_COUNTRY_PUERTO_RICO          = 83;
        public const uint XONLINE_COUNTRY_PORTUGAL             = 84;
        public const uint XONLINE_COUNTRY_PARAGUAY             = 85;
        public const uint XONLINE_COUNTRY_QATAR                = 86;
        public const uint XONLINE_COUNTRY_ROMANIA              = 87;
        public const uint XONLINE_COUNTRY_RUSSIAN_FEDERATION   = 88;
        public const uint XONLINE_COUNTRY_SAUDI_ARABIA         = 89;
        public const uint XONLINE_COUNTRY_SWEDEN               = 90;
        public const uint XONLINE_COUNTRY_SINGAPORE            = 91;
        public const uint XONLINE_COUNTRY_SLOVENIA             = 92;
        public const uint XONLINE_COUNTRY_SLOVAK_REPUBLIC      = 93;
        public const uint XONLINE_COUNTRY_EL_SALVADOR          = 95;
        public const uint XONLINE_COUNTRY_SYRIA                = 96;
        public const uint XONLINE_COUNTRY_THAILAND             = 97;
        public const uint XONLINE_COUNTRY_TUNISIA              = 98;
        public const uint XONLINE_COUNTRY_TURKEY               = 99;
        public const uint XONLINE_COUNTRY_TRINIDAD_AND_TOBAGO  = 100;
        public const uint XONLINE_COUNTRY_TAIWAN               = 101;
        public const uint XONLINE_COUNTRY_UKRAINE              = 102;
        public const uint XONLINE_COUNTRY_UNITED_STATES        = 103;
        public const uint XONLINE_COUNTRY_URUGUAY              = 104;
        public const uint XONLINE_COUNTRY_UZBEKISTAN           = 105;
        public const uint XONLINE_COUNTRY_VENEZUELA            = 106;
        public const uint XONLINE_COUNTRY_VIET_NAM             = 107;
        public const uint XONLINE_COUNTRY_YEMEN                = 108;
        public const uint XONLINE_COUNTRY_SOUTH_AFRICA         = 109;
        public const uint XONLINE_COUNTRY_ZIMBABWE             = 110;

        //
        // Tiers
        //
        public const uint XONLINE_TIER_NEWUSER      = 0;
        public const uint XONLINE_TIER_SILVER       = 3;
        public const uint XONLINE_TIER_GOLD         = 6;
        public const uint XONLINE_TIER_FAMILY_GOLD  = 9;

        public static string UserTierToString(uint tier)
        {
            switch (tier)
            {
            case XOn.XONLINE_TIER_NEWUSER:
                return "None";
            case XOn.XONLINE_TIER_SILVER:
                return "Silver";
            case XOn.XONLINE_TIER_GOLD:
                return "Gold";
            case XOn.XONLINE_TIER_FAMILY_GOLD:
                return "FamilyGold";
            default:
                return tier.ToString();
            }
        }

        //
        // Gamer Profile stuff, used in statsfd
        //
        public const ushort XONLINE_MAX_SETTING_VALUE_BYTES = 1000;
        public const ushort XONLINE_MAX_SETTING_COUNT       = 32;
        public const ushort XONLINE_MAX_SETTING_RESPONSE_COUNT = 128;
        public const ushort XONLINE_MAX_SETTING_USERS       = 16;

        public const uint XSOURCE_NO_VALUE                  = 0;
        public const uint XSOURCE_DEFAULT                   = 1;
        public const uint XSOURCE_TITLE                     = 2;
        public const uint XSOURCE_PERMISSION_DENIED         = 3;

        // these are the enforcement bits applied to the setting ids
        public const uint XPROFILE_SETTING_ENFORCE_ACTIVITY     = 0x01;
        public const uint XPROFILE_SETTING_ENFORCE_UCC          = 0x02;
        public const uint XPROFILE_SETTING_ENFORCE_FRIENDS_ONLY = 0x04;

        public const uint XPROFILE_SETTING_TRANSIENT_ONLY       = 0x08;

        public const uint XPROFILE_SETTING_ENFORCE_CONSOLE_RO   = 0x10;
        public const uint XPROFILE_SETTING_ENFORCE_WEB_RO       = 0x20;
        public const uint XPROFILE_SETTING_ENFORCE_TITLE_RO     = 0x40;
        public const uint XPROFILE_SETTING_ENFORCE_NOT_SHARED   = 0x80;

        public const uint XPROFILE_SETTING_ENFORCE_VIDEO        = 0x100;

        // these are the permissions users can select for themselves
        public const byte XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE   = 0x01;
        public const byte XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS = 0x02;
        public const byte XPROFILE_PERMISSION_SHARE_UCC_NOONE        = 0x04;
        public const byte XPROFILE_PERMISSION_SHARE_UCC_FRIENDS      = 0x08;
        public const byte XPROFILE_PERMISSION_SHARE_MUSIC_NOONE      = 0x10;
        public const byte XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS    = 0x20;
        public const byte XPROFILE_PERMISSION_SHARE_VIDEO_OPTION     = 0x40;
        public const byte XPROFILE_PERMISSION_SHARE_VIDEO_EVERYONE   = 0x80;
        public const uint XPROFILE_PERMISSION_SHARE_AUDIO_DATA_COLL = 0x100;

        public const uint XPROFILE_PERMISSIONS                  = 0x10040000;


        // title types
        public const uint TITLE_TYPE_SYSTEM = 0;
        public const uint TITLE_TYPE_STANDARD = 1;
        public const uint TITLE_TYPE_DEMO = 2;
        public const uint TITLE_TYPE_ARCADE = 3;
        public const uint TITLE_TYPE_APPLICATION = 5;

        // achievement flags
        public const uint XACHIEVEMENT_DETAILS_MASK_TYPE = 0x00000007;
        public const uint XACHIEVEMENT_DETAILS_SHOWUNACHIEVED = 0x00000008;
        public const uint XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE = 0x00010000;
        public const uint XACHIEVEMENT_DETAILS_ACHIEVED = 0x00020000;
        public const uint XACHIEVEMENT_DETAILS_NOT_ACHIEVABLE = 0x00040000;
        public const uint XACHIEVEMENT_DETAILS_WAS_NOT_ACHIEVABLE = 0x00080000;

        public const uint XACHIEVEMENT_DETAILS_PLATFORM_MASK = 0x00700000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_360 = 0x00100000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_PC = 0x00200000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_MOBILE = 0x00300000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES = 0x00400000;
        public const int XACHIEVEMENT_DETAILS_PLATFORM_SHIFT = 20;

        // avatar asset flags
        public const uint XAVATAR_DETAILS_MASK_TYPE = 0x00000007;
        public const uint XAVATAR_DETAILS_SHOWUNACHIEVED = 0x00000008;

        public const uint XAVATAR_DETAILS_STATUS_MASK = 0x010F0000;
        public const uint XAVATAR_DETAILS_ACHIEVED_ONLINE = 0x00010000;
        public const uint XAVATAR_DETAILS_ACHIEVED = 0x00020000;
        public const uint XAVATAR_DETAILS_NOT_ACHIEVABLE = 0x00040000;
        public const uint XAVATAR_DETAILS_WAS_NOT_ACHIEVABLE = 0x00080000;
        public const uint XAVATAR_DETAILS_COLORIZABLE = 0x01000000;

        public const uint XAVATAR_DETAILS_PLATFORM_MASK = 0x00700000;
        public const uint XAVATAR_DETAILS_PLATFORM_360 = 0x00100000;
        public const uint XAVATAR_DETAILS_PLATFORM_PC = 0x00200000;
        public const uint XAVATAR_DETAILS_PLATFORM_MOBILE = 0x00300000;
        public const uint XAVATAR_DETAILS_PLATFORM_WEB_GAMES = 0x00400000;
        public const int XAVATAR_DETAILS_PLATFORM_SHIFT = 20;

        // marketplace genre constants that will be hardcoded into the client
        public const int XONLINE_GENRE_BASE           = 0;
        public const int XONLINE_GENRE_XARCADE      = 116000000;

        //
        // Achievements (statsfd)
        //
        public const ushort XONLINE_MAX_ACHIEVEMENTS = 32;
        public const uint XONLINE_SERVER_ACHIEVEMENT_SEQUENCE = 0xffffffff;
        public const uint XACHIEVEMENT_INVALID_ID = 0xffffffff;

        //
        // Avatar Assets (statsfd)
        //
        public const ushort XONLINE_MAX_AVATAR_ASSETS       = 32;

        // body types that that an asset applies to.
        public const byte XAVATAR_BODY_TYPE_UNKNOWN         = 0x00;
        public const byte XAVATAR_BODY_TYPE_MALE            = 0x01;
        public const byte XAVATAR_BODY_TYPE_FEMALE          = 0x02;
        public const byte XAVATAR_BODY_TYPE_ALL             = 0x03;

        // body component associated with each asset.
        public const uint XAVATAR_COMPONENT_MASK_NONE       = 0x0000;
        public const uint XAVATAR_COMPONENT_MASK_HEAD       = 0x0001;
        public const uint XAVATAR_COMPONENT_MASK_BODY       = 0x0002;
        public const uint XAVATAR_COMPONENT_MASK_HAIR       = 0x0004;
        public const uint XAVATAR_COMPONENT_MASK_SHIRT      = 0x0008;
        public const uint XAVATAR_COMPONENT_MASK_TROUSERS   = 0x0010;
        public const uint XAVATAR_COMPONENT_MASK_SHOES      = 0x0020;
        public const uint XAVATAR_COMPONENT_MASK_HAT        = 0x0040;
        public const uint XAVATAR_COMPONENT_MASK_GLOVES     = 0x0080;
        public const uint XAVATAR_COMPONENT_MASK_GLASSES    = 0x0100;
        public const uint XAVATAR_COMPONENT_MASK_WRISTWEAR  = 0x0200;
        public const uint XAVATAR_COMPONENT_MASK_EARRINGS   = 0x0400;
        public const uint XAVATAR_COMPONENT_MASK_RING       = 0x0800;
        public const uint XAVATAR_COMPONENT_MASK_CARRYABLE  = 0x1000;
        public const uint XAVATAR_COMPONENT_MASK_ALL        = 0x1FFF;

        //
        // Titles (statsfd)
        //
        public const ushort XPROFILE_MAX_ENUM_TITLE         = 32;

        //
        // Leaderboard/Stats API (statsfd)
        //
        public const ushort XONLINE_MAX_STATS_OP_COUNT      = 1000;
        public const ushort XONLINE_MAX_STATS_OP_PARAMS     = 256;
        public const ushort XONLINE_MAX_STATS_OP_PARAM_DATA = 1024;
        public const ushort XONLINE_MAX_STATS_COL_COUNT     = 64;
        public const ushort XONLINE_MAX_STATS_ROW_COUNT     = 1000;
        public const ushort XONLINE_MAX_STATS_SPEC_COUNT    = 1000;
        public const ushort XONLINE_MAX_STATS_USER_COUNT    = 101;
        public const ushort XONLINE_MAX_STATS_ENUM_COUNT    = 100;
        public const ushort XONLINE_MAX_STATS_ENUM_SPEC_COUNT = 10;
        public const ushort XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT = 101;
        public const ushort XONLINE_MAX_STATS_ATTACHMENT_COUNT = 65535; //in xlast it is USHORT

        //
        // liveinfo
        //
        public const ushort XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH = 64;

        //
        // xsig
        //
        public const uint XONLINE_SIG_MAX_CONTENT_TUPLES    = 32;

        //
        // parental controls
        //
        public const short XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH = 100;

        //
        // Ids
        //
        public class XboxId
        {
            public const UInt64 Mask                = 0xFFFF000000000000;
            public const UInt64 UserBase            = 0x0009000000000000;
            public const UInt64 XboxMachineBase     = 0x0009000000000000;
            public const UInt64 XenonConsoleBase    = 0xF000000000000000;
            public const UInt64 XenonMachineBase    = 0xFA00000000000000;
            public const UInt64 PcMachineBase       = 0xFB00000000000000;
            public const UInt64 MobileMachineBase   = 0xFC00000000000000;

            // note this is not a real machine base.  xbox.com is  faking
            // machine ids by passing session ids with this 2 byte prefix

            public const UInt64 XboxComMachineBase  = 0xFFED000000000000;


            public static bool IsUserPuid(UInt64 id)          { return (id & Mask) == UserBase; }
            public static bool IsXboxMachinePuid(UInt64 id)   { return (id & Mask) == XboxMachineBase; }
            public static bool IsXenonMachinePuid(UInt64 id)  { return (id & Mask) == XenonMachineBase; }
            public static bool IsPcMachinePuid(UInt64 id)     { return (id & Mask) == PcMachineBase; }
            public static bool IsMobileMachinePuid(UInt64 id) { return (id & Mask) == MobileMachineBase; }
            public static bool IsXboxcomMachinePuid(UInt64 id) { return (id & Mask) == XboxComMachineBase; }    // Note: Intentionally omitted from IsMachinePuid (it's not a real machine we can verify)
            public static bool IsMachinePuid(UInt64 id)       { return IsXboxMachinePuid(id) || IsXenonMachinePuid(id) || IsPcMachinePuid(id) || IsMobileMachinePuid(id); }

            public static byte GetPlatformType(UInt64 id)
            {
                if(IsXboxMachinePuid(id))
                {
                    return XOn.XPLT_XBOX1;
                }
                else if(IsXenonMachinePuid(id))
                {
                    return XOn.XPLT_XBOX360;
                }
                else if(IsPcMachinePuid(id))
                {
                    return XOn.XPLT_PC;
                }
                else if(IsMobileMachinePuid(id))
                {
                    return XOn.XPLT_MOBILE;
                }
                else if(IsXboxcomMachinePuid(id))
                {
                    return XOn.XPLT_WEB;
                }
                else
                {
                    throw new Exception(string.Format("Invalid platform type. Machine-id=0x{0}", id));
                }
            }

        }

        // -----------------------------------------------------------------------------
        // Platform types
        // These constants are used by CAuthData3 and SGADDR2 to identify the platform
        // type
        // -----------------------------------------------------------------------------
        public const byte XPLT_XBOX1            = 0;
        public const byte XPLT_XBOX360          = 1;
        public const byte XPLT_PC               = 2;
        public const byte XPLT_INTERNAL         = 3;
        public const byte XPLT_WEB              = 4;
        public const byte XPLT_INTERNAL_XBOXCOM = 5;
        public const byte XPLT_INTERNAL_ZUNE    = 6;
        public const byte XPLT_INTERNAL_XNA     = 7;
        public const byte XPLT_INTERNAL_WGX     = 8;

        public const byte XPLT_ZUNEV1           = 9;
        public const byte XPLT_ZUNEV2           = 10;
        public const byte XPLT_MEDIA_CENTER     = 11;
        public const byte XPLT_ZUNEV3           = 12;
        public const byte XPLT_ZUNE_MOBILE      = 13;

        public const byte XPLT_INTERNAL_LIVEN   = 14;
        public const byte XPLT_MOBILE           = 15;
        public const byte XPLT_WEB_GAMES        = 16;

        public const byte XPLT_INVALID          = 255;


        //
        // Console audit list (statsfd)
        //
        public const ushort XONLINE_MAX_CONSOLE_AUDIT_LIST = 100;

        //
        // Offers
        //
        public const ulong FREE_GAMERTAG_OFFER = 0xFFFE07D10AA00002;
        public const ulong SILVER_OFFER = 0xFFFE07D180000011;
    }


    // -----------------------------------------------------------------------------
    // Xbox Live Http Headers (Internal) - Never seen by a client
    // -----------------------------------------------------------------------------
    public static class XHttpHdr
    {
        public const string XPLT                = "XPLT";                     // SGInfo
        public const string XPLT_I              = "XPLTOnBehalfOf";           // SGInfo
        public const string SGIPPORT            = "SGIPPort";                 // SGInfo, XRLScan
        public const string SERVERPORT          = "ServerPort";               // SGInfo, XRLScan
        public const string HTTPAUTHDATA        = "HTTPAuthData";             // SGInfo
        public const string BUNDLEDAUTHDATA     = "BundledAuthData";          // SGInfo
        public const string AUTHZ               = "AuthZ";                    // AAInfo
        public const string LOADBALANCER_ISSSL  = "X-LB-Is-Ssl";              // SSL LB -> AAModule
        public const string CERT_SUBJECT        = "X-LB-Cert-Subject-Name";   // SSL LB -> AAModule
        public const string CERT_THUMBPRINT     = "X-LB-Cert-Thumbprint";     // SSL LB -> AAModule
        public const string CERT_EKULIST        = "X-LB-Cert-EKU-List";       // SSL LB -> AAModule
        public const string SUBJECTNAME         = "Subject-Name";             // WebSG
        public const string CLIENTIPPORT        = "Client-IP-Port";           // WebSG
        public const string REQUESTID           = "RequestId";                // WebSG
        public const string WEBCACHEREQUEST     = "WebCacheSource";           // WebCache, Query
        public const string HEADERCOLLECTION    = "HTTPHeaderCollection";     // LiveCache
        public const string THMSESSIONID        = "THM_session_id";           // LiveCache, Billing


        public static bool IsKnownInternalHeader(string header)
        {
            if (String.IsNullOrEmpty(header))
                return false;
            else
                return _InternalHeaders.ContainsKey(header.ToLower());
        }

        static XHttpHdr()
        {
            _InternalHeaders = new Dictionary<string, string>();

            FieldInfo[] fi = typeof(XHttpHdr).GetFields(
                BindingFlags.Static |
                BindingFlags.DeclaredOnly |
                BindingFlags.Public);

            foreach (FieldInfo f in fi)
            {
                try
                {
                    string h = (string)f.GetValue(null);
                    _InternalHeaders[h.ToLower()] = f.Name;
                }
                catch {}  // not much we can do in a static constructor
            }
        }

        private static Dictionary<string, string> _InternalHeaders;

    }

    public static class XDateTime
    {
        public static DateTime Now
        {
            get 
            {
                return DateTime.UtcNow;
            }
        }

        public static string NowStr
        {
            get
            {
                return ToString(XDateTime.Now);
            }
        }

        public static string ToString(DateTime now)
        {
            // Gets a consistently-formatted string of the form:
            //   2010/07/23 23:53:47.487
            //   
            // For 1M iterations, the timings are:
            //   1.877s: str = now.ToString("yyyy/MM/dd HH:mm:ss.fff");
            //   0.440s: the unrolled ugliness below
            // Blech. Sorry.

            char[] charstr = new char[23];
            int idx = 0;
            int n = now.Year;
            charstr[idx++] = (char)('0' + (n / 1000) % 10);
            charstr[idx++] = (char)('0' + (n / 100) % 10);
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = '/';
            n = now.Month;
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = '/';
            n = now.Day;
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = ' ';
            n = now.Hour;
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = ':';
            n = now.Minute;
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = ':';
            n = now.Second;
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            charstr[idx++] = '.';
            n = now.Millisecond;
            charstr[idx++] = (char)('0' + (n / 100) % 10);
            charstr[idx++] = (char)('0' + (n / 10) % 10);
            charstr[idx++] = (char)('0' + (n / 1) % 10);
            return new string(charstr);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\xsigprot.cs ===
/*==========================================================================
 *
 *  XSigProt.cs -- This module defines the wire protocol for Signature server
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Xml.Serialization;

using STF.common.service;
namespace STF.common.protocol
{
    public class XSigAuthData : WireData
    {
        public uint        _titleID;
        public uint        _titleVersion;
        public ulong       _XboxID;
        public ulong       _userID1;
        public ulong       _userID2;
        public ulong       _userID3;
        public ulong      _userID4;
        static public int GetSizeInBytes()
        {
            return 48;
        }
    };

    // ------------------------------------------
    //      SignOnBehalf request
    // ------------------------------------------
    public class XSigSignOnBehalfRequest : XRLObject2
    {
        public const int XONLINE_XSIG_DIGEST_SIZE=20;
        public uint        _serviceId;

        [WireInfo(ArraySize=XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;

        public XSigAuthData  _authData;

        static public int GetSizeInBytes()
        {
            return 4+XSigAuthData.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public virtual new string ToString()
        {
            string szSigData = _serviceId.ToString("X8") + "|"
                +(ByteConvert.ToString(_digest))+ "|"
                + _authData._titleID.ToString("X8") + "|"
                + _authData._titleVersion.ToString("X8") + "|"
                + _authData._XboxID.ToString("X16") + "|"
                + _authData._userID1.ToString("X16") + "|"
                + _authData._userID2.ToString("X16") + "|"
                + _authData._userID3.ToString("X16") + "|"
                + _authData._userID4.ToString("X16");

            return szSigData;
        }

        public override string Xrl
        {
            get { return "/xsig/SignOnBehalf.ashx"; }
        }
    }

    // ------------------------------------------
    //      GetSigningKey request
    // ------------------------------------------
    //
    // None: This request type takes no input data.


    public class XSigSignature : XRLObject2
    {
        public const int XONLINE_XSIG_RESERVED_SIZE = 16;
        public const int XONLINE_XSIG_SIGNATURE_KEY_SIZE = 20;
        public const short XONLINE_XSIG_SIGNATURE_VERSION = 1;

        public short       _signatureVersion = XONLINE_XSIG_SIGNATURE_VERSION;
        public short       _keyVersion;
        public uint        _serviceId = 0;
        public long        _timeStamp ;
        public XSigAuthData       _authData;
        [WireInfo(ArraySize=XONLINE_XSIG_RESERVED_SIZE)]
        public byte[]  _reserved;
        [WireInfo(ArraySize=XONLINE_XSIG_SIGNATURE_KEY_SIZE)]
        public byte[]  _signature;

        [WireInfo(Serialize=false)]
        public ulong _liNonce = 0;

        static public int GetSizeInBytes()
        {
            return 16 + XSigAuthData.GetSizeInBytes() + XONLINE_XSIG_RESERVED_SIZE + XONLINE_XSIG_SIGNATURE_KEY_SIZE;
        }

        // NOTE: Since WireData overloads operator byte[], casting this object to a byte[] will allow you to
        // get the signature for use as a binary array.

        public virtual new string ToString()
        {
            string szSigData;

            if ( this._signature == null )
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    "null";
            }
            else
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    (ByteConvert.ToString(this._signature));
            }

            return szSigData;
        }

    };

    // ------------------------------------------
    //      SignOnBehalf response
    // ------------------------------------------
    public class XSigSignOnBehalfResponse : XRLObject2
    {
        public uint          _hresult;
        public XSigSignature _signature;
    }

    // ------------------------------------------
    //      XSigVerifySignatureRequest request
    // ------------------------------------------
    public class XSigVerifySignatureRequest : XRLObject2
    {
        [WireInfo(ArraySize=XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;
        public XSigSignature  _signature;

        static public int GetSizeInBytes()
        {
            return XSigSignature.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public override string Xrl
        {
            get { return "/xsig/VerifySignature.ashx"; }
        }
    }

    // ------------------------------------------
    //      XSigVerifySignatureResponse
    // ------------------------------------------
    public class XSigVerifySignatureResponse : XRLObject2
    {
         public uint      _hresult;
    }

    // ------------------------------------------
    //      CheckRevocation
    // ------------------------------------------

    public class ContentTuple : WireData
    {
        public uint TitleId;
        public uint TitleVersion;
        public ulong ConsolePuid;

        [WireInfo(ArraySize=5)]
        public byte[] ConsoleId = new byte[5];

        [WireInfo(ArraySize=4)]
        public ulong[] UserPuid = new ulong[4];

        [WireInfo(ArraySize=20)]
        public byte[] Digest = new byte[20];

        public override WireData ReadStream(BinaryReader reader)
        {
            TitleId = reader.ReadUInt32();
            TitleVersion = reader.ReadUInt32();
            ConsolePuid = reader.ReadUInt64();

            ConsoleId = reader.ReadBytes(5);
            if (ConsoleId.Length != 5)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.COMMON_CODE_177, "failed to read 5 bytes for ConsoleID!");
            }


            for (int i = 0; i < UserPuid.Length; i++)
                UserPuid[i] = reader.ReadUInt64();

            Digest = reader.ReadBytes(20);
            if (Digest.Length != 20)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.COMMON_CODE_178, "failed to read 20 bytes for Digest!");
            }

            return this;
        }

    }

    public class CheckRevocationRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumContentTuples = 0;

        [WireInfo(SizeParam="NumContentTuples")]
        public ContentTuple[] Tuples = new ContentTuple[0];

        public override string Xrl
        {
            get { return "/xsig/CheckRevocation.ashx"; }
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            NumContentTuples = reader.ReadUInt32();
            if (NumContentTuples > XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_CODE_179, "Rquest contained too many Content Tuples!");
            }

            Tuples = new ContentTuple[NumContentTuples];
            for (int i = 0; i < NumContentTuples; i++)
            {
                Tuples[i] = new ContentTuple();
                Tuples[i].ReadStream(reader);
            }

            return this;
        }

    }

    public class CheckRevocationResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumHrs = 0;

        [WireInfo(SizeParam="NumHrs")]
        public uint[] Hrs = new uint[0];

        public override void WriteStream(BinaryWriter writer)
        {
            writer.Write(Hrs.Length);
            for (int i = 0; i < Hrs.Length; i++)
            {
                writer.Write(Hrs[i]);
            }
        }
    }


    public class XmstvCreateCertificateRequest : XRLObject2
    {
        const int RSAPUB_2048_SIZE = 272;
        public const int SHA1_DIGEST_SIZE = 20;

        public uint Flags;

        [WireInfo(ArraySize=RSAPUB_2048_SIZE)]
        public byte[] AvPubKey;

        [WireInfo(ArraySize=RSAPUB_2048_SIZE)]
        public byte[] NonAvPubKey;

        public ulong KeyNonce;

        [WireInfo(ArraySize=SHA1_DIGEST_SIZE)]
        public byte[] KeyedHash;

        public override string Xrl
        {
            get
            {
                return "/xsig/XmstvCreateCertificate.ashx";
            }
        }
    }


    public class XmstvCreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvCertificateSize;

        [WireInfo(SizeParam="AvCertificateSize")]
        public byte[] AvCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvSerializedCertificateSize;

        [WireInfo(SizeParam="AvSerializedCertificateSize")]
        public byte[] AvSerializedCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvCertificateSize;

        [WireInfo(SizeParam="NonAvCertificateSize")]
        public byte[] NonAvCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvSerializedCertificateSize;

        [WireInfo(SizeParam="NonAvSerializedCertificateSize")]
        public byte[] NonAvSerializedCertificate;
    }


    public class CreateCertificateRequest : XRLObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int RSAPUB_2048_SIZE = 272;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        public ulong userPuid;

        [WireInfo(ArraySize = RSAPUB_2048_SIZE)]
        public byte[] PubKey;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate.ashx";
            }
        }
    }


    public class CreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }

    public class CreateCertificate2Request : XRLObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        [WireInfo(ArraySize = XE_CONSOLE_CERTIFICATE_SIZE - CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] ConsoleCertificate;

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate2.ashx";
            }
        }
    }

    public class XEConsoleCertificate : WireData
    {
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_ID_SIZE = 5;
        public const int CONSOLE_CERT_PART_NUMBER_SIZE = 11;
        public const int CONSOLE_CERTIFICATE_RESERVED_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_EXPONENT_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_MODULUS_SIZE = 128;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = XE_CONSOLE_CERTIFICATE_SIZE)]
        public ushort CertSize;             // Size of this structure (424);

        [WireInfo(ArraySize = CONSOLE_ID_SIZE)]
        public byte[] ConsoleId;            // Uniquely ids console

        [WireInfo(ArraySize = CONSOLE_CERT_PART_NUMBER_SIZE)]
        public byte[] ConsolePartNumber;    // Identifies mfg part number

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_RESERVED_SIZE)]
        public byte[] Reserved;             // Reserved for future use

        public ushort Privileges;           // Privileges for SG

        public uint ConsoleType;            // States whether console is a retail or dev/test kit

        public ulong ManufacturingDate;     // Date of mfg for console

        [WireInfo(ArraySize = CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[] ConsolePublicKey;     // Console's Public Key

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;      // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)

    }

    public class CreateCertificate2Response : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }

    public interface ILicenseApiResponse
    {
        MediaInstanceIdOfferIdPair IdPair { get; set; }
        HResult Hr { get; set; }
    }

    public class MediaInstanceIdOfferIdPair : WireData
    {
        public Guid miid;
        public Guid oid;
    }

    public class MediaLicense : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public ushort licenseType;

        public const int LICENSE_BLOCK_MAX_COUNT = 13;

        [XmlIgnoreAttribute]
        [WireInfo(Max=LICENSE_BLOCK_MAX_COUNT)]
        public ushort licenseBlockCount;

        [XmlIgnoreAttribute]
        [WireInfo(SizeParam="licenseBlockCount")]
        public XeGenericBlock[] licenseBlocks;

        [WireInfo(Serialize=false)]
        public byte[] license;

        public HResult hr;

        [XmlIgnoreAttribute]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnoreAttribute]
        public HResult Hr { get { return hr; } set { hr = value; } }
    }

    public class AcquireMediaLicensesRequest : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        public ulong userPuid;

        public const int CLIENT_INFO_BLOCK_MAX_COUNT = 13;

        [WireInfo(Min=1, Max=CLIENT_INFO_BLOCK_MAX_COUNT)]
        public ushort clientInfoBlockCount;

        [WireInfo(SizeParam="clientInfoBlockCount")]
        public XeGenericBlock[] clientInfoBlocks;

        public override string Xrl { get { return "/xsig/AcquireMediaLicenses.ashx"; } }
    }

    public class AcquireMediaLicensesResponse : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort mediaLicensesLength;

        [WireInfo(SizeParam="mediaLicensesLength")]
        public MediaLicense[] mediaLicenses;
    }


    public class Acknowledgement : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public HResult hr;

        [XmlIgnoreAttribute]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnoreAttribute]
        public HResult Hr { get { return hr; } set { hr = value; } }
    }

    public class AcknowledgeLicensesDeliveryRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        public override string Xrl { get { return "/xsig/AcknowledgeLicensesDelivery.ashx"; } }
    }

    public class AcknowledgeLicensesDeliveryResponse : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort acknowledgementsLength;

        [WireInfo(SizeParam="acknowledgementsLength")]
        public Acknowledgement[] acknowledgements;
    }


    public class RefreshGameLicenseRequest : XRLObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl { get { return "/xsig/RefreshGameLicense.ashx"; } }
    }

    public class RefreshGameLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }

    public enum UpdateTransferStateEnum
    {
        Start,
        Complete,
        Cancel
    }

    public class UpdateLicenseTransferStateRequest : XRLObject2
    {
        public UpdateTransferStateEnum command;

        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/UpdateLicenseTransferState.ashx"; } }
    }

    public enum LicenseTransferStatusEnum
    {
        LicenseTransferTimeout = -2,
        MultipleSignInDetected = -1,

        NotStarted = 0,
        PendingConsoleSignIn = 1,
        PendingUserConfirmation = 2,
        Completed = 3
    }

    public class GetLicenseTransferStateRequest : XRLObject2
    {
        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/GetLicenseTransferState.ashx"; } }
    }

    public class ConsoleLicenseCount : WireData
    {
        public UInt32 licenseCount;

        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;
    }

    public class GetLicenseTransferStateResponse : XRLObject2
    {
        public const int XONLINE_CONSOLEID_LENGTH   = 16;
        public const int XONLINE_CONSOLE_ARRAY_SIZE = 100;

        public LicenseTransferStatusEnum currentStatus = LicenseTransferStatusEnum.NotStarted;

        public Boolean restartAllowed = true;

        public DateTime lastUpdated = WireData.MinDateTimeValue;

        [WireInfo(Max = XONLINE_CONSOLEID_LENGTH)]
        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;

        [WireInfo(Max = XONLINE_CONSOLE_ARRAY_SIZE)]
        public UInt16 sourceConsolesLength;

        [WireInfo(SizeParam = "sourceConsolesLength")]
        public ConsoleLicenseCount[] sourceConsoles;

        public UInt16 sourceVideoConsolesLength;

        [WireInfo(SizeParam = "sourceVideoConsolesLength")]
        public ConsoleLicenseCount[] sourceVideoConsoles;

        [WireInfo(MinSchemaVersion = "7.0")]
        public DateTime nextAvailableTransfer = WireData.MinDateTimeValue;

    }


    public sealed class GetSignedHeaderRequest : XRLObject2
    {
        public const int XONLINE_HEADER_HASH_SIZE = 20;

        public const uint ONLY_LEGAL_FILE_TYPE = 0x52475459;

        public UInt32 fileSize;

        public UInt32 fileType;

        [WireInfo(ArraySize = XONLINE_HEADER_HASH_SIZE)]
        public byte[] fileHash;

        public override string Xrl { get { return "/xsig/GetSignedHeader.ashx"; } }
    }

    public sealed class GetSignedHeaderResponse : XRLObject2
    {
        public UInt32 headerSize;

        [WireInfo(SizeParam = "headerSize", LimitString = true)]
        public byte[] header;
    }

    public sealed class ValidateCertificateRequest : XRLObject2
    {
        // Everyone loves powers of 2.
        public const int MAX_CERT_SIZE = 32768;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort certificateSize;

        [WireInfo(SizeParam = "certificateSize")]
        public byte[] certificate;

        public override string Xrl
        {
            get
            {
                return "/xsig/ValidateCertificate.ashx";
            }
        }
    }

    public sealed class ValidateCertificateResponse : XRLObject2
    {
        public HResult  hr;
        public DateTime validUntil;
    }

    public class CreatePlayReadyCertificateRequest : XRLObject2
    {
        public const int PUBLIC_SIGNING_KEY_LEN = 64;
        public const int PUBLIC_ENCRYPTION_KEY_LEN = 64;

        [WireInfo(Min=0, Max=0)]
        public uint flags;

        [WireInfo(ArraySize=PUBLIC_SIGNING_KEY_LEN)]
        public byte[] publicSigningKey;

        [WireInfo(ArraySize=PUBLIC_ENCRYPTION_KEY_LEN)]
        public byte[] publicEncryptionKey;

        public override string Xrl { get { return "/xsig/CreatePlayReadyCertificate.ashx"; } }
    }

    public class CreatePlayReadyCertificateResponse : XRLObject2
    {
        public const int CERTIFICATE_BLOCK_MAX_COUNT = 3;

        [WireInfo(Min=1, Max=CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;

        [WireInfo(SizeParam="certBlockCount")]
        public XeGenericBlock[] certBlocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\sts\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.sts.WebService
{
    public class SvcProviderWrapper : SecurityTicket
    {
        public static int   TimeOut=25000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        public string ServerAddr;
        public ulong PassportPuid;
        public ulong Xuid;
        public ulong MachinePuid;
        public uint TitleId;

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }

        new public string GetPartnerSecurityTicket(ulong xuid, uint titleId, ushort titleVersion) 
        {
            string results = base.GetPartnerSecurityTicket(xuid, titleId, titleVersion);
            
            return (results);
        }

        new public string GetSecurityTicket(byte platformType, uint titleId, ushort titleVersion, ushort clientVersion, string deviceId) 
        {
            string results = base.GetSecurityTicket(platformType, titleId, titleVersion, clientVersion, deviceId);
                        
            return (results);
        }
        
        



        public SvcProviderWrapper() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.sts))
        {
            ;
        }


        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/sts/sts.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/sts/sts.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            FakeAAInfo fakeAAInfo = new FakeAAInfo();
            fakeAAInfo.PassportPuid = PassportPuid;

            STSUtil.GetSecurityTicketParameters gstParam = new STSUtil.GetSecurityTicketParameters();
            gstParam.Puid0 = PassportPuid.ToString();
            gstParam.Xuid0 = Xuid.ToString();
            gstParam.MachineID = MachinePuid.ToString();
            gstParam.TitleID = TitleId.ToString();
            gstParam.Certificate = new X509Certificate2("sts.test.xboxlive.com.pfx","XblRocks!");
            fakeAAInfo.SamlToken = STSUtil.GetSecurityTicket(gstParam);
            
            xonline.common.service.AAInfo.MarshallToHeaders(wr.Headers, fakeAAInfo);

            return wr;
        }

    }

   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\CUST\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.CUST
{
    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class AccountInfo
    {
        public bool isOwner=false;
        public bool isActive=false;
        public bool isLockedOut=false;
        public bool isVoiceBanned=false;
        public bool isNicknameBanned=false;
        public bool mustChangeXName=false;
        public bool isGeofenceExempt = false;

        public virtual void BanAll()
        {
            isOwner = isActive = isLockedOut = isVoiceBanned = isNicknameBanned = mustChangeXName = isGeofenceExempt=true;
        }

        public bool IsEqualTo(AccountInfo AI)
        {
            if (isLockedOut!=AI.isLockedOut)
                return false;
            if (isVoiceBanned!=AI.isVoiceBanned)
                return false;
            if (isNicknameBanned!=AI.isNicknameBanned)
                return false;
            if (mustChangeXName!=AI.mustChangeXName)
                return false;
            if (isGeofenceExempt != AI.isGeofenceExempt)
                return false;
            return true;
        }

        public virtual bool IsEqualTo(UserInfo uInfo)
        {
            DateTime    UTCTime=DateTime.Now.ToUniversalTime();
            if ((uInfo.nameChangeRequired!=0)!=mustChangeXName)
                return false;
            if ((uInfo.suspendedUntil>UTCTime) != isLockedOut)
                return false;
            if ((uInfo.voiceBannedUntil>UTCTime) != isVoiceBanned)
                return false;
            if ((uInfo.isGeofenceExempt != 0) != isGeofenceExempt)
                return false;
            return true;
        }

        public virtual void Dump()
        {
            string s = string.Format("AI: Locked:{0} NickBanned:{1} VoiceBanned:{2} MustChange:{3} GeofenceExempt:{4}", isLockedOut, isNicknameBanned, isVoiceBanned, mustChangeXName, isGeofenceExempt);
            Global.RO.Info(s);
        }
    }

#if false
    /// <summary>
    /// A new AccountInfo class contains isGeofenceExempt field. Should use this class for all new tests.
    /// </summary>
    public class AccountInfo2 : AccountInfo
    {
        public bool isGeofenceExempt = false;

        public override void BanAll()
        {
            base.BanAll();
            isGeofenceExempt = true;
        }

        public bool IsEqualTo(AccountInfo2 AI)
        {
            if (!base.IsEqualTo(AI))
                return false;
            if (isGeofenceExempt != AI.isGeofenceExempt)
                return false;
            return true;
        }

        public override bool IsEqualTo(UserInfo uInfo)
        {
            if (!base.IsEqualTo(uInfo))
                return false;
            if ((uInfo.isGeofenceExempt != 0) != isGeofenceExempt)
                return false;
            return true;
        }

        public override void Dump()
        {
            string s = string.Format("AI: Locked:{0} NickBanned:{1} VoiceBanned:{2} MustChange:{3} GeofenceExempt:{4}", isLockedOut, isNicknameBanned, isVoiceBanned, mustChangeXName, isGeofenceExempt);
            Global.RO.Info(s);
        }
    }
#endif

    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class AccountInfoEx
    {
        public ulong        Puid;
        public ulong        OwnerPuid;
        public DateTime     ResumeDate;
        public int          SuspensionLength;
        public DateTime     VoiceResumeDate;
        public int          VoiceBanLength;
        public bool         MustChangeXName;
        public DateTime     AcceptedTOS;
        public byte         CountryId;
        public string       ErrorString;
        public bool isGeofenceExempt = false;

        public bool IsEqualTo(AccountInfoEx aix)
        {
            if (Puid != aix.Puid)
                return false;
            if (OwnerPuid != aix.OwnerPuid)
                return false;
            if (ResumeDate != aix.ResumeDate)
                return false;
            if (SuspensionLength != aix.SuspensionLength)
                return false;
            if (VoiceResumeDate != aix.VoiceResumeDate)
                return false;
            if (VoiceBanLength != aix.VoiceBanLength)
                return false;
            if (MustChangeXName != aix.MustChangeXName)
                return false;
            if (AcceptedTOS != aix.AcceptedTOS)
                return false;
            if (CountryId != aix.CountryId)
                return false;
            if (ErrorString != aix.ErrorString)
                return false;
            if (isGeofenceExempt != aix.isGeofenceExempt)
                return false;

            return true;
        }

        public bool IsEqualTo(UserInfo uInfo)
        {
            DateTime    UTCTime=DateTime.Now.ToUniversalTime();
            if ((uInfo.nameChangeRequired!=0)!=MustChangeXName)
                return false;
            if ((uInfo.isGeofenceExempt != 0) != isGeofenceExempt)
                return false;

            // TODO: probably need some better tests here

            return true;
        }

        public void Dump()
        {
            StringBuilder str = new StringBuilder();

            str.Append("Puid: "); str.Append(Puid);
            str.Append(", OnrPuid: "); str.Append(OwnerPuid);
            str.Append(", ResumeDt: "); str.Append(ResumeDate);
            str.Append(", SuspLen: "); str.Append(SuspensionLength);
            str.Append(", VoResumeDt: "); str.Append(VoiceResumeDate);
            str.Append(", VoBanLen: "); str.Append(VoiceBanLength);
            str.Append(", MustCngXN: "); str.Append(MustChangeXName);
            str.Append(", AptTOS: "); str.Append(AcceptedTOS);
            str.Append(", Country: "); str.Append(CountryId);
            str.Append(", IsGeofenceExempt: "); str.Append(isGeofenceExempt);
            str.Append(", ErrorStr: "); str.Append(ErrorString);

            Global.RO.Info(str.ToString());
        }
    }

    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class MachineAccountInfo
    {
        public bool     isLockedOut=false;
        public string   ErrorString;

        public bool IsEqualTo(MachineAccountInfo MAI)
        {
            if (isLockedOut!=MAI.isLockedOut)
                return false;
            return true;
        }

        public virtual void Dump()
        {
            string s = string.Format("MAI: Locked:{0}", isLockedOut);
            Global.RO.Info(s);
        }
    }

    public class SvcProviderWrapper
    {
/*
        class MyCertPolicy : ICertificatePolicy
        {
            public bool CheckValidationResult(ServicePoint sp, X509Certificate cert, WebRequest request, int problem)
            {
                if (problem != 0)
                {
                    Console.WriteLine("The problem is = "+problem.ToString("X"));
                }
                return true;
            }
        }
*/
        CXSuppApi Prov=new CXSuppApi();

        public static int   TimeOut=60000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        public string CustomHeader
        {
            get
            {
                return Prov.CustomHeader;
            }
            set
            {
                Prov.CustomHeader = value;
            }
        }

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }

        public ulong    GetPuidFromXName(string Name, out string error)
        {
            ulong puid;
            ReturnCode=Prov.getPuidFromXName(Name,out puid, out error);
            ErrorString = error;
            return puid;
        }

        public ulong    GetAccount(ulong puid, out AccountInfo info)
        {
            info=new AccountInfo();
            ReturnCode=Prov.getAccount(puid,out info.isOwner, out info.isActive, out info.isLockedOut, out info.isVoiceBanned, out info.isNicknameBanned, out info.mustChangeXName, out info.isGeofenceExempt, out ErrorString);
            return ReturnCode;
        }

        public ulong    GetAccountEx(ulong puid, out AccountInfoEx info)
        {
            info=new AccountInfoEx();
            info.Puid = puid;
            ReturnCode=Prov.getAccountEx(puid,out info.OwnerPuid, out info.ResumeDate, out info.SuspensionLength, out info.VoiceResumeDate, out info.VoiceBanLength, out info.MustChangeXName, out info.AcceptedTOS, out info.CountryId, out info.isGeofenceExempt, out ErrorString);
            info.ErrorString = ErrorString;
            return ReturnCode;
        }

        public ConsoleApplications[] ConsoleApplicationsGetByGamerTag(string gamertag, string consoleId)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.ConsoleApplicationsGetByGamerTag(gamertag, consoleId);
        }

        public ConsoleApplications[] ConsoleApplicationsGetByUserPuid(Puid userPuid, string consoleId)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.ConsoleApplicationsGetByUserPuid(userPuid, consoleId);
        }

        public ConsoleApplications[] ConsoleApplicationsGetByConsoleId(string consoleId)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.ConsoleApplicationsGetByConsoleId(consoleId);
        }

        public ConsoleApplications ConsoleApplicationsGetByMachinePuid(Puid machinePuid)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.ConsoleApplicationsGetByMachinePuid(machinePuid);
        }

        public ulong    GetMachineAccountByConsoleId(ulong puid, string consoleId, out MachineAccountInfo info)
        {
            info = new MachineAccountInfo();
            ReturnCode=Prov.getMachineAccountByConsoleId(puid, consoleId, out info.isLockedOut, out ErrorString);
            info.ErrorString = ErrorString;
            return ReturnCode;
        }

        public ulong GetPassportMemberName(ulong puid, out string userPmn, out string parentPmn)
        {
            ReturnCode = Prov.getPassportMemberName(puid, out userPmn, out parentPmn, out ErrorString);
            return ReturnCode;
        }

        public ulong    ModifyAccount(ulong puid, AccountInfo info)
        {
            ReturnCode = Prov.modifyAccount(puid, info.isLockedOut, info.isVoiceBanned, info.isNicknameBanned, info.mustChangeXName, info.isGeofenceExempt, out ErrorString);
            return ReturnCode;
        }

        public ulong    BanAccount(ulong puid, AccountInfo info)
        {
            ReturnCode = Prov.banAccount(puid, info.isLockedOut, out ErrorString);
            return ReturnCode;
        }

        public ulong    SetUserMotto(ulong puid, string newMotto)
        {
            ReturnCode = Prov.SetUserMotto(puid, newMotto, out ErrorString);
            return ReturnCode;
        }

        public ulong    SetUserProfileItems(ulong puid, ProfileItem [] items)
        {
            ReturnCode = Prov.SetUserProfileItems(puid, items, out ErrorString);
            return ReturnCode;
        }

        public ulong    RemoveGamerPicture(ulong puid)
        {
            ReturnCode = Prov.RemoveGamerPicture(puid, out ErrorString);
            return ReturnCode;
        }

        public ulong    GetRelatedAccounts(ulong puid, out ulong []Accounts, out string []Names)
        {
            ReturnCode=Prov.getRelatedAccounts(puid, out Accounts, out Names, out ErrorString);
            return ReturnCode;
        }

        public uint     GetSubscriptionCodeStatus(
            string      Code,
            out bool    IsValid,
            out bool    IsUsed,
            out bool    UsedMaxTimes,
            out ulong   LastUser,
            out string  LastUserName,
            out DateTime LastUsage,
            out ulong   OfferID,
            out string  InstanceID)
        {
            ReturnCode=Prov.getSubscriptionCodeStatus(
                            Code,
                            out IsValid,
                            out IsUsed,
                            out UsedMaxTimes,
                            out LastUser,
                            out LastUserName,
                            out LastUsage,
                            out OfferID,
                            out InstanceID,
                            out ErrorString);
            return (uint)ReturnCode;
        }

        public uint GetXMLFromXName(string Name, out string userXML, out string error)
        {
            ReturnCode = Prov.GetXMLFromXName(Name, out userXML, out error);
            ErrorString = error;
            return (uint)ReturnCode;
        }

        public uint SwapUserWLID(   Puid xuid,
                                    string oldUserPassportName,
                                    string newUserPassportName,
                                    out string error)
        {
            ReturnCode = Prov.SwapUserWLID( xuid,
                                            oldUserPassportName,
                                            newUserPassportName,
                                            out error);
            ErrorString = error;
            return (uint)ReturnCode;
        }

        public uint SwapOwnerWLID(  Puid xuid,
                                    string oldOwnerPassportName,
                                    string newOwnerPassportName,
                                    out string error)
        {
            ReturnCode = Prov.SwapOwnerWLID(xuid,
                                            oldOwnerPassportName,
                                            newOwnerPassportName,
                                            out error);
            ErrorString = error;
            return (uint)ReturnCode;
        }

        public uint SwapUserDateOfBirth(Puid xuid,
                                        DateTime userDateOfBirth,
                                        out string error)
        {
            ReturnCode = Prov.SwapUserDateOfBirth(  xuid,
                                                    userDateOfBirth,
                                                    out error);
            ErrorString = error;
            return (uint)ReturnCode;
        }

        public uint GetFamilyMembersByGamertag(string gamertag, out FamilyMember[] familyMembers, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.GetFamilyMembersByGamertag(gamertag, out familyMembers, out errorString);
        }

        public uint GetFamilyMembersByPuid(ulong userPuid, out FamilyMember[] familyMembers, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.GetFamilyMembersByPuid(userPuid, out familyMembers, out errorString);
        }

        public uint FamilyHistoryGetByGamertag(string gamertag, out FamilyHistoryDetail[] details, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.FamilyHistoryGetByGamertag(gamertag, out details, out errorString);
        }

        public uint FamilyHistoryGetByPuid(ulong userPuid, out FamilyHistoryDetail[] details, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.FamilyHistoryGetByPuid(userPuid, out details, out errorString);
        }

        public uint SetFamilyGoldSeatExemptionByGamertag(string ownerGamertag, string dependentGamertag, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.SetFamilyGoldSeatExemptionByGamertag(ownerGamertag, dependentGamertag, out errorString);
        }

        public uint SetFamilyGoldSeatExemptionByPuid(ulong ownerPassportPuid, ulong dependentPuid, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.SetFamilyGoldSeatExemptionByPuid(ownerPassportPuid, dependentPuid, out errorString);
        }

        public uint SetFreeGamertagEligible(ulong userPuid, bool isEligible, out string errorString)
        {
            ReturnCode = xonline.common.service.HResult.S_OK;
            return Prov.SetFreeGamertagEligible(userPuid, isEligible, out errorString);
        }

        public SvcProviderWrapper() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xsuppapi))
        {
        }

        public SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            Prov.Timeout=TimeOut;

            string ServerAddr = ServerEP.Address.ToString();
            if (ServerEP.Port != 80)
            {
                ServerAddr += ":" + ServerEP.Port;
            }

            Prov.Url="http://"+ServerAddr+"/xsuppapi/cxsuppapi.asmx";
        }

        public SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            Prov.Timeout=TimeOut;
            Prov.Url="http://"+Server.IPToString()+"/xsuppapi/cxsuppapi.asmx";
//          Prov.Credentials=new NetworkCredential("xontest\\spsp_xbox_sp","4RtmmKw5sHcBgrFxrvA8Gc3vz4c");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\UACS\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
//using ServerTestFramework.LiveService.ZuneSignIn;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;

namespace ServerTestFramework.LiveService.UserAccount.WebService
{
    public class SvcProviderWrapper : SvcProvider
    {
        //UserAccount Prov=new UserAccount();

        public static int   TimeOut=25000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;
        public string AlternateppsaProfileUrl = null;
        public string AlternateppsaCredentialUrl = null;
        public string ClientType = null;


        public string ServerAddr;
        public ulong PassportPuid;

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }

        new public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) 
        {
            AddCreditCardResults results;
            results=base.AddCreditCard(
                     userPuid, 
                     machinePuid, 
                     addressStreet1, 
                     addressStreet2, 
                     addressCity, 
                     addressDistrict, 
                     addressState, 
                     addressPostalCode, 
                     phonePrefix, 
                     phoneNumber, 
                     phoneExtension, 
                     cardType, 
                     accountHolderName, 
                     accountNumber, 
                     cardVerificationNumber, 
                     expirationDate);

            return (results);
        }
        
        
        new public GetPointsBalanceResults GetPointsBalance(ulong userPuid) 
        {
            GetPointsBalanceResults results;
            results = base.GetPointsBalance(userPuid);

            return (results);
        }
        
        
        new public SignInResults SignIn() 
        {
            SignInResults results;
            results = base.SignIn();
            
            return (results);
        }
        
        
        new public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) 
        {
            GetPaymentInstrumentResults results;
            results = base.GetPaymentInstruments(userPuid, machinePuid);

            return (results);
        }
        
        
        new public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) 
        {
            GetUserAuthorizationInfo results;
            results = base.GetUserAuthorization(serviceType, titleId);

            return (results);
        }

        new public string TestConnection(string inputMessage) 
        {
            string results;
            results = base.TestConnection(inputMessage);

            return (results);
        }


        public SvcProviderWrapper(ulong _passportPuid) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs))
        {
            PassportPuid = _passportPuid;
        }

        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/xuacs/useraccount.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/xuacs/useraccount.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            HttpWebRequest wr = (HttpWebRequest) base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);
            if (AlternateppsaProfileUrl != null)
                wr.Headers.Add("AlternatePpProfileServiceApiUrl", AlternateppsaProfileUrl);
            if (AlternateppsaCredentialUrl != null)
                wr.Headers.Add("AlternatePpCredentialServiceApiUrl", AlternateppsaCredentialUrl);
            if (ClientType != null)
                wr.Headers.Add("X-ClientType", ClientType);

            if (wr.Headers[XHttpHdr.AUTHZ] == null)
            {
                FakeAAInfo aainfo = new FakeAAInfo(PassportPuid);
                wr.Headers.Add(XHttpHdr.AUTHZ, aainfo.ConvertToHttpHeaderValue());
            }

            wr.KeepAlive = false;
            
            return wr;
        }



        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\CUST\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.5444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//...and slightly altered by hand...

namespace ServerTestFramework.CUST {

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="XSuppApiSoap", Namespace="http://xbox.com/xsuppapi/")]
public partial class CXSuppApi : ServerTestFramework.Web.STFSoapHttpClientProtocol
{
    public string CustomHeader = String.Empty;

    override protected System.Net.WebRequest GetWebRequest(Uri url)
    {
        System.Net.WebRequest wr = base.GetWebRequest(new Uri(Url));

        if (!String.IsNullOrEmpty(CustomHeader))
            wr.Headers.Add(CustomHeader);

        return wr;
    }

    private System.Threading.SendOrPostCallback ConsoleApplicationsGetByGamerTagOperationCompleted;
    
    private System.Threading.SendOrPostCallback ConsoleApplicationsGetByUserPuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback ConsoleApplicationsGetByConsoleIdOperationCompleted;
    
    private System.Threading.SendOrPostCallback ConsoleApplicationsGetByMachinePuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback getPuidFromXNameOperationCompleted;
    
    private System.Threading.SendOrPostCallback getAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback modifyAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback banAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback getRelatedAccountsOperationCompleted;
    
    private System.Threading.SendOrPostCallback getSubscriptionCodeStatusOperationCompleted;
    
    private System.Threading.SendOrPostCallback getAccountExOperationCompleted;
    
    private System.Threading.SendOrPostCallback getPassportMemberNameOperationCompleted;
    
    private System.Threading.SendOrPostCallback RemoveGamerPictureOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetUserMottoOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetUserProfileItemsOperationCompleted;
    
    private System.Threading.SendOrPostCallback IncrementMaximumLicenseCountOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetXMLFromXNameOperationCompleted;
    
    private System.Threading.SendOrPostCallback SwapUserWLIDOperationCompleted;
    
    private System.Threading.SendOrPostCallback SwapOwnerWLIDOperationCompleted;
    
    private System.Threading.SendOrPostCallback SwapUserDateOfBirthOperationCompleted;
    
    private System.Threading.SendOrPostCallback FamilyHistoryGetByPuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback FamilyHistoryGetByGamertagOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetFamilyMembersByPuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetFamilyMembersByGamertagOperationCompleted;
    
    private System.Threading.SendOrPostCallback getMachineAccountByConsoleIdOperationCompleted;
    
    private System.Threading.SendOrPostCallback IsMachinePuidBannedOperationCompleted;
    
    private System.Threading.SendOrPostCallback LookupMachineAccountByConsoleIdAndSCodeOperationCompleted;
    
    private System.Threading.SendOrPostCallback LookupMachineAccountByConsoleIdAndXuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback MachineHistoryGetByConsoleIdOperationCompleted;
    
    private System.Threading.SendOrPostCallback MachineHistoryGetByPuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetFamilyGoldSeatExemptionByPuidOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetFamilyGoldSeatExemptionByGamertagOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetFreeGamertagEligibleOperationCompleted;
    
    private System.Threading.SendOrPostCallback GamertagHistoryGetOperationCompleted;
    
    private System.Threading.SendOrPostCallback UserHistoryGetByGamertagOperationCompleted;
    
    private System.Threading.SendOrPostCallback UserHistoryGetByPuidOperationCompleted;
    
    /// <remarks/>
    public CXSuppApi()
    {
        this.ComputeUrl("xsuppapi", "/xsuppapi/cxsuppapi.asmx");
    }
    
    /// <remarks/>
    public event ConsoleApplicationsGetByGamerTagCompletedEventHandler ConsoleApplicationsGetByGamerTagCompleted;
    
    /// <remarks/>
    public event ConsoleApplicationsGetByUserPuidCompletedEventHandler ConsoleApplicationsGetByUserPuidCompleted;
    
    /// <remarks/>
    public event ConsoleApplicationsGetByConsoleIdCompletedEventHandler ConsoleApplicationsGetByConsoleIdCompleted;
    
    /// <remarks/>
    public event ConsoleApplicationsGetByMachinePuidCompletedEventHandler ConsoleApplicationsGetByMachinePuidCompleted;
    
    /// <remarks/>
    public event getPuidFromXNameCompletedEventHandler getPuidFromXNameCompleted;
    
    /// <remarks/>
    public event getAccountCompletedEventHandler getAccountCompleted;
    
    /// <remarks/>
    public event modifyAccountCompletedEventHandler modifyAccountCompleted;
    
    /// <remarks/>
    public event banAccountCompletedEventHandler banAccountCompleted;
    
    /// <remarks/>
    public event getRelatedAccountsCompletedEventHandler getRelatedAccountsCompleted;
    
    /// <remarks/>
    public event getSubscriptionCodeStatusCompletedEventHandler getSubscriptionCodeStatusCompleted;
    
    /// <remarks/>
    public event getAccountExCompletedEventHandler getAccountExCompleted;
    
    /// <remarks/>
    public event getPassportMemberNameCompletedEventHandler getPassportMemberNameCompleted;
    
    /// <remarks/>
    public event RemoveGamerPictureCompletedEventHandler RemoveGamerPictureCompleted;
    
    /// <remarks/>
    public event SetUserMottoCompletedEventHandler SetUserMottoCompleted;
    
    /// <remarks/>
    public event SetUserProfileItemsCompletedEventHandler SetUserProfileItemsCompleted;
    
    /// <remarks/>
    public event IncrementMaximumLicenseCountCompletedEventHandler IncrementMaximumLicenseCountCompleted;
    
    /// <remarks/>
    public event GetXMLFromXNameCompletedEventHandler GetXMLFromXNameCompleted;
    
    /// <remarks/>
    public event SwapUserWLIDCompletedEventHandler SwapUserWLIDCompleted;
    
    /// <remarks/>
    public event SwapOwnerWLIDCompletedEventHandler SwapOwnerWLIDCompleted;
    
    /// <remarks/>
    public event SwapUserDateOfBirthCompletedEventHandler SwapUserDateOfBirthCompleted;
    
    /// <remarks/>
    public event FamilyHistoryGetByPuidCompletedEventHandler FamilyHistoryGetByPuidCompleted;
    
    /// <remarks/>
    public event FamilyHistoryGetByGamertagCompletedEventHandler FamilyHistoryGetByGamertagCompleted;
    
    /// <remarks/>
    public event GetFamilyMembersByPuidCompletedEventHandler GetFamilyMembersByPuidCompleted;
    
    /// <remarks/>
    public event GetFamilyMembersByGamertagCompletedEventHandler GetFamilyMembersByGamertagCompleted;
    
    /// <remarks/>
    public event getMachineAccountByConsoleIdCompletedEventHandler getMachineAccountByConsoleIdCompleted;
    
    /// <remarks/>
    public event IsMachinePuidBannedCompletedEventHandler IsMachinePuidBannedCompleted;
    
    /// <remarks/>
    public event LookupMachineAccountByConsoleIdAndSCodeCompletedEventHandler LookupMachineAccountByConsoleIdAndSCodeCompleted;
    
    /// <remarks/>
    public event LookupMachineAccountByConsoleIdAndXuidCompletedEventHandler LookupMachineAccountByConsoleIdAndXuidCompleted;
    
    /// <remarks/>
    public event MachineHistoryGetByConsoleIdCompletedEventHandler MachineHistoryGetByConsoleIdCompleted;
    
    /// <remarks/>
    public event MachineHistoryGetByPuidCompletedEventHandler MachineHistoryGetByPuidCompleted;
    
    /// <remarks/>
    public event SetFamilyGoldSeatExemptionByPuidCompletedEventHandler SetFamilyGoldSeatExemptionByPuidCompleted;
    
    /// <remarks/>
    public event SetFamilyGoldSeatExemptionByGamertagCompletedEventHandler SetFamilyGoldSeatExemptionByGamertagCompleted;
    
    /// <remarks/>
    public event SetFreeGamertagEligibleCompletedEventHandler SetFreeGamertagEligibleCompleted;
    
    /// <remarks/>
    public event GamertagHistoryGetCompletedEventHandler GamertagHistoryGetCompleted;
    
    /// <remarks/>
    public event UserHistoryGetByGamertagCompletedEventHandler UserHistoryGetByGamertagCompleted;
    
    /// <remarks/>
    public event UserHistoryGetByPuidCompletedEventHandler UserHistoryGetByPuidCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/ConsoleApplicationsGetByGamerTag", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ConsoleApplications[] ConsoleApplicationsGetByGamerTag(string gamertag, string consoleId) {
        object[] results = this.Invoke("ConsoleApplicationsGetByGamerTag", new object[] {
                    gamertag,
                    consoleId});
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsoleApplicationsGetByGamerTag(string gamertag, string consoleId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsoleApplicationsGetByGamerTag", new object[] {
                    gamertag,
                    consoleId}, callback, asyncState);
    }
    
    /// <remarks/>
    public ConsoleApplications[] EndConsoleApplicationsGetByGamerTag(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByGamerTagAsync(string gamertag, string consoleId) {
        this.ConsoleApplicationsGetByGamerTagAsync(gamertag, consoleId, null);
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByGamerTagAsync(string gamertag, string consoleId, object userState) {
        if ((this.ConsoleApplicationsGetByGamerTagOperationCompleted == null)) {
            this.ConsoleApplicationsGetByGamerTagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByGamerTagOperationCompleted);
        }
        this.InvokeAsync("ConsoleApplicationsGetByGamerTag", new object[] {
                    gamertag,
                    consoleId}, this.ConsoleApplicationsGetByGamerTagOperationCompleted, userState);
    }
    
    private void OnConsoleApplicationsGetByGamerTagOperationCompleted(object arg) {
        if ((this.ConsoleApplicationsGetByGamerTagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.ConsoleApplicationsGetByGamerTagCompleted(this, new ConsoleApplicationsGetByGamerTagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/ConsoleApplicationsGetByUserPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ConsoleApplications[] ConsoleApplicationsGetByUserPuid(ulong userPuid, string consoleId) {
        object[] results = this.Invoke("ConsoleApplicationsGetByUserPuid", new object[] {
                    userPuid,
                    consoleId});
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsoleApplicationsGetByUserPuid(ulong userPuid, string consoleId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsoleApplicationsGetByUserPuid", new object[] {
                    userPuid,
                    consoleId}, callback, asyncState);
    }
    
    /// <remarks/>
    public ConsoleApplications[] EndConsoleApplicationsGetByUserPuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByUserPuidAsync(ulong userPuid, string consoleId) {
        this.ConsoleApplicationsGetByUserPuidAsync(userPuid, consoleId, null);
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByUserPuidAsync(ulong userPuid, string consoleId, object userState) {
        if ((this.ConsoleApplicationsGetByUserPuidOperationCompleted == null)) {
            this.ConsoleApplicationsGetByUserPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByUserPuidOperationCompleted);
        }
        this.InvokeAsync("ConsoleApplicationsGetByUserPuid", new object[] {
                    userPuid,
                    consoleId}, this.ConsoleApplicationsGetByUserPuidOperationCompleted, userState);
    }
    
    private void OnConsoleApplicationsGetByUserPuidOperationCompleted(object arg) {
        if ((this.ConsoleApplicationsGetByUserPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.ConsoleApplicationsGetByUserPuidCompleted(this, new ConsoleApplicationsGetByUserPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/ConsoleApplicationsGetByConsoleId", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ConsoleApplications[] ConsoleApplicationsGetByConsoleId(string consoleId) {
        object[] results = this.Invoke("ConsoleApplicationsGetByConsoleId", new object[] {
                    consoleId});
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsoleApplicationsGetByConsoleId(string consoleId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsoleApplicationsGetByConsoleId", new object[] {
                    consoleId}, callback, asyncState);
    }
    
    /// <remarks/>
    public ConsoleApplications[] EndConsoleApplicationsGetByConsoleId(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ConsoleApplications[])(results[0]));
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByConsoleIdAsync(string consoleId) {
        this.ConsoleApplicationsGetByConsoleIdAsync(consoleId, null);
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByConsoleIdAsync(string consoleId, object userState) {
        if ((this.ConsoleApplicationsGetByConsoleIdOperationCompleted == null)) {
            this.ConsoleApplicationsGetByConsoleIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByConsoleIdOperationCompleted);
        }
        this.InvokeAsync("ConsoleApplicationsGetByConsoleId", new object[] {
                    consoleId}, this.ConsoleApplicationsGetByConsoleIdOperationCompleted, userState);
    }
    
    private void OnConsoleApplicationsGetByConsoleIdOperationCompleted(object arg) {
        if ((this.ConsoleApplicationsGetByConsoleIdCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.ConsoleApplicationsGetByConsoleIdCompleted(this, new ConsoleApplicationsGetByConsoleIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/ConsoleApplicationsGetByMachinePuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ConsoleApplications ConsoleApplicationsGetByMachinePuid(ulong machinePuid) {
        object[] results = this.Invoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                    machinePuid});
        return ((ConsoleApplications)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsoleApplicationsGetByMachinePuid(ulong machinePuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                    machinePuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public ConsoleApplications EndConsoleApplicationsGetByMachinePuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ConsoleApplications)(results[0]));
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid) {
        this.ConsoleApplicationsGetByMachinePuidAsync(machinePuid, null);
    }
    
    /// <remarks/>
    public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid, object userState) {
        if ((this.ConsoleApplicationsGetByMachinePuidOperationCompleted == null)) {
            this.ConsoleApplicationsGetByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByMachinePuidOperationCompleted);
        }
        this.InvokeAsync("ConsoleApplicationsGetByMachinePuid", new object[] {
                    machinePuid}, this.ConsoleApplicationsGetByMachinePuidOperationCompleted, userState);
    }
    
    private void OnConsoleApplicationsGetByMachinePuidOperationCompleted(object arg) {
        if ((this.ConsoleApplicationsGetByMachinePuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.ConsoleApplicationsGetByMachinePuidCompleted(this, new ConsoleApplicationsGetByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPuidFromXName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getPuidFromXName(string XName, out ulong puid, out string errorString) {
        object[] results = this.Invoke("getPuidFromXName", new object[] {
                    XName});
        puid = ((ulong)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetPuidFromXName(string XName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getPuidFromXName", new object[] {
                    XName}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetPuidFromXName(System.IAsyncResult asyncResult, out ulong puid, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        puid = ((ulong)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getPuidFromXNameAsync(string XName) {
        this.getPuidFromXNameAsync(XName, null);
    }
    
    /// <remarks/>
    public void getPuidFromXNameAsync(string XName, object userState) {
        if ((this.getPuidFromXNameOperationCompleted == null)) {
            this.getPuidFromXNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPuidFromXNameOperationCompleted);
        }
        this.InvokeAsync("getPuidFromXName", new object[] {
                    XName}, this.getPuidFromXNameOperationCompleted, userState);
    }
    
    private void OngetPuidFromXNameOperationCompleted(object arg) {
        if ((this.getPuidFromXNameCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getPuidFromXNameCompleted(this, new getPuidFromXNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getAccount(ulong puid, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out bool isGeofenceExempt, out string errorString) {
        object[] results = this.Invoke("getAccount", new object[] {
                    puid});
        isAccountOwner = ((bool)(results[1]));
        isActive = ((bool)(results[2]));
        isLockedOut = ((bool)(results[3]));
        isVoiceBanned = ((bool)(results[4]));
        isNicknameBanned = ((bool)(results[5]));
        mustChangeXName = ((bool)(results[6]));
        isGeofenceExempt = ((bool)(results[7]));
        errorString = ((string)(results[8]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetAccount(ulong puid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getAccount", new object[] {
                    puid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetAccount(System.IAsyncResult asyncResult, out bool isAccountOwner, out bool isActive, out bool isLockedOut, out bool isVoiceBanned, out bool isNicknameBanned, out bool mustChangeXName, out bool isGeofenceExempt, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        isAccountOwner = ((bool)(results[1]));
        isActive = ((bool)(results[2]));
        isLockedOut = ((bool)(results[3]));
        isVoiceBanned = ((bool)(results[4]));
        isNicknameBanned = ((bool)(results[5]));
        mustChangeXName = ((bool)(results[6]));
        isGeofenceExempt = ((bool)(results[7]));
        errorString = ((string)(results[8]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getAccountAsync(ulong puid) {
        this.getAccountAsync(puid, null);
    }
    
    /// <remarks/>
    public void getAccountAsync(ulong puid, object userState) {
        if ((this.getAccountOperationCompleted == null)) {
            this.getAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountOperationCompleted);
        }
        this.InvokeAsync("getAccount", new object[] {
                    puid}, this.getAccountOperationCompleted, userState);
    }
    
    private void OngetAccountOperationCompleted(object arg) {
        if ((this.getAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getAccountCompleted(this, new getAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/modifyAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint modifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, out string errorString) {
        object[] results = this.Invoke("modifyAccount", new object[] {
                    puid,
                    isLockedOut,
                    isVoiceBanned,
                    isNicknameBanned,
                    mustChangeXName,
                    isGeoFenceExempt});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginmodifyAccount(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("modifyAccount", new object[] {
                    puid,
                    isLockedOut,
                    isVoiceBanned,
                    isNicknameBanned,
                    mustChangeXName,
                    isGeoFenceExempt}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndmodifyAccount(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt) {
        this.modifyAccountAsync(puid, isLockedOut, isVoiceBanned, isNicknameBanned, mustChangeXName, isGeoFenceExempt, null);
    }
    
    /// <remarks/>
    public void modifyAccountAsync(ulong puid, bool isLockedOut, bool isVoiceBanned, bool isNicknameBanned, bool mustChangeXName, bool isGeoFenceExempt, object userState) {
        if ((this.modifyAccountOperationCompleted == null)) {
            this.modifyAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnmodifyAccountOperationCompleted);
        }
        this.InvokeAsync("modifyAccount", new object[] {
                    puid,
                    isLockedOut,
                    isVoiceBanned,
                    isNicknameBanned,
                    mustChangeXName,
                    isGeoFenceExempt}, this.modifyAccountOperationCompleted, userState);
    }
    
    private void OnmodifyAccountOperationCompleted(object arg) {
        if ((this.modifyAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.modifyAccountCompleted(this, new modifyAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/banAccount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint banAccount(ulong puid, bool isLockedOut, out string errorString) {
        object[] results = this.Invoke("banAccount", new object[] {
                    puid,
                    isLockedOut});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginbanAccount(ulong puid, bool isLockedOut, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("banAccount", new object[] {
                    puid,
                    isLockedOut}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndbanAccount(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void banAccountAsync(ulong puid, bool isLockedOut) {
        this.banAccountAsync(puid, isLockedOut, null);
    }
    
    /// <remarks/>
    public void banAccountAsync(ulong puid, bool isLockedOut, object userState) {
        if ((this.banAccountOperationCompleted == null)) {
            this.banAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnbanAccountOperationCompleted);
        }
        this.InvokeAsync("banAccount", new object[] {
                    puid,
                    isLockedOut}, this.banAccountOperationCompleted, userState);
    }
    
    private void OnbanAccountOperationCompleted(object arg) {
        if ((this.banAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.banAccountCompleted(this, new banAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getRelatedAccounts", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getRelatedAccounts(ulong puid, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
        object[] results = this.Invoke("getRelatedAccounts", new object[] {
                    puid});
        relatedAccounts = ((ulong[])(results[1]));
        relatedAccountNames = ((string[])(results[2]));
        errorString = ((string)(results[3]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetRelatedAccounts(ulong puid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getRelatedAccounts", new object[] {
                    puid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetRelatedAccounts(System.IAsyncResult asyncResult, out ulong[] relatedAccounts, out string[] relatedAccountNames, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        relatedAccounts = ((ulong[])(results[1]));
        relatedAccountNames = ((string[])(results[2]));
        errorString = ((string)(results[3]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getRelatedAccountsAsync(ulong puid) {
        this.getRelatedAccountsAsync(puid, null);
    }
    
    /// <remarks/>
    public void getRelatedAccountsAsync(ulong puid, object userState) {
        if ((this.getRelatedAccountsOperationCompleted == null)) {
            this.getRelatedAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetRelatedAccountsOperationCompleted);
        }
        this.InvokeAsync("getRelatedAccounts", new object[] {
                    puid}, this.getRelatedAccountsOperationCompleted, userState);
    }
    
    private void OngetRelatedAccountsOperationCompleted(object arg) {
        if ((this.getRelatedAccountsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getRelatedAccountsCompleted(this, new getRelatedAccountsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getSubscriptionCodeStatus", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getSubscriptionCodeStatus(string SubscriptionCode, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
        object[] results = this.Invoke("getSubscriptionCodeStatus", new object[] {
                    SubscriptionCode});
        bValidSubscriptionCode = ((bool)(results[1]));
        bUsed = ((bool)(results[2]));
        bUsedMaxTimes = ((bool)(results[3]));
        ulLastUser = ((ulong)(results[4]));
        szLastUser = ((string)(results[5]));
        ftLastUsage = ((System.DateTime)(results[6]));
        ulOfferID = ((ulong)(results[7]));
        szOffer = ((string)(results[8]));
        errorString = ((string)(results[9]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetSubscriptionCodeStatus(string SubscriptionCode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getSubscriptionCodeStatus", new object[] {
                    SubscriptionCode}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetSubscriptionCodeStatus(System.IAsyncResult asyncResult, out bool bValidSubscriptionCode, out bool bUsed, out bool bUsedMaxTimes, out ulong ulLastUser, out string szLastUser, out System.DateTime ftLastUsage, out ulong ulOfferID, out string szOffer, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        bValidSubscriptionCode = ((bool)(results[1]));
        bUsed = ((bool)(results[2]));
        bUsedMaxTimes = ((bool)(results[3]));
        ulLastUser = ((ulong)(results[4]));
        szLastUser = ((string)(results[5]));
        ftLastUsage = ((System.DateTime)(results[6]));
        ulOfferID = ((ulong)(results[7]));
        szOffer = ((string)(results[8]));
        errorString = ((string)(results[9]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getSubscriptionCodeStatusAsync(string SubscriptionCode) {
        this.getSubscriptionCodeStatusAsync(SubscriptionCode, null);
    }
    
    /// <remarks/>
    public void getSubscriptionCodeStatusAsync(string SubscriptionCode, object userState) {
        if ((this.getSubscriptionCodeStatusOperationCompleted == null)) {
            this.getSubscriptionCodeStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetSubscriptionCodeStatusOperationCompleted);
        }
        this.InvokeAsync("getSubscriptionCodeStatus", new object[] {
                    SubscriptionCode}, this.getSubscriptionCodeStatusOperationCompleted, userState);
    }
    
    private void OngetSubscriptionCodeStatusOperationCompleted(object arg) {
        if ((this.getSubscriptionCodeStatusCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getSubscriptionCodeStatusCompleted(this, new getSubscriptionCodeStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getAccountEx", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getAccountEx(ulong puid, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out bool isGeoFenceExempt, out string errorString) {
        object[] results = this.Invoke("getAccountEx", new object[] {
                    puid});
        biOwnerPuid = ((ulong)(results[1]));
        dtAccountResumeDate = ((System.DateTime)(results[2]));
        iSuspensionLength = ((int)(results[3]));
        dtVoiceResumeDate = ((System.DateTime)(results[4]));
        iVoiceBanLength = ((int)(results[5]));
        bMustChangeXName = ((bool)(results[6]));
        dtAcceptedTOS = ((System.DateTime)(results[7]));
        tiCountryID = ((byte)(results[8]));
        isGeoFenceExempt = ((bool)(results[9]));
        errorString = ((string)(results[10]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetAccountEx(ulong puid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getAccountEx", new object[] {
                    puid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetAccountEx(System.IAsyncResult asyncResult, out ulong biOwnerPuid, out System.DateTime dtAccountResumeDate, out int iSuspensionLength, out System.DateTime dtVoiceResumeDate, out int iVoiceBanLength, out bool bMustChangeXName, out System.DateTime dtAcceptedTOS, out byte tiCountryID, out bool isGeoFenceExempt, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        biOwnerPuid = ((ulong)(results[1]));
        dtAccountResumeDate = ((System.DateTime)(results[2]));
        iSuspensionLength = ((int)(results[3]));
        dtVoiceResumeDate = ((System.DateTime)(results[4]));
        iVoiceBanLength = ((int)(results[5]));
        bMustChangeXName = ((bool)(results[6]));
        dtAcceptedTOS = ((System.DateTime)(results[7]));
        tiCountryID = ((byte)(results[8]));
        isGeoFenceExempt = ((bool)(results[9]));
        errorString = ((string)(results[10]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getAccountExAsync(ulong puid) {
        this.getAccountExAsync(puid, null);
    }
    
    /// <remarks/>
    public void getAccountExAsync(ulong puid, object userState) {
        if ((this.getAccountExOperationCompleted == null)) {
            this.getAccountExOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetAccountExOperationCompleted);
        }
        this.InvokeAsync("getAccountEx", new object[] {
                    puid}, this.getAccountExOperationCompleted, userState);
    }
    
    private void OngetAccountExOperationCompleted(object arg) {
        if ((this.getAccountExCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getAccountExCompleted(this, new getAccountExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getPassportMemberName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getPassportMemberName(ulong puid, out string userPmn, out string parentPmn, out string errorString) {
        object[] results = this.Invoke("getPassportMemberName", new object[] {
                    puid});
        userPmn = ((string)(results[1]));
        parentPmn = ((string)(results[2]));
        errorString = ((string)(results[3]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetPassportMemberName(ulong puid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getPassportMemberName", new object[] {
                    puid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetPassportMemberName(System.IAsyncResult asyncResult, out string userPmn, out string parentPmn, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        userPmn = ((string)(results[1]));
        parentPmn = ((string)(results[2]));
        errorString = ((string)(results[3]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getPassportMemberNameAsync(ulong puid) {
        this.getPassportMemberNameAsync(puid, null);
    }
    
    /// <remarks/>
    public void getPassportMemberNameAsync(ulong puid, object userState) {
        if ((this.getPassportMemberNameOperationCompleted == null)) {
            this.getPassportMemberNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetPassportMemberNameOperationCompleted);
        }
        this.InvokeAsync("getPassportMemberName", new object[] {
                    puid}, this.getPassportMemberNameOperationCompleted, userState);
    }
    
    private void OngetPassportMemberNameOperationCompleted(object arg) {
        if ((this.getPassportMemberNameCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getPassportMemberNameCompleted(this, new getPassportMemberNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/RemoveGamerPicture", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint RemoveGamerPicture(ulong puid, out string errorString) {
        object[] results = this.Invoke("RemoveGamerPicture", new object[] {
                    puid});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveGamerPicture(ulong puid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveGamerPicture", new object[] {
                    puid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndRemoveGamerPicture(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void RemoveGamerPictureAsync(ulong puid) {
        this.RemoveGamerPictureAsync(puid, null);
    }
    
    /// <remarks/>
    public void RemoveGamerPictureAsync(ulong puid, object userState) {
        if ((this.RemoveGamerPictureOperationCompleted == null)) {
            this.RemoveGamerPictureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveGamerPictureOperationCompleted);
        }
        this.InvokeAsync("RemoveGamerPicture", new object[] {
                    puid}, this.RemoveGamerPictureOperationCompleted, userState);
    }
    
    private void OnRemoveGamerPictureOperationCompleted(object arg) {
        if ((this.RemoveGamerPictureCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.RemoveGamerPictureCompleted(this, new RemoveGamerPictureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetUserMotto", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SetUserMotto(ulong puid, string newMotto, out string errorString) {
        object[] results = this.Invoke("SetUserMotto", new object[] {
                    puid,
                    newMotto});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetUserMotto(ulong puid, string newMotto, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetUserMotto", new object[] {
                    puid,
                    newMotto}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSetUserMotto(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SetUserMottoAsync(ulong puid, string newMotto) {
        this.SetUserMottoAsync(puid, newMotto, null);
    }
    
    /// <remarks/>
    public void SetUserMottoAsync(ulong puid, string newMotto, object userState) {
        if ((this.SetUserMottoOperationCompleted == null)) {
            this.SetUserMottoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserMottoOperationCompleted);
        }
        this.InvokeAsync("SetUserMotto", new object[] {
                    puid,
                    newMotto}, this.SetUserMottoOperationCompleted, userState);
    }
    
    private void OnSetUserMottoOperationCompleted(object arg) {
        if ((this.SetUserMottoCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetUserMottoCompleted(this, new SetUserMottoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetUserProfileItems", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SetUserProfileItems(ulong puid, ProfileItem[] profileItems, out string errorString) {
        object[] results = this.Invoke("SetUserProfileItems", new object[] {
                    puid,
                    profileItems});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetUserProfileItems(ulong puid, ProfileItem[] profileItems, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetUserProfileItems", new object[] {
                    puid,
                    profileItems}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSetUserProfileItems(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SetUserProfileItemsAsync(ulong puid, ProfileItem[] profileItems) {
        this.SetUserProfileItemsAsync(puid, profileItems, null);
    }
    
    /// <remarks/>
    public void SetUserProfileItemsAsync(ulong puid, ProfileItem[] profileItems, object userState) {
        if ((this.SetUserProfileItemsOperationCompleted == null)) {
            this.SetUserProfileItemsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserProfileItemsOperationCompleted);
        }
        this.InvokeAsync("SetUserProfileItems", new object[] {
                    puid,
                    profileItems}, this.SetUserProfileItemsOperationCompleted, userState);
    }
    
    private void OnSetUserProfileItemsOperationCompleted(object arg) {
        if ((this.SetUserProfileItemsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetUserProfileItemsCompleted(this, new SetUserProfileItemsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/IncrementMaximumLicenseCount", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint IncrementMaximumLicenseCount(ulong xuid, System.Guid offerInstanceId) {
        object[] results = this.Invoke("IncrementMaximumLicenseCount", new object[] {
                    xuid,
                    offerInstanceId});
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIncrementMaximumLicenseCount(ulong xuid, System.Guid offerInstanceId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IncrementMaximumLicenseCount", new object[] {
                    xuid,
                    offerInstanceId}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndIncrementMaximumLicenseCount(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void IncrementMaximumLicenseCountAsync(ulong xuid, System.Guid offerInstanceId) {
        this.IncrementMaximumLicenseCountAsync(xuid, offerInstanceId, null);
    }
    
    /// <remarks/>
    public void IncrementMaximumLicenseCountAsync(ulong xuid, System.Guid offerInstanceId, object userState) {
        if ((this.IncrementMaximumLicenseCountOperationCompleted == null)) {
            this.IncrementMaximumLicenseCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIncrementMaximumLicenseCountOperationCompleted);
        }
        this.InvokeAsync("IncrementMaximumLicenseCount", new object[] {
                    xuid,
                    offerInstanceId}, this.IncrementMaximumLicenseCountOperationCompleted, userState);
    }
    
    private void OnIncrementMaximumLicenseCountOperationCompleted(object arg) {
        if ((this.IncrementMaximumLicenseCountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.IncrementMaximumLicenseCountCompleted(this, new IncrementMaximumLicenseCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/GetXMLFromXName", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint GetXMLFromXName(string XName, out string userXML, out string errorString) {
        object[] results = this.Invoke("GetXMLFromXName", new object[] {
                    XName});
        userXML = ((string)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetXMLFromXName(string XName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetXMLFromXName", new object[] {
                    XName}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndGetXMLFromXName(System.IAsyncResult asyncResult, out string userXML, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        userXML = ((string)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void GetXMLFromXNameAsync(string XName) {
        this.GetXMLFromXNameAsync(XName, null);
    }
    
    /// <remarks/>
    public void GetXMLFromXNameAsync(string XName, object userState) {
        if ((this.GetXMLFromXNameOperationCompleted == null)) {
            this.GetXMLFromXNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetXMLFromXNameOperationCompleted);
        }
        this.InvokeAsync("GetXMLFromXName", new object[] {
                    XName}, this.GetXMLFromXNameOperationCompleted, userState);
    }
    
    private void OnGetXMLFromXNameOperationCompleted(object arg) {
        if ((this.GetXMLFromXNameCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetXMLFromXNameCompleted(this, new GetXMLFromXNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SwapUserWLID", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SwapUserWLID(ulong xuid, string oldUserPassportName, string newUserPassportName, out string errorString) {
        object[] results = this.Invoke("SwapUserWLID", new object[] {
                    xuid,
                    oldUserPassportName,
                    newUserPassportName});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwapUserWLID(ulong xuid, string oldUserPassportName, string newUserPassportName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwapUserWLID", new object[] {
                    xuid,
                    oldUserPassportName,
                    newUserPassportName}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSwapUserWLID(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SwapUserWLIDAsync(ulong xuid, string oldUserPassportName, string newUserPassportName) {
        this.SwapUserWLIDAsync(xuid, oldUserPassportName, newUserPassportName, null);
    }
    
    /// <remarks/>
    public void SwapUserWLIDAsync(ulong xuid, string oldUserPassportName, string newUserPassportName, object userState) {
        if ((this.SwapUserWLIDOperationCompleted == null)) {
            this.SwapUserWLIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSwapUserWLIDOperationCompleted);
        }
        this.InvokeAsync("SwapUserWLID", new object[] {
                    xuid,
                    oldUserPassportName,
                    newUserPassportName}, this.SwapUserWLIDOperationCompleted, userState);
    }
    
    private void OnSwapUserWLIDOperationCompleted(object arg) {
        if ((this.SwapUserWLIDCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SwapUserWLIDCompleted(this, new SwapUserWLIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SwapOwnerWLID", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SwapOwnerWLID(ulong xuid, string oldOwnerPassportName, string newOwnerPassportName, out string errorString) {
        object[] results = this.Invoke("SwapOwnerWLID", new object[] {
                    xuid,
                    oldOwnerPassportName,
                    newOwnerPassportName});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwapOwnerWLID(ulong xuid, string oldOwnerPassportName, string newOwnerPassportName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwapOwnerWLID", new object[] {
                    xuid,
                    oldOwnerPassportName,
                    newOwnerPassportName}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSwapOwnerWLID(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SwapOwnerWLIDAsync(ulong xuid, string oldOwnerPassportName, string newOwnerPassportName) {
        this.SwapOwnerWLIDAsync(xuid, oldOwnerPassportName, newOwnerPassportName, null);
    }
    
    /// <remarks/>
    public void SwapOwnerWLIDAsync(ulong xuid, string oldOwnerPassportName, string newOwnerPassportName, object userState) {
        if ((this.SwapOwnerWLIDOperationCompleted == null)) {
            this.SwapOwnerWLIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSwapOwnerWLIDOperationCompleted);
        }
        this.InvokeAsync("SwapOwnerWLID", new object[] {
                    xuid,
                    oldOwnerPassportName,
                    newOwnerPassportName}, this.SwapOwnerWLIDOperationCompleted, userState);
    }
    
    private void OnSwapOwnerWLIDOperationCompleted(object arg) {
        if ((this.SwapOwnerWLIDCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SwapOwnerWLIDCompleted(this, new SwapOwnerWLIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SwapUserDateOfBirth", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SwapUserDateOfBirth(ulong xuid, System.DateTime userDateOfBirth, out string errorString) {
        object[] results = this.Invoke("SwapUserDateOfBirth", new object[] {
                    xuid,
                    userDateOfBirth});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwapUserDateOfBirth(ulong xuid, System.DateTime userDateOfBirth, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwapUserDateOfBirth", new object[] {
                    xuid,
                    userDateOfBirth}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSwapUserDateOfBirth(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SwapUserDateOfBirthAsync(ulong xuid, System.DateTime userDateOfBirth) {
        this.SwapUserDateOfBirthAsync(xuid, userDateOfBirth, null);
    }
    
    /// <remarks/>
    public void SwapUserDateOfBirthAsync(ulong xuid, System.DateTime userDateOfBirth, object userState) {
        if ((this.SwapUserDateOfBirthOperationCompleted == null)) {
            this.SwapUserDateOfBirthOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSwapUserDateOfBirthOperationCompleted);
        }
        this.InvokeAsync("SwapUserDateOfBirth", new object[] {
                    xuid,
                    userDateOfBirth}, this.SwapUserDateOfBirthOperationCompleted, userState);
    }
    
    private void OnSwapUserDateOfBirthOperationCompleted(object arg) {
        if ((this.SwapUserDateOfBirthCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SwapUserDateOfBirthCompleted(this, new SwapUserDateOfBirthCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/FamilyHistoryGetByPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint FamilyHistoryGetByPuid(ulong userPuid, out FamilyHistoryDetail[] details, out string errorString) {
        object[] results = this.Invoke("FamilyHistoryGetByPuid", new object[] {
                    userPuid});
        details = ((FamilyHistoryDetail[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginFamilyHistoryGetByPuid(ulong userPuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("FamilyHistoryGetByPuid", new object[] {
                    userPuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndFamilyHistoryGetByPuid(System.IAsyncResult asyncResult, out FamilyHistoryDetail[] details, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        details = ((FamilyHistoryDetail[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void FamilyHistoryGetByPuidAsync(ulong userPuid) {
        this.FamilyHistoryGetByPuidAsync(userPuid, null);
    }
    
    /// <remarks/>
    public void FamilyHistoryGetByPuidAsync(ulong userPuid, object userState) {
        if ((this.FamilyHistoryGetByPuidOperationCompleted == null)) {
            this.FamilyHistoryGetByPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFamilyHistoryGetByPuidOperationCompleted);
        }
        this.InvokeAsync("FamilyHistoryGetByPuid", new object[] {
                    userPuid}, this.FamilyHistoryGetByPuidOperationCompleted, userState);
    }
    
    private void OnFamilyHistoryGetByPuidOperationCompleted(object arg) {
        if ((this.FamilyHistoryGetByPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.FamilyHistoryGetByPuidCompleted(this, new FamilyHistoryGetByPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/FamilyHistoryGetByGamertag", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint FamilyHistoryGetByGamertag(string gamertag, out FamilyHistoryDetail[] details, out string errorString) {
        object[] results = this.Invoke("FamilyHistoryGetByGamertag", new object[] {
                    gamertag});
        details = ((FamilyHistoryDetail[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginFamilyHistoryGetByGamertag(string gamertag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("FamilyHistoryGetByGamertag", new object[] {
                    gamertag}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndFamilyHistoryGetByGamertag(System.IAsyncResult asyncResult, out FamilyHistoryDetail[] details, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        details = ((FamilyHistoryDetail[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void FamilyHistoryGetByGamertagAsync(string gamertag) {
        this.FamilyHistoryGetByGamertagAsync(gamertag, null);
    }
    
    /// <remarks/>
    public void FamilyHistoryGetByGamertagAsync(string gamertag, object userState) {
        if ((this.FamilyHistoryGetByGamertagOperationCompleted == null)) {
            this.FamilyHistoryGetByGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFamilyHistoryGetByGamertagOperationCompleted);
        }
        this.InvokeAsync("FamilyHistoryGetByGamertag", new object[] {
                    gamertag}, this.FamilyHistoryGetByGamertagOperationCompleted, userState);
    }
    
    private void OnFamilyHistoryGetByGamertagOperationCompleted(object arg) {
        if ((this.FamilyHistoryGetByGamertagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.FamilyHistoryGetByGamertagCompleted(this, new FamilyHistoryGetByGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/GetFamilyMembersByPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint GetFamilyMembersByPuid(ulong userPuid, out FamilyMember[] familyMembers, out string errorString) {
        object[] results = this.Invoke("GetFamilyMembersByPuid", new object[] {
                    userPuid});
        familyMembers = ((FamilyMember[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetFamilyMembersByPuid(ulong userPuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetFamilyMembersByPuid", new object[] {
                    userPuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndGetFamilyMembersByPuid(System.IAsyncResult asyncResult, out FamilyMember[] familyMembers, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        familyMembers = ((FamilyMember[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void GetFamilyMembersByPuidAsync(ulong userPuid) {
        this.GetFamilyMembersByPuidAsync(userPuid, null);
    }
    
    /// <remarks/>
    public void GetFamilyMembersByPuidAsync(ulong userPuid, object userState) {
        if ((this.GetFamilyMembersByPuidOperationCompleted == null)) {
            this.GetFamilyMembersByPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFamilyMembersByPuidOperationCompleted);
        }
        this.InvokeAsync("GetFamilyMembersByPuid", new object[] {
                    userPuid}, this.GetFamilyMembersByPuidOperationCompleted, userState);
    }
    
    private void OnGetFamilyMembersByPuidOperationCompleted(object arg) {
        if ((this.GetFamilyMembersByPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetFamilyMembersByPuidCompleted(this, new GetFamilyMembersByPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/GetFamilyMembersByGamertag", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint GetFamilyMembersByGamertag(string gamertag, out FamilyMember[] familyMembers, out string errorString) {
        object[] results = this.Invoke("GetFamilyMembersByGamertag", new object[] {
                    gamertag});
        familyMembers = ((FamilyMember[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetFamilyMembersByGamertag(string gamertag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetFamilyMembersByGamertag", new object[] {
                    gamertag}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndGetFamilyMembersByGamertag(System.IAsyncResult asyncResult, out FamilyMember[] familyMembers, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        familyMembers = ((FamilyMember[])(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void GetFamilyMembersByGamertagAsync(string gamertag) {
        this.GetFamilyMembersByGamertagAsync(gamertag, null);
    }
    
    /// <remarks/>
    public void GetFamilyMembersByGamertagAsync(string gamertag, object userState) {
        if ((this.GetFamilyMembersByGamertagOperationCompleted == null)) {
            this.GetFamilyMembersByGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFamilyMembersByGamertagOperationCompleted);
        }
        this.InvokeAsync("GetFamilyMembersByGamertag", new object[] {
                    gamertag}, this.GetFamilyMembersByGamertagOperationCompleted, userState);
    }
    
    private void OnGetFamilyMembersByGamertagOperationCompleted(object arg) {
        if ((this.GetFamilyMembersByGamertagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetFamilyMembersByGamertagCompleted(this, new GetFamilyMembersByGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/getMachineAccountByConsoleId", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint getMachineAccountByConsoleId(ulong puid, string consoleId, out bool isLockedOut, out string errorString) {
        object[] results = this.Invoke("getMachineAccountByConsoleId", new object[] {
                    puid,
                    consoleId});
        isLockedOut = ((bool)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BegingetMachineAccountByConsoleId(ulong puid, string consoleId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("getMachineAccountByConsoleId", new object[] {
                    puid,
                    consoleId}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndgetMachineAccountByConsoleId(System.IAsyncResult asyncResult, out bool isLockedOut, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        isLockedOut = ((bool)(results[1]));
        errorString = ((string)(results[2]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void getMachineAccountByConsoleIdAsync(ulong puid, string consoleId) {
        this.getMachineAccountByConsoleIdAsync(puid, consoleId, null);
    }
    
    /// <remarks/>
    public void getMachineAccountByConsoleIdAsync(ulong puid, string consoleId, object userState) {
        if ((this.getMachineAccountByConsoleIdOperationCompleted == null)) {
            this.getMachineAccountByConsoleIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetMachineAccountByConsoleIdOperationCompleted);
        }
        this.InvokeAsync("getMachineAccountByConsoleId", new object[] {
                    puid,
                    consoleId}, this.getMachineAccountByConsoleIdOperationCompleted, userState);
    }
    
    private void OngetMachineAccountByConsoleIdOperationCompleted(object arg) {
        if ((this.getMachineAccountByConsoleIdCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.getMachineAccountByConsoleIdCompleted(this, new getMachineAccountByConsoleIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/IsMachinePuidBanned", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool IsMachinePuidBanned(ulong machinePuid) {
        object[] results = this.Invoke("IsMachinePuidBanned", new object[] {
                    machinePuid});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsMachinePuidBanned(ulong machinePuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsMachinePuidBanned", new object[] {
                    machinePuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndIsMachinePuidBanned(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public void IsMachinePuidBannedAsync(ulong machinePuid) {
        this.IsMachinePuidBannedAsync(machinePuid, null);
    }
    
    /// <remarks/>
    public void IsMachinePuidBannedAsync(ulong machinePuid, object userState) {
        if ((this.IsMachinePuidBannedOperationCompleted == null)) {
            this.IsMachinePuidBannedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsMachinePuidBannedOperationCompleted);
        }
        this.InvokeAsync("IsMachinePuidBanned", new object[] {
                    machinePuid}, this.IsMachinePuidBannedOperationCompleted, userState);
    }
    
    private void OnIsMachinePuidBannedOperationCompleted(object arg) {
        if ((this.IsMachinePuidBannedCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.IsMachinePuidBannedCompleted(this, new IsMachinePuidBannedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/LookupMachineAccountByConsoleIdAndSCode", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ulong LookupMachineAccountByConsoleIdAndSCode(string consoleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] scode) {
        object[] results = this.Invoke("LookupMachineAccountByConsoleIdAndSCode", new object[] {
                    consoleId,
                    scode});
        return ((ulong)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLookupMachineAccountByConsoleIdAndSCode(string consoleId, byte[] scode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LookupMachineAccountByConsoleIdAndSCode", new object[] {
                    consoleId,
                    scode}, callback, asyncState);
    }
    
    /// <remarks/>
    public ulong EndLookupMachineAccountByConsoleIdAndSCode(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ulong)(results[0]));
    }
    
    /// <remarks/>
    public void LookupMachineAccountByConsoleIdAndSCodeAsync(string consoleId, byte[] scode) {
        this.LookupMachineAccountByConsoleIdAndSCodeAsync(consoleId, scode, null);
    }
    
    /// <remarks/>
    public void LookupMachineAccountByConsoleIdAndSCodeAsync(string consoleId, byte[] scode, object userState) {
        if ((this.LookupMachineAccountByConsoleIdAndSCodeOperationCompleted == null)) {
            this.LookupMachineAccountByConsoleIdAndSCodeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachineAccountByConsoleIdAndSCodeOperationCompleted);
        }
        this.InvokeAsync("LookupMachineAccountByConsoleIdAndSCode", new object[] {
                    consoleId,
                    scode}, this.LookupMachineAccountByConsoleIdAndSCodeOperationCompleted, userState);
    }
    
    private void OnLookupMachineAccountByConsoleIdAndSCodeOperationCompleted(object arg) {
        if ((this.LookupMachineAccountByConsoleIdAndSCodeCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.LookupMachineAccountByConsoleIdAndSCodeCompleted(this, new LookupMachineAccountByConsoleIdAndSCodeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/LookupMachineAccountByConsoleIdAndXuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public ulong LookupMachineAccountByConsoleIdAndXuid(string consoleId, ulong xuid) {
        object[] results = this.Invoke("LookupMachineAccountByConsoleIdAndXuid", new object[] {
                    consoleId,
                    xuid});
        return ((ulong)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLookupMachineAccountByConsoleIdAndXuid(string consoleId, ulong xuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LookupMachineAccountByConsoleIdAndXuid", new object[] {
                    consoleId,
                    xuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public ulong EndLookupMachineAccountByConsoleIdAndXuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((ulong)(results[0]));
    }
    
    /// <remarks/>
    public void LookupMachineAccountByConsoleIdAndXuidAsync(string consoleId, ulong xuid) {
        this.LookupMachineAccountByConsoleIdAndXuidAsync(consoleId, xuid, null);
    }
    
    /// <remarks/>
    public void LookupMachineAccountByConsoleIdAndXuidAsync(string consoleId, ulong xuid, object userState) {
        if ((this.LookupMachineAccountByConsoleIdAndXuidOperationCompleted == null)) {
            this.LookupMachineAccountByConsoleIdAndXuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachineAccountByConsoleIdAndXuidOperationCompleted);
        }
        this.InvokeAsync("LookupMachineAccountByConsoleIdAndXuid", new object[] {
                    consoleId,
                    xuid}, this.LookupMachineAccountByConsoleIdAndXuidOperationCompleted, userState);
    }
    
    private void OnLookupMachineAccountByConsoleIdAndXuidOperationCompleted(object arg) {
        if ((this.LookupMachineAccountByConsoleIdAndXuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.LookupMachineAccountByConsoleIdAndXuidCompleted(this, new LookupMachineAccountByConsoleIdAndXuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/MachineHistoryGetByConsoleId", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public MachineHistory[] MachineHistoryGetByConsoleId(string consoleId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
        object[] results = this.Invoke("MachineHistoryGetByConsoleId", new object[] {
                    consoleId,
                    since});
        return ((MachineHistory[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMachineHistoryGetByConsoleId(string consoleId, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MachineHistoryGetByConsoleId", new object[] {
                    consoleId,
                    since}, callback, asyncState);
    }
    
    /// <remarks/>
    public MachineHistory[] EndMachineHistoryGetByConsoleId(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((MachineHistory[])(results[0]));
    }
    
    /// <remarks/>
    public void MachineHistoryGetByConsoleIdAsync(string consoleId, System.Nullable<System.DateTime> since) {
        this.MachineHistoryGetByConsoleIdAsync(consoleId, since, null);
    }
    
    /// <remarks/>
    public void MachineHistoryGetByConsoleIdAsync(string consoleId, System.Nullable<System.DateTime> since, object userState) {
        if ((this.MachineHistoryGetByConsoleIdOperationCompleted == null)) {
            this.MachineHistoryGetByConsoleIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMachineHistoryGetByConsoleIdOperationCompleted);
        }
        this.InvokeAsync("MachineHistoryGetByConsoleId", new object[] {
                    consoleId,
                    since}, this.MachineHistoryGetByConsoleIdOperationCompleted, userState);
    }
    
    private void OnMachineHistoryGetByConsoleIdOperationCompleted(object arg) {
        if ((this.MachineHistoryGetByConsoleIdCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.MachineHistoryGetByConsoleIdCompleted(this, new MachineHistoryGetByConsoleIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/MachineHistoryGetByPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public MachineHistory MachineHistoryGetByPuid(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
        object[] results = this.Invoke("MachineHistoryGetByPuid", new object[] {
                    machinePuid,
                    since});
        return ((MachineHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMachineHistoryGetByPuid(ulong machinePuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MachineHistoryGetByPuid", new object[] {
                    machinePuid,
                    since}, callback, asyncState);
    }
    
    /// <remarks/>
    public MachineHistory EndMachineHistoryGetByPuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((MachineHistory)(results[0]));
    }
    
    /// <remarks/>
    public void MachineHistoryGetByPuidAsync(ulong machinePuid, System.Nullable<System.DateTime> since) {
        this.MachineHistoryGetByPuidAsync(machinePuid, since, null);
    }
    
    /// <remarks/>
    public void MachineHistoryGetByPuidAsync(ulong machinePuid, System.Nullable<System.DateTime> since, object userState) {
        if ((this.MachineHistoryGetByPuidOperationCompleted == null)) {
            this.MachineHistoryGetByPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMachineHistoryGetByPuidOperationCompleted);
        }
        this.InvokeAsync("MachineHistoryGetByPuid", new object[] {
                    machinePuid,
                    since}, this.MachineHistoryGetByPuidOperationCompleted, userState);
    }
    
    private void OnMachineHistoryGetByPuidOperationCompleted(object arg) {
        if ((this.MachineHistoryGetByPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.MachineHistoryGetByPuidCompleted(this, new MachineHistoryGetByPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetFamilyGoldSeatExemptionByPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SetFamilyGoldSeatExemptionByPuid(ulong ownerPassportPuid, ulong dependentPuid, out string errorString) {
        object[] results = this.Invoke("SetFamilyGoldSeatExemptionByPuid", new object[] {
                    ownerPassportPuid,
                    dependentPuid});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetFamilyGoldSeatExemptionByPuid(ulong ownerPassportPuid, ulong dependentPuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetFamilyGoldSeatExemptionByPuid", new object[] {
                    ownerPassportPuid,
                    dependentPuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSetFamilyGoldSeatExemptionByPuid(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SetFamilyGoldSeatExemptionByPuidAsync(ulong ownerPassportPuid, ulong dependentPuid) {
        this.SetFamilyGoldSeatExemptionByPuidAsync(ownerPassportPuid, dependentPuid, null);
    }
    
    /// <remarks/>
    public void SetFamilyGoldSeatExemptionByPuidAsync(ulong ownerPassportPuid, ulong dependentPuid, object userState) {
        if ((this.SetFamilyGoldSeatExemptionByPuidOperationCompleted == null)) {
            this.SetFamilyGoldSeatExemptionByPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetFamilyGoldSeatExemptionByPuidOperationCompleted);
        }
        this.InvokeAsync("SetFamilyGoldSeatExemptionByPuid", new object[] {
                    ownerPassportPuid,
                    dependentPuid}, this.SetFamilyGoldSeatExemptionByPuidOperationCompleted, userState);
    }
    
    private void OnSetFamilyGoldSeatExemptionByPuidOperationCompleted(object arg) {
        if ((this.SetFamilyGoldSeatExemptionByPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetFamilyGoldSeatExemptionByPuidCompleted(this, new SetFamilyGoldSeatExemptionByPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetFamilyGoldSeatExemptionByGamertag", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SetFamilyGoldSeatExemptionByGamertag(string ownerGamertag, string dependentGamertag, out string errorString) {
        object[] results = this.Invoke("SetFamilyGoldSeatExemptionByGamertag", new object[] {
                    ownerGamertag,
                    dependentGamertag});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetFamilyGoldSeatExemptionByGamertag(string ownerGamertag, string dependentGamertag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetFamilyGoldSeatExemptionByGamertag", new object[] {
                    ownerGamertag,
                    dependentGamertag}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSetFamilyGoldSeatExemptionByGamertag(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SetFamilyGoldSeatExemptionByGamertagAsync(string ownerGamertag, string dependentGamertag) {
        this.SetFamilyGoldSeatExemptionByGamertagAsync(ownerGamertag, dependentGamertag, null);
    }
    
    /// <remarks/>
    public void SetFamilyGoldSeatExemptionByGamertagAsync(string ownerGamertag, string dependentGamertag, object userState) {
        if ((this.SetFamilyGoldSeatExemptionByGamertagOperationCompleted == null)) {
            this.SetFamilyGoldSeatExemptionByGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetFamilyGoldSeatExemptionByGamertagOperationCompleted);
        }
        this.InvokeAsync("SetFamilyGoldSeatExemptionByGamertag", new object[] {
                    ownerGamertag,
                    dependentGamertag}, this.SetFamilyGoldSeatExemptionByGamertagOperationCompleted, userState);
    }
    
    private void OnSetFamilyGoldSeatExemptionByGamertagOperationCompleted(object arg) {
        if ((this.SetFamilyGoldSeatExemptionByGamertagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetFamilyGoldSeatExemptionByGamertagCompleted(this, new SetFamilyGoldSeatExemptionByGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/SetFreeGamertagEligible", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint SetFreeGamertagEligible(ulong userPuid, bool isEligible, out string errorString) {
        object[] results = this.Invoke("SetFreeGamertagEligible", new object[] {
                    userPuid,
                    isEligible});
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetFreeGamertagEligible(ulong userPuid, bool isEligible, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetFreeGamertagEligible", new object[] {
                    userPuid,
                    isEligible}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndSetFreeGamertagEligible(System.IAsyncResult asyncResult, out string errorString) {
        object[] results = this.EndInvoke(asyncResult);
        errorString = ((string)(results[1]));
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void SetFreeGamertagEligibleAsync(ulong userPuid, bool isEligible) {
        this.SetFreeGamertagEligibleAsync(userPuid, isEligible, null);
    }
    
    /// <remarks/>
    public void SetFreeGamertagEligibleAsync(ulong userPuid, bool isEligible, object userState) {
        if ((this.SetFreeGamertagEligibleOperationCompleted == null)) {
            this.SetFreeGamertagEligibleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetFreeGamertagEligibleOperationCompleted);
        }
        this.InvokeAsync("SetFreeGamertagEligible", new object[] {
                    userPuid,
                    isEligible}, this.SetFreeGamertagEligibleOperationCompleted, userState);
    }
    
    private void OnSetFreeGamertagEligibleOperationCompleted(object arg) {
        if ((this.SetFreeGamertagEligibleCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetFreeGamertagEligibleCompleted(this, new SetFreeGamertagEligibleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/GamertagHistoryGet", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public UserHistoryDetail[] GamertagHistoryGet(string gamertag, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
        object[] results = this.Invoke("GamertagHistoryGet", new object[] {
                    gamertag,
                    since});
        return ((UserHistoryDetail[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGamertagHistoryGet(string gamertag, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GamertagHistoryGet", new object[] {
                    gamertag,
                    since}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserHistoryDetail[] EndGamertagHistoryGet(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserHistoryDetail[])(results[0]));
    }
    
    /// <remarks/>
    public void GamertagHistoryGetAsync(string gamertag, System.Nullable<System.DateTime> since) {
        this.GamertagHistoryGetAsync(gamertag, since, null);
    }
    
    /// <remarks/>
    public void GamertagHistoryGetAsync(string gamertag, System.Nullable<System.DateTime> since, object userState) {
        if ((this.GamertagHistoryGetOperationCompleted == null)) {
            this.GamertagHistoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGamertagHistoryGetOperationCompleted);
        }
        this.InvokeAsync("GamertagHistoryGet", new object[] {
                    gamertag,
                    since}, this.GamertagHistoryGetOperationCompleted, userState);
    }
    
    private void OnGamertagHistoryGetOperationCompleted(object arg) {
        if ((this.GamertagHistoryGetCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GamertagHistoryGetCompleted(this, new GamertagHistoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/UserHistoryGetByGamertag", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public UserHistory UserHistoryGetByGamertag(string gamertag, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
        object[] results = this.Invoke("UserHistoryGetByGamertag", new object[] {
                    gamertag,
                    since});
        return ((UserHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUserHistoryGetByGamertag(string gamertag, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UserHistoryGetByGamertag", new object[] {
                    gamertag,
                    since}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserHistory EndUserHistoryGetByGamertag(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserHistory)(results[0]));
    }
    
    /// <remarks/>
    public void UserHistoryGetByGamertagAsync(string gamertag, System.Nullable<System.DateTime> since) {
        this.UserHistoryGetByGamertagAsync(gamertag, since, null);
    }
    
    /// <remarks/>
    public void UserHistoryGetByGamertagAsync(string gamertag, System.Nullable<System.DateTime> since, object userState) {
        if ((this.UserHistoryGetByGamertagOperationCompleted == null)) {
            this.UserHistoryGetByGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUserHistoryGetByGamertagOperationCompleted);
        }
        this.InvokeAsync("UserHistoryGetByGamertag", new object[] {
                    gamertag,
                    since}, this.UserHistoryGetByGamertagOperationCompleted, userState);
    }
    
    private void OnUserHistoryGetByGamertagOperationCompleted(object arg) {
        if ((this.UserHistoryGetByGamertagCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.UserHistoryGetByGamertagCompleted(this, new UserHistoryGetByGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xbox.com/xsuppapi/UserHistoryGetByPuid", RequestNamespace="http://xbox.com/xsuppapi/", ResponseNamespace="http://xbox.com/xsuppapi/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public UserHistory UserHistoryGetByPuid(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
        object[] results = this.Invoke("UserHistoryGetByPuid", new object[] {
                    userPuid,
                    since});
        return ((UserHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUserHistoryGetByPuid(ulong userPuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UserHistoryGetByPuid", new object[] {
                    userPuid,
                    since}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserHistory EndUserHistoryGetByPuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserHistory)(results[0]));
    }
    
    /// <remarks/>
    public void UserHistoryGetByPuidAsync(ulong userPuid, System.Nullable<System.DateTime> since) {
        this.UserHistoryGetByPuidAsync(userPuid, since, null);
    }
    
    /// <remarks/>
    public void UserHistoryGetByPuidAsync(ulong userPuid, System.Nullable<System.DateTime> since, object userState) {
        if ((this.UserHistoryGetByPuidOperationCompleted == null)) {
            this.UserHistoryGetByPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUserHistoryGetByPuidOperationCompleted);
        }
        this.InvokeAsync("UserHistoryGetByPuid", new object[] {
                    userPuid,
                    since}, this.UserHistoryGetByPuidOperationCompleted, userState);
    }
    
    private void OnUserHistoryGetByPuidOperationCompleted(object arg) {
        if ((this.UserHistoryGetByPuidCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.UserHistoryGetByPuidCompleted(this, new UserHistoryGetByPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class ConsoleApplications {
    
    private ulong machinePuidField;
    
    private string consoleIdField;
    
    private ConsoleApplicationGroup[] applicationGroupsField;
    
    /// <remarks/>
    public ulong MachinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public string ConsoleId {
        get {
            return this.consoleIdField;
        }
        set {
            this.consoleIdField = value;
        }
    }
    
    /// <remarks/>
    public ConsoleApplicationGroup[] ApplicationGroups {
        get {
            return this.applicationGroupsField;
        }
        set {
            this.applicationGroupsField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class ConsoleApplicationGroup {
    
    private string nameField;
    
    private string systemOnlineManifestRevisionField;
    
    private string systemManifestRevisionField;
    
    private int flashVersionField;
    
    private System.Guid groupIdField;
    
    private ConsoleApplicationDetail[] applicationsField;
    
    /// <remarks/>
    public string Name {
        get {
            return this.nameField;
        }
        set {
            this.nameField = value;
        }
    }
    
    /// <remarks/>
    public string SystemOnlineManifestRevision {
        get {
            return this.systemOnlineManifestRevisionField;
        }
        set {
            this.systemOnlineManifestRevisionField = value;
        }
    }
    
    /// <remarks/>
    public string SystemManifestRevision {
        get {
            return this.systemManifestRevisionField;
        }
        set {
            this.systemManifestRevisionField = value;
        }
    }
    
    /// <remarks/>
    public int FlashVersion {
        get {
            return this.flashVersionField;
        }
        set {
            this.flashVersionField = value;
        }
    }
    
    /// <remarks/>
    public System.Guid GroupId {
        get {
            return this.groupIdField;
        }
        set {
            this.groupIdField = value;
        }
    }
    
    /// <remarks/>
    public ConsoleApplicationDetail[] Applications {
        get {
            return this.applicationsField;
        }
        set {
            this.applicationsField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class ConsoleApplicationDetail {
    
    private string fileNameField;
    
    private string friendlyNameField;
    
    private string appVersionField;
    
    private bool onlineField;
    
    /// <remarks/>
    public string FileName {
        get {
            return this.fileNameField;
        }
        set {
            this.fileNameField = value;
        }
    }
    
    /// <remarks/>
    public string FriendlyName {
        get {
            return this.friendlyNameField;
        }
        set {
            this.friendlyNameField = value;
        }
    }
    
    /// <remarks/>
    public string AppVersion {
        get {
            return this.appVersionField;
        }
        set {
            this.appVersionField = value;
        }
    }
    
    /// <remarks/>
    public bool Online {
        get {
            return this.onlineField;
        }
        set {
            this.onlineField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class UserHistory {
    
    private ulong userPuidField;
    
    private UserHistoryDetail[] userHistoryDetailField;
    
    private MachineHistoryDetail[] machineHistoryDetailField;
    
    /// <remarks/>
    public ulong UserPuid {
        get {
            return this.userPuidField;
        }
        set {
            this.userPuidField = value;
        }
    }
    
    /// <remarks/>
    public UserHistoryDetail[] UserHistoryDetail {
        get {
            return this.userHistoryDetailField;
        }
        set {
            this.userHistoryDetailField = value;
        }
    }
    
    /// <remarks/>
    public MachineHistoryDetail[] MachineHistoryDetail {
        get {
            return this.machineHistoryDetailField;
        }
        set {
            this.machineHistoryDetailField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class UserHistoryDetail {
    
    private System.DateTime timestampField;
    
    private System.Nullable<ulong> userPuidField;
    
    private System.Nullable<ulong> machinePuidField;
    
    private string ipAddressField;
    
    private string reasonField;
    
    private string detailField;
    
    /// <remarks/>
    public System.DateTime Timestamp {
        get {
            return this.timestampField;
        }
        set {
            this.timestampField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> UserPuid {
        get {
            return this.userPuidField;
        }
        set {
            this.userPuidField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> MachinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public string IpAddress {
        get {
            return this.ipAddressField;
        }
        set {
            this.ipAddressField = value;
        }
    }
    
    /// <remarks/>
    public string Reason {
        get {
            return this.reasonField;
        }
        set {
            this.reasonField = value;
        }
    }
    
    /// <remarks/>
    public string Detail {
        get {
            return this.detailField;
        }
        set {
            this.detailField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class MachineHistoryDetail {
    
    private ulong userPuidField;
    
    private ulong machinePuidField;
    
    private System.DateTime firstSeenField;
    
    private System.DateTime lastSeenField;
    
    private int daysSeenField;
    
    private string ipAddressField;
    
    /// <remarks/>
    public ulong UserPuid {
        get {
            return this.userPuidField;
        }
        set {
            this.userPuidField = value;
        }
    }
    
    /// <remarks/>
    public ulong MachinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime FirstSeen {
        get {
            return this.firstSeenField;
        }
        set {
            this.firstSeenField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime LastSeen {
        get {
            return this.lastSeenField;
        }
        set {
            this.lastSeenField = value;
        }
    }
    
    /// <remarks/>
    public int DaysSeen {
        get {
            return this.daysSeenField;
        }
        set {
            this.daysSeenField = value;
        }
    }
    
    /// <remarks/>
    public string IpAddress {
        get {
            return this.ipAddressField;
        }
        set {
            this.ipAddressField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class MachineInfo {
    
    private ulong machinePuidField;
    
    private string consoleIdField;
    
    private byte[] secondaryIdentifierField;
    
    private System.DateTime resetDateField;
    
    private System.DateTime createDateField;
    
    private string flashVersionField;
    
    private System.DateTime flashDateField;
    
    private int consoleRegionField;
    
    private string updateVersionField;
    
    private System.DateTime updateDateField;
    
    /// <remarks/>
    public ulong MachinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public string ConsoleId {
        get {
            return this.consoleIdField;
        }
        set {
            this.consoleIdField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] SecondaryIdentifier {
        get {
            return this.secondaryIdentifierField;
        }
        set {
            this.secondaryIdentifierField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime ResetDate {
        get {
            return this.resetDateField;
        }
        set {
            this.resetDateField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime CreateDate {
        get {
            return this.createDateField;
        }
        set {
            this.createDateField = value;
        }
    }
    
    /// <remarks/>
    public string FlashVersion {
        get {
            return this.flashVersionField;
        }
        set {
            this.flashVersionField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime FlashDate {
        get {
            return this.flashDateField;
        }
        set {
            this.flashDateField = value;
        }
    }
    
    /// <remarks/>
    public int ConsoleRegion {
        get {
            return this.consoleRegionField;
        }
        set {
            this.consoleRegionField = value;
        }
    }
    
    /// <remarks/>
    public string UpdateVersion {
        get {
            return this.updateVersionField;
        }
        set {
            this.updateVersionField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime UpdateDate {
        get {
            return this.updateDateField;
        }
        set {
            this.updateDateField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class MachineHistory {
    
    private ulong machinePuidField;
    
    private UserHistoryDetail[] userHistoryDetailField;
    
    private MachineHistoryDetail[] machineHistoryDetailField;
    
    private MachineInfo machineConsoleInfoField;
    
    /// <remarks/>
    public ulong MachinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public UserHistoryDetail[] UserHistoryDetail {
        get {
            return this.userHistoryDetailField;
        }
        set {
            this.userHistoryDetailField = value;
        }
    }
    
    /// <remarks/>
    public MachineHistoryDetail[] MachineHistoryDetail {
        get {
            return this.machineHistoryDetailField;
        }
        set {
            this.machineHistoryDetailField = value;
        }
    }
    
    /// <remarks/>
    public MachineInfo MachineConsoleInfo {
        get {
            return this.machineConsoleInfoField;
        }
        set {
            this.machineConsoleInfoField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class FamilyMember {
    
    private ulong userPuidField;
    
    private ushort userFlagsField;
    
    private string gamertagField;
    
    /// <remarks/>
    public ulong userPuid {
        get {
            return this.userPuidField;
        }
        set {
            this.userPuidField = value;
        }
    }
    
    /// <remarks/>
    public ushort userFlags {
        get {
            return this.userFlagsField;
        }
        set {
            this.userFlagsField = value;
        }
    }
    
    /// <remarks/>
    public string gamertag {
        get {
            return this.gamertagField;
        }
        set {
            this.gamertagField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class FamilyHistoryDetail {
    
    private ulong ownerPassportPuidField;
    
    private string ownerGamertagField;
    
    private ulong dependentPuidField;
    
    private string dependentGamertagField;
    
    private System.Nullable<ulong> machinePuidField;
    
    private string ipAddressField;
    
    private System.DateTime timestampField;
    
    private uint hrField;
    
    private string reasonField;
    
    /// <remarks/>
    public ulong ownerPassportPuid {
        get {
            return this.ownerPassportPuidField;
        }
        set {
            this.ownerPassportPuidField = value;
        }
    }
    
    /// <remarks/>
    public string ownerGamertag {
        get {
            return this.ownerGamertagField;
        }
        set {
            this.ownerGamertagField = value;
        }
    }
    
    /// <remarks/>
    public ulong dependentPuid {
        get {
            return this.dependentPuidField;
        }
        set {
            this.dependentPuidField = value;
        }
    }
    
    /// <remarks/>
    public string dependentGamertag {
        get {
            return this.dependentGamertagField;
        }
        set {
            this.dependentGamertagField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> machinePuid {
        get {
            return this.machinePuidField;
        }
        set {
            this.machinePuidField = value;
        }
    }
    
    /// <remarks/>
    public string ipAddress {
        get {
            return this.ipAddressField;
        }
        set {
            this.ipAddressField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime timestamp {
        get {
            return this.timestampField;
        }
        set {
            this.timestampField = value;
        }
    }
    
    /// <remarks/>
    public uint hr {
        get {
            return this.hrField;
        }
        set {
            this.hrField = value;
        }
    }
    
    /// <remarks/>
    public string reason {
        get {
            return this.reasonField;
        }
        set {
            this.reasonField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xbox.com/xsuppapi/")]
public partial class ProfileItem {
    
    private uint profileItemField;
    
    private string profileItemValueField;
    
    private uint titleIdField;
    
    /// <remarks/>
    public uint profileItem {
        get {
            return this.profileItemField;
        }
        set {
            this.profileItemField = value;
        }
    }
    
    /// <remarks/>
    public string profileItemValue {
        get {
            return this.profileItemValueField;
        }
        set {
            this.profileItemValueField = value;
        }
    }
    
    /// <remarks/>
    public uint titleId {
        get {
            return this.titleIdField;
        }
        set {
            this.titleIdField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void ConsoleApplicationsGetByGamerTagCompletedEventHandler(object sender, ConsoleApplicationsGetByGamerTagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class ConsoleApplicationsGetByGamerTagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal ConsoleApplicationsGetByGamerTagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ConsoleApplications[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ConsoleApplications[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void ConsoleApplicationsGetByUserPuidCompletedEventHandler(object sender, ConsoleApplicationsGetByUserPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class ConsoleApplicationsGetByUserPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal ConsoleApplicationsGetByUserPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ConsoleApplications[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ConsoleApplications[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void ConsoleApplicationsGetByConsoleIdCompletedEventHandler(object sender, ConsoleApplicationsGetByConsoleIdCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class ConsoleApplicationsGetByConsoleIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal ConsoleApplicationsGetByConsoleIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ConsoleApplications[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ConsoleApplications[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void ConsoleApplicationsGetByMachinePuidCompletedEventHandler(object sender, ConsoleApplicationsGetByMachinePuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class ConsoleApplicationsGetByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal ConsoleApplicationsGetByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ConsoleApplications Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ConsoleApplications)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getPuidFromXNameCompletedEventHandler(object sender, getPuidFromXNameCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getPuidFromXNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getPuidFromXNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public ulong puid {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getAccountCompletedEventHandler(object sender, getAccountCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public bool isAccountOwner {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public bool isActive {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[2]));
        }
    }
    
    /// <remarks/>
    public bool isLockedOut {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[3]));
        }
    }
    
    /// <remarks/>
    public bool isVoiceBanned {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[4]));
        }
    }
    
    /// <remarks/>
    public bool isNicknameBanned {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[5]));
        }
    }
    
    /// <remarks/>
    public bool mustChangeXName {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[6]));
        }
    }
    
    /// <remarks/>
    public bool isGeofenceExempt {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[7]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[8]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void modifyAccountCompletedEventHandler(object sender, modifyAccountCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class modifyAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal modifyAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void banAccountCompletedEventHandler(object sender, banAccountCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class banAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal banAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getRelatedAccountsCompletedEventHandler(object sender, getRelatedAccountsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getRelatedAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getRelatedAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public ulong[] relatedAccounts {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong[])(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string[] relatedAccountNames {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string[])(this.results[2]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[3]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getSubscriptionCodeStatusCompletedEventHandler(object sender, getSubscriptionCodeStatusCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getSubscriptionCodeStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getSubscriptionCodeStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public bool bValidSubscriptionCode {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public bool bUsed {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[2]));
        }
    }
    
    /// <remarks/>
    public bool bUsedMaxTimes {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[3]));
        }
    }
    
    /// <remarks/>
    public ulong ulLastUser {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[4]));
        }
    }
    
    /// <remarks/>
    public string szLastUser {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[5]));
        }
    }
    
    /// <remarks/>
    public System.DateTime ftLastUsage {
        get {
            this.RaiseExceptionIfNecessary();
            return ((System.DateTime)(this.results[6]));
        }
    }
    
    /// <remarks/>
    public ulong ulOfferID {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[7]));
        }
    }
    
    /// <remarks/>
    public string szOffer {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[8]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[9]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getAccountExCompletedEventHandler(object sender, getAccountExCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getAccountExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getAccountExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public ulong biOwnerPuid {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public System.DateTime dtAccountResumeDate {
        get {
            this.RaiseExceptionIfNecessary();
            return ((System.DateTime)(this.results[2]));
        }
    }
    
    /// <remarks/>
    public int iSuspensionLength {
        get {
            this.RaiseExceptionIfNecessary();
            return ((int)(this.results[3]));
        }
    }
    
    /// <remarks/>
    public System.DateTime dtVoiceResumeDate {
        get {
            this.RaiseExceptionIfNecessary();
            return ((System.DateTime)(this.results[4]));
        }
    }
    
    /// <remarks/>
    public int iVoiceBanLength {
        get {
            this.RaiseExceptionIfNecessary();
            return ((int)(this.results[5]));
        }
    }
    
    /// <remarks/>
    public bool bMustChangeXName {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[6]));
        }
    }
    
    /// <remarks/>
    public System.DateTime dtAcceptedTOS {
        get {
            this.RaiseExceptionIfNecessary();
            return ((System.DateTime)(this.results[7]));
        }
    }
    
    /// <remarks/>
    public byte tiCountryID {
        get {
            this.RaiseExceptionIfNecessary();
            return ((byte)(this.results[8]));
        }
    }
    
    /// <remarks/>
    public bool isGeoFenceExempt {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[9]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[10]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getPassportMemberNameCompletedEventHandler(object sender, getPassportMemberNameCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getPassportMemberNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getPassportMemberNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string userPmn {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string parentPmn {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[3]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void RemoveGamerPictureCompletedEventHandler(object sender, RemoveGamerPictureCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class RemoveGamerPictureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal RemoveGamerPictureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetUserMottoCompletedEventHandler(object sender, SetUserMottoCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetUserMottoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetUserMottoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetUserProfileItemsCompletedEventHandler(object sender, SetUserProfileItemsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetUserProfileItemsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetUserProfileItemsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void IncrementMaximumLicenseCountCompletedEventHandler(object sender, IncrementMaximumLicenseCountCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class IncrementMaximumLicenseCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal IncrementMaximumLicenseCountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetXMLFromXNameCompletedEventHandler(object sender, GetXMLFromXNameCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetXMLFromXNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetXMLFromXNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string userXML {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SwapUserWLIDCompletedEventHandler(object sender, SwapUserWLIDCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SwapUserWLIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SwapUserWLIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SwapOwnerWLIDCompletedEventHandler(object sender, SwapOwnerWLIDCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SwapOwnerWLIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SwapOwnerWLIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SwapUserDateOfBirthCompletedEventHandler(object sender, SwapUserDateOfBirthCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SwapUserDateOfBirthCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SwapUserDateOfBirthCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void FamilyHistoryGetByPuidCompletedEventHandler(object sender, FamilyHistoryGetByPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class FamilyHistoryGetByPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal FamilyHistoryGetByPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public FamilyHistoryDetail[] details {
        get {
            this.RaiseExceptionIfNecessary();
            return ((FamilyHistoryDetail[])(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void FamilyHistoryGetByGamertagCompletedEventHandler(object sender, FamilyHistoryGetByGamertagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class FamilyHistoryGetByGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal FamilyHistoryGetByGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public FamilyHistoryDetail[] details {
        get {
            this.RaiseExceptionIfNecessary();
            return ((FamilyHistoryDetail[])(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetFamilyMembersByPuidCompletedEventHandler(object sender, GetFamilyMembersByPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetFamilyMembersByPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetFamilyMembersByPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public FamilyMember[] familyMembers {
        get {
            this.RaiseExceptionIfNecessary();
            return ((FamilyMember[])(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetFamilyMembersByGamertagCompletedEventHandler(object sender, GetFamilyMembersByGamertagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetFamilyMembersByGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetFamilyMembersByGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public FamilyMember[] familyMembers {
        get {
            this.RaiseExceptionIfNecessary();
            return ((FamilyMember[])(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void getMachineAccountByConsoleIdCompletedEventHandler(object sender, getMachineAccountByConsoleIdCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class getMachineAccountByConsoleIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal getMachineAccountByConsoleIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public bool isLockedOut {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[1]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[2]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void IsMachinePuidBannedCompletedEventHandler(object sender, IsMachinePuidBannedCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class IsMachinePuidBannedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal IsMachinePuidBannedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public bool Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void LookupMachineAccountByConsoleIdAndSCodeCompletedEventHandler(object sender, LookupMachineAccountByConsoleIdAndSCodeCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class LookupMachineAccountByConsoleIdAndSCodeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal LookupMachineAccountByConsoleIdAndSCodeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ulong Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void LookupMachineAccountByConsoleIdAndXuidCompletedEventHandler(object sender, LookupMachineAccountByConsoleIdAndXuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class LookupMachineAccountByConsoleIdAndXuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal LookupMachineAccountByConsoleIdAndXuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public ulong Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((ulong)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void MachineHistoryGetByConsoleIdCompletedEventHandler(object sender, MachineHistoryGetByConsoleIdCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class MachineHistoryGetByConsoleIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal MachineHistoryGetByConsoleIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public MachineHistory[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((MachineHistory[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void MachineHistoryGetByPuidCompletedEventHandler(object sender, MachineHistoryGetByPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class MachineHistoryGetByPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal MachineHistoryGetByPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public MachineHistory Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((MachineHistory)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetFamilyGoldSeatExemptionByPuidCompletedEventHandler(object sender, SetFamilyGoldSeatExemptionByPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetFamilyGoldSeatExemptionByPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetFamilyGoldSeatExemptionByPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetFamilyGoldSeatExemptionByGamertagCompletedEventHandler(object sender, SetFamilyGoldSeatExemptionByGamertagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetFamilyGoldSeatExemptionByGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetFamilyGoldSeatExemptionByGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetFreeGamertagEligibleCompletedEventHandler(object sender, SetFreeGamertagEligibleCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetFreeGamertagEligibleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetFreeGamertagEligibleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
    
    /// <remarks/>
    public string errorString {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[1]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GamertagHistoryGetCompletedEventHandler(object sender, GamertagHistoryGetCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GamertagHistoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GamertagHistoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public UserHistoryDetail[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((UserHistoryDetail[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void UserHistoryGetByGamertagCompletedEventHandler(object sender, UserHistoryGetByGamertagCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class UserHistoryGetByGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal UserHistoryGetByGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public UserHistory Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((UserHistory)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void UserHistoryGetByPuidCompletedEventHandler(object sender, UserHistoryGetByPuidCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class UserHistoryGetByPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal UserHistoryGetByPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public UserHistory Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((UserHistory)(this.results[0]));
        }
    }
}
} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\sts\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.sts.WebService {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SecurityTicketSoap", Namespace="urn:schemas-xbox-com:SecurityTicket-data")]
    public partial class SecurityTicket : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetPartnerSecurityTicketOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSecurityTicketOperationCompleted;
        
        /// <remarks/>
        public SecurityTicket() {
            this.Url = "http://localhost:10290/Sts/sts.asmx";
        }
        
        /// <remarks/>
        public event GetPartnerSecurityTicketCompletedEventHandler GetPartnerSecurityTicketCompleted;
        
        /// <remarks/>
        public event GetSecurityTicketCompletedEventHandler GetSecurityTicketCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:SecurityTicket-data/GetPartnerSecurityTicket", RequestNamespace="urn:schemas-xbox-com:SecurityTicket-data", ResponseNamespace="urn:schemas-xbox-com:SecurityTicket-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetPartnerSecurityTicket(ulong xuid, uint titleId, ushort titleVersion) {
            object[] results = this.Invoke("GetPartnerSecurityTicket", new object[] {
                        xuid,
                        titleId,
                        titleVersion});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPartnerSecurityTicket(ulong xuid, uint titleId, ushort titleVersion, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPartnerSecurityTicket", new object[] {
                        xuid,
                        titleId,
                        titleVersion}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetPartnerSecurityTicket(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetPartnerSecurityTicketAsync(ulong xuid, uint titleId, ushort titleVersion) {
            this.GetPartnerSecurityTicketAsync(xuid, titleId, titleVersion, null);
        }
        
        /// <remarks/>
        public void GetPartnerSecurityTicketAsync(ulong xuid, uint titleId, ushort titleVersion, object userState) {
            if ((this.GetPartnerSecurityTicketOperationCompleted == null)) {
                this.GetPartnerSecurityTicketOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPartnerSecurityTicketOperationCompleted);
            }
            this.InvokeAsync("GetPartnerSecurityTicket", new object[] {
                        xuid,
                        titleId,
                        titleVersion}, this.GetPartnerSecurityTicketOperationCompleted, userState);
        }
        
        private void OnGetPartnerSecurityTicketOperationCompleted(object arg) {
            if ((this.GetPartnerSecurityTicketCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPartnerSecurityTicketCompleted(this, new GetPartnerSecurityTicketCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:SecurityTicket-data/GetSecurityTicket", RequestNamespace="urn:schemas-xbox-com:SecurityTicket-data", ResponseNamespace="urn:schemas-xbox-com:SecurityTicket-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetSecurityTicket(byte platformType, uint titleId, ushort titleVersion, ushort clientVersion, string deviceId) {
            object[] results = this.Invoke("GetSecurityTicket", new object[] {
                        platformType,
                        titleId,
                        titleVersion,
                        clientVersion,
                        deviceId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSecurityTicket(byte platformType, uint titleId, ushort titleVersion, ushort clientVersion, string deviceId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSecurityTicket", new object[] {
                        platformType,
                        titleId,
                        titleVersion,
                        clientVersion,
                        deviceId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSecurityTicket(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSecurityTicketAsync(byte platformType, uint titleId, ushort titleVersion, ushort clientVersion, string deviceId) {
            this.GetSecurityTicketAsync(platformType, titleId, titleVersion, clientVersion, deviceId, null);
        }
        
        /// <remarks/>
        public void GetSecurityTicketAsync(byte platformType, uint titleId, ushort titleVersion, ushort clientVersion, string deviceId, object userState) {
            if ((this.GetSecurityTicketOperationCompleted == null)) {
                this.GetSecurityTicketOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSecurityTicketOperationCompleted);
            }
            this.InvokeAsync("GetSecurityTicket", new object[] {
                        platformType,
                        titleId,
                        titleVersion,
                        clientVersion,
                        deviceId}, this.GetSecurityTicketOperationCompleted, userState);
        }
        
        private void OnGetSecurityTicketOperationCompleted(object arg) {
            if ((this.GetSecurityTicketCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSecurityTicketCompleted(this, new GetSecurityTicketCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPartnerSecurityTicketCompletedEventHandler(object sender, GetPartnerSecurityTicketCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPartnerSecurityTicketCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPartnerSecurityTicketCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSecurityTicketCompletedEventHandler(object sender, GetSecurityTicketCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSecurityTicketCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSecurityTicketCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\UACS\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ServerTestFramework.LiveService.UserAccount.WebService
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;

    // 
    // This source code was auto-generated by wsdl, Version=2.0.50727.42.
    // 


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SvcProvider : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AddCreditCardOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPointsBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SignInOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentInstrumentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        /// <remarks/>
        public SvcProvider() {
            this.Url = "http://localhost:10050/xuacs/useraccount.asmx";
        }
        
        /// <remarks/>
        public event AddCreditCardCompletedEventHandler AddCreditCardCompleted;
        
        /// <remarks/>
        public event GetPointsBalanceCompletedEventHandler GetPointsBalanceCompleted;
        
        /// <remarks/>
        public event SignInCompletedEventHandler SignInCompleted;
        
        /// <remarks/>
        public event GetPaymentInstrumentsCompletedEventHandler GetPaymentInstrumentsCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AddCreditCard", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            object[] results = this.Invoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate});
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public AddCreditCardResults EndAddCreditCard(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            this.AddCreditCardAsync(userPuid, machinePuid, addressStreet1, addressStreet2, addressCity, addressDistrict, addressState, addressPostalCode, phonePrefix, phoneNumber, phoneExtension, cardType, accountHolderName, accountNumber, cardVerificationNumber, expirationDate, null);
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    object userState) {
            if ((this.AddCreditCardOperationCompleted == null)) {
                this.AddCreditCardOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCreditCardOperationCompleted);
            }
            this.InvokeAsync("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, this.AddCreditCardOperationCompleted, userState);
        }
        
        private void OnAddCreditCardOperationCompleted(object arg) {
            if ((this.AddCreditCardCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCreditCardCompleted(this, new AddCreditCardCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid) {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                        userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPointsBalance(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPointsBalance", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPointsBalanceResults EndGetPointsBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid) {
            this.GetPointsBalanceAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid, object userState) {
            if ((this.GetPointsBalanceOperationCompleted == null)) {
                this.GetPointsBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPointsBalanceOperationCompleted);
            }
            this.InvokeAsync("GetPointsBalance", new object[] {
                        userPuid}, this.GetPointsBalanceOperationCompleted, userState);
        }
        
        private void OnGetPointsBalanceOperationCompleted(object arg) {
            if ((this.GetPointsBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPointsBalanceCompleted(this, new GetPointsBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn() {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignIn(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignIn", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public SignInResults EndSignIn(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public void SignInAsync() {
            this.SignInAsync(null);
        }
        
        /// <remarks/>
        public void SignInAsync(object userState) {
            if ((this.SignInOperationCompleted == null)) {
                this.SignInOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignInOperationCompleted);
            }
            this.InvokeAsync("SignIn", new object[0], this.SignInOperationCompleted, userState);
        }
        
        private void OnSignInOperationCompleted(object arg) {
            if ((this.SignInCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignInCompleted(this, new SignInCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPaymentInstruments", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid});
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(ulong userPuid, ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults EndGetPaymentInstruments(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid) {
            this.GetPaymentInstrumentsAsync(userPuid, machinePuid, null);
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid, object userState) {
            if ((this.GetPaymentInstrumentsOperationCompleted == null)) {
                this.GetPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, this.GetPaymentInstrumentsOperationCompleted, userState);
        }
        
        private void OnGetPaymentInstrumentsOperationCompleted(object arg) {
            if ((this.GetPaymentInstrumentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsCompleted(this, new GetPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetUserAuthorization", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetUserAuthorizationInfo", IsNullable=true)]
        public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId});
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserAuthorization(int serviceType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo EndGetUserAuthorization(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId) {
            this.GetUserAuthorizationAsync(serviceType, titleId, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddCreditCardResults {
        
        private string paymentInstrumentIdField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo {
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo {
        
        private ulong offerIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private bool hasLapsedField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalOfferIdField;
        
        /// <remarks/>
        public ulong OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public bool HasLapsed {
            get {
                return this.hasLapsedField;
            }
            set {
                this.hasLapsedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalOfferId {
            get {
                return this.renewalOfferIdField;
            }
            set {
                this.renewalOfferIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;
        
        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint[] servicesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable=false)]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Service", IsNullable=false)]
        public uint[] Services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetUserAuthorizationInfo {
        
        private ErrorInfo errorInfoField;
        
        private AccountInfo accountInfoField;
        
        private SubscriptionInfo[] subscriptionInfoField;
        
        private SessionInfo sessionInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Subscription")]
        public SubscriptionInfo[] SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionInfo SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class BillingAgreementDetails {
        
        private string payerEmailField;
        
        private string billingAgreementIdField;
        
        private string firstNameField;
        
        private string lastNameField;
        
        private string middleNameField;
        
        private string payerBusinessField;
        
        private string payerCountryField;
        
        private string billingAgreementDescriptionField;
        
        /// <remarks/>
        public string PayerEmail {
            get {
                return this.payerEmailField;
            }
            set {
                this.payerEmailField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementId {
            get {
                return this.billingAgreementIdField;
            }
            set {
                this.billingAgreementIdField = value;
            }
        }
        
        /// <remarks/>
        public string FirstName {
            get {
                return this.firstNameField;
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string LastName {
            get {
                return this.lastNameField;
            }
            set {
                this.lastNameField = value;
            }
        }
        
        /// <remarks/>
        public string MiddleName {
            get {
                return this.middleNameField;
            }
            set {
                this.middleNameField = value;
            }
        }
        
        /// <remarks/>
        public string PayerBusiness {
            get {
                return this.payerBusinessField;
            }
            set {
                this.payerBusinessField = value;
            }
        }
        
        /// <remarks/>
        public string PayerCountry {
            get {
                return this.payerCountryField;
            }
            set {
                this.payerCountryField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementDescription {
            get {
                return this.billingAgreementDescriptionField;
            }
            set {
                this.billingAgreementDescriptionField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PayPalPayinInfo {
        
        private BillingAgreementDetails billingAgreementDetailsField;
        
        /// <remarks/>
        public BillingAgreementDetails BillingAgreementDetails {
            get {
                return this.billingAgreementDetailsField;
            }
            set {
                this.billingAgreementDetailsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class WholesaleInfo {
        
        private string accountHolderNameField;
        
        private string externalReferenceIdField;
        
        private string wholesalePartnerField;
        
        private string encryptedPasswordField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public string WholesalePartner {
            get {
                return this.wholesalePartnerField;
            }
            set {
                this.wholesalePartnerField = value;
            }
        }
        
        /// <remarks/>
        public string EncryptedPassword {
            get {
                return this.encryptedPasswordField;
            }
            set {
                this.encryptedPasswordField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class DirectDebitInfo {
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string bankCodeField;
        
        private string branchCodeField;
        
        private string checkDigitsField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string BankCode {
            get {
                return this.bankCodeField;
            }
            set {
                this.bankCodeField = value;
            }
        }
        
        /// <remarks/>
        public string BranchCode {
            get {
                return this.branchCodeField;
            }
            set {
                this.branchCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CheckDigits {
            get {
                return this.checkDigitsField;
            }
            set {
                this.checkDigitsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CreditCardInfo {
        
        private byte cardTypeField;
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string ccvNumberField;
        
        private System.DateTime expirationDateField;
        
        /// <remarks/>
        public byte CardType {
            get {
                return this.cardTypeField;
            }
            set {
                this.cardTypeField = value;
            }
        }
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string CcvNumber {
            get {
                return this.ccvNumberField;
            }
            set {
                this.ccvNumberField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ExpirationDate {
            get {
                return this.expirationDateField;
            }
            set {
                this.expirationDateField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PhoneInfo {
        
        private string phonePrefixField;
        
        private string phoneNumberField;
        
        private string phoneExtensionField;
        
        /// <remarks/>
        public string PhonePrefix {
            get {
                return this.phonePrefixField;
            }
            set {
                this.phonePrefixField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneNumber {
            get {
                return this.phoneNumberField;
            }
            set {
                this.phoneNumberField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneExtension {
            get {
                return this.phoneExtensionField;
            }
            set {
                this.phoneExtensionField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddressInfo {
        
        private string street1Field;
        
        private string street2Field;
        
        private string cityField;
        
        private string districtField;
        
        private string stateField;
        
        private string postalCodeField;
        
        /// <remarks/>
        public string Street1 {
            get {
                return this.street1Field;
            }
            set {
                this.street1Field = value;
            }
        }
        
        /// <remarks/>
        public string Street2 {
            get {
                return this.street2Field;
            }
            set {
                this.street2Field = value;
            }
        }
        
        /// <remarks/>
        public string City {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string District {
            get {
                return this.districtField;
            }
            set {
                this.districtField = value;
            }
        }
        
        /// <remarks/>
        public string State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PaymentInstrumentInfo {
        
        private string paymentInstrumentIdField;
        
        private byte paymentInstrumentTypeField;
        
        private AddressInfo addressInfoField;
        
        private PhoneInfo phoneInfoField;
        
        private CreditCardInfo creditCardInfoField;
        
        private DirectDebitInfo directDebitInfoField;
        
        private WholesaleInfo wholesaleInfoField;
        
        private PayPalPayinInfo payPalPayinInfoField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
        
        /// <remarks/>
        public byte PaymentInstrumentType {
            get {
                return this.paymentInstrumentTypeField;
            }
            set {
                this.paymentInstrumentTypeField = value;
            }
        }
        
        /// <remarks/>
        public AddressInfo AddressInfo {
            get {
                return this.addressInfoField;
            }
            set {
                this.addressInfoField = value;
            }
        }
        
        /// <remarks/>
        public PhoneInfo PhoneInfo {
            get {
                return this.phoneInfoField;
            }
            set {
                this.phoneInfoField = value;
            }
        }
        
        /// <remarks/>
        public CreditCardInfo CreditCardInfo {
            get {
                return this.creditCardInfoField;
            }
            set {
                this.creditCardInfoField = value;
            }
        }
        
        /// <remarks/>
        public DirectDebitInfo DirectDebitInfo {
            get {
                return this.directDebitInfoField;
            }
            set {
                this.directDebitInfoField = value;
            }
        }
        
        /// <remarks/>
        public WholesaleInfo WholesaleInfo {
            get {
                return this.wholesaleInfoField;
            }
            set {
                this.wholesaleInfoField = value;
            }
        }
        
        /// <remarks/>
        public PayPalPayinInfo PayPalPayinInfo {
            get {
                return this.payPalPayinInfoField;
            }
            set {
                this.payPalPayinInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPaymentInstrumentResults {
        
        private PaymentInstrumentInfo[] paymentInstrumentInfosField;
        
        /// <remarks/>
        public PaymentInstrumentInfo[] PaymentInstrumentInfos {
            get {
                return this.paymentInstrumentInfosField;
            }
            set {
                this.paymentInstrumentInfosField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionDetails {
        
        private byte[] sessionKeyField;
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SessionKey {
            get {
                return this.sessionKeyField;
            }
            set {
                this.sessionKeyField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionDetails {
        
        private ulong xboxOfferIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private string musicNetSkuField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalXboxOfferIdField;
        
        /// <remarks/>
        public ulong XboxOfferId {
            get {
                return this.xboxOfferIdField;
            }
            set {
                this.xboxOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetSku {
            get {
                return this.musicNetSkuField;
            }
            set {
                this.musicNetSkuField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalXboxOfferId {
            get {
                return this.renewalXboxOfferIdField;
            }
            set {
                this.renewalXboxOfferIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountDetails {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string postalCodeField;
        
        private string countryCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorDetails {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool subscriptionLapsedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool SubscriptionLapsed {
            get {
                return this.subscriptionLapsedField;
            }
            set {
                this.subscriptionLapsedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults {
        
        private ErrorDetails errorInfoField;
        
        private AccountDetails accountInfoField;
        
        private SubscriptionDetails subscriptionInfoField;
        
        private SessionDetails sessionInfoField;
        
        /// <remarks/>
        public ErrorDetails ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountDetails AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        public SubscriptionDetails SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionDetails SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults {
        
        private int pointsBalanceField;
        
        private bool aboveLowBalanceField;
        
        private byte dmpAccountStatusField;
        
        /// <remarks/>
        public int PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool AboveLowBalance {
            get {
                return this.aboveLowBalanceField;
            }
            set {
                this.aboveLowBalanceField = value;
            }
        }
        
        /// <remarks/>
        public byte DmpAccountStatus {
            get {
                return this.dmpAccountStatusField;
            }
            set {
                this.dmpAccountStatusField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCreditCardCompletedEventHandler(object sender, AddCreditCardCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCreditCardCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCreditCardCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AddCreditCardResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AddCreditCardResults)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPointsBalanceCompletedEventHandler(object sender, GetPointsBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPointsBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPointsBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPointsBalanceResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPointsBalanceResults)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SignInCompletedEventHandler(object sender, SignInCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignInCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SignInCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SignInResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SignInResults)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentInstrumentsCompletedEventHandler(object sender, GetPaymentInstrumentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPaymentInstrumentResults)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetUserAuthorizationInfo)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\UACS2\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserAccount.WebService2
{
    public class SvcProviderWrapper : UserAccount
    {
        //UserAccount Prov=new UserAccount();

        public static int   TimeOut=25000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public string ServerAddr;
        public ulong PassportPuid;
        public ulong Xuid;
        public ulong MachinePuid;
        public uint TitleId;

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }

        new public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) 
        {
            AddCreditCardResults results;
            results=base.AddCreditCard(
                     userPuid, 
                     machinePuid, 
                     addressStreet1, 
                     addressStreet2, 
                     addressCity, 
                     addressDistrict, 
                     addressState, 
                     addressPostalCode, 
                     phonePrefix, 
                     phoneNumber, 
                     phoneExtension, 
                     cardType, 
                     accountHolderName, 
                     accountNumber, 
                     cardVerificationNumber, 
                     expirationDate);

            return (results);
        }
        
        
        new public GetPointsBalanceResults GetPointsBalance(ulong userPuid) 
        {
            GetPointsBalanceResults results;
            results = base.GetPointsBalance(userPuid);

            return (results);
        }
        
        
        new public SignInResults SignIn() 
        {
            SignInResults results;
            results = base.SignIn();
            
            return (results);
        }
        
        
        new public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) 
        {
            GetPaymentInstrumentResults results;
            results = base.GetPaymentInstruments(userPuid, machinePuid);

            return (results);
        }
        
        
        new public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) 
        {
            GetUserAuthorizationInfo results;
            results = base.GetUserAuthorization(serviceType, titleId);

            return (results);
        }

        new public void AcceptTermsOfService(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) 
        {
            base.AcceptTermsOfService( userPuid,  signedOwnerPassportPuid, serviceType);
        }

        new public void CreateMobileAccount(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) 
        {
            base.CreateMobileAccount( userPuid,  ownerPassportTicket,  machinePuid,  gamertag,  countryId,  languageId, birthDate);
        }

        new public string GenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) 
        {
            string results;
            results = base.GenerateGamertag(  seed,  machinePuid,  gamertagSuggestionType);
            
            return (results);
        }

        new public CountryInfo[] GetSupportedCountries(byte serviceType, byte platformType) 
        {
            CountryInfo[] results;
            results = base.GetSupportedCountries(serviceType, platformType);
            
            return (results);
        }

        new public string TestConnection(string inputMessage) 
        {
            string results;
            results = base.TestConnection(inputMessage);

            return (results);
        }

        new public ConsoleApplications ConsoleApplicationsGetByMachinePuid(ulong machinePuid)
        {
            ConsoleApplications results;
            results = base.ConsoleApplicationsGetByMachinePuid(machinePuid);
            return results;
        }

        public SvcProviderWrapper() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs))
        {
            ;
        }

        public SvcProviderWrapper(ulong passportPuid, ulong xuid, ulong machinePuid, uint titleId) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs))
        {
            PassportPuid = passportPuid;
            Xuid = xuid;
            MachinePuid = machinePuid;
            TitleId = titleId;
            TimeOut = 60000;
        }
        
        public SvcProviderWrapper(ulong _passportPuid) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs))
        {
            PassportPuid = _passportPuid;
        }

        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/xuacs/useraccount.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/xuacs/useraccount.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            HttpWebRequest wr = (HttpWebRequest) base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            FakeAAInfo fakeAAInfo = new FakeAAInfo(PassportPuid, UacsCommon.GetLocalIpAddress());

            STSUtil.GetSecurityTicketParameters gstParam = new STSUtil.GetSecurityTicketParameters();
            gstParam.Puid0 = PassportPuid.ToString();
            gstParam.Xuid0 = Xuid.ToString();
            gstParam.MachineID = MachinePuid.ToString();
            gstParam.TitleID = TitleId.ToString();
            gstParam.Certificate = new X509Certificate2("sts.test.xboxlive.com.pfx","XblRocks!");
            fakeAAInfo.SamlToken = STSUtil.GetSecurityTicket(gstParam);
            
            xonline.common.service.AAInfo.MarshallToHeaders(wr.Headers, fakeAAInfo);

            wr.KeepAlive = false;

            return wr;
        }

    }

#if false
    public class AAInfoWrapper : xonline.common.service.AAInfo
    {
        // Expose the constructor
        public AAInfoWrapper () : base()
        {
            _ipAddressInternet = "";
            _certDeviceId = "";
            _samlToken = "";
        }

        // These properties are serialized to the AuthZ header
        public new ulong PassportPuid { set { _passportPuid = value; } }
        public new string IpAddressInternet { set { _ipAddressInternet = value; } }
        public new ulong? LiveXuid { set { _liveXuid = value; } }
        public new ulong PassportCId { set { _passportCId = value; } }
        public new DateTime NotAfter { set { _notAfterDateTime = value; } }
        public new DateTime IssueInstant { set { _issueInstantDateTime = value; } }
        public new string CertDeviceId { get { return _certDeviceId; } set { _certDeviceId = value; } }
        public string SamlToken { set { _samlToken = value; } }

        // These properties are not serialized
        public xonline.common.service.XblSamlToken SamlSecurityToken { set { _xblSamlToken = value; } }
        public new System.Net.IPAddress OriginatingIP { set { _originatingIP = value; } }
        public new byte? CountryId { set { _countryId = value; } }
        public new System.Collections.BitArray UserPrivileges { set { _userPrivileges = value; } }

        #region AAInfo Abstract Members

        // No need to implement these.

        protected override void PopulateLiveXuid ()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserInfo ()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserPrivileges ()
        {
            throw new NotImplementedException();
        }

        #endregion
    }
#endif
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\TeamWidget\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Teams {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="TeamsSoap", Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class Teams : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback CreateTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback ManageTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback ManageTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback RecruitTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback JoinTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamInfoOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamMembersOperationCompleted;
        
        /// <remarks/>
        public Teams() {
            this.ComputeUrl("wcteams", "/teams/teams.asmx");
        }
        
        /// <remarks/>
        public event CreateTeamCompletedEventHandler CreateTeamCompleted;
        
        /// <remarks/>
        public event DeleteTeamCompletedEventHandler DeleteTeamCompleted;
        
        /// <remarks/>
        public event RemoveTeamMemberCompletedEventHandler RemoveTeamMemberCompleted;
        
        /// <remarks/>
        public event ManageTeamCompletedEventHandler ManageTeamCompleted;
        
        /// <remarks/>
        public event ManageTeamMemberCompletedEventHandler ManageTeamMemberCompleted;
        
        /// <remarks/>
        public event RecruitTeamMemberCompletedEventHandler RecruitTeamMemberCompleted;
        
        /// <remarks/>
        public event JoinTeamCompletedEventHandler JoinTeamCompleted;
        
        /// <remarks/>
        public event GetTeamInfoCompletedEventHandler GetTeamInfoCompleted;
        
        /// <remarks/>
        public event GetTeamMembersCompletedEventHandler GetTeamMembersCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/CreateTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] teamData, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] creatorData) {
            this.Invoke("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateTeam(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData) {
            this.CreateTeamAsync(titleId, webId, gamerTag, teamName, maxMembers, description, motto, URL, teamData, creatorData, null);
        }
        
        /// <remarks/>
        public void CreateTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData, object userState) {
            if ((this.CreateTeamOperationCompleted == null)) {
                this.CreateTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateTeamOperationCompleted);
            }
            this.InvokeAsync("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData}, this.CreateTeamOperationCompleted, userState);
        }
        
        private void OnCreateTeamOperationCompleted(object arg) {
            if ((this.CreateTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/DeleteTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            this.Invoke("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTeam(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.DeleteTeamAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void DeleteTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.DeleteTeamOperationCompleted == null)) {
                this.DeleteTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteTeamOperationCompleted);
            }
            this.InvokeAsync("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.DeleteTeamOperationCompleted, userState);
        }
        
        private void OnDeleteTeamOperationCompleted(object arg) {
            if ((this.DeleteTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RemoveTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag) {
            this.Invoke("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RemoveTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag) {
            this.RemoveTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, null);
        }
        
        /// <remarks/>
        public void RemoveTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, object userState) {
            if ((this.RemoveTeamMemberOperationCompleted == null)) {
                this.RemoveTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveTeamMemberOperationCompleted);
            }
            this.InvokeAsync("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag}, this.RemoveTeamMemberOperationCompleted, userState);
        }
        
        private void OnRemoveTeamMemberOperationCompleted(object arg) {
            if ((this.RemoveTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ManageTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] teamData) {
            this.Invoke("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginManageTeam(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndManageTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ManageTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData) {
            this.ManageTeamAsync(titleId, webId, gamerTag, teamName, newTeamName, description, motto, URL, teamData, null);
        }
        
        /// <remarks/>
        public void ManageTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData, object userState) {
            if ((this.ManageTeamOperationCompleted == null)) {
                this.ManageTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageTeamOperationCompleted);
            }
            this.InvokeAsync("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData}, this.ManageTeamOperationCompleted, userState);
        }
        
        private void OnManageTeamOperationCompleted(object arg) {
            if ((this.ManageTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ManageTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] memberData) {
            this.Invoke("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginManageTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndManageTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ManageTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData) {
            this.ManageTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, memberPriv, memberData, null);
        }
        
        /// <remarks/>
        public void ManageTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, object userState) {
            if ((this.ManageTeamMemberOperationCompleted == null)) {
                this.ManageTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageTeamMemberOperationCompleted);
            }
            this.InvokeAsync("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, this.ManageTeamMemberOperationCompleted, userState);
        }
        
        private void OnManageTeamMemberOperationCompleted(object arg) {
            if ((this.ManageTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RecruitTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RecruitTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] memberData) {
            this.Invoke("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRecruitTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRecruitTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RecruitTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData) {
            this.RecruitTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, memberPriv, memberData, null);
        }
        
        /// <remarks/>
        public void RecruitTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, object userState) {
            if ((this.RecruitTeamMemberOperationCompleted == null)) {
                this.RecruitTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRecruitTeamMemberOperationCompleted);
            }
            this.InvokeAsync("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, this.RecruitTeamMemberOperationCompleted, userState);
        }
        
        private void OnRecruitTeamMemberOperationCompleted(object arg) {
            if ((this.RecruitTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RecruitTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/JoinTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void JoinTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, byte answer) {
            this.Invoke("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginJoinTeam(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndJoinTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void JoinTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer) {
            this.JoinTeamAsync(titleId, webId, gamerTag, teamName, answer, null);
        }
        
        /// <remarks/>
        public void JoinTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer, object userState) {
            if ((this.JoinTeamOperationCompleted == null)) {
                this.JoinTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnJoinTeamOperationCompleted);
            }
            this.InvokeAsync("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer}, this.JoinTeamOperationCompleted, userState);
        }
        
        private void OnJoinTeamOperationCompleted(object arg) {
            if ((this.JoinTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.JoinTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamInfo", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TeamInfo[] GetTeamInfo(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            object[] results = this.Invoke("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
            return ((TeamInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamInfo(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public TeamInfo[] EndGetTeamInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TeamInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamInfoAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.GetTeamInfoAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void GetTeamInfoAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.GetTeamInfoOperationCompleted == null)) {
                this.GetTeamInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamInfoOperationCompleted);
            }
            this.InvokeAsync("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.GetTeamInfoOperationCompleted, userState);
        }
        
        private void OnGetTeamInfoOperationCompleted(object arg) {
            if ((this.GetTeamInfoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamInfoCompleted(this, new GetTeamInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamMembers", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TeamMember[] GetTeamMembers(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            object[] results = this.Invoke("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
            return ((TeamMember[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamMembers(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public TeamMember[] EndGetTeamMembers(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TeamMember[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamMembersAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.GetTeamMembersAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void GetTeamMembersAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.GetTeamMembersOperationCompleted == null)) {
                this.GetTeamMembersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamMembersOperationCompleted);
            }
            this.InvokeAsync("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.GetTeamMembersOperationCompleted, userState);
        }
        
        private void OnGetTeamMembersOperationCompleted(object arg) {
            if ((this.GetTeamMembersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamMembersCompleted(this, new GetTeamMembersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class TeamInfo {
        
        private string nameField;
        
        private string descriptionField;
        
        private string mottoField;
        
        private string uRLField;
        
        private ulong createdField;
        
        private uint numMembersField;
        
        private byte[] dataField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string motto {
            get {
                return this.mottoField;
            }
            set {
                this.mottoField = value;
            }
        }
        
        /// <remarks/>
        public string URL {
            get {
                return this.uRLField;
            }
            set {
                this.uRLField = value;
            }
        }
        
        /// <remarks/>
        public ulong created {
            get {
                return this.createdField;
            }
            set {
                this.createdField = value;
            }
        }
        
        /// <remarks/>
        public uint numMembers {
            get {
                return this.numMembersField;
            }
            set {
                this.numMembersField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class TeamMember {
        
        private string gamertagField;
        
        private bool memberField;
        
        private uint privilegesField;
        
        private byte[] dataField;
        
        private ulong joinedField;
        
        /// <remarks/>
        public string gamertag {
            get {
                return this.gamertagField;
            }
            set {
                this.gamertagField = value;
            }
        }
        
        /// <remarks/>
        public bool member {
            get {
                return this.memberField;
            }
            set {
                this.memberField = value;
            }
        }
        
        /// <remarks/>
        public uint privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
        
        /// <remarks/>
        public ulong joined {
            get {
                return this.joinedField;
            }
            set {
                this.joinedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RecruitTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void JoinTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamInfoCompletedEventHandler(object sender, GetTeamInfoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TeamInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TeamInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamMembersCompletedEventHandler(object sender, GetTeamMembersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamMembersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamMembersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TeamMember[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TeamMember[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetGeneralInfo\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.GeneralInfo {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="GeneralInfoSoap", Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public partial class GeneralInfo : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetTitleListOperationCompleted;
        
        private System.Threading.SendOrPostCallback LinkedGamerTagsOperationCompleted;
        
        /// <remarks/>
        public GeneralInfo() {
            this.ComputeUrl("wcgeneral", "/generalinfo/generalinfo.asmx");
        }
        
        /// <remarks/>
        public event GetTitleListCompletedEventHandler GetTitleListCompleted;
        
        /// <remarks/>
        public event LinkedGamerTagsCompletedEventHandler LinkedGamerTagsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/GetTitleList", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TitlePrivilegeInfo[] GetTitleList(out uint ValidSeconds) {
            object[] results = this.Invoke("GetTitleList", new object[0]);
            ValidSeconds = ((uint)(results[1]));
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleList(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleList", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public TitlePrivilegeInfo[] EndGetTitleList(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTitleListAsync() {
            this.GetTitleListAsync(null);
        }
        
        /// <remarks/>
        public void GetTitleListAsync(object userState) {
            if ((this.GetTitleListOperationCompleted == null)) {
                this.GetTitleListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTitleListOperationCompleted);
            }
            this.InvokeAsync("GetTitleList", new object[0], this.GetTitleListOperationCompleted, userState);
        }
        
        private void OnGetTitleListOperationCompleted(object arg) {
            if ((this.GetTitleListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTitleListCompleted(this, new GetTitleListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID) {
            object[] results = this.Invoke("LinkedGamerTags", new object[] {
                        WebID});
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLinkedGamerTags(byte[] WebID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LinkedGamerTags", new object[] {
                        WebID}, callback, asyncState);
        }
        
        /// <remarks/>
        public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID) {
            this.LinkedGamerTagsAsync(WebID, null);
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID, object userState) {
            if ((this.LinkedGamerTagsOperationCompleted == null)) {
                this.LinkedGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkedGamerTagsOperationCompleted);
            }
            this.InvokeAsync("LinkedGamerTags", new object[] {
                        WebID}, this.LinkedGamerTagsOperationCompleted, userState);
        }
        
        private void OnLinkedGamerTagsOperationCompleted(object arg) {
            if ((this.LinkedGamerTagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LinkedGamerTagsCompleted(this, new LinkedGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public partial class TitlePrivilegeInfo {
        
        private uint titleIDField;
        
        private TitlePrivilege privilegesField;
        
        private ESRBRating ratingField;
        
        private string defaultLocaleField;
        
        private LocalizedDisplayName[] localizedNameField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public TitlePrivilege Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public ESRBRating Rating {
            get {
                return this.ratingField;
            }
            set {
                this.ratingField = value;
            }
        }
        
        /// <remarks/>
        public string DefaultLocale {
            get {
                return this.defaultLocaleField;
            }
            set {
                this.defaultLocaleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LocalizedDisplayName[] LocalizedName {
            get {
                return this.localizedNameField;
            }
            set {
                this.localizedNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public enum TitlePrivilege {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        ReadOnly,
        
        /// <remarks/>
        ReadWrite,
        
        /// <remarks/>
        FullControl,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public enum ESRBRating {
        
        /// <remarks/>
        ALL,
        
        /// <remarks/>
        ADULT,
        
        /// <remarks/>
        MATURE,
        
        /// <remarks/>
        TEEN,
        
        /// <remarks/>
        EVERYONE,
        
        /// <remarks/>
        KIDS_TO_ADULTS,
        
        /// <remarks/>
        EARLY_CHILDHOOD,
        
        /// <remarks/>
        UNSPECIFIED,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public partial class LocalizedDisplayName {
        
        private string localeField;
        
        private string displayNameField;
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayName {
            get {
                return this.displayNameField;
            }
            set {
                this.displayNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public partial class LinkInfo {
        
        private string gamerTagField;
        
        private bool ownerField;
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public bool Owner {
            get {
                return this.ownerField;
            }
            set {
                this.ownerField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleListCompletedEventHandler(object sender, GetTitleListCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TitlePrivilegeInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TitlePrivilegeInfo[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LinkedGamerTagsCompletedEventHandler(object sender, LinkedGamerTagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LinkedGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LinkedGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LinkInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LinkInfo[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\UACS2\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.UserAccount.WebService2 {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AcceptTermsOfServiceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddCreditCardOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPointsBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SignInOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateMobileAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GenerateGamertagOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentInstrumentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSupportedCountriesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback ConsoleApplicationsGetByMachinePuidOperationCompleted;
        
        /// <remarks/>
        public UserAccount() {
            this.Url = "http://localhost:10050/xuacs/useraccount.asmx";
        }
        
        /// <remarks/>
        public event AcceptTermsOfServiceCompletedEventHandler AcceptTermsOfServiceCompleted;
        
        /// <remarks/>
        public event AddCreditCardCompletedEventHandler AddCreditCardCompleted;
        
        /// <remarks/>
        public event GetPointsBalanceCompletedEventHandler GetPointsBalanceCompleted;
        
        /// <remarks/>
        public event SignInCompletedEventHandler SignInCompleted;
        
        /// <remarks/>
        public event CreateMobileAccountCompletedEventHandler CreateMobileAccountCompleted;
        
        /// <remarks/>
        public event GenerateGamertagCompletedEventHandler GenerateGamertagCompleted;
        
        /// <remarks/>
        public event GetPaymentInstrumentsCompletedEventHandler GetPaymentInstrumentsCompleted;
        
        /// <remarks/>
        public event GetSupportedCountriesCompletedEventHandler GetSupportedCountriesCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event ConsoleApplicationsGetByMachinePuidCompletedEventHandler ConsoleApplicationsGetByMachinePuidCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AcceptTermsOfService", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AcceptTermsOfService(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            this.Invoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAcceptTermsOfService(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAcceptTermsOfService(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            this.AcceptTermsOfServiceAsync(userPuid, signedOwnerPassportPuid, serviceType, null);
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, object userState) {
            if ((this.AcceptTermsOfServiceOperationCompleted == null)) {
                this.AcceptTermsOfServiceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcceptTermsOfServiceOperationCompleted);
            }
            this.InvokeAsync("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, this.AcceptTermsOfServiceOperationCompleted, userState);
        }
        
        private void OnAcceptTermsOfServiceOperationCompleted(object arg) {
            if ((this.AcceptTermsOfServiceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AcceptTermsOfServiceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AddCreditCard", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            object[] results = this.Invoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate});
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public AddCreditCardResults EndAddCreditCard(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            this.AddCreditCardAsync(userPuid, machinePuid, addressStreet1, addressStreet2, addressCity, addressDistrict, addressState, addressPostalCode, phonePrefix, phoneNumber, phoneExtension, cardType, accountHolderName, accountNumber, cardVerificationNumber, expirationDate, null);
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    object userState) {
            if ((this.AddCreditCardOperationCompleted == null)) {
                this.AddCreditCardOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCreditCardOperationCompleted);
            }
            this.InvokeAsync("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, this.AddCreditCardOperationCompleted, userState);
        }
        
        private void OnAddCreditCardOperationCompleted(object arg) {
            if ((this.AddCreditCardCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCreditCardCompleted(this, new AddCreditCardCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid) {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                        userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPointsBalance(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPointsBalance", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPointsBalanceResults EndGetPointsBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid) {
            this.GetPointsBalanceAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid, object userState) {
            if ((this.GetPointsBalanceOperationCompleted == null)) {
                this.GetPointsBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPointsBalanceOperationCompleted);
            }
            this.InvokeAsync("GetPointsBalance", new object[] {
                        userPuid}, this.GetPointsBalanceOperationCompleted, userState);
        }
        
        private void OnGetPointsBalanceOperationCompleted(object arg) {
            if ((this.GetPointsBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPointsBalanceCompleted(this, new GetPointsBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn() {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignIn(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignIn", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public SignInResults EndSignIn(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public void SignInAsync() {
            this.SignInAsync(null);
        }
        
        /// <remarks/>
        public void SignInAsync(object userState) {
            if ((this.SignInOperationCompleted == null)) {
                this.SignInOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignInOperationCompleted);
            }
            this.InvokeAsync("SignIn", new object[0], this.SignInOperationCompleted, userState);
        }
        
        private void OnSignInOperationCompleted(object arg) {
            if ((this.SignInCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignInCompleted(this, new SignInCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/CreateMobileAccount", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateMobileAccount(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            this.Invoke("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateMobileAccount(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateMobileAccount(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            this.CreateMobileAccountAsync(userPuid, ownerPassportTicket, machinePuid, gamertag, countryId, languageId, birthDate, null);
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, object userState) {
            if ((this.CreateMobileAccountOperationCompleted == null)) {
                this.CreateMobileAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateMobileAccountOperationCompleted);
            }
            this.InvokeAsync("CreateMobileAccount", new object[] {
                        userPuid,
                        ownerPassportTicket,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, this.CreateMobileAccountOperationCompleted, userState);
        }
        
        private void OnCreateMobileAccountOperationCompleted(object arg) {
            if ((this.CreateMobileAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateMobileAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GenerateGamertag", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            object[] results = this.Invoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGenerateGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            this.GenerateGamertagAsync(seed, machinePuid, gamertagSuggestionType, null);
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, object userState) {
            if ((this.GenerateGamertagOperationCompleted == null)) {
                this.GenerateGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGenerateGamertagOperationCompleted);
            }
            this.InvokeAsync("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, this.GenerateGamertagOperationCompleted, userState);
        }
        
        private void OnGenerateGamertagOperationCompleted(object arg) {
            if ((this.GenerateGamertagCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GenerateGamertagCompleted(this, new GenerateGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPaymentInstruments", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid});
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(ulong userPuid, ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults EndGetPaymentInstruments(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid) {
            this.GetPaymentInstrumentsAsync(userPuid, machinePuid, null);
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid, object userState) {
            if ((this.GetPaymentInstrumentsOperationCompleted == null)) {
                this.GetPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, this.GetPaymentInstrumentsOperationCompleted, userState);
        }
        
        private void OnGetPaymentInstrumentsOperationCompleted(object arg) {
            if ((this.GetPaymentInstrumentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsCompleted(this, new GetPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetSupportedCountries", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CountryInfo[] GetSupportedCountries(byte serviceType, byte platformType) {
            object[] results = this.Invoke("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType});
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSupportedCountries(byte serviceType, byte platformType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType}, callback, asyncState);
        }
        
        /// <remarks/>
        public CountryInfo[] EndGetSupportedCountries(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte platformType) {
            this.GetSupportedCountriesAsync(serviceType, platformType, null);
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte platformType, object userState) {
            if ((this.GetSupportedCountriesOperationCompleted == null)) {
                this.GetSupportedCountriesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSupportedCountriesOperationCompleted);
            }
            this.InvokeAsync("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType}, this.GetSupportedCountriesOperationCompleted, userState);
        }
        
        private void OnGetSupportedCountriesOperationCompleted(object arg) {
            if ((this.GetSupportedCountriesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSupportedCountriesCompleted(this, new GetSupportedCountriesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetUserAuthorization", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetUserAuthorizationInfo", IsNullable=true)]
        public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId});
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserAuthorization(int serviceType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo EndGetUserAuthorization(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId) {
            this.GetUserAuthorizationAsync(serviceType, titleId, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/ConsoleApplicationsGetByMachinePuid", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleApplications ConsoleApplicationsGetByMachinePuid(ulong machinePuid) {
            object[] results = this.Invoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid});
            return ((ConsoleApplications)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConsoleApplicationsGetByMachinePuid(ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleApplications EndConsoleApplicationsGetByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleApplications)(results[0]));
        }
        
        /// <remarks/>
        public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid) {
            this.ConsoleApplicationsGetByMachinePuidAsync(machinePuid, null);
        }
        
        /// <remarks/>
        public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid, object userState) {
            if ((this.ConsoleApplicationsGetByMachinePuidOperationCompleted == null)) {
                this.ConsoleApplicationsGetByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid}, this.ConsoleApplicationsGetByMachinePuidOperationCompleted, userState);
        }
        
        private void OnConsoleApplicationsGetByMachinePuidOperationCompleted(object arg) {
            if ((this.ConsoleApplicationsGetByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConsoleApplicationsGetByMachinePuidCompleted(this, new ConsoleApplicationsGetByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum ServiceTypeEnum {
        
        /// <remarks/>
        Unknown,
        
        /// <remarks/>
        XboxLive,
        
        /// <remarks/>
        Zune,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddCreditCardResults {
        
        private string paymentInstrumentIdField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplicationDetail {
        
        private string fileNameField;
        
        private string friendlyNameField;
        
        private string appVersionField;
        
        private bool onlineField;
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        public string FriendlyName {
            get {
                return this.friendlyNameField;
            }
            set {
                this.friendlyNameField = value;
            }
        }
        
        /// <remarks/>
        public string AppVersion {
            get {
                return this.appVersionField;
            }
            set {
                this.appVersionField = value;
            }
        }
        
        /// <remarks/>
        public bool Online {
            get {
                return this.onlineField;
            }
            set {
                this.onlineField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplicationGroup {
        
        private string nameField;
        
        private string systemOnlineManifestRevisionField;
        
        private string systemManifestRevisionField;
        
        private int flashVersionField;
        
        private string groupIdField;
        
        private ConsoleApplicationDetail[] applicationsField;
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string SystemOnlineManifestRevision {
            get {
                return this.systemOnlineManifestRevisionField;
            }
            set {
                this.systemOnlineManifestRevisionField = value;
            }
        }
        
        /// <remarks/>
        public string SystemManifestRevision {
            get {
                return this.systemManifestRevisionField;
            }
            set {
                this.systemManifestRevisionField = value;
            }
        }
        
        /// <remarks/>
        public int FlashVersion {
            get {
                return this.flashVersionField;
            }
            set {
                this.flashVersionField = value;
            }
        }
        
        /// <remarks/>
        public string GroupId {
            get {
                return this.groupIdField;
            }
            set {
                this.groupIdField = value;
            }
        }
        
        /// <remarks/>
        public ConsoleApplicationDetail[] Applications {
            get {
                return this.applicationsField;
            }
            set {
                this.applicationsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplications {
        
        private string consoleIdField;
        
        private ConsoleApplicationGroup[] applicationGroupsField;
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        public ConsoleApplicationGroup[] ApplicationGroups {
            get {
                return this.applicationGroupsField;
            }
            set {
                this.applicationGroupsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo {
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo {
        
        private ulong offerIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private bool hasLapsedField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalOfferIdField;
        
        /// <remarks/>
        public ulong OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public bool HasLapsed {
            get {
                return this.hasLapsedField;
            }
            set {
                this.hasLapsedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalOfferId {
            get {
                return this.renewalOfferIdField;
            }
            set {
                this.renewalOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;
        
        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint[] servicesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        private uint cultureIdField;
        
        private uint parentalControlGroupIdField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable=false)]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Service", IsNullable=false)]
        public uint[] Services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
        
        /// <remarks/>
        public uint CultureId {
            get {
                return this.cultureIdField;
            }
            set {
                this.cultureIdField = value;
            }
        }
        
        /// <remarks/>
        public uint ParentalControlGroupId {
            get {
                return this.parentalControlGroupIdField;
            }
            set {
                this.parentalControlGroupIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetUserAuthorizationInfo {
        
        private ErrorInfo errorInfoField;
        
        private AccountInfo accountInfoField;
        
        private SubscriptionInfo[] subscriptionInfoField;
        
        private SessionInfo sessionInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Subscription")]
        public SubscriptionInfo[] SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionInfo SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CountryInfo {
        
        private byte countryIdField;
        
        private string countryCodeField;
        
        private byte userField;
        
        private byte billingField;
        
        private bool allowDirectDebitField;
        
        private bool allowPayPalField;
        
        private bool requireCCAgeVerificationField;
        
        /// <remarks/>
        public byte CountryId {
            get {
                return this.countryIdField;
            }
            set {
                this.countryIdField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public byte User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public byte Billing {
            get {
                return this.billingField;
            }
            set {
                this.billingField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowDirectDebit {
            get {
                return this.allowDirectDebitField;
            }
            set {
                this.allowDirectDebitField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowPayPal {
            get {
                return this.allowPayPalField;
            }
            set {
                this.allowPayPalField = value;
            }
        }
        
        /// <remarks/>
        public bool RequireCCAgeVerification {
            get {
                return this.requireCCAgeVerificationField;
            }
            set {
                this.requireCCAgeVerificationField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class BillingAgreementDetails {
        
        private string payerEmailField;
        
        private string billingAgreementIdField;
        
        private string firstNameField;
        
        private string lastNameField;
        
        private string middleNameField;
        
        private string payerBusinessField;
        
        private string payerCountryField;
        
        private string billingAgreementDescriptionField;
        
        /// <remarks/>
        public string PayerEmail {
            get {
                return this.payerEmailField;
            }
            set {
                this.payerEmailField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementId {
            get {
                return this.billingAgreementIdField;
            }
            set {
                this.billingAgreementIdField = value;
            }
        }
        
        /// <remarks/>
        public string FirstName {
            get {
                return this.firstNameField;
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string LastName {
            get {
                return this.lastNameField;
            }
            set {
                this.lastNameField = value;
            }
        }
        
        /// <remarks/>
        public string MiddleName {
            get {
                return this.middleNameField;
            }
            set {
                this.middleNameField = value;
            }
        }
        
        /// <remarks/>
        public string PayerBusiness {
            get {
                return this.payerBusinessField;
            }
            set {
                this.payerBusinessField = value;
            }
        }
        
        /// <remarks/>
        public string PayerCountry {
            get {
                return this.payerCountryField;
            }
            set {
                this.payerCountryField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementDescription {
            get {
                return this.billingAgreementDescriptionField;
            }
            set {
                this.billingAgreementDescriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PayPalPayinInfo {
        
        private BillingAgreementDetails billingAgreementDetailsField;
        
        /// <remarks/>
        public BillingAgreementDetails BillingAgreementDetails {
            get {
                return this.billingAgreementDetailsField;
            }
            set {
                this.billingAgreementDetailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class WholesaleInfo {
        
        private string accountHolderNameField;
        
        private string externalReferenceIdField;
        
        private string wholesalePartnerField;
        
        private string encryptedPasswordField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public string WholesalePartner {
            get {
                return this.wholesalePartnerField;
            }
            set {
                this.wholesalePartnerField = value;
            }
        }
        
        /// <remarks/>
        public string EncryptedPassword {
            get {
                return this.encryptedPasswordField;
            }
            set {
                this.encryptedPasswordField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class DirectDebitInfo {
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string bankCodeField;
        
        private string branchCodeField;
        
        private string checkDigitsField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string BankCode {
            get {
                return this.bankCodeField;
            }
            set {
                this.bankCodeField = value;
            }
        }
        
        /// <remarks/>
        public string BranchCode {
            get {
                return this.branchCodeField;
            }
            set {
                this.branchCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CheckDigits {
            get {
                return this.checkDigitsField;
            }
            set {
                this.checkDigitsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CreditCardInfo {
        
        private byte cardTypeField;
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string ccvNumberField;
        
        private System.DateTime expirationDateField;
        
        /// <remarks/>
        public byte CardType {
            get {
                return this.cardTypeField;
            }
            set {
                this.cardTypeField = value;
            }
        }
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string CcvNumber {
            get {
                return this.ccvNumberField;
            }
            set {
                this.ccvNumberField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ExpirationDate {
            get {
                return this.expirationDateField;
            }
            set {
                this.expirationDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PhoneInfo {
        
        private string phonePrefixField;
        
        private string phoneNumberField;
        
        private string phoneExtensionField;
        
        /// <remarks/>
        public string PhonePrefix {
            get {
                return this.phonePrefixField;
            }
            set {
                this.phonePrefixField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneNumber {
            get {
                return this.phoneNumberField;
            }
            set {
                this.phoneNumberField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneExtension {
            get {
                return this.phoneExtensionField;
            }
            set {
                this.phoneExtensionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddressInfo {
        
        private string street1Field;
        
        private string street2Field;
        
        private string cityField;
        
        private string districtField;
        
        private string stateField;
        
        private string postalCodeField;
        
        /// <remarks/>
        public string Street1 {
            get {
                return this.street1Field;
            }
            set {
                this.street1Field = value;
            }
        }
        
        /// <remarks/>
        public string Street2 {
            get {
                return this.street2Field;
            }
            set {
                this.street2Field = value;
            }
        }
        
        /// <remarks/>
        public string City {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string District {
            get {
                return this.districtField;
            }
            set {
                this.districtField = value;
            }
        }
        
        /// <remarks/>
        public string State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PaymentInstrumentInfo {
        
        private string paymentInstrumentIdField;
        
        private byte paymentInstrumentTypeField;
        
        private AddressInfo addressInfoField;
        
        private PhoneInfo phoneInfoField;
        
        private CreditCardInfo creditCardInfoField;
        
        private DirectDebitInfo directDebitInfoField;
        
        private WholesaleInfo wholesaleInfoField;
        
        private PayPalPayinInfo payPalPayinInfoField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
        
        /// <remarks/>
        public byte PaymentInstrumentType {
            get {
                return this.paymentInstrumentTypeField;
            }
            set {
                this.paymentInstrumentTypeField = value;
            }
        }
        
        /// <remarks/>
        public AddressInfo AddressInfo {
            get {
                return this.addressInfoField;
            }
            set {
                this.addressInfoField = value;
            }
        }
        
        /// <remarks/>
        public PhoneInfo PhoneInfo {
            get {
                return this.phoneInfoField;
            }
            set {
                this.phoneInfoField = value;
            }
        }
        
        /// <remarks/>
        public CreditCardInfo CreditCardInfo {
            get {
                return this.creditCardInfoField;
            }
            set {
                this.creditCardInfoField = value;
            }
        }
        
        /// <remarks/>
        public DirectDebitInfo DirectDebitInfo {
            get {
                return this.directDebitInfoField;
            }
            set {
                this.directDebitInfoField = value;
            }
        }
        
        /// <remarks/>
        public WholesaleInfo WholesaleInfo {
            get {
                return this.wholesaleInfoField;
            }
            set {
                this.wholesaleInfoField = value;
            }
        }
        
        /// <remarks/>
        public PayPalPayinInfo PayPalPayinInfo {
            get {
                return this.payPalPayinInfoField;
            }
            set {
                this.payPalPayinInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPaymentInstrumentResults {
        
        private PaymentInstrumentInfo[] paymentInstrumentInfosField;
        
        /// <remarks/>
        public PaymentInstrumentInfo[] PaymentInstrumentInfos {
            get {
                return this.paymentInstrumentInfosField;
            }
            set {
                this.paymentInstrumentInfosField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionDetails {
        
        private byte[] sessionKeyField;
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SessionKey {
            get {
                return this.sessionKeyField;
            }
            set {
                this.sessionKeyField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionDetails {
        
        private ulong xboxOfferIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private string musicNetSkuField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalXboxOfferIdField;
        
        /// <remarks/>
        public ulong XboxOfferId {
            get {
                return this.xboxOfferIdField;
            }
            set {
                this.xboxOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetSku {
            get {
                return this.musicNetSkuField;
            }
            set {
                this.musicNetSkuField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalXboxOfferId {
            get {
                return this.renewalXboxOfferIdField;
            }
            set {
                this.renewalXboxOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountDetails {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string postalCodeField;
        
        private string countryCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorDetails {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool subscriptionLapsedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool SubscriptionLapsed {
            get {
                return this.subscriptionLapsedField;
            }
            set {
                this.subscriptionLapsedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults {
        
        private ErrorDetails errorInfoField;
        
        private AccountDetails accountInfoField;
        
        private SubscriptionDetails subscriptionInfoField;
        
        private SessionDetails sessionInfoField;
        
        /// <remarks/>
        public ErrorDetails ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountDetails AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        public SubscriptionDetails SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionDetails SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults {
        
        private int pointsBalanceField;
        
        private bool aboveLowBalanceField;
        
        private byte dmpAccountStatusField;
        
        /// <remarks/>
        public int PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool AboveLowBalance {
            get {
                return this.aboveLowBalanceField;
            }
            set {
                this.aboveLowBalanceField = value;
            }
        }
        
        /// <remarks/>
        public byte DmpAccountStatus {
            get {
                return this.dmpAccountStatusField;
            }
            set {
                this.dmpAccountStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum GamertagSuggestionType {
        
        /// <remarks/>
        NounAdjectiveSuggestion,
        
        /// <remarks/>
        SeedSuggestion,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AcceptTermsOfServiceCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCreditCardCompletedEventHandler(object sender, AddCreditCardCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCreditCardCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCreditCardCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AddCreditCardResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AddCreditCardResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPointsBalanceCompletedEventHandler(object sender, GetPointsBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPointsBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPointsBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPointsBalanceResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPointsBalanceResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SignInCompletedEventHandler(object sender, SignInCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignInCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SignInCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SignInResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SignInResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateMobileAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GenerateGamertagCompletedEventHandler(object sender, GenerateGamertagCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GenerateGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GenerateGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((str