, 0, 0);
            mach.ClientFlashVersion="1.2.3.4";
            mach.ClientFlashVersionChangedDate=System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0);
            mach.ClientFlashUpdateVersion="5.6.7.8";
            mach.ClientFlashUpdateVersionChangedDate=System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0);

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[]{MakeMachineInfo(mach.Id)}, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Does a lookup on a single machine with all dates possible as null.")]
        public void DatesNull()
        {
            //create machine
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            mach.CreationDate=null;
            mach.ClientFlashVersion="";
            mach.ClientFlashVersionChangedDate=null;
            mach.ClientFlashUpdateVersion="";
            mach.ClientFlashUpdateVersionChangedDate=null;

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[]{MakeMachineInfo(mach.Id)}, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Does a lookup on a single machine with all dates possible as min value.")]
        public void DatesMin()
        {
            //create machine
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            mach.CreationDate=(System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue;
            mach.ClientFlashVersion="0.0.0.0";
            mach.ClientFlashVersionChangedDate=(System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue;
            mach.ClientFlashUpdateVersion="0.0.0.0";
            mach.ClientFlashUpdateVersionChangedDate=(System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue;

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[]{MakeMachineInfo(mach.Id)}, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Does a lookup on a single machine with all dates possible as max value.")]
        public void DatesMax()
        {
            //create machine
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            mach.CreationDate=System.DateTime.MaxValue;
            mach.ClientFlashVersion="15.15.65535.255";
            mach.ClientFlashVersionChangedDate=System.DateTime.MaxValue;
            mach.ClientFlashUpdateVersion="15.15.65535.255";
            mach.ClientFlashUpdateVersionChangedDate=System.DateTime.MaxValue;

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[]{MakeMachineInfo(mach.Id)}, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Run on the max supported number of puids.")]
        public void MaxValid()
        {
            //create machines
            int maxValidCount=100;
            ulong []puids=new ulong[maxValidCount];
            MachineInfo []expectedRet=new MachineInfo[maxValidCount];
            Global.RO.Debug("Creating "+maxValidCount+" machines...");
            for (int i=0; i<maxValidCount; ++i)
            {
                puids[i]=MachineEditor.CreateNew().Id;
                expectedRet[i]=MakeMachineInfo(puids[i]);
            }

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(puids);
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Attempt to lookup more machines than the API can handle at once.")]
        public void LookupTooMany()
        {
            //create machines
            List<ulong> puids=new List<ulong>();

            Global.RO.Debug("Creating 500 machines...");
            for (int i=0; i<500; ++i)
            {
                puids.Add(MachineEditor.CreateNew().Id);
            }

            //call the api and verify the return
            XMachineTestUtil.ExecuteCallExpecting404(delegate{LookupMachineInfoByMachinePuidsVerbose(puids.ToArray());});
        }

        [TestCase, Description("Calls lookup on no machines.")]
        public void LookupNone()
        {
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[0]);

            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[0], ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Calls lookup on on puid in the valid range but for a machine that doesn't exist.")]
        public void MachineDoesNotExist()
        {
            //create machine
            ulong puid=0xfa0010108080ffee;

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{puid});

            ValueCheck.TestAllUnordered("MachineInfo Returned", new MachineInfo[0], ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Creates a machine, calls lookup on it along with some invalid ones.")]
        public void MixedValidInvalidPlatform()
        {
            //create machine
            ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
            ulong []puids=new ulong[]{0x12345, validPuid, 0xffffffedcba98765};

            //call the api and verify the return
            //NOTE: This behavior is NOT consistant with the Lookup*Ban* APIs which fail with "Invalid platform type".  The server APIs should be changed to be consistant sometime...
            //XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachineInfoByMachinePuidsVerbose(puids);}, "Invalid platform type");

            //NOTE: Until this is fixed, it treats it like a normal invalid puid
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(puids);

            MachineInfo []expectedRet=new MachineInfo[]{MakeMachineInfo(validPuid)};
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Creates a machine, calls lookup on it along with some invalid ones.")]
        public void MixedValidInvalidPuids()
        {
            //create machine
            ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
            ulong []puids=new ulong[]{0xfa00ffedcba98764, validPuid, 0xfa00ffedcba98765};

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(puids);

            MachineInfo []expectedRet=new MachineInfo[]{MakeMachineInfo(validPuid)};
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Pass null for the machine puids paramater.")]
        public void NullPuidsParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachineInfoByMachinePuidsVerbose((Puid[])null);}, "Null array");
        }

        [TestCase, Description("Creates a couple machines, calls lookup with duplicate puids.")]
        public void DuplicatePuidsInParameter()
        {
            //create machine
            ulong validPuid0=XMachineTestUtil.CreateXbox360Machine();
            ulong validPuid1=XMachineTestUtil.CreateXbox360Machine();
            ulong []puids=new ulong[]{validPuid0, validPuid0, validPuid1};

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(puids);

            MachineInfo []expectedRet=new MachineInfo[]{MakeMachineInfo(validPuid0), MakeMachineInfo(validPuid1)};
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Lookup an old-style xbox360 machine that has not yet been migrated to the new name lookup table.")]
        public void LegacyMachine()
        {
            //create machine
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            //call the api and verify the return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{mach.Id});

            MachineInfo []expectedRet=new MachineInfo[]{MakeMachineInfo(mach.Id)};
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }

        [TestCase, Description("Creates two consoles that share the same console id, calls lookup on the puids for both.")]
        public void DuplicateConsole()
        {
            //create machines
            MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

            //call api and verify return
            MachineInfo []ret=LookupMachineInfoByMachinePuidsVerbose(new ulong[]{machA.Id, machB.Id});

            MachineInfo []expectedRet=new MachineInfo[]{MakeMachineInfo(machA.Id), MakeMachineInfo(machB.Id)};
            ValueCheck.TestAllUnordered("MachineInfo Returned", expectedRet, ret, MachineInfoEquals, MachineInfoStringer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupUserHistoryByMachinePuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupUserHistoryByMachinePuid: TestNode
    {
        public static UserMachineHistoryDetails[] LookupUserHistoryByMachinePuidVerbose(Puid machinePuid, System.DateTime ?sinceLastSignin)
        {
            Global.RO.Debug("Calling LookupUserHistoryByMachinePuid: MachinePuid="+machinePuid+", SinceLastSignin="+sinceLastSignin);
            UserMachineHistoryDetails []ret=new XMachineSoapClient().LookupUserHistoryByMachinePuid((ulong)machinePuid, sinceLastSignin);
            Global.RO.Debug("LookupUserHistoryByMachinePuid returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", HistoryCommon.UserMachineHistoryDetailsStringer));
            return ret;
        }

        public static void ComputeAndVerifyUserMachineHistoryDetails(Puid machinePuid, System.DateTime ?sinceLastSignin, UserMachineHistoryDetails []gottenResults)
        {
            //lookup the actual rows in the db and convert them into a UserMachineHistoryDetails that contains the expected result
            UserMachineHistoryEditor []allHistories=UserMachineHistoryEditor.FromMachineId(machinePuid);
            List<UserMachineHistoryDetails> expectedResults=new List<UserMachineHistoryDetails>();
            foreach (UserMachineHistoryEditor entry in allHistories)
            {
                if (sinceLastSignin==null || (entry.LastSignin!=null ? entry.LastSignin>=sinceLastSignin : entry.LastSeen>=sinceLastSignin))
                {
                    UserMachineHistoryDetails newExpected=new UserMachineHistoryDetails();
                    newExpected.MachinePuid=machinePuid;
                    newExpected.UserPuid=entry.UserPuid;
                    newExpected.IpAddress=entry.IPAddress;
                    newExpected.FirstSignin=(entry.FirstSignin!=null ? (System.DateTime)entry.FirstSignin : (System.DateTime)entry.FirstSeen);
                    newExpected.LastSignin=(entry.LastSignin!=null ? (System.DateTime)entry.LastSignin : (System.DateTime)entry.LastSeen);
                    newExpected.LastSignout=(entry.LastSignout!=null ? (System.DateTime)entry.LastSignout : (System.DateTime)entry.LastSeen);
                    newExpected.DaysSeen=entry.DaysSeen;
                    newExpected.FriendlyName=entry.FriendlyName;
                    newExpected.TrustLevel=entry.TrustLevel;
                    expectedResults.Add(newExpected);
                }
            }

            //Verify
            HistoryCommon.VerifyUserMachineHistoryDetails(expectedResults.ToArray(), gottenResults);
        }

        public static void CallAndVerify(Puid machinePuid, System.DateTime ?since)
        {
            UserMachineHistoryDetails []ret=LookupUserHistoryByMachinePuidVerbose(machinePuid, since);
            ComputeAndVerifyUserMachineHistoryDetails(machinePuid, since, ret);
        }

        public static UserMachineHistoryEditor GenerateHistoryLog(ulong machinePuid, ulong userPuid, string ip, int daysSeen, string friendlyName, int trustLevel, System.DateTime ?deprecatedFirstSeen, System.DateTime ?deprecatedLastSeen, System.DateTime ?firstSignin, System.DateTime ?lastSignin, System.DateTime ?lastSignout)
        {
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(userPuid, machinePuid);
            umh.IPAddress=ip;
            umh.DaysSeen=daysSeen;
            umh.FriendlyName=friendlyName;
            umh.TrustLevel=trustLevel;
            umh.FirstSeen=(deprecatedFirstSeen!=null?(System.DateTime)deprecatedFirstSeen:System.DateTime.Parse("2006-01-01")); //column is not nullable, null for these just means use an old date as default
            umh.LastSeen=(deprecatedLastSeen!=null?(System.DateTime)deprecatedLastSeen:System.DateTime.Parse("2006-02-02")); //column is not nullable, null for these just means use an old date as default
            umh.FirstSignin=firstSignin;
            umh.LastSignin=lastSignin;
            umh.LastSignout=lastSignout;
            return umh;
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoDate",          null)]
        [CompoundCase("WithEarlierDate", -1)]
        [CompoundCase("WithLaterDate",   +1)]
        public void SimpleOneRow(TestNode self)
        {
            int ?dateOffset=(self.MyValues[0]==null?(int?)null:(int?)(int)self.MyValues[0]);

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            System.DateTime now=System.DateTime.UtcNow;
            GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, null, null, now, null);

            System.DateTime ?sinceDate=(dateOffset==null?(System.DateTime?)null:now+new System.TimeSpan(0, (int)dateOffset, 0));
            CallAndVerify(mach.Id, sinceDate);
        }

        [TestCase, Description("Three simple rows are placed in the database with different dates.")]
        [CompoundCase("WithDate HitNone",  2019)]
        [CompoundCase("WithDate HitOne",   2017)]
        [CompoundCase("WithDate HitTwo",   2015)]
        [CompoundCase("WithDate HitThree", 2013)]
        [CompoundCase("WithDate HitFour",  2011)]
        [CompoundCase("NoDate HitFour",    null)]
        public void FourRowsDifferentLastSigninDates(TestNode self)
        {
            int ?yearToPass=(self.MyValues[0]==null?(int?)null:(int?)(int)self.MyValues[0]);

            UserEditor userA=UserEditor.CreateNew();
            UserEditor userB=UserEditor.CreateNew();
            UserEditor userC=UserEditor.CreateNew();
            UserEditor userD=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            GenerateHistoryLog(mach.Id, userA.Puid, "1.2.3.1", 9, "BigBox", 1,  null, System.DateTime.Parse("2012-01-01"), null, null,                                null);
            GenerateHistoryLog(mach.Id, userB.Puid, "1.2.3.2", 8, "BigBox", -1, null, System.DateTime.Parse("2014-01-01"), null, null,                                null);
            GenerateHistoryLog(mach.Id, userC.Puid, "1.2.3.3", 7, "FunBox", 0,  null, System.DateTime.Parse("2014-01-01"), null, System.DateTime.Parse("2016-01-01"), null);
            GenerateHistoryLog(mach.Id, userD.Puid, "1.2.3.4", 6, "HitBox", 1,  null, System.DateTime.Parse("2014-01-01"), null, System.DateTime.Parse("2018-01-01"), null);

            System.DateTime ?sinceDate=(yearToPass!=null?(System.DateTime?)new System.DateTime((int)yearToPass, 1, 1):(System.DateTime?)null);
            CallAndVerify(mach.Id, sinceDate);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoDate",       false)]
        [CompoundCase("WithDate",     true)]
        public void NoRows(TestNode self)
        {
            bool passDate=(bool)self.MyValues[0];

            MachineEditor mach=MachineEditor.CreateNew();

            System.DateTime ?sinceDate=(passDate?(System.DateTime?)System.DateTime.UtcNow:(System.DateTime?)null);
            CallAndVerify(mach.Id, sinceDate);
        }

        [TestGroup]
        public class VariousValuesInDB: TestNode
        {
            //User puids have a foreign key constraint in UODB for the table this API hits.

            [TestCase, Description("Various machine puids.")]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xffed000000000000)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void MachinePuid(TestNode self)
            {
                ulong machinePuid=(ulong)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();

                GenerateHistoryLog(machinePuid, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, null, null, null, null);

                CallAndVerify(machinePuid, null);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                string ipAddress=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                GenerateHistoryLog(mach.Id, user.Puid, ipAddress, 3, "FunBox", 1, null, null, null, null, null);

                CallAndVerify(mach.Id, null);
            }

            [TestCase, Description("Various days seen.")]
            [CompoundCase("{0}", 0)]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", -1)]
            [CompoundCase("{0}", 255)]
            [CompoundCase("{0}", 65535)]
            [CompoundCase("{0}", int.MaxValue)]
            [CompoundCase("{0}", int.MinValue)]
            public void DaysSeen(TestNode self)
            {
                int daysSeen=(int)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", daysSeen, "FunBox", 1, null, null, null, null, null);

                CallAndVerify(mach.Id, null);
            }

            [TestCase, Description("Various friendly names.")]
            [CompoundCase("null",        null)]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("1Char",       "X")]
            [CompoundCase("Normal",      "Bob's Machine")]
            [CompoundCase("WeirdChars",  "!@#$%^&*(){}`~[ ]=+/?-_;:|\\")]
            [CompoundCase("MaxLength", "M234567890123456789012345678901234567890123456789012345678901234")]
            public void FriendlyName(TestNode self)
            {
                string friendlyName=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, friendlyName, 1, null, null, null, null, null);

                CallAndVerify(mach.Id, null);
            }

            [TestCase, Description("Various trust levels.")]
            [CompoundCase("{0}", 0)]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", -1)]
            [CompoundCase("{0}", 255)]
            [CompoundCase("{0}", 65535)]
            [CompoundCase("{0}", int.MaxValue)]
            [CompoundCase("{0}", int.MinValue)]
            public void TrustLevel(TestNode self)
            {
                int trustLevel=(int)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", trustLevel, null, null, null, null, null);

                CallAndVerify(mach.Id, null);
            }

            [TestCase, Description("Various values for the deprecated first seen column with the newer date columns all null.")]
            public class FirstSeen: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    instances.Add(new CompoundCaseAttribute("MaxSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MaxValue));
                    instances.Add(new CompoundCaseAttribute("MinSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue));
                    instances.Add(new CompoundCaseAttribute("CurrentDateTime", System.DateTime.UtcNow));
                }

                public override void Run()
                {
                    System.DateTime timestamp=(System.DateTime)MyValues[0];

                    UserEditor user=UserEditor.CreateNew();
                    MachineEditor mach=MachineEditor.CreateNew();

                    GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, timestamp, null, null, null, null);

                    CallAndVerify(mach.Id, null);
                }
            }

            [TestCase, Description("Various values for the deprecated last seen column with the newer date columns all null.")]
            public class LastSeen: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    instances.Add(new CompoundCaseAttribute("MaxSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MaxValue));
                    instances.Add(new CompoundCaseAttribute("MinSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue));
                    instances.Add(new CompoundCaseAttribute("CurrentDateTime", System.DateTime.UtcNow));
                }

                public override void Run()
                {
                    System.DateTime timestamp=(System.DateTime)MyValues[0];

                    UserEditor user=UserEditor.CreateNew();
                    MachineEditor mach=MachineEditor.CreateNew();

                    GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, timestamp, null, null, null);

                    CallAndVerify(mach.Id, null);
                }
            }

            [TestCase, Description("Various values for the first signin column.")]
            public class FirstSignin: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    instances.Add(new CompoundCaseAttribute("MaxSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MaxValue));
                    instances.Add(new CompoundCaseAttribute("MinSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue));
                    instances.Add(new CompoundCaseAttribute("CurrentDateTime", System.DateTime.UtcNow));
                }

                public override void Run()
                {
                    System.DateTime timestamp=(System.DateTime)MyValues[0];

                    UserEditor user=UserEditor.CreateNew();
                    MachineEditor mach=MachineEditor.CreateNew();

                    GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, null, timestamp, null, null);

                    CallAndVerify(mach.Id, null);
                }
            }

            [TestCase, Description("Various values for the last signin column.")]
            public class LastSignin: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    instances.Add(new CompoundCaseAttribute("MaxSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MaxValue));
                    instances.Add(new CompoundCaseAttribute("MinSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue));
                    instances.Add(new CompoundCaseAttribute("CurrentDateTime", System.DateTime.UtcNow));
                }

                public override void Run()
                {
                    System.DateTime timestamp=(System.DateTime)MyValues[0];

                    UserEditor user=UserEditor.CreateNew();
                    MachineEditor mach=MachineEditor.CreateNew();

                    GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, null, null, timestamp, null);

                    CallAndVerify(mach.Id, null);
                }
            }

            [TestCase, Description("Various values for the last signout column.")]
            public class LastSignout: TestNode
            {
                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    instances.Add(new CompoundCaseAttribute("MaxSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MaxValue));
                    instances.Add(new CompoundCaseAttribute("MinSqlDateTime", (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue));
                    instances.Add(new CompoundCaseAttribute("CurrentDateTime", System.DateTime.UtcNow));
                }

                public override void Run()
                {
                    System.DateTime timestamp=(System.DateTime)MyValues[0];

                    UserEditor user=UserEditor.CreateNew();
                    MachineEditor mach=MachineEditor.CreateNew();

                    GenerateHistoryLog(mach.Id, user.Puid, "1.2.3.4", 3, "FunBox", 1, null, null, null, null, timestamp);

                    CallAndVerify(mach.Id, null);
                }
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            MachineEditor mach=MachineEditor.CreateNew();

            for (int i=0; i<1000; ++i)
            {
                UserEditor user=UserEditor.CreateNew();
                UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            }

            CallAndVerify(mach.Id, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupRecoveryHistoryByMachinePuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupRecoveryHistoryByMachinePuid: DoubleWriteTestGroup
    {
        public static RecoveryHistory LookupRecoveryHistoryByMachinePuidVerbose(Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            Global.RO.Debug("Calling LookupRecoveryHistoryByMachinePuid: MachinePuid="+machinePuid+", UserPuid="+userPuid+", Since="+since+", Details="+details);
            RecoveryHistory ret=new XMachineSoapClient().LookupRecoveryHistoryByMachinePuid((ulong)machinePuid, (ulong?)userPuid, since, details);
            Global.RO.Debug("LookupRecoveryHistoryByMachinePuid returned: "+HistoryCommon.RecoveryHistoryStringer(ret));
            return ret;
        }

        public static void ComputeAndVerifyRecoveryHistory(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, RecoveryHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a RecoveryHistory that contains the expected result
            RecoveryHistory expectedResult=new RecoveryHistory();

            MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry []allHistories=MachineRecoveryHistoryEditor.FromMachinePuid(machinePuid, isSecMHDB).GetAllHistory();
            HashSet<ulong> uniqueUsers=new HashSet<ulong>();
            int totalEntries=0;
            System.DateTime ?first=null;
            System.DateTime ?last=null;
            List<RecoveryHistoryDetails> detailsExpectedInResult=new List<RecoveryHistoryDetails>();
            foreach (MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry entry in allHistories)
            {
                if (since==null || entry.TimeStamp>=since)
                {
                    if (userPuid==null || userPuid==entry.UserPuid)
                    {
                        ++totalEntries;

                        if (first==null || first>entry.TimeStamp)
                        {
                            first=entry.TimeStamp;
                        }

                        if (last==null || last<entry.TimeStamp)
                        {
                            last=entry.TimeStamp;
                        }

                        if (!uniqueUsers.Contains(entry.UserPuid))
                        {
                            uniqueUsers.Add(entry.UserPuid);
                        }

                        if (details)
                        {
                            RecoveryHistoryDetails detail=new RecoveryHistoryDetails();
                            detail.MachinePuid=machinePuid;
                            detail.UserPuid=entry.UserPuid;
                            detail.IpAddress=entry.IpAddress;
                            detail.Timestamp=entry.TimeStamp;
                            detail.HResult=entry.Hr;
                            detail.Reason=entry.Reason;
                            detail.PassportPuid=entry.PassportPuid;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total=totalEntries;
            expectedResult.Unique=uniqueUsers.Count;
            expectedResult.First=first;
            expectedResult.Last=last;
            expectedResult.Details=detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details=null;
            }

            //Verify
            HistoryCommon.VerifyRecoveryHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            RecoveryHistory ret=LookupRecoveryHistoryByMachinePuidVerbose(machinePuid, userPuid, since, details);
            ComputeAndVerifyRecoveryHistory(machinePuid, userPuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithUserPuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoUserPuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 2, 1, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoUserPuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithUserPuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithUserPuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithUserPuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoUserPuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithUserPuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithUserPuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithUserPuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, 3, 1, useSecMHDB));
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, 4, 2, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",              0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",              1,    null, false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",        0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",        1,    2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",        0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",        1,    4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",            0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",            1,    null, true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",      0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",      1,    2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",      0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",      1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            int ?passUserPuid=(self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor []users=new UserEditor[]{UserEditor.CreateNew(), UserEditor.CreateNew()};
            MachineEditor mach=MachineEditor.CreateNew();

            MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(users[0].Puid, mach.Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, 4, 1, useSecMHDB));
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(users[0].Puid, mach.Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, 5, 2, useSecMHDB));
            mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(users[1].Puid, mach.Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, 6, 3, useSecMHDB));

            ulong ?userPuid=(passUserPuid!=null?users[(int)passUserPuid].Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //Machine puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird user puids.")]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void UserPuids(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                ulong userPuid=(ulong)self.MyValues[0];

                MachineEditor mach=MachineEditor.CreateNew();

                MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(userPuid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 2, 1, useSecMHDB));

                CallAndVerify(mach.Id, userPuid, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                string ipAddress=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, 2, 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                byte reason=(byte)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 5, reason, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird passport puids.")]
            [CompoundCase("MinValue", (ulong)0)]
            [CompoundCase("MaxValue", (ulong)0xffffffffffffffff)]
            public void Passports(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                ulong passports=(ulong)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, passports, 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineRecoveryHistoryEditor mghe=MachineRecoveryHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            for (int i=0; i<1000; ++i)
            {
                mghe.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, (ulong)i, (byte)(i%10+1), useSecMHDB));
            }

            CallAndVerify(mach.Id, null, null, true, useSecMHDB);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\TestConnection.cs ===
using System;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests the connection to XMachine by echoing a string back. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class TestConnection: TestNode
    {
        public static string TestConnectionVerbose(string inputMessage)
        {
            Global.RO.Debug("Calling TestConnection: InputMessage="+inputMessage);
            string ret=new XMachineSoapClient().TestConnection(inputMessage);
            Global.RO.Debug("TestConnection returned: "+ret);
            return ret;
        }

        // -----

        //Tests
        [TestCase, Description("Simple small string.")]
        public void Simple()
        {
            string ret=TestConnectionVerbose("Rar");
            ValueCheck.Test("TestConnection return", "Rar", ret);
        }

        [TestCase, Description("Long string.")]
        public void Long()
        {
            string s="";
            for (int i=0; i<50; ++i)
            {
                s+="abcdefghijklmnopqrstuvwxyz";
            }

            string ret=TestConnectionVerbose(s);
            ValueCheck.Test("TestConnection return", s, ret);
        }

        [TestCase, Description("Pass in an empty string.")]
        public void EmptyString()
        {
            string ret=TestConnectionVerbose("");
            ValueCheck.Test("TestConnection return", "", ret);
        }

        [TestCase, Description("Pass in null.")]
        public void Null()
        {
            string ret=TestConnectionVerbose(null);
            ValueCheck.Test("TestConnection return", (string)null, ret);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\ResetMachinePasswordByConsoleIds.cs ===
using System;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for ResetMachinePasswordByConsoleIds. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class ResetMachinePasswordByConsoleIds: TestNode
    {
        public static ConsoleIdResult MakeConsoleIdResult(string consoleId, uint result)
        {
            ConsoleIdResult r=new ConsoleIdResult();
            r.ConsoleId = consoleId;
            r.Result    = result;
            return r;
        }

        public static string ConsoleIdResultStringer(ConsoleIdResult result)
        {
            return "ConsoleIdResult(ConsoleId="+result.ConsoleId+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string ConsoleIdResultStringer(object result)
        {
            if (result is ConsoleIdResult)
            {
                return ConsoleIdResultStringer((ConsoleIdResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool ConsoleIdResultEquals(ConsoleIdResult left, ConsoleIdResult right)
        {
            return left.ConsoleId==right.ConsoleId &&
                left.Result==right.Result;
        }

        public static ConsoleIdResult[] ResetMachinePasswordByConsoleIdsVerbose(string []consoleList)
        {
            Global.RO.Debug("Calling ResetMachinePasswordByConsoleIds: ConsoleList={"+StringUtils.MakeCommaSeparatedList(consoleList)+"}");
            ConsoleIdResult[] ret=new XMachineSoapClient().ResetMachinePasswordByConsoleIds(consoleList);
            Global.RO.Debug("ResetMachinePasswordByConsoleIds returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", ConsoleIdResultStringer));
            return ret;
        }

        // -----

        [TestGroup]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Calls reset on one machine."), BVT]
            public void ResetOne()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify return
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(new string[]{mach.ConsoleId});

                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify tgt reset date and actual key reset in db
                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDate, mach.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKey, mach.GetEncryptedKey());
            }

            [TestCase, Description("Calls reset on multiple machine.")]
            [CompoundCase("7", 7)]
            [CompoundCase("Max", 100)]
            public void ResetMultiple(TestNode self)
            {
                int count=(int)self.MyValues[0];

                //create machines and build expectations
                MachineEditor []machs=new MachineEditor[count];
                string []cids=new string[count];
                ConsoleIdResult []expectedRet=new ConsoleIdResult[count];
                System.DateTime []origResetDates=new System.DateTime[count];
                byte [][]origEncryptedKeys=new byte[count][];

                for (int i=0; i<count; ++i)
                {
                    machs[i]=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                    cids[i]=machs[i].ConsoleId;
                    expectedRet[i]=MakeConsoleIdResult(cids[i], 0);
                    origResetDates[i]=machs[i].ResetDate;
                    origEncryptedKeys[i]=machs[i].GetEncryptedKey();
                }

                MachineEditor machNotReset=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDateNotReset=machNotReset.ResetDate;
                byte []origEncryptedKeyNotReset=machNotReset.GetEncryptedKey();

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify return
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(cids);

                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", expectedRet, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify tgt reset date and actual key reset in db
                for (int i=0; i<count; ++i)
                {
                    ValueCheck.TestDifferent("Machine Key Reset Date", origResetDates[i], machs[i].ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                    ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKeys[i], machs[i].GetEncryptedKey());
                }

                ValueCheck.Test("Machine Key Reset Date", origResetDateNotReset, machNotReset.ResetDate, new System.TimeSpan(0, 0, 0, 0, 1));
                ValueCheck.TestAll("Machine Encrypted Key", origEncryptedKeyNotReset, machNotReset.GetEncryptedKey());
            }

            [TestCase, Description("Calls reset on more entries than can be handled.")]
            public void ResetTooMany()
            {
                int count=500;

                //create machines and build expectations
                MachineEditor []machs=new MachineEditor[count];
                string []cids=new string[count];
                System.DateTime []origResetDates=new System.DateTime[count];
                byte [][]origEncryptedKeys=new byte[count][];

                Global.RO.Debug("Creating "+count+" machines...");
                for (int i=0; i<count; ++i)
                {
                    machs[i]=MachineEditor.CreateNew(MachineType.Xbox360);
                    cids[i]=machs[i].ConsoleId;
                    origResetDates[i]=machs[i].ResetDate;
                    origEncryptedKeys[i]=machs[i].GetEncryptedKey();
                }

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify return
                XMachineTestUtil.ExecuteCallExpecting404(delegate{ResetMachinePasswordByConsoleIdsVerbose(cids);});

                //verify tgt reset date and actual key reset in db
                for (int i=0; i<count; ++i)
                {
                    ValueCheck.Test("Machine Key Reset Date", origResetDates[i], machs[i].ResetDate, new System.TimeSpan(0, 0, 0, 0, 1));
                    ValueCheck.TestAll("Machine Encrypted Key", origEncryptedKeys[i], machs[i].GetEncryptedKey());
                }
            }

            [TestCase, Description("Calls reset on a console that doesn't exist machine.")]
            public void ResetConsoleDoesNotExist()
            {
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);


                //call the api and verify return
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(new string[]{cid});

                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid, 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
            }

            [TestCase, Description("Calls reset on no machines.")]
            public void ResetNone()
            {
                //call the api and verify return
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(new string[0]);

                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", new ConsoleIdResult[0], ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
            }

            [TestCase, Description("Calls reset passing null for console ID.")]
            public void ResetNullConsoleIDsParameter()
            {
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{ResetMachinePasswordByConsoleIdsVerbose(null);}, "Null array: consoleIds");
            }

            [TestCase, Description("Valid console IDs, but one entry in array is null.")]
            public void ResetNullConsoleIdInArray()
            {
                //create machine
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate0=mach0.ResetDate;
                byte []origEncryptedKey0=mach0.GetEncryptedKey();

                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate1=mach1.ResetDate;
                byte []origEncryptedKey1=mach1.GetEncryptedKey();

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{ResetMachinePasswordByConsoleIdsVerbose(new string[]{mach0.ConsoleId, null, mach1.ConsoleId});}, "Null element in: consoleIds");

                //verify the db
                ValueCheck.Test("Machine Key Reset Date", origResetDate0, mach0.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestAll("Machine Encrypted Key", origEncryptedKey0, mach0.GetEncryptedKey());

                ValueCheck.Test("Machine Key Reset Date", origResetDate1, mach1.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestAll("Machine Encrypted Key", origEncryptedKey1, mach1.GetEncryptedKey());
            }

            [TestCase, Description("Ban a list of mostly invalid console IDs with one valid one mixed in.")]
            public void InvalidConsoleIDs()
            {
                //create one valid machine and some invalid strings for others
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                string totallyInvalid0="";
                string totallyInvalid1=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(15);
                string totallyInvalid2=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(25);
                string totallyInvalid3="';drop table t_machine_banned_console_id; select '";
                string almostValid0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid0=almostValid0.Substring(0, 14)+(almostValid0[14]=='0'?"9":"0"); // F@$%ing C# doesn't allow this: almostValid0[15]=(almostValid0[15]=='0'?'9':'0');
                string almostValid1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId+"X";
                string almostValid2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid2=almostValid2.Substring(0, 2)+" "+almostValid2.Substring(3,12); //F@$%ing C# doesn't allow this: almostValid2[2]=' ';
                string []cids=new string[]{totallyInvalid0, totallyInvalid1, totallyInvalid2, totallyInvalid3, mach.ConsoleId, almostValid0, almostValid1, almostValid2};

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{ResetMachinePasswordByConsoleIdsVerbose(cids);}, "Invalid ConsoleId");

                //verify the db
                ValueCheck.Test("Machine Key Reset Date", origResetDate, mach.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestAll("Machine Encrypted Key", origEncryptedKey, mach.GetEncryptedKey());
            }

            [TestCase, Description("Reset an old-style xbox360 machine that has not yet been migrated to the new name lookup table.")]
            public void LegacyMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(new string[]{mach.ConsoleId});
                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDate, mach.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKey, mach.GetEncryptedKey());
            }

            [TestCase, Description("Creates two consoles that share the same console id then call reset on the console id, then verifies the tables.")]
            public void ResetDuplicateConsole()
            {
                //create machines
                MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

                System.DateTime origResetDateA=machA.ResetDate;
                byte []origEncryptedKeyA=machA.GetEncryptedKey();

                System.DateTime origResetDateB=machB.ResetDate;
                byte []origEncryptedKeyB=machB.GetEncryptedKey();

                System.Threading.Thread.Sleep(50); //seperate creation time from reset time by a more measurable amount

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=ResetMachinePasswordByConsoleIdsVerbose(new string[]{machA.ConsoleId});
                ValueCheck.TestAllUnordered("ResetMachinePasswordByConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(machA.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB, both should have been reset
                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDateA, machA.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKeyA, machA.GetEncryptedKey());

                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDateB, machB.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKeyB, machB.GetEncryptedKey());
            }
        }; //class Xbox360
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupPcTokensByMachinePuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for LookupPcTokenByMachinePuids. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupPcTokensByMachinePuid: TestNode
    {
        public static PcTokenInfo MakePcTokenInfo(ulong machinePuid, byte []voucherHash)
        {
            PcTokenInfo r=new PcTokenInfo();
            r.MachinePuid=machinePuid;
            r.VoucherHash=voucherHash;
            return r;
        }

        public static string PcTokenInfoStringer(PcTokenInfo result)
        {
            return "PcTokenInfo(MachinePuid="+string.Format("0x{0:X}", result.MachinePuid)+" VoucherHash=0x"+Hexer.tohex(result.VoucherHash)+")";
        }

        public static string PcTokenInfoStringer(object result)
        {
            if (result is PcTokenInfo)
            {
                return PcTokenInfoStringer((PcTokenInfo)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool PcTokenInfoEquals(PcTokenInfo left, PcTokenInfo right)
        {
            if (left.MachinePuid!=right.MachinePuid)
            {
                return false;
            }

            if (left.VoucherHash.Length!=right.VoucherHash.Length)
            {
                return false;
            }

            for (int i=0; i<left.VoucherHash.Length; ++i)
            {
                if (left.VoucherHash[i]!=right.VoucherHash[i])
                {
                    return false;
                }
            }

            return true;
        }

        public static PcTokenInfo[] LookupPcTokensByMachinePuidsVerbose(Puid []machineList)
        {
            Global.RO.Debug("Calling LookupPcTokensByMachinePuids: MachineList={"+StringUtils.MakeCommaSeparatedList(machineList)+"}");
            PcTokenInfo []ret;
            if (machineList!=null)
            {
                ret=new XMachineSoapClient().LookupPcTokensByMachinePuids(System.Array.ConvertAll(machineList, u=>(ulong)(u)));
            }
            else
            {
                ret=new XMachineSoapClient().LookupPcTokensByMachinePuids(null);
            }
            Global.RO.Debug("LookupPcTokensByMachinePuids returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", PcTokenInfoStringer));
            return ret;
        }

        public static PcTokenInfo[] LookupPcTokensByMachinePuidsVerbose(ulong []machineList)
        {
            return LookupPcTokensByMachinePuidsVerbose(System.Array.ConvertAll(machineList, u=>(Puid)(u)));
        }

        // -----

        [TestCase, Description("Does a lookup of one PC machine."), BVT]
        public void OneVoucherHasOneMachine()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{puid});
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[]{MakePcTokenInfo(puid, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Lookup multiple puids at once.")]
        [CompoundCase("7", 7)]
        [CompoundCase("Max", 100)]
        public void LookupMultiple(TestNode self)
        {
            //create vouchers and machines.  we do this directly here because hitting passport for 100 tickets is not desirable.
            int createCount=(int)self.MyValues[0];

            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);

            ulong []puids=new ulong[createCount];
            for (int i=0; i<createCount; ++i)
            {
                if (0==(i&1))
                {
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(voucherA, (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }
                else
                {
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(voucherB, (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }
            }

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(puids);

            PcTokenInfo []expectedRet=new PcTokenInfo[createCount];
            for (int i=0; i<createCount; ++i)
            {
                expectedRet[i]=MakePcTokenInfo(puids[i], (0==(i&1)?voucherHashA:voucherHashB));
            }

            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", expectedRet, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Attempt to lookup more than the API can handle at once.")]
        public void LookupTooMany()
        {
            //create machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();

            List<ulong> puids=new List<ulong>();

            Global.RO.Debug("Creating 500 machines...");
            for (int i=0; i<500; ++i)
            {
                puids.Add(MachineEditor.CreateOrUseExistingPCName(voucher, (ulong)i, MachineEditor.GetCachedPassportId()).Id);
            }

            //call the ban api and verify the return
            XMachineTestUtil.ExecuteCallExpecting404(delegate{LookupPcTokensByMachinePuidsVerbose(puids.ToArray());});
        }

        [TestCase, Description("Does a lookup of nothing.")]
        public void LookupNone()
        {
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[0]);
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[0], ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Voucher has several machines associated with it.")]
        [CompoundCase("Lookup One", 1)]
        [CompoundCase("Lookup All", 3)]
        public void OneVoucherHasSeveralMachines(TestNode self)
        {
            //create one voucher and several machines from it
            int lookupCount=(int)self.MyValues[0];
            const int machineCount=3;

            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                puids[i]=XMachineTestUtil.CreatePCMachine(voucher);
            }

            //call api
            ulong []lookupPuids=new ulong[lookupCount];
            for (int i=0; i<lookupCount; ++i)
            {
                lookupPuids[i]=puids[i];
            }

            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(lookupPuids);

            //verify return
            PcTokenInfo []expectedRet=new PcTokenInfo[lookupCount];
            for (int i=0; i<lookupCount; ++i)
            {
                expectedRet[i]=MakePcTokenInfo(puids[i], voucherHash);
            }

            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", expectedRet, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Several vouchers, mixed number of machines from each voucher.  Lookup several at once")]
        public void SeveralVouchersSeveralMachines()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            string voucherC=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashC=TokendbWS.GetHashForPanoramaVoucher(voucherC);

            ulong puidA0=XMachineTestUtil.CreatePCMachine(voucherA);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);
            ulong puidB1=XMachineTestUtil.CreatePCMachine(voucherB);
            ulong puidC0=XMachineTestUtil.CreatePCMachine(voucherC);
            ulong puidC1=XMachineTestUtil.CreatePCMachine(voucherC);
            ulong puidC2=XMachineTestUtil.CreatePCMachine(voucherC);

            //call api and verify return
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{puidA0, puidB1, puidC0, puidC1});

            PcTokenInfo []expectedRet=new PcTokenInfo[]{
                MakePcTokenInfo(puidA0, voucherHashA),
                MakePcTokenInfo(puidB1, voucherHashB),
                MakePcTokenInfo(puidC0, voucherHashC),
                MakePcTokenInfo(puidC1, voucherHashC)};

            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", expectedRet, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Pass duplicates of some puids to lookup.")]
        public void DuplicatePuidsInParameter()
        {
            //create voucher and machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puidA=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidB=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidC=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{puidA, puidA, puidC, puidB, puidC, puidA});
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[]{MakePcTokenInfo(puidA, voucherHash), MakePcTokenInfo(puidB, voucherHash), MakePcTokenInfo(puidC, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Passes null for the puids parameter.")]
        public void NullParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupPcTokensByMachinePuidsVerbose((Puid[])null);}, "Null array: machinePuids");
        }

        [TestCase, Description("Pass some puids in the right range for a PC but that don't actually exist.")]
        public void NonexistantPuidsInParameter()
        {
            //create voucher and machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puidReal=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidFakeA=0xfb00ffff12345678;
            ulong puidFakeB=0xfb00f00f98765432;

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{puidFakeA, puidReal, puidFakeB});
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[]{MakePcTokenInfo(puidReal, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Pass somepuids in the wrong range for a PC.")]
        public void InvalidPuidsInParameter()
        {
            //create voucher and machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puidReal=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidFakeA=0x0000ffff12345678;
            ulong puidFakeB=0xfffff00f98765432;

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{puidFakeA, puidReal, puidFakeB});
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[]{MakePcTokenInfo(puidReal, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Pass a machine puid from a different platform.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void WrongPlatform(TestNode self)
        {
            //create machine
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.CreateNew(mtype);

            //call api and verify
            PcTokenInfo []ret=LookupPcTokensByMachinePuidsVerbose(new ulong[]{mach.Id});

            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[0], ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\Stress.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class Stress: TestNode
    {
        public class Xbox360MachineInfo
        {
            public ulong MachineId;
            public string ConsoleId;
            public byte []SecondaryIdentifier;
        };

        public static TimedQueue<Xbox360MachineInfo> xbox360MachineCache;

        public static Xbox360MachineInfo GetCachedOrCreateXbox360()
        {
            Xbox360MachineInfo minfo=xbox360MachineCache.PopFront();
            if (minfo==null)
            {
                MachineEditor medit=MachineEditor.CreateNew(MachineType.Xbox360);

                minfo=new Xbox360MachineInfo();
                minfo.MachineId=medit.Id;
                minfo.ConsoleId=medit.ConsoleId;
                minfo.SecondaryIdentifier=medit.CertHash;
                return minfo;
            }

            return minfo;
        }

        // -

        public class PCMachineInfo
        {
            public ulong MachineId;
            public byte []VoucherHash;
            public ulong PcId;
        };

        public static TimedQueue<PCMachineInfo> pcMachineCache;

        public static PCMachineInfo GetCachedOrCreatePC()
        {
            PCMachineInfo minfo=pcMachineCache.PopFront();
            if (minfo==null)
            {
                string voucher=TokendbWS.CreatePanoramaVoucher(-1);
                ulong pcId=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
                MachineEditor medit=MachineEditor.CreateOrUseExistingPCName(voucher, pcId, pcId);

                minfo=new PCMachineInfo();
                minfo.MachineId=medit.Id;
                minfo.VoucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                minfo.PcId=pcId;
                return minfo;
            }

            return minfo;
        }

        // -

        public class PhoneMachineInfo
        {
            public ulong MachineId;
        };

        public static TimedQueue<PhoneMachineInfo> phoneMachineCache;

        public static PhoneMachineInfo GetCachedOrCreatePhone()
        {
            PhoneMachineInfo minfo=phoneMachineCache.PopFront();
            if (minfo==null)
            {
                MachineEditor medit=MachineEditor.CreateNew(MachineType.Phone);

                minfo=new PhoneMachineInfo();
                minfo.MachineId=medit.Id;
                return minfo;
            }

            return minfo;
        }

        // -

        public class UserInfo
        {
            public ulong UserId;
            public string Gamertag;
        };

        public static TimedQueue<UserInfo> userCache;

        public static UserInfo GetCachedOrCreateUser()
        {
            UserInfo uinfo=userCache.PopFront();
            if (uinfo==null)
            {
                UserEditor uedit=UserEditor.CreateNew();

                uinfo=new UserInfo();
                uinfo.UserId=uedit.Puid;
                uinfo.Gamertag=uedit.Gamertag;

                //let's make all users be seen on one machine in the past
                Xbox360MachineInfo mach=GetCachedOrCreateXbox360();
                UserMachineHistoryEditor hist=UserMachineHistoryEditor.CreateOrUseExisting(uinfo.UserId, mach.MachineId);
                hist.FirstSeen=DateTime.UtcNow;
                hist.LastSeen=DateTime.UtcNow;
                xbox360MachineCache.PushBack(mach);

                return uinfo;
            }

            return uinfo;
        }

        // -

        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        // -----

        public override void PreRun()
        {
            if (xbox360MachineCache==null)
            {
                xbox360MachineCache=new TimedQueue<Xbox360MachineInfo>();
                xbox360MachineCache.MinimumReuseTime=new TimeSpan(0,0,0,1,0); //a machine may not be used more than once every 1 second.  This is arbitrary just to cause us to use a larger pool of machines so that there are fewer cache hits.
            }

            if (pcMachineCache==null)
            {
                pcMachineCache=new TimedQueue<PCMachineInfo>();
                pcMachineCache.MinimumReuseTime=new TimeSpan(0,0,0,0,250); //a machine may not be used more than once every 250ms.  This is arbitrary just to cause us to use a larger pool of machines so that there are fewer cache hits.
            }

            if (phoneMachineCache==null)
            {
                phoneMachineCache=new TimedQueue<PhoneMachineInfo>();
                phoneMachineCache.MinimumReuseTime=new TimeSpan(0,0,0,0,500); //a machine may not be used more than once every 500ms.  This is arbitrary just to cause us to use a larger pool of machines so that there are fewer cache hits.
            }

            if (userCache==null)
            {
                userCache=new TimedQueue<UserInfo>();
                userCache.MinimumReuseTime=new TimeSpan(0,0,0,1,0); //a user may not be used more than once every 1 second.  This is arbitrary just to cause us to use a larger pool of users so that there are fewer cache hits.
            }
        }

        // -----

        [StressTest, Description("Spits out the status of the caches.")]
        public void PrintStatus()
        {
            Global.RO.Debug("xbox360MachineCache.Count: "+xbox360MachineCache.Count);
            Global.RO.Debug("pcMachineCache.Count: "+pcMachineCache.Count);
            Global.RO.Debug("phoneMachineCache.Count: "+phoneMachineCache.Count);
            Global.RO.Debug("userCache.Count: "+userCache.Count);
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void BanConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            ConsoleIdResult []ret=new XMachineSoapClient().BanConsoleIds(cids, banReason, System.DateTime.UtcNow);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (ConsoleIdResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Banning console ID "+r.ConsoleId+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void BanMachinePuids_Xbox360(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            MachinePuidResult []ret=new XMachineSoapClient().BanMachinePuids(puids, banReason, System.DateTime.UtcNow, System.DateTime.MaxValue);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Banning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void BanMachinePuids_PC(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            MachinePuidResult []ret=new XMachineSoapClient().BanMachinePuids(puids, 0x8015190D, System.DateTime.UtcNow, System.DateTime.MaxValue);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Banning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void BanMachinePuids_Phone(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PhoneMachineInfo []machines=new PhoneMachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePhone();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            MachinePuidResult []ret=new XMachineSoapClient().BanMachinePuids(puids, banReason, System.DateTime.UtcNow, System.DateTime.MaxValue);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Banning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                phoneMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void BanPcTokens(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            byte [][]voucherHashes=new byte[machineCount][];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                voucherHashes[i]=machines[i].VoucherHash;
            }

            //call the api and verify return
            PcTokenBanResult []ret=new XMachineSoapClient().BanPcTokens(voucherHashes);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (PcTokenBanResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Banning voucher hash "+r.VoucherHash+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupConsoleBansByConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api.  we don't track what's banned and what's not at the moment so no real verification we can do
            ConsoleBanInfo []ret=new XMachineSoapClient().LookupConsoleBansByConsoleIds(cids);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupConsoleBansByMachinePuids(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                puids[i]=machines[i].MachineId;
            }

            //call the api.  we don't track what's banned and what's not at the moment so no real verification we can do
            ConsoleBanInfo []ret=new XMachineSoapClient().LookupConsoleBansByMachinePuids(puids);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupConsoleIdsByMachinePuids(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            MachinePuidInfo []ret=new XMachineSoapClient().LookupConsoleIdsByMachinePuids(puids);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        public void LookupMachinePuidByConsoleIdAndXuid()
        {
            //grab machine and user from the cache or create them if the cache ran out
            Xbox360MachineInfo machine=GetCachedOrCreateXbox360();
            UserInfo user=GetCachedOrCreateUser();

            //call the api and verify return
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidByConsoleIdAndXuid(machine.ConsoleId, user.UserId);
            ValueCheck.Test("Returned array length", 1, ret.Length);
            ValueCheck.Test("Machine Puid", machine.MachineId, ret[0].MachinePuid);

            //return the machine and user to the cache if it had no problems
            xbox360MachineCache.PushBack(machine);
            userCache.PushBack(user);
        }

        [StressTest]
        public void LookupMachinePuidsByConsoleIdAndSCode()
        {
            //grab machine from the cache or create them if the cache ran out
            Xbox360MachineInfo machine=GetCachedOrCreateXbox360();
            byte []sCode=XMachineTests.LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryIDSilent(machine.SecondaryIdentifier);

            //call the api and verify return
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidsByConsoleIdAndSCode(machine.ConsoleId, sCode);
            ValueCheck.Test("Returned array length", 1, ret.Length);
            ValueCheck.Test("Machine Puid", machine.MachineId, ret[0].MachinePuid);

            //return the machine to the cache if it had no problems
            xbox360MachineCache.PushBack(machine);
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupMachineBansByConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api.  we don't track what's banned and what's not at the moment so no real verification we can do
            MachineBanInfo []ret=new XMachineSoapClient().LookupMachineBansByConsoleIds(cids);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupMachinePuidsByPcTokens(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            byte [][]voucherHashes=new byte[machineCount][];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                voucherHashes[i]=machines[i].VoucherHash;
            }

            //call the api and verify return
            PcTokenInfo []ret=new XMachineSoapClient().LookupMachinePuidsByPcTokens(voucherHashes);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupPcTokensByMachinePuids(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            PcTokenInfo []ret=new XMachineSoapClient().LookupPcTokensByMachinePuids(puids);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupMachineBansByMachinePuids(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                puids[i]=machines[i].MachineId;
            }

            //call the api.  we don't track what's banned and what's not at the moment so no real verification we can do
            MachineBanInfo []ret=new XMachineSoapClient().LookupMachineBansByMachinePuids(puids);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void LookupMachinePuidsByConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api and verify return
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidsByConsoleIds(cids);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void ResetMachinePasswordByConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api and verify return
            ConsoleIdResult []ret=new XMachineSoapClient().ResetMachinePasswordByConsoleIds(cids);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        public void TestConnection()
        {
            string s="Hello World of Stress.";
            string ret=new XMachineSoapClient().TestConnection(s);
            ValueCheck.Test("TestConnection return", s, ret);
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void UnbanConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            ConsoleIdResult []ret=new XMachineSoapClient().UnbanConsoleIds(cids, banReason);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (ConsoleIdResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Unbanning console ID "+r.ConsoleId+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void UnbanMachinePuids_Xbox360(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            MachinePuidResult []ret=new XMachineSoapClient().UnbanMachinePuids(puids, banReason);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Unbanning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void UnbanMachinePuids_PC(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            MachinePuidResult []ret=new XMachineSoapClient().UnbanMachinePuids(puids, 0x8015190D);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Unbanning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void UnbanMachinePuids_Phone(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PhoneMachineInfo []machines=new PhoneMachineInfo[machineCount];
            ulong []puids=new ulong[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePhone();
                puids[i]=machines[i].MachineId;
            }

            //call the api and verify return
            uint banReason=unchecked((uint)(0x80000000+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%10));
            MachinePuidResult []ret=new XMachineSoapClient().UnbanMachinePuids(puids, banReason);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (MachinePuidResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Unbanning machine ID "+r.MachinePuid+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                phoneMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void UnbanPcTokens(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            PCMachineInfo []machines=new PCMachineInfo[machineCount];
            byte [][]voucherHashes=new byte[machineCount][];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreatePC();
                voucherHashes[i]=machines[i].VoucherHash;
            }

            //call the api and verify return
            PcTokenBanResult []ret=new XMachineSoapClient().UnbanPcTokens(voucherHashes);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (PcTokenBanResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Unbanning voucher hash "+r.VoucherHash+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                pcMachineCache.PushBack(machines[i]);
            }
        }

        [StressTest]
        [CompoundCase("{0}", 1)]
        [CompoundCase("{0}", 100)]
        public void VerifyXbox360ConsoleIds(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            //grab machines from the cache or create them if the cache ran out
            Xbox360MachineInfo []machines=new Xbox360MachineInfo[machineCount];
            string []cids=new string[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machines[i]=GetCachedOrCreateXbox360();
                cids[i]=machines[i].ConsoleId;
            }

            //call the api and verify return
            ConsoleIdResult []ret=new XMachineSoapClient().VerifyXbox360ConsoleIds(cids);
            ValueCheck.Test("Returned array length", machineCount, ret.Length);

            foreach (ConsoleIdResult r in ret)
            {
                if (r.Result!=0)
                {
                    throw new UnexpectedTestResultException("Verifying console ID "+r.ConsoleId+" failed with reason "+r.Result);
                }
            }

            //return the machines to the cache if it had no problems
            for (int i=0; i<machineCount; ++i)
            {
                xbox360MachineCache.PushBack(machines[i]);
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        public class TestNodeWithPrivateXbox360MachineCache: TestNode
        {
            private TimedQueue<Xbox360MachineInfo> machineCache;

            protected Xbox360MachineInfo GetCachedMachine()
            {
                Xbox360MachineInfo minfo=machineCache.PopFront();
                if (minfo==null)
                {
                    minfo=GenerateNewMachine();
                }

                return minfo;
            }

            protected virtual Xbox360MachineInfo GenerateNewMachine()
            {
                MachineEditor medit=MachineEditor.CreateNew(MachineType.Xbox360);
                Xbox360MachineInfo minfo=new Xbox360MachineInfo();
                minfo.MachineId=medit.Id;
                minfo.ConsoleId=medit.ConsoleId;
                minfo.SecondaryIdentifier=medit.CertHash;
                return minfo;
            }

            protected void ReturnToCache(Xbox360MachineInfo minfo)
            {
                machineCache.PushBack(minfo);
            }

            public TestNodeWithPrivateXbox360MachineCache()
            {
                machineCache=new TimedQueue<Xbox360MachineInfo>();
                machineCache.MinimumReuseTime=new TimeSpan(0,0,0,0,100); //a machine may not be used more than once every 100ms.  This is arbitrary just to cause us to use a larger pool of machines so that there are fewer cache hits.
            }
        }

        [StressTest]
        public class LogGamertagHistory: TestNodeWithPrivateXbox360MachineCache
        {
            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                GamertagHistoryDetails ghd=new GamertagHistoryDetails
                {
                    UserPuid=RandomPuid(),
                    MachinePuid=mach.MachineId,
                    IpAddress="255.254.253.252",
                    Timestamp=System.DateTime.UtcNow,
                    HResult=0,
                    Reason=1,
                    OldGamertag="OldStress",
                    NewGamertag="NewStress",
                };

                new XMachineSoapClient().LogGamertagHistory(ghd);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LogPassportHistory: TestNodeWithPrivateXbox360MachineCache
        {
            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                PassportHistoryDetails phd=new PassportHistoryDetails
                {
                    UserPuid=RandomPuid(),
                    MachinePuid=mach.MachineId,
                    IpAddress="254.253.252.251",
                    Timestamp=System.DateTime.UtcNow,
                    HResult=0,
                    Reason=1,
                    OldPassportPuid=RandomPuid(),
                    NewPassportPuid=RandomPuid()
                };

                new XMachineSoapClient().LogPassportHistory(phd);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LogRecoveryHistory: TestNodeWithPrivateXbox360MachineCache
        {
            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                RecoveryHistoryDetails rhd=new RecoveryHistoryDetails
                {
                    UserPuid=RandomPuid(),
                    MachinePuid=mach.MachineId,
                    IpAddress="253.252.251.250",
                    Timestamp=System.DateTime.UtcNow,
                    HResult=0,
                    Reason=1,
                    PassportPuid=RandomPuid()
                };

                new XMachineSoapClient().LogRecoveryHistory(rhd);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LookupGamertagHistoryByMachinePuid: TestNodeWithPrivateXbox360MachineCache
        {
            protected override Xbox360MachineInfo GenerateNewMachine()
            {
                Xbox360MachineInfo mach=base.GenerateNewMachine();

                bool useSecMHDB=!xonline.common.config.Config.GetBoolSetting("xmachine_doubleWriteHistory");
                MachineGamertagHistoryEditor histEdit=MachineGamertagHistoryEditor.FromMachinePuid(mach.MachineId, useSecMHDB);
                histEdit.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, "OldyStressA", "NewyStressB", 1, useSecMHDB));
                histEdit.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, "OldyStressC", "NewyStressD", 1, useSecMHDB));
                histEdit.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, "OldyStressE", "NewyStressF", 1, useSecMHDB));

                return mach;
            }

            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                GamertagHistory ret=new XMachineSoapClient().LookupGamertagHistoryByMachinePuid(mach.MachineId, null, null, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LookupPassportHistoryByMachinePuid: TestNodeWithPrivateXbox360MachineCache
        {
            protected override Xbox360MachineInfo GenerateNewMachine()
            {
                Xbox360MachineInfo mach=base.GenerateNewMachine();

                bool useSecMHDB=!xonline.common.config.Config.GetBoolSetting("xmachine_doubleWriteHistory");
                MachinePassportHistoryEditor histEdit=MachinePassportHistoryEditor.FromMachinePuid(mach.MachineId, useSecMHDB);
                histEdit.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecMHDB));
                histEdit.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecMHDB));
                histEdit.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecMHDB));

                return mach;
            }

            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                PassportHistory ret=new XMachineSoapClient().LookupPassportHistoryByMachinePuid(mach.MachineId, null, null, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LookupRecoveryHistoryByMachinePuid: TestNodeWithPrivateXbox360MachineCache
        {
            protected override Xbox360MachineInfo GenerateNewMachine()
            {
                Xbox360MachineInfo mach=base.GenerateNewMachine();

                bool useSecMHDB=!xonline.common.config.Config.GetBoolSetting("xmachine_doubleWriteHistory");
                MachineRecoveryHistoryEditor histEdit=MachineRecoveryHistoryEditor.FromMachinePuid(mach.MachineId, useSecMHDB);
                histEdit.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, RandomPuid(), 1, useSecMHDB));
                histEdit.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, RandomPuid(), 1, useSecMHDB));
                histEdit.SetHistory(new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry(RandomPuid(), mach.MachineId, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, RandomPuid(), 1, useSecMHDB));

                return mach;
            }

            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                RecoveryHistory ret=new XMachineSoapClient().LookupRecoveryHistoryByMachinePuid(mach.MachineId, null, null, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

        [StressTest]
        public class LookupUserHistoryByMachinePuid: TestNodeWithPrivateXbox360MachineCache
        {
            protected override Xbox360MachineInfo GenerateNewMachine()
            {
                Xbox360MachineInfo mach=base.GenerateNewMachine();

                UserEditor userA=UserEditor.CreateNew();
                UserEditor userB=UserEditor.CreateNew();
                UserEditor userC=UserEditor.CreateNew();

                XMachineTests.LookupUserHistoryByMachinePuid.GenerateHistoryLog(mach.MachineId, userA.Puid, "64.64.64.64", 0, "Sam's Stress Machine",    -1, null, null, null, null, null);
                XMachineTests.LookupUserHistoryByMachinePuid.GenerateHistoryLog(mach.MachineId, userB.Puid, "64.64.64.64", 6, "Ellen's Stress Machine",  0,  null, null, null, null, null);
                XMachineTests.LookupUserHistoryByMachinePuid.GenerateHistoryLog(mach.MachineId, userC.Puid, "64.64.64.64", 9, "Xanadu's Stress Machine", 1,  null, null, null, null, null);

                return mach;
            }

            public override void Run()
            {
                Xbox360MachineInfo mach=GetCachedMachine();

                UserMachineHistoryDetails []ret=new XMachineSoapClient().LookupUserHistoryByMachinePuid(mach.MachineId, null);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Length);

                //return to cache only if it had no problems
                ReturnToCache(mach);
            }
        }

    }; //class Stress
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:13:58 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\VerifyXbox360ConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for the VerifyXbox360ConsoleIds api. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class VerifyXbox360ConsoleIds : TestNode
    {
        public static ConsoleIdResult MakeConsoleIdResult(string consoleId, uint result)
        {
            ConsoleIdResult r=new ConsoleIdResult();
            r.ConsoleId=consoleId;
            r.Result=result;
            return r;
        }

        public static string ConsoleIdResultStringer(ConsoleIdResult result)
        {
            return "ConsoleIdResult(ConsoleId="+result.ConsoleId+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string ConsoleIdResultStringer(object result)
        {
            if (result is ConsoleIdResult)
            {
                return ConsoleIdResultStringer((ConsoleIdResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool ConsoleIdResultEquals(ConsoleIdResult left, ConsoleIdResult right)
        {
            return left.ConsoleId==right.ConsoleId && left.Result==right.Result;
        }

        public static ConsoleIdResult[] VerifyXbox360ConsoleIdsVerbose(string []consoleList)
        {
            Global.RO.Debug("Calling VerifyXbox360ConsoleIds: ConsoleList={"+StringUtils.MakeCommaSeparatedList(consoleList)+"}");
            ConsoleIdResult []ret=new XMachineSoapClient().VerifyXbox360ConsoleIds(consoleList);
            Global.RO.Debug("VerifyXbox360ConsoleIds returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", ConsoleIdResultStringer));
            return ret;
        }

        // -----

        [TestCase, Description("Pass one valid console ID."), BVT]
        public void OneValid()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass one valid console ID explicitely as upper case.")]
        public void OneValidUpperCase()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360).ToUpper();

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass one valid console ID explicitely as lower case.")]
        public void OneValidLowerCase()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360).ToLower();

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a bad prefix.")]
        public void BadPrefix()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid="XX"+cid.Substring(2, 13);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a prefix for a non-xbox360 platform.")]
        [CompoundCase("Xbox1", MachineType.Xbox1)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void PrefixWrongPlatfrom(TestNode self)
        {
            MachineType mt=(MachineType)self.MyValues[0];
            string cid=MachineEditor.GenerateRandomConsoleID(mt);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a without a prefix.")]
        public void NoPrefix()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(2, 13);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a without a seperator.")]
        public void NoSeperator()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(0, 2)+cid.Substring(3, 12);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a without a prefix or seperator.")]
        public void NoPrefixNoSeperator()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(3, 12);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a with an incorrect a seperator.")]
        public void WrongSeperator()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(0, 2)+" "+cid.Substring(3, 12);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix has the wrong checksum digit.")]
        public void BadSuffixChecksum()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(0, 14)+(cid[14]=='0'?"9":"0");

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix is missing.")]
        public void MissingSuffixChecksum()
        {
            string cid="XE.01111111111"; //intentionally, the checksum digit should be 0 here except it's gone from the end

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix is missing.")]
        public void MissingSuffix()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            cid=cid.Substring(0, 3);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix is too short.")]
        public void SuffixTooShort()
        {
            string cid="xe.011114"; //this is picked such that the last digit would be a correct checksum

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix is too long.")]
        public void SuffixTooLong()
        {
            string cid="XE.0111111111111"; //this is picked such that the last digit would be a correct checksum

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Valid except that the suffix has bad characters in it.")]
        [CompoundCase("{0}", "XE.O11111111110")]
        [CompoundCase("{0}", "XE.01111111111O")]
        [CompoundCase("{0}", "XE.............")]
        [CompoundCase("{0}", "XE.#$%^(*-'\"Q!\\")]
        public void BadCharsInSuffix(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a suffix with a negative number")]
        public void NegativeSuffix()
        {
            string cid="XE.-01111111119";

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass a suffix with a hex number")]
        public void HexSuffix()
        {
            string cid="XE.0x00423A35CF"; //001111111119 as hex, padded

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass multiple valid console IDs.")]
        public void MultipleValid()
        {
            string cid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string cid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string cid2=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cid0, cid1, cid2});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid0.ToUpper(), 0), MakeConsoleIdResult(cid1.ToUpper(), 0), MakeConsoleIdResult(cid2.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass the maximum allowed valid console IDs.")]
        public void MaxValid()
        {
            string []cids=new string[100];
            for (int i=0; i<100; ++i)
            {
                cids[i]=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            }

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(cids);

            ConsoleIdResult []expectedRet=new ConsoleIdResult[100];
            for (int i=0; i<100; ++i)
            {
                expectedRet[i]=MakeConsoleIdResult(cids[i].ToUpper(), 0);
            }

            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", expectedRet, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass more than the maximum allowed valid console IDs.")]
        public void TooMany()
        {
            Global.RO.Debug("Creating 500 machines...");
            string []cids=new string[500];
            for (int i=0; i<500; ++i)
            {
                cids[i]=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            }

            XMachineTestUtil.ExecuteCallExpecting404(delegate{VerifyXbox360ConsoleIdsVerbose(cids);});
        }

        [TestCase, Description("Pass an empty list.")]
        public void PassNone()
        {
            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[0]);
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[0], ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass multiple console IDs, some of which are valid, some are duplicates.")]
        public void MixedValidAndInvalid()
        {
            string cidValid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string cidValid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string cidBad0="WTF.BAD.CONSOLE";
            string cidBad1="BAD.WTF.CONSOLE";

            ConsoleIdResult []ret=VerifyXbox360ConsoleIdsVerbose(new string[]{cidValid0, cidBad0, cidValid0.ToLower(), cidValid1, cidBad0.ToLower(), cidBad1});
            ValueCheck.TestAllUnordered("VerifyXbox360ConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cidValid0.ToUpper(), 0), MakeConsoleIdResult(cidValid1.ToUpper(), 0), MakeConsoleIdResult(cidBad0.ToUpper(), 0x80004005), MakeConsoleIdResult(cidBad1.ToUpper(), 0x80004005)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
        }

        [TestCase, Description("Pass null for one of the console IDs in the array.")]
        public void NullArrayEntry()
        {
            string cid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string cid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{VerifyXbox360ConsoleIdsVerbose(new string[]{cid0, null, cid1});}, "Null element in: consoleIds");
        }

        [TestCase, Description("Pass null for console IDs.")]
        public void NullParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{VerifyXbox360ConsoleIdsVerbose(null);}, "Null array: consoleIds");
        }
    }; //class VerifyXbox360ConsoleIds
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\UnbanConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the UnbanConsoleIds. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class UnbanConsoleIds: TestNode
    {
        public static ConsoleIdResult MakeConsoleIdResult(string consoleId, uint result)
        {
            ConsoleIdResult r=new ConsoleIdResult();
            r.ConsoleId = consoleId;
            r.Result    = result;
            return r;
        }

        public static string ConsoleIdResultStringer(ConsoleIdResult result)
        {
            return "ConsoleIdResult(ConsoleId="+result.ConsoleId+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string ConsoleIdResultStringer(object result)
        {
            if (result is ConsoleIdResult)
            {
                return ConsoleIdResultStringer((ConsoleIdResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool ConsoleIdResultEquals(ConsoleIdResult left, ConsoleIdResult right)
        {
            return left.ConsoleId==right.ConsoleId &&
                left.Result==right.Result;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static bool ConsoleBanHistoryEquals2S(ConsoleBanEditor.ConsoleBanHistory left, ConsoleBanEditor.ConsoleBanHistory right)
        {
            return left.ConsoleId==right.ConsoleId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyUnbannedMachineRow(string cid, ulong puid, uint reason, System.DateTime startDate, System.DateTime endDate)
        {
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)reason), startDate, endDate)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
        }

        public static ConsoleIdResult[] UnbanConsoleIdsVerbose(string []consoleList, uint reasonCode)
        {
            Global.RO.Debug("Calling UnbanConsoleIds: ConsoleList={"+StringUtils.MakeCommaSeparatedList(consoleList)+"}, ReasonCode="+string.Format("0x{0:X}",reasonCode));
            ConsoleIdResult[] ret=new XMachineSoapClient().UnbanConsoleIds(consoleList, reasonCode);
            Global.RO.Debug("UnbanConsoleIds returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", ConsoleIdResultStringer));
            return ret;
        }

        //same as default .Equals, but this allows for 5 second time differences rather than 10ms.
        public static bool MachineBanStatusEqualsLeniently(MachineEditor.MachineBanStatus left, MachineEditor.MachineBanStatus right)
        {
            return left.MachineId==right.MachineId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                left.HashBucket==right.HashBucket;
        }

        const int DATE_COMPARISON_LENIENCY_MS=4000;
        const int BAN_UNBAN_DELAY=DATE_COMPARISON_LENIENCY_MS+2000;

        // -----

        [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(8)]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Creates a console, console bans it, console unbans it, then verifies the tables."), BVT]
            public void UnbanOneExisting()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Calls unban for a valid console id that hasn't been created yet but has a valid console ban, then verifies the tables."), BVT]
            public void UnbanOneNotExisting()
            {
                //generate machine id and ban it
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                System.DateTime banStart=System.DateTime.UtcNow;
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(cid);
                cbe.BanConsole(unchecked((int)0x80000001), banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{cid}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=cbe.GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

                ValueCheck.Test("MachinePuid exists", 0, UodbWS.ExecuteSQLSelectCount("select count(*) from t_machines where vc_serial_num='"+cid+"'"));
            }

            [TestCase, Description("Creates a console, and calls console unban on it even though it's not banned, then verifies the tables.")]
            public void UnbanNotBanned()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001);

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
            }

            [TestCase, Description("Creates a console, bans it, calls unban on it explicitely as uppercase, then verifies the tables.")]
            public void UnbanOneUppercase()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId.ToUpper()}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Creates a console, bans it, calls unban on it explicitely as lowercase, then verifies the tables.")]
            public void BanOneLowercase()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId.ToLower()}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer); //NOTE: We expect all return values to be upper case.

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Creates a console and bans it, calls unban on it and a non-existing but valid one, then verifies the tables.")]
            public void MixedExistingAndNonExisting()
            {
                //create machine and generate an ad and ban them
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId, cid}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId, cid}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0), MakeConsoleIdResult(cid, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banStart, banEnd);

                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);
            }

            [TestCase, Description("Creates multiple machines and bans them, calls unban on them, then verifies the tables.")]
            [CompoundCase("7", 7)]
            [CompoundCase("Max", 100)]
            public void UnbanMany(TestNode self)
            {
                int numberToBan=(int)self.MyValues[0];

                //create machines
                List<MachineEditor> machs=new List<MachineEditor>();
                List<string> cids=new List<string>();
                List<ConsoleIdResult> expectedRet=new List<ConsoleIdResult>();

                for (int i=0; i<numberToBan; ++i)
                {
                    machs.Add(MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()));
                    cids.Add(machs[i].ConsoleId);
                    expectedRet.Add(MakeConsoleIdResult(cids[i], 0));
                }

                MachineEditor machNotUnbanned=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //ban them
                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(cids.ToArray(), 0x80000001, banStart);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{machNotUnbanned.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(cids.ToArray(), 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", expectedRet.ToArray(), ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

               //verify db
               for (int i=0; i<numberToBan; ++i)
               {
                   VerifyUnbannedMachineRow(cids[i], machs[i].Id, 0x80000001, banStart, banEnd);
               }

               BanConsoleIds.VerifyOneMachineOneConsoleBanRow(machNotUnbanned.ConsoleId, machNotUnbanned.Id, 0x80000001, banStart);
            }

            [TestCase, Description("Attempt to unban more consoles than the API can handle at once.")]
            public void UnbanTooMany()
            {
                //create machines
                List<string> cidsToUnban=new List<string>();

                Global.RO.Debug("Creating 500 machines...");
                for (int i=0; i<500; ++i)
                {
                    MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                    cidsToUnban.Add(mach.ConsoleId);
                }

                //call the api and verify the return
                XMachineTestUtil.ExecuteCallExpecting404(delegate{UnbanConsoleIdsVerbose(cidsToUnban.ToArray(), 0x80000001);});
            }

            [TestCase, Description("Calls unban on no consoles.")]
            public void UnbanNone()
            {
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[0], 0x80000001);

                ValueCheck.TestAllUnordered("Values returned", new ConsoleIdResult[0], ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
            }

            [TestCase, Description("Calls unban passing null for console ID.")]
            public void UnbanNullConsoleIDsParameter()
            {
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(null, 0x80000001);}, "Null array: consoleIds");
            }

            [TestCase, Description("Valid console IDs, but one entry in array is null.")]
            public void UnbanNullConsoleIdInArray()
            {
                //create machines and  ban them
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach1.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(new string[]{mach0.ConsoleId, null, mach1.ConsoleId}, 0x80000001);}, "Null element in: consoleIds");

                //verify the db
                foreach (MachineEditor mach in new MachineEditor[]{mach0, mach1})
                {
                    BanConsoleIds.VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, banStart);
                }
            }

            [TestCase, Description("Unban a list of mostly invalid console IDs with one valid one mixed in.")]
            public void InvalidConsoleIDs()
            {
                //create one valid machine and some invalid strings for others
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                string totallyInvalid0="";
                string totallyInvalid1=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(15);
                string totallyInvalid2=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(25);
                string totallyInvalid3="';drop table t_machine_banned_console_id; select '";
                string almostValid0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid0=almostValid0.Substring(0, 14)+(almostValid0[14]=='0'?"9":"0"); // F@$%ing C# doesn't allow this: almostValid0[15]=(almostValid0[15]=='0'?'9':'0');
                string almostValid1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId+"X";
                string almostValid2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid2=almostValid2.Substring(0, 2)+" "+almostValid2.Substring(3,12); //F@$%ing C# doesn't allow this: almostValid2[2]=' ';
                string []cids=new string[]{totallyInvalid0, totallyInvalid1, totallyInvalid2, totallyInvalid3, mach.ConsoleId, almostValid0, almostValid1, almostValid2};

                //ban them
                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(cids, 0x80000001);}, "Invalid ConsoleId");

                //verify the db
                BanConsoleIds.VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, banStart);
            }

            [TestCase, Description("Same console ID is passed twice in the parameter.")]
            public void DuplicateConsoleIDsInParameter()
            {
                //create machine and ban them
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach1.ConsoleId}, 0x80000001, banStart);

                //call the api and verify the return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach0.ConsoleId.ToUpper(), mach0.ConsoleId.ToLower(), mach1.ConsoleId}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach0.ConsoleId, 0), MakeConsoleIdResult(mach1.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                VerifyUnbannedMachineRow(mach0.ConsoleId, mach0.Id, 0x80000001, banStart, banEnd);
                VerifyUnbannedMachineRow(mach1.ConsoleId, mach1.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Creates a console, console bans it in the future, then unbans it, then verifies the tables.")]
            public void UnbanFutureBan()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime banStart=System.DateTime.UtcNow+new System.TimeSpan(7, 0, 0, 0);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banEnd, banEnd);
            }

            [TestCase, Description("Creates a console and bans it for multiple reasons, then unbans one of those reasons.")]
            public void BanMultipleReasonsUnbanOneReason()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime ban1Start=System.DateTime.UtcNow;
                System.DateTime ban2Start=System.DateTime.UtcNow;
                System.DateTime ban3Start=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
                System.DateTime ban4Start=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, ban1Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000002, ban2Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000003, ban3Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000004, ban4Start);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify returned
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000002);
                System.DateTime banEnd=System.DateTime.UtcNow;

                //verify db
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[]{
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0x80000001), ban1Start),
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0x80000003), ban3Start),
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0x80000004), ban4Start)};
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());

                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), ban1Start, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000002), ban2Start, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000003), ban3Start, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000004), ban4Start, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, mach.GetAllMachineBans(), MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a console and bans it for multiple reasons, then unbans one of all reasons.")]
            public void BanMultipleReasonsSpecialUnbanAllReasons()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime ban1Start=System.DateTime.UtcNow;
                System.DateTime ban2Start=System.DateTime.UtcNow;
                System.DateTime ban3Start=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
                System.DateTime ban4Start=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, ban1Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000002, ban2Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000003, ban3Start);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000004, ban4Start);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify returned
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0);
                System.DateTime banEnd=System.DateTime.UtcNow;

                //verify db
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());

                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), ban1Start, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000002), ban2Start, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000003), banEnd, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000004), ban4Start, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, mach.GetAllMachineBans(), MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a machine, calls unban on it with an invalid code.")]
            public void InvalidBanCode()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 13);}, "Invalid ReasonCode");
            }

            [TestCase, Description("Ban an old-style xbox360 machine that has not yet been migrated to the new name lookup table, then unban it.")]
            public void LegacyMachine()
            {
                //create machine and ban it
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();

                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(mach.ConsoleId, mach.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Creates two consoles that share the same console id, calls ban on the console id, then calln unban and verifies the tables.")]
            public void BanDuplicateConsole()
            {
                //create machines
                MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

                //call API and verify return
                System.DateTime banStart=System.DateTime.UtcNow;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{machA.ConsoleId}, 0x80000001, banStart);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                ConsoleIdResult []ret=UnbanConsoleIdsVerbose(new string[]{machA.ConsoleId}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("UnbanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(machA.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyUnbannedMachineRow(machA.ConsoleId, machA.Id, 0x80000001, banStart, banEnd);
                VerifyUnbannedMachineRow(machB.ConsoleId, machB.Id, 0x80000001, banStart, banEnd);
            }

            [TestCase, Description("Verify the history tables are being written to correctly.")]
            public void History()
            {
                //create machine
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                string cid0=MachineEditor.FromId(puid0).ConsoleId;
                ulong puid1=XMachineTestUtil.CreateXbox360Machine();
                string cid1=MachineEditor.FromId(puid1).ConsoleId;

                //call the ban api on both for reason 1, then on one for reason 2
                System.DateTime banStart=System.DateTime.UtcNow;
                System.DateTime banEnd=System.DateTime.MaxValue;
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{cid0, cid1}, 0x80000001, banStart);
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{cid0}, 0x80000002, banStart);
                System.DateTime banChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the unban api on both for reason 1
                UnbanConsoleIdsVerbose(new string[]{cid0, cid1}, 0x80000001);
                System.DateTime unban0Time=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the unban api on one again for reason 2
                UnbanConsoleIdsVerbose(new string[]{cid0}, 0x80000002);
                System.DateTime unban1Time=System.DateTime.UtcNow;

                //verify the db for machine0
                MachineEditor.MachineBanHistory []actualMachineHistories0=MachineEditor.FromId(puid0).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedMachineHistories0=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid0, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid0, banChangeTime, unchecked((int)0x80000002), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid0, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time),
                    new MachineEditor.MachineBanHistory(puid0, unban1Time, unchecked((int)0x80000002), unban1Time, unban1Time)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedMachineHistories0, actualMachineHistories0, MachineBanHistoryEquals2S);

                ConsoleBanEditor.ConsoleBanHistory []actualConsoleHistories0=ConsoleBanEditor.FromConsoleId(cid0).GetAllConsoleBanHistories();
                ConsoleBanEditor.ConsoleBanHistory []expectedConsoleHistories0=new ConsoleBanEditor.ConsoleBanHistory[]{
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, banChangeTime, unchecked((int)0x80000002), banStart, banEnd),
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time),
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, unban1Time, unchecked((int)0x80000002), unban1Time, unban1Time)};
                ValueCheck.TestAllUnordered("ConsoleBanHistory rows", expectedConsoleHistories0, actualConsoleHistories0, ConsoleBanHistoryEquals2S);

                //verify the db for machine1
                MachineEditor.MachineBanHistory []actualMachineHistories1=MachineEditor.FromId(puid1).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedMachineHistories1=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid1, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid1, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedMachineHistories1, actualMachineHistories1, MachineBanHistoryEquals2S);

                ConsoleBanEditor.ConsoleBanHistory []actualConsoleHistories1=ConsoleBanEditor.FromConsoleId(cid1).GetAllConsoleBanHistories();
                ConsoleBanEditor.ConsoleBanHistory []expectedConsoleHistories1=new ConsoleBanEditor.ConsoleBanHistory[]{
                    new ConsoleBanEditor.ConsoleBanHistory(cid1, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new ConsoleBanEditor.ConsoleBanHistory(cid1, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time)};
                ValueCheck.TestAllUnordered("ConsoleBanHistory rows", expectedConsoleHistories1, actualConsoleHistories1, ConsoleBanHistoryEquals2S);
            }
        }; //class Xbox360

        [TestCase, Description("Attempt to unban a PC console ID.  It should not work.")]
        public void PcConsoleId()
        {
            //create voucher and machine and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            string cid=MachineEditor.FromId(puid).ConsoleId;

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});

            //call the unban api
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(new string[]{cid}, 0x8015190D);}, "Invalid Non-Xbox360 ConsoleId: PC.");

            //verify the db
            BanPcTokens.VerifySimpleBanRows(puid, voucherHash);
        }

        [TestCase, Description("Attempt to unban a Phone console ID.  It should not work.")]
        public void PhoneConsoleId()
        {
            //create voucher and machine and ban it
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            string cid=MachineEditor.FromId(puid).ConsoleId;

            System.DateTime banStart=System.DateTime.UtcNow;
            BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, banStart, System.DateTime.MaxValue);

            //call the unban api
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanConsoleIdsVerbose(new string[]{cid}, 0x8015190D);}, "Invalid Non-Xbox360 ConsoleId: WM.");

            //verify the db
            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x8015190D), banStart, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\XMachineTests.cs ===
using System;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    public class XMachineTestUtil
    {
        public delegate void SimpleCall();

        //xrlscan will block calls that exceed the content length and return 404.  This will execute code expecting a 404 WebException.
        public static void ExecuteCallExpecting404(SimpleCall call)
        {
            try
            {
                call();
            }
            catch (System.Net.WebException we)
            {
                if (we.Response is System.Net.HttpWebResponse)
                {
                    if ((int)((System.Net.HttpWebResponse)we.Response).StatusCode==404)
                    {
                        Global.RO.Debug("Got expected HTTP error: "+we.Message);
                        return;
                    }
                }

                throw;
            }

            throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
        }

        public static void ExecuteCallExpectingSoapError(SimpleCall call, string substringMatch)
        {
            try
            {
                call();
            }
            catch (System.Web.Services.Protocols.SoapException se)
            {
                if (se.Message.ToLower().Contains(substringMatch.ToLower()))
                {
                    Global.RO.Debug("Got expected SOAP error: "+se.Message);
                    return;
                }

                throw;
            }

            throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
        }

        public static ulong CreateXbox360Machine()
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.ExecuteXmacs(true);

            ulong puid=client.XmacsOutput.MachineId;
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2}", puid, client.XmacsOutput.ConsoleId, Hexer.tohex(client.XmacsRequest.Input.FindConsoleCertificateInPreauths().ComputeHash()));
            return puid;
        }

        public static ulong CreateDuplicateXbox360Machine(string consoleId)
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.ConsoleId=consoleId;
            client.XmacsRequest.Input.ConsoleCert=new ConsoleCertificate();
            client.XmacsRequest.Input.ConsoleCert.SetConsoleIdFromGamertag(client.XmacsRequest.Input.ConsoleId);
            client.XmacsRequest.Input.ConsoleCert.ConsolePublicKey.GenerateRandomKey();
            client.XmacsRequest.Input.ConsoleCert.Sign();
            client.ExecuteXmacs(true);

            ulong puid=client.XmacsOutput.MachineId;
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2}", puid, client.XmacsOutput.ConsoleId, Hexer.tohex(client.XmacsRequest.Input.FindConsoleCertificateInPreauths().ComputeHash()));
            return puid;
        }

        public static string CreateUnlimitedPCVoucher()
        {
            string voucher=TokendbWS.CreatePanoramaVoucher(-1);
            Global.RO.Debug("Created new unlimited use count PC voucher: "+voucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher))+")"); //CreatePanoramaVoucher already has debug output
            return voucher;
        }

        public static ulong CreatePCMachine(string voucher)
        {
            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.ExecuteXmacs(true);

            ulong puid=client.XmacsOutput.MachineId;
            Global.RO.Debug("Created PC: MachineId=0x{0:X} ConsoleId={1} Voucher={2}(Hash=0x{3}) PcId=0x{4}", puid, client.XmacsOutput.ConsoleId, voucher, Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher)), client.XmacsRequest.Input.PcId);
            return puid;
        }

        public static ulong CreatePhoneMachine()
        {
            //TODO: At some point in the future maybe use the sts client to do this?
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Phone);
            Global.RO.Debug("Created Phone: MachineId=0x{0:X} ConsoleId={1}", mach.Id, mach.ConsoleId);
            return mach.Id;
        }

        public static void ReloadConfig()
        {
            String xmgmtText;

            if (!ManagementConsole.ExecuteOnAllIISProcess(xonline.common.config.Interface.xmachine, "xmachine", "xmachine configcacherefresh", out xmgmtText))
            {
                // This just means that XMachine isn't running yet so we can ignore this error
                if (!xmgmtText.Contains("No process id for w3wp:xmachine seems to be running"))
                {
                    throw new UnexpectedTestResultException("Unable to reload configuration: " + xmgmtText);
                }
            }

            xonline.common.config.Config.DiscardCachedValues();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:27:42 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\UnbanMachinePuids.cs ===
using System;
using System.Collections.Generic;
using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the UnbanMachinePuids. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class UnbanMachinePuids : TestNode
    {
        public static MachinePuidResult MakeMachinePuidResult(ulong machinePuid, UInt32 result)
        {
            MachinePuidResult r=new MachinePuidResult();
            r.MachinePuid = machinePuid;
            r.Result      = result;
            return r;
        }

        public static string MachinePuidResultStringer(MachinePuidResult result)
        {
            return "MachinePuidResult(MachinePuid="+string.Format("0x{0:X}", result.MachinePuid)+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string MachinePuidResultStringer(object result)
        {
            if (result is MachinePuidResult)
            {
                return MachinePuidResultStringer((MachinePuidResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool MachinePuidResultEquals(MachinePuidResult left, MachinePuidResult right)
        {
            return left.MachinePuid==right.MachinePuid &&
                left.Result==right.Result;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static MachinePuidResult[] UnbanMachinePuidsVerbose(Puid []machineList, uint reasonCode)
        {
            Global.RO.Debug("Calling UnbanMachinePuids: MachineList={"+StringUtils.MakeCommaSeparatedList(machineList)+"}, ReasonCode="+reasonCode);
            MachinePuidResult[] ret;
            if (machineList!=null)
            {
                ret=new XMachineSoapClient().UnbanMachinePuids(System.Array.ConvertAll(machineList, u=>(ulong)(u)), reasonCode);
            }
            else
            {
                ret=new XMachineSoapClient().UnbanMachinePuids(null, reasonCode);
            }
            Global.RO.Debug("UnbanMachinePuids returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", MachinePuidResultStringer));
            return ret;
        }

        public static MachinePuidResult[] UnbanMachinePuidsVerbose(ulong []machineList, uint reasonCode)
        {
            return UnbanMachinePuidsVerbose(System.Array.ConvertAll(machineList, u=>(Puid)(u)), reasonCode);
        }

        //same as default .Equals, but this allows for 5 second time differences rather than 10ms.
        public static bool MachineBanStatusEqualsLeniently(MachineEditor.MachineBanStatus left, MachineEditor.MachineBanStatus right)
        {
            return left.MachineId==right.MachineId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                left.HashBucket==right.HashBucket;
        }

        const int DATE_COMPARISON_LENIENCY_MS=4000;
        const int BAN_UNBAN_DELAY=DATE_COMPARISON_LENIENCY_MS+2000;

        // -----

        [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(8)]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Ban a machine by puid then call unban on it."), BVT]
            public void UnbanOneMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                //ban
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //unban and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals);

                //verify ban tables in db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

                //verify tgt revocation and key reset
                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDate, mach.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKey, mach.GetEncryptedKey());
            }

            [TestCase, Description("Call unban on a machine that's not banned.")]
            public void UnbanOneMachineNotBanned()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                System.Threading.Thread.Sleep(250); //to spread apart the key reset date of now apart from the time of the call which should reset it

                //unban and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals);

                //verify ban tables in db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                //It doesn't really matter whether or not the tgt is revoked and key reset in this case.  It happens that it is.
                ValueCheck.TestDifferent("Machine Key Reset Date", origResetDate, mach.ResetDate, new System.TimeSpan(0, 0, 0, 0, 20));
                ValueCheck.TestNotAll("Machine Encrypted Key", origEncryptedKey, mach.GetEncryptedKey());
            }

            [TestCase, Description("Ban a machine for two reasons, then call unban for one of the reasons.")]
            public void BanOneMachineTwoReasonsUnbanOneReason()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //ban
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, banStart, System.DateTime.MaxValue);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000002, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //unban and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals);

                //verify ban tables in db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000002), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Call unban on nothing.")]
            public void UnbanNone()
            {
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[0], 0x80000001);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[0], ret, MachinePuidResultEquals);
            }

            [TestCase, Description("Ban a machine for two reasons, then call unban with the special case \"all\" reason.")]
            public void SpecialUnbanAllOneMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                System.DateTime origResetDate=mach.ResetDate;
                byte []origEncryptedKey=mach.GetEncryptedKey();

                //ban
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, banStart, System.DateTime.MaxValue);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000002, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //unban and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals);

                //verify ban tables in db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000002), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Calls unban on on puid in the valid range but for a machine that doesn't exist.")]
            public void MachineDoesNotExistSpecificReason()
            {
                //create machine
                ulong validPuid=0xfa0010108080fffe;

                //call the ban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{validPuid}, 0x80000001);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(validPuid, 0x80004005)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);
            }

            [TestCase, Description("Calls unban on on puid in the valid range but for a machine that doesn't exist.")]
            public void MachineDoesNotExistSpecialAllReason()
            {
                //create machine
                ulong validPuid=0xfa0010108080fffd;

                //call the ban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{validPuid}, 0);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(validPuid, 0x80004005)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);
            }

            [TestCase, Description("Calls unban on more than one machine at once.")]
            [CompoundCase("7", 7)]
            [CompoundCase("Max", 100)]
            public void UnbanMultipleMachines(TestNode self)
            {
                int numberToBan=(int)self.MyValues[0];

                //create machines
                List<MachinePuidResult> expectedRet=new List<MachinePuidResult>();
                List<ulong> puidsToUnban=new List<ulong>();

                for (int i=0; i<numberToBan; ++i)
                {
                    puidsToUnban.Add(XMachineTestUtil.CreateXbox360Machine());
                    expectedRet.Add(MakeMachinePuidResult(puidsToUnban[i], 0));
                }

                ulong puidNotUnbanned=XMachineTestUtil.CreateXbox360Machine();

                //ban them all
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(puidsToUnban.ToArray(), 0x80000001, banStart, System.DateTime.MaxValue);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puidNotUnbanned}, 0x80000001, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //unban and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(puidsToUnban.ToArray(), 0);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet.ToArray(), ret, MachinePuidResultEquals);

                //verify ban tables in db
                foreach (ulong puid in puidsToUnban)
                {
                    MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, banEnd)};
                    ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
                }

                MachineEditor.MachineBanStatus []machineBansForBanned=MachineEditor.FromId(puidNotUnbanned).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBansForBanned=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puidNotUnbanned, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB for a banned machine", expectedMachineBansForBanned, machineBansForBanned);
            }

            [TestCase, Description("Attempt to unban more machines than the API can handle at once.")]
            public void UnbanTooMany()
            {
                //create machines
                List<ulong> puidsToUnban=new List<ulong>();

                Global.RO.Debug("Creating 500 machines...");
                for (int i=0; i<500; ++i)
                {
                    MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                    puidsToUnban.Add(mach.Id);
                }

                //call the ban api and verify the return
                XMachineTestUtil.ExecuteCallExpecting404(delegate{UnbanMachinePuidsVerbose(puidsToUnban.ToArray(), 0x80000001);});
            }

            [TestCase, Description("Creates a machine, bans it, calls ban on it along with some invalid ones, then verifies the tables.")]
            public void MixedValidInvalidPlatforms()
            {
                //create machine
                ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{0x12345, validPuid, 0xffffffedcba98765};

                //ban the valid one
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{validPuid}, 0x80000001, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(puids, 0x80000001);}, "Invalid platform type");

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(validPuid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a machine, bans it, calls ban on it along with some invalid ones, then verifies the tables.")]
            public void MixedValidInvalidPuids()
            {
                //create machine
                ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{0xfa00ffedcba98764, validPuid, 0xfa00ffedcba98765};

                //ban the valid one
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{validPuid}, 0x80000001, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(puids, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                MachinePuidResult []expectedReturn=new MachinePuidResult[]{MakeMachinePuidResult(0xfa00ffedcba98764, 0x80004005), MakeMachinePuidResult(validPuid, 0), MakeMachinePuidResult(0xfa00ffedcba98765, 0x80004005)};
                ValueCheck.TestAllUnordered("Puid errors returned", expectedReturn, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(validPuid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Pass null for the machine puids paramater.")]
            public void NullPuidsParameter()
            {
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose((Puid[])null, 0x80000001);}, "Null array: machinePuids");
            }

            [TestCase, Description("Creates a couple machines, calls unban with duplicate puids, then verifies the tables.")]
            public void DuplicatePuidsInParameter()
            {
                //create machine
                ulong validPuid0=XMachineTestUtil.CreateXbox360Machine();
                ulong validPuid1=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{validPuid0, validPuid0, validPuid1};

                //ban them
                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{validPuid0, validPuid1}, 0x80000001, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(puids, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                MachinePuidResult []expectedReturn=new MachinePuidResult[]{MakeMachinePuidResult(validPuid0, 0), MakeMachinePuidResult(validPuid1, 0)};
                ValueCheck.TestAllUnordered("Puid errors returned", expectedReturn, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(validPuid0).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid0, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

                actualMachineBans=MachineEditor.FromId(validPuid1).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid1, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a machine, creates an expired ban for it, then verifies the tables.")]
            public void UnbanExpiredBan()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //ban
                System.DateTime banStart=System.DateTime.UtcNow-new System.TimeSpan(9, 0, 0, 0);
                System.DateTime banOriginalEnd=banStart+new System.TimeSpan(3, 0, 0, 0);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, banOriginalEnd);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001);
                System.DateTime callEndTime=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, banOriginalEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a machine, creates a future ban for it, then verifies the tables.")]
            public void UnbanFutureBan()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //ban
                System.DateTime banStart=System.DateTime.UtcNow+new System.TimeSpan(9, 0, 0, 0);
                System.DateTime banOriginalEnd=banStart+new System.TimeSpan(3, 0, 0, 0);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, banOriginalEnd);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001);
                System.DateTime callEndTime=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), callEndTime, callEndTime)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates a machine, calls unban on it with an invalid code.")]
            public void InvalidBanCode()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the unban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(new ulong[]{puid}, 13);}, "Invalid ReasonCode");

                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Unban an old-style xbox360 machine that has not yet been migrated to the new name lookup table.")]
            public void LegacyMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();

                //ban them directly
                System.DateTime banStart=System.DateTime.UtcNow;
                mach.BanMachine(unchecked((int)0x80000001), banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates two consoles that share the same console id, puid bans on both puids, then unbans one and verifies the tables.")]
            public void UnbanDuplicateConsole()
            {
                //create machines
                MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

                //ban both
                System.DateTime banStart=System.DateTime.UtcNow;
                machA.BanMachine(unchecked((int)0x80000001), banStart, System.DateTime.MaxValue);
                machB.BanMachine(unchecked((int)0x80000001), banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call API and verify return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{machB.Id}, 0x80000001);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(machB.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify DB
                MachineEditor.MachineBanStatus []actualMachineBans=machA.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(machA.Id, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

                actualMachineBans=machB.GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(machB.Id, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Verify the history tables are being written to correctly.")]
            public void History()
            {
                //create machine
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                ulong puid1=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api on both for reason 1, then on one for reason 2
                System.DateTime banStart=System.DateTime.UtcNow;
                System.DateTime banEnd=System.DateTime.MaxValue;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x80000001, banStart, banEnd);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid0}, 0x80000002, banStart, banEnd);
                System.DateTime banChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the unban api on both for reason 1
                UnbanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x80000001);
                System.DateTime unban0Time=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the unban api on one again for reason 2
                UnbanMachinePuidsVerbose(new ulong[]{puid0}, 0x80000002);
                System.DateTime unban1Time=System.DateTime.UtcNow;

                //verify the db for machine0
                MachineEditor.MachineBanHistory []actualHistories0=MachineEditor.FromId(puid0).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedHistories0=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid0, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid0, banChangeTime, unchecked((int)0x80000002), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid0, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time),
                    new MachineEditor.MachineBanHistory(puid0, unban1Time, unchecked((int)0x80000002), unban1Time, unban1Time)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistories0, actualHistories0, MachineBanHistoryEquals2S);
                ValueCheck.Test("ConsoleBanHistory rows for machine0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puid0).ConsoleId).GetAllConsoleBanHistories().Length);

                //verify the db for machine1
                MachineEditor.MachineBanHistory []actualHistories1=MachineEditor.FromId(puid1).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedHistories1=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid1, banChangeTime, unchecked((int)0x80000001), banStart, banEnd),
                    new MachineEditor.MachineBanHistory(puid1, unban0Time, unchecked((int)0x80000001), unban0Time, unban0Time)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistories1, actualHistories1, MachineBanHistoryEquals2S);
                ValueCheck.Test("ConsoleBanHistory rows for machine1", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puid1).ConsoleId).GetAllConsoleBanHistories().Length);
            }
        }; //class Xbox360


        [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3)]
        public class PC
        {
            [TestCase, Description("Creates a machine, bans it, then calls unban on it, then verifies the tables."), BVT]
            public void UnbanOne()
            {
                //create voucher and machine and ban it
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
                System.DateTime banStart=System.DateTime.UtcNow;

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                UnbanPcTokens.VerifyUnbanned(puid, voucherHash, banStart, banEnd);
            }

            [TestCase, Description("Creates several machines, bans them, calls unban on them, then verifies the tables.")]
            public void UnbanMultiple()
            {
                int createCount=5;

                //create vouchers and machines and ban them.  we do this directly here because hitting passport for 100 tickets is not desirable.
                string []vouchers=new string[createCount];
                byte [][]voucherHashes=new byte [createCount][];
                ulong []puids=new ulong[createCount];

                for (int i=0; i<createCount; ++i)
                {
                    vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                    voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(vouchers[i], (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }

                BanPcTokens.BanPcTokensVerbose(voucherHashes);
                System.DateTime banStart=System.DateTime.UtcNow;

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call api and verify
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(puids, 0x8015190D);
                System.DateTime banEnd=System.DateTime.UtcNow;

                MachinePuidResult []expectedRet=new MachinePuidResult[createCount];
                for (int i=0; i<createCount; ++i)
                {
                    expectedRet[i]=MakeMachinePuidResult(puids[i], 0);
                }

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify db
                for (int i=0; i<createCount; ++i)
                {
                    UnbanPcTokens.VerifyUnbanned(puids[0], voucherHashes[i], banStart, banEnd);
                }
            }

            [TestCase, Description("Creates multiple machines from the same voucher, bans the voucher and machines, calls unban on one machine (which should unban the voucher and all other machines), then verifies the tables.")]
            public void OneVoucherMultipleMachines()
            {
                //create voucher and machines and ban them
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid0=XMachineTestUtil.CreatePCMachine(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);
                ulong puid2=XMachineTestUtil.CreatePCMachine(voucher);

                BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
                System.DateTime banStart=System.DateTime.UtcNow;

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the ban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{puid0}, 0x8015190D);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid0, 0), MakeMachinePuidResult(puid1, 0), MakeMachinePuidResult(puid2, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                UnbanPcTokens.VerifyUnbanned(puid0, voucherHash, banStart, banEnd);
                UnbanPcTokens.VerifyUnbanned(puid1, voucherHash, banStart, banEnd);
                UnbanPcTokens.VerifyUnbanned(puid2, voucherHash, banStart, banEnd);
            }

            [TestCase, Description("Creates a machine, bans it, calls ban on it with a reason other than the only reason PC may currently be banned for, then verifies the tables.")]
            public void BadPcBanReason()
            {
                //create voucher and machine and ban them
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
                System.DateTime banStart=System.DateTime.UtcNow;

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the ban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x80151337);}, "PC Bans must be for Reason 0x8015190D");

                //verify the db
                UnbanPcTokens.VerifyStillBanned(puid, voucherHash, banStart);
            }
        }; //class PC


        [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(8)]
        public class Phone
        {
            [TestCase, Description("Creates a machine, bans it, then calls unban on it, then verifies the tables."), BVT]
            public void UnbanOne()
            {
                //create machine and ban it
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call the unban api and verify the return
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D);
                System.DateTime banEnd=System.DateTime.UtcNow;

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x8015190D), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
            }

            [TestCase, Description("Creates several machines, bans them, calls unban on them, then verifies the tables.")]
            public void UnbanMultiple()
            {
                int createCount=5;

                //create machines and ban them
                ulong []puids=new ulong[createCount];

                for (int i=0; i<createCount; ++i)
                {
                    puids[i]=XMachineTestUtil.CreatePhoneMachine();
                }

                System.DateTime banStart=System.DateTime.UtcNow;
                BanMachinePuids.BanMachinePuidsVerbose(puids, 0x8015190D, banStart, System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

                //call api and verify
                MachinePuidResult []ret=UnbanMachinePuidsVerbose(puids, 0x8015190D);
                System.DateTime banEnd=System.DateTime.UtcNow;

                MachinePuidResult []expectedRet=new MachinePuidResult[createCount];
                for (int i=0; i<createCount; ++i)
                {
                    expectedRet[i]=MakeMachinePuidResult(puids[i], 0);
                }

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify db
                for (int i=0; i<createCount; ++i)
                {
                    MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puids[i]).GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puids[i], unchecked((int)0x8015190D), banStart, banEnd)};
                    ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);
                }
            }
        }; //class Phone


        [TestGroup]
        public class Mixed
        {
            [TestCase]
            public void Xbox360AndPC()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();

                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D);}, "Mixed PlatformType");
            }

            [TestCase]
            public void Xbox360AndPhone()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                ulong puid1=XMachineTestUtil.CreatePhoneMachine();

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D);}, "Mixed PlatformType");
            }

            [TestCase]
            public void PCAndPhone()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreatePhoneMachine();

                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D);}, "Mixed PlatformType");
            }
        }; //class Mixed
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xnull\fd\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\UnbanPcTokens.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the UnbanPcTokens. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1), AsyncGroup(1, 0), AsyncThreadCount(3)]
    public class UnbanPcTokens: TestNode
    {
        public static PcTokenBanResult MakePcTokenBanResult(byte []voucherHash, uint result)
        {
            PcTokenBanResult r=new PcTokenBanResult();
            r.VoucherHash=voucherHash;
            r.Result=result;
            return r;
        }

        public static string PcTokenBanResultStringer(PcTokenBanResult result)
        {
            return "PcTokenBanResult(VoucherHash=0x"+Hexer.tohex(result.VoucherHash)+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string PcTokenBanResultStringer(object result)
        {
            if (result is PcTokenBanResult)
            {
                return PcTokenBanResultStringer((PcTokenBanResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static string ByteArrayStringer(byte[] ba)
        {
            return "0x"+Hexer.tohex(ba);
        }

        public static string ByteArrayStringer(object ba)
        {
            if (ba is byte[])
            {
                return ByteArrayStringer((byte[])ba);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(ba);
            }
        }

        public static bool PcTokenBanResultEquals(PcTokenBanResult left, PcTokenBanResult right)
        {
            if (left.Result!=right.Result)
            {
                return false;
            }

            if (left.VoucherHash.Length!=right.VoucherHash.Length)
            {
                return false;
            }

            for (int i=0; i<left.VoucherHash.Length; ++i)
            {
                if (left.VoucherHash[i]!=right.VoucherHash[i])
                {
                    return false;
                }
            }

            return true;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyUnbanned(ulong puid, byte []voucherHash, System.DateTime startTime, System.DateTime endTime)
        {
            MachineEditor mach=MachineEditor.FromId(puid);

            MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x8015190D), startTime, endTime)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 0, ve.Status); //0=active, 1=disabled, 2=banned
        }

        public static void VerifyStillBanned(ulong puid, byte []voucherHash, System.DateTime startTime)
        {
            MachineEditor mach=MachineEditor.FromId(puid);

            //there should be one machine ban row, no console ban row, and the voucher status should be banned
            MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x8015190D), startTime, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 2, ve.Status); //0=active, 1=disabled, 2=banned
        }

        //same as default .Equals, but this allows for 5 second time differences rather than 10ms.
        public static bool MachineBanStatusEqualsLeniently(MachineEditor.MachineBanStatus left, MachineEditor.MachineBanStatus right)
        {
            return left.MachineId==right.MachineId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                left.HashBucket==right.HashBucket;
        }

        const int DATE_COMPARISON_LENIENCY_MS=4000;
        const int BAN_UNBAN_DELAY=DATE_COMPARISON_LENIENCY_MS+2000;
        const ulong PANORAMA_VOUCHER_OFFER_ID=0x585207D10FF00001;

        public static PcTokenBanResult[] UnbanPcTokensVerbose(byte [][]tokenHashes)
        {
            Global.RO.Debug("Calling UnbanPcTokens: VoucherHashes={"+StringUtils.MakeDeliminatorSeparatedList(tokenHashes, ", ", ByteArrayStringer)+"}");
            PcTokenBanResult[] ret=new XMachineSoapClient().UnbanPcTokens(tokenHashes);
            Global.RO.Debug("UnbanPcTokens returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", PcTokenBanResultStringer));
            return ret;
        }

        // -----

        [TestCase, Description("Unban a PC voucher that has one machine created from it."), BVT]
        public void UnbanOne()
        {
            //create voucher and machine and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banEnd=System.DateTime.UtcNow;

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifyUnbanned(puid, voucherHash, banStart, banEnd);
        }

        [TestCase, Description("Unban a PC token that doesn't have any machines created from it.")]
        public void BanTokenWithoutMachines()
        {
            //create voucher and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 0, ve.Status); //0=active, 1=disabled, 2=banned
        }

        [TestCase, Description("Unban a PC voucher that has several machines created from it.")]
        public void UnbanTokenWithSeveralMachines()
        {
            //create voucher and machine and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid0=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puid2=XMachineTestUtil.CreatePCMachine(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banEnd=System.DateTime.UtcNow;

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifyUnbanned(puid0, voucherHash, banStart, banEnd);
            VerifyUnbanned(puid1, voucherHash, banStart, banEnd);
            VerifyUnbanned(puid2, voucherHash, banStart, banEnd);
        }

        [TestCase, Description("Unban a PC voucher that is not banned.")]
        public void UnbanNotBanned()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api to unban verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            MachineEditor mach=MachineEditor.FromId(puid);

            MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 0, ve.Status); //0=active, 1=disabled, 2=banned
        }

        [TestCase, Description("Unban multiple voucher hashes at once.")]
        [CompoundCase("7", 7)]
        [CompoundCase("Max", 100)]
        public void UnbanMultiple(TestNode self)
        {
            //create vouchers and machines then ban them.  we do this creation directly here because hitting passport for 100 tickets is not desirable.
            int createCount=(int)self.MyValues[0];

            string []vouchers=new string[createCount];
            byte [][]voucherHashes=new byte [createCount][];
            ulong []puids=new ulong[createCount];

            for (int i=0; i<createCount; ++i)
            {
                vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
                puids[i]=MachineEditor.CreateOrUseExistingPCName(vouchers[i], (ulong)i, MachineEditor.GetCachedPassportId()).Id;
            }

            BanPcTokens.BanPcTokensVerbose(voucherHashes);
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify
            PcTokenBanResult []ret=UnbanPcTokensVerbose(voucherHashes);
            System.DateTime banEnd=System.DateTime.UtcNow;

            PcTokenBanResult []expectedRet=new PcTokenBanResult[createCount];
            for (int i=0; i<createCount; ++i)
            {
                expectedRet[i]=MakePcTokenBanResult(voucherHashes[i], 0);
            }

            ValueCheck.TestAllUnordered("UnbanPcTokens return", expectedRet, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            for (int i=0; i<createCount; ++i)
            {
                VerifyUnbanned(puids[i], voucherHashes[i], banStart, banEnd);
            }
        }

        [TestCase, Description("Attempt to unban more than the API can handle at once.")]
        public void UnbanTooMany()
        {
            //create vouchers
            string []vouchers=new string[500];
            byte [][]voucherHashes=new byte [500][];

            Global.RO.Debug("Creating 500 machines...");
            for (int i=0; i<500; ++i)
            {
                vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
            }

            //call the ban api and verify the return
            XMachineTestUtil.ExecuteCallExpecting404(delegate{UnbanPcTokensVerbose(voucherHashes);});
        }

        [TestCase, Description("Unban no PC vouchers.")]
        public void UnbanNone()
        {
            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{});

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[0], ret, PcTokenBanResultEquals, PcTokenBanResultStringer);
        }

        [TestCase, Description("Attempt to unban a voucher that doesn't exist.")]
        public void VoucherDoesNotExist()
        {
            //create voucher
            string voucher="QJKXB-12345-WOOPS-NOTTT-EXIST";
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0x80004005)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Voucher exists now", false, ve.Exists);
        }

        [TestCase, Description("Unban a PC voucher with one byte missing that has one machine created from it.")]
        public void VoucherTooShort()
        {
            //create voucher and machine and ban it 
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            byte []badVoucherHash=new byte[19];
            System.Array.Copy(voucherHash, badVoucherHash, 19);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanPcTokensVerbose(new byte[][]{badVoucherHash});}, "Token Hashes must be 20 bytes long");

            //verify db
            VerifyStillBanned(puid, voucherHash, banStart);
        }

        [TestCase, Description("Unban a PC voucher with one byte extra that has one machine created from it.")]
        public void VoucherTooLong()
        {
            //create voucher and machine and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            byte []badVoucherHash=new byte[21];
            System.Array.Copy(voucherHash, badVoucherHash, 20);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanPcTokensVerbose(new byte[][]{badVoucherHash});}, "Token Hashes must be 20 bytes long");

            //verify db
            VerifyStillBanned(puid, voucherHash, banStart);
        }

        [TestCase, Description("Unban a PC voucher with one byte wrong that has one machine created from it.")]
        [CompoundCase("Start", 0)]
        [CompoundCase("End", 19)]
        public void VoucherBadByte(TestNode self)
        {
            int byteToTwiddle=(int)self.MyValues[0];

            //create voucher and machine and ban it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            byte []badVoucherHash=new byte[20];
            System.Array.Copy(voucherHash, badVoucherHash, 20);
            badVoucherHash[byteToTwiddle]=(byte)~badVoucherHash[byteToTwiddle];

            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{badVoucherHash});

            ValueCheck.TestAllUnordered("UnbanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(badVoucherHash, 0x80004005)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifyStillBanned(puid, voucherHash, banStart);
        }

        [TestCase, Description("Some vouchers are valid, others are not.")]
        public void MixedValidInvalid()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            string voucherC=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashC=TokendbWS.GetHashForPanoramaVoucher(voucherC);
            ulong puidC0=XMachineTestUtil.CreatePCMachine(voucherC);
            ulong puidC1=XMachineTestUtil.CreatePCMachine(voucherC);

            string voucherInvalidD="QXYYZ-12345-WOOPS-NOTTT-EXIST";
            byte []voucherInvalidHashD=TokendbWS.GetHashForPanoramaVoucher(voucherInvalidD);
            string voucherInvalidE="QXVVK-12345-WOOPS-NOTTT-EXIST";
            byte []voucherInvalidHashE=TokendbWS.GetHashForPanoramaVoucher(voucherInvalidE);

            //ban the valid ones
            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB, voucherHashC});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            PcTokenBanResult []ret=UnbanPcTokensVerbose(new byte[][]{voucherInvalidHashD, voucherHashA, voucherHashB, voucherHashC, voucherInvalidHashE});
            System.DateTime banEnd=System.DateTime.UtcNow;

            PcTokenBanResult []expectedRet=new PcTokenBanResult[]{
                MakePcTokenBanResult(voucherHashA, 0),
                MakePcTokenBanResult(voucherHashB, 0),
                MakePcTokenBanResult(voucherHashC, 0),
                MakePcTokenBanResult(voucherInvalidHashD, 0x80004005),
                MakePcTokenBanResult(voucherInvalidHashE, 0x80004005)};

            ValueCheck.TestAllUnordered("UnbanPcTokens return", expectedRet, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor veA=VoucherEditor.FromHash(voucherHashA, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucherA", 0, veA.Status); //0=active, 1=disabled, 2=banned

            VerifyUnbanned(puidB0, voucherHashB, banStart, banEnd);

            VerifyUnbanned(puidC0, voucherHashC, banStart, banEnd);
            VerifyUnbanned(puidC1, voucherHashC, banStart, banEnd);

            VoucherEditor veD=VoucherEditor.FromHash(voucherInvalidHashD, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("VoucherD exists now", false, veD.Exists);

            VoucherEditor veE=VoucherEditor.FromHash(voucherInvalidHashE, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("VoucherE exists now", false, veE.Exists);
        }

        [TestCase, Description("Pass null to the voucher hash list parameter.")]
        public void NullParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanPcTokensVerbose(null);}, "Null array: pcTokens");
        }

        [TestCase, Description("Pass null for one of the vouchers in the list, the others are valid.")]
        public void NullVoucherInArray()
        {
            //create vouchers and machines and ban them
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB});
            System.DateTime banStart=System.DateTime.UtcNow;

            System.Threading.Thread.Sleep(BAN_UNBAN_DELAY); //seperate the ban and unban by more than leniency time

            //call api and verify return
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{UnbanPcTokensVerbose(new byte[][]{voucherHashA, null, voucherHashB});}, "Null element in: pcTokens");

            //verify db
            VoucherEditor veA=VoucherEditor.FromHash(voucherHashA, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucherA", 2, veA.Status); //0=active, 1=disabled, 2=banned

            VerifyStillBanned(puidB0, voucherHashB, banStart);
        }

        [TestCase, Description("Verify the history tables are being written to correctly.")]
        public void History()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            ulong puidA0=XMachineTestUtil.CreatePCMachine(voucherA);
            ulong puidA1=XMachineTestUtil.CreatePCMachine(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            //call the ban api on both vouchers
            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB});
            System.DateTime banTime=System.DateTime.UtcNow;
            System.Threading.Thread.Sleep(3000);

            //call the unban api on both vouchers
            UnbanPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB});
            System.DateTime unban0Time=System.DateTime.UtcNow;
            System.Threading.Thread.Sleep(3000);

            //call the unban api again on only the second voucher
            UnbanPcTokensVerbose(new byte[][]{voucherHashB});
            System.DateTime unban1Time=System.DateTime.UtcNow;

            //verify the db for machineA0
            MachineEditor.MachineBanHistory []actualHistoriesA0=MachineEditor.FromId(puidA0).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesA0=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidA0, banTime, unchecked((int)0x8015190D), banTime, System.DateTime.MaxValue),
                new MachineEditor.MachineBanHistory(puidA0, unban0Time, unchecked((int)0x8015190D), unban0Time, unban0Time)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesA0, actualHistoriesA0, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineA0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidA0).ConsoleId).GetAllConsoleBanHistories().Length);

            //verify the db for machineA1
            MachineEditor.MachineBanHistory []actualHistoriesA1=MachineEditor.FromId(puidA1).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesA1=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidA1, banTime, unchecked((int)0x8015190D), banTime, System.DateTime.MaxValue),
                new MachineEditor.MachineBanHistory(puidA1, unban0Time, unchecked((int)0x8015190D), unban0Time, unban0Time)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesA1, actualHistoriesA1, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineA1", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidA1).ConsoleId).GetAllConsoleBanHistories().Length);

            //verify the db for machineB0
            MachineEditor.MachineBanHistory []actualHistoriesB0=MachineEditor.FromId(puidB0).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesB0=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidB0, banTime, unchecked((int)0x8015190D), banTime, System.DateTime.MaxValue),
                new MachineEditor.MachineBanHistory(puidB0, unban0Time, unchecked((int)0x8015190D), unban0Time, unban0Time),
                new MachineEditor.MachineBanHistory(puidB0, unban1Time, unchecked((int)0x8015190D), unban1Time, unban1Time)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesB0, actualHistoriesB0, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineB0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidB0).ConsoleId).GetAllConsoleBanHistories().Length);
        }
    }; //class UnbanPcTokens
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xnull\fd\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live Null Front Door")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xnull\fd\nullapp.cs ===
// 
// MatchApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Null Front Door
// Xbox Online Service
// 
// Author: pnewson
//

using System;
//using System.IO;
//using System.Text;
//using System.Threading;
using System.Web;
//using xonline.common.service;
//using xonline.common.mgmt;
//using xonline.common.config;
//sing xonline.common.installer;

namespace xonline.server.xnull.fd
{

// -----------------------------------------------------------------------------------
// NullApp class - the main application class
// -----------------------------------------------------------------------------------
public class NullApp : HttpApplication
{
    // -------------------------------------------------------------------------------
    // Application_Start - called once when the front door starts up
    // -------------------------------------------------------------------------------
    public void Application_Start( object sender, EventArgs e )
    {
    }

    // -------------------------------------------------------------------------------
    // Application_BeginRequest - called at the beginning of every request
    // -------------------------------------------------------------------------------
    public void Application_BeginRequest( object sender, EventArgs e )
    {
    }

    // -------------------------------------------------------------------------------
    // Application_EndRequest - called at the end of every request
    // -------------------------------------------------------------------------------
    public void Application_EndRequest( object sender, EventArgs e )
    {
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\wsdl\XMachineSoapClient.cs ===
// -------------------------------------------------------------------------------
// class XMachineSoapXBL
//
// The wsdl generated class XMachine (XMachineSoap.cs) can't be used as is
// because it is hard-coded to a specific machine.
// 
// This class provides an implementation that derives from XMachine but uses 
// configuration information to send the request to the real XMachine servers
//
// -------------------------------------------------------------------------------

using System;
using System.Net;
using System.Web;

using xonline.common.service;
using xonline.common.config;

namespace xonline.server.xmachine.fd.soap 
{
    public class XMachineSoapClient : XMachine
    {
        private string _urlPrefix;

        public XMachineSoapClient( )
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xmachine_int, Config.SiteId);
            _urlPrefix = viInfo.Protocol + "://" + viInfo.IPAddressString + ":" + viInfo.Port;
                
            Uri uri = new Uri(this.Url);
            this.Url = _urlPrefix + uri.LocalPath;
        }

        // This code exists in order to load balance the connection to the
        // various XMachine boxes that sit behind a VIP
        //  
        // See http://support.microsoft.com/kb/2551125 as to why it was done
        // this way instead of using ConnectionGroupName
        protected override WebRequest GetWebRequest(Uri url)
        {
            WebRequest req = base.GetWebRequest(url);
            if (req is HttpWebRequest)
            {
                ((HttpWebRequest) req).KeepAlive = false;
            }
            return req;
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xnull\fd\nullrequest.cs ===
//
// SessionSearch.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/18/2005, pnewson
//

using System;
using System.Configuration;
using System.Threading;
using System.Web;

namespace xonline.server.xnull.fd
{

public class AsyncRequestState : IAsyncResult
{
    public AsyncRequestState(HttpContext ctx, 
                           AsyncCallback cb, 
                           object extraData )
    {
        _ctx = ctx;
        _cb = cb;
        _extraData = extraData;
    }

    internal HttpContext _ctx;
    internal AsyncCallback _cb;
    internal object _extraData;
    private bool _isCompleted = false;
    private ManualResetEvent _callCompleteEvent = null;

    internal void CompleteRequest()
    {
        _isCompleted = true;
        lock (this)
        {
            if (_callCompleteEvent != null)
            {
                _callCompleteEvent.Set();
            }
        }
        // if a callback was registered, invoke it now
        if (_cb != null)
        {
          _cb(this);
        }
    }

    // IAsyncResult interface property implementations
    public object AsyncState           
    { get { return(_extraData);   } }
    public bool CompletedSynchronously 
    { get { return(false);        } }
    public bool IsCompleted            
    { get { return(_isCompleted); } }
    public WaitHandle AsyncWaitHandle
    {
    get
    {
      lock( this )
      {
        if( _callCompleteEvent == null )
        _callCompleteEvent = new ManualResetEvent(false);
      
        return _callCompleteEvent;
      }
    }
    }
}

// From file: AsyncThread.ashx
public class AsyncRequest
{
  private static Random _random = new Random();

  private AsyncRequestState _asyncRequestState;

  public AsyncRequest(AsyncRequestState ars)
  {
    _asyncRequestState = ars;
  }
    
  public void ProcessRequest()
  {
        // read some headers
        string contentType = _asyncRequestState._ctx.Request.ContentType;
        string userAgent = _asyncRequestState._ctx.Request.UserAgent;
        string sgIPPort = _asyncRequestState._ctx.Request.Headers["SGIPPort"];
        string serverPort = _asyncRequestState._ctx.Request.Headers["ServerPort"];

        // simulate waiting on an inh or database operation
        int longWaitsPerThousand = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitsPerThousand"]);
        int shortWaitMin = Int32.Parse(ConfigurationSettings.AppSettings["ShortWaitMin"]);
        int shortWaitMax = Int32.Parse(ConfigurationSettings.AppSettings["ShortWaitMax"]);
        int longWaitMin = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitMin"]);
        int longWaitMax = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitMax"]);

        int type = _random.Next(1000);
        int sleep = 0;
        if (type < longWaitsPerThousand)
        {
            sleep = _random.Next(longWaitMin, longWaitMax);
        }
        else
        {
            sleep = _random.Next(shortWaitMin, shortWaitMax);
        }
        Thread.Sleep(sleep);

        _asyncRequestState._ctx.Response.ContentType = "text/html";
        _asyncRequestState._ctx.Response.StatusCode = 200;
        _asyncRequestState._ctx.Response.Write("<p>Welcome to XNullRequest.AsyncProcessRequest\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>ContentType was: " + contentType + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>UserAgent was: " + userAgent + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>SGIPPort was: " + sgIPPort + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>ServerPort was: " + serverPort + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>Sleep was: " + sleep + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>LongWaitsPerThousand was: " + longWaitsPerThousand + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>ShortWaitMin was: " + shortWaitMin + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>ShortWaitMax was: " + shortWaitMax + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>LongWaitMin was: " + longWaitMin + "\n</p>");
        _asyncRequestState._ctx.Response.Write("<p>LongWaitMax was: " + longWaitMax + "\n</p>");

        // tell asp.net I am finished processing this request
        _asyncRequestState.CompleteRequest();
  }
}

public class XNullRequest : IHttpAsyncHandler
{ 
  public void ProcessRequest(HttpContext ctx)
  {
    // not used
  }

  public bool IsReusable
  {
    get { return false;}
  }

  public IAsyncResult BeginProcessRequest(HttpContext ctx, 
                                          AsyncCallback cb, 
                                          object obj)
  {
    AsyncRequestState reqState = 
                      new AsyncRequestState(ctx, cb, obj);
    AsyncRequest ar = new AsyncRequest(reqState);
    ThreadStart ts = new ThreadStart(ar.ProcessRequest);
    Thread t = new Thread(ts);
    t.Start();
  
    return reqState;
  }

  public void EndProcessRequest(IAsyncResult ar)
  {
    // This will be called on the manually created thread in response to 
    // calling the ASP.NET AsyncCallback delegate once the request has
    // completed processing. The incoming IAsyncResult parameter will be 
    // a reference to the AsyncRequestState class, so the Context can be
    // accessed through that class. Note - you *cannot* access the 
    // current context using the HttpContext.Current property, as you are 
    // running on your own thread which has not been initialized with a 
    // context reference.
    AsyncRequestState ars = ar as AsyncRequestState;
    if (ars != null)
    {
     // here you could perform some cleanup, write something else to the
     // Response, or whatever else you need to do
    }
  }
}

// ---------------------------------------------------------------------------
// XNullRequest class - entry point for null requests
// ---------------------------------------------------------------------------
/*
public class XNullRequest : IHttpAsyncHandler
{
    private static Random _random = new Random();

    public IAsyncResult BeginProcessRequest(
        HttpContext ctx,
        AsyncCallback asyncCallback,
        object extraData)
    {
        
    }

    public void ProcessRequest(HttpContext ctx)
    {
        // read some headers
        string contentType = ctx.Request.ContentType;
        string userAgent = ctx.Request.UserAgent;
        string sgIPPort = ctx.Request.Headers["SGIPPort"];
        string serverPort = ctx.Request.Headers["ServerPort"];

        // simulate waiting on an inh or database operation
        int longWaitsPerThousand = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitsPerThousand"]);
        int shortWaitMin = Int32.Parse(ConfigurationSettings.AppSettings["ShortWaitMin"]);
        int shortWaitMax = Int32.Parse(ConfigurationSettings.AppSettings["ShortWaitMax"]);
        int longWaitMin = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitMin"]);
        int longWaitMax = Int32.Parse(ConfigurationSettings.AppSettings["LongWaitMax"]);

        int type = _random.Next(1000);
        int sleep = 0;
        if (type < longWaitsPerThousand)
        {
            sleep = _random.Next(longWaitMin, longWaitMax);
        }
        else
        {
            sleep = _random.Next(shortWaitMin, shortWaitMax);
        }
        Thread.Sleep(sleep);

        ctx.Response.ContentType = "text/html";
        ctx.Response.StatusCode = 200;
        ctx.Response.Write("<p>Welcome to XNullRequest.ProcessRequest\n</p>");
        ctx.Response.Write("<p>ContentType was: " + contentType + "\n</p>");
        ctx.Response.Write("<p>UserAgent was: " + userAgent + "\n</p>");
        ctx.Response.Write("<p>SGIPPort was: " + sgIPPort + "\n</p>");
        ctx.Response.Write("<p>ServerPort was: " + serverPort + "\n</p>");
        ctx.Response.Write("<p>Sleep was: " + sleep + "\n</p>");
        ctx.Response.Write("<p>LongWaitsPerThousand was: " + longWaitsPerThousand + "\n</p>");
        ctx.Response.Write("<p>ShortWaitMin was: " + shortWaitMin + "\n</p>");
        ctx.Response.Write("<p>ShortWaitMax was: " + shortWaitMax + "\n</p>");
        ctx.Response.Write("<p>LongWaitMin was: " + longWaitMin + "\n</p>");
        ctx.Response.Write("<p>LongWaitMax was: " + longWaitMax + "\n</p>");
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xrlscan_none_12.4.56.0_none_9abf3fa1181358ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xrlscan
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.manifest
XP_MANIFEST_PATH=manifests\x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.cat
XP_CATALOG_PATH=manifests\x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.cat
XP_PAYLOAD_PATH=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xrlscan,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\XrlScan.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name: xrlscan

Abstract:


Author: natalyp

--*/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <httpfilt.h>
#include <stdio.h>

//SGInfo COM obj
#include <atlbase.h>
#include <atlcom.h>

#include <xsginfo.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;
#include <commonconfig.h>
#include <mscoree.h>

// tracing and NT events
#include <xmgmt.h>
#include <xeventids.h>
#include <assert.h>

#include <cutil.h>
#include <locks.h>

XomDefineArea(DefaultTrace);

#include <wsockntp.h>
#include <xonlinep.h>
#include "OleDbWrapper.h"
#include "ConfigListener.h"

// ipv4 can be 15, ipv6 can be 39.   add one for null termination
#define STRING_IP_SIZE 40
#define STRING_PORT_SIZE 6

#define SG_INFO_ADDR_HEADER_NAME "SGIPPort:"
#define SERVER_PORT_HEADER_NAME "ServerPort:"

#define MAX_URL_LENGTH 1024

#define MAX_ALL_HEADERS 1024

#define MAX_SIZE_TO_PRINT MAX_URL_LENGTH
#define REQ_FAILURE_INFO "Http request failed to pass validation tests. Port [%d], Url [%s], failure reason [%s], value [%s]"
#define REQ_FAILURE_INFO_SIZE sizeof(REQ_FAILURE_INFO)

static const DWORD XRL_MAX_LENGTH         = 80;
static const DWORD HTTP_VERBS_MAX_LENGTH  = 64;

static const DWORD HTTP_FLAG_DELETE       =  1;
static const DWORD HTTP_FLAG_GET          =  2;
static const DWORD HTTP_FLAG_POST         =  4;
static const DWORD HTTP_FLAG_PUT          =  8;

typedef struct _XRLINFO
{
    char        szXrl[XRL_MAX_LENGTH + 1];
    ULONG       lMaxUrlLength;
    LONG        lMaxContentLength; // signed because -1 signifies don't check.
    ULONG       lMaxQueryStringLength;
    DWORD       dwPort;
    char        fAllowTextXmlContentType;
    char        fDontGetSGInfo;
    char        fAllowNoExactMatch;
    char        fBlockLimitedPCAccount;
    char        szHttpVerbs[HTTP_VERBS_MAX_LENGTH + 1];
    DWORD       dwHttpFlags;
} XRLINFO, *PXRLINFO;

typedef struct _XRLMAPPINGS
{
    PXRLINFO    pValidXrls;
    DWORD       dwMaxXrls;
    DWORD       dwCurXrls;
} XRLARRAY, *PXRLARRAY;

static const DWORD SETTING_MAX_LENGTH = 256;
static const DWORD VALUE_MAX_LENGTH = 3700;

typedef struct _XRLSETTNG
{
    char    szSetting[SETTING_MAX_LENGTH + 1];
    char    szValue[VALUE_MAX_LENGTH + 1];
} XRLSETTING, *PXRLSETTING;

XRLARRAY            g_ValidXrls = { NULL, 0, 0 };   //the current set of xrls
HANDLE              g_hLoadingConfigEvent = NULL;   //set if we're reloading t_xrl_virtual_interface_mappings table.
// CReaderWriterLock3  g_configLock;
LONG                g_lRequestCount = 0;            //count of requests we're currently handling
VARIANT_BOOL        g_fAllowHead = FALSE;
CComPtr<IConfig>    g_pConfig;                      //holds a pointer to the config interop instance
CComBSTR            g_bsServer;                     //local server name

char*               g_rszValidContentTypes[256] = {0};
XRLSETTING          g_sValidContentTypes = {{0}, {0}};

typedef TLocalStr<MAX_SIZE_TO_PRINT*3+ REQ_FAILURE_INFO_SIZE> CRequestInfoStr;
typedef TLocalStr<MAX_ALL_HEADERS> CHeadersStr;

#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))

VOID
GetIpAddress(
    HTTP_FILTER_CONTEXT *           pfc,
    IN_ADDR *                       ulIp,
    USHORT*                         pwPort );

VOID 
GetHostHeaderIpAddress(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreprocHeaders,
    IN_ADDR *                       ulIp );

VOID
GetAllHeaders (
    HTTP_FILTER_CONTEXT *           pfc,
    CHeadersStr &                   szHeaders
    );

VOID
LogClientInfo(
    HTTP_FILTER_CONTEXT *           pfc,
    LPCSTR                          pszRequestInfo,
    PXRLINFO                        pXrlInfo = NULL
    );

BOOL
IsValidXrl(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    );

BOOL
AddSGInfoAddrHeader(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    );

BOOL
GetServerPort(
    HTTP_FILTER_CONTEXT *           pfc,
    DWORD &                         dwPort
    );

BOOL
AddServerPortHeader(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    );


HRESULT InitFilter(
     );

HRESULT ReadConfig(
     );

HRESULT AddXrl(
    XRLINFO&                        xrlInfo,
    XRLARRAY&                       xrls
    );

BOOL IsMatchingPort(
    DWORD reqPort,
    DWORD aclPort
    );

DWORD ParseVerbs(
    char * pszHttpVerbs
);

BOOL IsIPv6Address(
    char * pszAddress
);

void
DoSendResponse(
    HTTP_FILTER_CONTEXT * pFilterContext,
    HTTP_FILTER_SEND_RESPONSE * pFilterSendResponse
);

HRESULT ReadContentTypesConfig(
    BSTR bsConnectionString
    ,LPCWSTR pAppPoolId
    ,LPCWSTR pVrootName
 );

BOOL IsValidContentType(
    LPCSTR pContentType
    );

class XrlScanConfigListener : public CConfigListenerBase
{

    STDMETHODIMP    XrlMappingsChange()
    {
        return ReadConfig();
    }

    STDMETHODIMP    SettingChange(struct ISettingChangeEventArgs * e)
    {
/*
        CComBSTR bstrSetting;
        CComBSTR bstrValue;

        e->get_Setting(&bstrSetting);
        e->get_ValueNew(&bstrValue);

        if(wcscmp(bstrSetting.m_str, L"xrlscan_allowHead") == 0)
        {
            //  The logic below is ported from
            //  config.cs(6246).
            g_fAllowHead = (
                wcscmp(bstrValue.m_str, L"1") == 0 ||
                wcscmp(bstrValue.m_str, L"yes") == 0 ||
                wcscmp(bstrValue.m_str, L"true") == 0 ||
                wcscmp(bstrValue.m_str, L"on") == 0 ) ? VARIANT_TRUE : VARIANT_FALSE;
        }
*/
        return S_OK;
    }

    ULONG __stdcall AddRef() { return 1; }
    ULONG __stdcall Release() { return 1; }
    STDMETHODIMP    QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
        }
        else if(riid == __uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }

};

XrlScanConfigListener* g_pXrlScanConfigListener = NULL;

BOOL APIENTRY DllMain(
    HANDLE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
    )
{
    if(ul_reason_for_call == DLL_PROCESS_DETACH)
    {
        if(g_pConfig != NULL)
        {
            g_pConfig->putref_ConfigListener(NULL);
            g_pConfig.Release();
        }

        if(g_pXrlScanConfigListener != NULL)
        {
            delete g_pXrlScanConfigListener;
            g_pXrlScanConfigListener = NULL;
        }
    }

    return TRUE;
}


//
// ISAPI entry point implementations
//

BOOL
WINAPI
GetFilterVersion(
    PHTTP_FILTER_VERSION    pVer
    )
/*++

  Required entry point for ISAPI filters.  This function
  is called when the server initially loads this DLL.

  Arguments:

    pVer - Points to the filter version info structure

  Returns:

    TRUE on successful initialization
    FALSE on initialization failure

--*/
{
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    const char cszDescription[] = "XRlScan ISAPI Filter";
    DWORD dwSize = min (strlen(cszDescription), SF_MAX_FILTER_DESC_LEN-1);
    strncpy( pVer->lpszFilterDesc, cszDescription, dwSize );
    pVer->lpszFilterDesc[dwSize] = '\0';

    pVer->dwFlags = SF_NOTIFY_ORDER_HIGH | SF_NOTIFY_PREPROC_HEADERS;
    TCHAR szAppPoolId[MAX_PATH];

    // if application pool is catalog, xbos, or MarketplaceCatalog then we  need
    // need to do additional  processing  on  the  response

    if (GetEnvironmentVariable(_T("APP_POOL_ID"), szAppPoolId, ARRAYSIZE(szAppPoolId)))
    {
        if ((_tcsicmp(szAppPoolId, _T("catalog-Catalog")) == 0) ||
            (_tcsicmp(szAppPoolId, _T("XBOS-xbos"))       == 0) ||
            (_tcsicmp(szAppPoolId, _T("MarketplaceCatalog-MarketplaceCatalog")) == 0))
        {
            pVer->dwFlags |= SF_NOTIFY_SEND_RESPONSE;
        }
    }

    HRESULT hr = InitFilter();
    if(FAILED(hr))
    {
        XomTrace(DefaultTrace, L_ERROR, "Failure in InitFilter(), hr [0x%x]",hr);
        return FALSE;
    }
    return TRUE;
}


class CXrlScanControlCallback : public CXomControlCallback
{
public:

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );
} g_XrlScanControlCallback;


HRESULT CXrlScanControlCallback::OnControlRequest(
                LPCSTR pszRequest,
                DWORD dwRequestId,
                CXomControlResponseInterface* pResponseInterface )
{
    HRESULT hr;
    CXomParamList xompl;

    hr = xompl.Parse(pszRequest);
    if (FAILED(hr))
    {
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Command parse error. %x", hr );
        goto Cleanup;
    }

    DWORD  cParam = xompl.GetCount();
    LPCSTR pszCmd = xompl.GetParam( 0 );

    if (cParam == 0)
    {
        hr = S_OK;
        goto Cleanup;
    }

//345678901234567890123456789012345678901234567890123456789012345678901234567890
    char * szHelpText = "\n\n \
XrlScan Commands:\n \
  reload_mappings              : Force Xrl mappings to be reload\n \
  list_mappings                : Enumerate currently loaded mappings\n \
";

    if (_strcmpi(pszCmd, "help") == 0)
    {
        pResponseInterface->WriteResponse(
            dwRequestId,
            (BYTE *) szHelpText,
            (DWORD)-1
            );
    }
    else if (_strcmpi(pszCmd, "reload_mappings") == 0)
    {
        HRESULT _hr = ReadConfig();
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            SUCCEEDED(_hr) ? "Mappings reloaded successfully." : "Read config completed, hr=0x%08x.",
            _hr
            );
        hr = S_OK;
    }
    else if (_strcmpi(pszCmd, "list_mappings") == 0)
    {
        WCHAR szAppPoolId[MAX_PATH];

        ZeroMemory(szAppPoolId, sizeof(szAppPoolId));
        GetEnvironmentVariable(_T("APP_POOL_ID"), szAppPoolId, ARRAYSIZE(szAppPoolId));

        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "%d mappings loaded for AppPool:%S (HEAD requests allowed: %s)%\n",
            g_ValidXrls.dwCurXrls,
            szAppPoolId,
            g_fAllowHead == VARIANT_TRUE ? "true" : "false"
            );
        for (DWORD i = 0; i < g_ValidXrls.dwCurXrls; i++)
        {
            XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "%s\n"
                " Port:%d\tExact Match:%d\tGet SG Info:%d\tBlock Limited:%d\ttext/xml ok:%d\tHttpVerbs: %s\n",
                g_ValidXrls.pValidXrls[i].szXrl,
                g_ValidXrls.pValidXrls[i].dwPort,
                !g_ValidXrls.pValidXrls[i].fAllowNoExactMatch,
                !g_ValidXrls.pValidXrls[i].fDontGetSGInfo,
                g_ValidXrls.pValidXrls[i].fBlockLimitedPCAccount,
                g_ValidXrls.pValidXrls[i].fAllowTextXmlContentType,
                g_ValidXrls.pValidXrls[i].szHttpVerbs
                );
        }
    }

Cleanup:
    return hr;
}

HRESULT InitFilter(
    )
{
    XomTrace(DefaultTrace, L_INFO, "XrlScan.InitFilter");

    // Always start the server CLR up in the IIS processes.
    CComPtr<ICorRuntimeHost> pHost;

    HRESULT hr = CorBindToRuntimeEx(
        L"v2.0.50727",
        L"svr",
        STARTUP_SERVER_GC | STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST | STARTUP_ALWAYSFLOW_IMPERSONATION,
        CLSID_CorRuntimeHost,
        IID_ICorRuntimeHost,
        (LPVOID*)&pHost);
    if (FAILED(hr))
    {
        // Can't trace, as there is no config loaded yet.  This is to start the CLR, so must happen before XomCentral.Init()
        goto Cleanup;
    }

    hr = pHost->Start();
    if (FAILED(hr))
    {
        // Can't trace, as there is no config loaded yet.  This is to start the CLR, so must happen before XomCentral.Init()
        goto Cleanup;
    }


    hr = g_xomcentral.Init("xrlscan");
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.InitFilter: g_xomcentral.Init failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_0, "XrlScan.InitFilter: g_xomcentral.Init failed with 0x%X", hr);
        goto Cleanup;
    }

    //  Create the loading event
    g_hLoadingConfigEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if(g_hLoadingConfigEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.InitFilter: CreateEvent failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_0, "XrlScan.InitFilter: CreateEvent failed with 0x%X", hr);
        goto Cleanup;
    }

    //  Create the loading event
    hr = g_xomcentral.RegisterControlCallback( &g_XrlScanControlCallback );
    if( FAILED( hr ) )
    {
        // complain, but start anyway.
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.InitFilter: g_xomcentral.RegisterControlCallback failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_0, "XrlScan.InitFilter: g_xomcentral.RegisterControlCallback failed with 0x%X", hr);
        goto Cleanup;
    }

    //  Instantiate config interop

    g_pConfig = g_xomcentral.GetConfigPtr();
//    hr = g_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (!g_pConfig)
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.InitFilter: g_xomcentral.GetConfigPtr returned NULL");
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_0, "XrlScan.InitFilter: g_xomcentral.GetConfigPtr returned NULL");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //  Setup notification handler
    g_pXrlScanConfigListener = new XrlScanConfigListener();
    g_pConfig->putref_ConfigListener((IConfigListener*)g_pXrlScanConfigListener);

    hr = ReadConfig();

Cleanup:

    return hr;
}


DWORD
WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT    pfc,
    DWORD                   dwNotificationType,
    LPVOID                  pvNotification
    )
/*++

  Required filter notification entry point.  This function is called
  whenever one of the events (as registered in GetFilterVersion) occurs.

  Arguments:

    pfc              - A pointer to the filter context for this notification
    NotificationType - The type of notification
    pvNotification   - A pointer to the notification data

  Returns:


--*/
{
    DWORD dwReturn;

    WaitForSingleObject(g_hLoadingConfigEvent, INFINITE);
//    CAutoReadLock<CReaderWriterLock3> oLock(g_configLock);
    InterlockedIncrement(&g_lRequestCount);

    switch ( dwNotificationType )
    {
    case SF_NOTIFY_SEND_RESPONSE:
        DoSendResponse(pfc, (HTTP_FILTER_SEND_RESPONSE *) pvNotification);
        dwReturn = SF_STATUS_REQ_NEXT_NOTIFICATION;

        break;

    case SF_NOTIFY_PREPROC_HEADERS:
        {
            CRequestInfoStr szCurReqInfo;

            if (IsValidXrl( pfc, (HTTP_FILTER_PREPROC_HEADERS *)pvNotification, szCurReqInfo) )
            {
                dwReturn = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
            else
            {
                LogClientInfo(pfc, szCurReqInfo.cstr());
                SetLastError( ERROR_FILE_NOT_FOUND );
                dwReturn = SF_STATUS_REQ_ERROR;
                break;
            }
        }

    default:
        dwReturn = SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    InterlockedDecrement(&g_lRequestCount);
    return dwReturn;
}


void
DoSendResponse(
    HTTP_FILTER_CONTEXT * pFilterContext,
    HTTP_FILTER_SEND_RESPONSE * pSendResponse
)
{
    char szXrlHeader[1024];
    DWORD lszXrlHeader = sizeof(szXrlHeader);

    char szHttpHeader[1024];
    DWORD lszHttpHeader = sizeof(szHttpHeader);

    DWORD hr = S_OK;

    // if there is an X-Cache-Control header then use it to
    // overwrite existing or add a new cache-control header

    if (pSendResponse->GetHeader(pFilterContext, "X-Cache-Control:", szXrlHeader, &lszXrlHeader))
    {
        // delete the X-Cache-Control header.  if we  faill
        // keep going.   we may get lucky adding new header

        szHttpHeader[0] = '\0';
        if (! pSendResponse->SetHeader(pFilterContext, "X-Cache-Control:", szHttpHeader))
        {
            hr = GetLastError();
        }

        // if there's an existing header then we replace it
        // and YES, we may overwrite an earlier error  here

        if (pSendResponse->GetHeader(pFilterContext, "Cache-Control:", szHttpHeader, &lszHttpHeader))
        {
            if (! pSendResponse->SetHeader(pFilterContext, "Cache-Control:", szXrlHeader))
            {
                hr = GetLastError();
            }
        }
        else
        {
            // it's okay if it's not there, we will add one
            if ((hr = GetLastError()) == ERROR_INVALID_INDEX)
            {
                hr = pSendResponse->AddHeader(pFilterContext, "Cache-Control:", szXrlHeader) ? S_OK : GetLastError();
            }
        }

    }

    else
    {
        // it is okay if it is not there,   that just means
        // response is not  overriding  the  cache  control

        if ((hr = GetLastError()) == ERROR_INVALID_INDEX)
        {
            hr = S_OK;
        }
    }


    if (hr != S_OK)
    {
        LogClientInfo(pFilterContext, "Error replacing cache-control headers");
    }
}

BOOL
IsValidFileChar(
    char ch
    )
{
    switch (ch)
    {
    case '\\':
    case '?':
    case '"':
    case '<':
    case '>':
    case '|':
    case '*':
        return false;
    }
    return true;
}

BOOL
IsValidQueryChar(
    char ch
    )
{
    switch (ch)
    {
        // These characters are required to add form parameters
    case '?':
    case '=':
    case '&':
    case '%':
    case '+':

        // These, according to 3986, should always be decoded on transmission (even if encoded), so allow them as well.
    case '_':
    case '-':
    case '.':

        // These are allowed simply because .Net allows them, I can't really find any other reason to leave these here.
    case ',':
    case '\'':
    case '(':
    case ')':
    case '*':
    case '!':
    case '~':
        return true;
    }
    return false;
}
/*++

  Verifies the validity of the http request.

--*/
BOOL
IsValidXrl(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    )
{
    USES_CONVERSION;

    ULONG lszUrl;
    char szUrl[MAX_URL_LENGTH];
    char szQuery[MAX_URL_LENGTH];

    CSmallStr szParam;

    DWORD dwPort = 0;

    BOOL bIsValid = FALSE;
    BOOL bIsQueryStringFound = FALSE;

    LPSTR pszCurTest;

    PXRLINFO pXrlInfo = NULL;

    pszCurTest = "Cannot retrieve url";

    szUrl[0] = '\0';

    // check url size
    lszUrl = sizeof(szUrl);
    if (!pPreproc->GetHeader( pfc, "url", szUrl, &lszUrl ))
    {
        XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve url from http header, error = [0x08%x]", GetLastError());
        goto Cleanup;
    }
    lszUrl--; // Remove terminating null character

    //  Separate query string from url

    SIZE_T lUrlLen =  lszUrl;
    SIZE_T lQueryLen = 0;

    CHAR* pQueryStr = strchr(szUrl,'?');
    if (pQueryStr != NULL)
    {
        // ouch it's a Get request, find url in the string
        bIsQueryStringFound = TRUE;
        lUrlLen = (pQueryStr - szUrl);
        lQueryLen = lszUrl - lUrlLen;

        // Copy the query portion away, including the trailing null)
        memcpy( szQuery, pQueryStr, lQueryLen + 1);
    }

    XomTrace(DefaultTrace, L_LOW,  "URL is :%s ",szUrl);
    // keep the url for further tests

    pszCurTest = "Failed to retrieve server port";
    if (!GetServerPort( pfc, dwPort ))
    {
        XomTrace(DefaultTrace, L_ERROR, "Failed to retrieve server port from request. error = [0x%08x]", GetLastError());
        szParam.Format("err=%d", GetLastError());
        goto Cleanup;
    }

    // Normalize URL
    pszCurTest = "Unable to normalize Url";
    if (!pfc->ServerSupportFunction( pfc, SF_REQ_NORMALIZE_URL, szUrl, NULL, NULL ))
    {
        XomTrace(DefaultTrace, L_ERROR, "Url cannot be normalized, error = [0x%08x] URL: %s", GetLastError(), szUrl);
        szParam.Format("err=%d", GetLastError());
        goto Cleanup;
    }
    lUrlLen = lszUrl = strlen( szUrl ); // Get the length of the normalized string, without the terminating null character

    XomTrace(DefaultTrace, L_LOW,  "Normalized (Raw) URL is :%s ",szUrl);
    XomTrace(DefaultTrace, L_LOW,  "Non-Query URL Length is: %d ", lUrlLen );

    pszCurTest = "Invalid character is found in the url";
    char *pCur = szUrl;

    // We apply maximum character checks to the non-query portion of the URL
    while (pCur < (szUrl + lUrlLen))
    {
        if (!isalnum(*pCur) && (*pCur != '/'))
        {
            if(*pCur == '.')
            {
                // Safe to check because the string is NULL terminated, so at worst, the check will see '\0'
                if(*(pCur + 1) == '.')
                {
                    pszCurTest = "Invalid double dot character is found in the url";

                    XomTrace(DefaultTrace, L_ERROR, "Invalid double character [%c] found in url [%s]", *pCur, szUrl);
                    szParam.Format("%c", *pCur);
                    goto Cleanup;
                }
            }
            else if (!IsValidFileChar(*pCur))
            {
                    XomTrace(DefaultTrace, L_ERROR, "Invalid character [%c] found in url [%s]", *pCur, szUrl);
                    szParam.Format("%c", *pCur);
                    goto Cleanup;
            }
        }

        pCur++;
    }

    // Append back the query portion of the URL
    if (bIsQueryStringFound) 
    {
        pszCurTest = "Unable to add query string to Url";

        // Sanity check the lengths
        if ((lQueryLen + lszUrl + 1) > sizeof(szUrl)) 
        {
            XomTrace(
                DefaultTrace, 
                L_ERROR, 
                "Query Url cannot be normalized as it would require %d bytes. xrl [%s] query [%s]",
                (lQueryLen + lszUrl + 1),
                szUrl,
                szQuery
                );
            goto Cleanup;
        }
        memcpy( szUrl + lszUrl, szQuery, lQueryLen + 1 );
        lszUrl = strlen( szUrl ); // Get the length of the normalized string, without the terminating null character

        XomTrace(DefaultTrace, L_LOW,  "Normalized (Full) URL is :%s ",szUrl);
        XomTrace(DefaultTrace, L_LOW,  "Overall URL Length is: %d ", lszUrl );
        XomTrace(DefaultTrace, L_LOW,  "Query URL Length is: %d ", lQueryLen );

        pszCurTest = "Invalid character is found in the query url";

        // Explicitly set the pCur pointer to the start of the query portion.
        // It should have been in this position from when we checked the file
        // portion of the URL, but since the code was refactored to move
        // that check away from here, this was added to make sure that someone
        // doesn't mess it up.
        pCur = szUrl + lUrlLen;

        // Check the query portion of the URL with looser rules
        while (pCur < (szUrl + lszUrl))
        {
            if (!isalnum(*pCur) && (*pCur != '/')) 
            {
                // allow &, _, =, ?, ,, -, %, ., +
                if( !IsValidQueryChar(*pCur) )
                {
                    XomTrace(DefaultTrace, L_ERROR, "Invalid character [%c] found in xrl [%s]", *pCur, szUrl);
                    szParam.Format("%c", *pCur);
                    goto Cleanup;
                }
            }

            pCur++;
        }
    }

    // lookup XRLINFO entry
    pszCurTest = "No port match found";

    // now check that url is in the list of valid Xrl
    if (g_ValidXrls.pValidXrls)
    {
        BOOL bFoundMatch = FALSE;
        int iXrlMatchResult = 2; // I need an invalid value from the standpoint of strnicmp

        for (DWORD i = 0; i < g_ValidXrls.dwCurXrls; i++)
        {
            SIZE_T lCompareLen, lXrlLen;
            LPSTR szTraceMsg;

            //XomTrace(DefaultTrace, L_LOW, "Comparing _strnicmp(%s,%s,%d) result:%d", szUrl, g_pValidXrls[i].szXrl, lUrlLen, _strnicmp(szUrl, g_pValidXrls[i].szXrl, lUrlLen));
            lXrlLen = strlen(g_ValidXrls.pValidXrls[i].szXrl);

            if (!g_ValidXrls.pValidXrls[i].fAllowNoExactMatch)
            {
                lCompareLen = (lUrlLen < lXrlLen ? lXrlLen : lUrlLen);
                szTraceMsg = "Exact match found";
            }
            else
            {
                lCompareLen = lXrlLen;
                szTraceMsg = "Partial match found";
            }

            if ( IsMatchingPort(dwPort, g_ValidXrls.pValidXrls[i].dwPort) &&
                 (iXrlMatchResult = _strnicmp(szUrl, g_ValidXrls.pValidXrls[i].szXrl, lCompareLen) == 0)
               )
            {
                XomTrace(DefaultTrace, L_LOW, szTraceMsg);
                pXrlInfo = &(g_ValidXrls.pValidXrls[i]);
                bFoundMatch = TRUE;
                break;
            }
        }

        if(!bFoundMatch)
        {
            if (iXrlMatchResult != 2)
                pszCurTest = "No matching xrl found";

            goto Cleanup;
        }
    }
    else
    {
        goto Cleanup;
    }

    //  Check lengths
    if ((lszUrl-lUrlLen) > pXrlInfo->lMaxQueryStringLength+1)
    {
        pszCurTest = "Query string is too long";
        XomTrace(DefaultTrace, L_ERROR, "Get request has a query string that is longer than maximum allowed");
        goto Cleanup;
    }

    pszCurTest = "Url length is too long";
    if( lUrlLen >= pXrlInfo->lMaxUrlLength)
    {
        XomTrace(DefaultTrace, L_ERROR, "Url of size [%lu] is too long. Max allowed is [%lu]", szUrl, pXrlInfo->lMaxUrlLength);
        goto Cleanup;
    }

    // check method
    pszCurTest = "No HTTP method found";

    ULONG lszMethod;
    if (!pPreproc->GetHeader( pfc, "method", szParam.StartWrite((UINT32*)&lszMethod), &lszMethod ))
    {
        szParam.EndWrite(0);
        XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve method, hr = [0x%x]", GetLastError());
        szParam.Format("err=%d", GetLastError());
        goto Cleanup;
    }
    lszMethod--; // Remove terminating null character
    szParam.EndWrite(lszMethod);

    const char *szMethod = szParam.cstr();
    BOOL bIsPostOrPut = (_stricmp(szMethod, "POST") == 0) || (_stricmp(szMethod, "PUT") == 0);
    XomTrace(DefaultTrace, L_LOW, "bIsPostOrPut = [%d]", bIsPostOrPut);

    pszCurTest = "Invalid HTTP method";

    // head is controlled by a single setting and overridden by some components
    if (_stricmp(szMethod, "HEAD") == 0)
    {
        if (g_fAllowHead == VARIANT_FALSE) {
            XomTrace(DefaultTrace, L_ERROR, "HEAD method is currently disallowed by configuration setting.");
            goto Cleanup;
        }
    }

    // for all other verbs they have to be enabled for the matching specific XRL
    else if (! (((_stricmp(szMethod, "GET")    == 0) && (pXrlInfo->dwHttpFlags & HTTP_FLAG_GET))    ||
                ((_stricmp(szMethod, "POST")   == 0) && (pXrlInfo->dwHttpFlags & HTTP_FLAG_POST))   ||
                ((_stricmp(szMethod, "PUT")    == 0) && (pXrlInfo->dwHttpFlags & HTTP_FLAG_PUT))    ||
                ((_stricmp(szMethod, "DELETE") == 0) && (pXrlInfo->dwHttpFlags & HTTP_FLAG_DELETE))))
    {
        XomTrace(DefaultTrace, L_ERROR, "[%s] method is invalid.", szMethod);
        goto Cleanup;
    }

    XomTrace(DefaultTrace, L_LOW, "Method=[%s]", szMethod);
    szParam.Reset();

    if (bIsPostOrPut)
    {
        //  If max content length is -1, then bypass all content length checks.
        if(pXrlInfo->lMaxContentLength != -1)
        {
            // check content length
            pszCurTest = "Content-length field too big or not found";

            ULONG lszContentLength = 0;
            if (!pPreproc->GetHeader( pfc, "Content-Length:", szParam.StartWrite((UINT32*)&lszContentLength), &lszContentLength ))
            {
                szParam.EndWrite(0);
                XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve content length, hr = [0x%x]", GetLastError());
                szParam.Format("err=%d", GetLastError());
                goto Cleanup;
            }
            lszContentLength--; // Remove terminating null character
            szParam.EndWrite(lszContentLength);

            pszCurTest = "Content-length is too big";
            const char *szContentLength = szParam.cstr();
            LONG lContentLength = atol(szContentLength);
            if ( ( (ULONG) lContentLength) > ( (ULONG) pXrlInfo->lMaxContentLength) )
            {
                XomTrace(DefaultTrace, L_ERROR, "Content-length: is too long. Current [%lu]/max [%lu]",
                    lContentLength, pXrlInfo->lMaxContentLength);
                goto Cleanup;
            }
            XomTrace(DefaultTrace, L_LOW, "ContentLen = [%d]", lContentLength);

            szParam.Reset();
        }

        // check Content-Type:
        pszCurTest = "Content-type field too big or not found";
        ULONG lszContentType = 0;
        if (!pPreproc->GetHeader( pfc, "Content-Type:", szParam.StartWrite((UINT32*)&lszContentType), &lszContentType ))
        {
            szParam.EndWrite(0);
            XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve Content-Type from http header, hr = [0x%x]", GetLastError());
            szParam.Format("err=%d", GetLastError());
            goto Cleanup;
        }
        lszContentType--; // Remove terminating null character
        szParam.EndWrite(lszContentType);
        szParam.ToLower();

        const char *szContentType = szParam.cstr();
        // content type should regularly be "xon/X"
        // allow text/xml content type only if configured explicitly
        // the valid content types are xon/ServiceId or text/xml if configured
        if(0 == strncmp("xon/", szContentType, sizeof("xon/") - 1))
        {
            pszCurTest = "Invalid ServiceId";

            for ( const char* pCurDigit = szContentType + sizeof("xon/") - 1; pCurDigit < szContentType + lszContentType; pCurDigit++)
            {
                if (!isxdigit((unsigned char)*pCurDigit))
                {
                    XomTrace(DefaultTrace, L_ERROR, "Invalid serviceId: %s", szContentType);
                    goto Cleanup;
                }
            }
        }
        else if (! pXrlInfo->fAllowTextXmlContentType ||
                 ! IsValidContentType(szContentType))
        {
            pszCurTest = "Invalid content-type";
            XomTrace(DefaultTrace, L_ERROR, "Invalid content type [%s]", szContentType);
            goto Cleanup;
        }

        szParam.Reset();
    }

    pszCurTest = "blocked limited pc account";

    // The port check is for the special case where we allow an internal port for an
    // Xrl that is declared for the public interface.  The only time the ports should not match is in
    // this case, so we don't do limited account checking in this case.
    //
    // Since the SG does not allow calls to internal interfaces from clients, it is not possible
    // for an external caller to have the port be an internal interface.
    if (pXrlInfo->fBlockLimitedPCAccount && dwPort == pXrlInfo->dwPort)
    {
        IN_ADDR ulClientIP;
        ulClientIP.s_addr = 0;
        USHORT nClientPort = 0XFFFF;

        // Note: Get rid of the CAuthData3 version after the Berlin Release
        BYTE rgbBuffer[ CBSGSPIREPMSG ];
        CSgMsgSpiRep* pSpiRep = (CSgMsgSpiRep*) rgbBuffer;
        CSgMsgSpiData* pSpiData = (CSgMsgSpiData*)( pSpiRep + 1 );
        CSgMsgHdr* pAuthHdr = (CSgMsgHdr*)( pSpiData + 1 );
        CAuthData4* pAuthData = (CAuthData4*)( pAuthHdr + 1 );
        CAuthData3* pAuthData3 = (CAuthData3*)( pAuthHdr + 1 );

        GetIpAddress( pfc, &ulClientIP, &nClientPort);

        HRESULT hr = GetSGInfo( ulClientIP.s_addr, nClientPort, pSpiRep, sizeof( rgbBuffer ) );
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_XRLSCAN_LIMITED_NO_SGINFO,
                "Unable to acquire sginfo for limited account check, not blocking call.\n\n"
                "Xrl=%s\n\nThe request is sent by IpZ [%s], PortZ[%d]. AuthData unavailable hr [0x%08x]. ",
                    szUrl, inet_ntoa(ulClientIP), nClientPort, hr);
            XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve SGInfo for LMA blocking. xrl [%s], hr [0x%x]",szUrl,hr);
        }
        else
        {
            if (pAuthData->wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
            {
                if (IS_PC_MACHINE_PUID(pAuthData->qwXboxID) && (pAuthData->dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE))
                {
                    szParam.Format("%016I64x", pAuthData->qwXboxID);
                    XomTrace(DefaultTrace, L_ERROR, "Invalid Limited PC account request blocked.");
                    goto Cleanup;
                }
            }
            else if (pAuthData->wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION)
            {
                if (IS_PC_MACHINE_PUID(pAuthData3->qwXboxID) && (pAuthData3->dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE))
                {
                    szParam.Format("%016I64x", pAuthData3->qwXboxID);
                    XomTrace(DefaultTrace, L_ERROR, "Invalid Limited PC account request blocked.");
                    goto Cleanup;
                }
            }
        }
        szParam.Reset();
    }

    //
    //  Bug 174395 - We had a client that was sending up a host header containing 
    //  pseudo-random IP addresses.  This caused .NET to cache the XML Serializer assemblies
    //  once for each distinct host header value, which eventually lead to
    //  out of memory conditions on the machine.  Specifically, the IP address sent
    //  up always contained zero for the high octet.
    //
    //  To combat this issue, XrlScan overwrites the host header with the
    //  local machine name.
    //

    IN_ADDR ipAddr;

    GetHostHeaderIpAddress( pfc, pPreproc, &ipAddr );

    // If the high octet is zero, replace the host header with the local server name.
    if ((ipAddr.s_addr & 0x000000ff) == 0)
    {
        if (! pPreproc->SetHeader(pfc, "Host:", OLE2A(g_bsServer.m_str)))
        {
            XomTrace(DefaultTrace, L_ERROR, "Failed to set host header.");
            goto Cleanup;
        }
    }

    if (!AddSGInfoAddrHeader(pfc, pPreproc, szCurRequestInfo))
    {
        // we were not able to add the header, so reject the request
        pszCurTest = "Error adding SGInfoAddr header";
        szParam.Format("err=%d", GetLastError());
        XomTrace(DefaultTrace, L_ERROR, "Unable to add SGInfoAddr http header [%d]", GetLastError());
        goto Cleanup;
    }

    if (!AddServerPortHeader(pfc, pPreproc, szCurRequestInfo))
    {
        // we were not able to add the header, so reject the request
        pszCurTest = "Error adding ServerPort header";
        szParam.Format("err=%d", GetLastError());
        XomTrace(DefaultTrace, L_ERROR, "Unable to add ServerPort http header [%d]", GetLastError());
        goto Cleanup;
    }

    bIsValid = TRUE;

Cleanup:
    if ( !bIsValid )
    {
        szCurRequestInfo.Format(REQ_FAILURE_INFO, dwPort, szUrl, pszCurTest, szParam.IsEmpty() ? "NULL" : szParam.cstr());
        int nChar = szCurRequestInfo.GetLength();

        // substitute all not printable chars
        for (int i = 0; i < nChar; i++)
        {
            if (!isprint(szCurRequestInfo[i]) || szCurRequestInfo[i] == '%')
            {
                szCurRequestInfo[i] = '!';
            }
        }
    }
    else // valid xrl, nobody cares what it is
    {
        szCurRequestInfo.Reset();
    }

    XomTrace(DefaultTrace, L_LOW,  "IsValidXrl returns:%d, %s", bIsValid, szCurRequestInfo.cstr() );

    return bIsValid;
}

/*++

   Looks up the IP and port the request came from, and adds them to
   the SGInfoAddr http header, to make it faster for C# front doors
   to look up this information. Note that any existing SGInfoAddr header
   will pass through untouched, since the UDP adapter also adds this
   header to http requests it forwards on.

--*/
BOOL
AddSGInfoAddrHeader(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    )
{
    BOOL    bResult;

    // plus 2 in case we need square bracks for an ipv6 port
    DWORD dwHeaderSize = STRING_IP_SIZE + STRING_PORT_SIZE + 2;
    char szHeader[STRING_IP_SIZE + STRING_PORT_SIZE + 2]; // ':' is covered by virtue that the extra char is covered by buffer size.
    memset(szHeader, 0, dwHeaderSize);

    // check to see if there is already a header there. This will be the
    // case if this request came to us via the UDP adapter.
    bResult = pPreproc->GetHeader(pfc, SG_INFO_ADDR_HEADER_NAME, szHeader, &dwHeaderSize);
    if (bResult)
    {
        XomTrace(DefaultTrace, L_LOW, "SGIPPort header already exists, value: [%s]", szHeader);
    }
    else
    {
        // no pre-existing header, so add one
        char szIp[STRING_IP_SIZE];
        memset(szIp, 0, sizeof(szIp));
        DWORD dwIpSize = STRING_IP_SIZE;
        bResult = pfc->GetServerVariable(pfc, "REMOTE_ADDR", szIp, &dwIpSize);
        if(!bResult)
        {
            XomTrace(DefaultTrace, L_LOW,  "Failed to GetServerVariable REMOTE_ADDR, GetLastError:[0x%x]", GetLastError());
            goto error_cleanup;
        }

        BOOL isIPv6 = IsIPv6Address(szIp);
        XomTrace(DefaultTrace, L_LOW, "SGInfo IP Address is : [%s]", szIp);

        char szPort[STRING_PORT_SIZE];
        memset(szPort, 0, sizeof(szPort));
        DWORD dwPortSize = STRING_PORT_SIZE;
        bResult = pfc->GetServerVariable(pfc, "REMOTE_PORT",  szPort, &dwPortSize);
        if(!bResult)
        {
            XomTrace(DefaultTrace, L_LOW,  "Failed to GetServerVariable REMOTE_PORT, GetLastError:[0x%x]", GetLastError());
            goto error_cleanup;
        }
        XomTrace(DefaultTrace, L_LOW, "SGInfo Port is : [%s]", szPort);

        memset(szHeader, 0, sizeof(szHeader));

        // strncpy is considered a generally unsafe function because it doesn't gaurantee
        // that szHeader will be null-terminated. However, I have carefully reviewed this
        // particular usage of it and it is definitely null-terminated in this case.
        // TobiasB
        strncpy(szHeader, szIp, STRING_IP_SIZE);
#pragma warning (push)
#pragma warning (disable : 6053)
        strncat(szHeader, ":", 1);
#pragma warning (pop)

        if (isIPv6) strncat(szHeader, "[", 1);
        strncat(szHeader, szPort, STRING_PORT_SIZE);
        if (isIPv6) strncat(szHeader, "]", 1);

        XomTrace(DefaultTrace, L_LOW, "Setting SGIPPort header to : [%s]", szHeader);
        bResult = pPreproc->AddHeader(pfc, SG_INFO_ADDR_HEADER_NAME, szHeader);
        if (!bResult)
        {
            XomTrace(DefaultTrace, L_LOW,  "Failed to AddHeader, GetLastError:[0x%x]", GetLastError());
            goto error_cleanup;
        }
    }
    return true;

error_cleanup:
    // returning false ensures that if anything weird happened, xrlscan
    // will block the request
    return false;
}

BOOL
GetServerPort(
    HTTP_FILTER_CONTEXT *           pfc,
    DWORD &                         dwPort
    )
{
    DWORD dwHeaderSize = STRING_PORT_SIZE;
    char szPort[STRING_PORT_SIZE];
    memset(szPort, 0, sizeof(szPort));

    dwHeaderSize = STRING_PORT_SIZE;
    if(!pfc->GetServerVariable(pfc, "SERVER_PORT",  szPort, &dwHeaderSize))
    {
        XomTrace(DefaultTrace, L_LOW,  "Failed to GetServerVariable SERVER_PORT, GetLastError:[0x%x]", GetLastError());
        goto error_cleanup;
    }

    dwPort = atoi(szPort);

    return true;

error_cleanup:
    // returning false ensures that if anything weird happened, xrlscan
    // will block the request
    return false;
}


/*++

   Looks up the port the request came in on, and adds it to
   the ServerPort http header, to make it faster for C# front doors
   to look up this information. If the request already contains a
   ServerPort header, then the request will be rejected. This is to
   prevent hackers from sending a request through the SG that impersonates
   a datacenter request.
--*/
BOOL
AddServerPortHeader(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc,
    CRequestInfoStr &               szCurRequestInfo
    )
{
    BOOL    bResult;
    DWORD dwHeaderSize = STRING_PORT_SIZE;
    char szHeader[STRING_PORT_SIZE];
    char szHeaderNewValue[STRING_PORT_SIZE];
    memset(szHeader        , 0, sizeof(szHeader));
    memset(szHeaderNewValue, 0, sizeof(szHeaderNewValue));

    dwHeaderSize = STRING_PORT_SIZE;
    bResult = pfc->GetServerVariable(pfc, "SERVER_PORT",  szHeaderNewValue, &dwHeaderSize);
    if(!bResult)
    {
        XomTrace(DefaultTrace, L_LOW,  "Failed to GetServerVariable SERVER_PORT, GetLastError:[0x%x]", GetLastError());
        goto error_cleanup;
    }

    // check to see if there is already a header there. If so, update it with the
    // correct information
    bResult = pPreproc->GetHeader(pfc, SERVER_PORT_HEADER_NAME, szHeader, &dwHeaderSize);
    if (bResult)
    {
        XomTrace(DefaultTrace, L_LOW, "Updating ServerPort header : [%s]", szHeader);
        bResult = pPreproc->SetHeader(pfc, SERVER_PORT_HEADER_NAME, szHeaderNewValue);
        if (!bResult)
        {
            XomTrace(DefaultTrace, L_LOW,  "Failed to SetHeader, GetLastError:[0x%x]", GetLastError());
            goto error_cleanup;
        }
    }
    else
    {
        // no pre-existing header, so add one
        XomTrace(DefaultTrace, L_LOW, "Adding ServerPort header : [%s]", szHeader);
        bResult = pPreproc->AddHeader(pfc, SERVER_PORT_HEADER_NAME, szHeaderNewValue);
        if (!bResult)
        {
            XomTrace(DefaultTrace, L_LOW,  "Failed to AddHeader, GetLastError:[0x%x]", GetLastError());
            goto error_cleanup;
        }
    }
    return true;

error_cleanup:
    // returning false ensures that if anything weird happened, xrlscan
    // will block the request
    return false;
}


/*++

  perform an action based on validity test results

--*/


VOID
LogClientInfo(
    HTTP_FILTER_CONTEXT *           pfc,
    LPCSTR pszRequestInfo,
    PXRLINFO pXrlInfo
    )
{
    IN_ADDR ulClientIP;
    ulClientIP.s_addr = 0;
    USHORT nClientPort = 0XFFFF;
    HRESULT hr = S_OK;

    // Note: Get rid of the CAuthData3 version after the Berlin Release
    BYTE rgbBuffer[ CBSGSPIREPMSG ];
    CSgMsgSpiRep* pSpiRep = (CSgMsgSpiRep*) rgbBuffer;
    CSgMsgSpiData* pSpiData = (CSgMsgSpiData*)( pSpiRep + 1 );
    CSgMsgHdr* pAuthHdr = (CSgMsgHdr*)( pSpiData + 1 );
    CAuthData4* pAuthData = (CAuthData4*)( pAuthHdr + 1 );
    CAuthData3* pAuthData3 = (CAuthData3*)( pAuthHdr + 1 );

    GetIpAddress( pfc, &ulClientIP, &nClientPort);

    CHeadersStr szAllHeadersStr;

    GetAllHeaders ( pfc, szAllHeadersStr );
    LPCSTR szAllHeaders = szAllHeadersStr.cstr();

    if (pXrlInfo != NULL && pXrlInfo->fDontGetSGInfo == TRUE)
    {
        XomNtEvent(XEVENT_XRLSCAN_HACK_0, "%s.\n\nRaw Headers: [%s].\n\nThe request is sent by IpZ [%s], PortZ[0x%x].",
                pszRequestInfo, szAllHeaders, inet_ntoa(ulClientIP), nClientPort);

        return;
    }

    hr = GetSGInfo( ulClientIP.s_addr, nClientPort, pSpiRep, sizeof( rgbBuffer ) );
    if (FAILED(hr))
    {
        XomTrace(DefaultTrace, L_ERROR, "Fail to retrieve SGInfo, hr [0x%x]",hr);
        XomNtEvent(XEVENT_XRLSCAN_E_INVALID_URL_1,
            "%s.\n\nRaw Headers: [%s].\n\nThe request is sent by IpZ [%s], PortZ[0x%x]. AuthData unavailable hr [0x%x]. ",
            pszRequestInfo,
            szAllHeaders,
            inet_ntoa(ulClientIP),
            nClientPort, hr
            );
        return;
    }

    if (pAuthData->wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION )
    {
        // GetSGInfo will have already validated the reply type, so just assert that here
        XOMASSERT( sizeof( CSgMsgSpiRep ) == pSpiRep->_cbEnt );
        XOMASSERT( SGMSG_TYPE_SPIDATA_REP == pSpiRep->_wType );
        XOMASSERT( sizeof( CSgMsgSpiData ) == pSpiData->_cbEnt );
        XOMASSERT( SGMSG_TYPE_SPIDATA == pSpiData->_wType );
        XOMASSERT( sizeof( CSgMsgHdr ) + sizeof( CAuthData4 ) == pAuthHdr->_cbEnt );
        XOMASSERT( SGMSG_TYPE_AUTHDATA == pAuthHdr->_wType );

        XomNtEvent(XEVENT_XRLSCAN_E_INVALID_URL,
                "%s\n\nRaw Headers: [%s].\n\nThe request is sent by IpI [%s], portI [0x%x], titleId [0x%x], titleVersion [0x%x], XboxID [0x%016I64X], user1 ID [0x%016I64X], user2 ID [0x%016I64X], user3 ID [0x%016I64X], user4 ID [0x%016I64X]",
                pszRequestInfo,
                szAllHeaders,
                inet_ntoa( pSpiData->_ipaI ),
                pSpiData->_ipportI,
                pAuthData->dwTitleID,
                pAuthData->dwTitleVersion,
                pAuthData->qwXboxID,
                pAuthData->users[0].qwUserID,
                pAuthData->users[1].qwUserID,
                pAuthData->users[2].qwUserID,
                pAuthData->users[3].qwUserID
                );
    }
    else if (pAuthData->wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION)
    {
        // GetSGInfo will have already validated the reply type, so just assert that here
        XOMASSERT( sizeof( CSgMsgSpiRep ) == pSpiRep->_cbEnt );
        XOMASSERT( SGMSG_TYPE_SPIDATA_REP == pSpiRep->_wType );
        XOMASSERT( sizeof( CSgMsgSpiData ) == pSpiData->_cbEnt );
        XOMASSERT( SGMSG_TYPE_SPIDATA == pSpiData->_wType );
        XOMASSERT( sizeof( CSgMsgHdr ) + sizeof( CAuthData3 ) == pAuthHdr->_cbEnt );
        XOMASSERT( SGMSG_TYPE_AUTHDATA == pAuthHdr->_wType );

        XomNtEvent(XEVENT_XRLSCAN_E_INVALID_URL,
                "%s\n\nRaw Headers: [%s].\n\nThe request is sent by IpI [%s], portI [0x%x], titleId [0x%x], titleVersion [0x%x], XboxID [0x%016I64X], user1 ID [0x%016I64X], user2 ID [0x%016I64X], user3 ID [0x%016I64X], user4 ID [0x%016I64X]",
                pszRequestInfo,
                szAllHeaders,
                inet_ntoa( pSpiData->_ipaI ),
                pSpiData->_ipportI,
                pAuthData3->dwTitleID,
                pAuthData3->dwTitleVersion,
                pAuthData3->qwXboxID,
                pAuthData3->users[0].qwUserID,
                pAuthData3->users[1].qwUserID,
                pAuthData3->users[2].qwUserID,
                pAuthData3->users[3].qwUserID
                );
    }
}


BOOL TerminateFilter(
    DWORD   dwFlags
    )
{
    if(g_pConfig != NULL)
    {
        g_pConfig->putref_ConfigListener(NULL);
        g_pConfig.Release();
    }

    if(g_pXrlScanConfigListener != NULL)
    {
        delete g_pXrlScanConfigListener;
        g_pXrlScanConfigListener = NULL;
    }

    g_xomcentral.Term();

    // memory cleanup
    delete [] g_ValidXrls.pValidXrls;
    g_ValidXrls.pValidXrls = NULL;
    g_ValidXrls.dwCurXrls = 0;

    return TRUE;
}


VOID GetIpAddress(
    HTTP_FILTER_CONTEXT * pfc,
    IN_ADDR * ulIp,
    USHORT* pwPort)
{
    BOOL    bResult;

    if(NULL == ulIp)
    {
        return;
    }
    char szIp[STRING_IP_SIZE];

    ulIp->s_addr = 0;
    DWORD dwIpSize = STRING_IP_SIZE;
    bResult = pfc->GetServerVariable(pfc, "REMOTE_ADDR", szIp, &dwIpSize);
    if(bResult)
    {
        ulIp->s_addr = inet_addr(szIp);
        ulIp->s_addr = ulIp->s_addr == INADDR_NONE? 0  : ulIp->s_addr;
    }

    dwIpSize = STRING_IP_SIZE;
    bResult = pfc->GetServerVariable(pfc, "REMOTE_PORT",  szIp, &dwIpSize);
    if(!bResult)
    {
        XomTrace(DefaultTrace, L_LOW,  "Fail to get Port number res [0x%x]", GetLastError());
    }
    XomTrace(DefaultTrace, L_LOW, "Port no. is : [%s]", szIp);
    *pwPort = htons((WORD)(atoi(szIp)));

    *pwPort = bResult ? *pwPort : 0xFFFF;
    XomTrace(DefaultTrace, L_LOW,  "Enter IPz = [%x], Portz=[%x]", ulIp->s_addr, *pwPort);
}

// Get IP and Port from Host header.
VOID GetHostHeaderIpAddress(
    HTTP_FILTER_CONTEXT * pfc,
    HTTP_FILTER_PREPROC_HEADERS * pPreprocHeaders,
    IN_ADDR * ulIp )
{
    if(NULL == ulIp)
    {
        return;
    }

    BOOL bResult;
    char szHostHeader[1024];
    DWORD dwHostHeaderSize = sizeof(szHostHeader);

    ulIp->s_addr = 0;
    bResult = pPreprocHeaders->GetHeader(pfc, "Host:", szHostHeader, &dwHostHeaderSize);
    if(!bResult)
    {
        return;
    }

    // Check for port number in header.  Strip it if found.
    char* pszColon = strchr(szHostHeader, ':');
    if(pszColon != NULL)
    {
        *(pszColon++) = '\0';
    }

    ulIp->s_addr = inet_addr(szHostHeader);

    XomTrace(DefaultTrace, L_LOW,  "Host Header address: IPz = [%x]", ulIp->s_addr);
}

VOID GetAllHeaders (
    HTTP_FILTER_CONTEXT * pfc,
    CHeadersStr & szHeaders )
{
    DWORD dwSize = 0;

    BOOL bResult = pfc->GetServerVariable(pfc, "ALL_RAW",  szHeaders.StartWrite((PUINT32)&dwSize), &dwSize);
    DWORD dwErr = 0;
    if ( !bResult )
    {
        szHeaders.EndWrite(0);
        dwErr = GetLastError();
        szHeaders.Format("Cannot retrieve the headers, hr = 0x%x",HRESULT_FROM_WIN32(dwErr));
        return;
    }

    dwSize--;

    szHeaders.EndWrite(dwSize);

    for (DWORD i = 0; i < dwSize; i++)
    {
        if ((!isprint(szHeaders[i]) && szHeaders[i] != '\r'  && szHeaders[i] != '\n') || szHeaders[i] == '%')
        {
            szHeaders[i] = '?';
        }
    }
}

HRESULT ReadConfig(
    )
{
    // Doing this allows only the first CallProc call to have to do any parsing
    XomTrace(DefaultTrace, L_INFO, "XrlScan.ReadConfig");

    static CWSProcCache cache;

    static DBBINDING xrlBind[] = {
        WSBIND(1, offsetof(XRLINFO, szXrl), DBTYPE_STR, XRL_MAX_LENGTH + 1),
        WSBIND(2, offsetof(XRLINFO, lMaxUrlLength), DBTYPE_I4, sizeof(ULONG)),
        WSBIND(3, offsetof(XRLINFO, lMaxContentLength), DBTYPE_I4, sizeof(LONG)),
        WSBIND(4, offsetof(XRLINFO, lMaxQueryStringLength), DBTYPE_I4, sizeof(ULONG)),
        WSBIND(5, offsetof(XRLINFO, fAllowTextXmlContentType), DBTYPE_I1, sizeof(char)),
        WSBIND(6, offsetof(XRLINFO, fDontGetSGInfo), DBTYPE_I1, sizeof(char)),
        WSBIND(7, offsetof(XRLINFO, fAllowNoExactMatch), DBTYPE_I1, sizeof(char)),
        WSBIND(8, offsetof(XRLINFO, dwPort), DBTYPE_I4, sizeof(DWORD)),
        WSBIND(9, offsetof(XRLINFO, fBlockLimitedPCAccount), DBTYPE_I1, sizeof(char)),
        WSBIND(10, offsetof(XRLINFO, szHttpVerbs), DBTYPE_STR, HTTP_VERBS_MAX_LENGTH + 1),
    };

    static DBBINDING settingBind[] = {
        WSBIND(1, offsetof(XRLSETTING, szSetting), DBTYPE_STR, SETTING_MAX_LENGTH + 1),
        WSBIND(2, offsetof(XRLSETTING, szValue), DBTYPE_STR, VALUE_MAX_LENGTH + 1),
    };

    HRESULT         hr = S_OK;
    XRLARRAY        newXrls = { NULL, 0, 0 };
    CODBWSession    ses;
    CComBSTR bsConnectionString;
    VARIANT_BOOL fAllowHead;

    //
    //  We're good to go, start working...
    //


    WCHAR szAppPoolId[MAX_PATH];

    ZeroMemory(szAppPoolId, sizeof(szAppPoolId));
    GetEnvironmentVariable(_T("APP_POOL_ID"), szAppPoolId, ARRAYSIZE(szAppPoolId));

    LPWSTR pSplitName = wcschr(szAppPoolId, L'-');
    LPCWSTR pVrootName = pSplitName != NULL ? pSplitName+1 : NULL;

    // If the name is a two-part name, then split it out in order to get the relevent pieces
    if (pSplitName != NULL)
    {
        *pSplitName = L'\0';
    }

    hr = g_pConfig->get_Server(&g_bsServer);
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: pConfig->get_Server failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_1, "XrlScan.ReadConfig: pConfig->get_Server failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = g_pConfig->get_NpdbConnectionString(&bsConnectionString);
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: pConfig->get_NpdbConnectionString failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_2, "XrlScan.ReadConfig: pConfig->get_NpdbConnectionString failed with 0x%X", hr);
        goto Cleanup;
    }

    // Connect to the NPDB database
    hr = ses.InitializeEx( bsConnectionString );
    if( FAILED( hr ) )
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.InitializeEx failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_5, "XrlScan.ReadConfig: ses.InitializeEx failed with 0x%X", hr);
        goto Cleanup;
    }

    // Get the list of valid xrls
    XomTrace( DefaultTrace, L_LOW, "{ hr = CALL p_xrlscan_get_valid_xrls(server) }");
    hr = ses.CallProc( &cache, L"{ %T = CALL p_xrlscan_get_valid_xrls(%vW, %vW, %vW) }", g_bsServer.m_str, szAppPoolId, pVrootName);
    if( FAILED( hr ) )
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.CallProc failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_6, "XrlScan.ReadConfig: ses.CallProc failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = ses.SetBindings(xrlBind, ARRAY_ELEMENTS( xrlBind ) );
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.SetBindings failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_7, "XrlScan.ReadConfig: ses.SetBindings failed with 0x%X", hr);
        goto Cleanup;
    }

    XRLINFO xrlInfo;
    memset(&xrlInfo, 0, sizeof(XRLINFO));

    DBCOUNTITEM cRows = 1;
    hr = ses.GetRows(&cRows, &xrlInfo, sizeof(XRLINFO));
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.GetRows failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_8, "XrlScan.ReadConfig: ses.GetRows failed with 0x%X", hr);
        goto Cleanup;
    }

    //char szComponent[COMPONENT_MAX_LENGTH + 1] = {};
    //strcpy(szComponent, xrlInfo.szComponent);
    //BOOL fComponentSame = 1;

    while(cRows == 1)
    {
        XomTrace(DefaultTrace, L_INFO, "XrlScan.ReadConfig - adding XRL");
        AddXrl(xrlInfo, newXrls);

        memset(&xrlInfo, 0, sizeof(XRLINFO));

        hr = ses.GetRows(&cRows, &xrlInfo, sizeof(XRLINFO));
        if(FAILED(hr))
        {
            XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.GetRows failed with 0x%X", hr);
            XomNtEvent( XEVENT_XRLSCAN_CONFIG_9, "XrlScan.ReadConfig: ses.GetRows failed with 0x%X", hr);
            goto Cleanup;
        }

        //fComponentSame &= (0 == _stricmp(szComponent, xrlInfo.szComponent));
    }
/*
    if (fComponentSame)
    {
        hr = g_pConfig->put_ComponentName(CComBSTR(szComponent));

        if (FAILED(hr))
        {
            XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: put_ComponentName failed with 0x%X", hr);
            XomNtEvent( XEVENT_XRLSCAN_PUT_COMPONENTNAME_FAILED, "XrlScan.ReadConfig: put_ComponentName failed with 0x%X", hr);

            // Continue processing because we need to at least get the default config -- this is a non-critical failure.
        }
    }


    hr = g_pConfig->GetBoolSetting(CComBSTR(L"xrlscan_allowHead"), &fAllowHead);
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: pConfig->GetBoolSetting(xrlscan_allowHead) failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_10, "XrlScan.ReadConfig: pConfig->GetBoolSetting(xrlscan_allowHead) failed with 0x%X", hr);
        goto Cleanup;
    }
*/
    hr = ses.NextRowsetResult();
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: Attempt to find next rowset failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_GETNEXTROWSET_FAILED, "XrlScan.ReadConfig: Attempt to find next rowset failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = ses.SetBindings(settingBind, ARRAY_ELEMENTS( settingBind ) );
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: ses.SetBindings for xrlsetting failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_SETBINDINGS_FAILED, "XrlScan.ReadConfig: ses.SetBindings for xrlsetting failed with 0x%X", hr);
        goto Cleanup;
    }

    XRLSETTING xrlSetting;
    ZeroMemory(&xrlSetting, sizeof(xrlSetting));

    cRows = 1;
    hr = ses.GetRows(&cRows, &xrlSetting, sizeof(XRLSETTING));
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: Attempt to read row from next rowset failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_GETROWS_FAILED, "XrlScan.ReadConfig: Attempt to read row from next rowset failed with 0x%X", hr);
    }

    fAllowHead = _stricmp(xrlSetting.szValue, "true") == 0 || _stricmp(xrlSetting.szValue, "1") == 0 || _stricmp(xrlSetting.szValue, "on") == 0;

    hr = ReadContentTypesConfig(bsConnectionString, szAppPoolId, pVrootName);
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadConfig: reading of content types setting failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_LOADCONTENTTYPES_FAILED, "XrlScan.ReadConfig: reading of content types setting failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = S_OK;

    //
    //  Block requests
    //

    if(!ResetEvent(g_hLoadingConfigEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Wait for current requests to drain off
    //

    while(g_lRequestCount != 0)
        Sleep(0);

//    g_configLock.WriteLock();

    //
    //  Delete current xrl mappings
    //

    if(g_ValidXrls.pValidXrls != NULL)
    {
        delete [] g_ValidXrls.pValidXrls;
    }

    g_ValidXrls = newXrls;
    g_fAllowHead = fAllowHead ? VARIANT_TRUE : VARIANT_FALSE;

    //
    //  Allow requests to proceed
    //

    SetEvent(g_hLoadingConfigEvent);
//    g_configLock.WriteUnlock();

Cleanup:

    //
    //  In case of error, we don't want to leak
    //

    if(FAILED(hr))
    {
        if(newXrls.pValidXrls != NULL)
            delete [] newXrls.pValidXrls;
    }

    return hr;
}

HRESULT ReadContentTypesConfig(
    BSTR bsConnectionString
    ,LPCWSTR pAppPoolId
    ,LPCWSTR pVrootName
    )
{
    // Doing this allows only the first CallProc call to have to do any parsing
    XomTrace(DefaultTrace, L_INFO, "XrlScan.ReadContentTypesConfig");

    static CWSProcCache cache;

    static DBBINDING settingBind[] = {
        WSBIND(1, offsetof(XRLSETTING, szSetting), DBTYPE_STR, SETTING_MAX_LENGTH + 1),
        WSBIND(2, offsetof(XRLSETTING, szValue), DBTYPE_STR, VALUE_MAX_LENGTH + 1),
    };

    HRESULT         hr = S_OK;
    CODBWSession    ses;
    XRLSETTING sValidContentTypes = {{0}, {0}};
    
    ZeroMemory(&g_rszValidContentTypes, sizeof(g_rszValidContentTypes));
    ZeroMemory(&g_sValidContentTypes, sizeof(g_sValidContentTypes));
    
    //
    //  We're good to go, start working...
    //


    // Connect to the NPDB database
    hr = ses.InitializeEx( bsConnectionString );
    if( FAILED( hr ) )
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig: ses.InitializeEx failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_5, "XrlScan.ReadContentTypesConfig: ses.InitializeEx failed with 0x%X", hr);
        goto Cleanup;
    }

    // Get the list of valid content types
    
    XomTrace( DefaultTrace, L_LOW, "{ hr = CALL p_config_batch_get_setting_values_ranked() }");
    LPCWSTR pcszSettingName =  L"<a vc_setting=\"xrlscan_whitelistcontenttypes\"/>";
    hr = ses.CallProc( &cache, L"{ %T = CALL p_config_batch_get_setting_values_ranked(%vW, %vW, %vW, %vW) }", g_bsServer.m_str, pAppPoolId, pVrootName, pcszSettingName);
    if( FAILED( hr ) )
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig: ses.CallProc of content types failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_CONFIG_6, "XrlScan.ReadContentTypesConfig: ses.CallProc of content types failed with 0x%X", hr);
        goto Cleanup;
    }

    hr = ses.SetBindings(settingBind, ARRAY_ELEMENTS( settingBind ) );
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig: ses.SetBindings for xrlsetting failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_SETBINDINGS_FAILED, "XrlScan.ReadContentTypesConfig: ses.SetBindings for xrlsetting failed with 0x%X", hr);
        goto Cleanup;
    }

    DBCOUNTITEM cRows = 1;
    hr = ses.GetRows(&cRows, &g_sValidContentTypes, sizeof(g_sValidContentTypes));
    if(FAILED(hr))
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig: ses.GetRows failed with 0x%X", hr);
        XomNtEvent( XEVENT_XRLSCAN_GETROWS_FAILED, "XrlScan.ReadContentTypesConfig: ses.GetRows failed with 0x%X", hr);
        goto Cleanup;
    }

    char* pszContentTypes = NULL;
    if (_stricmp(g_sValidContentTypes.szSetting, "xrlscan_whitelistcontenttypes") != 0)
    {
        hr = E_FAIL;
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig: ses.GetRows returned incorrect setting value, returning 0x%X", hr);
        goto Cleanup;
    }
    else
    {
        //convert it to lower case as content types and subtypes are case insensitive according to the protocol spec
        if (_strlwr_s(g_sValidContentTypes.szValue, ARRAY_SIZE(g_sValidContentTypes.szValue)) != 0)
        {
            hr = E_FAIL;
            XomTrace( DefaultTrace, L_WARNING, "XrlScan.ReadContentTypesConfig:_strlwr_s failed, returning 0x%X", hr);
            goto Cleanup;
           }
    }

    // Split it up into indivdual values
    char seps[] = " ,";
    char* nextToken;
    g_rszValidContentTypes[0] = strtok_s(g_sValidContentTypes.szValue, seps, &nextToken);
    for (int i=1; i<ARRAY_SIZE(g_rszValidContentTypes); ++i)
    {
        g_rszValidContentTypes[i] = strtok_s(NULL, seps, &nextToken);
        if (g_rszValidContentTypes[i] == NULL)
        {
            //we are out of content types in this setting
            break;
        }
    }

    hr = S_OK;


Cleanup:

    return hr;
}

BOOL IsValidContentType(
    LPCSTR pContentType
    )
{
    // Doing this allows only the first CallProc call to have to do any parsing
    XomTrace(DefaultTrace, L_INFO, "XrlScan.IsValidContentType");

    BOOL match = FALSE;

    //We need to check if the value is present in the comma seperated setting value
    //Convert the strings to lower and cap the input to the max length
    char  szToCheck[SETTING_MAX_LENGTH + 1];
    
    if (strlen(pContentType) > SETTING_MAX_LENGTH)
    {
        //If we are truncating the setting we should raise an event to let ops know
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.IsValidContentType: content type %s is longer than permitted, returning FALSE", pContentType);
        goto Cleanup;
    }

    if (strncpy_s(szToCheck, ARRAY_SIZE(szToCheck), pContentType, ARRAY_SIZE(szToCheck)) != 0)
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.IsValidContentType: strcpy_s failed, returning FALSE");
        goto Cleanup;
    }

    //Convert it to lower case
    if (_strlwr_s(szToCheck, ARRAY_SIZE(szToCheck)) != 0)
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.IsValidContentType: _strlwr_s failed, returning FALSE");
        goto Cleanup;
    }

    //Look for a match by cycling through our array of allowed types. We require it to be at the front of the
    //header with no leading characters. 
    for (int i=0; !match && i<ARRAY_SIZE(g_rszValidContentTypes); ++i)
    {
        if (g_rszValidContentTypes[i] == NULL)
        {
            //out of types
            break;
        }

        match = (_strnicmp(g_rszValidContentTypes[i], szToCheck, strlen(g_rszValidContentTypes[i])) == 0);
    }

Cleanup:
    if (!match)
    {
        XomTrace( DefaultTrace, L_WARNING, "XrlScan.IsValidContentType: invalid content type %s sent", pContentType);
    }

    return match;
}

HRESULT AddXrl(
    XRLINFO& xrlInfo,
    XRLARRAY& xrls
    )
{
    HRESULT hr = S_OK;

    // resize the array of valid xrl if capacity is reached
    if (xrls.dwCurXrls >= xrls.dwMaxXrls)
    {
        PXRLINFO pNewXrlArr = new XRLINFO [xrls.dwMaxXrls + 10];
        if (NULL == pNewXrlArr)
        {
            return E_OUTOFMEMORY;
        }

        memcpy (pNewXrlArr, xrls.pValidXrls, sizeof(XRLINFO) * xrls.dwCurXrls);
        delete [] xrls.pValidXrls;
        xrls.pValidXrls = pNewXrlArr;
        xrls.dwMaxXrls += 10;
    }

    assert(xrls.dwCurXrls < xrls.dwMaxXrls);

    // when we read from the database,  the  verbs are strings.
    // convert the strings into flags to make them more useful
    // the parse routine is destructive, copy the string first

    char szBuffer[sizeof(xrlInfo.szHttpVerbs)];
    strncpy_s(szBuffer, xrlInfo.szHttpVerbs, sizeof(xrlInfo.szHttpVerbs));
    xrlInfo.dwHttpFlags = ParseVerbs(szBuffer);

    memcpy(&(xrls.pValidXrls[xrls.dwCurXrls]), &xrlInfo, sizeof(XRLINFO));
    xrls.dwCurXrls++;
    XomTrace(DefaultTrace, L_LOW,  "AddXrlName total = %d, %s", xrls.dwCurXrls, xrls.pValidXrls[xrls.dwCurXrls - 1].szXrl);

    return hr;
}

/*++
  Matches the ports to ensure that an xrl is being matched only on the appropriate interfaces

  The matching is based on the assumption that front doors have a specific port numbering convention:

  The front door has a "public" port with a value between 10,000 and 11,000, with an "internal" port that is
  "public" + 1000.  For example, public Signature(xsig) is 10120 and internal Signature (xsig_int) is 11120.

  The code will consider the port a match if the port matches either the public or internal ports to a service.
--*/
BOOL IsMatchingPort(
    DWORD reqPort,
    DWORD aclPort
    )
{
    if (reqPort == aclPort)
    {
        return TRUE;
    }
/*    else if (reqPort < 11000 && (reqPort == aclPort-1000))
    {
        return TRUE;
    }
*/    else if (reqPort >= 11000 && reqPort < 12000 && (reqPort == aclPort+1000))
    {
        return TRUE;
    }

    return FALSE;
}


DWORD VerbToBit(char * verb) {
    if (_strnicmp("POST", verb, 4)   == 0) return HTTP_FLAG_POST;
    if (_strnicmp("GET", verb, 3)    == 0) return HTTP_FLAG_GET;
    if (_strnicmp("PUT", verb, 3)    == 0) return HTTP_FLAG_PUT;
    if (_strnicmp("DELETE", verb, 6) == 0) return HTTP_FLAG_DELETE;
    return 0;
}

DWORD ParseVerbs(char * szHttpVerbs)
{
    if (szHttpVerbs == NULL) {
        return 0;
    }

    int iMask = 0;
    char   *pContext;
    char * verb = strtok_s(szHttpVerbs, " ,", &pContext);
    
    while (verb != NULL)
    {
        iMask |= VerbToBit(verb);
        verb = strtok_s(NULL, " ,", &pContext);
    }

    return iMask;
}


BOOL IsIPv6Address(
    char * pszAddress
)
{
    if (pszAddress != NULL)
    {
        while (*pszAddress != '\0') {
            if (*pszAddress == ':') return TRUE;
            pszAddress++;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xrlscan_none_12.4.56.0_none_9abf3fa1181358ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xrlscan
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.manifest
XP_MANIFEST_PATH=manifests\x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.cat
XP_CATALOG_PATH=manifests\x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605.cat
XP_PAYLOAD_PATH=x86_xrlscan_no-public-key_12.4.56.0_x-ww_337f5605
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xrlscan,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\test\dvt\XrlScanTest.cs ===
using System;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Threading;
using System.Net;
using System.Xml;

using ServerTestFramework;
using stfls = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.diagnostics;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.nUnit;
using xonline.server.comps.common;
using xonline.common.mgmt;
using xonline.common.stfutil;
using xonline.common.config;

namespace xonline.server.xrlscan.test.dvt
{
    [TestGroup, DVT]
    public class XrlScanTestGroup : TestNode
    {
        /// <summary>
        /// This test case verifies that XRLSCAN can be loaded, initialized and terminated successfully.
        /// </summary>
        [TestCase]
        public void InitTest()
        {
            Assert.IsTrue(XrlScan.InitXrlScan());
            Assert.IsTrue(XrlScan.TerminateXrlScan(0));
        }

        /// <summary>
        /// This test case verifies the behavior when the url is absent from the request.  Not
        /// sure if this can ever really happen, but ensures partial code coverage.
        /// </summary>
        [TestCase]
        public void NoUrlInRequest()
        {
            Assert.IsTrue(XrlScan.InitXrlScan());

            IsapiFilterRequestor req = new IsapiFilterRequestor();
            req.Url = "";

            HttpFilterProcReturnCodes ret = XrlScan.FilterRequest(req);

            Assert.IsTrue(XrlScan.TerminateXrlScan(0));

            Assert.IsTrue(ret == HttpFilterProcReturnCodes.SF_STATUS_REQ_ERROR);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\XrlscanTest.h ===
#pragma once

class XrlscanTest
{
public:
    XrlscanTest(void);
public:
    ~XrlscanTest(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\HttpFilterClient.h ===
#pragma once

typedef BOOL (WINAPI* GETFILTERVERSIONPROC)(HTTP_FILTER_VERSION*);
typedef DWORD (WINAPI* HTTPFILTERPROC)(HTTP_FILTER_CONTEXT*, DWORD, VOID*);
typedef BOOL (WINAPI* TERMINATEFILTERPROC)(DWORD);

class HttpFilterClient
{
public:
    HttpFilterClient(LPCWSTR wszFilter);

    BOOL Load();
    DWORD ProcessRequest(
        BOOL fIsSecure,                                       
        LPCWSTR wszMethod,
        LPCWSTR wszUrl,
        LPCWSTR wszHeaders);

    //
    //  Callbackfunctions
    //

    BOOL GetServerVariable(
        PHTTP_FILTER_CONTEXT pfc,
        LPSTR lpszVariableName,
        LPVOID lpvBuffer,
        LPDWORD lpdwSize
        );
    BOOL AddResponseHeaders(
        PHTTP_FILTER_CONTEXT pfc,
        LPSTR lpszHeaders,
        LPSTR dwReserved
        );
    BOOL WriteClient(
        PHTTP_FILTER_CONTEXT pfc,
        LPVOID buffer,
        LPDWORD lpdwBytes,
        DWORD dwReserved
        );


public:
    ~HttpFilterClient(void);

private:

    WCHAR m_wszFilter[MAX_PATH];
    HMODULE m_hFilter;
    HTTP_FILTER_VERSION m_FilterVersion;

    GETFILTERVERSIONPROC m_pfnGetFilterVersion;
    HTTPFILTERPROC m_pfnHttpFilterProc;
    TERMINATEFILTERPROC m_pfnTerminateFilter;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// xrlscantest.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once


#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
#include <httpfilt.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>

#include "HttpFilterClient.h"
#include "XrlscanTest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\XrlscanTest.cpp ===
#include "StdAfx.h"

XrlscanTest::XrlscanTest(void)
{
}

XrlscanTest::~XrlscanTest(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\wsdl\XMachineSoap.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4963
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.server.xmachine.fd.soap {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XMachineSoap", Namespace="urn:schemas-xbox-com:machine-data")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(HistorySummary))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(HistoryDetails))]
    public partial class XMachine : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback BanConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback BanMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback BanPcTokensOperationCompleted;
        
        private System.Threading.SendOrPostCallback IsConsoleIdAndSCodeBannedOperationCompleted;
        
        private System.Threading.SendOrPostCallback LogGamertagHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback LogPassportHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback LogRecoveryHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupBanHistoryByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupConsoleBansByConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachineBansByConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupConsoleBansByMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachineBansByMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupConsoleIdsByMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupGamertagHistoryByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachineInfoByMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachinePuidByConsoleIdAndXuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachinePuidsByConsoleIdAndSCodeOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachinePuidsByConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupMachinePuidsByPcTokensOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupPassportHistoryByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupPcTokensByMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupRecoveryHistoryByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback LookupUserHistoryByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback ResetMachinePasswordByConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback UnbanConsoleIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback UnbanMachinePuidsOperationCompleted;
        
        private System.Threading.SendOrPostCallback UnbanPcTokensOperationCompleted;
        
        private System.Threading.SendOrPostCallback VerifyXbox360ConsoleIdsOperationCompleted;
        
        /// <remarks/>
        public XMachine() {
            this.Url = "http://127.0.0.1:13050/xmachine/xmachine.asmx";
        }
        
        /// <remarks/>
        public event BanConsoleIdsCompletedEventHandler BanConsoleIdsCompleted;
        
        /// <remarks/>
        public event BanMachinePuidsCompletedEventHandler BanMachinePuidsCompleted;
        
        /// <remarks/>
        public event BanPcTokensCompletedEventHandler BanPcTokensCompleted;
        
        /// <remarks/>
        public event IsConsoleIdAndSCodeBannedCompletedEventHandler IsConsoleIdAndSCodeBannedCompleted;
        
        /// <remarks/>
        public event LogGamertagHistoryCompletedEventHandler LogGamertagHistoryCompleted;
        
        /// <remarks/>
        public event LogPassportHistoryCompletedEventHandler LogPassportHistoryCompleted;
        
        /// <remarks/>
        public event LogRecoveryHistoryCompletedEventHandler LogRecoveryHistoryCompleted;
        
        /// <remarks/>
        public event LookupBanHistoryByMachinePuidCompletedEventHandler LookupBanHistoryByMachinePuidCompleted;
        
        /// <remarks/>
        public event LookupConsoleBansByConsoleIdsCompletedEventHandler LookupConsoleBansByConsoleIdsCompleted;
        
        /// <remarks/>
        public event LookupMachineBansByConsoleIdsCompletedEventHandler LookupMachineBansByConsoleIdsCompleted;
        
        /// <remarks/>
        public event LookupConsoleBansByMachinePuidsCompletedEventHandler LookupConsoleBansByMachinePuidsCompleted;
        
        /// <remarks/>
        public event LookupMachineBansByMachinePuidsCompletedEventHandler LookupMachineBansByMachinePuidsCompleted;
        
        /// <remarks/>
        public event LookupConsoleIdsByMachinePuidsCompletedEventHandler LookupConsoleIdsByMachinePuidsCompleted;
        
        /// <remarks/>
        public event LookupGamertagHistoryByMachinePuidCompletedEventHandler LookupGamertagHistoryByMachinePuidCompleted;
        
        /// <remarks/>
        public event LookupMachineInfoByMachinePuidsCompletedEventHandler LookupMachineInfoByMachinePuidsCompleted;
        
        /// <remarks/>
        public event LookupMachinePuidByConsoleIdAndXuidCompletedEventHandler LookupMachinePuidByConsoleIdAndXuidCompleted;
        
        /// <remarks/>
        public event LookupMachinePuidsByConsoleIdAndSCodeCompletedEventHandler LookupMachinePuidsByConsoleIdAndSCodeCompleted;
        
        /// <remarks/>
        public event LookupMachinePuidsByConsoleIdsCompletedEventHandler LookupMachinePuidsByConsoleIdsCompleted;
        
        /// <remarks/>
        public event LookupMachinePuidsByPcTokensCompletedEventHandler LookupMachinePuidsByPcTokensCompleted;
        
        /// <remarks/>
        public event LookupPassportHistoryByMachinePuidCompletedEventHandler LookupPassportHistoryByMachinePuidCompleted;
        
        /// <remarks/>
        public event LookupPcTokensByMachinePuidsCompletedEventHandler LookupPcTokensByMachinePuidsCompleted;
        
        /// <remarks/>
        public event LookupRecoveryHistoryByMachinePuidCompletedEventHandler LookupRecoveryHistoryByMachinePuidCompleted;
        
        /// <remarks/>
        public event LookupUserHistoryByMachinePuidCompletedEventHandler LookupUserHistoryByMachinePuidCompleted;
        
        /// <remarks/>
        public event ResetMachinePasswordByConsoleIdsCompletedEventHandler ResetMachinePasswordByConsoleIdsCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event UnbanConsoleIdsCompletedEventHandler UnbanConsoleIdsCompleted;
        
        /// <remarks/>
        public event UnbanMachinePuidsCompletedEventHandler UnbanMachinePuidsCompleted;
        
        /// <remarks/>
        public event UnbanPcTokensCompletedEventHandler UnbanPcTokensCompleted;
        
        /// <remarks/>
        public event VerifyXbox360ConsoleIdsCompletedEventHandler VerifyXbox360ConsoleIdsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/BanConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdResult[] BanConsoleIds(string[] consoleIds, uint reasonCode, System.DateTime banStart) {
            object[] results = this.Invoke("BanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode,
                        banStart});
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanConsoleIds(string[] consoleIds, uint reasonCode, System.DateTime banStart, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode,
                        banStart}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdResult[] EndBanConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public void BanConsoleIdsAsync(string[] consoleIds, uint reasonCode, System.DateTime banStart) {
            this.BanConsoleIdsAsync(consoleIds, reasonCode, banStart, null);
        }
        
        /// <remarks/>
        public void BanConsoleIdsAsync(string[] consoleIds, uint reasonCode, System.DateTime banStart, object userState) {
            if ((this.BanConsoleIdsOperationCompleted == null)) {
                this.BanConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBanConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("BanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode,
                        banStart}, this.BanConsoleIdsOperationCompleted, userState);
        }
        
        private void OnBanConsoleIdsOperationCompleted(object arg) {
            if ((this.BanConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BanConsoleIdsCompleted(this, new BanConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/BanMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachinePuidResult[] BanMachinePuids(ulong[] puids, uint reasonCode, System.DateTime banStart, System.DateTime banEnd) {
            object[] results = this.Invoke("BanMachinePuids", new object[] {
                        puids,
                        reasonCode,
                        banStart,
                        banEnd});
            return ((MachinePuidResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanMachinePuids(ulong[] puids, uint reasonCode, System.DateTime banStart, System.DateTime banEnd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanMachinePuids", new object[] {
                        puids,
                        reasonCode,
                        banStart,
                        banEnd}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachinePuidResult[] EndBanMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachinePuidResult[])(results[0]));
        }
        
        /// <remarks/>
        public void BanMachinePuidsAsync(ulong[] puids, uint reasonCode, System.DateTime banStart, System.DateTime banEnd) {
            this.BanMachinePuidsAsync(puids, reasonCode, banStart, banEnd, null);
        }
        
        /// <remarks/>
        public void BanMachinePuidsAsync(ulong[] puids, uint reasonCode, System.DateTime banStart, System.DateTime banEnd, object userState) {
            if ((this.BanMachinePuidsOperationCompleted == null)) {
                this.BanMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBanMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("BanMachinePuids", new object[] {
                        puids,
                        reasonCode,
                        banStart,
                        banEnd}, this.BanMachinePuidsOperationCompleted, userState);
        }
        
        private void OnBanMachinePuidsOperationCompleted(object arg) {
            if ((this.BanMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BanMachinePuidsCompleted(this, new BanMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/BanPcTokens", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PcTokenBanResult[] BanPcTokens(byte[][] tokens) {
            object[] results = this.Invoke("BanPcTokens", new object[] {
                        tokens});
            return ((PcTokenBanResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanPcTokens(byte[][] tokens, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanPcTokens", new object[] {
                        tokens}, callback, asyncState);
        }
        
        /// <remarks/>
        public PcTokenBanResult[] EndBanPcTokens(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PcTokenBanResult[])(results[0]));
        }
        
        /// <remarks/>
        public void BanPcTokensAsync(byte[][] tokens) {
            this.BanPcTokensAsync(tokens, null);
        }
        
        /// <remarks/>
        public void BanPcTokensAsync(byte[][] tokens, object userState) {
            if ((this.BanPcTokensOperationCompleted == null)) {
                this.BanPcTokensOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBanPcTokensOperationCompleted);
            }
            this.InvokeAsync("BanPcTokens", new object[] {
                        tokens}, this.BanPcTokensOperationCompleted, userState);
        }
        
        private void OnBanPcTokensOperationCompleted(object arg) {
            if ((this.BanPcTokensCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BanPcTokensCompleted(this, new BanPcTokensCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/IsConsoleIdAndSCodeBanned", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool IsConsoleIdAndSCodeBanned(string consoleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] secondaryId) {
            object[] results = this.Invoke("IsConsoleIdAndSCodeBanned", new object[] {
                        consoleId,
                        secondaryId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsConsoleIdAndSCodeBanned(string consoleId, byte[] secondaryId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsConsoleIdAndSCodeBanned", new object[] {
                        consoleId,
                        secondaryId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndIsConsoleIdAndSCodeBanned(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void IsConsoleIdAndSCodeBannedAsync(string consoleId, byte[] secondaryId) {
            this.IsConsoleIdAndSCodeBannedAsync(consoleId, secondaryId, null);
        }
        
        /// <remarks/>
        public void IsConsoleIdAndSCodeBannedAsync(string consoleId, byte[] secondaryId, object userState) {
            if ((this.IsConsoleIdAndSCodeBannedOperationCompleted == null)) {
                this.IsConsoleIdAndSCodeBannedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsConsoleIdAndSCodeBannedOperationCompleted);
            }
            this.InvokeAsync("IsConsoleIdAndSCodeBanned", new object[] {
                        consoleId,
                        secondaryId}, this.IsConsoleIdAndSCodeBannedOperationCompleted, userState);
        }
        
        private void OnIsConsoleIdAndSCodeBannedOperationCompleted(object arg) {
            if ((this.IsConsoleIdAndSCodeBannedCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsConsoleIdAndSCodeBannedCompleted(this, new IsConsoleIdAndSCodeBannedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LogGamertagHistory", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LogGamertagHistory(GamertagHistoryDetails gthd) {
            this.Invoke("LogGamertagHistory", new object[] {
                        gthd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLogGamertagHistory(GamertagHistoryDetails gthd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LogGamertagHistory", new object[] {
                        gthd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndLogGamertagHistory(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void LogGamertagHistoryAsync(GamertagHistoryDetails gthd) {
            this.LogGamertagHistoryAsync(gthd, null);
        }
        
        /// <remarks/>
        public void LogGamertagHistoryAsync(GamertagHistoryDetails gthd, object userState) {
            if ((this.LogGamertagHistoryOperationCompleted == null)) {
                this.LogGamertagHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLogGamertagHistoryOperationCompleted);
            }
            this.InvokeAsync("LogGamertagHistory", new object[] {
                        gthd}, this.LogGamertagHistoryOperationCompleted, userState);
        }
        
        private void OnLogGamertagHistoryOperationCompleted(object arg) {
            if ((this.LogGamertagHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LogGamertagHistoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LogPassportHistory", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LogPassportHistory(PassportHistoryDetails phd) {
            this.Invoke("LogPassportHistory", new object[] {
                        phd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLogPassportHistory(PassportHistoryDetails phd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LogPassportHistory", new object[] {
                        phd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndLogPassportHistory(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void LogPassportHistoryAsync(PassportHistoryDetails phd) {
            this.LogPassportHistoryAsync(phd, null);
        }
        
        /// <remarks/>
        public void LogPassportHistoryAsync(PassportHistoryDetails phd, object userState) {
            if ((this.LogPassportHistoryOperationCompleted == null)) {
                this.LogPassportHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLogPassportHistoryOperationCompleted);
            }
            this.InvokeAsync("LogPassportHistory", new object[] {
                        phd}, this.LogPassportHistoryOperationCompleted, userState);
        }
        
        private void OnLogPassportHistoryOperationCompleted(object arg) {
            if ((this.LogPassportHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LogPassportHistoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LogRecoveryHistory", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LogRecoveryHistory(RecoveryHistoryDetails rhd) {
            this.Invoke("LogRecoveryHistory", new object[] {
                        rhd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLogRecoveryHistory(RecoveryHistoryDetails rhd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LogRecoveryHistory", new object[] {
                        rhd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndLogRecoveryHistory(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void LogRecoveryHistoryAsync(RecoveryHistoryDetails rhd) {
            this.LogRecoveryHistoryAsync(rhd, null);
        }
        
        /// <remarks/>
        public void LogRecoveryHistoryAsync(RecoveryHistoryDetails rhd, object userState) {
            if ((this.LogRecoveryHistoryOperationCompleted == null)) {
                this.LogRecoveryHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLogRecoveryHistoryOperationCompleted);
            }
            this.InvokeAsync("LogRecoveryHistory", new object[] {
                        rhd}, this.LogRecoveryHistoryOperationCompleted, userState);
        }
        
        private void OnLogRecoveryHistoryOperationCompleted(object arg) {
            if ((this.LogRecoveryHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LogRecoveryHistoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupBanHistoryByMachinePuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachineBanHistoryInfo[] LookupBanHistoryByMachinePuid(ulong puid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("LookupBanHistoryByMachinePuid", new object[] {
                        puid,
                        since});
            return ((MachineBanHistoryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupBanHistoryByMachinePuid(ulong puid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupBanHistoryByMachinePuid", new object[] {
                        puid,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachineBanHistoryInfo[] EndLookupBanHistoryByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineBanHistoryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupBanHistoryByMachinePuidAsync(ulong puid, System.Nullable<System.DateTime> since) {
            this.LookupBanHistoryByMachinePuidAsync(puid, since, null);
        }
        
        /// <remarks/>
        public void LookupBanHistoryByMachinePuidAsync(ulong puid, System.Nullable<System.DateTime> since, object userState) {
            if ((this.LookupBanHistoryByMachinePuidOperationCompleted == null)) {
                this.LookupBanHistoryByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupBanHistoryByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("LookupBanHistoryByMachinePuid", new object[] {
                        puid,
                        since}, this.LookupBanHistoryByMachinePuidOperationCompleted, userState);
        }
        
        private void OnLookupBanHistoryByMachinePuidOperationCompleted(object arg) {
            if ((this.LookupBanHistoryByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupBanHistoryByMachinePuidCompleted(this, new LookupBanHistoryByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupConsoleBansByConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleBanInfo[] LookupConsoleBansByConsoleIds(string[] consoleIds) {
            object[] results = this.Invoke("LookupConsoleBansByConsoleIds", new object[] {
                        consoleIds});
            return ((ConsoleBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupConsoleBansByConsoleIds(string[] consoleIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupConsoleBansByConsoleIds", new object[] {
                        consoleIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleBanInfo[] EndLookupConsoleBansByConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupConsoleBansByConsoleIdsAsync(string[] consoleIds) {
            this.LookupConsoleBansByConsoleIdsAsync(consoleIds, null);
        }
        
        /// <remarks/>
        public void LookupConsoleBansByConsoleIdsAsync(string[] consoleIds, object userState) {
            if ((this.LookupConsoleBansByConsoleIdsOperationCompleted == null)) {
                this.LookupConsoleBansByConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupConsoleBansByConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("LookupConsoleBansByConsoleIds", new object[] {
                        consoleIds}, this.LookupConsoleBansByConsoleIdsOperationCompleted, userState);
        }
        
        private void OnLookupConsoleBansByConsoleIdsOperationCompleted(object arg) {
            if ((this.LookupConsoleBansByConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupConsoleBansByConsoleIdsCompleted(this, new LookupConsoleBansByConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachineBansByConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachineBanInfo[] LookupMachineBansByConsoleIds(string[] consoleIds) {
            object[] results = this.Invoke("LookupMachineBansByConsoleIds", new object[] {
                        consoleIds});
            return ((MachineBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachineBansByConsoleIds(string[] consoleIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachineBansByConsoleIds", new object[] {
                        consoleIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachineBanInfo[] EndLookupMachineBansByConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachineBansByConsoleIdsAsync(string[] consoleIds) {
            this.LookupMachineBansByConsoleIdsAsync(consoleIds, null);
        }
        
        /// <remarks/>
        public void LookupMachineBansByConsoleIdsAsync(string[] consoleIds, object userState) {
            if ((this.LookupMachineBansByConsoleIdsOperationCompleted == null)) {
                this.LookupMachineBansByConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachineBansByConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("LookupMachineBansByConsoleIds", new object[] {
                        consoleIds}, this.LookupMachineBansByConsoleIdsOperationCompleted, userState);
        }
        
        private void OnLookupMachineBansByConsoleIdsOperationCompleted(object arg) {
            if ((this.LookupMachineBansByConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachineBansByConsoleIdsCompleted(this, new LookupMachineBansByConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupConsoleBansByMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleBanInfo[] LookupConsoleBansByMachinePuids(ulong[] puids) {
            object[] results = this.Invoke("LookupConsoleBansByMachinePuids", new object[] {
                        puids});
            return ((ConsoleBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupConsoleBansByMachinePuids(ulong[] puids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupConsoleBansByMachinePuids", new object[] {
                        puids}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleBanInfo[] EndLookupConsoleBansByMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupConsoleBansByMachinePuidsAsync(ulong[] puids) {
            this.LookupConsoleBansByMachinePuidsAsync(puids, null);
        }
        
        /// <remarks/>
        public void LookupConsoleBansByMachinePuidsAsync(ulong[] puids, object userState) {
            if ((this.LookupConsoleBansByMachinePuidsOperationCompleted == null)) {
                this.LookupConsoleBansByMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupConsoleBansByMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("LookupConsoleBansByMachinePuids", new object[] {
                        puids}, this.LookupConsoleBansByMachinePuidsOperationCompleted, userState);
        }
        
        private void OnLookupConsoleBansByMachinePuidsOperationCompleted(object arg) {
            if ((this.LookupConsoleBansByMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupConsoleBansByMachinePuidsCompleted(this, new LookupConsoleBansByMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachineBansByMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachineBanInfo[] LookupMachineBansByMachinePuids(ulong[] puids) {
            object[] results = this.Invoke("LookupMachineBansByMachinePuids", new object[] {
                        puids});
            return ((MachineBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachineBansByMachinePuids(ulong[] puids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachineBansByMachinePuids", new object[] {
                        puids}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachineBanInfo[] EndLookupMachineBansByMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineBanInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachineBansByMachinePuidsAsync(ulong[] puids) {
            this.LookupMachineBansByMachinePuidsAsync(puids, null);
        }
        
        /// <remarks/>
        public void LookupMachineBansByMachinePuidsAsync(ulong[] puids, object userState) {
            if ((this.LookupMachineBansByMachinePuidsOperationCompleted == null)) {
                this.LookupMachineBansByMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachineBansByMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("LookupMachineBansByMachinePuids", new object[] {
                        puids}, this.LookupMachineBansByMachinePuidsOperationCompleted, userState);
        }
        
        private void OnLookupMachineBansByMachinePuidsOperationCompleted(object arg) {
            if ((this.LookupMachineBansByMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachineBansByMachinePuidsCompleted(this, new LookupMachineBansByMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupConsoleIdsByMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachinePuidInfo[] LookupConsoleIdsByMachinePuids(ulong[] puids) {
            object[] results = this.Invoke("LookupConsoleIdsByMachinePuids", new object[] {
                        puids});
            return ((MachinePuidInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupConsoleIdsByMachinePuids(ulong[] puids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupConsoleIdsByMachinePuids", new object[] {
                        puids}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachinePuidInfo[] EndLookupConsoleIdsByMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachinePuidInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupConsoleIdsByMachinePuidsAsync(ulong[] puids) {
            this.LookupConsoleIdsByMachinePuidsAsync(puids, null);
        }
        
        /// <remarks/>
        public void LookupConsoleIdsByMachinePuidsAsync(ulong[] puids, object userState) {
            if ((this.LookupConsoleIdsByMachinePuidsOperationCompleted == null)) {
                this.LookupConsoleIdsByMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupConsoleIdsByMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("LookupConsoleIdsByMachinePuids", new object[] {
                        puids}, this.LookupConsoleIdsByMachinePuidsOperationCompleted, userState);
        }
        
        private void OnLookupConsoleIdsByMachinePuidsOperationCompleted(object arg) {
            if ((this.LookupConsoleIdsByMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupConsoleIdsByMachinePuidsCompleted(this, new LookupConsoleIdsByMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupGamertagHistoryByMachinePuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GamertagHistory LookupGamertagHistoryByMachinePuid(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> userPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, bool details) {
            object[] results = this.Invoke("LookupGamertagHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details});
            return ((GamertagHistory)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupGamertagHistoryByMachinePuid(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupGamertagHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, callback, asyncState);
        }
        
        /// <remarks/>
        public GamertagHistory EndLookupGamertagHistoryByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GamertagHistory)(results[0]));
        }
        
        /// <remarks/>
        public void LookupGamertagHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details) {
            this.LookupGamertagHistoryByMachinePuidAsync(machinePuid, userPuid, since, details, null);
        }
        
        /// <remarks/>
        public void LookupGamertagHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, object userState) {
            if ((this.LookupGamertagHistoryByMachinePuidOperationCompleted == null)) {
                this.LookupGamertagHistoryByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupGamertagHistoryByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("LookupGamertagHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, this.LookupGamertagHistoryByMachinePuidOperationCompleted, userState);
        }
        
        private void OnLookupGamertagHistoryByMachinePuidOperationCompleted(object arg) {
            if ((this.LookupGamertagHistoryByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupGamertagHistoryByMachinePuidCompleted(this, new LookupGamertagHistoryByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachineInfoByMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachineInfo[] LookupMachineInfoByMachinePuids(ulong[] puids) {
            object[] results = this.Invoke("LookupMachineInfoByMachinePuids", new object[] {
                        puids});
            return ((MachineInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachineInfoByMachinePuids(ulong[] puids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachineInfoByMachinePuids", new object[] {
                        puids}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachineInfo[] EndLookupMachineInfoByMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachineInfoByMachinePuidsAsync(ulong[] puids) {
            this.LookupMachineInfoByMachinePuidsAsync(puids, null);
        }
        
        /// <remarks/>
        public void LookupMachineInfoByMachinePuidsAsync(ulong[] puids, object userState) {
            if ((this.LookupMachineInfoByMachinePuidsOperationCompleted == null)) {
                this.LookupMachineInfoByMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachineInfoByMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("LookupMachineInfoByMachinePuids", new object[] {
                        puids}, this.LookupMachineInfoByMachinePuidsOperationCompleted, userState);
        }
        
        private void OnLookupMachineInfoByMachinePuidsOperationCompleted(object arg) {
            if ((this.LookupMachineInfoByMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachineInfoByMachinePuidsCompleted(this, new LookupMachineInfoByMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachinePuidByConsoleIdAndXuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdInfo[] LookupMachinePuidByConsoleIdAndXuid(string consoleId, ulong userId) {
            object[] results = this.Invoke("LookupMachinePuidByConsoleIdAndXuid", new object[] {
                        consoleId,
                        userId});
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachinePuidByConsoleIdAndXuid(string consoleId, ulong userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachinePuidByConsoleIdAndXuid", new object[] {
                        consoleId,
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] EndLookupMachinePuidByConsoleIdAndXuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachinePuidByConsoleIdAndXuidAsync(string consoleId, ulong userId) {
            this.LookupMachinePuidByConsoleIdAndXuidAsync(consoleId, userId, null);
        }
        
        /// <remarks/>
        public void LookupMachinePuidByConsoleIdAndXuidAsync(string consoleId, ulong userId, object userState) {
            if ((this.LookupMachinePuidByConsoleIdAndXuidOperationCompleted == null)) {
                this.LookupMachinePuidByConsoleIdAndXuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachinePuidByConsoleIdAndXuidOperationCompleted);
            }
            this.InvokeAsync("LookupMachinePuidByConsoleIdAndXuid", new object[] {
                        consoleId,
                        userId}, this.LookupMachinePuidByConsoleIdAndXuidOperationCompleted, userState);
        }
        
        private void OnLookupMachinePuidByConsoleIdAndXuidOperationCompleted(object arg) {
            if ((this.LookupMachinePuidByConsoleIdAndXuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachinePuidByConsoleIdAndXuidCompleted(this, new LookupMachinePuidByConsoleIdAndXuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachinePuidsByConsoleIdAndSCode", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdInfo[] LookupMachinePuidsByConsoleIdAndSCode(string consoleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] secondaryId) {
            object[] results = this.Invoke("LookupMachinePuidsByConsoleIdAndSCode", new object[] {
                        consoleId,
                        secondaryId});
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachinePuidsByConsoleIdAndSCode(string consoleId, byte[] secondaryId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachinePuidsByConsoleIdAndSCode", new object[] {
                        consoleId,
                        secondaryId}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] EndLookupMachinePuidsByConsoleIdAndSCode(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByConsoleIdAndSCodeAsync(string consoleId, byte[] secondaryId) {
            this.LookupMachinePuidsByConsoleIdAndSCodeAsync(consoleId, secondaryId, null);
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByConsoleIdAndSCodeAsync(string consoleId, byte[] secondaryId, object userState) {
            if ((this.LookupMachinePuidsByConsoleIdAndSCodeOperationCompleted == null)) {
                this.LookupMachinePuidsByConsoleIdAndSCodeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachinePuidsByConsoleIdAndSCodeOperationCompleted);
            }
            this.InvokeAsync("LookupMachinePuidsByConsoleIdAndSCode", new object[] {
                        consoleId,
                        secondaryId}, this.LookupMachinePuidsByConsoleIdAndSCodeOperationCompleted, userState);
        }
        
        private void OnLookupMachinePuidsByConsoleIdAndSCodeOperationCompleted(object arg) {
            if ((this.LookupMachinePuidsByConsoleIdAndSCodeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachinePuidsByConsoleIdAndSCodeCompleted(this, new LookupMachinePuidsByConsoleIdAndSCodeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachinePuidsByConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdInfo[] LookupMachinePuidsByConsoleIds(string[] consoleIds) {
            object[] results = this.Invoke("LookupMachinePuidsByConsoleIds", new object[] {
                        consoleIds});
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachinePuidsByConsoleIds(string[] consoleIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachinePuidsByConsoleIds", new object[] {
                        consoleIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] EndLookupMachinePuidsByConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByConsoleIdsAsync(string[] consoleIds) {
            this.LookupMachinePuidsByConsoleIdsAsync(consoleIds, null);
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByConsoleIdsAsync(string[] consoleIds, object userState) {
            if ((this.LookupMachinePuidsByConsoleIdsOperationCompleted == null)) {
                this.LookupMachinePuidsByConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachinePuidsByConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("LookupMachinePuidsByConsoleIds", new object[] {
                        consoleIds}, this.LookupMachinePuidsByConsoleIdsOperationCompleted, userState);
        }
        
        private void OnLookupMachinePuidsByConsoleIdsOperationCompleted(object arg) {
            if ((this.LookupMachinePuidsByConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachinePuidsByConsoleIdsCompleted(this, new LookupMachinePuidsByConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupMachinePuidsByPcTokens", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PcTokenInfo[] LookupMachinePuidsByPcTokens(byte[][] tokens) {
            object[] results = this.Invoke("LookupMachinePuidsByPcTokens", new object[] {
                        tokens});
            return ((PcTokenInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupMachinePuidsByPcTokens(byte[][] tokens, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupMachinePuidsByPcTokens", new object[] {
                        tokens}, callback, asyncState);
        }
        
        /// <remarks/>
        public PcTokenInfo[] EndLookupMachinePuidsByPcTokens(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PcTokenInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByPcTokensAsync(byte[][] tokens) {
            this.LookupMachinePuidsByPcTokensAsync(tokens, null);
        }
        
        /// <remarks/>
        public void LookupMachinePuidsByPcTokensAsync(byte[][] tokens, object userState) {
            if ((this.LookupMachinePuidsByPcTokensOperationCompleted == null)) {
                this.LookupMachinePuidsByPcTokensOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupMachinePuidsByPcTokensOperationCompleted);
            }
            this.InvokeAsync("LookupMachinePuidsByPcTokens", new object[] {
                        tokens}, this.LookupMachinePuidsByPcTokensOperationCompleted, userState);
        }
        
        private void OnLookupMachinePuidsByPcTokensOperationCompleted(object arg) {
            if ((this.LookupMachinePuidsByPcTokensCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupMachinePuidsByPcTokensCompleted(this, new LookupMachinePuidsByPcTokensCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupPassportHistoryByMachinePuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PassportHistory LookupPassportHistoryByMachinePuid(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> userPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, bool details) {
            object[] results = this.Invoke("LookupPassportHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details});
            return ((PassportHistory)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupPassportHistoryByMachinePuid(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupPassportHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, callback, asyncState);
        }
        
        /// <remarks/>
        public PassportHistory EndLookupPassportHistoryByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PassportHistory)(results[0]));
        }
        
        /// <remarks/>
        public void LookupPassportHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details) {
            this.LookupPassportHistoryByMachinePuidAsync(machinePuid, userPuid, since, details, null);
        }
        
        /// <remarks/>
        public void LookupPassportHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, object userState) {
            if ((this.LookupPassportHistoryByMachinePuidOperationCompleted == null)) {
                this.LookupPassportHistoryByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupPassportHistoryByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("LookupPassportHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, this.LookupPassportHistoryByMachinePuidOperationCompleted, userState);
        }
        
        private void OnLookupPassportHistoryByMachinePuidOperationCompleted(object arg) {
            if ((this.LookupPassportHistoryByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupPassportHistoryByMachinePuidCompleted(this, new LookupPassportHistoryByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupPcTokensByMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PcTokenInfo[] LookupPcTokensByMachinePuids(ulong[] puids) {
            object[] results = this.Invoke("LookupPcTokensByMachinePuids", new object[] {
                        puids});
            return ((PcTokenInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupPcTokensByMachinePuids(ulong[] puids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupPcTokensByMachinePuids", new object[] {
                        puids}, callback, asyncState);
        }
        
        /// <remarks/>
        public PcTokenInfo[] EndLookupPcTokensByMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PcTokenInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupPcTokensByMachinePuidsAsync(ulong[] puids) {
            this.LookupPcTokensByMachinePuidsAsync(puids, null);
        }
        
        /// <remarks/>
        public void LookupPcTokensByMachinePuidsAsync(ulong[] puids, object userState) {
            if ((this.LookupPcTokensByMachinePuidsOperationCompleted == null)) {
                this.LookupPcTokensByMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupPcTokensByMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("LookupPcTokensByMachinePuids", new object[] {
                        puids}, this.LookupPcTokensByMachinePuidsOperationCompleted, userState);
        }
        
        private void OnLookupPcTokensByMachinePuidsOperationCompleted(object arg) {
            if ((this.LookupPcTokensByMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupPcTokensByMachinePuidsCompleted(this, new LookupPcTokensByMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupRecoveryHistoryByMachinePuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RecoveryHistory LookupRecoveryHistoryByMachinePuid(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> userPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, bool details) {
            object[] results = this.Invoke("LookupRecoveryHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details});
            return ((RecoveryHistory)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupRecoveryHistoryByMachinePuid(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupRecoveryHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, callback, asyncState);
        }
        
        /// <remarks/>
        public RecoveryHistory EndLookupRecoveryHistoryByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RecoveryHistory)(results[0]));
        }
        
        /// <remarks/>
        public void LookupRecoveryHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details) {
            this.LookupRecoveryHistoryByMachinePuidAsync(machinePuid, userPuid, since, details, null);
        }
        
        /// <remarks/>
        public void LookupRecoveryHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<ulong> userPuid, System.Nullable<System.DateTime> since, bool details, object userState) {
            if ((this.LookupRecoveryHistoryByMachinePuidOperationCompleted == null)) {
                this.LookupRecoveryHistoryByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupRecoveryHistoryByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("LookupRecoveryHistoryByMachinePuid", new object[] {
                        machinePuid,
                        userPuid,
                        since,
                        details}, this.LookupRecoveryHistoryByMachinePuidOperationCompleted, userState);
        }
        
        private void OnLookupRecoveryHistoryByMachinePuidOperationCompleted(object arg) {
            if ((this.LookupRecoveryHistoryByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupRecoveryHistoryByMachinePuidCompleted(this, new LookupRecoveryHistoryByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/LookupUserHistoryByMachinePuid", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserMachineHistoryDetails[] LookupUserHistoryByMachinePuid(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("LookupUserHistoryByMachinePuid", new object[] {
                        machinePuid,
                        since});
            return ((UserMachineHistoryDetails[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupUserHistoryByMachinePuid(ulong machinePuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupUserHistoryByMachinePuid", new object[] {
                        machinePuid,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserMachineHistoryDetails[] EndLookupUserHistoryByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserMachineHistoryDetails[])(results[0]));
        }
        
        /// <remarks/>
        public void LookupUserHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<System.DateTime> since) {
            this.LookupUserHistoryByMachinePuidAsync(machinePuid, since, null);
        }
        
        /// <remarks/>
        public void LookupUserHistoryByMachinePuidAsync(ulong machinePuid, System.Nullable<System.DateTime> since, object userState) {
            if ((this.LookupUserHistoryByMachinePuidOperationCompleted == null)) {
                this.LookupUserHistoryByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLookupUserHistoryByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("LookupUserHistoryByMachinePuid", new object[] {
                        machinePuid,
                        since}, this.LookupUserHistoryByMachinePuidOperationCompleted, userState);
        }
        
        private void OnLookupUserHistoryByMachinePuidOperationCompleted(object arg) {
            if ((this.LookupUserHistoryByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LookupUserHistoryByMachinePuidCompleted(this, new LookupUserHistoryByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/ResetMachinePasswordByConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdResult[] ResetMachinePasswordByConsoleIds(string[] consoleIds) {
            object[] results = this.Invoke("ResetMachinePasswordByConsoleIds", new object[] {
                        consoleIds});
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginResetMachinePasswordByConsoleIds(string[] consoleIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ResetMachinePasswordByConsoleIds", new object[] {
                        consoleIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdResult[] EndResetMachinePasswordByConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public void ResetMachinePasswordByConsoleIdsAsync(string[] consoleIds) {
            this.ResetMachinePasswordByConsoleIdsAsync(consoleIds, null);
        }
        
        /// <remarks/>
        public void ResetMachinePasswordByConsoleIdsAsync(string[] consoleIds, object userState) {
            if ((this.ResetMachinePasswordByConsoleIdsOperationCompleted == null)) {
                this.ResetMachinePasswordByConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnResetMachinePasswordByConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("ResetMachinePasswordByConsoleIds", new object[] {
                        consoleIds}, this.ResetMachinePasswordByConsoleIdsOperationCompleted, userState);
        }
        
        private void OnResetMachinePasswordByConsoleIdsOperationCompleted(object arg) {
            if ((this.ResetMachinePasswordByConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ResetMachinePasswordByConsoleIdsCompleted(this, new ResetMachinePasswordByConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/UnbanConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdResult[] UnbanConsoleIds(string[] consoleIds, uint reasonCode) {
            object[] results = this.Invoke("UnbanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode});
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanConsoleIds(string[] consoleIds, uint reasonCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdResult[] EndUnbanConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public void UnbanConsoleIdsAsync(string[] consoleIds, uint reasonCode) {
            this.UnbanConsoleIdsAsync(consoleIds, reasonCode, null);
        }
        
        /// <remarks/>
        public void UnbanConsoleIdsAsync(string[] consoleIds, uint reasonCode, object userState) {
            if ((this.UnbanConsoleIdsOperationCompleted == null)) {
                this.UnbanConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnbanConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("UnbanConsoleIds", new object[] {
                        consoleIds,
                        reasonCode}, this.UnbanConsoleIdsOperationCompleted, userState);
        }
        
        private void OnUnbanConsoleIdsOperationCompleted(object arg) {
            if ((this.UnbanConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnbanConsoleIdsCompleted(this, new UnbanConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/UnbanMachinePuids", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachinePuidResult[] UnbanMachinePuids(ulong[] puids, uint reasonCode) {
            object[] results = this.Invoke("UnbanMachinePuids", new object[] {
                        puids,
                        reasonCode});
            return ((MachinePuidResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanMachinePuids(ulong[] puids, uint reasonCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanMachinePuids", new object[] {
                        puids,
                        reasonCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachinePuidResult[] EndUnbanMachinePuids(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachinePuidResult[])(results[0]));
        }
        
        /// <remarks/>
        public void UnbanMachinePuidsAsync(ulong[] puids, uint reasonCode) {
            this.UnbanMachinePuidsAsync(puids, reasonCode, null);
        }
        
        /// <remarks/>
        public void UnbanMachinePuidsAsync(ulong[] puids, uint reasonCode, object userState) {
            if ((this.UnbanMachinePuidsOperationCompleted == null)) {
                this.UnbanMachinePuidsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnbanMachinePuidsOperationCompleted);
            }
            this.InvokeAsync("UnbanMachinePuids", new object[] {
                        puids,
                        reasonCode}, this.UnbanMachinePuidsOperationCompleted, userState);
        }
        
        private void OnUnbanMachinePuidsOperationCompleted(object arg) {
            if ((this.UnbanMachinePuidsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnbanMachinePuidsCompleted(this, new UnbanMachinePuidsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/UnbanPcTokens", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PcTokenBanResult[] UnbanPcTokens(byte[][] tokens) {
            object[] results = this.Invoke("UnbanPcTokens", new object[] {
                        tokens});
            return ((PcTokenBanResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanPcTokens(byte[][] tokens, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanPcTokens", new object[] {
                        tokens}, callback, asyncState);
        }
        
        /// <remarks/>
        public PcTokenBanResult[] EndUnbanPcTokens(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PcTokenBanResult[])(results[0]));
        }
        
        /// <remarks/>
        public void UnbanPcTokensAsync(byte[][] tokens) {
            this.UnbanPcTokensAsync(tokens, null);
        }
        
        /// <remarks/>
        public void UnbanPcTokensAsync(byte[][] tokens, object userState) {
            if ((this.UnbanPcTokensOperationCompleted == null)) {
                this.UnbanPcTokensOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnbanPcTokensOperationCompleted);
            }
            this.InvokeAsync("UnbanPcTokens", new object[] {
                        tokens}, this.UnbanPcTokensOperationCompleted, userState);
        }
        
        private void OnUnbanPcTokensOperationCompleted(object arg) {
            if ((this.UnbanPcTokensCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnbanPcTokensCompleted(this, new UnbanPcTokensCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:machine-data/VerifyXbox360ConsoleIds", RequestNamespace="urn:schemas-xbox-com:machine-data", ResponseNamespace="urn:schemas-xbox-com:machine-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleIdResult[] VerifyXbox360ConsoleIds(string[] consoleIds) {
            object[] results = this.Invoke("VerifyXbox360ConsoleIds", new object[] {
                        consoleIds});
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginVerifyXbox360ConsoleIds(string[] consoleIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("VerifyXbox360ConsoleIds", new object[] {
                        consoleIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleIdResult[] EndVerifyXbox360ConsoleIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleIdResult[])(results[0]));
        }
        
        /// <remarks/>
        public void VerifyXbox360ConsoleIdsAsync(string[] consoleIds) {
            this.VerifyXbox360ConsoleIdsAsync(consoleIds, null);
        }
        
        /// <remarks/>
        public void VerifyXbox360ConsoleIdsAsync(string[] consoleIds, object userState) {
            if ((this.VerifyXbox360ConsoleIdsOperationCompleted == null)) {
                this.VerifyXbox360ConsoleIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnVerifyXbox360ConsoleIdsOperationCompleted);
            }
            this.InvokeAsync("VerifyXbox360ConsoleIds", new object[] {
                        consoleIds}, this.VerifyXbox360ConsoleIdsOperationCompleted, userState);
        }
        
        private void OnVerifyXbox360ConsoleIdsOperationCompleted(object arg) {
            if ((this.VerifyXbox360ConsoleIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.VerifyXbox360ConsoleIdsCompleted(this, new VerifyXbox360ConsoleIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class ConsoleIdResult {
        
        private string consoleIdField;
        
        private uint resultField;
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint Result {
            get {
                return this.resultField;
            }
            set {
                this.resultField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class UserMachineHistoryDetails {
        
        private ulong userPuidField;
        
        private System.Nullable<ulong> machinePuidField;
        
        private int daysSeenField;
        
        private string ipAddressField;
        
        private System.DateTime firstSigninField;
        
        private System.DateTime lastSigninField;
        
        private System.DateTime lastSignoutField;
        
        private string friendlyNameField;
        
        private int trustLevelField;
        
        /// <remarks/>
        public ulong UserPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public int DaysSeen {
            get {
                return this.daysSeenField;
            }
            set {
                this.daysSeenField = value;
            }
        }
        
        /// <remarks/>
        public string IpAddress {
            get {
                return this.ipAddressField;
            }
            set {
                this.ipAddressField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime FirstSignin {
            get {
                return this.firstSigninField;
            }
            set {
                this.firstSigninField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastSignin {
            get {
                return this.lastSigninField;
            }
            set {
                this.lastSigninField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastSignout {
            get {
                return this.lastSignoutField;
            }
            set {
                this.lastSignoutField = value;
            }
        }
        
        /// <remarks/>
        public string FriendlyName {
            get {
                return this.friendlyNameField;
            }
            set {
                this.friendlyNameField = value;
            }
        }
        
        /// <remarks/>
        public int TrustLevel {
            get {
                return this.trustLevelField;
            }
            set {
                this.trustLevelField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class PcTokenInfo {
        
        private ulong machinePuidField;
        
        private byte[] voucherHashField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] VoucherHash {
            get {
                return this.voucherHashField;
            }
            set {
                this.voucherHashField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class ConsoleIdInfo {
        
        private ulong machinePuidField;
        
        private string consoleIdField;
        
        private byte[] secondaryIdentifierField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SecondaryIdentifier {
            get {
                return this.secondaryIdentifierField;
            }
            set {
                this.secondaryIdentifierField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class MachineInfo {
        
        private ulong machinePuidField;
        
        private string consoleIdField;
        
        private byte[] secondaryIdentifierField;
        
        private System.DateTime resetDateField;
        
        private System.DateTime createDateField;
        
        private string flashVersionField;
        
        private System.DateTime flashDateField;
        
        private int consoleRegionField;
        
        private string updateVersionField;
        
        private System.DateTime updateDateField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SecondaryIdentifier {
            get {
                return this.secondaryIdentifierField;
            }
            set {
                this.secondaryIdentifierField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ResetDate {
            get {
                return this.resetDateField;
            }
            set {
                this.resetDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
        /// <remarks/>
        public string FlashVersion {
            get {
                return this.flashVersionField;
            }
            set {
                this.flashVersionField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime FlashDate {
            get {
                return this.flashDateField;
            }
            set {
                this.flashDateField = value;
            }
        }
        
        /// <remarks/>
        public int ConsoleRegion {
            get {
                return this.consoleRegionField;
            }
            set {
                this.consoleRegionField = value;
            }
        }
        
        /// <remarks/>
        public string UpdateVersion {
            get {
                return this.updateVersionField;
            }
            set {
                this.updateVersionField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime UpdateDate {
            get {
                return this.updateDateField;
            }
            set {
                this.updateDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RecoveryHistory))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportHistory))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagHistory))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class HistorySummary {
        
        private System.Nullable<System.DateTime> firstField;
        
        private System.Nullable<System.DateTime> lastField;
        
        private int totalField;
        
        private int uniqueField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> First {
            get {
                return this.firstField;
            }
            set {
                this.firstField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> Last {
            get {
                return this.lastField;
            }
            set {
                this.lastField = value;
            }
        }
        
        /// <remarks/>
        public int Total {
            get {
                return this.totalField;
            }
            set {
                this.totalField = value;
            }
        }
        
        /// <remarks/>
        public int Unique {
            get {
                return this.uniqueField;
            }
            set {
                this.uniqueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class RecoveryHistory : HistorySummary {
        
        private RecoveryHistoryDetails[] detailsField;
        
        /// <remarks/>
        public RecoveryHistoryDetails[] Details {
            get {
                return this.detailsField;
            }
            set {
                this.detailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class RecoveryHistoryDetails : HistoryDetails {
        
        private ulong passportPuidField;
        
        /// <remarks/>
        public ulong PassportPuid {
            get {
                return this.passportPuidField;
            }
            set {
                this.passportPuidField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RecoveryHistoryDetails))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportHistoryDetails))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagHistoryDetails))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public abstract partial class HistoryDetails {
        
        private ulong userPuidField;
        
        private ulong machinePuidField;
        
        private string ipAddressField;
        
        private System.DateTime timestampField;
        
        private uint hResultField;
        
        private byte reasonField;
        
        /// <remarks/>
        public ulong UserPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string IpAddress {
            get {
                return this.ipAddressField;
            }
            set {
                this.ipAddressField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Timestamp {
            get {
                return this.timestampField;
            }
            set {
                this.timestampField = value;
            }
        }
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public byte Reason {
            get {
                return this.reasonField;
            }
            set {
                this.reasonField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class PassportHistoryDetails : HistoryDetails {
        
        private System.Nullable<ulong> oldPassportPuidField;
        
        private System.Nullable<ulong> newPassportPuidField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> OldPassportPuid {
            get {
                return this.oldPassportPuidField;
            }
            set {
                this.oldPassportPuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> NewPassportPuid {
            get {
                return this.newPassportPuidField;
            }
            set {
                this.newPassportPuidField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class GamertagHistoryDetails : HistoryDetails {
        
        private string oldGamertagField;
        
        private string newGamertagField;
        
        /// <remarks/>
        public string OldGamertag {
            get {
                return this.oldGamertagField;
            }
            set {
                this.oldGamertagField = value;
            }
        }
        
        /// <remarks/>
        public string NewGamertag {
            get {
                return this.newGamertagField;
            }
            set {
                this.newGamertagField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class PassportHistory : HistorySummary {
        
        private PassportHistoryDetails[] detailsField;
        
        /// <remarks/>
        public PassportHistoryDetails[] Details {
            get {
                return this.detailsField;
            }
            set {
                this.detailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class GamertagHistory : HistorySummary {
        
        private GamertagHistoryDetails[] detailsField;
        
        /// <remarks/>
        public GamertagHistoryDetails[] Details {
            get {
                return this.detailsField;
            }
            set {
                this.detailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class MachinePuidInfo {
        
        private ulong machinePuidField;
        
        private string consoleIdField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class MachineBanInfo {
        
        private ulong machinePuidField;
        
        private string consoleIdField;
        
        private uint reasonCodeField;
        
        private System.DateTime banStartField;
        
        private System.DateTime banEndField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint ReasonCode {
            get {
                return this.reasonCodeField;
            }
            set {
                this.reasonCodeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanStart {
            get {
                return this.banStartField;
            }
            set {
                this.banStartField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanEnd {
            get {
                return this.banEndField;
            }
            set {
                this.banEndField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class ConsoleBanInfo {
        
        private string consoleIdField;
        
        private uint reasonCodeField;
        
        private System.DateTime banStartField;
        
        private System.DateTime banEndField;
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint ReasonCode {
            get {
                return this.reasonCodeField;
            }
            set {
                this.reasonCodeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanStart {
            get {
                return this.banStartField;
            }
            set {
                this.banStartField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanEnd {
            get {
                return this.banEndField;
            }
            set {
                this.banEndField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class MachineBanHistoryInfo {
        
        private ulong machinePuidField;
        
        private System.DateTime entryDateField;
        
        private uint reasonCodeField;
        
        private System.DateTime banStartField;
        
        private System.DateTime banEndField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EntryDate {
            get {
                return this.entryDateField;
            }
            set {
                this.entryDateField = value;
            }
        }
        
        /// <remarks/>
        public uint ReasonCode {
            get {
                return this.reasonCodeField;
            }
            set {
                this.reasonCodeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanStart {
            get {
                return this.banStartField;
            }
            set {
                this.banStartField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BanEnd {
            get {
                return this.banEndField;
            }
            set {
                this.banEndField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class PcTokenBanResult {
        
        private byte[] voucherHashField;
        
        private uint resultField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] VoucherHash {
            get {
                return this.voucherHashField;
            }
            set {
                this.voucherHashField = value;
            }
        }
        
        /// <remarks/>
        public uint Result {
            get {
                return this.resultField;
            }
            set {
                this.resultField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:machine-data")]
    public partial class MachinePuidResult {
        
        private ulong machinePuidField;
        
        private uint resultField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public uint Result {
            get {
                return this.resultField;
            }
            set {
                this.resultField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BanConsoleIdsCompletedEventHandler(object sender, BanConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BanConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BanConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BanMachinePuidsCompletedEventHandler(object sender, BanMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BanMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BanMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachinePuidResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachinePuidResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BanPcTokensCompletedEventHandler(object sender, BanPcTokensCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BanPcTokensCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BanPcTokensCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PcTokenBanResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PcTokenBanResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IsConsoleIdAndSCodeBannedCompletedEventHandler(object sender, IsConsoleIdAndSCodeBannedCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IsConsoleIdAndSCodeBannedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal IsConsoleIdAndSCodeBannedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LogGamertagHistoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LogPassportHistoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LogRecoveryHistoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupBanHistoryByMachinePuidCompletedEventHandler(object sender, LookupBanHistoryByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupBanHistoryByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupBanHistoryByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachineBanHistoryInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineBanHistoryInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupConsoleBansByConsoleIdsCompletedEventHandler(object sender, LookupConsoleBansByConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupConsoleBansByConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupConsoleBansByConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleBanInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleBanInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachineBansByConsoleIdsCompletedEventHandler(object sender, LookupMachineBansByConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachineBansByConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachineBansByConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachineBanInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineBanInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupConsoleBansByMachinePuidsCompletedEventHandler(object sender, LookupConsoleBansByMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupConsoleBansByMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupConsoleBansByMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleBanInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleBanInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachineBansByMachinePuidsCompletedEventHandler(object sender, LookupMachineBansByMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachineBansByMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachineBansByMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachineBanInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineBanInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupConsoleIdsByMachinePuidsCompletedEventHandler(object sender, LookupConsoleIdsByMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupConsoleIdsByMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupConsoleIdsByMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachinePuidInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachinePuidInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupGamertagHistoryByMachinePuidCompletedEventHandler(object sender, LookupGamertagHistoryByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupGamertagHistoryByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupGamertagHistoryByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GamertagHistory Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GamertagHistory)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachineInfoByMachinePuidsCompletedEventHandler(object sender, LookupMachineInfoByMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachineInfoByMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachineInfoByMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachineInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachinePuidByConsoleIdAndXuidCompletedEventHandler(object sender, LookupMachinePuidByConsoleIdAndXuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachinePuidByConsoleIdAndXuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachinePuidByConsoleIdAndXuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachinePuidsByConsoleIdAndSCodeCompletedEventHandler(object sender, LookupMachinePuidsByConsoleIdAndSCodeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachinePuidsByConsoleIdAndSCodeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachinePuidsByConsoleIdAndSCodeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachinePuidsByConsoleIdsCompletedEventHandler(object sender, LookupMachinePuidsByConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachinePuidsByConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachinePuidsByConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupMachinePuidsByPcTokensCompletedEventHandler(object sender, LookupMachinePuidsByPcTokensCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupMachinePuidsByPcTokensCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupMachinePuidsByPcTokensCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PcTokenInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PcTokenInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupPassportHistoryByMachinePuidCompletedEventHandler(object sender, LookupPassportHistoryByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupPassportHistoryByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupPassportHistoryByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PassportHistory Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PassportHistory)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupPcTokensByMachinePuidsCompletedEventHandler(object sender, LookupPcTokensByMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupPcTokensByMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupPcTokensByMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PcTokenInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PcTokenInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupRecoveryHistoryByMachinePuidCompletedEventHandler(object sender, LookupRecoveryHistoryByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupRecoveryHistoryByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupRecoveryHistoryByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public RecoveryHistory Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RecoveryHistory)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LookupUserHistoryByMachinePuidCompletedEventHandler(object sender, LookupUserHistoryByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LookupUserHistoryByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LookupUserHistoryByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserMachineHistoryDetails[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserMachineHistoryDetails[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ResetMachinePasswordByConsoleIdsCompletedEventHandler(object sender, ResetMachinePasswordByConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ResetMachinePasswordByConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ResetMachinePasswordByConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnbanConsoleIdsCompletedEventHandler(object sender, UnbanConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnbanConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UnbanConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnbanMachinePuidsCompletedEventHandler(object sender, UnbanMachinePuidsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnbanMachinePuidsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UnbanMachinePuidsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachinePuidResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachinePuidResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnbanPcTokensCompletedEventHandler(object sender, UnbanPcTokensCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnbanPcTokensCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UnbanPcTokensCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PcTokenBanResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PcTokenBanResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void VerifyXbox360ConsoleIdsCompletedEventHandler(object sender, VerifyXbox360ConsoleIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class VerifyXbox360ConsoleIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal VerifyXbox360ConsoleIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleIdResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleIdResult[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\HttpFilterClient.cpp ===
#include "StdAfx.h"

//
//  Callback functions
//

BOOL WINAPI GetServerVariable(
    PHTTP_FILTER_CONTEXT pfc,
    LPSTR lpszVariableName,
    LPVOID lpvBuffer,
    LPDWORD lpdwSize
    )
{
    HttpFilterClient* pClient = (HttpFilterClient*)pfc->ServerContext;
    return pClient->GetServerVariable(pfc, lpszVariableName, lpvBuffer, lpdwSize);
}

BOOL WINAPI AddResponseHeaders(
    PHTTP_FILTER_CONTEXT pfc,
    LPSTR lpszHeaders,
    LPSTR dwReserved
    )
{
    HttpFilterClient* pClient = (HttpFilterClient*)pfc->ServerContext;
    return pClient->AddResponseHeaders(pfc, lpszHeaders, dwReserved);
}

BOOL WINAPI WriteClient(
    PHTTP_FILTER_CONTEXT pfc,
    LPVOID buffer,
    LPDWORD lpdwBytes,
    DWORD dwReserved
    )
{
    HttpFilterClient* pClient = (HttpFilterClient*)pfc->ServerContext;
    return pClient->WriteClient(pfc, buffer, lpdwBytes, dwReserved);
}

HttpFilterClient::HttpFilterClient(LPCWSTR wszFilter)
{
    wcscpy(m_wszFilter, wszFilter);
    memset(&m_FilterVersion, 0, sizeof(HTTP_FILTER_VERSION));
}

BOOL HttpFilterClient::Load()
{
    m_hFilter = LoadLibraryW(m_wszFilter);
    if(m_hFilter == NULL)
        return FALSE;

    m_pfnGetFilterVersion = (GETFILTERVERSIONPROC)GetProcAddress(m_hFilter, "GetFilterVersion");
    m_pfnHttpFilterProc = (HTTPFILTERPROC)GetProcAddress(m_hFilter, "HttpFilterProc");
    m_pfnTerminateFilter = (TERMINATEFILTERPROC)GetProcAddress(m_hFilter, "TerminateFilter");

    return (*m_pfnGetFilterVersion)(&m_FilterVersion);
}

DWORD HttpFilterClient::ProcessRequest(
    BOOL fIsSecure,                                       
    LPCWSTR wszMethod,
    LPCWSTR wszUrl,
    LPCWSTR wszHeaders)
{
    HTTP_FILTER_CONTEXT fc;
    fc.cbSize = sizeof(HTTP_FILTER_CONTEXT);
    fc.Revision = 0;
    fc.ServerContext = (LPVOID)this;
    fc.ulReserved = 0;
    fc.fIsSecurePort = fIsSecure;
    fc.pFilterContext = NULL;


    HTTP_FILTER_PREPROC_HEADERS pph;
    
    DWORD dwRet = (*m_pfnHttpFilterProc)(&fc, SF_NOTIFY_PREPROC_HEADERS, (LPVOID)&pph);

    return dwRet;
}

//
//  Callback functions
//

BOOL HttpFilterClient::GetServerVariable(
    PHTTP_FILTER_CONTEXT pfc,
    LPSTR lpszVariableName,
    LPVOID lpvBuffer,
    LPDWORD lpdwSize
    )
{
    return TRUE;
}

BOOL HttpFilterClient::AddResponseHeaders(
    PHTTP_FILTER_CONTEXT pfc,
    LPSTR lpszHeaders,
    LPSTR dwReserved
    )
{
    return TRUE;
}

BOOL HttpFilterClient::WriteClient(
    PHTTP_FILTER_CONTEXT pfc,
    LPVOID buffer,
    LPDWORD lpdwBytes,
    DWORD dwReserved
    )
{
    return TRUE;
}

HttpFilterClient::~HttpFilterClient(void)
{
    if(m_hFilter != NULL)
    {
        FreeLibrary(m_hFilter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan_cfg\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan\xrlscantest\xrlscantestapp.cpp ===
// xrlscantest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

HttpFilterClient *g_pXrlscan;

int __cdecl wmain(int argc, WCHAR* argv[])
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    g_pXrlscan = new HttpFilterClient(L"xrlscan.dll");

    if(!g_pXrlscan->Load())
        goto Cleanup;

    while(true) Sleep(3600000);

Cleanup:

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\contracts\xsecsupdatacontractv1.cs ===
using System;
using System.Runtime.Serialization;
using System.ServiceModel;

namespace xonline.xsecsup.contract
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xrlscan_cfg\xrlscan_cfg.cs ===
//
// Content Download configurator stub
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Content download service configurator stub
// Xbox Online Service
//
// Author: Michio Nikaido (michion)
//

using xonline.common.config;
using xonline.common.installer;

[assembly: XomXRLScanInstallerAttribute( Interface.xrlscan )]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\contracts\xsecsupservicecontractv1.cs ===
using System;
using System.ServiceModel;

using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xsecsup.contract
{   
    [ServiceContract(Name = "IXSecSup", Namespace = "http://xonline.xsecsup.V1")]
    public interface IXSecSup
    {
        [OperationContract(Name = "TestConnection")]
        string TestConnection(string testData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XrlScanManaged\XrlInfo.cs ===
﻿///
/// Implementation of the XrlInfo class.
/// 
namespace xonline.server.xrlscanmanaged
{
    using System.Data.SqlClient;

    /// <summary>
    /// Contains the information of interest needed to scan for XRL Policies
    /// </summary>
    internal sealed class XrlInfo
    {
        /// <summary>
        /// Constructs the class based on the response from a SQL Query to NPDB
        /// 
        /// TODO: How to deal with SQL Errors.  Probably toss them up to the owner of the reader.
        /// </summary>
        /// <param name="reader">Reads the results of the query.</param>
        public XrlInfo(SqlDataReader reader)
        {
            this.Xrl = reader["vc_xrl"] as string;
            this.MaxUrlLen = (int)reader["i_max_url_length"];
            this.MaxContentLen = (int)reader["i_max_content_length"];
            this.MaxQueryStringLen = (int)reader["i_max_query_string_length"];
            this.AllowTextXmlType = (byte)reader["ti_allow_text_xml_type"] == 1 ? true : false;
            this.DontGetSgInfo = (byte)reader["ti_dont_get_sg_info"] == 1 ? true : false;
            this.AllowNoExactMatch = (byte)reader["ti_allow_no_exact_match"] == 1 ? true : false;
            this.Port = (int)reader["i_port"];
            this.BlockLimitedPcAccount = (byte)reader["ti_block_limited_pc_account"] == 1 ? true : false;
        }

        /// <summary>
        /// Gets the Xrl
        /// </summary>
        public string Xrl
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the max length of the Xrl
        /// </summary>
        public int MaxUrlLen
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the max content length associated with the Xrl
        /// </summary>
        public int MaxContentLen
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the max length of the query string.
        /// </summary>
        public int MaxQueryStringLen
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets wheather we are allowed to use XML content types.
        /// </summary>
        public bool AllowTextXmlType
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the DontGetSGInfo flag
        /// </summary>
        public bool DontGetSgInfo
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets wheather an exact match is required to process the XRL.
        /// </summary>
        public bool AllowNoExactMatch
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the port on which the XRL may be accessed
        /// </summary>
        public int Port
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets wheather limited PCs should be allowed to access the 
        /// </summary>
        public bool BlockLimitedPcAccount
        {
            get;
            private set;
        }

        public override string ToString()
        {
            return string.Format(
                "{0}\r\n Port:{1}\tAllow No Exact Match:{2}\tDont Get SG Info:{3}\tBlock Limited:{4}\ttext/xml ok:{5}",
                this.Xrl, 
                this.Port, 
                this.AllowNoExactMatch, 
                this.DontGetSgInfo, 
                this.BlockLimitedPcAccount, 
                this.AllowTextXmlType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XrlScanManaged\XrlMappings.cs ===
﻿///
/// Implementation of the XRL Mappings class.
/// 
namespace xonline.server.xrlscanmanaged
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Text;
    using xonline.common.config;

    /// <summary>
    /// The XrlMappings class is implemented as a singleton instance of a List of XrlInfo objects.
    /// Its purpose is simply to:
    /// 1. Provide read only access to the Singleton
    /// 2. Create a new instance from SQL Data when instructed
    /// 3. Atomically replace the old instance with the new when the mappings have been updated.
    /// </summary>
    internal sealed class XrlMappings : List<XrlInfo>
    {
        /// <summary>
        /// Simply creates an empty instance of the XrlMappings class.
        /// </summary>
        static XrlMappings()
        {
            XrlMappings.Instance = new XrlMappings();
            XrlMappings.Loaded = false;
        }

        /// <summary>
        /// Prevents the class frpm having a visible default constructor.
        /// </summary>
        private XrlMappings()
        {
            this.AllowHead = false;
        }

        /// <summary>
        /// Gets whether the mappings have been loaded.
        /// </summary>
        public static bool Loaded
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the current instance of the XrlMappings.
        /// </summary>
        public static XrlMappings Instance
        {
            get;
            private set;
        }

        /// <summary>
        /// Creates a new instance of the XrlMappings, loads it from SQL and makes it 
        /// available through the Instance field.
        /// 
        /// TODO: How to deal with SQL Errors.
        /// </summary>
        public static void Reload()
        {
            XrlMappings newMappings = new XrlMappings();

            using (SqlConnection conn = new SqlConnection(Config.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = new SqlCommand("p_xrlscan_get_valid_xrls", conn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandTimeout = Config.NpdbConnectionTimeout;
                    cmd.Parameters.Add(new SqlParameter("@vc_server", Config.Server));
                    cmd.Parameters.Add(new SqlParameter("@vc_vsite", XrlScan.VSite));
                    cmd.Parameters.Add(new SqlParameter("@vc_vdir", XrlScan.VDir));
                    cmd.Parameters.Add(new SqlParameter("@vc_environment", Config.Environment));
                    
                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            newMappings.Add(new XrlInfo(reader));
                        }

                        if (reader.NextResult())
                        {
                            while (reader.Read())
                            {
                                if ((reader["vc_setting"] as string).Equals("xrlscan_allowHead", StringComparison.InvariantCultureIgnoreCase))
                                {
                                    string value = reader["vc_value"] as string;
                                    if (value.Equals("true", StringComparison.InvariantCultureIgnoreCase) ||
                                        value.Equals("1", StringComparison.InvariantCultureIgnoreCase) ||
                                        value.Equals("on", StringComparison.InvariantCultureIgnoreCase))
                                    {
                                        newMappings.AllowHead = true;
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
            }

            XrlMappings.Instance = newMappings;
            XrlMappings.Loaded = true;
        }

        /// <summary>
        /// Is the head method allowed.
        /// </summary>
        public bool AllowHead
        {
            get;
            private set;
        }

        /// <summary>
        /// Lists the current mappings in string format.
        /// </summary>
        /// <returns>A string containing the mappings report.</returns>
        public string ListMappings()
        {
            StringBuilder sb = new StringBuilder();
            if (this.Count == 0)
            {
                sb.AppendLine("No mappings loaded.");
            }
            else
            {
                foreach (XrlInfo xrlInfo in this)
                {
                    sb.AppendLine(xrlInfo.ToString());
                }
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.xsecsup.service
{
    [RunInstaller(true)]
    public class Installer : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class PerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\logging.cs ===
using System;
using System.Globalization;

using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.xsecsup.service
{
    internal class Logging
    {

        internal static void Init()
        {
        }

        internal static void NtEvent(ExceptionWithEventId e, string format, params object[] args)
        {
            Xom.NtEvent(((ExceptionWithEventId) e).EventId, (Exception) e, format, args);
        }

        internal static void NtEvent(XEvent.Id eventId, Exception e, string format, params object[] args)
        {
            Xom.NtEvent(eventId, e, format, args);
        }

        internal static void NtEvent(XEvent.Id eventId, string format, params object[] args)
        {
            Xom.NtEvent(eventId, format, args);
        }

        internal static void Log(Exception e)
        {
            Xom.Log(XomAreaName.log, "{0}", e.ToString());
        }
 
        internal static void Log(string logMsg)
        {
            Xom.Log(XomAreaName.log, logMsg);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\health.cs ===
using System;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

using xonline.common.health;

namespace xonline.xsecsup.service
{

    public class XSecsupHealthRequest : BaseHealthRequest
    {
       public override void ProcessRequest( HttpContext ctx )
       {
           if (!IsHealthInitialized)
           {
               Management.Init();

               IsHealthInitialized = true;
           }

           base.ProcessRequest( ctx );

       }
      
       private bool IsHealthInitialized = false;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\servicehostfactory.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;

using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.mgmt;

//This cannot be used with wcf unless you move to .NET 4.0
//It is a bug in 3.5 where you cannot have two base
//addresses for the same service, even if the ports
//are different
//[assembly: XomIisInstallerAttribute(Interface.xsecsup)]
[assembly: XomIisInstallerAttribute(Interface.xsecsup_int)]
[assembly: ConfigAttribute(Component.xsecsup)]

namespace xonline.xsecsup.service
{
    /// <summary>
    /// This is the class that hooks into the service host initialization performed by IIS. It 
    /// adds event handlers for the state transition events and is the place where you can put 
    /// init code. XSecsup.svc sets its ServiceHost object's factory property to this one.
    /// </summary>
    public class ServiceHostFactory : ServiceHostFactoryBase
    {
        public override System.ServiceModel.ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses)
        {
            ServiceHost host = new ServiceHost(typeof(XSecSup), baseAddresses);

            host.Description.Behaviors.Add(new ErrorHandler());
            host.Description.Behaviors.Add(new CounterServiceBehavior());

            host.Opening += new EventHandler(ServiceHost_Opening);
            host.Opened += new EventHandler(ServiceHost_Opened);
            host.Closing += new EventHandler(ServiceHost_Closing);
            host.Closed += new EventHandler(ServiceHost_Closed);
            host.Faulted += new EventHandler(ServiceHost_Faulted);
            host.UnknownMessageReceived += new EventHandler<UnknownMessageReceivedEventArgs>(ServiceHost_UnknownMessageReceived);

            return host;
        }

        void ServiceHost_Opening(object sender, EventArgs e)
        {
        }

        void ServiceHost_Opened(object sender, EventArgs e)
        {
            EventBuilder.ShowSGInfo = false;
            Management.Init();
            Logging.Init();
        }

        void ServiceHost_Closing(object sender, EventArgs e)
        {
        }

        void ServiceHost_Closed(object sender, EventArgs e)
        {
        }

        void ServiceHost_Faulted(object sender, EventArgs e)
        {
        }

        void ServiceHost_UnknownMessageReceived(object sender, UnknownMessageReceivedEventArgs e)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\management.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.xsecsup.service
{
    public class Management
    {
        public static void Init()
        {
            Config.Assembly = Assembly.GetExecutingAssembly();
            XomLoggingControl.Init();

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(Config.Assembly.GetName().Name + " help:\r\n" +
                                                          "    echo [value] -- Echos the value.\r\n" +
                                                          "\r\n",
                                                        args.RequestId);

                        args.Handled = true;
                        break;

                    case "echo":
                        string val = args.CommandArgs[0];
                        XomControlConnection.SendMessage("Echo:" + val, args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch (Exception e)
            {
                HResult hr = XRLException.ToHResult(e, HResult.E_FAIL);
                XomControlConnection.SendMessage(string.Format("Error: {0}, hr = {1}\r\n\r\n", e.ToString(), hr), args.RequestId);

                Logging.Log(e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XrlScanManaged\XrlScan.cs ===
﻿///
/// A managed Implementation of XRLScan
/// 
/// Owner: dmercer
namespace xonline.server.xrlscanmanaged
{
    using System;
    using System.Collections.Generic;
    using System.Text;
    using System.Web;
    using xonline.common.config;
    using xonline.common.mgmt;

    /// <summary>
    /// A managed implementation of the XrlScan ISAPI DLL.
    /// </summary>
    public sealed class XrlScan : IHttpModule
    {
        /// <summary>
        /// A delegate to handle xmgmt commands.
        /// </summary>
        /// <param name="sender">The source of the command.</param>
        /// <param name="args">The arguements associated with the command.</param>
        private delegate void dCommandHandler(object sender, ControlRequestEventArgs args);

        /// <summary>
        /// Help Text
        /// </summary>
        private static readonly string HelpText =
            Environment.NewLine +
            Environment.NewLine +
            "XrlScan Help:" + Environment.NewLine +
                "  reload_mappings -- Force Xrl mappings to be reload" + Environment.NewLine +
                "  list_mappings -- Enumerate currently loaded mappings" + Environment.NewLine +
                "  help -- This message" + Environment.NewLine;

        /// <summary>
        /// A mapping if text commands to their associated command handler.
        /// </summary>
        private static readonly Dictionary<string, XrlScan.dCommandHandler> commandHandlers =
            new Dictionary<string, XrlScan.dCommandHandler>();

        /// <summary>
        /// Loaded with the names of the app domains that require processing on the return.
        /// This was hard coded in the original XrlScan code so I did likewise.
        /// </summary>
        private static readonly string[] processSendResponseAppPools = 
        {
            "catalog-catalog",
            "xbos-xbos",
            "marketplacecatalog-marketplacecatalog"
        };

        /// <summary>
        /// The name of the app pool that the class is loaded in.
        /// </summary>
        private static readonly string appPool;

        /// <summary>
        /// True if the XrlRequires return processing.
        /// </summary>
        private static readonly bool requiresResponseProcessing;

        /// <summary>
        /// Gets the virtual site as extracted from the app pool name
        /// </summary>
        internal static string VSite
        {
            get;
            private set;
        }

        /// <summary>
        /// The virtual directory as extracted from the app pool name.
        /// </summary>
        internal static string VDir
        {
            get;
            private set;
        }

        /// <summary>
        /// This is the name used to address the host process through the xmgmt console.
        /// </summary>
        internal static string ManagementName
        {
            get;
            private set;
        }

        /// <summary>
        /// The Http application initializing XRLScan.
        /// </summary>
        private HttpApplication HttpApplication
        {
            get;
            set;
        }

        /// <summary>
        /// BeginRequest evt handler.
        /// </summary>
        private EventHandler BeginRequestEventHandler
        {
            get;
            set;
        }

        /// <summary>
        /// End request evt handler
        /// </summary>
        private EventHandler EndRequestEventHandler
        {
            get;
            set;
        }

        /// <summary>
        /// If the XRL is valid
        /// </summary>
        private bool isValidXrl = true;

        /// <summary>
        /// Static constructor.  Does a bunch of work around parsing the name of the 
        /// app pool, registering static call backs, etc.
        /// </summary>
        static XrlScan()
        {
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_INFO, "XrlScan HTTP Module class initializing.");

            try
            {
                #region Parse various aspects of the App Pool name into various strings and other names.
                XrlScan.appPool = Environment.GetEnvironmentVariable("APP_POOL_ID");
                if (string.IsNullOrEmpty(XrlScan.appPool))
                {
                    // TODO: Need to do something more gentle here.
                    throw new ApplicationException("Cannot identify the ApplicationPool");
                }

                string[] appPoolIdFragements = XrlScan.appPool.Split('-');

                if ((appPoolIdFragements == null) ||
                    (appPoolIdFragements.Length != 2))
                {
                    //TODO:  What to do?
                    return;
                }

                XrlScan.VSite = appPoolIdFragements[0];
                XrlScan.VDir = appPoolIdFragements[1];

                if (string.IsNullOrEmpty(XrlScan.VSite) ||
                    string.IsNullOrEmpty(XrlScan.VDir))
                {
                    //TODO: What to do here?
                    return;
                }

                // We need to do this because if we don't, listing components in 
                // xmgmtc causes every w3wp process to show up as XblConfig

                XrlScan.ManagementName = string.Format("{0}-xrlScan", XrlScan.VDir);

                XomControlConnection.Startup(XrlScan.ManagementName);
                #endregion

                #region Is Outbound processing required for this app pool?
                foreach (string ap in XrlScan.processSendResponseAppPools)
                {
                    if (string.Equals(XrlScan.appPool, ap, StringComparison.InvariantCultureIgnoreCase))
                    {
                        XrlScan.requiresResponseProcessing = true;
                        break;
                    }
                }
                #endregion

                // Map xmgmt text commands to the approptiate handler.
                XrlScan.commandHandlers.Add("reload_mappings", new XrlScan.dCommandHandler(OnReloadMappings));
                XrlScan.commandHandlers.Add("list_mappings", new XrlScan.dCommandHandler(OnListMappings));
                XrlScan.commandHandlers.Add("help", new XrlScan.dCommandHandler(OnHelp));

                // Register for xmgmt control commands.
                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XomControl_ControlRequestEvent);

                Xom.Trace(
                    XomAreaName.xrltrace,
                    LogLevel.L_INFO,
                    "XrlScan initialized for appPool:{0}, vSite:{1}, vDir:{2}, ManagementName:{3}, requiresResponseProcessing:{4}",
                    XrlScan.appPool,
                    XrlScan.VSite,
                    XrlScan.VDir,
                    XrlScan.ManagementName,
                    XrlScan.requiresResponseProcessing);
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_ERROR, "Exception initializing XrlScan:\r\n{0}", e);
                throw;
            }
        }

        #region XomControl callbacks.
        /// <summary>
        /// Reloads XrlMappings from SQL
        /// </summary>
        /// <param name="sender">The originator of the callback.</param>
        /// <param name="args">The details of the command.</param>
        private static void OnReloadMappings(object sender, ControlRequestEventArgs args)
        {
            string result = "Mappings reloaded successfully";
            try
            {
                XrlMappings.Reload();
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_INFO, result);
            }
            catch (Exception e)
            {
                result = string.Format("Exception reloading mappings:\r\n{0}", e);
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_ERROR, result);
            }

            XomControlConnection.SendMessage(result, args.RequestId);
            args.Handled = true;
        }

        /// <summary>
        /// Lists the current XRL Mappings
        /// </summary>
        /// <param name="sender">The originator of the callback.</param>
        /// <param name="args">The details of the command.</param>
        private static void OnListMappings(object sender, ControlRequestEventArgs args)
        {
            XrlMappings mappings = XrlMappings.Instance;
            XomControlConnection.SendMessage(
                string.Format(
                    "{0} mappings loaded for AppPool:{1} (HEAD requests allowed: {2})\r\n{3}",
                    mappings.Count,
                    XrlScan.appPool,
                    mappings.AllowHead,
                    mappings.ListMappings()),
                args.RequestId);

            args.Handled = true;
        }

        /// <summary>
        /// Outputs help on management commands serviced by the modulke.
        /// </summary>
        /// <param name="sender">The originator of the callback.</param>
        /// <param name="args">The details of the command.</param>
        private static void OnHelp(object sender, ControlRequestEventArgs args)
        {
            XomControlConnection.SendMessage(XrlScan.HelpText, args.RequestId);
        }

        /// <summary>
        /// The main XomControl message callback.
        /// If we are interested in this command then it is dispatched to the appropriate handler.
        /// </summary>
        /// <param name="sender">The originator of the callback.</param>
        /// <param name="args">The details of the command.</param>
        private static void XomControl_ControlRequestEvent(object sender, ControlRequestEventArgs args)
        {
            XrlScan.dCommandHandler myCommandHandler = null;
            if (XrlScan.commandHandlers.TryGetValue(args.Command, out myCommandHandler))
            {
                myCommandHandler.Invoke(sender, args);
            }
        }
        #endregion

        #region IHttpModule Members
        /// <summary>
        /// Unregister evt handlers.
        /// </summary>
        public void Dispose()
        {
            if (this.HttpApplication != null)
            {
                this.HttpApplication.BeginRequest -= this.BeginRequestEventHandler;
                this.HttpApplication.EndRequest -= this.EndRequestEventHandler;
            }
        }

        /// <summary>
        /// Initializes the module
        /// </summary>
        /// <param name="context">The Application Context</param>
        public void Init(HttpApplication context)
        {
            if (context == null)
            {
                throw new ArgumentException("context may not be null", "context");
            }

            this.HttpApplication = context;

            if (!XrlMappings.Loaded)
            {
                lock (typeof(XrlMappings))
                {
                    if (!XrlMappings.Loaded)
                    {
                        XrlMappings.Reload();
                    }
                }
            }

            // Create Event handlers
            this.BeginRequestEventHandler = new EventHandler(this.OnBeginRequest);
            this.EndRequestEventHandler = new EventHandler(this.OnEndRequest);

            // Register our event handler with Application object.
            this.HttpApplication.BeginRequest += this.BeginRequestEventHandler;
            this.HttpApplication.EndRequest += this.EndRequestEventHandler;
        }
        #endregion

        #region HttpModule Event Handlers
        /// <summary>
        /// Raised when ASP.NET runtime receives a new HTTP request
        /// </summary>
        /// <param name="sender">Origin of the request.</param>
        /// <param name="args">Event arguements.</param>
        private void OnBeginRequest(object sender, EventArgs args)
        {
            HttpApplication httpApplication = null;
            HttpContext httpContext = null;

            XrlScan.ValidateIHttpModuleEventArgs(
                sender,
                args,
                out httpApplication,
                out httpContext);

            if (!XrlScan.IsValidXrl(httpContext))
            {
                this.isValidXrl = false;
                XrlScan.LogClientInfo(httpContext, "Xrl is not valid");
                httpApplication.CompleteRequest();
            }
        }

        /// <summary>
        /// Raised just before sending the response content to the client.
        /// </summary>
        /// <param name="sender">Origin of the request.</param>
        /// <param name="args">Event arguements.</param>
        private void OnEndRequest(object sender, EventArgs args)
        {
            if (this.isValidXrl)
            {
                HttpApplication httpApplication = null;
                HttpContext httpContext = null;

                try
                {
                    if (!XrlScan.requiresResponseProcessing)
                    {
                        XrlScan.ValidateIHttpModuleEventArgs(
                            sender,
                            args,
                            out httpApplication,
                            out httpContext);


                        string xrlCacheControlHeader = httpContext.Response.Headers.Get("X-Cache-Control");

                        if (xrlCacheControlHeader != null)
                        {
                            httpContext.Response.Headers.Remove("X-Cache-Control");

                            if (httpContext.Response.Headers.Get("Cache-Control") != null)
                            {
                                httpContext.Response.Headers["Cache-Control"] = xrlCacheControlHeader;
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    LogClientInfo(httpContext, string.Format("Error replacing cache-control headers:\r\n{0}", e));
                }
            }
        }

        #endregion

        private static bool IsValidXrl(HttpContext httpContext)
        {
            XrlMappings localMappingsInstance = XrlMappings.Instance;

            bool isValid = true;

            string path = httpContext.Request.Path;
            string query = httpContext.Request.Url.Query;
            string method = httpContext.Request.RequestType;
            int port = httpContext.Request.Url.Port;
            XrlInfo matchedXrl = null;
            string errorMessage;
            bool isPost = false;
            bool isHead = false;
            bool isGet = false;

            if (!(isPost = method.Equals("POST", StringComparison.InvariantCulture)))
            {
                if (!(isGet = method.Equals("GET", StringComparison.InvariantCulture)))
                {
                    if (!(isHead = method.Equals("HEAD", StringComparison.InvariantCulture)))
                    {
                        isValid = false;
                        errorMessage = string.Format("{0} method is unsupported.  Only GET/POST/HEAD are allowed");
                    }
                    else if (!localMappingsInstance.AllowHead)
                    {
                        isValid = false;
                        errorMessage = "Support for the HEAD method is turned off in config.";
                    }
                }
            }
            else if (!string.IsNullOrEmpty(query))
            {
                isValid = false;
                errorMessage = "Query strings are not allowed on POSTs";
            }


            if (isValid)
            {
                foreach (XrlInfo xrlInfo in localMappingsInstance)
                {
                    int compareLen = xrlInfo.Xrl.Length;
                    if (!xrlInfo.AllowNoExactMatch)
                    {
                        compareLen = (path.Length < xrlInfo.Xrl.Length) ? xrlInfo.Xrl.Length : path.Length;
                    }

                    if (XrlScan.IsMatchingPort(port, xrlInfo.Port) &&
                        (string.Compare(path, 0, xrlInfo.Xrl, 0, compareLen, StringComparison.InvariantCultureIgnoreCase) == 0))
                    {
                        matchedXrl = xrlInfo;
                        break;
                    }
                }



                if (matchedXrl == null)
                {
                    isValid = false;
                    errorMessage = "No matching xrl found";
                }
                else if (query.Length > matchedXrl.MaxQueryStringLen)
                {
                    isValid = false;
                    errorMessage = "Query string is too long";
                }
                else if (path.Length > matchedXrl.MaxUrlLen)
                {
                    isValid = false;
                    errorMessage = "Url length is too long";
                }
                else if (isPost &&
                        (matchedXrl.MaxContentLen != -1) &&
                        (httpContext.Request.ContentLength > matchedXrl.MaxContentLen))
                {
                    isValid = false;
                    errorMessage = "Content-length is too big";
                }
            }

            if (isValid && isPost)
            {
                if (!httpContext.Request.ContentType.StartsWith("xon/"))
                {
                    if (!matchedXrl.AllowTextXmlType ||
                        (!httpContext.Request.ContentType.Equals("text/xml", StringComparison.InvariantCulture) &&
                         !httpContext.Request.ContentType.Equals("application/x-www-form-urlencoded", StringComparison.InvariantCulture) &&
                         !httpContext.Request.ContentType.Equals("application/soap+xml", StringComparison.InvariantCulture)))
                    {
                        isValid = false;
                        errorMessage = string.Format("{Content-Type {0} is not allowed", httpContext.Request.ContentType);
                    }
                }
            }




            return isValid;
        }

        private static bool IsMatchingPort(int reqPort, int aclPort)
        {
            if ((reqPort == aclPort) ||
                (reqPort >= 11000 && reqPort < 12000 && (reqPort == aclPort + 1000)))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Logs info about the client when something bad happens.
        /// </summary>
        /// <param name="context">The http context of the request.</param>
        /// <param name="message">The message as to what went wrong.</param>
        private static void LogClientInfo(HttpContext context, string message)
        {
            XrlScan.LogClientInfo(context, message, null);
        }

        /// <summary>
        /// Logs info about the client when something bad happens.
        /// </summary>
        /// <param name="context">The http context of the request.</param>
        /// <param name="message">The message as to what went wrong.</param>
        /// <param name="xrlInfo">Set if what is being logged pertains to a specific XrlMapping</param>
        private static void LogClientInfo(HttpContext context, string message, XrlInfo xrlInfo)
        {


        }

        /// <summary>
        /// Validates the arguements passed to the IHttpModule event callbacks.
        /// </summary>
        /// <param name="sender">Origin of the request.</param>
        /// <param name="args">Event arguements.</param>
        /// <param name="httpApplication">out: the sender as an instance of HttpApplication.</param>
        /// <param name="httpContext">out: the HttpContext of the call.</param>
        private static void ValidateIHttpModuleEventArgs(
            object sender,
            EventArgs args,
            out HttpApplication httpApplication,
            out HttpContext httpContext)
        {
            httpApplication = sender as HttpApplication;
            if (httpApplication == null)
            {
                throw new ArgumentException("Sender is not an instance of HttpApplication", "sender");
            }

            httpContext = httpApplication.Context;
            if (httpContext == null)
            {
                throw new ArgumentException("No HttpContext in HttpApplication", "(sender as HttpApplication).Context");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\errorhandler.cs ===
using System;
using System.Collections.ObjectModel;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;

using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.xsecsup.service
{
    public class ErrorHandler : IServiceBehavior, IErrorHandler
    {
        public ErrorHandler()
        {
        }

        public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            IErrorHandler errorHandler = new ErrorHandler();

            foreach (ChannelDispatcherBase channelDispatcherBase in serviceHostBase.ChannelDispatchers)
            {
                ChannelDispatcher channelDispatcher = channelDispatcherBase as ChannelDispatcher;
                channelDispatcher.ErrorHandlers.Add(errorHandler);
            }
        }

        public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
        }

        public bool HandleError(Exception e)
        {
            return true;
        }

        public void ProvideFault(Exception e, MessageVersion version, ref Message fault)
        {
            WebOperationContext webOperationContext = WebOperationContext.Current;

            if (webOperationContext != null)
            {
                HResult hr = XblException.GetHResult(e);
                webOperationContext.OutgoingResponse.Headers.Add("X-Err", hr.ToString());
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\counters.cs ===
using System;
using System.Diagnostics;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;

using xonline.common.mgmt;
using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.xsecsup.service
{
    public class CounterInvoker : IOperationInvoker
    {
        private IOperationInvoker _innerInvoker;
        private Counter _counter;

        public CounterInvoker(IOperationInvoker innerInvoker, Counter counter)
        {
            _innerInvoker = innerInvoker;
            _counter      = counter;
        }

        public object[] AllocateInputs() {
            return _innerInvoker.AllocateInputs();
        }

        public object Invoke(object instance, object[] inputs, out object[] outputs)
        {
            HResult hr = HResult.S_OK;
            XomRequestTimeElapsed elapsedTime = _counter.Start();
  
            try {
                return _innerInvoker.Invoke(instance, inputs, out outputs);
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally {
                _counter.End(elapsedTime.TimeElapsed * 1000, hr);
            }
        }

        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state) {
            return _innerInvoker.InvokeBegin(instance, inputs, callback, state);
        }


        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result) {
            return _innerInvoker.InvokeEnd(instance, out outputs, result);
        }

        public bool IsSynchronous {
            get { return _innerInvoker.IsSynchronous; }
        }
    }

    public class CounterOperationBehavior : IOperationBehavior
    {
        private string _counterName;

        public CounterOperationBehavior(string counterName) {
            _counterName = counterName;
        }

        public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters) {
            return;
        }

        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation) {
            throw new NotImplementedException();
        }

        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
            dispatchOperation.Invoker = new CounterInvoker(
                dispatchOperation.Invoker, Counter.Counters[_counterName]
            );
        }

        public void Validate(OperationDescription operationDescription) {
            return;
        }
    }
    
    public class CounterServiceBehavior : IServiceBehavior
    {
        public void  AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) {
            return;
        }

        public void  ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            XomPerformanceCounterCategory.InitPerfCtrs();

            foreach (ServiceEndpoint endpoint in serviceDescription.Endpoints)
            {
                foreach (OperationDescription operation in endpoint.Contract.Operations) {
                    if (! operation.Behaviors.Contains(typeof(CounterOperationBehavior))) {
                        string counterName = endpoint.Address.Uri.AbsolutePath + "/" + operation.SyncMethod.Name;
                        operation.Behaviors.Add(new CounterOperationBehavior(Counter.GetInstanceName(counterName)));
                    }
                }
            }
        }

        public void  Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) {
            return;
        }
    }
    

    [XomComponentPerformanceCounterCategoryAttr( "XRL" , "Xbox Live Common Per-XRL Counters" )]
    public class Counter : XomPerformanceCounterCategory
    {
        // Publicly visible static instance
        static public Counter Counters = new Counter();

        // Public visible getter
        public Counter this[string instance] {
            get {
                return (Counter) GetInstance(instance);
            }
        }

        public XomRequestTimeElapsed Start()
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            RequestsInProgress.Increment();
            Counters.RequestsInProgress.Increment();

            return timeElapsed;
        }

        public void End(long timeElapsed, HResult hr) 
        {
            RequestsInProgress.Decrement();
            TotalRequests.Increment();
            RequestsPerSec.Increment();
            FailuresPercentageBase.Increment();
            AverageExecutionTime.IncrementBy(timeElapsed);
            AverageExecutionTimeBase.Increment();

            // if there was a failure then  count  that

            if (hr.IsFailure()) {
                FailuresPerSecond.Increment();
                FailuresTotal.Increment();
                FailuresPercentage.Increment();
            }

            // if we are not counting the _total counter
            // then recurse (sort of) and count that too

            if (Counters != this) Counters.End(timeElapsed, hr);
        }


        public static string GetInstanceName(string s)
        {
            // 1. "/" are bad in instance names
            // 2. instance must be <= 127 chars
            // 3. query strings are bad in instance names
            string instanceName = s.Replace('/', '\\');

            if (instanceName.Length > 127) {
                instanceName = instanceName.Substring(0, 127);
            }

            return instanceName;
        }


        [XomPerformanceCounterAttr("Requests, Total", "Total number of requests", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr("Requests, In Progress", "Number of requests in progress", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgress;
        
        [XomPerformanceCounterAttr("Requests, Per Sec", "Number of requests completed per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSec;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time (in ms)", "Average request execution time in the current AppDomain (in ms)", PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time Base", "Base for the average request execution time in the current AppDomain", PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        [XomPerformanceCounterAttr("Failures, Per Sec", "Number of failures per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr("Failures, Total", "Total number of failures", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr("Failures, Percentage", "Request failure percentage", PerformanceCounterType.SampleFraction)]
        public PerformanceCounter FailuresPercentage;

        [XomPerformanceCounterAttr("Failures, Percentage Base", "Base for the request failure percentage", PerformanceCounterType.SampleBase)]
        public PerformanceCounter FailuresPercentageBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\testconnection.cs ===
using System;

using xonline.common.service;
using xonline.xsecsup.contract;

using Microsoft.IdentityModel;
using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xsecsup.service
{
    public partial class XSecSup : IXSecSup
    {
        /// <summary>
        /// TestConnection - and echo test method
        /// </summary>
        /// <param name="testData">test data to echo back</param>
        public string TestConnection(
            string testData
        )
        {
            if (String.IsNullOrEmpty(testData))
            {
                return "Test Data Not Defined";
            }
            else
            {
                return testData;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\stf\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\service\xsecsup.cs ===
using xonline.xsecsup.contract;
using xonline.common.service;

namespace xonline.xsecsup.service {
    public partial class XSecSup : FrontEndApp, IXSecSup {
        // all the XSecsup methods are in separate files
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\stf\stress.cs ===
using System;
using System.Collections.Generic;
using XUserTests;
using xonline.common.service;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using xonline.xsecsup.soap;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class Stress : TestNode
    {
        public static Random _ran = new Random();  

        public override void PreRun()
        {
        }


        [StressTest, Description("Spits out the status of the cache.")]
        public void PrintStatus()
        {

        }

    }; //class Stress
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\stf\xsecsuptestsutils.cs ===
using System;
using System.Text;
using System.ServiceModel;
using System.Net;
using System.Collections;
using System.Web;
using System.IO;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.xsecsup.soap;

namespace XSecsupTests
{
    public class XSecsupTestGroup : TestNode
    {
        public static bool checkedMaster = false;
        public override void PreRun()
        {
            if (checkedMaster == false)
            {
                if (!ServerTestFramework.LiveService.XSTS.XstsUtil.IsMasterKeyInstalled())
                {
                    ServerTestFramework.LiveService.XSTS.XstsUtil.InstallMasterKey();
                }
                checkedMaster = true;
            }
            base.PreRun();
        }
    }

    public class XSecsupTestUtil
    {
        public static BasicHttpBinding DefaultBasicHttpBinding(string wsbName)
        {
            BasicHttpBinding wsb = new BasicHttpBinding();
            wsb.Name = wsbName;
            wsb.CloseTimeout = TimeSpan.Parse("00:01:00");
            wsb.OpenTimeout = TimeSpan.Parse("00:01:00");
            wsb.ReceiveTimeout = TimeSpan.Parse("00:10:00");
            wsb.SendTimeout = TimeSpan.Parse("00:01:00");

            wsb.BypassProxyOnLocal = false;
            wsb.HostNameComparisonMode =
                System.ServiceModel.HostNameComparisonMode.StrongWildcard;
            wsb.MaxBufferPoolSize = 524288;
            wsb.MaxReceivedMessageSize = 6553600;
            wsb.MessageEncoding =
                System.ServiceModel.WSMessageEncoding.Text;
            wsb.TextEncoding = System.Text.Encoding.UTF8;
            wsb.UseDefaultWebProxy = true;
            wsb.AllowCookies = false;

            wsb.Security.Transport.ProxyCredentialType = HttpProxyCredentialType.None;
            wsb.Security.Mode = BasicHttpSecurityMode.None;

            return wsb;
        }

        public static XSecsupSoapClient GetUserClient()
        {
            return new XSecsupSoapClient(); 
        }

        public static string ByteToString(byte[] arrayValue)
        {
            // BitConverted adds '-' which I don't want for these
            StringBuilder sb = new StringBuilder("0x");
            foreach (byte bt in arrayValue)
            {
                sb = sb.Append(Convert.ToString(bt, 16).ToUpper());
            }

            return sb.ToString();
        }

        public static bool ByteArraysEqual(byte[] b1, byte[] b2)
        {
            if (b1 == b2)
                return true;
            if (b1 == null || b2 == null)
                return false;
            if (b1.Length != b2.Length)
                return false;

            for (int i = 0; i < b1.Length; i++)
            {
                if (b1[i] != b2[i])
                    return false;
            }
            return true; 
        }

       
    } //class XUserUtil

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\xsecsupproxy\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("XONLINE")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\xsecsupproxy\xsecsupsoap.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4963
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.xsecsup.soap {
  using System;
  using System.ComponentModel;
  using System.Diagnostics;
  using System.Web.Services;
  using System.Web.Services.Protocols;
  using System.Xml.Serialization;

  // 
  // Assembly WebServiceStudio Version = 2.0.50727.4963
  // 


  /// <remarks/>
  [System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
  [System.Diagnostics.DebuggerStepThroughAttribute()]
  [System.ComponentModel.DesignerCategoryAttribute("code")]
  [System.Web.Services.WebServiceBindingAttribute(Name="BasicHttpBinding_IXSecsup", Namespace="http://tempuri.org/")]
  public partial class XSecsup : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public XSecsup() {
        this.Url = "http://127.0.0.1:13400/xsecsup/xsecsup.svc";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xsecsup.V1/IXSecsup/TestConnection", RequestNamespace="http://xonline.xsecsup.V1", ResponseNamespace="http://xonline.xsecsup.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string TestConnection([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string testData) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    testData});
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string testData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    testData}, callback, asyncState);
    }
    
    /// <remarks/>
    public string EndTestConnection(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\stf\authtesthelper.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AuthTestHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections.ObjectModel;
using System.Security.Principal;
using System.Threading;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XSTS;

namespace Microsoft.Xbox.Devices.Test.Integration.Common
{
    public static class AuthTestHelper
    {
        // All values borrowed from Platform.MvcSample
        private const string Issuer = "xsts.xboxlive.com";

        public static ClaimsPrincipal GetClaimsPrincipal(ulong xuid)
        {
            return GetClaimsPrincipal(xuid, Convert.ToUInt32("FFFE0000", 16), "1", Convert.ToUInt64("FA00FFFFFFFFFFFF", 16));
        }

        public static ClaimsPrincipal GetClaimsPrincipal(ulong xuid, ulong deviceId)
        {
            return GetClaimsPrincipal(xuid, Convert.ToUInt32("FFFE0000", 16), "1", deviceId);
        }

        public static ClaimsPrincipal GetClaimsPrincipal(ulong? xuid, uint? titleId, string platformType, ulong? deviceId)
        {
            Collection<Claim> claims = new Collection<Claim>()
            {
                new Claim(AuthClaimTypes.AgeGroup, "Adult", AuthClaimTypes.ValueTypes[AuthClaimTypes.AgeGroup], Issuer),
                new Claim(AuthClaimTypes.ClientIpPort, "10.124.212.84:65535", AuthClaimTypes.ValueTypes[AuthClaimTypes.ClientIpPort], Issuer),
                new Claim(AuthClaimTypes.Country, "103", AuthClaimTypes.ValueTypes[AuthClaimTypes.Country], Issuer),
                new Claim(AuthClaimTypes.FlowToken, "EF594473B7D97D8D", AuthClaimTypes.ValueTypes[AuthClaimTypes.FlowToken], Issuer),
                new Claim(AuthClaimTypes.Gamertag, "STFUWIB98GSPDRE", AuthClaimTypes.ValueTypes[AuthClaimTypes.Gamertag], Issuer),
                new Claim(AuthClaimTypes.Language, "1", AuthClaimTypes.ValueTypes[AuthClaimTypes.Language], Issuer),
                new Claim(AuthClaimTypes.Privileges, "255", AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges], Issuer),
                new Claim(AuthClaimTypes.Puid, "37FFF893377D2", AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid], Issuer),
                new Claim(AuthClaimTypes.Tier, "Gold", AuthClaimTypes.ValueTypes[AuthClaimTypes.Tier], Issuer),
                new Claim(AuthClaimTypes.TitleVersion, "1", AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleVersion], Issuer),
            };

            if (deviceId.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.DeviceId, deviceId.Value.ToString("X"), AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId], Issuer));
            }

            if (!String.IsNullOrEmpty(platformType))
            {
                claims.Add(new Claim(AuthClaimTypes.DeviceType, platformType, AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceType], Issuer));
            }

            if (titleId.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.TitleId, titleId.Value.ToString("D"), AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId], Issuer));
            }

            if (xuid.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.Xuid, xuid.Value.ToString("D"), AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid], Issuer));
            }

            Collection<IClaimsIdentity> identities = new Collection<IClaimsIdentity>()
            {
                new ClaimsIdentity(claims, AuthenticationTypes.Federation)
            };

            return new ClaimsPrincipal(identities);
        }

        public static void SetClaimsOnThread(ulong callerXuid)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid);
        }

        public static void SetClaimsOnThread(ulong callerXuid, ulong deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, deviceId);
        }

        public static void SetClaimsOnThread(ulong? callerXuid, uint? titleId, uint? platformType, ulong? deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, titleId, platformType.ToString(), deviceId);
        }

        public static void SetClaimsOnThread(ulong? callerXuid, uint? titleId, string platformType, ulong? deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, titleId, platformType, deviceId);
        }

        public static void SetClaimsOnThread(IPrincipal principal)
        {
            Thread.CurrentPrincipal = principal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\test\stf\testconnection.cs ===
﻿using System;
using XSecsupTests;
using xonline.common.service;
using xonline.xsecsup.soap;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using System.ServiceModel;

namespace XSecsupTests
{
    [TestGroup, Owner("chlange"), TestCasePriority(1)]
    class TestXSecsup : XSecsupTestGroup
    {

        [TestCase, Description("Verifies test connection functionality")]
        public void TestConnectionResponse()
        {

            XSecsupSoapClient client = XSecsupTestUtil.GetUserClient();

            string testVerifyString = "VerifyTestString";

            string testResponse = client.TestConnection(testVerifyString);

            if (String.IsNullOrEmpty(testResponse) || testResponse != testVerifyString)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected the string result {0} but received: {1}", testVerifyString, testResponse));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\xsecsupproxy\properties\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XSecsupProxy")]
[assembly: AssemblyDescription("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4ad7d05d-fe9a-413c-a193-b755369df994")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xsecsup\xsecsupproxy\xsecsupsoapclient.cs ===
// -------------------------------------------------------------------------------
// class XSecsupSoapXBL
//
// The wsdl generated class XSecsup (XSecsupSoap.cs) can't be used as is
// because it is hard-coded to a specific machine.
// 
// This class provides an implementation that derives from XSecsup but uses 
// configuration information to send the request to the real XSecsup servers
//
// -------------------------------------------------------------------------------

using System;
using System.Net;
using System.Web;
using System.Threading;

using xonline.common.service;
using xonline.common.config;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using Microsoft.XboxLive.Auth.Tokens;

namespace xonline.xsecsup.soap 
{
    public class XSecsupSoapClient : XSecsup
    {
        private string _urlPrefix = null;
        private IClaimsPrincipal _claimsPrincipal;

        public XSecsupSoapClient()
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xsecsup_int, Config.SiteId);
            _urlPrefix = viInfo.Protocol + "://" + viInfo.IPAddressString + ":" + viInfo.Port;

            Uri uri = new Uri(this.Url);
            this.Url = _urlPrefix + uri.LocalPath;

            _claimsPrincipal = new ClaimsPrincipal();
            IClaimsIdentity identity = new ClaimsIdentity();


            identity.Claims.Add(new Claim("http://schemas.microsoft.com/xbox/2011/07/claims/internal", Config.ComponentName, ClaimValueTypes.String, "System"));
            _claimsPrincipal.Identities.Add(identity);
        }

        public XSecsupSoapClient(string subUrl)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xsecsup_int, Config.SiteId);
            string url = string.Format("{0}://{1}:{2}/{3}", "http", viInfo.IPAddressString, viInfo.Port, subUrl);

            this.Url = url;
        }

        protected override WebRequest GetWebRequest(Uri url)
        {
            WebRequest req = base.GetWebRequest(url);
            HttpWebRequest httpWebRequest = req as HttpWebRequest;

            if (req is HttpWebRequest)
            {
                // This code exists in order to load balance the connection to the
                // various XSecsup boxes that sit behind a VIP
                //  
                // See http://support.microsoft.com/kb/2551125 as to why it was done
                // this way instead of using ConnectionGroupName
                
                ((HttpWebRequest) req).KeepAlive = false;

                if (_claimsPrincipal != null)
                {
                    httpWebRequest.SetXAuthdata(_claimsPrincipal);
                }
            }
            if (Thread.CurrentPrincipal.Identity.AuthenticationType.Length > 0)
            {
                XAuthdataToken t = new XAuthdataToken((Thread.CurrentPrincipal as ClaimsPrincipal).Identities);
                req.Headers.Add("Authorization", t.ToString());
            }

            return req;
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ClaimProvider.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.utilities2;
using xonline.server.xsts.provider;

using xonline.config.sts.interfaces;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

namespace xonline.server.xsts.fd
{
    internal class ClaimProvider : IClaimProvider, IDelegationHandler
    {
        private AppDomain      _appDomain;
        private IClaimProvider _claimProvider;
        private IClaimTypeProvider _claimTypeProvider;
        private IDelegationHandler _delegationHandler;
        private byte[] _symmetricKey = null;
        private byte[] _symmetricIV = null;

        internal ClaimProvider(IClaimTypeProvider config)
        {
            _claimTypeProvider = config;

            // the claim provider string should look something like
            // a module definition we  see  in  a  web.config  file

            // "mynamespace.myclaimprovider, myclaimprovider.dll, Culture=neutral PublicKey=null"

            if (string.IsNullOrEmpty(config.Type)) {
                throw new XblException(
                    HResult.XONLINE_E_XSTS_CONFIG_CP_INVALID, "Empty claim provider descriptor"
                );
            }

            // split at first comma. everything before is the claim
            // provider type, everything after is the assembly name

            int index = config.Type.IndexOf(',');

            if (index == -1) {
                throw new XblException(
                    HResult.XONLINE_E_XSTS_CONFIG_CP_INVALID, "Invalid claim provider descriptor"
                );
            }

            string providerType = config.Type.Substring(0, index).Trim();
            string providerAssembly = config.Type.Substring(index + 1).Trim();

            if (string.IsNullOrEmpty(providerType))
                throw new XblException(
                    HResult.XONLINE_E_XSTS_CONFIG_CP_TYPE_INVALID, "Empty claim provider type"
                );
            else if (string.IsNullOrEmpty(providerAssembly)) {
                throw new XblException(
                    HResult.XONLINE_E_XSTS_CONFIG_CP_ASSEMBLY_INVALID, "Empty claim provider assembly"
                );
            }

            // insulate ourselves from third party code  by running
            // all claim providers in their own application  domain

            try {
                // _appDomain = AppDomain.CreateDomain(providerType);
                _claimProvider = (IClaimProvider) AppDomain.CurrentDomain.CreateInstanceAndUnwrap(providerAssembly, providerType);
            }

            catch (Exception e) {
                throw new XblException(
                    HResult.XONLINE_E_XSTS_CONFIG_CP_LOAD_ERROR,
                    e, "Error loading claim provider '{0}'", config.Type
                );
            }

            // make sure all the claims configured for  this  claim
            // provider are indeed supported by this claim provider

            foreach (KeyValuePair<Uri, IClaimType> claimTypeKeyValue in config.ClaimTypes) {
                if (! _claimProvider.ClaimTypes.Contains(claimTypeKeyValue.Key.ToString())) {
                    throw new XblException(
                        HResult.XONLINE_E_XSTS_CONFIG_CP_CLAIM_TYPE_NOT_SUPPORTED,
                        "Claim provider does not support claim type '{0}'", claimTypeKeyValue.Key.ToString()
                    );
                }
            }
        }

        public string Name
        {
            get { return _claimProvider.ToString(); }
        }

        public IClaimTypeProvider ClaimTypeProvider
        {
            get { return _claimTypeProvider; }
        }
    
        public void Open()
        {
            _claimProvider.Open();
        }

        public void Close()
        {
            IClaimProvider claimProvider = _claimProvider;
            _claimProvider = null;

            AppDomain appDomain = _appDomain;
            _appDomain = null;

            try {
                if (claimProvider != null) {
                    claimProvider.Close();
                }
            }

            // always try to unload the application domain  (so  we
            // do not start accumulating and then run out of memory

            finally {
                if (appDomain != null) {
                    AppDomain.Unload(appDomain);
                }
            }
        }

        public HashSet<string>  ClaimTypes
        {
	        get { return _claimProvider.ClaimTypes; }
        }

        public string DecryptAndDeanonymize(string s, out string salt)
        {
            if (null != _symmetricKey)
            {
                string symmetricKeyVersion = s.Substring(0, 1);
                // Todo: Verify symmetricKeyVersion

                Blob encrypted = Blob.Parse(s.Substring(1));

                // Todo: need to get the right symmetric key
                SymmetricKey decryptor = new SymmetricKey(_symmetricKey, _symmetricIV);

                string decrypted = ASCIIEncoding.ASCII.GetString(decryptor.Decrypt(encrypted));
                int index = decrypted.IndexOf(":");
                int saltLength = int.Parse(decrypted.Substring(0, index));
                salt = decrypted.Substring(index + 1, saltLength);

                return decrypted.Substring(index + saltLength + 1);
            }
            else
            {
                salt = string.Empty;
            }

            // If no key then we don't encrypt
            return s;
        }

        public IDelegationHandler GetDelegationTokenHandler(string claimType)
        {
            _delegationHandler = _claimProvider.GetDelegationTokenHandler(claimType);

            if (null != _delegationHandler)
            {
                return this;
            }

            return null;
        }

        public IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            IClaimsIdentity claimsIdentity = _claimProvider.GetOutputClaimsIdentity(claimTypes, principal, request, scope);

            // do any XSTS specific post processing of claims here

            return claimsIdentity;
        }

        public IClaimsIdentity PostGetOutputClaimsIdentity(IAppliesTo _appliesTo, IClaimsIdentity claimsIdentity )
        {
            for (int i = 0; i < claimsIdentity.Claims.Count; i++)
            {
                Claim claim = claimsIdentity.Claims[i];
                IClaimType claimType = _claimTypeProvider.ClaimTypes[new Uri(claim.ClaimType)];

                if (claimType.Anonymized)
                {
                    claimsIdentity.Claims[i] = new Claim(claim.ClaimType
                        , AnonymizeAndHash(_appliesTo, claim.Value)
                        , ClaimValueTypes.HexBinary, claim.Issuer);
                }
                else if (claimType.Encrypted)
                {
                    claimsIdentity.Claims[i] = new Claim(claim.ClaimType
                        , AnonymizeAndEncrypt(_appliesTo, claim.Value)
                        , ClaimValueTypes.HexBinary, claim.Issuer);
                }
            }

            return claimsIdentity;
        }

        //////////////////////////////////////
        // Only call this through the IDelegationHandler interface retrieved using GetDelegationTokenHandler
        //////////////////////////////////////

        public bool GetTokenProperties(string encryptedDToken, out Dictionary<string, object> properties)
        {
            bool isSuccess;
            string salt;

            string dtoken = DecryptAndDeanonymize(encryptedDToken, out salt);

            isSuccess = this._delegationHandler.GetTokenProperties(dtoken, out properties);

            if ( isSuccess )
            {
                properties.Add("appliestoSalt", salt);
            }

            return isSuccess;
        }

        public void SetEncryptionKey(byte[] symmetricKey, byte[] symmetricIV)
        {
            _symmetricKey = symmetricKey;
            _symmetricIV = symmetricIV;
        }

        public override string ToString() {
            return base.ToString();
        }

        private string AnonymizeAndHash(IAppliesTo appliesTo, string s)
        {
            Blob value = GetHashedBytes(Anonymize(appliesTo, s));

            return value.ToString();
        }

        private string AnonymizeAndEncrypt(IAppliesTo appliesTo, string s)
        {
            if (null != _symmetricKey)
            {
                SymmetricKey encryptor = new SymmetricKey(_symmetricKey, _symmetricIV);

                Blob encrypted = encryptor.Encrypt(Anonymize(appliesTo, s));

                // Todo: Need to put the real symmetric key version here
                return "1" + encrypted.ToString(); 
            }
            else
            {   // If no key then we don't encrypt
                return s;
            }
        }

        private byte[] Anonymize(IAppliesTo appliesTo, string s)
        {
            string anonymizedValue = string.Format("{0}:{1}{2}", appliesTo.BusinessPartner.AnonymizingSalt.Length, appliesTo.BusinessPartner.AnonymizingSalt, s);

            return ASCIIEncoding.ASCII.GetBytes(anonymizedValue);
        }

        private byte[] GetHashedBytes(byte[] buffer) 
        {
            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider()) {
                return sha1.ComputeHash(buffer);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\CertificateUtil.cs ===
//-----------------------------------------------------------------------------
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

using System;
using System.Security.Cryptography.X509Certificates;

/// <summary>
/// A utility class which helps to retrieve an x509 certificate
/// </summary>
public class CertificateUtil
{
    public static X509Certificate2 GetCertificate( StoreName name, StoreLocation location, string subjectName )
    {
        X509Store store = new X509Store( name, location );
        X509Certificate2Collection certificates = null;
        store.Open( OpenFlags.ReadOnly );

        try
        {
            X509Certificate2 result = null;

            //
            // Every time we call store.Certificates property, a new collection will be returned.
            //
            certificates = store.Certificates.Find(X509FindType.FindBySubjectName, subjectName, true);

            if ( 1 == certificates.Count )
            {
                result = new X509Certificate2( certificates[0] );
            }
            else if ( 1 < certificates.Count )
            {
                throw new ApplicationException( string.Format( "There are multiple certificate for subject Name {0}", subjectName ) );
            }
            else
            {
                throw new ApplicationException( string.Format( "No certificate was found for subject Name {0}", subjectName ) );
            }

            return result;
        }
        finally
        {
            if ( certificates != null )
            {
                for ( int i = 0; i < certificates.Count; i++ )
                {
                    X509Certificate2 cert = certificates[i];
                    cert.Reset();
                }
            }

            store.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ActiveClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.IdentityModel.Claims;

using xonline.server.xsts.provider;
using xonline.config.sts.interfaces;

namespace xonline.server.xsts.fd
{

    /// <summary>
    /// Summary description for Common
    /// </summary>
    internal class ActiveClaimProvider
    {
        // Attributes

        protected IClaimProvider _claimProvider;
        protected HashSet<string> _claimTypes = new HashSet<string>();

        // Constructor
        public ActiveClaimProvider(IClaimProvider claimProvider, string claimType)
        {
            _claimProvider = claimProvider;
            _claimTypes.Add(claimType);
        }

        private ActiveClaimProvider() {;}

        // Implementation

        public IClaimProvider ClaimProvider
        {
            get
            {
                return _claimProvider;
            }
        }

        public HashSet<string> ClaimTypes
        {
            get
            {
                return _claimTypes;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Delegate.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.service;

using xonline.server.xsts.provider;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// Verify that the caller can delegate and perform the delegation
        /// </summary>
        private bool ValidatePrincipalAndDelegate(IClaimsPrincipal principal, string delegationToken)
        {
            if (null == principal)
            {
                throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_NO_PRINCIPAL, "Delegation operation invalid. No principal.");
            }

            // Verify we have the cert claim
            IEnumerable<Claim> certClaims = principal.FindClaims(XStsClaimTypes.AACLAIM_CLIENTCERT_SUBJECTNAME);

            if (0 == certClaims.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_NO_CERTCLAIM, "Delegation operation invalid. No client cert claim.");
            }
            else if (1 < certClaims.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_MULTIPLE_CERTCLAIMS, "Delegation operation invalid. Multiple client cert claims.");
            }

            // If the principal already has a user identity we consider this invalid
            IEnumerable<Claim> claims = principal.FindClaims(AuthClaimTypes.Xuid);

            if (0 < claims.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_HASXUID, "Delegation operation invalid. Principal already has a xuid.");
            }

            claims = principal.FindClaims(AuthClaimTypes.Puid);
            if (0 < claims.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_HASPUID, "Delegation operation invalid. Principal already has a puid.");
            }

            // Done checking let's do the delegation work

            Dictionary<string, object> delegationProperties;

            IDelegationHandler dtokenHandler = _atctcpCurrent.ClaimTypeClaimProviders[AuthClaimTypes.DelegationToken].GetDelegationTokenHandler(AuthClaimTypes.DelegationToken);

            if (dtokenHandler.GetTokenProperties(delegationToken, out delegationProperties))
            {
                string salt;
                DateTime datetimeIssued;

                _xuid = (Puid)delegationProperties["xuid"];
                datetimeIssued = (DateTime) delegationProperties["dateIssued"];
                salt = (string) delegationProperties["appliestoSalt"];

                // Verify the salt matched the certificate
                if ((!_atctcpCurrent.ClientCertToBusinessPartnerSalt.ContainsKey(certClaims.ElementAt(0).Value))
                   || (!string.Equals(_atctcpCurrent.ClientCertToBusinessPartnerSalt[certClaims.ElementAt(0).Value], salt))
                   )
                {
                    throw new XblException(HResult.XONLINE_E_XSTS_DELEGATION_NOTAUTHORIZED_CLIENTCERT_SALT_MISMATCH, "Delegation operation invalid. Delegation token to client certificate mismatch.");
                }
            }

            if (0 != _xuid)
            {
                // Todo: Enforce delegation token expiry

                // Perform delegation by modify the ClaimsPrincipal to the delegated id
                // Delegated Xuid Claim
                Claim delegatedXuidClaim = new Claim(AuthClaimTypes.Xuid, ((ulong)_xuid).ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid], "DelegationToken");

                // Let's add the Xuid claim to the first principal
                principal.Identities[0].Claims.Add(delegatedXuidClaim);

                XClaimsPrincipal xcp = principal as XClaimsPrincipal;
                if (null != principal)
                {
                    xcp.CreateUserClaims();
                }
            }

            return (0 != _xuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Common.cs ===
﻿using System;

namespace xonline.server.xsts.fd
{

    /// <summary>
    /// Summary description for Common
    /// </summary>

    public static class XStsClaimTypes
    {
        /// <summary>the server's ip address and port</summary>
        public const string ServerIpPort = "http://XSts/2011/05/claims/ServerIpPort";
        // AA claims
        public const string AACLAIM_CLIENTCERT_SUBJECTNAME = "http://schemas.microsoft.com/xbox/2011/07/claims/partner/certsubject";

        public const string ADDITIONALCONTEXT_DEVICE_CLIENTVERSION = "http://schemas.microsoft.com/xbox/2011/07/claims/device/clientversion";
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ErrorHandler.cs ===
using System;
using System.Collections.ObjectModel;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;

using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.server.xsts.fd
{
    public class ErrorHandler : IServiceBehavior, IErrorHandler
    {
        public ErrorHandler()
        {
        }

        public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            IErrorHandler errorHandler = new ErrorHandler();

            foreach (ChannelDispatcherBase channelDispatcherBase in serviceHostBase.ChannelDispatchers)
            {
                ChannelDispatcher channelDispatcher = channelDispatcherBase as ChannelDispatcher;
                channelDispatcher.ErrorHandlers.Add(errorHandler);
            }
        }

        public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
        }

        public bool HandleError(Exception e)
        {
            return true;
        }

        public void ProvideFault(Exception e, MessageVersion version, ref Message fault)
        {
            WebOperationContext webOperationContext = WebOperationContext.Current;

            if (webOperationContext != null)
            {
                HResult hr = XblException.GetHResult(e);
                webOperationContext.OutgoingResponse.Headers.Add("X-Err", hr.ToString());
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\GetTokenLifeTime.cs ===
using System;

using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.IdentityModel.Tokens;

using xonline.common.exceptions;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {
        private static TimeSpan LifetimeStartSkew = new TimeSpan(0, 5, 0);

        /// <summary>
        /// Override the GetTokenLifetime method to specify the token lifetime
        /// </summary>
        /// <param name="request">The security token request.</param>
        protected override Lifetime GetTokenLifetime(Lifetime requestLifetime)
        {
            return new Lifetime(DateTime.UtcNow - LifetimeStartSkew, DateTime.UtcNow + _appliesTo.ValidityInterval);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Health.cs ===
using System.Web;
using System.Collections.Specialized;

using xonline.common.health;

namespace xonline.server.xsts.fd
{
    public class XStsHealthRequest : BaseHealthRequest
    {
       public override void ProcessRequest( HttpContext ctx )
       {
           XSts.Init();
           base.ProcessRequest(ctx);
       }
    }

    public class XStsHealthBlock : IHealthBlock
    {
        public XStsHealthBlock()
        {
            // leave this empty
        }

        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; } 
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            XSts.CheckHealth(report);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\GetResponse.cs ===
using System;

using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.IdentityModel.Tokens;

using xonline.common.exceptions;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// Override the GetRespone method for Logging
        /// </summary>
        /// <param name="request">The security token request.</param>
        protected override RequestSecurityTokenResponse GetResponse(RequestSecurityToken request, SecurityTokenDescriptor tokenDescriptor)
        {
            RequestSecurityTokenResponse rstr = base.GetResponse(request, tokenDescriptor);
            Logging.Log(request, tokenDescriptor, null);

            return rstr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\GetOutputClaimsIdentity.cs ===
using System;
using System.Collections.Generic;
using System.Threading;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.config.sts.interfaces;
using xonline.server.xsts.provider;

namespace xonline.server.xsts.fd
{
    /// <summary>
    /// A custom SecurityTokenService implementation.
    /// </summary>

    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// This method returns the claims to be issued in the token.
        /// </summary>
        /// <param name="principal">The caller's principal.</param>
        /// <param name="request">The incoming RST, can be used to obtain addtional information.</param>
        /// <param name="scope">The scope information corresponding to this request.</param>/// 
        /// <exception cref="ArgumentNullException">If 'principal' parameter is null.</exception>
        /// <returns>The outgoing claimsIdentity to be included in the issued token.</returns>
        protected override IClaimsIdentity GetOutputClaimsIdentity(IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            principal = (IClaimsPrincipal)HttpContextAdapter.Current.Items["Principal"];
            if (principal == null) throw new ArgumentNullException("principal");

            IClaimsIdentity outputClaimsIdentity = null;
            Dictionary<string, ActiveClaimProvider> activeClaimProviderDictionary = new Dictionary<string, ActiveClaimProvider>();

            // Build the Active Dictionary of Claim Providers that are needed
            // And the set of claims that each Provider will provide

            foreach (KeyValuePair<Uri, IAppliesToClaimType> claimTypeKV in _appliesTo.ClaimTypes)
            {
                IClaimProvider oIClaimProvider = null;

                try
                {
                    oIClaimProvider = _atctcpCurrent.ClaimTypeClaimProviders[claimTypeKV.Key.AbsoluteUri];  // Will throw KeyNotFound exception if there is no Provider configured for this claimType
                }
                catch
                {
                }
                if (null != oIClaimProvider)
                {
                    string claimProviderType = ((ClaimProvider)oIClaimProvider).Name;
                    if (activeClaimProviderDictionary.ContainsKey(claimProviderType))
                    {
                        activeClaimProviderDictionary[claimProviderType].ClaimTypes.Add(claimTypeKV.Key.AbsoluteUri);
                    }
                    else
                    {
                        activeClaimProviderDictionary.Add(claimProviderType, new ActiveClaimProvider(oIClaimProvider, claimTypeKV.Key.AbsoluteUri));
                    }
                }
            }

            foreach (KeyValuePair<string, ActiveClaimProvider> keyValueClaimProvider in activeClaimProviderDictionary)
            {
                IClaimsIdentity providerOutputClaimsIdentity = null;
                ActiveClaimProvider activeClaimProvider = keyValueClaimProvider.Value;

                try
                {
                    providerOutputClaimsIdentity = activeClaimProvider.ClaimProvider.GetOutputClaimsIdentity(activeClaimProvider.ClaimTypes, principal, request, scope);

                    // Post GetOutputClaimsIdentity processing
                    providerOutputClaimsIdentity = ((ClaimProvider)(activeClaimProvider.ClaimProvider)).PostGetOutputClaimsIdentity(_appliesTo, providerOutputClaimsIdentity);
                }
                catch (Exception e)
                {
                    if (HResult.Failed(XblException.GetHResult(e)))
                    {
                        throw;
                    }
                    else
                    {
                        throw new XblException(HResult.XONLINE_E_XSTS_PROVIDER_GETOUTPUTCLAIMSIDENTITY, e, "Error calling GetOutputClaimsIdentity for provider: {0}", activeClaimProvider.ClaimProvider.ToString());
                    }
                }
                if (null != providerOutputClaimsIdentity)
                {
                    if (null == outputClaimsIdentity)
                    {
                        outputClaimsIdentity = providerOutputClaimsIdentity;
                    }
                    else
                    {
                        outputClaimsIdentity.Claims.AddRange(providerOutputClaimsIdentity.Claims);

                        ClaimsIdentity defaultClaimsIdentity = new ClaimsIdentity();

                        if (defaultClaimsIdentity.Actor != providerOutputClaimsIdentity.Actor)
                            outputClaimsIdentity.Actor = providerOutputClaimsIdentity.Actor;
                        if (defaultClaimsIdentity.Label != providerOutputClaimsIdentity.Label)
                            outputClaimsIdentity.Label = providerOutputClaimsIdentity.Label;
                        if (defaultClaimsIdentity.NameClaimType != providerOutputClaimsIdentity.NameClaimType)
                            outputClaimsIdentity.NameClaimType = providerOutputClaimsIdentity.NameClaimType;
                        if (defaultClaimsIdentity.RoleClaimType != providerOutputClaimsIdentity.RoleClaimType)
                            outputClaimsIdentity.RoleClaimType = providerOutputClaimsIdentity.RoleClaimType;
                    }
                }
            }

            if (!_serviceInstanceProviderLifetime)
                ServiceHostClosed();

            return outputClaimsIdentity;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Issue.cs ===
using System;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.IdentityModel.Tokens;

using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// Override the Issue method to be able to reliably manage the AppliesTosClaimTypesClaimProviders
        /// </summary>
        /// <param name="request">The security token request.</param>
        public override RequestSecurityTokenResponse Issue(IClaimsPrincipal principal, RequestSecurityToken request)
        {
            try
            {
                _atctcpCurrent = XSts.TryAcquireATCTCP();
                if (null == _atctcpCurrent)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_XSTS_ATCTCP_ACQUIRE_FAILURE, "Failed to acquire valid ATCTCP configuration"); 
                }

                RequestSecurityTokenResponse rstr = base.Issue(principal, request);
                _appliesToPerfCounters.EndRequestIncrement();
                _totalPerfCounter.EndRequestIncrement();

                return rstr;
            }
            catch (Exception e)
            {
                Logging.Log(request, e);
                if (!(e is xonline.common.service.ExceptionWithHResult
                   || e is xonline.common.exceptions.ExceptionWithHResult
                   || e is InvalidRequestException
                   || e is UnsupportedTokenTypeBadRequestException
                   || e is XblException
                   ))
                {
                    Logging.NtEvent(XEvent.Id.XSTS_ISSUE_ERROR, e, "Issue error: {0}", e.Message);
                }
                _appliesToPerfCounters.EndRequestIncrementFailure();
                _totalPerfCounter.EndRequestIncrementFailure();
                throw;
            }
            finally
            {
                if (null != _atctcpCurrent)
                {
                    _atctcpCurrent.Release();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Installer.cs ===
﻿using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.server.xsts.fd
{
    [RunInstaller(true)]
    public class Installer : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class PerformanceCounterInstaller : XomPerformanceCounterInstall
    {
        public override bool IsInstallablePerformanceCounterCategory(Type t)
        {
            return
                t.IsSubclassOf(typeof(PerformanceCounterCategory)) &&
                t != typeof(PerformanceCounterCategory) &&
                Attribute.IsDefined(t, typeof(XomPerformanceCounterCategoryAttr));
        }

        // Uses .Net libraries to open up each counter in the category. Should ensure 
        // everything exists.

        protected override void VerifyCategory(Type categoryType)
        {
            if (!IsInstallablePerformanceCounterCategory(categoryType))
            {
                LogMessage("\t\tNot a valid PerformanceCounterCategory type: " + categoryType.ToString());
                throw new InvalidOperationException("Not a valid category type");
            }

            PerformanceCounterCategory o = (PerformanceCounterCategory)Activator.CreateInstance(categoryType);

            // The XomPerformanceCounterCategory constructor initializes perf 
            // counters, which reads a value for each one. No exceptions == good to go

        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\GetScope.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.Web.Configuration;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Configuration;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using xonline.common.exceptions;
using xonline.common.service;

using xonline.config.sts.interfaces;


namespace xonline.server.xsts.fd
{

    /// <summary>
    /// A custom SecurityTokenService implementation.
    /// </summary>
    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// This method returns the configuration for the token issuance request. The configuration
        /// is represented by the Scope class.
        /// </summary>
        /// <param name="principal">The caller's principal.</param>
        /// <param name="request">The incoming RST.</param>
        /// <returns>The scope information to be used for the token issuance.</returns>
        protected override Scope GetScope(IClaimsPrincipal principal, RequestSecurityToken request)
        {
            // this isn't used, but we don't want people to think the
            // one that is passed in is the one that they should  use

            principal = (IClaimsPrincipal) HttpContextAdapter.Current.Items["Principal"];

            ValidateAppliesTo(request.AppliesTo);

            if (!_serviceInstanceProviderLifetime)
                ServiceHostOpened();
            //
            // Note: The signing certificate used by default has a Distinguished name of "CN=STSTestCert",
            // and is located in the Personal certificate store of the Local Computer. Before going into production,
            // ensure that you change this certificate to a valid CA-issued certificate as appropriate.
            //
            Scope scope = new Scope(request.AppliesTo.Uri.OriginalString, SecurityTokenServiceConfiguration.SigningCredentials);

            // Get the AppliesTo certificate for encrypting the token
            X509Certificate2 encryptingCertificate = _appliesTo.AppliesToCertificate;

            if (null != encryptingCertificate)
            {
                scope.EncryptingCredentials = new X509EncryptingCredentials(encryptingCertificate);
            }
            else
            {
                // If there is no encryption certificate specified, the STS will not perform encryption.
                // This will succeed for tokens that are created without keys (BearerTokens) or asymmetric keys.  Symmetric keys are
                // required to be 'wrapped' and the STS will throw.
                scope.TokenEncryptionRequired = false;

                // Symmetric keys are required to be 'wrapped' or the STS will throw, uncomment the code below to turn off proof key encryption.
                // Turning off proof key encryption is not secure and should not be used in a deployment scenario.

                // scope.SymmetricKeyEncryptionRequired = false;
            }

            return scope;
        }

        /// <summary>
        /// Validates appliesTo and throws an exception if the appliesTo is null or contains an unexpected address.
        /// </summary>
        /// <param name="appliesTo">The AppliesTo value that came in the RST.</param>
        /// <exception cref="ArgumentNullException">If 'appliesTo' parameter is null.</exception>
        /// <exception cref="InvalidRequestException">If 'appliesTo' is not valid.</exception>
        protected void ValidateAppliesTo(EndpointAddress appliesTo)
        {
            try
            {
                _appliesTo = _atctcpCurrent.AppliesTos[appliesTo.Uri];

                _appliesToPerfCounters.BeginRequestIncrement(AppliesToCounterNamePrefix + _appliesTo.AppliesToUri.ToString());
            }
            catch (KeyNotFoundException)
            {
                throw new XblException(HResult.XONLINE_E_XSTS_APPLIESTO_NOTFOUND, "XSts is not configured for the requested 'appliesTo' address '{0}'.", appliesTo.Uri.AbsoluteUri);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Logging.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.Tokens;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.server.xsts.fd
{
    public class Logging
    {
        public static Dictionary<string, string> _logRelyingParties = new Dictionary<string, string>();

        public static void Init()
        {
            // TODO - load relying parties so we can emit friendly names
        }

        internal static void NtEvent(XEvent.Id eventId, Exception e, string format, params object[] args)
        {
            Xom.NtEvent(eventId, e, format, args);
        }

        internal static void NtEvent(XEvent.Id eventId, string format, params object[] args)
        {
            Xom.NtEvent(eventId, format, args);
        }

        internal static void Log(RequestSecurityToken request, Exception e)
        {
            Log(request, null, e);
        }

        internal static void Log(RequestSecurityToken request, SecurityTokenDescriptor tokenDescriptor, Exception e)
        {
            // Logging info should either come from our principal (created in ValidateRequest)
            IClaimsPrincipal principal = (IClaimsPrincipal) HttpContextAdapter.Current.Items["Principal"];

            // Or from the claims populated by claims providers
            IClaimsIdentity claimsIdentity = (null == tokenDescriptor) ? null : claimsIdentity = tokenDescriptor.Subject;

            HResult hr = e == null ? (HResult) HResult.S_OK : XblException.GetHResult(e);

            // for now the request type, some client information and just a
            // little of the request information. we may want  (much)  more

            Xom.Log(XomAreaName.log, "{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}|{9}|{10}|{11}|{12}|{13}|{14}|{15}|{16}|{17}|{18}|{19}"
                , GetRequestType(request)
                , hr
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Xuid)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Puid)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Gamertag)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.DeviceId)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.DeviceType)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.TitleId)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.TitleVersion)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Country)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Language)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Tier)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Status)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.ClientIpPort)
                , GetClaim(principal, claimsIdentity, XStsClaimTypes.ServerIpPort)
                , GetClaim(principal, claimsIdentity, AuthClaimTypes.Privileges)
                , (null == claimsIdentity) ? 0 : claimsIdentity.Claims.Count
                , GetAppliesTo(request)
                , GetTokenType(request)
                , GetAdditionalContext(request)
                , (null == e) ? string.Empty : e.Message
            );
        }

        internal static void Log(byte[] b1, byte[] b2)
        {
            StringBuilder sb1 = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();

            for (int i = 0; i < b1.Length; i++)
            {
                sb1.Append(b1[i].ToString("X2"));
            }
            for (int i = 0; i < b2.Length; i++)
            {
                sb2.Append(b2[i].ToString("X2"));
            }

            Xom.Log(XomAreaName.log, " {0} | {1}"
                , sb1.ToString()
                , sb2.ToString()
                );
        }

        private static string GetClaim(IClaimsPrincipal principal, IClaimsIdentity claimsIdentity, string claimType)
        {
            string claimValue = string.Empty;

            if (null != principal)
            {
                principal.TryGetClaimValue(claimType, out claimValue);
            }
            if (string.IsNullOrEmpty(claimValue) && null != claimsIdentity)
            {
                claimsIdentity.TryGetClaimValue(claimType, out claimValue);
            }
            return claimValue;
        }

        // find the URI fragment with the additional context for the
        // request. otherwise return an empty string

        private static string GetAdditionalContext(RequestSecurityToken request)
        {
            if ((null == request) || (null == request.AdditionalContext) || (0 == request.AdditionalContext.Items.Count)) 
                return string.Empty;

            StringBuilder context = new StringBuilder();
            int index = request.AdditionalContext.Items[0].Name.AbsolutePath.LastIndexOf('/');

            context.AppendFormat("{0}|{1}:{2}"
                , request.AdditionalContext.Items.Count
                , (-1 == index) ? request.AdditionalContext.Items[0].Name.AbsolutePath : request.AdditionalContext.Items[0].Name.AbsolutePath.Substring(index+1)
                , request.AdditionalContext.Items[0].Value
                );

            return context.ToString();
        }

        // find the URI fragment with the friendly name  for  the
        // request type. otherwise we just return the whole thing

        private static string GetRequestType(RequestSecurityToken request) 
        {
            if ((request == null) || string.IsNullOrEmpty(request.RequestType)) return string.Empty;
            int index = request.RequestType.LastIndexOf('/');

            if (index == -1) return request.RequestType;
            return request.RequestType.Substring(index + 1).ToUpper();
        }

        // find the URI fragment with the friendly name  for  the
        // token type. otherwise we simply return the whole thing

        private static string GetTokenType(RequestSecurityToken request)
        {
            if ((request == null) || string.IsNullOrEmpty(request.TokenType)) return string.Empty;
            int index = request.TokenType.LastIndexOf('#');

            if (index == -1) return request.TokenType;
            return request.TokenType.Substring(index + 1);
        }

        // get the applies to and convert to a more friendly name
        // using the configuration data for the  relying  parties

        private static string GetAppliesTo(RequestSecurityToken request)
        {
            if ((null == request) || (null == request.AppliesTo)) 
                return string.Empty;

            string appliesTo = request.AppliesTo.Uri.ToString();
            if (string.IsNullOrEmpty(appliesTo)) 
                return string.Empty;

            if (! _logRelyingParties.ContainsKey(appliesTo)) 
                return appliesTo;

            return _logRelyingParties[appliesTo];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\PerfCounters.cs ===
using System;
using System.Diagnostics;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.xsts.fd
{
    [XomComponentPerformanceCounterCategoryAttr("WCF", "XSts Custom WCF Perf Counters")]
    public class PerfCounters : PerformanceCounterCategory
    {
        public PerfCounters this[string s]
        {
            get
            {
                return (PerfCounters)GetInstance(s);
            }
        }

        static public PerfCounters Counters = new PerfCounters();

        [XomPerformanceCounterAttr(
             "Requests, Total",
             "Total number of requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _TotalRequests;

        public PerformanceCounter TotalRequests { get { return _TotalRequests; } }

        [XomPerformanceCounterAttr(
             "Requests, In Progress",
             "Number of requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _RequestsInProgress;

        public PerformanceCounter RequestsInProgress { get { return _RequestsInProgress; } }

        [XomPerformanceCounterAttr(
             "Requests, Per Sec",
             "Number of requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _RequestsPerSec;

        public PerformanceCounter RequestsPerSec { get { return _RequestsPerSec; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time (in ms)",
             "Average request execution time in the current AppDomain (in ms)",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter _AverageExecutionTime;

        public PerformanceCounter AverageExecutionTime { get { return _AverageExecutionTime; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time Base",
             "Base for the average request execution time in the current AppDomain",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter _AverageExecutionTimeBase;

        public PerformanceCounter AverageExecutionTimeBase { get { return _AverageExecutionTimeBase; } }

        [XomPerformanceCounterAttr(
             "Failures, Per Sec",
             "Number of failures per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _FailuresPerSecond;

        public PerformanceCounter FailuresPerSecond { get { return _FailuresPerSecond; } }

        [XomPerformanceCounterAttr(
             "Failures, Total",
             "Total number of failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _FailuresTotal;

        public PerformanceCounter FailuresTotal { get { return _FailuresTotal; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage",
             "Request failure percentage",
             PerformanceCounterType.SampleFraction)]
        public PerformanceCounter _FailuresPercentage;

        public PerformanceCounter FailuresPercentage { get { return _FailuresPercentage; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage Base",
             "Base for the prequest failure percentage",
             PerformanceCounterType.SampleBase)]
        public PerformanceCounter _FailuresPercentageBase;

        public PerformanceCounter FailuresPercentageBase { get { return _FailuresPercentageBase; } }

        public static string GetCounterName(string s)
        {
            // 1. "/" are bad in instance names
            // 2. instance must be <= 127 chars
            // 3. query strings are bad in instance names
            string instanceName = s.Replace('/', '\\');
            if (instanceName.Length > 127)
            {
                instanceName = instanceName.Substring(0, 127);
            }
            return instanceName;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ServiceHostFactory.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Description;

using Microsoft.IdentityModel.Protocols.WSTrust;

using xonline.common.config;

namespace xonline.server.xsts.fd
{
    public class ServiceHostFactory : WSTrustServiceHostFactory
    {
        // Summary:
        //     Creates a System.ServiceModel.ServiceHost with specific base addresses and
        //     initializes it with specified data.
        //
        // Parameters:
        //   constructorString:
        //     The initialization data passed to the System.ServiceModel.ServiceHostBase
        //     instance being constructed by the factory.
        //
        //   baseAddresses:
        //     The System.Array of type System.Uri that contains the base addresses for
        //     the service hosted.
        //
        // Returns:
        //     A System.ServiceModel.ServiceHost with specific base addresses.
        //
        // Exceptions:
        //   System.ArgumentNullException:
        //     baseAddress is null.
        //
        //   System.InvalidOperationException:
        //     There is no hosting context provided or constructorString is null or empty.
        public override ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses)
        {
            Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();
            ServiceHostBase host = base.CreateServiceHost(constructorString, baseAddresses);

            if ("development" == Config.EnvironmentType)
            {
                ServiceDebugBehavior debugBehavior = (ServiceDebugBehavior)host.Description.Behaviors.Find<System.ServiceModel.Description.ServiceDebugBehavior>();

                if (null != debugBehavior)
                {
                    debugBehavior.IncludeExceptionDetailInFaults = true;
                }
            }

            host.Description.Behaviors.Add(new ErrorHandler());

            //Allow any URI in  the mustUnderstand of the SOAP request.
            ServiceBehaviorAttribute descBehavior = ((ServiceBehaviorAttribute)host.Description.Behaviors[typeof(ServiceBehaviorAttribute)]);
            if (null != descBehavior)
            {
                descBehavior.AddressFilterMode = AddressFilterMode.Any;
            }

            host.Opened += new EventHandler(ServiceHostOpened);
            host.Closed  += new EventHandler(ServiceHostClosed);

            return host;
        }

        public void ServiceHostOpened(object sender, EventArgs e)
        {
            XSts.Init();
            XSts.ServiceHostOpened();
        }

        public void ServiceHostClosed(object sender, EventArgs e)
        {
            XSts.ServiceHostClosed();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\PerfCountersInstance.cs ===
using System;
using System.Diagnostics;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.xsts.fd
{
    public class PerfCountersInstance
    {
        ///////////////////////////////////////////////////
        // Attributes
        ///////////////////////////////////////////////////

        XomRequestTimeElapsed _requestTimeElapsed = new XomRequestTimeElapsed();

        private bool _isCounterIncrementComplete = false;
        private bool _isInProgress = false;

        private string _instanceName;

        // Static Attributes
        private static bool _isInitialized = false;

        static public PerfCounters Counters = PerfCounters.Counters;

        ///////////////////////////////////////////////////
        // Constructor
        ///////////////////////////////////////////////////

        public PerfCountersInstance()
        {
        }

        public PerfCountersInstance(bool isTotal)
        {
            _instanceName = "_total_";
            PerfCounters.Counters[_instanceName].RequestsInProgress.Increment();
            _isInProgress = true;
        }

        ~PerfCountersInstance()
        {
            EndRequestIncrement(false);  // if it does any work this must be a failure
        }

        ///////////////////////////////////////////////////
        // Implemenation : Public
        ///////////////////////////////////////////////////

        public void BeginRequestIncrement(string instanceName)
        {
            if (_isInProgress) return;

            _instanceName = PerfCounters.GetCounterName(instanceName);

            PerfCounters.Counters[_instanceName].RequestsInProgress.Increment();
            _isInProgress = true;
        }

        public void EndRequestIncrement()
        {
            EndRequestIncrement(true);
        }

        public void EndRequestIncrementFailure()
        {
            EndRequestIncrement(false);
        }

        // Records a performance counter failure.
        // Meant to be used for a counter that BeginRequestIncrement has not been called for
        // this can happen if the Perf Counter instance name is not known early on in the processing pipeline
        public void EndRequestIncrementFailure(string instanceName)
        {
            if (!_isInProgress) return;

            EndRequestIncrement(false, PerfCounters.GetCounterName(instanceName));
        }

        public static void Init()
        {
            if (_isInitialized) return;

            _isInitialized = true;
            
            // This is needed, to create the PerfCounter collection that gets everything started
            // Not PerformanceCounterCategory is a modified version of XomPerformanceCounterCategory
            // that will not create the XomPerformanceCounterCategory.DEFAULT_INSTANCE when this call
            // is invoked
            PerfCounters counters = PerfCounters.Counters;
        }

        public static void UnInit()
        {
            if (!_isInitialized) return;

            PerformanceCounter.CloseSharedResources();
            _isInitialized = false;
        }

        ///////////////////////////////////////////////////
        // Implemenation : Protected
        ///////////////////////////////////////////////////

        protected void EndRequestIncrement(bool isRequestSuccessful = true, string instanceNameIn = null)
        {
            if (!_isCounterIncrementComplete)
            {
                _isCounterIncrementComplete = true;

                string instanceName = string.IsNullOrEmpty(_instanceName) ? instanceNameIn : _instanceName;

                if (!string.IsNullOrEmpty(instanceName))
                {
                    PerfCounters perfCounters = PerfCounters.Counters[instanceName];

                    perfCounters.TotalRequests.Increment();
                    perfCounters.RequestsPerSec.Increment();
                    if (_isInProgress)
                    {
                        perfCounters.RequestsInProgress.Decrement();
                    }
                    perfCounters.FailuresPercentageBase.Increment();

                    // Only add succeses into the average execution time.
                    if (isRequestSuccessful)
                    {
                        perfCounters.AverageExecutionTime.IncrementBy(_requestTimeElapsed.TimeElapsed * 1000);
                        perfCounters.AverageExecutionTimeBase.Increment();
                    }
                    else
                    {
                        perfCounters.FailuresPerSecond.Increment();
                        perfCounters.FailuresTotal.Increment();
                        perfCounters.FailuresPercentage.Increment();
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ValidateRequest.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

using System.ServiceModel;
using System.ServiceModel.Web;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.XboxLive.Auth.Protocol;

using xonline.common.exceptions;
using xonline.common.service;

using xonline.server.xsts.provider;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {

        /// <summary>
        /// Parse and Validate the RST AdditionalContext
        /// </summary>
        protected void ValidateAdditionalContext(AdditionalContext additionalCtx)
        {
            bool isAdditionalContextValid = false;
            string delegationToken = null;
            string titleId = null;
            string titleVersion = null;
            string clientVersion = null;

            if (null == additionalCtx)
            {
                isAdditionalContextValid = true;
            }
            else if (1 == additionalCtx.Items.Count)
            {
                if (string.Equals(additionalCtx.Items[0].Name.ToString(), AuthClaimTypes.Xuid))
                {
                    Puid.TryParse(additionalCtx.Items[0].Value, out _xuid);
                }
                else if (string.Equals(additionalCtx.Items[0].Name.ToString(), AuthClaimTypes.DelegationToken))
                {
                    delegationToken = additionalCtx.Items[0].Value;
                }
            }
            else if (3 == additionalCtx.Items.Count)
            {
                if (string.Equals(additionalCtx.Items[0].Name.ToString(), AuthClaimTypes.TitleId)
                  && string.Equals(additionalCtx.Items[1].Name.ToString(), AuthClaimTypes.TitleVersion)
                  && string.Equals(additionalCtx.Items[2].Name.ToString(), XStsClaimTypes.ADDITIONALCONTEXT_DEVICE_CLIENTVERSION)
                   )
                {
                    titleId = additionalCtx.Items[0].Value;
                    titleVersion = additionalCtx.Items[1].Value;
                    clientVersion = additionalCtx.Items[2].Value;
                }
            }


            // Ok, finally ready to set the ClaimsPrincipal. Needed to get the _xuid first!
            // Would have liked to do this earlier as so much depends on it but now is the time. 
            // Everything going forward will be able to rely on it (i.e. Logging)

            IClaimsPrincipal principal = null;

            if (0 != _xuid)
            {   // Xuid in AdditionalContext indicates this should be an SG caller.
                // Try to create a ClaimsPrincipal.
                principal = XClaimsPrincipal.CreateFromXblContext(HttpContextAdapter.Current, _xuid);

                if (null != principal)
                {
                    if (principal.ClaimExists(AuthClaimTypes.Xuid))
                    {
                        isAdditionalContextValid = true;
                    }
                }
            }

            // if there is no sginfo, see if there is an authorization header

            if (null == principal)
            {
                var uri = OperationContext.Current.IncomingMessageHeaders.To.AbsoluteUri;
                var headers = WebOperationContext.Current.IncomingRequest.Headers;

                XblAuthProtocolHandler protocolHandler = new XblAuthProtocolHandler();
                principal = protocolHandler.ProcessToken(headers, uri) as IClaimsPrincipal;

                if (null != principal)
                {
                    principal = new XClaimsPrincipal(principal);
                }
            }

            // if we don't have a principal at this point, we are out of here

            if (null == principal)
            {
                throw new XblException(HResult.XONLINE_E_XSTS_PRINCIPAL_NOTAUTHORIZED, "Principal not authorized");
            }

            // put the principal onto the context so other methods can find it

            HttpContextAdapter.Current.Items["Principal"] = principal;

            if (!string.IsNullOrEmpty(delegationToken))
            {
                isAdditionalContextValid = ValidatePrincipalAndDelegate(principal, delegationToken);
            }
            else if (!string.IsNullOrEmpty(titleId))
            {
                isAdditionalContextValid = ValidatePrincipalAndTitle(principal, titleId, titleVersion, clientVersion);
            }

            // Waited till after we set the Current Principal before throwing this exception
            if (!isAdditionalContextValid)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ADDITIONALCONTEXT, "Invalid RST AdditionalContext");

        }

        /// <summary>
        /// Override the ValidateRequest method to validate the custom element
        /// </summary>
        /// <param name="request">The security token request.</param>
        protected override void ValidateRequest(RequestSecurityToken request)
        {
            ValidateAdditionalContext(request.AdditionalContext);

            base.ValidateRequest(request);

            // Validate there are no unwanted fields
            // RequestSecurityToken fields
            if (null != request.ActAs)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ACTASSTS, "Invalid RST ActAs");
            if (null != request.CancelTarget)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_CANCELTARGET, "Invalid RST CancelTarget");
            if (null != request.ClientPseudonym)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_CLIENTPSEUDONYM, "Invalid RST ClientPseudonym");
            if (null != request.ComputedKeyAlgorithm)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_COMPUTEDKEYALGORITHM, "Invalid RST ComputedKeyAlgorithm");
            if (null != request.Delegatable)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_DELEGATABLE, "Invalid RST Delegatable");
            if (null != request.DelegateTo)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_DELEGATETO, "Invalid RST DelegateTo");
            if (null != request.DisplayTokenLanguage)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_DISPLAYTOKENLANGUAGE, "Invalid RST DisplayTokenLanguage");
            if (null != request.Encryption)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ENCRYPTION, "Invalid RST Encryption");
            if (null != request.Forwardable)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_FORWARDABLE, "Invalid RST Forwardable");
            if (null != request.InformationCardReference)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_INFORMATIONCARDREFERENCE, "Invalid RST InformationCardReference");
            if (null != request.Issuer)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ISSUER, "Invalid RST Issuer");
            if (null != request.OnBehalfOf)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ONBEHALFOF, "Invalid RST OnBehalfOf");
            if (null != request.Participants)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_PARTICIPANTS, "Invalid RST Participants");
            if (null != request.ProofEncryption)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_PROOFENCRYPTION, "Invalid RST ProofEncryption");
            if (null != request.Renewing)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_RENEWING, "Invalid RST Renewing");
            if (null != request.RenewTarget)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_RENEWTARGET, "Invalid RST RenewTarget");
            if (request.RequestDisplayToken)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_REQUESTDISPLAYTOKEN, "Invalid RST RequestDisplayToken");
            if (null != request.SecondaryParameters)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_SECONDARYPARAMETERS, "Invalid RST SecondaryParameters");
            if (null != request.ValidateTarget)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_VALIDATETARGET, "Invalid RST ValidateTarget");
            // WSTrustMessage fields
            if (request.AllowPostdating)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ALLOWPOSTDATING, "Invalid RST AllowPostdating");
            if (null == request.AppliesTo)  // Or 0x80131940 if AppliesTo is deemed invalid by WIF
                throw new XblException(HResult.XONLINE_E_XSTS_RST_APPLIESTO, "Invalid RST AppliesTo");
            if (null != request.AuthenticationType)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_AUTHENTICATIONTYPE, "Invalid RST AuthenticationType");
            if (null != request.BinaryExchange)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_BINARYEXCHANGE, "Invalid RST BinaryExchange");
            if (null != request.CanonicalizationAlgorithm)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_CANONICALIZATIONALGORITHM, "Invalid RST CanonicalizationAlgorithm");
            if (null != request.EncryptionAlgorithm)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ENCRYPTIONALGORITHM, "Invalid RST EncryptionAlgorithm");
            if (null != request.EncryptWith)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ENCRYPTWITH, "Invalid RST EncryptWith");
            if (null != request.Entropy)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_ENTROPY, "Invalid RST Entropy");
            if (null != request.KeySizeInBits)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_KEYSIZEINBITS, "Invalid RST KeySizeInBits");
            if (null != request.KeyType)
            {
                if (!KeyTypes.Equals(KeyTypes.Bearer, request.KeyType))
                    throw new XblException(HResult.XONLINE_E_XSTS_RST_KEYTYPE, "Invalid RST KeyType");
            }
            else
            {
                request.KeyType = KeyTypes.Bearer;
            }
            if (null != request.KeyWrapAlgorithm)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_KEYWRAPALGORITHM, "Invalid RST KeyWrapAlgorithm");
            if (null != request.Lifetime)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_LIFETIME, "Invalid RST Lifetime");
            if (null != request.ReplyTo)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_REPLYTO, "Invalid RST ReplyTo");
            if (!RequestTypes.Equals(RequestTypes.Issue, request.RequestType))
                throw new XblException(HResult.XONLINE_E_XSTS_RST_REQUESTTYPE, "Invalid RST RequestType");
            if (null != request.SignatureAlgorithm)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_SIGNATUREALGORITHM, "Invalid RST SignatureAlgorithm");
            if (null != request.SignWith)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_SIGNWITH, "Invalid RST SignWith");
            if (null != request.TokenType)
            {
                if (!string.Equals(Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11, request.TokenType))
                    throw new XblException(HResult.XONLINE_E_XSTS_RST_TOKENTYPE, "Invalid RST TokenType");
            }
            else
            {
                request.TokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11;
            }
            if (null != request.UseKey)
                throw new XblException(HResult.XONLINE_E_XSTS_RST_USEKEY, "Invalid RST UseKey");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\ValidateTitle.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.service;

using xonline.kdc.ManagedProxy;

using xonline.server.kdc;
using xonline.server.xsts.provider;

namespace xonline.server.xsts.fd
{
    public partial class XSts : SecurityTokenService
    {
        /// <summary>
        /// Verify that the caller can delegate and perform the delegation
        /// </summary>
        private bool ValidatePrincipalAndTitle(IClaimsPrincipal principal, string titleValue, string versionValue, string clientVersionValue)
        {
            // Private can assume Non-NULL parameter validation by caller

            // Verify this is a WindowsPhone

            IEnumerable<Claim> deviceTypes = principal.FindClaims(AuthClaimTypes.DeviceType);

            if (1 != deviceTypes.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_TITLE_NOTVALID_UNTRUSTED_CALLER, "Title claim invalid. Not a trusted caller");
            }

            if (AuthDeviceTypes.WindowsPhone != deviceTypes.ElementAt(0).Value)
            {
                throw new XblException(HResult.XONLINE_E_XSTS_TITLE_NOTVALID_UNTRUSTED_DEVICE, "Title claim invalid. Not a trusted device");
            }

            // Get the deviceId

            IEnumerable<Claim> deviceIds = principal.FindClaims(AuthClaimTypes.DeviceId);

            if (1 != deviceIds.Count())
            {
                throw new XblException(HResult.XONLINE_E_XSTS_TITLE_NOTVALID_UNTRUSTED_CALLER, "Title claim invalid. Device Id missing or not unique");
            }

            Claim deviceId = deviceIds.ElementAt(0);

            // Done checking the principal, okay let's check the title values

            byte platformType = XOn.XPLT_MOBILE;    // Verified above
            uint titleId = 0;
            uint titleVersion = 0;
            uint clientVersion = 0;

            if (!uint.TryParse(titleValue, out titleId))
            {
                throw new XblException
                    ( HResult.XONLINE_E_XSTS_TITLEID_PARSE_FAILURE
                    , string.Format("Could not parse TitleId {0}", titleValue)
                    );
            }
            if (!uint.TryParse(versionValue, out titleVersion))
            {
                throw new XblException
                    (HResult.XONLINE_E_XSTS_TITLEVERSION_PARSE_FAILURE
                    , string.Format("Could not parse TitleVersion {0}", versionValue)
                    );
            }
            if (!uint.TryParse(clientVersionValue, out clientVersion))
            {
                throw new XblException
                    (HResult.XONLINE_E_XSTS_CLIENTVERSION_PARSE_FAILURE
                    , string.Format("Could not parse ClientVersion {0}", clientVersionValue)
                    );
            }

            MachineAndTitleValidator validator = new MachineAndTitleValidator();

            // Throw exceptions on errors                
            validator.ValidateDeviceId(platformType, deviceId.Value);
            validator.ValidateClientVersion(platformType, clientVersion);   // Must happen after ValidateDeviceId so _machinePuid is valid
            validator.ValidateTitle(titleId, titleVersion, platformType, clientVersion);

            // Okay we are going to trust the title and version.  Add them to the principal
            Claim titleClaim = new Claim(AuthClaimTypes.TitleId, titleId.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId], AuthDeviceTypes.WindowsPhone);
            Claim versionClaim = new Claim(AuthClaimTypes.TitleVersion, titleVersion.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleVersion], AuthDeviceTypes.WindowsPhone);

            // Let's add the Title claims to the first principal
            principal.Identities[0].Claims.Add(titleClaim);
            principal.Identities[0].Claims.Add(versionClaim);

            // Also let's replace the DeviceId with the real DeviceId
            foreach (IClaimsIdentity identity in principal.Identities)
            {
                if (identity.Claims.Remove(deviceId))
                {
                    identity.Claims.Add
                        (new Claim
                            (AuthClaimTypes.DeviceId
                            , validator.MachinePuid.ToString("X")
                            , AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId]
                            )
                        );
                }
            }

            return true;
        }


        /// <summary>
        /// Copied these three functions as is from Stsvs (SecurityTicketImpl.cs)
        /// Wrapped in this class so I could use as is without any changes
        /// </summary>
        internal class MachineAndTitleValidator
        {
            // Attributes
            private ulong machinePuid = 0;

            public ulong MachinePuid
            {
                get { return this.machinePuid; }
            }

            // -------------------------------------------------------------------------------
            // ValidateClientVersion
            //
            // Intentionally empty for now
            // -------------------------------------------------------------------------------
            public void ValidateClientVersion(
                byte platformType, uint clientVersion
            )
            {
                if (XOn.XPLT_MOBILE == platformType)
                {
                    KdcServiceRequest request = new KdcServiceRequest();
                    request.ClientVersion = clientVersion;
                    XkdcSetMachineFlashVersionImpl.XkdcSetMachineFlashVersion(this.machinePuid, string.Format("{0:00}.{1:00}.{2:00000}.{3:000}", request.clientVersion.wMajorVersion, request.clientVersion.wMinorVersion, request.clientVersion.wBuildNumber, request.clientVersion.wQFENumber));
                }
            }

            // -------------------------------------------------------------------------------
            // ValidateDeviceId
            //
            // kdc like machine verify and account creation.  Adapted from MachineBan.
            // -------------------------------------------------------------------------------
            public void ValidateDeviceId(
                byte platformType, string deviceId
            )
            {
                if (XOn.XPLT_MOBILE == platformType)
                {
                    this.machinePuid = WMMachinesDB.GetMachinePuid(deviceId);

                    if (0 == this.machinePuid)
                    {   // create machine account
                        this.machinePuid = WMMachinesDB.CreateMachineAccount(deviceId);
                    }
                }
            }

            // -------------------------------------------------------------------------------
            // ValidateTitle
            //
            // "Managed KDC" title validation.
            // -------------------------------------------------------------------------------
            public void ValidateTitle(
                uint titleId, uint titleVersion, byte platformType, uint clientVersion
            )
            {
                // The ServiceRequest should contain the values we are checking
                KdcServiceRequest request = new KdcServiceRequest();
                request.ClientVersion = clientVersion;
                request.titleId = titleId;
                request.titleVersion = titleVersion;
                request.wAutoDiscoverServices = 0;

                // The PolicyData should contain the results of the check
                // There is a lot of logic around using Cached results in the kdc, omitting that for now :(
                KdcPolicyData policyData = new KdcPolicyData();
                policyData.ClientVersion = request.ClientVersion;
                policyData.platformType = (uint)platformType;
                policyData.machinePuid = this.machinePuid;

                _theKdc.PolicyCheck(request, policyData);

                if (HResult.Failed(policyData.machineAuthorization.BlockStatusCode))
                    throw new XRLExceptionWithoutEvent(policyData.machineAuthorization.BlockStatusCode, "Machine Blocked: {0}", this.machinePuid);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\Management.cs ===
﻿using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.config.sts.interfaces;

using xonline.server.kdc;

namespace xonline.server.xsts.fd
{
    public class Management
    {
        public static void Init()
        {
            XomLoggingControl.Init();
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command) 
                {
                    case "help":
                        XomControlConnection.SendMessage
                            ( "XSts help:\r\n" 
                            + "    reload           - reload the configuration\r\n\r\n" 
                            + "    list [appliesTo] - list the relying parties, or\r\n" 
                            + "                       if an appliesTo is specified then\r\n"
                            + "                       the claims for that relying party\r\n\r\n" 
                            + "    list [providers | p] [claim provider type]\r\n"
                            + "                     - list the claim providers, or\r\n" 
                            + "                       if a Claim Provider type is specified then\r\n" 
                            + "                       the claims supported by that provider type\r\n\r\n"
                            + "    list [titles | t] [titleid]\r\n"
                            + "                     - list the titles, or\r\n" 
                            + "                       if a titleid is specified then\r\n" 
                            + "                       the titleversin records currenlty loaded\r\n\r\n"
                            , args.RequestId
                            );

                        args.Handled = true;
                        break;

                    case "reload" :
                        XSts.LoadStsConfig();
                        XSts.LoadKdcConfig();
                        XomControlConnection.SendMessage("XSts configuration and title info have been reloaded", args.RequestId);
                        args.Handled = true;
                        break;

                    case "list":
                        string s;

                        if ((args.CommandArgs == null) || (args.CommandArgs.Length == 0))
                        {
                            s = XSts.ListAppliesTo(null);
                        }
                        else if (args.CommandArgs.Length == 1)
                        {
                            if ("providers" == args.CommandArgs[0].ToLower() || "p" == args.CommandArgs[0].ToLower())
                            {
                                s = XSts.ListClaimProviders(null);
                            }
                            else if ("titles" == args.CommandArgs[0].ToLower() || "t" == args.CommandArgs[0].ToLower())
                            {
                                s = XSts.ListTitles(null);
                            }
                            else 
                            {
                                s = XSts.ListAppliesTo(args.CommandArgs[0]);
                            }
                        }
                        else if (args.CommandArgs.Length == 2)
                        {
                            if ("providers" == args.CommandArgs[0].ToLower() || "p" == args.CommandArgs[0].ToLower())
                            {
                                s = XSts.ListClaimProviders(args.CommandArgs[1]);
                            }
                            else if ("titles" == args.CommandArgs[0].ToLower() || "t" == args.CommandArgs[0].ToLower())
                            {
                                s = XSts.ListTitles(args.CommandArgs[1]);
                            }
                            else 
                            {
                                s = "Invalid arguments, must specify 0 or 1 appliesTo parameters";
                            }
                        }
                        else 
                        {
                            s = "Invalid arguments, must specify 0 or 1 appliesTo parameters";
                        }

                        XomControlConnection.SendMessage(s, args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch (Exception e)
            {
                HResult hr = XRLException.ToHResult(e, HResult.E_FAIL);
                XomControlConnection.SendMessage(string.Format("Error: {0}, hr = {1}\r\n\r\n", e.ToString(), hr), args.RequestId);
            }
        }


        internal static string ListAppliesTo
            ( string s
            , IDictionary<Uri, IAppliesTo> appliesTos
            )
        {
            StringBuilder stringBuilder = new StringBuilder();

            // if there is no string passed in then we are just doing
            // a dump of all the relying parties 

            if (string.IsNullOrEmpty(s))
            {
                ListAppliesTo(appliesTos, stringBuilder);
            }
            else // dump out the specifics of the appliesto
            { 
                Uri appliesToUri;

                try {
                    appliesToUri = new Uri(s);

                    if ((appliesToUri == null) || (! appliesTos.ContainsKey(appliesToUri)))
                        stringBuilder.AppendFormat("No matching AppliesTo found, {0}", s);
                    else {
                        stringBuilder.AppendFormat("\r\nApplies To\r\n");
                        DumpAppliesTo(appliesTos[appliesToUri], appliesToUri, stringBuilder);
                    }
                }
                catch (UriFormatException) {
                    stringBuilder.AppendFormat("Not a valid AppliesTo, {0}", s);
                }
            }

            return stringBuilder.ToString();
        }

        internal static string ListClaimProviders
            ( string s
            , List<ClaimProvider> claimProviders
            )
        {
            StringBuilder stringBuilder = new StringBuilder();

            // if there is no string passed in then we are just doing
            // a dump of all claim providers

            if (string.IsNullOrEmpty(s))
            {
                ListClaimProviders(claimProviders, stringBuilder);
            }
            else // dump out the specifics of the claim provider
            {
                foreach (ClaimProvider claimProvider in claimProviders) {
                    if (s.Equals(claimProvider.Name)) {
                        stringBuilder.AppendFormat("\r\nClaim Provider\r\n");
                        DumpClaimProvider(claimProvider, stringBuilder);
                        return stringBuilder.ToString();
                    }
                }

                stringBuilder.AppendFormat("Claim Provider not found, {0}", s);
            }

            return stringBuilder.ToString();
        }

        internal static SortedDictionary<string, ClaimProvider> ListAppliesTo(
            IDictionary<Uri, IAppliesTo> appliesTos,
            StringBuilder                stringBuilder
        )
        {
            SortedDictionary<string, ClaimProvider> claimProviders = new SortedDictionary<string, ClaimProvider>();

            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("Applies Tos");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();

            foreach (IAppliesTo appliesTo in appliesTos.Values) 
            {
                stringBuilder.AppendFormat("    {0}\r\n", appliesTo.AppliesToUri);
            }

            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("Number of AppliesTos: {0}", appliesTos.Count);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();

            return claimProviders;
        }


        internal static void ListClaimProviders(List<ClaimProvider> claimProviders, StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("Claim Providers");
            stringBuilder.AppendLine();

            foreach (ClaimProvider claimProvider in claimProviders) {
                DumpClaimProvider(claimProvider, stringBuilder);
            }

            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("Number of Claim Providers: {0}", claimProviders.Count);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();
        }

        internal static void DumpClaimProvider(ClaimProvider claimProvider, StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("    {0}\r\n", claimProvider.Name);
            stringBuilder.AppendLine("    Available Claim Types\r\n");

            foreach (KeyValuePair<Uri, IClaimType> kvpClaimType in claimProvider.ClaimTypeProvider.ClaimTypes) {
                stringBuilder.AppendFormat("        {0}", kvpClaimType.Value.ClaimTypeUri.ToString());
                stringBuilder.AppendLine();
            }
            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("Number of Claims: {0}", claimProvider.ClaimTypeProvider.ClaimTypes.Count);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();
        }

        internal static void DumpAppliesTo(IAppliesTo appliesTo, Uri appliesToUri, StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("    Uri           : {0}\r\n", appliesTo.AppliesToUri);
            stringBuilder.AppendFormat("    Partner       : {0}\r\n", appliesTo.BusinessPartner.Name);
            stringBuilder.AppendFormat("    Partner Type  : {0}\r\n", appliesTo.BusinessPartner.Type.Type);
            stringBuilder.AppendFormat("    TokenType     : {0}\r\n", appliesTo.TokenType.Uri);
            stringBuilder.AppendFormat("    TokenLifetime : {0}\r\n", appliesTo.ValidityInterval);

            if (appliesTo.AppliesToCertificate == null)
                stringBuilder.AppendFormat("    Certificate   : {0}\r\n", "(none)");
            else
            {
                stringBuilder.AppendFormat("    Certificate   : {0}\r\n", appliesTo.AppliesToCertificate.Subject);
                stringBuilder.AppendFormat("    Expiration    : {0}\r\n", appliesTo.AppliesToCertificate.GetExpirationDateString());
            }

            // only include the claims if there are claims

            if (appliesTo.ClaimTypes.Count > 0)
            {
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("    Configured Claim Types");
                stringBuilder.AppendLine();

                foreach (IAppliesToClaimType claimType in appliesTo.ClaimTypes.Values)
                {
                    stringBuilder.AppendFormat("        {0}, {1}", claimType.ClaimType.ClaimTypeUri, claimType.ClaimType.ValueType);
                    if (claimType.ClaimType.Encrypted) stringBuilder.Append(", encrypted");
                    stringBuilder.AppendLine();
                }
            }
            stringBuilder.AppendLine();
            stringBuilder.AppendFormat("Number of Claims: {0}", appliesTo.ClaimTypes.Count);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\PerformanceCounterCategory.cs ===
/*
NT Performance Counters

Declare your own class following like in the example:

    [PerformanceCounterCategoryAttr(
        "TestApp Counters", 
        "The counters for your nice test app",
        true  //If this is a Shared PerfCategory installed by more than one component
    )]
    public class TestAppCounters : PerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Operations per second", 
            "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RatingsPerSecond;

        static public TestAppCounters Counters = new TestAppCounters();
    }

Then access the PerformanceCounter fields directly. E.g.:

    TestAppCounters.Counters.RatingsPerSecond.Increment();

For more information look for 'PerformanceCounter class' on MSDN. 

One more thing, if you're using counters then you will first have to install 
your assembly using InstallUtil.exe which is located in the .NET framework
directory: %WINDIR%\Microsoft.NET\Framework\vXXXX\InstallUtil.exe.

*/

using System;
using System.Collections;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.xsts.fd
{
    public class PerformanceCounterCategory
    {
        [ThreadStaticAttribute]
        private static string _categoryInstanceName;

        // Gets the instance name associated with the current thread, or the default instance
        // if none is specified.
        
        private static string GetInstanceName() {
            return _categoryInstanceName;
        }

        private static void SetInstanceName(string instance) {
            _categoryInstanceName = instance;
        }
        
        public PerformanceCounterCategory() : this(false)
        {
        }
        public PerformanceCounterCategory(bool fInitToZero)
        {
            // Extract the name and the instanceLifeTime text from the class's custom attribute. 
            XomPerformanceCounterCategoryAttr catAttr = XomPerformanceCounterInstall.GetCategoryAttribute(GetType());

            string categoryName = catAttr.CtgName;
            string categoryHelp = catAttr.CtgHelp;

            _categoryName = categoryName;
            _instanceLifetime = catAttr.CtrInstanceLifetime;

            InitializeCategory(GetInstanceName(), fInitToZero);
        }
        
        // You can use this method to create/access other instances. The first
        // time you access the instance will create it. Since the method returns
        // an PerformanceCounterCategory object  you will have to cast it
        // to your own class before accessing its counters. One practical way of
        // doing it is to declare your own [] operator. Hmmm, maybe we should 
        // have a method that destroys an instance, huh?

        public PerformanceCounterCategory GetInstance(string instanceName)
        {
            PerformanceCounterCategory instance;
            
            // access to instance list must be protected against writes.
            
            _lockInstances.AcquireReaderLock(-1);

            try
            {
                // search for instance
            
                instance = (PerformanceCounterCategory) _instances[instanceName];

                if(instance == null)
                {
                    try {
                        // object instance will be actived with, the 
                        // PerformanceCounterCategory::ctor will catch the 
                        // correct counter instance names to initialize with
                        SetInstanceName(instanceName);
                        instance = (PerformanceCounterCategory)Activator.CreateInstance(GetType());
                    }
                    finally {
                        SetInstanceName(null);
                    }

                    // We need write access to the instance list to add this new
                    // instance
                    
                    LockCookie lockCookie = _lockInstances.UpgradeToWriterLock(-1);

                    try
                    {
                        // Now that we are inside, make sure that no other thread
                        // added the instance before us.

                        if(_instances[instanceName] == null)
                        {
                            // Add instance to instance list
                            
                            _instances[instanceName] = instance;
                        }
                        else
                        {
                            // Some other thread got here first. Well, let's use
                            // the object that is already there, then.
                            
                            instance = (PerformanceCounterCategory) _instances[instanceName];
                        }
                    }
                    finally
                    {
                        _lockInstances.DowngradeFromWriterLock(ref lockCookie);
                    }
                }
            }
            finally
            {
                _lockInstances.ReleaseReaderLock();
            }

            return instance;
        }

        // Verifies that a field is a valid perform counter field.
        // Validity requires that is the right type, and has the required attribute
        
        private bool IsValidPerformanceCounterField(FieldInfo field) {
            return 
                field.FieldType == typeof(PerformanceCounter) &&
                Attribute.IsDefined(field, typeof(XomPerformanceCounterAttr), false);
        }

        // Get the attribute from a performance counter field, it is assumed that
        // the field is valid
        
        private XomPerformanceCounterAttr GetPerformanceCounterAttr(FieldInfo field) {
            return field.GetCustomAttributes(
                typeof(XomPerformanceCounterAttr), 
                false)[0] as XomPerformanceCounterAttr;
        }

        // Enumerate all fields that are valid performance counter fields for this
        // class
        
        private FieldInfo[] EnumerateValidPerformanceCounterFields() {
            FieldInfo[]     fields;
            List<FieldInfo> validFields;

            fields      = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            validFields = new List<FieldInfo>(fields.Length);
            
            for (int c=0; c<fields.Length; c++) {
                if (IsValidPerformanceCounterField(fields[c]))
                    validFields.Add(fields[c]);
            }

            return validFields.ToArray();
        }
        
        // Loads all the performance counters for the valid performance counter fields
        
        private void InitializeCategory(string instanceName, bool fInitToZero) 
        {
            if (string.IsNullOrEmpty(instanceName))
                return;

            foreach (FieldInfo field in EnumerateValidPerformanceCounterFields()) {
                XomPerformanceCounterAttr attr = GetPerformanceCounterAttr(field);

                PerformanceCounter counter;

                counter = CreateCounter(
                    attr._ctrName,
                    instanceName);

                if (fInitToZero)
                {
                    counter.RawValue = 0;
                }

                field.SetValue(this, counter);
            }
        }

        // Creates a new performance counter object

        private PerformanceCounter CreateCounter(string counterName, string instanceName) {
            PerformanceCounter counter;
            long raw;

            try {
                counter = new PerformanceCounter();
                counter.CategoryName     = _categoryName;
                counter.CounterName      = counterName;
                counter.InstanceName     = instanceName;
                counter.ReadOnly         = false;
                counter.InstanceLifetime = _instanceLifetime;
                
                //force initialization of the counter
                raw = counter.RawValue;

                return counter;
            }
            catch (Exception e) {
                Xom.NtEvent(XEvent.Id.PERFORMANCE_COUNTERS_0, e, 
                    "Failed to create the performance counter '{0}' in category '{1}' " +
                    "for instance '{2}'. " +
                    "This may be due to an improper installation of the component, if so running " +
                    "installutil.exe against against this component may fix the issue.",
                    counterName, _categoryName, instanceName
                );

                throw;
            }
        }

        private string _categoryName = null; 
            // Name of the performance counter category

        private Hashtable _instances = new Hashtable();
            // Hash table to store the instance objects
            
        private ReaderWriterLock _lockInstances = new ReaderWriterLock();
            // Sync access to the _instances

        private PerformanceCounterInstanceLifetime _instanceLifetime = PerformanceCounterInstanceLifetime.Global;
            // How long do counter instances in this cateogory live?
            
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\WMMachinesdb.cs ===
//
// Machinesdb.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Transactions;
using System.Web;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.sts)]

namespace xonline.server.xsts.fd
{
    internal class WMMachinesDB
    {
        private const string MOBILE_PREFIX = "WM.";

        // -------------------------------------------------------------------------------
        // Implementation public
        // -------------------------------------------------------------------------------

        public static ulong CreateMachineAccount( string deviceId )
        {
            ulong machinePuid       = WMMachinesDB.GetPuid();

            using (TransactionScope ts = new TransactionScope())
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // insert the machine into t_machines
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmacs_insertmachine";
                    ws.SetHashVal(machinePuid);

                    ws.AddParameter("@serialnum", MOBILE_PREFIX + machinePuid.ToString("X16").Substring(4));
                    ws.AddParameter("@machinepuid", machinePuid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();

                    // insert the machine into t_wm_machines
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_wm_insert_machine";
                    ws.SetHashVal(deviceId);

                    ws.AddParameter("@vc_WMDevice_id", deviceId);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }
                ts.Complete();
            }
            
            return machinePuid;
        }
        
        public static ulong GetMachinePuid( string deviceId )
        {
            ulong machinePuid       = 0;
            WstConnection   conn    = null;
            WstCommand      cmd     = null;
            WstDataReader   dataset = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_wm_get_machines";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType   = WstPartitionType.Logical;
                cmd.Partition       = WSClient.GetHashPartition( deviceId, ConfigUtil.UodbWebstoreApp);
                cmd.Parameters.Add("@vc_WMDevice_id", SqlDbType.NVarChar, 128).Value = deviceId;

                dataset = cmd.ExecuteReader();

                if (dataset.Read())
                {
                    machinePuid = (ulong) dataset.GetInt64(0);
                }
            }
            finally
            {
                if (null!=dataset)
                    dataset.Close();
                if (null!=conn)
                    conn.Close();
            }

            return machinePuid;
        }

        // -------------------------------------------------------------------------------
        // Implementation private
        // -------------------------------------------------------------------------------

        private static ulong GetPuid()
        {
            int blockSize = 1;
            int bucket = Config.GetIntSetting(Setting.puidmgr_userPuidBucket);

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_puid_get_next_id";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = bucket;
                    cmd.Parameters.Add("@i_req_block_size", SqlDbType.Int).Value = blockSize;
                    cmd.Parameters.Add("@bi_base", SqlDbType.BigInt).Value = unchecked((long)XOn.XboxId.MobileMachineBase);

                    SqlParameter puidParam = cmd.CreateParameter();
                    puidParam.Direction = ParameterDirection.Output;
                    puidParam.DbType = DbType.Int64;
                    puidParam.ParameterName = "@bi_next_id";
                    cmd.Parameters.Add(puidParam);

                    cmd.ExecuteNonQuery();

                    int retVal = (int) ret.Value;

                    // log the result information.
                    Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "PUID acquistion from NPDB returned :  RETVAL:  " + retVal + "\nBucket = " + bucket + "\nBlock Size = " + blockSize );

                    if (retVal == 0)
                    {
                        return (ulong) ((long) puidParam.Value);
                    }
                    else
                    {
                        throw new XRLException( HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.COMMON_CODE_180, "Failed to attain PUID block from NPDB.  Please investigate. RETVAL:  " + retVal );
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\XStsConfiguration.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Web.Configuration;

using xonline.common.service;

using xonline.config.sts.interfaces;

namespace xonline.server.xsts.fd.config
{
    internal class XStsConfiguration
    {
        /// </summary>
        /// Load/Reload configuration data
        /// </summary>
        public static ISTSConfiguration GetSTSConfiguration()
        {
            string configurationType = WebConfigurationManager.AppSettings["ConfigurationProvider"];
            ISTSConfigurationProvider configProvider = null;
            ISTSConfiguration config = null;

            if ("File" == configurationType)
            {
                STSConfigurationProvider XStsConfigurationSection = (STSConfigurationProvider)ConfigurationManager.GetSection("XStsConfiguration");
                configProvider = (ISTSConfigurationProvider)XStsConfigurationSection;
            }
            else // Make Database the Default: if ("Database" == configurationType)
            {
                configProvider = (ISTSConfigurationProvider)new xonline.config.sts.databaseconfig.DatabaseConfigurationProvider();
            }

            if (null != configProvider)
            {
                try
                {
                    configProvider.Load();
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_XSTS_CONFIGURATIONPROVIDER_LOAD, XEvent.Id.XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR, e, "Error calling ISTSConfigurationProvider::Load");
                }
                config = configProvider.STSConfiguration;
            }

            return config;
        }

        /// </summary>
        /// Load/Reload configuration data
        /// </summary>
        public static IDictionary<string, IIEBBusinessPartner> GetBusinessPartners()
        {
            string configurationType = WebConfigurationManager.AppSettings["ConfigurationProvider"];
            IIEBBusinessPartnerConfigurationProvider configProvider = null;
            IDictionary<string, IIEBBusinessPartner> partners = null;

            if ("File" == configurationType)
            {
                configProvider = null;
            }
            else if ("Database" == configurationType)
            {
                configProvider = (IIEBBusinessPartnerConfigurationProvider)new xonline.config.sts.databaseconfig.DatabaseConfigurationProvider();
            }
            
            if (null != configProvider)
            {
                try
                {
                    configProvider.Load();
                }
                catch (Exception e)
                {
                    throw new XRLException(HResult.XONLINE_E_XSTS_CONFIGURATIONPROVIDER_LOAD, XEvent.Id.XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR, e, "Error calling ISTSConfigurationProvider::Load");
                }
                partners = configProvider.IEBBusinessPartners;
            }

            return partners;
        }
    }

    /// <summary>
    /// Config handler for a section that contains a STSConfiguration Element.  For testing only.
    /// </summary>
    internal class STSConfigurationProvider : ConfigurationSection, ISTSConfigurationProvider
    {
        [ConfigurationProperty("STSConfiguration", IsRequired = true)]
        internal xonline.config.sts.configFileImpl.STSConfiguration STSConfigurationElement
        {
            get
            {
                return this["STSConfiguration"] as xonline.config.sts.configFileImpl.STSConfiguration;
            }
        }

        public ISTSConfiguration STSConfiguration
        {
            get
            {
                return STSConfigurationElement as ISTSConfiguration;
            }
        }

        public void Init(IDictionary<string, string> parameters)
        {
        }

        public void Load()
        {
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:14:03 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\xsts.svc.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

using Microsoft.IdentityModel.Configuration;
using Microsoft.IdentityModel.SecurityTokenService;

using xonline.common.config;
using xonline.common.health;
using xonline.common.exceptions;
using xonline.common.service;

using xonline.config.sts.interfaces;

using xonline.server.kdc;
using xonline.server.xsts.fd.config;
using xonline.server.xsts.provider;

namespace xonline.server.xsts.fd
{

    /// <summary>
    /// A custom SecurityTokenService implementation.
    /// </summary>
    public partial class XSts : SecurityTokenService
    {
        internal class AppliesTosClaimTypesClaimProviders
        {
            internal AppliesTosClaimTypesClaimProviders(
                  IDictionary<Uri,IAppliesTo>       appliesTos
                , List<ClaimProvider>               claimProviders
                , Dictionary<string, ClaimProvider> claimTypeClaimProviders
                , Dictionary<string, string>        clientCertToBusinessPartnerSalt
                )
            {
                AppliesTos = appliesTos;
                ClaimProviders = claimProviders;
                ClaimTypeClaimProviders = claimTypeClaimProviders;
                ClientCertToBusinessPartnerSalt = clientCertToBusinessPartnerSalt;
            }


            public AppliesTosClaimTypesClaimProviders TryAcquire()
            {
                int refCountBefore = this.refcount;
                int refCountAfter = refCountBefore + 1;

                while (0 < refCountBefore)
                {
                    if (refCountBefore == Interlocked.CompareExchange(ref this.refcount, refCountAfter, refCountBefore))
                    {   // Success, refcount updated to refCountAfter
                        return this;
                    }
                    refCountBefore = this.refcount;
                    refCountAfter = refCountBefore + 1;
                }

                // Refcount is 0 object no longer useable
                return null;
            }

            public void Release()
            {
                if (0 == Interlocked.Decrement(ref this.refcount))
                {
                    CloseProviders();
                }
            }

            protected void CloseProviders()
            {
                // spin and catch to clean up all of the claimProviders
                foreach (ClaimProvider claimProvider in ClaimProviders)
                {
                    try
                    {
                        claimProvider.Close();
                    }

                    catch (Exception e)
                    {
                        Logging.NtEvent(XEvent.Id.XSTS_CP_UNLOAD_ERROR, e, "Error closing provider '{0}'", claimProvider.Name);
                    }
                }
                ClaimProviders.Clear();
            }

            internal IDictionary<Uri, IAppliesTo>      AppliesTos;
            internal List<ClaimProvider>               ClaimProviders;
            internal Dictionary<string, ClaimProvider> ClaimTypeClaimProviders;
            internal Dictionary<string, string>        ClientCertToBusinessPartnerSalt;
            private int refcount = 1;
        }

        // a new xsts class is created on every single request
        // so these member variables are  really  per  request

        private Puid                              _xuid;
        private IAppliesTo                        _appliesTo;
        private AppliesTosClaimTypesClaimProviders _atctcpCurrent;

        const string AppliesToCounterNamePrefix = "AppliesTo:";
        const string ValidateRequestCounterFailureName = "_ValidateRequest_ failures";
        private PerfCountersInstance _appliesToPerfCounters = new PerfCountersInstance();
        private PerfCountersInstance _totalPerfCounter = new PerfCountersInstance(true);

        // these are static and persist across multiple requests

        private volatile static AppliesTosClaimTypesClaimProviders _atctcp = new AppliesTosClaimTypesClaimProviders(
            new Dictionary<Uri, IAppliesTo>(), new List<ClaimProvider>(), new Dictionary<string, ClaimProvider>(), new Dictionary<string,string>()
        );

        // static instance of kdc object
        static private Kdc _theKdc = new Kdc();

        static protected bool _serviceInstanceProviderLifetime = true;  // Useful for debugging "starup" : set to false - to run the ServiceHostOpened/Closed for each request as opposed to just once on startup

        /// <summary>
        /// Creates an instance of CustomSecurityTokenService.
        /// </summary>
        /// <param name="configuration">The SecurityTokenServiceConfiguration.</param>
        public XSts(SecurityTokenServiceConfiguration configuration) : base(configuration)
        {
        }

        // do a pretty good job of initializing.  the operations  are
        // idempotent.  so don't worry too much about synchronization

        private static bool _initialized = false;

        private const int ACQUIRERETRYACOUNT = 3;

        internal static AppliesTosClaimTypesClaimProviders TryAcquireATCTCP()
        {
            AppliesTosClaimTypesClaimProviders atctcp = null;

            for (int i = 0; i < ACQUIRERETRYACOUNT && null == atctcp; i++)
            {
                atctcp = _atctcp.TryAcquire();
            }

            return atctcp;
        }
        
        public static readonly object initLockObject = new object();

        public static void Init() 
        {
            if (_initialized) return;
            
            lock (initLockObject)
            {
                if (_initialized) return;

                Config.Assembly = Assembly.GetExecutingAssembly();

                Management.Init();
                Logging.Init();

                // Todo: XSts tracing
                //Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.TraceOutput += (sender, args) =>
                //{
                //    Trace.Normal("XblAuthProtocolModule: {0}", args.Message);
                //};

                Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolModule.AuthenticateError += (sender, args) =>
                {
                    Logging.NtEvent(XEvent.Id.XSTS_MXA_EVENT_AUTHENTICATE_ERROR, args.Exception, "XblAuthProtocolModule AuthenticateError: {0}", new Object[] { args.Exception.Message });
                };

                _initialized = true;
            }
        }

        public static void CheckHealth(HealthReport report)
        {
            AppliesTosClaimTypesClaimProviders atctcp = null;

            try
            {
                atctcp = XSts.TryAcquireATCTCP();

                if (0 == atctcp.ClaimProviders.Count)
                {   // May not have been loaded yet... let's try a load
                    atctcp.Release();
                    LoadStsConfig();
                    atctcp = XSts.TryAcquireATCTCP();
                    LoadKdcConfig();
                }

                if (0 == atctcp.ClaimProviders.Count)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails = "XSts Healthcheck failed: No Claim Providers";
                    return;
                }

                if (0 == atctcp.AppliesTos.Count)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails = "XSts Healthcheck failed: No AppliesToes configured";
                    return;
                }

                foreach (IAppliesTo appliesTo in atctcp.AppliesTos.Values)
                {
                    if (null == appliesTo.AppliesToCertificate)
                    {   // Non-public AppliesToes require certificates
                        if (appliesTo.BusinessPartner.Type.RequiresCert)
                        {
                            report.HealthStatus = HealthStatusEnum.Red;
                            report.ErrorDetails = string.Format("XSts Healthcheck failed: No certificate configured for AppliesTo: '{0}'", appliesTo.AppliesToUri.ToString());
                            return;
                        }
                    }
                }

                // Verify the certificate subject to salt mapping
                Dictionary<string, string> clientCertToBusinessPartnerSalt = new Dictionary<string, string>();

                foreach (IAppliesTo appliesTo in atctcp.AppliesTos.Values)
                {
                    if (null != appliesTo.AppliesToCertificate)
                    {
                        if (!clientCertToBusinessPartnerSalt.ContainsKey(appliesTo.AppliesToCertificate.SubjectName.Name))
                        {
                            clientCertToBusinessPartnerSalt.Add(appliesTo.AppliesToCertificate.SubjectName.Name, appliesTo.BusinessPartner.AnonymizingSalt);
                        }
                        else if (0 != string.Compare(clientCertToBusinessPartnerSalt[appliesTo.AppliesToCertificate.SubjectName.Name], appliesTo.BusinessPartner.AnonymizingSalt, true))
                        {
                            report.HealthStatus = HealthStatusEnum.Yellow;
                            report.ErrorDetails = string.Format("XSts Healthcheck failed: AppliesTo '{0}' certificate subject name {1} is a duplicate", appliesTo.AppliesToUri.ToString(), appliesTo.AppliesToCertificate.SubjectName.Name);
                            return;
                        }
                    }
                }

                // DONT ADD RED REPORTS AFTER THIS LINE OR IT WILL BE MASKED
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
            finally
            {
                if (null != atctcp)
                {
                    atctcp.Release();
                }
            }
        }

        public static void ServiceHostOpened()
        {
            // load configuration.  if that fails then fail startup
            try  
            {
                if (0 == _atctcp.ClaimProviders.Count)
                {
                    LoadStsConfig();
                }
            }
            catch (Exception e)  {
                Logging.NtEvent(XEvent.Id.XSTS_SERVICE_HOST_OPENED_ERROR, e, "Error loading configuration");
            }

            // get a reference to the applies to claim types claim providers
            // so  it doesn't get swapped out beneath us while we process
            AppliesTosClaimTypesClaimProviders atctcp = XSts.TryAcquireATCTCP();

            try
            {
                // if we can't open a particular claim provider, then fail

                List<ClaimProvider> claimProviders = atctcp.ClaimProviders;

                foreach (ClaimProvider claimProvider in claimProviders)
                {
                    try
                    {
                        claimProvider.Open();
                    }
                    catch (Exception e)
                    {
                        Logging.NtEvent(XEvent.Id.XSTS_CP_OPEN_ERROR, e, "Error opening claimProvider {0}", claimProvider.Name);
                    }
                }
            }
            finally
            {
                if (null != atctcp)
                {
                    atctcp.Release();
                }
            }

            LoadKdcConfig();
            PerfCountersInstance.Init();
        }


        public static void ServiceHostClosed()
        {
            try
            {
                PerfCountersInstance.UnInit();

                // get a reference to the applies to claim types claim providers
                // so  it doesn't get swapped out beneath us while we process.
                // Perhaps unnecessary on ServiceHostClosed but it feels safer.

                if (null != _atctcp)
                {
                    _atctcp.Release();  // Final release (unless in use by a current request)
                    _atctcp = null;
                }
            }
            catch (Exception e)
            {
                Logging.NtEvent(XEvent.Id.XSTS_FD_SERVICE_HOST_CLOSED_ERROR, e, "Error in closing service host");
            }
        }


        internal static void LoadKdcConfig()
        {
            Kdc.Load();
        }

        internal static void LoadStsConfig()
        {
            ISTSConfiguration config = XStsConfiguration.GetSTSConfiguration();

            List<ClaimProvider> claimProviders = new List<ClaimProvider>();
            Dictionary<string, ClaimProvider> claimTypeClaimProviders = new Dictionary<string, ClaimProvider>();
            Dictionary<string, string> clientCertToBusinessPartnerSalt = new Dictionary<string, string>();

            // Get the Xbox LIVE Business Partner symmetric key
            IDictionary<string, IIEBBusinessPartner> partners = XStsConfiguration.GetBusinessPartners();
            const string IEBBUSINESSPARTNER_XboxLIVE = "Xbox LIVE";

            IIEBBusinessPartner xboxlivePartner = null;

            if (partners.ContainsKey(IEBBUSINESSPARTNER_XboxLIVE))
            {
                xboxlivePartner = partners[IEBBUSINESSPARTNER_XboxLIVE];
            }

            // for each claim provider, load it, and then associate
            // configured claim types with  loaded  claim  provider

            foreach (IClaimTypeProvider claimProviderConfig in config.ClaimTypeProviders)
            {
                ClaimProvider claimProvider ;
                
                try {
                    claimProvider = new ClaimProvider(claimProviderConfig);
                }
                catch (Exception e) {
                    Logging.NtEvent(
                        XEvent.Id.XSTS_CP_OPEN_ERROR, e, e.Message
                    );

                    continue;
                }

                if (null != xboxlivePartner && 0 < xboxlivePartner.Keys.Count)
                {
                    claimProvider.SetEncryptionKey(xboxlivePartner.Keys[xboxlivePartner.Keys.Count - 1].SymmetricKey, xboxlivePartner.Keys[xboxlivePartner.Keys.Count - 1].SymmetricIV);
                }

                foreach (KeyValuePair<Uri, IClaimType> claimTypeKeyValue in claimProviderConfig.ClaimTypes) {
                    if (! claimTypeClaimProviders.ContainsKey(claimTypeKeyValue.Key.ToString())) 
                        claimTypeClaimProviders.Add(claimTypeKeyValue.Key.ToString(), claimProvider);
                    else {
                        Logging.NtEvent(
                            XEvent.Id.XSTS_CONFIG_CP_DUPLICATE_CLAIM_TYPE,
                            "Claim type '{0}' is already configured", claimTypeKeyValue.Key.ToString()
                        );
                    }
                }

                claimProviders.Add(claimProvider);
            }

            // spin through the relying parties and make sure there
            // are claim providers for all of the configured claims

            Queue<Uri> badAppliesToes = new Queue<Uri>();

            foreach (KeyValuePair<Uri, IAppliesTo> kvpAppliesTo in config.AppliesToes)
            {
                bool isAppliesToValid = true;

                foreach (Uri claimTypeUri in kvpAppliesTo.Value.ClaimTypes.Keys) 
                {
                    ClaimProvider claimProvider;

                    if (claimTypeClaimProviders.TryGetValue(claimTypeUri.ToString(), out claimProvider))
                    {
                        if (!kvpAppliesTo.Value.BusinessPartner.Claims.Contains(claimTypeUri))
                        {
                            isAppliesToValid = false;
                            Logging.NtEvent
                                ( XEvent.Id.XSTS_CONFIG_RP_USE_OF_PRIVATE_CLAIM_TYPE_INVALID
                                , "Applies To '{0}' is configured to use claim type '{1}'. This is not permitted for Business Partner's of type '{2}'."
                                , kvpAppliesTo.Key.ToString()
                                , claimTypeUri.ToString()
                                , kvpAppliesTo.Value.BusinessPartner.Type.Type
                                );
                        }
                    }
                    else
                    {
                        isAppliesToValid = false;
                        Logging.NtEvent(
                            XEvent.Id.XSTS_CONFIG_CP_NO_PROVIDER_FOR_CLAIM_TYPE,
                            "Claim type '{0}' has no claim provider", claimTypeUri.ToString()
                        );
                    }
                }
                if (!isAppliesToValid)
                {
                    badAppliesToes.Enqueue(kvpAppliesTo.Key);
                }
            }

            // Remove the bad ones
            while (0 < badAppliesToes.Count)
            {
                config.AppliesToes.Remove(badAppliesToes.Dequeue());
            }

            // Build the certificate subject to salt mapping
            foreach (KeyValuePair<string, IIEBBusinessPartner> kvpPartner in partners)
            {
                foreach (IIEBPartnerConnectionInfo info in kvpPartner.Value.IEBPartnerConnectionInfoes)
                {
                    if (null != info.SecurityGatewayCertificate)
                    {
                        if (!clientCertToBusinessPartnerSalt.ContainsKey(info.SecurityGatewayCertificate.SubjectName.Name))
                        {
                            clientCertToBusinessPartnerSalt.Add(info.SecurityGatewayCertificate.SubjectName.Name, kvpPartner.Value.AnonymizingSalt);
                        }
                        else if (!string.Equals(clientCertToBusinessPartnerSalt[info.SecurityGatewayCertificate.SubjectName.Name], kvpPartner.Value.AnonymizingSalt))
                        {
                            Logging.NtEvent(
                                XEvent.Id.XSTS_CONFIG_DUPLICATE_BUSINESSPARTNER_CERTIFICATE_SUBJECTNAME,
                                "Business Partner '{0}' certificate subject name {1} is a duplicate", kvpPartner.Value.Name, info.SecurityGatewayCertificate.SubjectName.Name
                            );
                        }
                    }
                }
            }

            // get reference to existing config before swapping new

            // Not using XSts.TryAcquireATCTCP() because we want to do the final release below
            AppliesTosClaimTypesClaimProviders atctcp = _atctcp;

            // we wrap the two dictionarys with a single object  so
            // we can atomically swap the configuration on a reload

            _atctcp = new AppliesTosClaimTypesClaimProviders(
                config.AppliesToes, claimProviders, claimTypeClaimProviders, clientCertToBusinessPartnerSalt
            );

            // if there is an existing config, then unload  all  of
            // the providers (call close() and  unload  app domain)

            if (null != atctcp)
            {
                atctcp.Release();  // Final release (unless in use by a current request)
            }
        }

        internal static string ListAppliesTo(string s)
        {
            string list = null;
            AppliesTosClaimTypesClaimProviders atctcp = XSts.TryAcquireATCTCP();

            try
            {
                list = Management.ListAppliesTo(s, atctcp.AppliesTos);
            }
            finally
            {
                if (null != atctcp)
                {
                    atctcp.Release();
                }
            }

            return list;
        }

        internal static string ListClaimProviders(string s)
        {
            string list = null;
            AppliesTosClaimTypesClaimProviders atctcp = XSts.TryAcquireATCTCP();

            try
            {
                list = Management.ListClaimProviders(s, atctcp.ClaimProviders);
            }
            finally
            {
                if (null != atctcp)
                {
                    atctcp.Release();
                }
            }

            return list;
        }

        internal static string ListTitles(string s)
        {
            uint titleId = 0;

            if (!string.IsNullOrEmpty(s))
            {
                if (!uint.TryParse(s, NumberStyles.HexNumber, null, out titleId))
                {
                    return "Not a valid Title Id, " + s;
                }
            }

            return _theKdc.List(titleId);
        }

        internal static void ReportXblTokenHandlerError(ErrorEventArgs args)
        {
            XRLExceptionWithoutEvent e = args.GetException() as XRLExceptionWithoutEvent;

            if (null != e)
            {
                Logging.NtEvent(XEvent.Id.XSTS_XBLTOKENHANDLER_ERROR, e, "{0}", e.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\xsts.svc.configuration.cs ===
﻿using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.Web.Configuration;

using Microsoft.IdentityModel.Configuration;
using Microsoft.IdentityModel.SecurityTokenService;

using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute(Interface.xsts)]
/// How can WCF support multiple IIS Binding specified per site ?
/// Solution in .Net Fx3.5: BaseAddressPrefixFilters
///  
/// Step1  set the baseAddressPrefix to one of the addresses   
/// <system.serviceModel>
/// <serviceHostingEnvironment>
/// <baseAddressPrefixFilters>
///         <add prefix=”http://payroll.myorg.com:8000”/>       
/// </baseAddressPrefixFilters>
/// </serviceHostingEnvironment>
/// </system.serviceModel>
/// Step 2 Set the endpoints in your web.config file to be absolute URIs
/// <services>
/// <service>
/// <endpoint address="http://payroll.myorg.com:8000/Service1.svc/EP1"  Binding="..." Contract="..." />
/// <endpoint address="http://payroll.myorg.com:9000/Service1.svc/EP12"  Binding="..." Contract="..." />
/// </service>
/// </services>
/// Solution in .Net Fx4.0: BaseAddressPrefixFilters
/// In the final bits, we decided to make it an opt-in due to application compatability reasons. In order to enable multiple site binding, you need to set multipleSiteBindingEnabled to true in your application. Multiple site binding is supported only for Http protocol. The address of endpoints in the configuration file need to be complete URI. When porting your 3.0 or 3.5 workaround to 4.0 you need to keep this particular aspect.
/// <serviceHostingEnvironment multipleSiteBindingsEnabled="true" />  
[assembly: XomIisInstallerAttribute(Interface.xsts_int)]
[assembly: ConfigAttribute(Component.xsts)]

namespace xonline.server.xsts.fd
{
    /// <summary>
    /// A custom SecurityTokenServiceConfiguration implementation.
    /// </summary>
    public class XStsServiceConfiguration : SecurityTokenServiceConfiguration
    {
        protected const string c_SigningCertificateName = "SigningCertificateName";
        protected const string c_IssuerName = "IssuerName";

        /// <summary>
        /// CustomSecurityTokenServiceConfiguration constructor.
        /// </summary>
        public XStsServiceConfiguration()
        {
            this.SecurityTokenService = typeof(XSts);
            // At least under .Net 3.5 need to DisableWsdl to support multiple site bindings!
            // When we move to .Net 4 you may be able to remove this
            this.DisableWsdl = true;

            // Web.config overrides npdb
            // Signing Certificate
            string signingCertificateName = WebConfigurationManager.AppSettings[c_SigningCertificateName];

            if (string.IsNullOrEmpty(signingCertificateName))
            {
                signingCertificateName = Config.GetSetting(Setting.xsts_signing_cert_name);
            }

            // Issuer Name
            string issuerName = WebConfigurationManager.AppSettings[c_IssuerName];

            if (string.IsNullOrEmpty(issuerName))
            {
                issuerName = Config.GetSetting(Setting.xsts_issuer_name);
            }

            this.TokenIssuerName = issuerName;

            // Signing Credentials
            X509Certificate2 cert = CertificateUtil.GetCertificate(StoreName.My, StoreLocation.LocalMachine, signingCertificateName);
            X509SecurityToken token = new X509SecurityToken(cert);
            SecurityKeyIdentifierClause skic = token.CreateKeyIdentifierClause<X509IssuerSerialKeyIdentifierClause>();
            SecurityKeyIdentifier ski = new SecurityKeyIdentifier(skic);

            // Sign with the X509SerialKeyIdentifierClause
            this.SigningCredentials = new X509SigningCredentials(cert, ski);
            // Previously signed with the cert
            //    new X509SigningCredentials(CertificateUtil.GetCertificate(StoreName.My, StoreLocation.LocalMachine, signingCertificateName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\common\IDelegationHandler.cs ===
using System;
using System.Collections.Generic;

namespace xonline.server.xsts.provider
{
    public interface IDelegationHandler
    {
        bool GetTokenProperties(string token, out Dictionary<string, object> properties);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\common\IClaimProvider.cs ===
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

namespace xonline.server.xsts.provider
{
    public interface IClaimProvider
    {
        void Open();

        void Close();

        HashSet<string> ClaimTypes {
            get;
        }

        IClaimsIdentity GetOutputClaimsIdentity(
            HashSet<string> claimTypes,
            IClaimsPrincipal principal,
            RequestSecurityToken request,
            Scope scope
        );

        IDelegationHandler GetDelegationTokenHandler(
            string claimType
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\common\ClaimProviderBase.cs ===
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

namespace xonline.server.xsts.provider
{
    public abstract class ClaimProviderBase : IClaimProvider
    {
        public virtual void Open() { }

        public virtual void Close() { }

        public virtual HashSet<string> ClaimTypes {
            get { return new HashSet<string>(); }
        }

        public abstract IClaimsIdentity GetOutputClaimsIdentity(
            HashSet<string> claimTypes,
            IClaimsPrincipal principal,
            RequestSecurityToken request,
            Scope scope
        );

        public virtual IDelegationHandler GetDelegationTokenHandler(
            string claimType
        )
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\fd\XClaimsPrincipal.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Xml.Linq;

using Microsoft.IdentityModel.Claims;

using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.service;

using xonline.server.kdc;

namespace xonline.server.xsts.fd
{
    public class XClaimsPrincipal : ClaimsPrincipal
    {
        public XClaimsPrincipal Current
        {
            get
            {
                return HttpContextAdapter.Current.Items["Principal"] as XClaimsPrincipal;
            }
            set
            {
                HttpContextAdapter.Current.Items["Principal"] = value;
            }
        }

        public XClaimsPrincipal()
            : base()
        {
        }

        public XClaimsPrincipal(ClaimsIdentityCollection claimsIdentities)
            : base(claimsIdentities)
        {
            this.CreateUserClaims();
        }

        public XClaimsPrincipal(IEnumerable<IClaimsIdentity> identities)
            : base(identities)
        {
            this.CreateUserClaims();
        }


        public XClaimsPrincipal(SGInfo sgInfo, Puid xuid)
            : base(CreateClaims(sgInfo, xuid))
        {
            this.CreateUserClaims();
        }

        public XClaimsPrincipal(IClaimsPrincipal principal)
            : base(principal.Identities)
        {
            this.CreateUserClaims();
        }

        public string GetCompactToken()
        {
            return Serialize(this);
        }

        public IEnumerable<Claim> AllClaims()
        {
            foreach (var identity in Identities)
            {
                foreach (var claim in identity.Claims)
                {
                    yield return claim;
                }
            }
        }

        public IEnumerable<Claim> AllClaims(string claimType)
        {
            return AllClaims().Where(c => c.ClaimType == claimType);
        }

        public Claim GetClaim(string claimType)
        {
            return AllClaims().Where(c => c.ClaimType == claimType).SingleOrDefault();
        }

        public bool HasClaim(string claimType)
        {
            return AllClaims().Any(c =>
                c.ClaimType == claimType);
        }

        public bool HasClaimValue(string claimType, object claimValue)
        {
            string claimValueComparison = claimValue == null ? null : claimValue.ToString();
            return AllClaims().Any(c =>
                c.ClaimType == claimType &&
                c.Value == claimValueComparison);
        }

        /// <summary>
        /// Guarantee, when possible, that the principal has both a xuid and puid claim
        /// </summary>
        public void CreateUserClaims()
        {
            ulong puid = 0; // Passport Puid
            ulong xuid = 0; // UserPuid

            string puidValue;
            string xuidValue;

            this.TryGetClaimValue(AuthClaimTypes.Puid, out puidValue);
            this.TryGetClaimValue(AuthClaimTypes.Xuid, out xuidValue);

            if (!string.IsNullOrEmpty(puidValue))
            {
                ulong.TryParse(puidValue, out puid);
            }
            if (!string.IsNullOrEmpty(xuidValue))
            {
                ulong.TryParse(xuidValue, out xuid);
            }

            if (0 == xuid && 0 != puid)
            {   // Have the passport Id need the user Id
                XCacheUserResponseData user = XCache.LookupUserByPassport(puid);
                if (0 != user.qwUserID)
                {
                    xuid = user.qwUserID;
                }
                else
                {   // Let's try the KdcManagedProxy
                    try
                    {
                        xuid = KdcUtil.GetUserPuidFromPassportPuid(puid);
                    }
                    catch (COMException comEx)
                    {
                        if (HResult.XONLINE_E_ACCOUNTS_INVALID_USER == XblException.GetHResult(comEx))
                        {
                            throw new XblException(HResult.XONLINE_E_ACCOUNTS_INVALID_USER, comEx, "Invalid passport user");
                        }
                        throw;
                    }
                    catch (xonline.kdc.ManagedProxy.PartitionTooBusyException e)
                    {
                        throw new XblException(XblException.GetHResult(e), e, e.Message);
                    }
                }

                if (0 != xuid)
                {   // Found it, add the claim
                    this.Identities[0].Claims.Add(new Claim
                        ( AuthClaimTypes.Xuid
                        , xuid.ToString()
                        , AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid]
                        ));
                }
            }
            if (0 == puid && 0 != xuid)
            {   // Have the user Id need the passport Id
                XCacheUserResponseData user = XCache.LookupUserByXUID(xuid);
                if (0 != user.qwPassportPUID)
                {
                    puid = user.qwPassportPUID;

                    this.Identities[0].Claims.Add(new Claim
                        ( AuthClaimTypes.Puid
                        , puid.ToString()
                        , AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid]
                        ));
                }
                // else No KdcManagedProxy option here, AAInfo does without it so hopefully we can as well?
            }
        }

        public static XClaimsPrincipal CreateFromXblContext(HttpContextAdapter ctx)
        {
            return CreateFromXblContext(ctx, 0);
        }

        public static XClaimsPrincipal CreateFromXblContext(HttpContextAdapter ctx, Puid xuid)
        {
            XClaimsPrincipal principal = null;

            if (ctx != null && SGInfo.IsAvailable)
            {
                principal = new XClaimsPrincipal(SGInfo.Current, xuid);
            }

            return principal;
        }

        public static IClaimsPrincipal Deserialize(string compactToken)
        {
            XElement root = XElement.Parse(compactToken);
            if (root.Name != "XClaimsPrincipal")
                return null;
            XClaimsPrincipal principal = new XClaimsPrincipal();
            foreach (var identEl in root.Elements("identity"))
            {
                ClaimsIdentity ident = new ClaimsIdentity();
                foreach (var claimEl in identEl.Elements("claim"))
                {
                    Claim claim = new Claim(
                        (string)claimEl.Attribute("type"),
                        claimEl.Value,
                        (string)claimEl.Attribute("valuetype"));
                    ident.Claims.Add(claim);
                }
                principal.Identities.Add(ident);
            }

            return principal;
        }

        public static string Serialize(IClaimsPrincipal principal)
        {
            XElement root = new XElement(
                "XClaimsPrincipal",
                principal.Identities.Select(ident => new XElement(
                    "identity",
                    ident.Claims.Select(claim => new XElement(
                        "claim",
                        new XAttribute("type", claim.ClaimType),
                        new XAttribute("valuetype", claim.ValueType),
                        claim.Value)
                        )
                    )
                )
            );

            return root.ToString(SaveOptions.DisableFormatting);
        }

        private static IEnumerable<IClaimsIdentity> CreateClaims(SGInfo sginfo, Puid xuid)
        {
            List<IClaimsIdentity> identities = new List<IClaimsIdentity>();

            // ??? 1 identity per user plus a machine identity? Just a single identity for all?
            // But then how to represent users?

            for (int i = 0; i < sginfo.LogonUsers.Length; i++)
            {
                XUIDAndTrust xuidTrust = sginfo.LogonUsers[sginfo.LogonUsers.Length - i - 1];
                if (
                   (0 != xuidTrust.qwUserID && !xuidTrust.IsGuest()) &&
                   (0 == xuid || xuid == xuidTrust.qwUserID)  // Non zero xuid means we only want that one user
                   )
                {
                    ClaimsIdentity userIdentity = new ClaimsIdentity(
                        "sginfouser",
                        AuthClaimTypes.Xuid,  // name claim type
                        null);
                    identities.Add(userIdentity);

                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Xuid,
                        xuidTrust.qwUserID.ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid]
                        ));
                    // 0,3,6 or None,Silver,Gold?
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Tier,
                        XOn.UserTierToString(xuidTrust.UserTier()),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Tier]));
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Country,
                        xuidTrust.UserCountry().ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Country]));
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Language,
                        xuidTrust.UserLanguage().ToString(),
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Language]));

                    byte[] privileges = sginfo.GetUserPrivileges(xuidTrust.qwUserID);
                    string privilegeString = privileges.Aggregate(
                        new StringBuilder(),
                        (sb, p) => sb.Append(p + " "),
                        sb => sb.Length == 0 ? String.Empty : sb.ToString(0, sb.Length - 1));
                    userIdentity.Claims.Add(new Claim(AuthClaimTypes.Privileges,
                        privilegeString,
                        AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges]));
                }
            }

            ClaimsIdentity machineIdentity = new ClaimsIdentity(
                "sginfomachine",
                AuthClaimTypes.DeviceId,  // name claim type
                null);
            identities.Add(machineIdentity);

            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceId,
                sginfo.MachineId.ToString("X"),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId]));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.DeviceType,
                GetDeviceTypeString(sginfo.GetPlatformType()),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceType]));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.ClientIpPort,
                sginfo.ClientIP.ToString() + ":" + sginfo.ClientPort,
                AuthClaimTypes.ValueTypes[AuthClaimTypes.ClientIpPort]));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.FlowToken,
                sginfo.FlowToken.FlowToken.ToString("X"),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.FlowToken]));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.TitleId,
                sginfo.TitleId.ToString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId]));
            machineIdentity.Claims.Add(new Claim(AuthClaimTypes.TitleVersion,
                sginfo.TitleVersion.ToString(),
                AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleVersion]));

            IPEndPoint endpoint = HttpContextAdapter.Current.Request.RemoteEP;

            machineIdentity.Claims.Add(new Claim(XStsClaimTypes.ServerIpPort,
                endpoint.Address.ToString() + ":" + endpoint.Port,
                AuthClaimValueTypes.IpAddress));

            return identities;
        }

        protected static string GetDeviceTypeString(byte deviceType)
        {
            string deviceTypeStr;
            
            switch (deviceType)
            {
                case XOn.XPLT_XBOX360:
                    deviceTypeStr = AuthDeviceTypes.Xbox360;
                    break;

                case XOn.XPLT_PC:
                    deviceTypeStr = AuthDeviceTypes.PC;
                    break;

                case XOn.XPLT_MOBILE:
                    deviceTypeStr = AuthDeviceTypes.WindowsPhone7;
                    break;

                case XOn.XPLT_WEB:
                default:
                    deviceTypeStr = AuthDeviceTypes.Web;
                    break;
            }

            return deviceTypeStr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\common\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:14:01 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\TestClaimProviders\FailOnRequestClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.XboxLive.Auth.Claims;

using xonline.server.xsts.provider;

namespace xonline.server.XSts.TestClaimProviders
{
    public class FailOnRequestClaimProvider : ClaimProviderBase
    {
        private static HashSet<string> _claimTypes = new HashSet<string>();

        static FailOnRequestClaimProvider()
        {
            _claimTypes.Add("http://schemas.microsoft.com/test/failonrequestclaimprovider/failonrequestclaim");
        }
        
        public override HashSet<string> ClaimTypes {
            get { return _claimTypes; }
        }

        public override IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            throw new Exception("FailOnRequestClaimProvider failed as expected when getting ClaimsIdentity");
        }

        public override IDelegationHandler GetDelegationTokenHandler(string claimType)
        {
            throw new Exception("FailOnRequestClaimProvider failed as expected when getting delegation token handler");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\TestClaimProviders\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:14:02 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\DelegationToken.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;

namespace xonline.server.XSts.XClaimProvider
{
    internal class DelegationToken
    {
        public DelegationToken(Puid userId)
        {
            _userId = userId;
            _dateIssued = DateTime.UtcNow;
            _version = c_Version;
        }

        public DelegationToken(string token)
        {
            InitializeFromToken(token);
        }

        public DelegationToken(byte[] ASCIIEncodedToken)
        {
            InitializeFromToken(ASCIIEncoding.ASCII.GetString(ASCIIEncodedToken));
        }

        //////////////////////////////////////
        // Attributes
        //////////////////////////////////////

        Puid _userId;           // UserPuid
        DateTime _dateIssued;   // DateTime token was issued
        string _version;        // Version

        private const string c_Version = "1";
        private const string c_TokenPrefix = "<dtoken ";

        public Puid UserId
        {
            get { return _userId; }
        }

        public DateTime DateIssued
        {
            get { return _dateIssued; }
        }

        //////////////////////////////////////
        // Implementation
        //////////////////////////////////////

        public static implicit operator byte[](DelegationToken dtoken)
        {
            return ASCIIEncoding.ASCII.GetBytes(dtoken.ToString());
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("<dtoken v={0} d=\"{1}\" x={2}/>", _version, _dateIssued.ToString(), _userId.ToString());

            return sb.ToString();
        }        

        private void InitializeFromToken(string token)
        {
            int index = token.IndexOf(c_TokenPrefix);

            if (-1 == index)
            {
                throw new XblException(HResult.XONLINE_E_XCLAIMPROVIDER_DELEGATIONTOKEN_INVALID, "Invalid Delegation Token");
            }

            // version
            index = token.IndexOf("v=");
            _version = token.Substring(index + 2, 1);

            if (c_Version != _version)
            {
                throw new XblException(HResult.XONLINE_E_XCLAIMPROVIDER_DELEGATIONTOKEN_VERSION_INVALID, "Invalid Delegation Token version");
            }

            // Date Issued
            index = token.IndexOf("d=\"");
            int indexend = token.IndexOf("\"", index+3);
            string dt = token.Substring(index + 3, indexend - index - 3);
            _dateIssued = DateTime.Parse(dt);

            // User id
            index = token.IndexOf("x=");
            _userId = Puid.Parse(token.Substring(index + 2, 18));
       }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\TestClaimProviders\FailOnLoadClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.XboxLive.Auth.Claims;

using xonline.server.xsts.provider;

namespace xonline.server.XSts.TestClaimProviders
{
    public class FailOnLoadClaimProvider : ClaimProviderBase
    {
        private static HashSet<string> _claimTypes = new HashSet<string>();

        static FailOnLoadClaimProvider()
        {
            _claimTypes.Add("http://schemas.microsoft.com/test/failonloadclaimprovider/failonloadclaim");

            throw new Exception("FailOnLoadClaimProvided fails as expected when loading");
        }
        
        public override HashSet<string> ClaimTypes {
            get { return _claimTypes; }
        }

        public override IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\DBHelper.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.IO;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Net;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.XSts.XClaimProvider
{
    public class DBHelper
    {
        public class XUser
        {
            // Constructor
            public XUser(ulong xuid)
            {
                this.Xuid = xuid;
            }

            // Attributes
            public bool AcceptedTermsOfService { get; private set; }
            public DateTime AcceptedTOSDate { get; private set; }
            public DateTime AccountResumeDate { get; private set; }
            public DateTime Birthdate { get; private set; }
            public byte Country { get; private set; }
            public string Gamertag { get; private set; }
            public int Language { get; private set; }
            public ulong OwnerPassportPuid { get; private set; }
            public ulong PassportPuid { get; private set; }
            public ulong Xuid { get; private set; }

            public bool IsSuspended { get { return this.AccountResumeDate > DateTime.UtcNow; } }

            //Implementation
            public static XUser GetUser(ulong puid)
            {
                WstConnection conn = null;
                WstCommand cmd = null;
                WstDataReader wstReader = null;
                IVirtualInterfaceInfo uodbInfo = Config.GetVirtualInterface(VirtualInterface.uodb, 1);

                XUser user = null;

                try
                {
                    // Open a connection
                    conn = new WstConnection(uodbInfo.WebstoreApp);
                    conn.Open();

                    // Create a command to call the stored procedure
                    cmd = conn.CreateCommand();
                    cmd.CommandTimeout = uodbInfo.Timeout;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "dbo.p_xuser_user_get";

                    cmd.PartitionType = WstPartitionType.Logical;
                    cmd.Partition = WSClient.GetHashPartition(puid, uodbInfo.WebstoreApp);

                    // add the params
                    cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = puid;

                    // Execute stored procedure
                    wstReader = cmd.ExecuteReader();

                    // read the first row only.
                    if (wstReader.Read())
                    {
                        user = new XUser(puid);

                        // read the row.
                        user.OwnerPassportPuid = WSClient.GetUInt64(wstReader, "bi_owner_passport_puid");
                        user.PassportPuid = WSClient.GetUInt64(wstReader, "bi_user_passport_puid");
                        user.Gamertag = WSClient.GetString(wstReader, "vc_gamertag");
                        user.Birthdate = WSClient.GetDateTime(wstReader, "dt_birthdate");
                        user.Country = WSClient.GetByte(wstReader, "ti_country_id");
                        user.Language = WSClient.GetInt32(wstReader, "i_language_id");
                        user.AccountResumeDate = WSClient.GetDateTime(wstReader, "dt_acct_resume_date");
                        user.AcceptedTOSDate = WSClient.GetDateTime(wstReader, "dt_accepted_tos");
                        user.AcceptedTermsOfService = (1 == WSClient.GetInt32(wstReader, "i_accepted_tos"));
                    }
                }
                catch (Exception e)
                {
                    throw new XRLException
                        ( HResult.XONLINE_E_XCLAIMPROVIDER_GETUSER_FAILURE
                        , XEvent.Id.WEBCACHE_COMM_1
                        , e
                        , "Error calling Uodb (p_xuser_user_get)."
                        );
                }
                finally
                {
                    if (conn != null)
                    {
                        conn.Close();
                        conn = null;
                    }
                    if (wstReader != null)
                    {
                        wstReader.Close();
                        wstReader = null;
                    }
                }

                return user;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\objd\amd64\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("11.8.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("11.8.31.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:14:02 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\TestClaimProviders\GoodClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.XboxLive.Auth.Claims;

using xonline.server.xsts.provider;

namespace xonline.server.XSts.TestClaimProviders
{
    public class GoodClaimProvider : ClaimProviderBase
    {
        private static readonly String TestClaimOne = "http://schemas.microsoft.com/test/goodclaimprovider/testclaimone";
        private static readonly String TestClaimTwo = "http://schemas.microsoft.com/test/goodclaimprovider/testclaimtwo";
        private static HashSet<string> _claimTypes = new HashSet<string>();

        static GoodClaimProvider()
        {
            _claimTypes.Add(TestClaimOne);
            _claimTypes.Add(TestClaimTwo);
        }
        
        public override HashSet<string> ClaimTypes {
            get { return _claimTypes; }
        }

        public override IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            ClaimsIdentity outputIdentity = new ClaimsIdentity();
            outputIdentity.Claims.Add(new Claim(TestClaimOne, "TestClaimOneValue", Microsoft.IdentityModel.Claims.ClaimValueTypes.String));
            outputIdentity.Claims.Add(new Claim(TestClaimTwo, "TestClaimTwoValue", Microsoft.IdentityModel.Claims.ClaimValueTypes.String));

            return outputIdentity;
        }

        public override IDelegationHandler GetDelegationTokenHandler(string claimType)
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\XClaimProvider.cs ===
﻿using System;
using System.Collections.Generic;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.XboxLive.Auth.Claims;

using xonline.server.xsts.provider;

namespace xonline.server.XSts.XClaimProvider
{
    public class XClaimProvider : ClaimProviderBase
    {
        private static HashSet<string> _claimTypes = new HashSet<string>();
        private DelegationTokenHandler _delegationTokenHandler = new DelegationTokenHandler();
        public const string TitleComponent = "http://schemas.microsoft.com/xbox/2011/07/claims/title/component";

        static XClaimProvider()
        {
            _claimTypes.Add(AuthClaimTypes.AgeGroup);
            _claimTypes.Add(AuthClaimTypes.ClientIpPort);
            _claimTypes.Add(AuthClaimTypes.Country);
            _claimTypes.Add(AuthClaimTypes.DelegationToken);
            _claimTypes.Add(AuthClaimTypes.DeviceId);
            _claimTypes.Add(AuthClaimTypes.DeviceName);
            _claimTypes.Add(AuthClaimTypes.DeviceType);
            _claimTypes.Add(AuthClaimTypes.FlowToken);
            _claimTypes.Add(AuthClaimTypes.Gamertag);
            _claimTypes.Add(AuthClaimTypes.Language);
            _claimTypes.Add(AuthClaimTypes.ParentXuid);
            _claimTypes.Add(AuthClaimTypes.PartnerDeviceId);
            _claimTypes.Add(AuthClaimTypes.PartnerParentXuid);
            _claimTypes.Add(AuthClaimTypes.PartnerXuid);
            _claimTypes.Add(AuthClaimTypes.Privileges);
            _claimTypes.Add(AuthClaimTypes.Puid);
            _claimTypes.Add(AuthClaimTypes.Tier);
            _claimTypes.Add(AuthClaimTypes.TitleId);
            _claimTypes.Add(AuthClaimTypes.Status);
            _claimTypes.Add(AuthClaimTypes.TitleVersion);
            _claimTypes.Add(AuthClaimTypes.Xuid);
            _claimTypes.Add(TitleComponent);
        }
        
        //////////////////////////////////////
        // Attributes
        //////////////////////////////////////

        public override HashSet<string> ClaimTypes {
            get { return _claimTypes; }
        }

        //////////////////////////////////////
        // Implementation
        //////////////////////////////////////

        public override IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
        {
            XClaimProviderRequest requestHandler = new XClaimProviderRequest();
            IClaimsIdentity outputIdentity = requestHandler.GetOutputClaimsIdentity(claimTypes, principal);

            ICollection<Claim> claims = outputIdentity.Claims.FindAll(new Predicate<Claim>(c => c.ClaimType == AuthClaimTypes.Gamertag));

            if (0 != claims.Count)
            {
                outputIdentity.NameClaimType = AuthClaimTypes.Gamertag;
            }

            return outputIdentity;
        }

        public override IDelegationHandler GetDelegationTokenHandler(string claimType)
        {
            if (string.Equals(AuthClaimTypes.DelegationToken, claimType))
            {
                return (IDelegationHandler)this._delegationTokenHandler;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\DelegationTokenHandler.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.common.utilities2;
using xonline.server.xsts.provider;

namespace xonline.server.XSts.XClaimProvider
{
    internal class DelegationTokenHandler : IDelegationHandler
    {
        public DelegationTokenHandler()
        {
        }

        //////////////////////////////////////
        // Attributes
        //////////////////////////////////////

        //////////////////////////////////////
        // Implementation
        //////////////////////////////////////

        public virtual bool GetTokenProperties(string token, out Dictionary<string, object> properties)
        {
            DelegationToken dtoken = new DelegationToken(Blob.Parse(token));
            properties = new Dictionary<string, object>();

            properties.Add("xuid", dtoken.UserId);
            properties.Add("dateIssued", dtoken.DateIssued);

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\CodeService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for AuthHelper"), AsyncGroup(0, 4)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    public class Code: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        //note that these tests are written with the assumption that the service will always generate the cononical form, while we accept both the cononical and the lexical form of claim values.

        //expected is either true, false, or the name of the exception type to expect.  got is the formated string returned from CallVerifyOperator.
        public static void VerifyResult(string expected, string got)
        {
            string []gotParts=got.Split(new char[]{'|'});
            if (gotParts.Length==0)
            {
                throw new UnexpectedTestResultException("Invalid return value from TestFdXsts: "+got);
            }

            if (gotParts[0].ToLower()!=expected.ToLower())
            {
                throw new UnexpectedTestResultException("Expected return result to be "+expected+", but got "+gotParts[0]+"\nFull return value: "+got);
            }
        }

        public class FindClaimResult
        {
            public string Result;
            public string ClaimType;
            public string Issuer;
            public string OriginalIssuer;
            // TODO: Properties
            public string Value;
            public string ValueType;
        };

        public static FindClaimResult ParseFindClaimResult(string serializedResult)
        {
            string []parts=serializedResult.Split(new char[]{'|'});
            if (parts.Length<1)
            {
                throw new UnexpectedTestResultException("Response cannot be parsed.");
            }

            FindClaimResult ret=new FindClaimResult();
            ret.Result=parts[0];

            if (ret.Result=="true" && parts.Length>=6)
            {
                ret.ClaimType=GetStringRightOfEquals(parts[1]);
                ret.Issuer=GetStringRightOfEquals(parts[2]);
                ret.OriginalIssuer=GetStringRightOfEquals(parts[3]);
                //ret.Properties=TODO(parts[4]);
                ret.Value=GetStringRightOfEquals(parts[5]);
                ret.ValueType=GetStringRightOfEquals(parts[6]);
            }

            return ret;
        }

        public static string GetStringRightOfEquals(string s)
        {
            int ind=s.IndexOf("=");
            if (ind==-1)
            {
                throw new UnexpectedTestResultException("Cannot parse value.");
            }

            return s.Substring(ind+1);
        }

        // --

        [TestGroup, Description("Tests for AuthHelper.VerifyExists")]
        public class Exists: TestNode
        {
            [TestCase, Description("No claim is present.  We expect tiger to exist.")]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallVerifyOperator("exists", "http://example.com/tiger", null, null);
                VerifyResult("false", ret);
            }

            [TestCase, Description("The lion claim is present, but tiger is not.  We expect tiger to exist.")]
            public void OtherExists()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", ""); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("exists", "http://example.com/tiger", null, null);
                VerifyResult("false", ret);
            }

            [TestCase, Description("The tiger claim is present.  We expect tiger to exist.")]
            public void TigerExists()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", ""); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("exists", "http://example.com/tiger", null, null);
                VerifyResult("true", ret);
            }
        }; //class Exists

        [TestGroup, Description("Tests for AuthHelper.VerifyEquals")]
        public class Equal: TestNode
        {
            [TestCase, Description("Ask when no token of that type is provided.")]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallVerifyOperator("equals", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Ask when no claim of that type is provided.")]
            public void NoClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/somethingunrelated", "7", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Claim is a string type.")]
            [CompoundCase("DifferentShorter",     "SimpleString",  "SimpleStrin",   "false")]
            [CompoundCase("DifferentLonger",      "SimpleString",  "SimpleStrings", "false")]
            [CompoundCase("SameCase",             "Simple String", "Simple String", "true")]
            [CompoundCase("DifferentCase",        "SimpleString",  "simplestring",  "false")]
            [CompoundCase("ClaimNormalPassEmpty", "SimpleString",  "",              "false")]
            [CompoundCase("ClaimNormalPassNull",  "SimpleString",  null,            "false")]
            [CompoundCase("ClaimEmptyPassNormal", "",              "SimpleString",  "false")]
            [CompoundCase("ClaimEmptyPassEmpty",  "",              "",              "true")]
            [CompoundCase("ClaimEmptyPassNull",   "",              null,            "false")]
            [CompoundCase("ExtraSpacesInClaim",   " Hello ",       "Hello",         "false")]
            [CompoundCase("PassExtraSpaces",      "Hello",         " Hello ",       "false")]
            public void ClaimString(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/stringtest", claimValue, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/stringtest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is an integer type.")]
            [CompoundCase("ClaimPositivePassVeryPositive", "12345678901234567890123456789", "1234567890123456789012345678901234567890", "System.FormatException")]
            [CompoundCase("ClaimVeryPositivePassVeryPositive", "1234567890123456789012345678901234567890", "1234567890123456789012345678901234567890", "Microsoft.XboxLive.Auth.InvalidClaimException")]
            [CompoundCase("ClaimNegativePassVeryNegative", "-12345678901234567890123456789", "-1234567890123456789012345678901234567890", "System.FormatException")]
            [CompoundCase("ClaimVeryNegativePassVeryNegative", "-1234567890123456789012345678901234567890", "-1234567890123456789012345678901234567890", "Microsoft.XboxLive.Auth.InvalidClaimException")]
            [CompoundCase("MinimallyLargePositiveInteger", "999999999999999999", "999999999999999999", "true")]
            [CompoundCase("MinimallyLargeNegativeInteger", "-999999999999999999",                       "-999999999999999999",                       "true")]
            [CompoundCase("SameSmallInteger",              "7",                                         "7",                                         "true")]
            [CompoundCase("SameZeroInteger",               "0",                                         "0",                                         "true")]
            [CompoundCase("SameZeroIntegerDifferentSign",  "-0",                                        "+0",                                        "true")]
            [CompoundCase("SameIntegerLeadingZeros",       "7",                                         "007",                                       "true")]
            [CompoundCase("DifferentInteger",              "7",                                         "-7",                                        "false")]
            [CompoundCase("ClaimNormalPassEmpty",          "0",                                         "",                                          "System.FormatException")]
            [CompoundCase("ClaimNormalPassNull",           "0",                                         null,                                        "System.FormatException")]
            [CompoundCase("PassInvalidInteger",            "7",                                         "7.",                                        "System.FormatException")]
            public void ClaimInteger(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integertest", claimValue, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/integertest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a boolean type.")]
            [CompoundCase("SameLowerFalse",              "false", "false", "true")]
            [CompoundCase("SameLowerTrue",               "true",  "true",  "true")]
            [CompoundCase("SameNumberFalse",             "false", "0",     "true")]
            [CompoundCase("SameNumberTrue",              "true",  "1",     "true")]
            [CompoundCase("DifferentLowerPassTrue",      "false", "true",  "false")]
            [CompoundCase("DifferentLowerPassFalse",     "true",  "false", "false")]
            [CompoundCase("DifferentLowerPass1",         "false", "1",     "false")]
            [CompoundCase("DifferentLowerPass0",         "true",  "0",     "false")]
            [CompoundCase("InvalidBoolTextClaimTrue",    "true",  "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolTextClaimFalse",   "false", "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolTextUpperTrue",    "true",  "TRUE",  "true")] //TRUE is not in the set of valid values, but we are more lenient with case
            [CompoundCase("InvalidBoolNumberClaimTrue",  "true",  "2",     "System.FormatException")]
            [CompoundCase("InvalidBoolNumberClaimFalse", "false", "-0",    "System.FormatException")]
            [CompoundCase("PassEmptyClaimTrue",          "true",  "",      "System.FormatException")]
            [CompoundCase("PassEmptyClaimFalse",         "false", "",      "System.FormatException")]
            [CompoundCase("PassNullClaimTrue",           "true",  null,    "System.FormatException")]
            [CompoundCase("PassNullClaimFalse",          "false", null,    "System.FormatException")]
            public void ClaimBoolean(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/booleantest", claimValue, ClaimValueTypes.Boolean);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/booleantest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Base64Binary type.")]
            [CompoundCase("ZeroByteSame",         new byte[0],                        new byte[0],                        "true")]
            [CompoundCase("ZeroByteClaimPassOne", new byte[0],                        new byte[]{0x00},                   "false")]
            [CompoundCase("OneByteClaimPassTwo",  new byte[]{0xff},                   new byte[]{0xff, 0xff},             "false")]
            [CompoundCase("OneByteSame",          new byte[]{0x07},                   new byte[]{0x07},                   "true")]
            [CompoundCase("TwoByteSame",          new byte[]{0x13, 0x37},             new byte[]{0x13, 0x37},             "true")]
            [CompoundCase("ThreeByteSame",        new byte[]{0x00, 0x7f, 0xff},       new byte[]{0x00, 0x7f, 0xff},       "true")]
            [CompoundCase("FourByteSame",         new byte[]{0xff, 0x13, 0x37, 0x00}, new byte[]{0xff, 0x13, 0x37, 0x00}, "true")]
            [CompoundCase("OneByteDifferent",     new byte[]{0x07},                   new byte[]{0xf7},                   "false")]
            [CompoundCase("TwoByteDifferent",     new byte[]{0x13, 0x37},             new byte[]{0x03, 0x37},             "false")]
            [CompoundCase("ThreeByteDifferent",   new byte[]{0x00, 0x7f, 0xff},       new byte[]{0x01, 0x7f, 0xff},       "false")]
            [CompoundCase("FourByteDifferent",    new byte[]{0xff, 0x13, 0x37, 0x00}, new byte[]{0x00, 0x13, 0x37, 0x00}, "false")]
            [CompoundCase("PassNull",             new byte[]{0x00},                   null,                               "false")] // null is allowed for reference types
            [CompoundCase("PassInvalid", new byte[] { 0x00 }, "*~woops~*", "System.FormatException")]
            public void ClaimBase64Binary(TestNode self)
            {
                string claimValue;
                string passValue;
                string expect=(string)self.MyValues[2];

                if (self.MyValues[0]==null)
                {
                    claimValue=null;
                }
                else if (self.MyValues[0] is byte[])
                {
                    claimValue=System.Convert.ToBase64String((byte[])self.MyValues[0]);
                }
                else
                {
                    claimValue=(string)self.MyValues[0];
                }

                if (self.MyValues[1]==null)
                {
                    passValue=null;
                }
                else if (self.MyValues[1] is byte[])
                {
                    passValue=System.Convert.ToBase64String((byte[])self.MyValues[1]);
                }
                else
                {
                    passValue=(string)self.MyValues[1];
                }

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/base64binarytest", claimValue, ClaimValueTypes.Base64Binary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/base64binarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a HexBinary type.")]
            [CompoundCase("ZeroByteSame",         "",                                                               "",                                                               "true")]
            [CompoundCase("ZeroByteClaimPassOne", "",                                                               "FF",                                                             "false")]
            [CompoundCase("OneByteSame",          "0A",                                                             "0A",                                                             "true")]
            [CompoundCase("OneBytePassLowerSame", "0A",                                                             "0a",                                                             "true")]
            [CompoundCase("OneByteDifferent",     "FF",                                                             "00",                                                             "false")]
            [CompoundCase("ManyByteSame",         "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "true")]
            [CompoundCase("ManyByteDifferent",    "F102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEF0", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("PassShorter",          "000102030405060708090A0B0C0D0E0F",                               "0102030405060708090A0B0C0D0E0F",                                 "false")]
            [CompoundCase("PassLonger",           "000102030405060708090A0B0C0D0E0F",                               "000102030405060708090A0B0C0D0E0F00",                             "false")]
            [CompoundCase("PassEmpty",            "FF0000DD",                                                       "",                                                               "false")]
            [CompoundCase("PassNull",             "FF0000DD",                                                       null,                                                             "false")] // null is allowed for reference types
            [CompoundCase("PassInvalidChars",     "FF0000DD",                                                       "0wtf",                                                           "System.FormatException")]
            [CompoundCase("PassInvalidLength",    "000",                                                            "0",                                                              "false")] // All hex binary is extended to the nearest byte so these end up different
            [CompoundCase("PassEquivelentLength", "00",                                                             "0",                                                              "true")] // All hex binary is extended to the nearest byte so these end up the same
            [CompoundCase("PassInvalidPrefix",    "FF0000DD",                                                       "0xFF0000DD",                                                     "true")] // The canonical representation is emitted (no leading 0x) so these end up being the same
            public void ClaimHexBinary(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/hexbinarytest", claimValue, ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/hexbinarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a DateTime type.")]
            [CompoundCase("SameDateUtcZone",             "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.78Z",      "true")]
            [CompoundCase("DifferentDateUtcZone",        "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.79Z",      "false")]
            [CompoundCase("SameEarlyDateUtcZone",        "0001-01-23T23:45:56.78Z",  "0001-01-23T23:45:56.78Z",      "true")] // we are constrained to valid dates for Date.Parse
            [CompoundCase("SameFutureDateUtcZone",       "9234-01-23T23:45:56.78Z",  "9234-01-23T23:45:56.78Z",      "true")] // we are constrained to valid dates for Date.Parse
            [CompoundCase("SameDateDifferentZones",      "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.78+01:00", "true")]
            [CompoundCase("DifferentDateDifferentZones", "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.79+01:00", "false")]
            [CompoundCase("SameDateNoZone",              "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.78",       "false", BugID=76462, BugDatabase="TFS")] //since there is a 14 hour window of possibilities, we return false to be safe since the answer "could" be no
            [CompoundCase("InvalidDate",                 "1234-01-23T23:45:56.78Z",  "The day before yesterday",     "System.FormatException")]
            public void ClaimDateTime(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/datetimetest", claimValue, ClaimValueTypes.Datetime);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/datetimetest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Decimal type.")]
            [CompoundCase("SameIntegerWithPointAndZero", "7.0",              "7.0",              "true")]
            [CompoundCase("SameIntegerWithPoint",        "7.",               "7.",               "true")]
            [CompoundCase("SameIntegerNoPoint",          "7",                "7",                "true")]
            [CompoundCase("SamePositiveDecimalWithZero", "0.7",              "0.7",              "true")]
            [CompoundCase("SamePositiveDecimalNoZero",   ".7",               ".7",               "true")]
            [CompoundCase("SameNumberPassPlus",          "0.7",              "+0.7",             "true")]
            [CompoundCase("SameNegativeDecimal",         "-0.7",             "-0.7",             "true")]
            [CompoundCase("SameNumberPassExtraZeros",    "0.7",              "00.70",            "true")]
            [CompoundCase("ZeroDifferentSign",           "0",                "-0",               "true")]
            [CompoundCase("DifferentBySign",             ".7",               "-.7",              "false")]
            [CompoundCase("DifferentNumber",             "0.7",              "7.0",              "false")]
            [CompoundCase("DifferentButClose",           "99999999.9999999", "99999999.9999998", "false")]
            [CompoundCase("InvalidNotation",             "10",               "1E+1",             "System.FormatException")] //sci notation is not allowed
            [CompoundCase("InvalidNumber",               "0",                "wtf",              "System.FormatException")]
            [CompoundCase("InvalidEmpty",                "0",                "",                 "System.FormatException")]
            [CompoundCase("InvalidNull",                 "0",                null,               "System.FormatException")]
            public void ClaimDecimal(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/decimaltest", claimValue, "http://www.w3.org/2001/XMLSchema#decimal");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/decimaltest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IPAddress type.")]
            [CompoundCase("IdenticalIPV6LongNoPort",     "1234:5678:9abc:def0:1234:5678:9abc:def0", "1234:5678:9abc:def0:1234:5678:9abc:def0",   "true")]
            [CompoundCase("IdenticalIPV6ShortNoPort",    "3:0:7:a:f:5:f:a",                         "3:0:7:a:f:5:f:a",                           "true")]
            [CompoundCase("IdenticalIPV6BracketsNoPort", "1234:5678:9abc:def0:1234:5678:9abc:def0", "[1234:5678:9abc:def0:1234:5678:9abc:def0]", "true")]
            [CompoundCase("IdenticalIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1237:a:f:1235:f:a32f]:65535",         "true")]
            [CompoundCase("IdenticalIPV6SamePort",       "[a3:0:1237:a:f:1235:f:a32f]:1234",       "[a3:0:1237:a:f:1235:f:a32f]:01234",          "true")]
            [CompoundCase("IdenticalIPV4LongNoPort",     "123.124.234.235",                         "123.124.234.235",                           "true")]
            [CompoundCase("IdenticalIPV4ColonNoPort",    "1.2.3.4",                                 "1.2.3.4:",                                  "true")]
            [CompoundCase("IdenticalIPV4ShortNoPort",    "1.2.3.4",                                 "1.2.3.4",                                   "true")]
            [CompoundCase("IdenticalIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.234.35:65535",                       "true")]
            [CompoundCase("IdenticalIPV4SamePort",       "12.124.234.35:1234",                     "12.124.234.35:01234",                        "true")]
            [CompoundCase("SameIPV6NoPort",              "234:5678:9abc:def0:1234:678:9abc:def0",   "0234:5678:9abc:def0:1234:0678:9abc:def0",   "true")]
            [CompoundCase("SameIPV6IdenticalPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5535",       "true")]
            [CompoundCase("SameIPV6SamePort",            "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:05535",      "true")]
            [CompoundCase("SameIPV6DifferentPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5534",       "false")]
            [CompoundCase("SameIPV6MissingPort",         "[a3:0:1237:a:f:1235:f:a32f]:5535",        "a3:0000:1237:a:f:1235:f:a32f",              "false")]
            [CompoundCase("SameIPV4NoPort",              "1.2.3.4",                                 "1.2.3.004",                                 "true")]
            [CompoundCase("SameIPV4IdenticalPort",       "12.124.234.29:5535",                      "12.124.234.035:5535",                       "true")]
            [CompoundCase("SameIPV4SamePort",            "12.124.234.29:5535",                      "12.124.234.035:05535",                      "true")]
            [CompoundCase("SameIPV4DifferentPort",       "12.124.234.29:5535",                      "12.124.234.035:5534",                       "false")]
            [CompoundCase("DifferentIPV6NoPort",         "3:0:7:a:f:5:f:a",                         "3:0:8:a:f:5:f:a",                           "false")]
            [CompoundCase("DifferentIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65535",         "false")]
            [CompoundCase("DifferentIPV6DifferentPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65534",         "false")]
            [CompoundCase("DifferentIPV4NoPort",         "1.2.3.4",                                 "1.2.5.4",                                   "false")]
            [CompoundCase("DifferentIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.235.35:65535",                       "false")]
            [CompoundCase("DifferentIPV4DifferentPort",  "12.124.234.35:65535",                     "12.124.235.35:65534",                       "false")]
            [CompoundCase("InvalidIpNumber",             "12.124.234.35:65535",                     "12.124.234.935:65535",                      "System.FormatException")]
            [CompoundCase("InvalidPort",              "12.124.234.35:65535",                        "12.124.234.35:965535",                      "System.FormatException")]
            [CompoundCase("InvalidIpFormat",          "12.124.234.35:65535",                        "wtf",                                       "System.FormatException")]
            [CompoundCase("InvalidEmpty",             "12.124.234.35:65535",                        "",                                          "System.FormatException")]
            [CompoundCase("InvalidNull",              "12.124.234.35:65535",                        null,                                        "System.FormatException")]
            public void CustomClaimIPAddress(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/ipaddresstest", claimValue, "http://schemas.microsoft.com/xbox/types#IpAddress");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/ipaddresstest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IntegerArray type.")]
            [CompoundCase("SameOneEntry",             "12345",      "12345",      "true")]
            [CompoundCase("DifferentOneEntry",        "12345",      "12945",      "false")]
            [CompoundCase("SameTwoEntries",           "12345 6789", "12345 6789", "true")]
            [CompoundCase("TwoEntriesDifferentOrder", "12345 6789", "6789 12345", "false")]
            [CompoundCase("ThreeEntriesOneDifferent", "1 2 3",      "1 9 3",      "false")]
            [CompoundCase("InvalidEntry",             "1 2 3",      "1 xz 3",     "System.FormatException")] // exception for invalid field
            [CompoundCase("ReversedEntry",            "1 2 3",      "3 2 1",      "false")] // comparisons are literally string compares so this fails
            [CompoundCase("OutOfOrderEntry",          "1 2 3",      "1 3 2",      "false")] // comparisons are literally string compares so this fails
            [CompoundCase("PassEmpty",                "1 2 3",      "",           "false")]
            [CompoundCase("PassNull",                 "1 2 3",      null,         "false", BugID=63229, BugDatabase="TFS")]
            [CompoundCase("PassLess",                 "1 2 3",      "1 2",        "false")]
            [CompoundCase("PassMore",                 "1 2 3",      "1 2 3 4",    "false")]
            public void CustomClaimIntegerArray(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integerarraytest", claimValue, "http://schemas.microsoft.com/xbox/types#IntegerArray");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("equals", "http://example.com/integerarraytest", passValue, null);
                VerifyResult(expect, ret);
            }
        }; //class Equal

        [TestGroup, Description("Tests for AuthHelper.VerifyContains")]
        public class Contains: TestNode
        {
            [TestCase, Description("Ask when no token of that type is provided.")]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallVerifyOperator("contains", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Ask when no claim of that type is provided.")]
            public void NoClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/somethingunrelated", "7", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Claim is a string type.")]
            [CompoundCase("SameCase", "Simple String", "Simple String", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimString(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/stringtest", claimValue, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/stringtest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is an integer type.")]
            [CompoundCase("SameInteger", "7", "7", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimInteger(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integertest", claimValue, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/integertest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a boolean type.")]
            [CompoundCase("SameFalse", "false", "false", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimBoolean(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/booleantest", claimValue, ClaimValueTypes.Boolean);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/booleantest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Base64Binary type.")]
            [CompoundCase("ZeroByteSame", new byte[0], new byte[0], "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimBase64Binary(TestNode self)
            {
                string claimValue;
                string passValue;
                string expect=(string)self.MyValues[2];

                if (self.MyValues[0]==null)
                {
                    claimValue=null;
                }
                else if (self.MyValues[0] is byte[])
                {
                    claimValue=System.Convert.ToBase64String((byte[])self.MyValues[0]);
                }
                else
                {
                    claimValue=(string)self.MyValues[0];
                }

                if (self.MyValues[1]==null)
                {
                    passValue=null;
                }
                else if (self.MyValues[1] is byte[])
                {
                    passValue=System.Convert.ToBase64String((byte[])self.MyValues[1]);
                }
                else
                {
                    passValue=(string)self.MyValues[1];
                }

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/base64binarytest", claimValue, ClaimValueTypes.Base64Binary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/base64binarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a HexBinary type.")]
            [CompoundCase("OneByteSame", "0A", "0A", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimHexBinary(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/hexbinarytest", claimValue, ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/hexbinarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a DateTime type.")]
            [CompoundCase("SameDateUtcZone", "1234-01-23T23:45:56.78Z", "1234-01-23T23:45:56.78Z", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimDateTime(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/datetimetest", claimValue, ClaimValueTypes.Datetime);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/datetimetest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Decimal type.")]
            [CompoundCase("SameIntegerWithPointAndZero", "7.0", "7.0", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void ClaimDecimal(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/decimaltest", claimValue, "http://www.w3.org/2001/XMLSchema#decimal");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/decimaltest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IPAddress type.")]
            [CompoundCase("IdenticalIPV6ShortNoPort", "3:0:7:a:f:5:f:a", "3:0:7:a:f:5:f:a", "System.InvalidOperationException")] // this type is not supported for the contains operator
            public void CustomClaimIPAddress(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/ipaddresstest", claimValue, "http://schemas.microsoft.com/xbox/types#IpAddress");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/ipaddresstest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IntegerArray type.")]
            [CompoundCase("SameOneEntry",             "12345",            "12345",         "true")]
            [CompoundCase("DifferentOneEntry",        "12345",            "12945",         "false")]
            [CompoundCase("DifferentContainingSub",   "123456",           "12345",         "false")]
            [CompoundCase("ContainingFirstEntry",     "12345 999 0123",   "12345",         "true")]
            [CompoundCase("ContainingMiddleEntry",    "654 12345 987",    "12345",         "true")]
            [CompoundCase("ContainingLastEntry",      "5 72381178 12345", "12345",         "true")]
            [CompoundCase("TooManyEntries",           "12345 6789",       "12345 6789",    "System.FormatException")]
            [CompoundCase("InvalidEntryFields",       "1 xz 3",           "1",             "System.FormatException")] // exception for invalid field
            [CompoundCase("InvalidEntryComparator",   "1 2 3",            "xz",            "System.FormatException")] // exception for invalid field            
            [CompoundCase("PassEmpty",                "1",                "",              "System.FormatException")]
            [CompoundCase("PassNull",                 "1",                null,            "false", BugID=63229, BugDatabase="TFS")]
            public void CustomClaimIntegerArray(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integerarraytest", claimValue, "http://schemas.microsoft.com/xbox/types#IntegerArray");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("contains", "http://example.com/integerarraytest", passValue, null);
                VerifyResult(expect, ret);
            }
        }; //class Contains
        
        [TestGroup, Description("Tests for AuthHelper.VerifyLessThan")]
        public class LessThan: TestNode
        {
            [TestCase, Description("Ask when no token of that type is provided.")]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Ask when no claim of that type is provided.")]
            public void NoClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/somethingunrelated", "7", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Claim is a string type.")]
            [CompoundCase("DifferentShorter",     "SimpleString",  "SimpleStrin",   "false")]
            [CompoundCase("DifferentLonger",      "SimpleString",  "SimpleStrings", "true")]
            [CompoundCase("SameCase",             "Simple String", "Simple String", "false")]
            [CompoundCase("DifferentCaseLess",    "SimpleString",  "simplestring",  "false")]
            [CompoundCase("DifferentCaseGreater", "SimpleString",  "SimpleStrinG",  "true")]
            [CompoundCase("ClaimNormalPassEmpty", "SimpleString",  "",              "false")]
            [CompoundCase("ClaimNormalPassNull",  "SimpleString",  null,            "false")] // null works with reference type
            [CompoundCase("ClaimEmptyPassNormal", "",              "SimpleString",  "true")]
            [CompoundCase("ClaimEmptyPassEmpty",  "",              "",              "false")]
            [CompoundCase("ClaimEmptyPassNull",   "",              null,            "false")] // null works with reference type
            [CompoundCase("ExtraSpacesInClaim",   " Hello ",       "Hello",         "true")]
            [CompoundCase("PassExtraSpaces",      "Hello",         " Hello ",       "false")]
            [CompoundCase("NumericStringEquals",  "2",             "2",             "false")]
            [CompoundCase("NumericStringLess",    "2",             "1",             "false")]
            [CompoundCase("NumericStringGreater", "2",             "3",             "true")]
            public void ClaimString(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/stringtest", claimValue, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/stringtest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is an integer type.")]
            [CompoundCase("VeryLargePositiveIntegerEquals",       "79228162514264337593543950335",             "79228162514264337593543950335",            "false")] // Decimal.Max is the highest value for the VeryLarge tests
            [CompoundCase("VeryLargePositiveIntegerLess",         "79228162514264337593543950335",             "79228162514264337593543950334",            "false")]
            [CompoundCase("VeryLargePositiveIntegerGreater",      "79228162514264337593543950334",             "79228162514264337593543950335",            "true")]
            [CompoundCase("MinimallyLargePositiveIntegerEquals",  "999999999999999999",                        "999999999999999999",                       "false")]
            [CompoundCase("MinimallyLargePositiveIntegerLess",    "999999999999999999",                        "999999999999999998",                       "false")]
            [CompoundCase("MinimallyLargePositiveIntegerGreater", "999999999999999998",                        "999999999999999999",                       "true")]
            [CompoundCase("MinimallyLargeNegativeIntegerEquals",  "-999999999999999999",                       "-999999999999999999",                      "false")]
            [CompoundCase("MinimallyLargeNegativeIntegerLess",    "-999999999999999998",                       "-999999999999999999",                      "false")]
            [CompoundCase("MinimallyLargeNegativeIntegerGreater", "-999999999999999999",                       "-999999999999999998",                      "true")]
            [CompoundCase("SameZeroInteger",                      "0",                                         "0",                                        "false")]
            [CompoundCase("SameZeroIntegerDifferentSign",         "-0",                                        "+0",                                       "false")]
            [CompoundCase("IntegerLeadingZerosEquals",            "7",                                         "007",                                      "false")]
            [CompoundCase("IntegerLeadingZerosLess",              "7",                                         "006",                                      "false")]
            [CompoundCase("IntegerLeadingZerosGreater",           "7",                                         "008",                                      "true")]
            [CompoundCase("DifferentSignLess",                    "7",                                         "-7",                                       "false")]
            [CompoundCase("DifferentSignGreater",                 "-7",                                        "7",                                        "true")]
            [CompoundCase("ClaimNormalPassEmpty",                 "0",                                         "",                                         "System.FormatException")]
            [CompoundCase("ClaimNormalPassNull",                  "0",                                         null,                                       "System.FormatException")]
            [CompoundCase("PassInvalidInteger",                   "7",                                         "8.",                                       "System.FormatException")]
            public void ClaimInteger(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integertest", claimValue, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/integertest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a boolean type.")]
            [CompoundCase("SameLowerFalse",              "false", "false", "false")]
            [CompoundCase("SameLowerTrue",               "true",  "true",  "false")]
            [CompoundCase("SameNumberFalse",             "false", "0",     "false")]
            [CompoundCase("SameNumberTrue",              "true",  "1",     "false")]
            [CompoundCase("DifferentLowerPassTrue",      "false", "true",  "true")]
            [CompoundCase("DifferentLowerPassFalse",     "true",  "false", "false")]
            [CompoundCase("DifferentLowerPass1",         "false", "1",     "true")]
            [CompoundCase("DifferentLowerPass0",         "true",  "0",     "false")]
            [CompoundCase("InvalidBoolTextClaimTrue",    "true",  "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolTextClaimFalse",   "false", "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolNumberClaimTrue",  "true",  "2",     "System.FormatException")]
            [CompoundCase("InvalidBoolNumberClaimFalse", "false", "-0",    "System.FormatException")]
            [CompoundCase("PassEmptyClaimTrue",          "true",  "",      "System.FormatException")]
            [CompoundCase("PassEmptyClaimFalse",         "false", "",      "System.FormatException")]
            [CompoundCase("PassNullClaimTrue",           "true",  null,    "System.FormatException")]
            [CompoundCase("PassNullClaimFalse",          "false", null,    "System.FormatException")]
            public void ClaimBoolean(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/booleantest", claimValue, ClaimValueTypes.Boolean);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/booleantest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Base64Binary type.")]
            [CompoundCase("ZeroByteSame",                new byte[0],                        new byte[0],                        "false")]
            [CompoundCase("ZeroByteClaimPassOne",        new byte[0],                        new byte[]{0x00},                   "true")]
            [CompoundCase("OneByteClaimPassTwo",         new byte[]{0xff},                   new byte[]{0xff, 0xff},             "true")]
            [CompoundCase("OneByteSame",                 new byte[]{0x07},                   new byte[]{0x07},                   "false")]
            [CompoundCase("TwoByteSame",                 new byte[]{0x13, 0x37},             new byte[]{0x13, 0x37},             "false")]
            [CompoundCase("ThreeByteSame",               new byte[]{0x00, 0x7f, 0xff},       new byte[]{0x00, 0x7f, 0xff},       "false")]
            [CompoundCase("FourByteSame",                new byte[]{0xff, 0x13, 0x37, 0x00}, new byte[]{0xff, 0x13, 0x37, 0x00}, "false")]
            [CompoundCase("OneByteDifferentLess",        new byte[]{0xf7},                   new byte[]{0xf6},                   "false")]
            [CompoundCase("OneByteDifferentGreater",     new byte[]{0xf7},                   new byte[]{0xf8},                   "true")]
            [CompoundCase("TwoByteDifferentLess",        new byte[]{0x03, 0x37},             new byte[]{0x03, 0x36},             "false")]
            [CompoundCase("TwoByteDifferentGreater",     new byte[]{0x03, 0x37},             new byte[]{0x03, 0x38},             "true")]
            [CompoundCase("ThreeByteDifferentLess",      new byte[]{0x01, 0x7f, 0xf4},       new byte[]{0x01, 0x7f, 0xf3},       "false")]
            [CompoundCase("ThreeByteDifferentGreater",   new byte[]{0x01, 0x7f, 0xf4},       new byte[]{0x01, 0x7f, 0xf5},       "true")]
            [CompoundCase("FourByteDifferentTopLess",    new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x70, 0x13, 0x37, 0x60}, "false")]
            [CompoundCase("FourByteDifferentTopGreater", new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x90, 0x13, 0x37, 0x60}, "true")]
            [CompoundCase("FourByteDifferentBotLess",    new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x80, 0x13, 0x37, 0x5f}, "false")]
            [CompoundCase("FourByteDifferentBotGreater", new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x80, 0x13, 0x37, 0x61}, "true")]
            [CompoundCase("PassNull",                    new byte[]{0x00},                   null,                               "System.FormatException", BugID=63229, BugDatabase="TFS")]
            [CompoundCase("PassInvalid",                 new byte[]{0x00},                   "*~woops~*",                        "System.FormatException")]
            public void ClaimBase64Binary(TestNode self)
            {
                string claimValue;
                string passValue;
                string expect=(string)self.MyValues[2];

                if (self.MyValues[0]==null)
                {
                    claimValue=null;
                }
                else if (self.MyValues[0] is byte[])
                {
                    claimValue=System.Convert.ToBase64String((byte[])self.MyValues[0]);
                }
                else
                {
                    claimValue=(string)self.MyValues[0];
                }

                if (self.MyValues[1]==null)
                {
                    passValue=null;
                }
                else if (self.MyValues[1] is byte[])
                {
                    passValue=System.Convert.ToBase64String((byte[])self.MyValues[1]);
                }
                else
                {
                    passValue=(string)self.MyValues[1];
                }

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/base64binarytest", claimValue, ClaimValueTypes.Base64Binary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/base64binarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a HexBinary type.")]
            [CompoundCase("ZeroByteSame",            "",                                                               "",                                                               "false")]
            [CompoundCase("ZeroByteClaimPassOne",    "",                                                               "FF",                                                             "true")]
            [CompoundCase("OneByteSame",             "0A",                                                             "0A",                                                             "false")]
            [CompoundCase("OneByteGreater",          "0A",                                                             "0B",                                                             "true")]
            [CompoundCase("OneByteGreaterPassLower", "0A",                                                             "0b",                                                             "true")]
            [CompoundCase("OneByteLess",             "FF",                                                             "FE",                                                             "false")]
            [CompoundCase("OneByteLessPassLower",    "FF",                                                             "Fe",                                                             "false")]
            [CompoundCase("ManyByteSame",            "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("ManyByteTopLess",         "1102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("ManyByteTopGreater",      "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "1102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "true")]
            [CompoundCase("ManyByteBotLess",         "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFE", "false")]
            [CompoundCase("ManyByteBotGreater",      "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFE", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "true")]
            [CompoundCase("PassShorter",             "020102030405060708090A0B0C0D0E0F",                               "0102030405060708090A0B0C0D0E0F",                                 "false")]
            [CompoundCase("PassLonger",              "000102030405060708090A0B0C0D0E0F",                               "000102030405060708090A0B0C0D0E0F00",                             "true")]
            [CompoundCase("PassEmpty",               "FF0000DD",                                                       "",                                                               "false")]
            [CompoundCase("PassNull",                "FF0000DD",                                                       null,                                                             "System.FormatException", BugID=63229, BugDatabase="TFS")]
            [CompoundCase("PassInvalidChars",        "FF0000DD",                                                       "0wtf",                                                           "System.FormatException")]
            [CompoundCase("PassInvalidLength",       "000",                                                            "0",                                                              "false")] // values are extended to the nearest byte
            [CompoundCase("PassEquivilentLength",    "00",                                                             "0",                                                              "false")] // values are extended to the nearest byte
            [CompoundCase("PassInvalidPrefix",       "FF0000DD",                                                       "0xFF0000DD",                                                     "false")] // the canonical representation is emitted (no 0x)
            public void ClaimHexBinary(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/hexbinarytest", claimValue, ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/hexbinarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a DateTime type.")]
            [CompoundCase("SameDateUtcZone",            "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.78Z",      "false")]
            [CompoundCase("LessDateUtcZone",            "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.77Z",      "false")]
            [CompoundCase("GreaterDateUtcZone",         "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.79Z",      "true")]
            [CompoundCase("LessEarlyDateUtcZone",       "0003-01-23T23:45:56.78Z",  "0003-01-23T23:45:56.77Z",      "false")] // we are bound to valide Date.Parse ranges
            [CompoundCase("GreaterEarlyDateUtcZone",    "0002-01-23T23:45:56.78Z",  "0002-01-23T23:45:56.79Z",      "true")] // we are bound to valide Date.Parse ranges
            [CompoundCase("LessFutureDateUtcZone",      "9876-01-23T23:45:56.78Z",  "9876-01-23T23:45:56.78Z",     "false")] // we are bound to valide Date.Parse ranges
            [CompoundCase("GreaterFutureDateUtcZone",   "9998-01-23T23:45:56.78Z",  "9998-01-23T23:45:56.79Z",      "true")] // we are bound to valide Date.Parse ranges
            [CompoundCase("LessDateDifferentZones",     "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.77+01:00", "false")]
            [CompoundCase("GreaterDateDifferentZones",  "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.79+01:00", "true")]
            [CompoundCase("GreaterDateNoZoneTooClose",  "1234-01-23T20:45:56.78Z",  "1234-01-23T23:45:56.78",       "true", BugID=76462, BugDatabase="TFS")] // everything is converted to UTC (NOTE: does not follow XML specifications)
            [CompoundCase("GreaterDateNoZoneFarEnough", "1234-01-23T23:45:56.78Z",  "1234-01-25T23:45:56.78",       "true", BugID=76462, BugDatabase="TFS")] // since there is a 14 hour window of possibilities, we return false to be safe since the answer "could" be no
            [CompoundCase("InvalidDate",                "1234-01-23T23:45:56.78Z",  "The day before yesterday",     "System.FormatException")]
            public void ClaimDateTime(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/datetimetest", claimValue, ClaimValueTypes.Datetime);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/datetimetest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Decimal type.")]
            [CompoundCase("SameIntegerWithPointAndZero",    "7.0",              "7.0",             "false")]
            [CompoundCase("LessIntegerWithPointAndZero",    "7.0",              "6.9",             "false")]
            [CompoundCase("GreaterIntegerWithPointAndZero", "7.0",              "7.1",             "true")]
            [CompoundCase("SameIntegerWithPoint",           "7.",               "7.",              "false")]
            [CompoundCase("LessIntegerWithPoint",           "7.",               "6.",              "false")]
            [CompoundCase("GreaterIntegerWithPoint",        "7.",               "8.",              "true")]
            [CompoundCase("SameIntegerNoPoint",             "7",                "7",               "false")]
            [CompoundCase("LessIntegerNoPoint",             "7",                "6",               "false")]
            [CompoundCase("GreaterIntegerNoPoint",          "7",                "8",               "true")]
            [CompoundCase("SamePositiveDecimalWithZero",    "0.7",              "0.7",             "false")]
            [CompoundCase("LessPositiveDecimalWithZero",    "0.7",              "0.6",             "false")]
            [CompoundCase("GreaterPositiveDecimalWithZero", "0.7",              "0.8",             "true")]
            [CompoundCase("SamePositiveDecimalNoZero",      ".7",               ".7",              "false")]
            [CompoundCase("LessPositiveDecimalNoZero",      ".7",               ".6",              "false")]
            [CompoundCase("GreaterPositiveDecimalNoZero",   ".7",               ".8",              "true")]
            [CompoundCase("SameNumberPassPlus",            "0.7",              "+0.7",             "false")]
            [CompoundCase("LessNumberPassPlus",            "0.7",              "+0.6",             "false")]
            [CompoundCase("GreaterNumberPassPlus",         "0.7",              "+0.8",             "true")]
            [CompoundCase("SameNegativeDecimal",           "-0.7",             "-0.7",             "false")]
            [CompoundCase("LessNegativeDecimal",           "-0.7",             "-0.8",             "false")]
            [CompoundCase("GreaterNegativeDecimal",        "-0.7",             "-0.6",             "true")]
            [CompoundCase("SameNumberPassExtraZeros",      "0.7",              "00.70",            "false")]
            [CompoundCase("LessNumberPassExtraZeros",      "0.7",              "00.60",            "false")]
            [CompoundCase("GreaterNumberPassExtraZeros",   "0.7",              "00.80",            "true")]
            [CompoundCase("ZeroDifferentSign",             "0",                "-0",               "false")]
            [CompoundCase("LessBigAndClose",               "99999999.9999999", "99999999.9999998", "false")]
            [CompoundCase("GreaterBigAndClose",            "99999999.9999998", "99999999.9999999", "true")]
            [CompoundCase("InvalidNotation",               "10",               "10E+10",           "System.FormatException")] //sci notation is not allowed
            [CompoundCase("InvalidNumber",                 "0",                "wtf",              "System.FormatException")]
            [CompoundCase("InvalidEmpty",                  "0",                "",                 "System.FormatException")]
            [CompoundCase("InvalidNull",                   "0",                null,               "System.FormatException")]
            public void ClaimDecimal(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/decimaltest", claimValue, "http://www.w3.org/2001/XMLSchema#decimal");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/decimaltest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IPAddress type.  Saying greater than is nonsense, always expect false.")]
            [CompoundCase("IdenticalIPV6LongNoPort",     "1234:5678:9abc:def0:1234:5678:9abc:def0", "1234:5678:9abc:def0:1234:5678:9abc:def0",   "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6ShortNoPort",    "3:0:7:a:f:5:f:a",                         "3:0:7:a:f:5:f:a",                           "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6BracketsNoPort", "1234:5678:9abc:def0:1234:5678:9abc:def0", "[1234:5678:9abc:def0:1234:5678:9abc:def0]", "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1237:a:f:1235:f:a32f]:65535",         "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6SamePort",       "[a3:0:1237:a:f:1235:f:a32f]:1234",       "[a3:0:1237:a:f:1235:f:a32f]:01234",          "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4LongNoPort",     "123.124.234.235",                         "123.124.234.235",                           "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4ShortNoPort",    "1.2.3.4",                                 "1.2.3.4",                                   "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.234.35:65535",                       "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4SamePort",       "12.124.234.35:1234",                     "12.124.234.35:01234",                        "System.InvalidOperationException")]
            [CompoundCase("SameIPV6NoPort",              "234:5678:9abc:def0:1234:678:9abc:def0",   "0234:5678:9abc:def0:1234:0678:9abc:def0",   "System.InvalidOperationException")]
            [CompoundCase("SameIPV6IdenticalPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5535",       "System.InvalidOperationException")]
            [CompoundCase("SameIPV6SamePort",            "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:05535",      "System.InvalidOperationException")]
            [CompoundCase("SameIPV6DifferentPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5534",       "System.InvalidOperationException")]
            [CompoundCase("SameIPV6MissingPort",         "[a3:0:1237:a:f:1235:f:a32f]:5535",        "a3:0000:1237:a:f:1235:f:a32f",              "System.InvalidOperationException")]
            [CompoundCase("SameIPV4NoPort",              "1.2.3.4",                                 "1.2.3.004",                                 "System.InvalidOperationException")]
            [CompoundCase("SameIPV4IdenticalPort",       "12.124.234.29:5535",                      "12.124.234.035:5535",                       "System.InvalidOperationException")]
            [CompoundCase("SameIPV4SamePort",            "12.124.234.29:5535",                      "12.124.234.035:05535",                      "System.InvalidOperationException")]
            [CompoundCase("SameIPV4DifferentPort",       "12.124.234.29:5535",                      "12.124.234.035:5534",                       "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6NoPort",         "3:0:7:a:f:5:f:a",                         "3:0:8:a:f:5:f:a",                           "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65535",         "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6DifferentPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65534",         "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4NoPort",         "1.2.3.4",                                 "1.2.5.4",                                   "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.235.35:65535",                       "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4DifferentPort",  "12.124.234.35:65535",                     "12.124.235.35:65534",                       "System.InvalidOperationException")]
            [CompoundCase("InvalidIpNumber",             "12.124.234.35:65535",                     "12.124.234.935:65535",                      "System.InvalidOperationException")]
            [CompoundCase("InvalidPort",                 "12.124.234.35:65535",                     "12.124.234.35:965535",                      "System.InvalidOperationException")]
            [CompoundCase("InvalidIpFormat",             "12.124.234.35:65535",                     "wtf",                                       "System.InvalidOperationException")]
            [CompoundCase("InvalidEmpty",                "12.124.234.35:65535",                     "",                                          "System.InvalidOperationException")]
            [CompoundCase("InvalidNull",                 "12.124.234.35:65535",                     null,                                        "System.InvalidOperationException")]
            public void CustomClaimIPAddress(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/ipaddresstest", claimValue, "http://schemas.microsoft.com/xbox/types#IpAddress");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/ipaddresstest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IntegerArray type.  Saying greater than is nonsense, always expect invalid operation exception.")]
            [CompoundCase("SameOneEntry",             "12345",      "12345",      "System.InvalidOperationException")]
            [CompoundCase("PassEmpty",                "1 2 3",      "",           "System.InvalidOperationException")]
            [CompoundCase("PassNull",                 "1 2 3",      null,         "System.InvalidOperationException")]
            public void CustomClaimIntegerArray(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integerarraytest", claimValue, "http://schemas.microsoft.com/xbox/types#IntegerArray");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("lessthan", "http://example.com/integerarraytest", passValue, null);
                VerifyResult(expect, ret);
            }
        }; //class LessThan

        [TestGroup, Description("Tests for AuthHelper.VerifyGreaterThan")]
        public class GreaterThan: TestNode
        {
            [TestCase, Description("Ask when no token of that type is provided.")]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Ask when no claim of that type is provided.")]
            public void NoClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/somethingunrelated", "7", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/notthere", "7", null);
                VerifyResult("Microsoft.XboxLive.Auth.ClaimNotFoundException", ret);
            }

            [TestCase, Description("Claim is a string type.")]
            [CompoundCase("DifferentShorter",     "SimpleString",  "SimpleStrin",   "true")]
            [CompoundCase("DifferentLonger",      "SimpleString",  "SimpleStrings", "false")]
            [CompoundCase("SameCase",             "Simple String", "Simple String", "false")]
            [CompoundCase("DifferentCaseLess",    "SimpleString",  "simplestring",  "true")]
            [CompoundCase("DifferentCaseGreater", "SimpleString",  "SimpleStrinG",  "false")]
            [CompoundCase("ClaimNormalPassEmpty", "SimpleString",  "",              "true")]
            [CompoundCase("ClaimNormalPassNull",  "SimpleString",  null,            "true")]  // null works with reference type
            [CompoundCase("ClaimEmptyPassNormal", "",              "SimpleString",  "false")]
            [CompoundCase("ClaimEmptyPassEmpty",  "",              "",              "false")]
            [CompoundCase("ClaimEmptyPassNull",   "",              null,            "true")] // null works with reference type
            [CompoundCase("ExtraSpacesInClaim",   " Hello ",       "Hello",         "false")]
            [CompoundCase("PassExtraSpaces",      "Hello",         " Hello ",       "true")]
            [CompoundCase("NumericStringEquals",  "2",             "2",             "false")]
            [CompoundCase("NumericStringLess",    "2",             "1",             "true")]
            [CompoundCase("NumericStringGreater", "2",             "3",             "false")]
            public void ClaimString(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/stringtest", claimValue, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/stringtest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is an integer type.")]
            [CompoundCase("VeryLargePositiveIntegerEquals",       "79228162514264337593543950335",             "79228162514264337593543950335",            "false")]
            [CompoundCase("VeryLargePositiveIntegerLess",         "79228162514264337593543950335",             "79228162514264337593543950334",            "true")]
            [CompoundCase("VeryLargePositiveIntegerGreater",      "79228162514264337593543950334",             "79228162514264337593543950335",            "false")]
            [CompoundCase("MinimallyLargePositiveIntegerEquals",  "999999999999999999",                        "999999999999999999",                       "false")]
            [CompoundCase("MinimallyLargePositiveIntegerLess",    "999999999999999999",                        "999999999999999998",                       "true")]
            [CompoundCase("MinimallyLargePositiveIntegerGreater", "999999999999999998",                        "999999999999999999",                       "false")]
            [CompoundCase("MinimallyLargeNegativeIntegerEquals",  "-999999999999999999",                       "-999999999999999999",                      "false")]
            [CompoundCase("MinimallyLargeNegativeIntegerLess",    "-999999999999999998",                       "-999999999999999999",                      "true")]
            [CompoundCase("MinimallyLargeNegativeIntegerGreater", "-999999999999999999",                       "-999999999999999998",                      "false")]
            [CompoundCase("SameZeroInteger",                      "0",                                         "0",                                        "false")]
            [CompoundCase("SameZeroIntegerDifferentSign",         "-0",                                        "+0",                                       "false")]
            [CompoundCase("IntegerLeadingZerosEquals",            "7",                                         "007",                                      "false")]
            [CompoundCase("IntegerLeadingZerosLess",              "7",                                         "006",                                      "true")]
            [CompoundCase("IntegerLeadingZerosGreater",           "7",                                         "008",                                      "false")]
            [CompoundCase("DifferentSignLess",                    "7",                                         "-7",                                       "true")]
            [CompoundCase("DifferentSignGreater",                 "-7",                                        "7",                                        "false")]
            [CompoundCase("ClaimNormalPassEmpty",                 "0",                                         "",                                         "System.FormatException")]
            [CompoundCase("ClaimNormalPassNull",                  "0",                                         null,                                       "System.FormatException")]
            [CompoundCase("PassInvalidInteger",                   "7",                                         "8.",                                       "System.FormatException")]
            public void ClaimInteger(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integertest", claimValue, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/integertest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a boolean type.")]
            [CompoundCase("SameLowerFalse",              "false", "false", "false")]
            [CompoundCase("SameLowerTrue",               "true",  "true",  "false")]
            [CompoundCase("SameNumberFalse",             "false", "0",     "false")]
            [CompoundCase("SameNumberTrue",              "true",  "1",     "false")]
            [CompoundCase("DifferentLowerPassTrue",      "false", "true",  "false")]
            [CompoundCase("DifferentLowerPassFalse",     "true",  "false", "true")]
            [CompoundCase("DifferentLowerPass1",         "false", "1",     "false")]
            [CompoundCase("DifferentLowerPass0",         "true",  "0",     "true")]
            [CompoundCase("InvalidBoolTextClaimTrue",    "true",  "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolTextClaimFalse",   "false", "wtf",   "System.FormatException")]
            [CompoundCase("InvalidBoolNumberClaimTrue",  "true",  "2",     "System.FormatException")]
            [CompoundCase("InvalidBoolNumberClaimFalse", "false", "-0",    "System.FormatException")]
            [CompoundCase("PassEmptyClaimTrue",          "true",  "",      "System.FormatException")]
            [CompoundCase("PassEmptyClaimFalse",         "false", "",      "System.FormatException")]
            [CompoundCase("PassNullClaimTrue",           "true",  null,    "System.FormatException")]
            [CompoundCase("PassNullClaimFalse",          "false", null,    "System.FormatException")]
            public void ClaimBoolean(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/booleantest", claimValue, ClaimValueTypes.Boolean);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/booleantest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Base64Binary type.")]
            [CompoundCase("ZeroByteSame",                new byte[0],                        new byte[0],                        "false")]
            [CompoundCase("ZeroByteClaimPassOne",        new byte[0],                        new byte[]{0x00},                   "false")]
            [CompoundCase("OneByteClaimPassTwo",         new byte[]{0xff},                   new byte[]{0xff, 0xff},             "false")]
            [CompoundCase("OneByteSame",                 new byte[]{0x07},                   new byte[]{0x07},                   "false")]
            [CompoundCase("TwoByteSame",                 new byte[]{0x13, 0x37},             new byte[]{0x13, 0x37},             "false")]
            [CompoundCase("ThreeByteSame",               new byte[]{0x00, 0x7f, 0xff},       new byte[]{0x00, 0x7f, 0xff},       "false")]
            [CompoundCase("FourByteSame",                new byte[]{0xff, 0x13, 0x37, 0x00}, new byte[]{0xff, 0x13, 0x37, 0x00}, "false")]
            [CompoundCase("OneByteDifferentLess",        new byte[]{0xf7},                   new byte[]{0xf6},                   "true")]
            [CompoundCase("OneByteDifferentGreater",     new byte[]{0xf7},                   new byte[]{0xf8},                   "false")]
            [CompoundCase("TwoByteDifferentLess",        new byte[]{0x03, 0x37},             new byte[]{0x03, 0x36},             "true")]
            [CompoundCase("TwoByteDifferentGreater",     new byte[]{0x03, 0x37},             new byte[]{0x03, 0x38},             "false")]
            [CompoundCase("ThreeByteDifferentLess",      new byte[]{0x01, 0x7f, 0xf4},       new byte[]{0x01, 0x7f, 0xf3},       "true")]
            [CompoundCase("ThreeByteDifferentGreater",   new byte[]{0x01, 0x7f, 0xf4},       new byte[]{0x01, 0x7f, 0xf5},       "false")]
            [CompoundCase("FourByteDifferentTopLess",    new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x70, 0x13, 0x37, 0x60}, "true")]
            [CompoundCase("FourByteDifferentTopGreater", new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x90, 0x13, 0x37, 0x60}, "false")]
            [CompoundCase("FourByteDifferentBotLess",    new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x80, 0x13, 0x37, 0x5f}, "true")]
            [CompoundCase("FourByteDifferentBotGreater", new byte[]{0x80, 0x13, 0x37, 0x60}, new byte[]{0x80, 0x13, 0x37, 0x61}, "false")]
            [CompoundCase("PassNull",                    new byte[]{0x00},                   null,                               "System.FormatException", BugID=63229, BugDatabase="TFS")]
            [CompoundCase("PassInvalid",                 new byte[]{0x00},                   "*~woops~*",                        "System.FormatException")]
            public void ClaimBase64Binary(TestNode self)
            {
                string claimValue;
                string passValue;
                string expect=(string)self.MyValues[2];

                if (self.MyValues[0]==null)
                {
                    claimValue=null;
                }
                else if (self.MyValues[0] is byte[])
                {
                    claimValue=System.Convert.ToBase64String((byte[])self.MyValues[0]);
                }
                else
                {
                    claimValue=(string)self.MyValues[0];
                }

                if (self.MyValues[1]==null)
                {
                    passValue=null;
                }
                else if (self.MyValues[1] is byte[])
                {
                    passValue=System.Convert.ToBase64String((byte[])self.MyValues[1]);
                }
                else
                {
                    passValue=(string)self.MyValues[1];
                }

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/base64binarytest", claimValue, ClaimValueTypes.Base64Binary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/base64binarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a HexBinary type.")]
            [CompoundCase("ZeroByteSame",            "",                                                               "",                                                               "false")]
            [CompoundCase("ZeroByteClaimPassOne",    "",                                                               "FF",                                                             "false")]
            [CompoundCase("OneByteSame",             "0A",                                                             "0A",                                                             "false")]
            [CompoundCase("OneByteGreater",          "0A",                                                             "0B",                                                             "false")]
            [CompoundCase("OneByteGreaterPassLower", "0A",                                                             "0b",                                                             "false")]
            [CompoundCase("OneByteLess",             "FF",                                                             "FE",                                                             "true")]
            [CompoundCase("OneByteLessPassLower",    "FF",                                                             "Fe",                                                             "true")]
            [CompoundCase("ManyByteSame",            "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("ManyByteTopLess",         "1102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "true")]
            [CompoundCase("ManyByteTopGreater",      "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "1102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("ManyByteBotLess",         "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFE", "true")]
            [CompoundCase("ManyByteBotGreater",      "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFE", "0102030405060708090A0B0C0D0E0FF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF", "false")]
            [CompoundCase("PassShorter",             "020102030405060708090A0B0C0D0E0F",                               "0102030405060708090A0B0C0D0E0F",                                 "true")]
            [CompoundCase("PassLonger",              "000102030405060708090A0B0C0D0E0F",                               "000102030405060708090A0B0C0D0E0F00",                             "false")]
            [CompoundCase("PassEmpty",               "FF0000DD",                                                       "",                                                               "true")]
            [CompoundCase("PassNull",                "FF0000DD",                                                       null,                                                             "System.FormatException", BugID=63229, BugDatabase="TFS")]
            [CompoundCase("PassInvalidChars",        "FF0000DD",                                                       "0wtf",                                                           "System.FormatException")]
            [CompoundCase("PassInvalidLength",       "000",                                                            "0",                                                              "true")] // values are extended to the nearest byte
            [CompoundCase("PassEquivilentLength",    "00",                                                             "0",                                                              "false")] // values are extended to the nearest byte
            [CompoundCase("PassInvalidPrefix",       "FF0000DD",                                                       "0xFF0000DD",                                                     "false")] // the canonical representation is emitted (no 0x)
            public void ClaimHexBinary(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/hexbinarytest", claimValue, ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/hexbinarytest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a DateTime type.")]
            [CompoundCase("SameDateUtcZone",           "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.78Z",      "false")]
            [CompoundCase("LessDateUtcZone",           "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.77Z",      "true")]
            [CompoundCase("GreaterDateUtcZone",        "1234-01-23T23:45:56.78Z",  "1234-01-23T23:45:56.79Z",      "false")]
            [CompoundCase("LessEarlyDateUtcZone",      "0003-01-23T23:45:56.78Z",  "0003-01-23T23:45:56.77Z",      "true")] // we are bound to valide Date.Parse ranges
            [CompoundCase("GreaterEarlyDateUtcZone",   "0005-01-23T23:45:56.78Z",  "0005-01-23T23:45:56.79Z",      "false")] // we are bound to valide Date.Parse ranges
            [CompoundCase("LessFutureDateUtcZone",     "9876-01-23T23:45:56.79Z",  "9876-01-23T23:45:56.78Z",      "true")] // we are bound to valide Date.Parse ranges
            [CompoundCase("GreaterFutureDateUtcZone",  "9998-01-23T23:45:56.78Z",  "9998-01-23T23:45:56.79Z",      "false")] // we are bound to valide Date.Parse ranges
            [CompoundCase("LessDateDifferentZones",    "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.77+01:00", "true")]
            [CompoundCase("GreaterDateDifferentZones", "1234-01-23T22:45:56.78Z",  "1234-01-23T23:45:56.79+01:00", "false")]
            [CompoundCase("LessDateNoZoneTooClose",    "1234-01-23T23:45:56.78Z",  "1234-01-23T20:45:56.78",       "false", BugID=76462, BugDatabase="TFS")] //since there is a 14 hour window of possibilities, we return false to be safe since the answer "could" be no
            [CompoundCase("LessDateNoZoneFarEnough",   "1234-01-23T23:45:56.78Z",  "1234-01-21T23:45:56.78",       "true", BugID=76462, BugDatabase="TFS")] //since there is a 14 hour window of possibilities, we return false to be safe since the answer "could" be no
            [CompoundCase("InvalidDate",               "1234-01-23T23:45:56.78Z",  "The day before yesterday",     "System.FormatException")]
            public void ClaimDateTime(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/datetimetest", claimValue, ClaimValueTypes.Datetime);
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/datetimetest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a Decimal type.")]
            [CompoundCase("SameIntegerWithPointAndZero",    "7.0",              "7.0",             "false")]
            [CompoundCase("LessIntegerWithPointAndZero",    "7.0",              "6.9",             "true")]
            [CompoundCase("GreaterIntegerWithPointAndZero", "7.0",              "7.1",             "false")]
            [CompoundCase("SameIntegerWithPoint",           "7.",               "7.",              "false")]
            [CompoundCase("LessIntegerWithPoint",           "7.",               "6.",              "true")]
            [CompoundCase("GreaterIntegerWithPoint",        "7.",               "8.",              "false")]
            [CompoundCase("SameIntegerNoPoint",             "7",                "7",               "false")]
            [CompoundCase("LessIntegerNoPoint",             "7",                "6",               "true")]
            [CompoundCase("GreaterIntegerNoPoint",          "7",                "8",               "false")]
            [CompoundCase("SamePositiveDecimalWithZero",    "0.7",              "0.7",             "false")]
            [CompoundCase("LessPositiveDecimalWithZero",    "0.7",              "0.6",             "true")]
            [CompoundCase("GreaterPositiveDecimalWithZero", "0.7",              "0.8",             "false")]
            [CompoundCase("SamePositiveDecimalNoZero",      ".7",               ".7",              "false")]
            [CompoundCase("LessPositiveDecimalNoZero",      ".7",               ".6",              "true")]
            [CompoundCase("GreaterPositiveDecimalNoZero",   ".7",               ".8",              "false")]
            [CompoundCase("SameNumberPassPlus",            "0.7",              "+0.7",             "false")]
            [CompoundCase("LessNumberPassPlus",            "0.7",              "+0.6",             "true")]
            [CompoundCase("GreaterNumberPassPlus",         "0.7",              "+0.8",             "false")]
            [CompoundCase("SameNegativeDecimal",           "-0.7",             "-0.7",             "false")]
            [CompoundCase("LessNegativeDecimal",           "-0.7",             "-0.8",             "true")]
            [CompoundCase("GreaterNegativeDecimal",        "-0.7",             "-0.6",             "false")]
            [CompoundCase("SameNumberPassExtraZeros",      "0.7",              "00.70",            "false")]
            [CompoundCase("LessNumberPassExtraZeros",      "0.7",              "00.60",            "true")]
            [CompoundCase("GreaterNumberPassExtraZeros",   "0.7",              "00.80",            "false")]
            [CompoundCase("ZeroDifferentSign",             "0",                "-0",               "false")]
            [CompoundCase("LessBigAndClose",               "99999999.9999999", "99999999.9999998", "true")]
            [CompoundCase("GreaterBigAndClose",            "99999999.9999998", "99999999.9999999", "false")]
            [CompoundCase("InvalidNotation",               "10",               "10E+10",           "System.FormatException")] //sci notation is not allowed
            [CompoundCase("InvalidNumber",                 "0",                "wtf",              "System.FormatException")]
            [CompoundCase("InvalidEmpty",                  "0",                "",                 "System.FormatException")]
            [CompoundCase("InvalidNull",                   "0",                null,               "System.FormatException")]
            public void ClaimDecimal(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/decimaltest", claimValue, "http://www.w3.org/2001/XMLSchema#decimal");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/decimaltest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IPAddress type.  Saying greater than is nonsense, always expect false.")]
            [CompoundCase("IdenticalIPV6LongNoPort",     "1234:5678:9abc:def0:1234:5678:9abc:def0", "1234:5678:9abc:def0:1234:5678:9abc:def0",   "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6ShortNoPort",    "3:0:7:a:f:5:f:a",                         "3:0:7:a:f:5:f:a",                           "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6BracketsNoPort", "1234:5678:9abc:def0:1234:5678:9abc:def0", "[1234:5678:9abc:def0:1234:5678:9abc:def0]", "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1237:a:f:1235:f:a32f]:65535",         "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV6SamePort",       "[a3:0:1237:a:f:1235:f:a32f]:1234",       "[a3:0:1237:a:f:1235:f:a32f]:01234",          "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4LongNoPort",     "123.124.234.235",                         "123.124.234.235",                           "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4ShortNoPort",    "1.2.3.4",                                 "1.2.3.4",                                   "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.234.35:65535",                       "System.InvalidOperationException")]
            [CompoundCase("IdenticalIPV4SamePort",       "12.124.234.35:1234",                     "12.124.234.35:01234",                        "System.InvalidOperationException")]
            [CompoundCase("SameIPV6NoPort",              "234:5678:9abc:def0:1234:678:9abc:def0",   "0234:5678:9abc:def0:1234:0678:9abc:def0",   "System.InvalidOperationException")]
            [CompoundCase("SameIPV6IdenticalPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5535",       "System.InvalidOperationException")]
            [CompoundCase("SameIPV6SamePort",            "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:05535",      "System.InvalidOperationException")]
            [CompoundCase("SameIPV6DifferentPort",       "[a3:0:1237:a:f:1235:f:a32f]:5535",        "[a3:0000:1237:a:f:1235:f:a32f]:5534",       "System.InvalidOperationException")]
            [CompoundCase("SameIPV6MissingPort",         "[a3:0:1237:a:f:1235:f:a32f]:5535",        "a3:0000:1237:a:f:1235:f:a32f",              "System.InvalidOperationException")]
            [CompoundCase("SameIPV4NoPort",              "1.2.3.4",                                 "1.2.3.004",                                 "System.InvalidOperationException")]
            [CompoundCase("SameIPV4IdenticalPort",       "12.124.234.29:5535",                      "12.124.234.035:5535",                       "System.InvalidOperationException")]
            [CompoundCase("SameIPV4SamePort",            "12.124.234.29:5535",                      "12.124.234.035:05535",                      "System.InvalidOperationException")]
            [CompoundCase("SameIPV4DifferentPort",       "12.124.234.29:5535",                      "12.124.234.035:5534",                       "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6NoPort",         "3:0:7:a:f:5:f:a",                         "3:0:8:a:f:5:f:a",                           "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6IdenticalPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65535",         "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV6DifferentPort",  "[a3:0:1237:a:f:1235:f:a32f]:65535",       "[a3:0:1238:a:f:1235:f:a32f]:65534",         "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4NoPort",         "1.2.3.4",                                 "1.2.5.4",                                   "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4IdenticalPort",  "12.124.234.35:65535",                     "12.124.235.35:65535",                       "System.InvalidOperationException")]
            [CompoundCase("DifferentIPV4DifferentPort",  "12.124.234.35:65535",                     "12.124.235.35:65534",                       "System.InvalidOperationException")]
            [CompoundCase("InvalidIpNumber",             "12.124.234.35:65535",                     "12.124.234.935:65535",                      "System.InvalidOperationException")]
            [CompoundCase("InvalidPort",                 "12.124.234.35:65535",                     "12.124.234.35:965535",                      "System.InvalidOperationException")]
            [CompoundCase("InvalidIpFormat",             "12.124.234.35:65535",                     "wtf",                                       "System.InvalidOperationException")]
            [CompoundCase("InvalidEmpty",                "12.124.234.35:65535",                     "",                                          "System.InvalidOperationException")]
            [CompoundCase("InvalidNull",                 "12.124.234.35:65535",                     null,                                        "System.InvalidOperationException")]
            public void CustomClaimIPAddress(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/ipaddresstest", claimValue, "http://schemas.microsoft.com/xbox/types#IpAddress");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/ipaddresstest", passValue, null);
                VerifyResult(expect, ret);
            }

            [TestCase, Description("Claim is a our custom IntegerArray type.  Saying greater than is nonsense, always expect invalid operation exception.")]
            [CompoundCase("SameOneEntry",             "12345",      "12345",      "System.InvalidOperationException")]
            [CompoundCase("PassEmpty",                "1 2 3",      "",           "System.InvalidOperationException")]
            [CompoundCase("PassNull",                 "1 2 3",      null,         "System.InvalidOperationException")]
            public void CustomClaimIntegerArray(TestNode self)
            {
                string claimValue=(string)self.MyValues[0];
                string passValue=(string)self.MyValues[1];
                string expect=(string)self.MyValues[2];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/integerarraytest", claimValue, "http://schemas.microsoft.com/xbox/types#IntegerArray");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallVerifyOperator("greaterthan", "http://example.com/integerarraytest", passValue, null);
                VerifyResult(expect, ret);
            }
        }; //class GreaterThan

        [TestGroup, Description("Tests for AuthHelper.FindClaim")]
        public class FindClaim: TestNode
        {
            [TestCase]
            public void SingleClaim_Integer()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "true", result.Result);
                ValueCheck.Test("ClaimType", Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, result.ClaimType);
                ValueCheck.Test("Issuer", "xsts.xboxlive.com", result.Issuer);
                ValueCheck.Test("OriginalIssuer", "xsts.xboxlive.com", result.OriginalIssuer);
                ValueCheck.Test("Value", "103", result.Value);
                ValueCheck.Test("ValueType", ClaimValueTypes.Integer, result.ValueType);
            }

            [TestCase]
            public void SingleClaim_String()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Old Enough");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "true", result.Result);
                ValueCheck.Test("ClaimType", Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, result.ClaimType);
                ValueCheck.Test("Issuer", "xsts.xboxlive.com", result.Issuer);
                ValueCheck.Test("OriginalIssuer", "xsts.xboxlive.com", result.OriginalIssuer);
                ValueCheck.Test("Value", "Old Enough", result.Value);
                ValueCheck.Test("ValueType", ClaimValueTypes.String, result.ValueType);
            }

            [TestCase]
            public void SingleClaim_IntegerArray()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Privileges, "128 160 255");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Privileges, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "true", result.Result);
                ValueCheck.Test("ClaimType", Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Privileges, result.ClaimType);
                ValueCheck.Test("Issuer", "xsts.xboxlive.com", result.Issuer);
                ValueCheck.Test("OriginalIssuer", "xsts.xboxlive.com", result.OriginalIssuer);
                ValueCheck.Test("Value", "128 160 255", result.Value);
                ValueCheck.Test("ValueType", Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes.IntegerArray, result.ValueType);
            }

            [TestCase, Description("Token has many claims.  Find one.")]
            public void MultipleClaims()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, "1234");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceType, "Xbox361");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "7");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Gamertag, "Tiger");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Tier, "Diamond");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Old Enough");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "9");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, "123456");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Status, "Coming In Hot");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "true", result.Result);
                ValueCheck.Test("ClaimType", Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, result.ClaimType);
                ValueCheck.Test("Issuer", "xsts.xboxlive.com", result.Issuer);
                ValueCheck.Test("OriginalIssuer", "xsts.xboxlive.com", result.OriginalIssuer);
                ValueCheck.Test("Value", "Old Enough", result.Value);
                ValueCheck.Test("ValueType", ClaimValueTypes.String, result.ValueType);
            }

            [TestCase]
            public void NoToken()
            {
                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "false", result.Result);
            }

            [TestCase]
            public void TokenWithDifferentClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Status, "Coming In Hot");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "false", result.Result);
            }

            [TestCase]
            public void PassNull()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Old Enough");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(null, null);

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "false", result.Result);
            }

            [TestCase]
            public void DifferentIssuer()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Old Enough");
                string tokenString=generatedToken.ToString();

                CodeClientBase client=CodeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.CallFindClaim(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "NinjaPartner");

                FindClaimResult result=ParseFindClaimResult(ret);
                ValueCheck.Test("Result", "false", result.Result);
            }
        }; //class FindClaim
    }; //class Code
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\AttributeService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for policy configured in using attributes on webmethods."), AsyncGroup(0, 1)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    public class Attribute: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("Platforms_None allows no platforms at all.  So nobody can call it.  Ever.")]
        public class Platforms_None: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Platforms_None();
            }

            [TestCase, Description("Token contains an unrelated claim.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/favoritecolor", "green", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_None();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWithAPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_None();
            }
        }; //class Platforms_None

        [TestGroup, Description("Platforms_Xbox360 requires that the platform type is xbox360.")]
        public class Platforms_Xbox360: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Platforms_Xbox360();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360();
            }
        }; //class Platforms_Xbox360

        [TestGroup, Description("Platforms_Xbox360_Pc requires that the platform type is either xbox360 or pc.")]
        public class Platforms_Xbox360_Pc: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Platforms_Xbox360_Pc();
            }

            [TestCase, Description("Token contains an unrelated claim.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/favoritecolor", "green", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360_Pc();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Web");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360_Pc();
            }

            [TestCase, Description("Token contains the correct platform.")]
            [CompoundCase("{0}", "Xbox360")]
            [CompoundCase("{0}", "PC")]
            public void TokenRightPlatform(TestNode self)
            {
                string platformInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", platformInToken);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360_Pc();
            }
        }; //class Platforms_Xbox360_Pc

        [TestGroup, Description("Titles_FFFE07D1 requires that the title is 0xfffe07d1.")]
        public class Titles_FFFE07D1: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Token contains the correct title.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class Titles_FFFE07D1

        [TestGroup, Description("Titles_FFFE07D1_00112233_FFAA7700 requires the title to be one of 0xFFFE07D1, 0x00112233, or 0xFFAA7700")]
        public class Titles_FFFE07D1_00112233_FFAA7700: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Titles_FFFE07D1_00112233_FFAA7700();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/animals/tigercount", "7", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1_00112233_FFAA7700();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1_00112233_FFAA7700();
            }

            [TestCase, Description("Token contains the correct title.")]
            [CompoundCase("{0:X}", "4294838225")]
            [CompoundCase("{0:X}", "1122867")]
            [CompoundCase("{0:X}", "4289361664")]
            public void TokenRightTitle(TestNode self)
            {
                string titleInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", titleInToken);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1_00112233_FFAA7700();
            }
        }; //class Titles_FFFE07D1_00112233_FFAA7700

        [TestGroup, Description("Privileges_None requires no privileges to be present.  So everything is ok.")]
        public class Privileges_None: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.Privileges_None();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/machine/greatness", "42", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_None();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_None();
            }

            [TestCase, Description("Token does not contain any of the priveleges needed but contains another privilege.")]
            public void TokenWithPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "233");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_None();
            }
        }; //class Privileges_None

        [TestGroup, Description("Privileges_254 requires that privilege 254 is present.")]
        public class Privileges_254: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges_254();
            }

            [TestCase, Description("Calls the API alternating providing a token and not providing a token.")]
            public void AlternatingTokenAndNoToken()
            {
                for (int i = 0; i < 10; ++i)
                {
                    //no token
                    {
                        AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                        client.ExpectedHttpResponseCode = 403;
                        client.Privileges_254();
                    }

                    //with token
                    {
                        XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                        generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                        string tokenString = generatedToken.ToString();

                        AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                        client.AddClaimToken(tokenString);
                        client.Privileges_254();
                    }
                }
            }
            
            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains only the privilege.")]
            public void TokenWithOnlyPrivelege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains the privilege and some others.")]
            public void TokenWithAdditionalPriveleges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222 254 255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains the privilege and some others but the privelege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }
        }; //class Privileges_254

        [TestGroup, Description("Privileges_128_160_255 requires that all of privileges 128(a machine privilege), 160(a user privilege), and 255(a user privelege) be present.")]
        class Privileges_128_160_255: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/machine/greatness", "42", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token does not contain any of the priveleges needed but contains another privilege.")]
            public void TokenWithUnrelatedPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "233");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token with 1 of the 3 priviliges that are needed.")]
            public void TokenWithOneRequiredPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token with 2 of the 3 priviliges that are needed.")]
            public void TokenWithTwoRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128 255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token with all 3 of the 3 priviliges that are needed.")]
            public void TokenWithAllRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128 160 255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token with all 3 of the 3 priviliges that are needed, but in a different order.")]
            public void TokenWithAllRequiredPrivilegesDifferentOrder()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255 128 160");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }

            [TestCase, Description("Token with all 3 of the 3 priviliges that are needed and more.")]
            public void TokenWithAllRequiredPrivilegesAndMore()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128 129 130 131 132 133 134 135 136 137 138 139 158 159 160 161 191 192 193 252 253 254 255");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_128_160_255();
            }
        }; //class Privileges_128_160_255

        [TestGroup, Description("Privileges_192_193 requires that privileges 192 and 193 be present.")]
        class Privileges_192_193: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges_192_193();
            }

            [TestCase, Description("Token does not contain any of the priveleges needed but contains another privilege.")]
            public void TokenWithUnrelatedPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "233");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_192_193();
            }

            [TestCase, Description("Token with 1 of the 3 priviliges that are needed.")]
            public void TokenWithOneRequiredPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "192");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_192_193();
            }

            [TestCase, Description("Token with all priviliges that are needed.")]
            public void TokenWithAllRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "192 193");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_192_193();
            }
        }; //class Privileges_192_193

        [TestGroup, Description("RequiresClaim_Tiger requires that tiger claim is present.")]
        class RequiresClaim_Tiger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("The lion claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("The tiger claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }
        }; //class RequiresClaim_Tiger

        [TestGroup, Description("RequiresClaim_Lion_Tiger_Ocelot requires that all of the tiger, lion, and ocelot claims are present.")]
        class RequiresClaim_Lion_Tiger_Ocelot: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaim_Lion_Tiger_Ocelot();
            }

            [TestCase, Description("The cougar claim is present instead.")]
            public void UnrelatedPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/cougar", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Lion_Tiger_Ocelot();
            }

            [TestCase, Description("The tiger claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Lion_Tiger_Ocelot();
            }

            [TestCase, Description("The lion, tiger, and ocelot claims are present.")]
            public void AllRequiredPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "3", ClaimValueTypes.Integer);
                generatedToken.AddAttribute("http://example.com/ocelot", "hello", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Lion_Tiger_Ocelot();
            }

            [TestCase, Description("The lion, tiger, and ocelot claims are present, in addition to something else.")]
            public void ExtraPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "3", ClaimValueTypes.Integer);
                generatedToken.AddAttribute("http://example.com/cougar", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/ocelot", "hello", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Lion_Tiger_Ocelot();
            }

        }; //class RequiresClaim_Lion_Tiger_Ocelot

        [TestGroup, Description("Require the age group to be elder or ancient using AllowedValues.")]
        public class AllowedValues_Strings: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AllowedValues_Strings();
            }

            [TestCase, Description("Token contains an unrelated claim.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/magic/number", "42", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AllowedValues_Strings();
            }

            [TestCase, Description("Age group is different.")]
            public void WrongAgeGroup()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "TooYoungForYou");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AllowedValues_Strings();
            }

            [TestCase, Description("Age group is correct.")]
            [CompoundCase("{0}", "Elder")]
            [CompoundCase("{0}", "Ancient")]
            public void MatchingAgeGroup(TestNode self)
            {
                string ageGroup=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, ageGroup);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.AllowedValues_Strings();
            }
        }; //class AllowedValues_Strings

        [TestGroup, Description("Require the age group to be elder using AuthEquals.")]
        public class AuthEquals_StringAgeGroupElder: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthEquals_StringAgeGroupElder();
            }

            [TestCase, Description("Token contains an unrelated claim.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/magic/number", "42", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder();
            }

            [TestCase, Description("Age group is different.")]
            public void WrongAgeGroup()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "TooYoungForYou");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder();
            }

            [TestCase, Description("Age group is correct.")]
            public void MatchingAgeGroup()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder();
            }
        }; //class AuthEquals_StringAgeGroupElder

        [TestGroup, Description("Require the age group to be elder and language to be 1337 using AuthEquals.")]
        public class AuthEquals_StringAgeGroupElder_IntegerLanguage1337: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }

            [TestCase, Description("Token contains an unrelated claim.")]
            public void TokenWithUnrelatedClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/magic/number", "42", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }

            [TestCase, Description("Age group is different but language matches.")]
            public void RightAgeGroupMissingLanguage()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }

            [TestCase, Description("Age group is right but language is wrong.")]
            public void RightAgeGroupWrongLanguage()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "1234");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }

            [TestCase, Description("Age group is wrong but language is right.")]
            public void WrongAgeGroupRightLanguage()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "NotVeryOld");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "1337");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }

            [TestCase, Description("Age and language mateches")]
            public void RightAgeRightLanguage()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder");
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "1337");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.AuthEquals_StringAgeGroupElder_IntegerLanguage1337();
            }
        }; //class AuthEquals_StringAgeGroupElder_IntegerLanguage1337

        [TestGroup, Description("Verifies that the AuthEquals on a xuid works correctly.  It expects 0x0011223344221100.")]
        public class AuthEquals_Xuid: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthEquals_Xuid();
            }

            [TestCase, Description("Xuid is a totally different value.")]
            public void WrongXuid_UnrelatedValue()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, "ff112233442211ff");
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_Xuid();
            }

            [TestCase, Description("Xuid doesn't match.")]
            public void WrongXuid_SimilarValue(TestNode self)
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, 0x0011223344222200.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.AuthEquals_Xuid();
            }

            [TestCase, Description("Xuid matches.")]
            public void CorrectXuid()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, 0x0011223344221100.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.AuthEquals_Xuid();
            }
        }; //class AuthEquals_Xuid

        [TestGroup, Description("Verifies a value is greater than 28.")]
        public class AuthGreaterThan_PositiveInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthGreaterThan_PositiveInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 403)]
            [CompoundCase("{0}", "-27", 403)]
            [CompoundCase("{0}", "-28", 403)]
            [CompoundCase("{0}", "-29", 403)]
            [CompoundCase("{0}", "0",   403)]
            [CompoundCase("{0}", "27",  403)]
            [CompoundCase("{0}", "28",  403)]
            [CompoundCase("{0}", "29",  200)]
            [CompoundCase("{0}", "999999999999999999",  200)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthGreaterThan_PositiveInteger();
            }
        }; //class AuthGreaterThan_PositiveInteger

        [TestGroup, Description("Verifies a value is greater than 0.")]
        public class AuthGreaterThan_ZeroInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthGreaterThan_ZeroInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 403)]
            [CompoundCase("{0}", "-1", 403)]
            [CompoundCase("{0}", "0",  403)]
            [CompoundCase("{0}", "1",  200)]
            [CompoundCase("{0}", "999999999999999999",  200)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthGreaterThan_ZeroInteger();
            }
        }; //class AuthGreaterThan_ZeroInteger

        [TestGroup, Description("Verifies a value is greater than -28.")]
        public class AuthGreaterThan_NegativeInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthGreaterThan_NegativeInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 403)]
            [CompoundCase("{0}", "-29", 403)]
            [CompoundCase("{0}", "-28", 403)]
            [CompoundCase("{0}", "-27", 200)]
            [CompoundCase("{0}", "0",   200)]
            [CompoundCase("{0}", "27",  200)]
            [CompoundCase("{0}", "28",  200)]
            [CompoundCase("{0}", "29",  200)]
            [CompoundCase("{0}", "999999999999999999",  200)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthGreaterThan_NegativeInteger();
            }
        }; //class AuthGreaterThan_NegativeInteger

        [TestGroup, Description("Verifies a value is greater than the string lllll.")]
        public class AuthGreaterThan_String: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthGreaterThan_String();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "lllll", 403)]
            [CompoundCase("{0}", "llllk", 403)]
            [CompoundCase("{0}", "llllm", 200)]
            [CompoundCase("{0}", "kllll", 403)]
            [CompoundCase("{0}", "mllll", 200)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/string", valueInToken, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthGreaterThan_String();
            }
        }; //class AuthGreaterThan_String

        [TestGroup, Description("Verifies a value is less than 28.")]
        public class AuthLessThan_PositiveInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthLessThan_PositiveInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 200)]
            [CompoundCase("{0}", "-27", 200)]
            [CompoundCase("{0}", "-28", 200)]
            [CompoundCase("{0}", "-29", 200)]
            [CompoundCase("{0}", "0",   200)]
            [CompoundCase("{0}", "27",  200)]
            [CompoundCase("{0}", "28",  403)]
            [CompoundCase("{0}", "29",  403)]
            [CompoundCase("{0}", "999999999999999999",  403)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthLessThan_PositiveInteger();
            }
        }; //class AuthLessThan_PositiveInteger

        [TestGroup, Description("Verifies a value is less than 0.")]
        public class AuthLessThan_ZeroInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthLessThan_ZeroInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 200)]
            [CompoundCase("{0}", "-1", 200)]
            [CompoundCase("{0}", "0",  403)]
            [CompoundCase("{0}", "1",  403)]
            [CompoundCase("{0}", "999999999999999999",  403)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthLessThan_ZeroInteger();
            }
        }; //class AuthLessThan_ZeroInteger

        [TestGroup, Description("Verifies a value is less than -28.")]
        public class AuthLessThan_NegativeInteger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthLessThan_NegativeInteger();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "-999999999999999999", 200)]
            [CompoundCase("{0}", "-29", 200)]
            [CompoundCase("{0}", "-28", 403)]
            [CompoundCase("{0}", "-27", 403)]
            [CompoundCase("{0}", "0",   403)]
            [CompoundCase("{0}", "27",  403)]
            [CompoundCase("{0}", "28",  403)]
            [CompoundCase("{0}", "29",  403)]
            [CompoundCase("{0}", "999999999999999999",  403)]
            [CompoundCase("Invalid", "wtf", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/int", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthLessThan_NegativeInteger();
            }
        }; //class AuthLessThan_NegativeInteger

        [TestGroup, Description("Verifies a value is less than the string lllll.")]
        public class AuthLessThan_String: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AuthLessThan_String();
            }

            [TestCase, Description("Pass values in the token.")]
            [CompoundCase("{0}", "lllll", 403)]
            [CompoundCase("{0}", "llllk", 200)]
            [CompoundCase("{0}", "llllm", 403)]
            [CompoundCase("{0}", "kllll", 200)]
            [CompoundCase("{0}", "mllll", 403)]
            public void Values(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];
                int expectedHttpResult=(int)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/string", valueInToken, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.AuthLessThan_String();
            }
        }; //class AuthLessThan_String

        [TestGroup, Description("Various parameter types excercising the VerifyUser parameter validation.")]
        public class VerifyUser: TestNode
        {
            [TestGroup, Description("Variation of VerifyUser that takes an unsigned long.")]
            public class UnsignedLong: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.UserParameter_UnsignedLong(0x0900123456789012);
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_UnsignedLong(0x0900123456789012);
                }

                [TestCase, Description("Pass null.")]
                public void NoValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    ProtocolToUse protocol=(ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client=AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=(protocol == ProtocolToUse.Wcf)? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_UnsignedLong(null);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void OneUserWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.UserParameter_UnsignedLong(0x0900123456789012);
                }

                [TestCase, Description("Provide a token with several users, one of which matches.  Multiple users are not supported.")]
                public void MultipleUsersWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789011.ToString() + " " + 0x0900123456789012.ToString() + " " + 0900123456789013.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_UnsignedLong(0x0900123456789012);
                }
            }; //class UnsignedLong

            [TestGroup, Description("Variation of VerifyUser that takes a nullable unsigned long.")]
            public class NullableUnsignedLong: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.UserParameter_NullableUnsignedLong(0x0900123456789012);
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch_Value()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_NullableUnsignedLong(0x0900123456789012);
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch_Null()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    ProtocolToUse protocol=(ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client=AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=(protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_NullableUnsignedLong(null);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void OneUserWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.UserParameter_NullableUnsignedLong(0x0900123456789012);
                }
            }; //class NullableUnsignedLong

            [TestGroup, Description("Variation of VerifyUser that takes a signed long.")]
            public class SignedLong: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.UserParameter_SignedLong(unchecked((long)0x0900123456789012));
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_SignedLong(unchecked((long)0x0900123456789012));
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void OneUserWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.UserParameter_SignedLong(unchecked((long)0x0900123456789012));
                }
            }; //class SignedLong

            [TestGroup, Description("Variation of VerifyUser that takes a string.")]
            public class String: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.UserParameter_String("0900123456789012");
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_String(0x0900123456789012.ToString());
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void OneUserWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.UserParameter_String(0x0900123456789012.ToString());
                }

                [TestCase, Description("Provide a token with a matching id.  Use hex value with prefix for a decimal integer.")]
                public void WithHexPrefix()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_String("0x0900123456789012");
                }
            }; //class String

            [TestGroup, Description("Variation of VerifyUser that takes a byte array.")]
            public class Binary: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.UserParameter_Binary(Hexer.unhex("0x0900123456789012"));
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void OneUserNoMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_Binary(Hexer.unhex("0x0900123456789012"));
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void OneUserWithMatch()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_Binary(Hexer.unhex("0x0900123456789012"));
                }

                [TestCase, Description("Pass null.")]
                public void NoValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900323456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_Binary(null);
                }

                [TestCase, Description("Pass a 0 byte array.")]
                public void EmptyArray()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_Binary(new byte[0]);
                }

                [TestCase, Description("Pass an array bigger than 8 bytes.")]
                public void PassArrayBiggerThanId()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", 0x0900123456789012.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.UserParameter_Binary(Hexer.unhex("0xff0900123456789012"));
                }
            }; //class Binary
        }; //class VerifyUser

        [TestGroup, Description("Various parameter types excercising the VerifyMachine parameter validation.")]
        public class VerifyMachine: TestNode
        {
            [TestGroup, Description("Variation that takes an unsigned long.")]
            public class UnsignedLong: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.MachineParameter_UnsignedLong(0xfa00000000000001);
                }

                [TestCase, Description("Provide a token with an id, but pass no value.")]
                public void NoValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, "FA00000000000007");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_UnsignedLong(null);
                }

                [TestCase, Description("Provide a token with a different id.")]
                public void DifferentValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, "FA00000000000007");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_UnsignedLong(0xfa00000000000001);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, "FA00000000000001");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_UnsignedLong(0xfa00000000000001);
                }
            }; //class UnsignedLong

            [TestGroup, Description("Variation that takes a string.")]
            public class String: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.MachineParameter_String("fa00000000000001");
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", "1")]
                [CompoundCase("{0}", "720575940379279361")]
                [CompoundCase("{0}", "0xFFFFFFFFFFFFFFFF")]
                [CompoundCase("EmptyString", "")]
                [CompoundCase("null", null)]
                public void DifferentValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, 0xFA00000000000001.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_String(valueToPass);
                }

                [TestCase, Description("Provide a token with an illegal value.")]
                [CompoundCase("{0}", "0xnotvalid")]
                [CompoundCase("{0}", "invalid")]
                public void IllegalValue(TestNode self)
                {
                    string valueToPass = (string)self.MyValues[0];

                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, 0xFA00000000000001.ToString());
                    string tokenString = generatedToken.ToString();

                    AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_String(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                [CompoundCase("HexPrefix", "0xFA00000000000001")]
                [CompoundCase("UpperCase", "FA00000000000001")]
                [CompoundCase("LowerCase", "fa00000000000001")]
                public void MatchingValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, "FA00000000000001");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.MachineParameter_String(valueToPass);
                }
            }; //class String
        }; //class VerifyMachine

        [TestGroup, Description("Various parameter types excercising the VerifyTitle parameter validation.")]
        public class VerifyTitle: TestNode
        {
            [TestGroup, Description("Variation that takes an unsigned int.")]
            public class UnsignedInt: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.TitleParameter_UnsignedInt(0xFFFE07D2);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (uint)0)]
                [CompoundCase("{0:X}", 0x8FFE07D2)]
                [CompoundCase("{0:X}", 0xFFFE07D1)]
                public void DifferentValue(TestNode self)
                {
                    uint? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(uint)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedInt(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                public void NullValue()
                {
                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString = generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedInt(null);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedInt(0xfffe07d2);
                }
            }; //class UnsignedInt

            [TestGroup, Description("Variation that takes an signed int.")]
            public class SignedInt: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.TitleParameter_SignedInt(unchecked((int)0xFFFE07D2));
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (int)0)]
                [CompoundCase("{0:X}", 0x7FFE07D2)]
                [CompoundCase("{0:X}", unchecked((int)0xFFFE07D1))]
                public void DifferentValue(TestNode self)
                {
                    int? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(int)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_SignedInt(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                public void NullValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_SignedInt(null);
                }
                

                [TestCase, Description("Provide a token with 4-byte value but as a negative integer id.")]
                public void NegativeValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_SignedInt(unchecked((int)0xfffe07d2));
                }
            }; //class SignedInt

            [TestGroup, Description("Variation that takes an unsigned long.")]
            public class UnsignedLong: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.TitleParameter_UnsignedLong(0xFFFE07D2);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (ulong)0)]
                [CompoundCase("{0:X}", (ulong)0x8FFE07D2)]
                [CompoundCase("{0:X}", (ulong)0xFFFE07D1)]
                [CompoundCase("{0:X}", 0xFFFFFFFFFFFE07D1)]
                public void DifferentValue(TestNode self)
                {
                    ulong? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(ulong)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedLong(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                [CompoundCase("null", null)]
                public void NullValue(TestNode self)
                {
                    ulong? valueToPass = null;
                    if (self.MyValues[0] != null)
                    {
                        valueToPass = (ulong)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString = generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));

                    // you can't pass null to a non-nullable parameter.   In this case
                    // SOAP is "helping" and converting the null into a zero.  As such
                    // there is no 500 tripping on the null,  we fail  the  comparison

                    client.ExpectedHttpResponseCode=(protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedLong(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_UnsignedLong(0xfffe07d2);
                }
            }; //class UnsignedLong

            [TestGroup, Description("Variation that takes a string.")]
            public class String: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.TitleParameter_String(0xFFFE07D2.ToString());
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", "26")]
                [CompoundCase("{0}", "74294838226")]
                public void DifferentValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_String(valueToPass);
                }

                [TestCase, Description("Provide a token with a illegal id.")]
                [CompoundCase("{0}", "4294838226.0")]
                [CompoundCase("{0}", "0wtf")]
                [CompoundCase("EmptyString", "")]
                [CompoundCase("null", null)]
                public void IllegalValue(TestNode self)
                {
                    string valueToPass = (string)self.MyValues[0];

                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString = generatedToken.ToString();

                    AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_String(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                [CompoundCase("{0}", "4294838226")]
                [CompoundCase("{0}", "04294838226")]
                [CompoundCase("{0}", "+04294838226")]
                public void MatchingValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_String(valueToPass);
                }
            }; //class String

            [TestGroup, Description("Variation that takes a byte array.")]
            public class Binary: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.TitleParameter_Binary(new byte[]{0xff, 0xfe, 0x07, 0xd2});
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("00", new byte[]{0x00})]
                [CompoundCase("7FFE07D2", new byte[]{0x7F, 0xFE, 0x07, 0xD2})]
                [CompoundCase("4294838225", new byte[]{0xFF, 0xFE, 0x07, 0xD1})]
                [CompoundCase("FFEEDDCCAAFFFE07D1", new byte[]{0xFF, 0xEE, 0xDD, 0xCC, 0xAA, 0xFF, 0xFE, 0x07, 0xD1})]
                [CompoundCase("0bytes", new byte[0])]
                [CompoundCase("null", null)]
                public void DifferentValue(TestNode self)
                {
                    byte []valueToPass=(byte[])self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=500;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_Binary(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    
                    // the bytes match,  but a byte array is  not  an  integer
                    // there is no conversion so we get back a FormatException

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_Binary(new byte[]{0xff, 0xfe, 0x07, 0xd2});
                }
            }; //class Binary

            [TestGroup, Description("Variation that takes a DateTime.  Yes I'm that evil.")]
            public class DateTime: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));

                    // this passes a data time for a title id (an integer). SOAP does
                    // not like that at all and throws a 500 before we  ever  see  it
                    // Wcf returns 403

                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 403 : 500;
                    client.TitleParameter_DateTime(System.DateTime.UtcNow);
                }

                [TestCase, Description("Provide a token but don't pass the value.")]
                public void NoValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=500;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_DateTime(null);
                }

                [TestCase, Description("Provide a token with a different value.")]
                public void DifferentValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.TitleId, 0xFFFE07D2.ToString());
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=500;
                    client.AddClaimToken(tokenString);
                    client.TitleParameter_DateTime(System.DateTime.UtcNow);
                }
            }; //class DateTime
        }; //class VerifyTitle

        [TestGroup, Description("Various parameter types excercising the VerifyCountry parameter validation.")]
        public class VerifyCountry: TestNode
        {
            [TestGroup, Description("Variation that takes an unsigned int.")]
            public class UnsignedInt: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_UnsignedInt(103);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (uint)0)]
                [CompoundCase("{0}", (uint)104)]
                [CompoundCase("{0}", 2147483751)]
                [CompoundCase("{0}", unchecked((uint)-103))]
                public void DifferentValue(TestNode self)
                {
                    uint? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(uint)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedInt(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                public void NullValue()
                {
                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString = generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedInt(null);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedInt(103);
                }
            }; //class UnsignedInt

            [TestGroup, Description("Variation that takes an nullable signed int.")]
            public class NullableSignedInt: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken_PassValue()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_NullableSignedInt(103);
                }

                [TestCase, Description("Do not provide a token.")]
                public void NoToken_PassNull()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_NullableSignedInt(null);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (int)0)]
                [CompoundCase("{0}", (int)104)]
                [CompoundCase("{0}", unchecked((int)2147483751))]
                [CompoundCase("{0}", (int)-103)]
                public void DifferentValue(TestNode self)
                {
                    int? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(int)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_NullableSignedInt(valueToPass);
                }

                [CompoundCase("null", null)]
                public void IllegalValue(TestNode self)
                {
                    int? valueToPass = null;
                    if (self.MyValues[0] != null)
                    {
                        valueToPass = (int)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString = generatedToken.ToString();

                    AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_NullableSignedInt(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_NullableSignedInt(103);
                }
            }; //class NullableSignedInt

            [TestGroup, Description("Variation that takes an signed short.")]
            public class SignedShort: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_SignedShort(103);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (short)0)]
                [CompoundCase("{0}", (short)104)]
                [CompoundCase("{0}", unchecked((short)0x8067))]
                [CompoundCase("{0}", (short)-103)]
                public void DifferentValue(TestNode self)
                {
                    short? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(short)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_SignedShort(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                public void NullValue()
                {
                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString = generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_SignedShort(null);
                }
                
                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_SignedShort(103);
                }
            }; //class SignedShort

            [TestGroup, Description("Variation that takes an unsigned byte.")]
            public class UnsignedByte: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken_Pass103()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_UnsignedByte(103);
                }

                [TestCase, Description("Do not provide a token.")]
                public void NoToken_Pass0()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_UnsignedByte(0);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", (byte)0)]
                [CompoundCase("{0}", (byte)104)]
                [CompoundCase("{0}", (byte)0xE7)]
                [CompoundCase("{0}", unchecked((byte)-103))]
                public void DifferentValue(TestNode self)
                {
                    byte? valueToPass=null;
                    if (self.MyValues[0]!=null)
                    {
                        valueToPass=(byte)self.MyValues[0];
                    }

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedByte(valueToPass);
                }

                [TestCase, Description("Pass null.")]
                public void NullValue()
                {
                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString = generatedToken.ToString();

                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 500 : 403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedByte(null);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                public void MatchingValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_UnsignedByte(103);
                }
            }; //class UnsignedByte

            [TestGroup, Description("Variation that takes a string.")]
            public class String: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken_Pass103()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_String("103");
                }

                [TestCase, Description("Do not provide a token.")]
                public void NoToken_PassNull()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_String(null);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("{0}", "0")]
                [CompoundCase("{0}", "104")]
                [CompoundCase("{0}", "-103")]
                public void DifferentValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_String(valueToPass);
                }

                [CompoundCase("{0}", "0x67")]
                [CompoundCase("{0}", "0wtf")]
                [CompoundCase("LongValue", "1000000000000000000000000000000000000000000000000000000000000000000000000000000000103")]
                [CompoundCase("EmptyString", "")]
                [CompoundCase("null", null)]
                public void IllegalValue(TestNode self)
                {
                    string valueToPass = (string)self.MyValues[0];

                    XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString = generatedToken.ToString();

                    AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_String(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                [CompoundCase("{0}", "103")]
                [CompoundCase("{0}", "0103")]
                public void MatchingValue(TestNode self)
                {
                    string valueToPass=(string)self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_String(valueToPass);
                }
            }; //class String

            [TestGroup, Description("Variation that takes a byte array.")]
            public class Binary: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                    client.ExpectedHttpResponseCode=403;
                    client.CountryParameter_Binary(new byte[]{103});
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("00", new byte[]{0x00})]
                [CompoundCase("FF", new byte[]{0xFF})]
                [CompoundCase("FF0000000000000067", new byte[]{0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67})]
                [CompoundCase("0bytes", new byte[0])]
                [CompoundCase("null", null)]
                public void Claim103_DifferentValue(TestNode self)
                {
                    byte []valueToPass=(byte[])self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));

                    // bytes do not match,  but we never get to test because a
                    // a byte array is not convertible into a country (integer)

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_Binary(valueToPass);
                }

                [TestCase, Description("Provide a token with a different id.")]
                [CompoundCase("01", new byte[]{0x01})]
                [CompoundCase("FF0000000000000000", new byte[]{0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})]
                [CompoundCase("0bytes", new byte[0])]
                [CompoundCase("null", null)]
                public void Claim0_DifferentValue(TestNode self)
                {
                    byte []valueToPass=(byte[])self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "0");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));

                    // bytes do not match,  but we never get to test because a
                    // a byte array is not convertible into a country (integer)

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_Binary(valueToPass);
                }

                [TestCase, Description("Provide a token with a matching id.")]
                [CompoundCase("0x67", new byte[]{0x67})]
                [CompoundCase("0x0067", new byte[]{0x00, 0x67})]
                public void MatchingValue(TestNode self)
                {
                    byte []valueToPass=(byte[])self.MyValues[0];

                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));

                    // the bytes match,  but a byte array is  not  convertible
                    // to an integer which results in a System.FormatException

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_Binary(valueToPass);
                }
            }; //class Binary

            [TestGroup, Description("Variation that takes a DateTime.  Yes I'm that evil.")]
            public class DateTime: TestNode
            {
                [TestCase, Description("Do not provide a token.")]
                public void NoToken()
                {
                    ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
                    AttributeClientBase client = AttributeClientBase.CreateClient(protocol, (bool)GetContextData("UseAuthSg"));

                    // none of these make any sense, SOAP does not let a DateTime
                    // through for an integer.  We never see the request,  so 500
                    // Wcf returns 403

                    client.ExpectedHttpResponseCode=(protocol == ProtocolToUse.Wcf) ? 403 : 500;
                    client.CountryParameter_DateTime(System.DateTime.UtcNow);
                }

                [TestCase, Description("Provide a token but don't pass the value.")]
                public void NoValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));

                    // none of these make any sense, SOAP does not let a DateTime
                    // through for an integer.  We never see the request,  so 500

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_DateTime(null);
                }

                [TestCase, Description("Provide a token with a different value.")]
                public void DifferentValue()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "103");
                    string tokenString=generatedToken.ToString();

                    AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));

                    // none of these make any sense, SOAP does not let a DateTime
                    // through for an integer.  We never see the request,  so 500

                    client.ExpectedHttpResponseCode = 500;
                    client.AddClaimToken(tokenString);
                    client.CountryParameter_DateTime(System.DateTime.UtcNow);
                }
            }; //class DateTime
        }; //class VerifyCountry

        [TestGroup, Description("An API that has a variety of policies applied to it.")]
        public class MassiveCombo: TestNode
        {
            [TestCase, Description("Do not provide a token.")]
            public void NoToken()
            {
                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.MassiveCombo(1, 2, 3, 4);
            }

            [TestCase, Description("One or more claims are missing.")]
            //                                  Platform   Title         Privileges Tiger  Age      User               Machine             Country ExpectedResult
            [CompoundCase("All Correct",        "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789012", "FA00000000000001", "103",  200)]
            [CompoundCase("All Wrong",          "Xbox1",   "4294838226", "255",     null,  "Young", "900123456789013", "FB00000000000001", "104",  403)]
            [CompoundCase("All Missing",        null,      null,         null,      null,  null,    null,               null,              null,   403)]
            [CompoundCase("Platform Wrong",     "Xbox1",   "4294838225", "254",     "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Platform Missing",   null,      "4294838225", "254",     "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Title Wrong",        "Xbox360", "4294838224", "254",     "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Title Missing",      "Xbox360", null,         "254",     "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Privileges Wrong",   "Xbox360", "4294838225", "201 202", "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Privileges Missing", "Xbox360", "4294838225", null,      "",    "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Tiger Value",        "Xbox360", "4294838225", "254",     "Rar", "Elder", "900123456789012", "FA00000000000001", "103",  200)] //Exists check is fine with any value
            [CompoundCase("Tiger Missing",      "Xbox360", "4294838225", "254",     null,  "Elder", "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Age Wrong",          "Xbox360", "4294838225", "254",     "",    "Low",   "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("Age Missing",        "Xbox360", "4294838225", "254",     "",    null,    "900123456789012", "FA00000000000001", "103",  403)]
            [CompoundCase("User Wrong",         "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789013", "FA00000000000001", "103",  403)]
            [CompoundCase("User Missing",       "Xbox360", "4294838225", "254",     "",    "Elder", null,              "FA00000000000001", "103",  403)]
            [CompoundCase("Machine Wrong",      "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789012", "FB00000000000001", "103",  403)]
            [CompoundCase("Machine Missing",    "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789012", null,               "103",  403)]
            [CompoundCase("Country Wrong",      "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789012", "FA00000000000001", "104",  403)]
            [CompoundCase("Country Missing",    "Xbox360", "4294838225", "254",     "",    "Elder", "900123456789012", "FA00000000000001", null,   403)]
            public void Claims(TestNode self)
            {
                string includePlatform=(string)self.MyValues[0];
                string includeTitle=(string)self.MyValues[1];
                string includePrivileges=(string)self.MyValues[2];
                string includeTiger=(string)self.MyValues[3];
                string includeAge=(string)self.MyValues[4];
                string includeUser=(string)self.MyValues[5];
                string includeMachine=(string)self.MyValues[6];
                string includeCountry=(string)self.MyValues[7];
                int expectedHttpResult=(int)self.MyValues[8];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                if (includePlatform!=null)
                {
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", includePlatform);
                }
                if (includeTitle!=null)
                {
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", includeTitle);
                }
                if (includePrivileges!=null)
                {
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", includePrivileges);
                }
                if (includeTiger!=null)
                {
                    generatedToken.AddAttribute("http://example.com/tiger", includeTiger, ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                }
                if (includeAge!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, includeAge);
                }
                if (includeUser!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, includeUser);
                }
                if (includeMachine!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceId, includeMachine);
                }
                if (includeCountry!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, includeCountry);
                }
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedHttpResult;
                client.AddClaimToken(tokenString);
                client.MassiveCombo(900123456789012, 0xFA00000000000001, 4294838225, 103);
            }
        }; //class MassiveCombo
    }; //class Attribute
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\Global.cs ===
using ServerTestFramework;
[assembly: RootNode(typeof(XstsPolicyEnforcementTests.XstsPolicyEnforcementTests))]

namespace XstsPolicyEnforcementTests
{
    public class Global
    {
        public static System.Security.Cryptography.X509Certificates.X509Certificate2 XstsSigningCertificate
        {
            get
            {
                if (_xstsSigningCertificate==null)
                {
                    _xstsSigningCertificate=ServerTestFramework.LiveService.XSTS.XstsUtil.GetXstsSigningCertificate();
                }

                return _xstsSigningCertificate;
            }
        }

        public static void ClearCaches()
        {
            _xstsSigningCertificate=null;
        }

        private static System.Security.Cryptography.X509Certificates.X509Certificate2 _xstsSigningCertificate=null;

        // --

        public static ServerTestFramework.LiveService.XSTS.XSTSSaml2Token CreateDefaultSaml2Token()
        {
            ServerTestFramework.LiveService.XSTS.XSTSSaml2Token generatedToken=new ServerTestFramework.LiveService.XSTS.XSTSSaml2Token(Global.XstsSigningCertificate);
            generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
            generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://testfdxsts")));
            return generatedToken;
        }
    };

    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class XstsPolicyEnforcementTests: TestNode
    {
        public override void PreRun(RUN_TYPE runType)
        {
            Global.ClearCaches();

            if (runType==RUN_TYPE.STRESS)
            {
                ServerTestFramework.Utilities.HttpClient.Verbose=false;
            }
            else //Functional
            {
                ServerTestFramework.Utilities.HttpClient.Verbose=true;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\SimpleService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for a service with no policy defined."), AsyncGroup(0, 5)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    public class Simple: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("The echo service returns a string that was sent to it.  It doesn't enforce any policies of any type.")]
        public class Echo: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                SimpleClientBase client=SimpleClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                string ret=client.Echo("Hello world");
                ValueCheck.Test("Returned value from Echo", "Hello world", ret);
            }

            [TestCase, Description("Some random claims are provided in a token.")]
            public void WithToken()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", "fffe07d1");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/version", "1");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", "0900000000000000");
                generatedToken.Assertion.IssueInstant=System.DateTime.UtcNow;
                generatedToken.Assertion.Conditions.NotBefore=System.DateTime.MinValue;
                generatedToken.Assertion.Conditions.NotOnOrAfter=System.DateTime.MaxValue;
                string tokenString=generatedToken.ToString();

                SimpleClientBase client=SimpleClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                string ret=client.Echo("Hello world");
                ValueCheck.Test("Returned value from Echo", "Hello world", ret);
            }
        }; //class Echo
    }; //class Simple
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\MixedOverrideService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for the policy configured in web.config overriding the policy configured by attributes."), AsyncGroup(0, 3)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    
    // The MixedOverride class verifies various combinations of policy settings on the class vs the methods vs webconfig settings.
    // In these tests the class itself requires privilege 253 but is overridden to 252 via webconfg.
    // The verified functionality is that webconfig settings override settings on the class or method.  The result is then
    // ANDED together to form the evaluated expression.
    // In the wcf case the requirement is specified on the webconfig due to it not being able to be set on the interface.
    public class MixedOverride: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("PlatformsPC requires that the platform type is PC.  This setting is specified on the method only.")]
        public class PlatformsPC : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the correct platform but is missing the privilege.")]
            public void TokenRightPlatformMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }
        }; //class PlatformsPC

        [TestGroup, Description("PlatformsPC_WebConfigXbox360 requires that the platform type is 360.  This setting is specified in webconfig which overrides the method setting of PC.")]
        public class PlatformsPC_WebConfigXbox360 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the platform specified on the method which is overridden.")]
            public void TokenWrongPlatformMethod()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }
            
            [TestCase, Description("Token contains the correct platform but is missing the privilege.")]
            public void TokenRightPlatformMissingPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }
        }; //class PlatformsPC_WebConfigXbox360

        [TestGroup, Description("TitlesFFFE07D2 requires that the title is 0xfffe07d2.  This is specified on the method only.")]
        public class TitlesFFFE07D2 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the correct title but is missing the privilege.")]
            public void TokenRightTitleMissingPrililege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the correct title.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }
        }; //class TitlesFFFE07D2

        [TestGroup, Description("TitlesFFFE07D2_WebConfigFFFE07D1 requires that the title is 0xfffe07d1.  This setting is specified in webconfig which overrides the method setting of 0xfffe07d2.")]
        public class TitlesFFFE07D2_WebConfigFFFE07D1 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D0.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the title specified on the method which is overridden.")]
            public void TokenWrongTitleMethod()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }
            
            [TestCase, Description("Token contains the correct title but is missing the privilege.")]
            public void TokenRightTitleMissingPrililege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the correct title.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }
        }; //class TitlesFFFE07D2_WebConfigFFFE07D1

        [TestGroup, Description("Privileges252 requires that privilege 252 is present.  This requirement is specified in the webconfig")]
        public class Privileges252 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges252();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges252();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "155 2 999");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges252();
            }

            [TestCase, Description("Token contains the required privilege.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges252();
            }

            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "155 252 253 300");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges252();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges252();
            }
        }; //class Privileges252

        [TestGroup, Description("Privileges254 requires that privilege 254 and 252 is present.  This requirement is specified on the method as well as the class")]
        public class Privileges254 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.Privileges254();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "987 1254 2520 0 255");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the required privileges.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252 254");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "012 254 55 252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }
        }; //class Privileges254

        [TestGroup, Description("Privileges254_WebConfig255 requires that privilege 255 and 252 is present.  This requirement is specified on the method as well as the class.  The method requirement is overridden by webconfig to 255.")]
        public class Privileges254_WebConfig255 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "12 8888 32 12");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains the required privileges.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252 255");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains overridden method privilige which should fail.")]
            public void TokenWithRequiredPrivilegesOverride()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253 254");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }
            
            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "5 254 1701 255 252 74656");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }
        }; //class Privileges254_WebConfig255

        [TestGroup, Description("RequiresClaimLion requires that lion claim is present via requirement on the method.")]
        class RequiresClaimLion : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaimLion();
            }

            [TestCase, Description("The tiger claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("The lion claim is present, but missing the privilege")]
            public void TigerPresentMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("The lion claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresentWrongOrder()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }
        }; //class RequiresClaimLion

        [TestGroup, Description("RequiresClaimLion_WebConfigTiger requires that tiger claim is present via webconfig override.")]
        class RequiresClaimLion_WebConfigTiger : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The lion claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The tiger claim is present, but missing the privilege")]
            public void TigerPresentMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The tiger claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresentWrongOrder()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString=generatedToken.ToString();

                MixedOverrideClientBase client=MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "252");
                string tokenString = generatedToken.ToString();

                MixedOverrideClientBase client = MixedOverrideClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }
        }; //class RequiresClaimLion_WebConfigTiger
    }; //class MixedOverride
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\SoapSpecific.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests specifically for the SOAP protocol."), TestTag("Transport", "Direct"), TestTag("Protocol", "Soap")]
    public class SoapSpecific: TestNode
    {
        [TestCase, Description("Call the API using http post parameters rather than soap xml.  Do not provide a token.")]
        public void HttpPostNotSoap_NoToken()
        {
            HttpClient.Request request=new HttpClient.Request();
            request.URI="/testfdxstssoap/Attribute.asmx/RequiresClaim_Tiger";
            request.Method="POST";
            request.Host="localhost"; //Normally this would be the testfxstssoap_int interface, but localhost tricks iis into accepting it
            request.SetContentLengthAndBody("");
            request.OtherHeaders.AddLast("Content-Type: text/xml"); //XrlScan requires a content type to be set

            HttpClient client=new HttpClient(ServerTestFramework.Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.testfdxstssoap_int));
            client.SendRequest(request);
            HttpClient.Response response=client.GetResponse();

            ValueCheck.Test("Server responded", true, response!=null);
            ValueCheck.Test("Http Response Code", 500, response.Status); //IIS blocks this before our code is called, and it sets the less-than-ideal 500 error
        }

        [TestCase, Description("Call the API using http post parameters rather than soap xml.  Provide a token.")]
        public void HttpPostNotSoap_WithToken()
        {
            HttpClient.Request request=new HttpClient.Request();
            request.URI="/testfdxstssoap/Attribute.asmx/RequiresClaim_Tiger";
            request.Method="POST";
            request.Host="localhost"; //Normally this would be the testfxstssoap_int interface, but localhost tricks iis into accepting it
            request.SetContentLengthAndBody("");
            request.OtherHeaders.AddLast("Content-Type: text/xml"); //XrlScan requires a content type to be set

            XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
            generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
            string tokenString=generatedToken.ToString();
            request.OtherHeaders.AddLast("Authorization: XBL2.0 x="+tokenString);

            HttpClient client=new HttpClient(ServerTestFramework.Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.testfdxstssoap_int));
            client.SendRequest(request);
            HttpClient.Response response=client.GetResponse();

            ValueCheck.Test("Server responded", true, response!=null);
            ValueCheck.Test("Http Response Code", 500, response.Status); //IIS blocks this before our code is called, and it sets the less-than-ideal 500 error
        }
    }; //class SoapSpecific
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\MixedService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for the policy configured in web.config overriding the policy configured by attributes."), AsyncGroup(0, 3)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    
    // The Mixed class verifies various combinations of policy settings on the class vs the methods vs webconfig settings.
    // In these tests the class itself requires privilege 253 as well as any requirements on the methods and or webconfig.
    // The verified functionality is that webconfig settings override settings on the class or method.  The result is then
    // ANDED together to form the evaluated expression.
    // In the wcf case the requirement is specified on the webconfig due to it not being able to be set on the interface.
    public class Mixed: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("PlatformsPC requires that the platform type is PC.  This setting is specified on the method only.")]
        public class PlatformsPC : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the correct platform but is missing the privilege.")]
            public void TokenRightPlatformMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                string tokenString = generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.PlatformsPC();
            }
        }; //class PlatformsPC

        [TestGroup, Description("PlatformsPC_WebConfigXbox360 requires that the platform type is 360.  This setting is specified in webconfig which overrides the method setting of PC.")]
        public class PlatformsPC_WebConfigXbox360 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the platform specified on the method which is overridden.")]
            public void TokenWrongPlatformMethod()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "PC");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }
            
            [TestCase, Description("Token contains the correct platform but is missing the privilege.")]
            public void TokenRightPlatformMissingPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.PlatformsPC_WebConfigXbox360();
            }
        }; //class PlatformsPC_WebConfigXbox360

        [TestGroup, Description("TitlesFFFE07D2 requires that the title is 0xfffe07d2.  This is specified on the method only.")]
        public class TitlesFFFE07D2 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the correct title but is missing the privilege.")]
            public void TokenRightTitleMissingPrililege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }

            [TestCase, Description("Token contains the correct title.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2();
            }
        }; //class TitlesFFFE07D2

        [TestGroup, Description("TitlesFFFE07D2_WebConfigFFFE07D1 requires that the title is 0xfffe07d1.  This setting is specified in webconfig which overrides the method setting of 0xfffe07d2.")]
        public class TitlesFFFE07D2_WebConfigFFFE07D1 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the wrong title.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D0.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the title specified on the method which is overridden.")]
            public void TokenWrongTitleMethod()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }
            
            [TestCase, Description("Token contains the correct title but is missing the privilege.")]
            public void TokenRightTitleMissingPrililege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }

            [TestCase, Description("Token contains the correct title.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.TitlesFFFE07D2_WebConfigFFFE07D1();
            }
        }; //class TitlesFFFE07D2_WebConfigFFFE07D1

        [TestGroup, Description("Privileges253 requires that privilege 253 is present.  This requirement is specified on the class")]
        public class Privileges253 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges253();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges253();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "155 2 999");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges253();
            }

            [TestCase, Description("Token contains the required privilege.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges253();
            }

            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "155 254 253 300");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges253();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges253();
            }
        }; //class Privileges254

        [TestGroup, Description("Privileges254 requires that privilege 254 and 253 is present.  This requirement is specified on the method as well as the class")]
        public class Privileges254 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.Privileges254();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "987 1254 2530 0 255");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the required privileges.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253 254");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "012 254 55 253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254();
            }
        }; //class Privileges254

        [TestGroup, Description("Privileges254_WebConfig255 requires that privilege 255 and 253 is present.  This requirement is specified on the method as well as the class.  The method requirement is overridden by webconfig to 255.")]
        public class Privileges254_WebConfig255 : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "12 8888 32 12");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains the required privileges.")]
            public void TokenWithRequiredPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253 255");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains overridden method privilige which should fail.")]
            public void TokenWithRequiredPrivilegesOverride()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253 254");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }
            
            [TestCase, Description("Token contains the required privileges and some others.")]
            public void TokenWithAdditionalPrivileges()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "5 254 1701 255 253 74656");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }

            [TestCase, Description("Token contains the privilege and some others but the privilege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.Privileges254_WebConfig255();
            }
        }; //class Privileges254_WebConfig255

        [TestGroup, Description("RequiresClaimLion requires that lion claim is present via requirement on the method.")]
        class RequiresClaimLion : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaimLion();
            }

            [TestCase, Description("The tiger claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("The lion claim is present, but missing the privilege")]
            public void TigerPresentMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("The lion claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresentWrongOrder()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion();
            }
        }; //class RequiresClaimLion

        [TestGroup, Description("RequiresClaimLion_WebConfigTiger requires that tiger claim is present via webconfig override.")]
        class RequiresClaimLion_WebConfigTiger : TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The lion claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The tiger claim is present, but missing the privilege")]
            public void TigerPresentMissingPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("The tiger claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresentWrongOrder()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString=generatedToken.ToString();

                MixedClientBase client=MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present. Since the operator is exists this should succeed no matter the order.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken = Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "253");
                string tokenString = generatedToken.ToString();

                MixedClientBase client = MixedClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaimLion_WebConfigTiger();
            }
        }; //class RequiresClaimLion_WebConfigTiger
    }; //class Mixed
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\providers\XClaim\XClaimProviderRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.utilities2;
using xonline.server.kdc;

using xonline.server.xmachine.fd.soap;

namespace xonline.server.XSts.XClaimProvider
{
    internal class XClaimProviderRequest
    {
        public XClaimProviderRequest()
        {
        }

        //////////////////////////////////////
        // Attributes
        //////////////////////////////////////

        IClaimsPrincipal _principal;
        ulong  _xuid;       // UserPuid
        ulong  _puid;       // Passport Puid
        ulong  _parentXuid; // Parent Xuid;
        string _gamertag;   // Gamertag

        User _user = null; // User

        // Only call GetUserAuthorizationAndPrivileges once
        bool _tryGetUserAuthData = true;
        KdcUtil.GetUserAuthorizationAndPrivilegesData _userAuthData;

        //////////////////////////////////////
        // Implementation
        //////////////////////////////////////

        public IClaimsIdentity GetOutputClaimsIdentity(HashSet<string> claimTypes, IClaimsPrincipal principal)
        {
            ClaimsIdentity outputIdentity = new ClaimsIdentity();
            IEnumerable<Claim> claims;

            _principal = principal;
            foreach (string claimType in claimTypes)
            {
                Claim claim = null;

                // Already in the Principal?
                claims = principal.FindClaims(claimType);

                if (0 == claims.Count())
                {   // Try getting from User Info
                    claim = GetClaim(claims, claimType);
                    if (null != claim)
                    {
                        outputIdentity.Claims.Add(claim);
                    }
                }
                else
                {   // We need to copy the claim because it already has a subject/IClaimsIdentity
                    // experienced bad things when I messed with that collection 
                    outputIdentity.Claims.Add(claims.ElementAt(0).Copy());
                }


            }

            return outputIdentity;
        }

        /* ---------------------------------------------------------
        Done: public const string PartnerXuid = "http://schemas.microsoft.com/xbox/2011/07/claims/user/pxuid";
        Nope: public const string ClientIpPort = "http://schemas.microsoft.com/xbox/2011/07/claims/user/clientipport";
        Done: public const string Country = "http://schemas.microsoft.com/xbox/2011/07/claims/user/country";
        Nope: public const string DeviceId = "http://schemas.microsoft.com/xbox/2011/07/claims/device/id";
        Done: public const string DeviceName = "http://schemas.microsoft.com/xbox/2011/07/claims/device/name";
        Nope: public const string DeviceType = "http://schemas.microsoft.com/xbox/2011/07/claims/device/type";
        Nope: public const string FlowToken = "http://schemas.microsoft.com/xbox/2011/07/claims/flowtoken";
        Done: public const string Gamertag = "http://schemas.microsoft.com/xbox/2011/07/claims/user/gamertag";
        Done: public const string Language = "http://schemas.microsoft.com/xbox/2011/07/claims/user/language";
        Done: public const string Privileges = "http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges";
        Done: public const string Puid = "http://schemas.microsoft.com/xbox/2011/07/claims/user/puid";
        Done: public const string Tier = "http://schemas.microsoft.com/xbox/2011/07/claims/user/tier";
        Nope: public const string TitleId = "http://schemas.microsoft.com/xbox/2011/07/claims/title/id";
        Nope: public const string TitleVersion = "http://schemas.microsoft.com/xbox/2011/07/claims/title/version";
        Done: public const string Xuid = "http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid";
        Done: public const string AgeGroup = "http://schemas.microsoft.com/xbox/2011/07/claims/user/agegroup";
        Done: public const string Status = "http://schemas.microsoft.com/xbox/2011/07/claims/user/status";
        --------------------------------------------------------- */
        protected Claim GetClaim(IEnumerable<Claim> claims, string claimType)
        {
            Claim claim = null;

            GetUserIds();

            switch (claimType)
            {
                // User claims
                case AuthClaimTypes.PartnerXuid:  // The XClaimProvider will just return the Xuid.  XSts is responsible for anonymizing this value
                    if (0 != _xuid)
                    {
                        claim = new Claim(AuthClaimTypes.PartnerXuid, ((ulong)_xuid).ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.PartnerXuid]);
                    }
                    break;
                case AuthClaimTypes.Puid:
                    if (0 != _puid)
                    {
                        claim = new Claim(AuthClaimTypes.Puid, ((ulong)_puid).ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid]);
                    }
                    break;

                case AuthClaimTypes.ParentXuid:
                case AuthClaimTypes.PartnerParentXuid:
                    claim = GetParentClaim(claimType);
                    break;
                    
                case AuthClaimTypes.AgeGroup:
                    claim = GetAgeGroupClaim();
                    break;
                case AuthClaimTypes.Country:
                    claim = GetCountryClaim();
                    break;
                case AuthClaimTypes.DeviceName:
                    claim = GetDeviceNameClaim();
                    break;
                case AuthClaimTypes.Gamertag:
                    claim = GetGamertagClaim();
                    break;
                case AuthClaimTypes.Language:
                    claim = GetLanguageClaim();
                    break;
                case AuthClaimTypes.Privileges:
                    claim = GetPrivilegesClaim();
                    break;
                case AuthClaimTypes.Tier:
                    claim = GetTierClaim();
                    break;
                case AuthClaimTypes.Xuid:
                    if (0 != _xuid)
                    {
                        claim = new Claim(AuthClaimTypes.Xuid, ((ulong)_xuid).ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid]);
                    }
                    break;
                case AuthClaimTypes.DelegationToken:
                    claim = GetDelegationTokenClaim();
                    break;

                case AuthClaimTypes.Status:
                    claim = GetStatusClaim();
                    break;
                    
                case XClaimProvider.TitleComponent:
                    claim = new Claim(XClaimProvider.TitleComponent, "xam", ClaimValueTypes.String);
                    break;

                case AuthClaimTypes.PartnerDeviceId:
                    claim = GetPartnerDeviceIdClaim();
                    break;

                default:
                    // Can't get these claim types from UserAuthorizationInfo
                    // Device Type claims
                    //  AuthClaimTypes.ClientIpPort;
                    //  AuthClaimTypes.DeviceId:
                    //  AuthClaimTypes.DeviceType:
                    //  AuthClaimTypes.FlowToken:
                    // Title claims
                    //  AuthClaimTypes.TitleId:
                    //  AuthClaimTypes.TitleVersion:
                    //  AuthClaimTypes.Xuid:
                    break;

            }

            return claim;
        }

        protected Claim GetAgeGroupClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                GetUser();
                if (null != _user)
                {
                    switch (_user.AgeGroupId)
                    {
                        case XOn.PARENTAL_CONTROL_GROUP_RESTRICTED:
                            claim = new Claim(AuthClaimTypes.AgeGroup, AuthAgeGroups.Child, AuthClaimTypes.ValueTypes[AuthClaimTypes.AgeGroup]);
                            break;
                        case XOn.PARENTAL_CONTROL_GROUP_MEDIUM:
                            claim = new Claim(AuthClaimTypes.AgeGroup, AuthAgeGroups.Teen, AuthClaimTypes.ValueTypes[AuthClaimTypes.AgeGroup]);
                            break;
                        case XOn.PARENTAL_CONTROL_GROUP_OPEN:
                            claim = new Claim(AuthClaimTypes.AgeGroup, AuthAgeGroups.Adult, AuthClaimTypes.ValueTypes[AuthClaimTypes.AgeGroup]);
                            break;
                    }
                }
            }

            return claim;
        }

        protected Claim GetCountryClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                GetUserAuthData();
                if (null != _userAuthData)
                {
                    claim = new Claim(AuthClaimTypes.Country, _userAuthData.CountryId.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Country]);
                }
            }

            return claim;
        }

        protected Claim GetDelegationTokenClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                DelegationToken dtoken = new DelegationToken(_xuid);
                Blob value = (Blob) (byte[]) dtoken;

                claim = new Claim(AuthClaimTypes.DelegationToken, value.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.DelegationToken]);
            }

            return claim;
        }

        protected Claim GetPartnerDeviceIdClaim()
        {
            IEnumerable<Claim> claims;

            // Is there a Device Id in the Principal?
            claims = _principal.FindClaims(AuthClaimTypes.DeviceId);
            if (1 == claims.Count())
            {
                return new Claim(AuthClaimTypes.PartnerDeviceId, claims.ElementAt(0).Value, AuthClaimTypes.ValueTypes[AuthClaimTypes.PartnerDeviceId]);
            }

            return null;
        }

        protected Claim GetDeviceNameClaim()
        {
            Claim claim = null;
            IEnumerable<Claim> deviceIdClaims = null;

           //Is there a deviceid claim?
           deviceIdClaims = _principal.FindClaims(AuthClaimTypes.DeviceId);
           if (deviceIdClaims.Count() != 1) return null;

           ulong machineId = Convert.ToUInt64(deviceIdClaims.ElementAt(0).Value, 16);

           if (machineId != 0) 
           { 
             MachinePuidInfo[]  machinePuidInfo = null;
             ulong[]            requestedPuids  = new ulong[1];
             XMachineSoapClient connection      = new XMachineSoapClient();

                
             requestedPuids[0] = machineId;
             machinePuidInfo = connection.LookupConsoleIdsByMachinePuids(
                                          requestedPuids
                                          );

              if (machinePuidInfo != null && machinePuidInfo.Length != 0)
              {
                  claim = new Claim(AuthClaimTypes.DeviceName, machinePuidInfo[0].ConsoleId, AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceName]);
              }
            }

            return claim;
        }

        protected Claim GetGamertagClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                XCacheUserResponseData user = XCache.LookupUserByXUID(_xuid);
                if (!XCache.IsInvalidGamertag(user.szGamertag))
                {
                    _gamertag = user.szGamertag;
                }
            }

            if (0 != _xuid && string.IsNullOrEmpty(_gamertag))
            {
                _gamertag = KdcUtil.GetGamerTagFromUserPuid(_xuid);
            }

            if (!string.IsNullOrEmpty(_gamertag))
                claim = new Claim(AuthClaimTypes.Gamertag, _gamertag, AuthClaimTypes.ValueTypes[AuthClaimTypes.Gamertag]);

            return claim;
        }

        protected Claim GetLanguageClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                GetUserAuthData();
                if (null != _userAuthData)
                {
                    claim = new Claim(AuthClaimTypes.Language, _userAuthData.LanguageId.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Language]);
                }
            }

            return claim;
        }

        protected Claim GetParentClaim(string claimType)
        {
            if ((_parentXuid == 0) && (_xuid != 0))
            {
                User user = GetUser();

                // if the user is not parentally controlled (user puid
                // equal to owner puid) then just  return  their  xuid

                if (! user.IsParentallyControlled)
                    _parentXuid = _xuid;
                else {
                    XCacheUserResponseData xcurd = XCache.LookupUserByPassport(user.OwnerPassportPuid);
                    _parentXuid = xcurd.qwUserID;
                }
            }

            // if they still have no parent xuid then the parent is not
            // an xbox user (just a wlid) and we don't return  a  claim

            if (_parentXuid == 0) return null;
            return new Claim(claimType, _parentXuid.ToString(), AuthClaimTypes.ValueTypes[claimType]);
        }

        protected Claim GetStatusClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                string value = null;

                if (null != _userAuthData)
                {
                    value = UserStatusToString(_userAuthData.isSuspended, _userAuthData.acceptedTermsOfService);
                }
                else
                {   // Get the status claim the cheap way, if we still need to go to KdcUtil.GetUserAuthorizationAndPrivileges 
                    // for other claims then this is sub-optimal but with proper claim ordering this should be the right thing to do
                    DBHelper.XUser user = DBHelper.XUser.GetUser(_xuid);

                    if (null != user)
                    {
                        if (user.IsSuspended)
                        {
                            throw new XblException(HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED, "Banned User!");
                        }

                        value = UserStatusToString(user.IsSuspended, user.AcceptedTermsOfService);
                    }
                }

                if (!string.IsNullOrEmpty(value))
                {
                    claim = new Claim(AuthClaimTypes.Status, value, AuthClaimTypes.ValueTypes[AuthClaimTypes.Status]);
                }
            }

            return claim;
        }

        protected Claim GetTierClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                GetUserAuthData();
                if (null != _userAuthData)
                {
                    claim = new Claim(AuthClaimTypes.Tier, XOn.UserTierToString((uint)_userAuthData.TierId), AuthClaimTypes.ValueTypes[AuthClaimTypes.Tier]);
                }
            }

            return claim;
        }

        protected Claim GetPrivilegesClaim()
        {
            Claim claim = null;

            if (0 != _xuid)
            {
                GetUserAuthData();
                if (null != _userAuthData)
                {
                    string privileges = _userAuthData.privileges.Aggregate(
                        new StringBuilder(),
                        (sb, p) => sb.Append(p + " "),
                        sb => sb.Length == 0 ? String.Empty : sb.ToString(0, sb.Length - 1));
                    claim = new Claim(AuthClaimTypes.Privileges, privileges, AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges]);
                }
            }

            return claim;
        }

        protected User GetUser()
        {
            if (null == _user && 0 != _xuid)
            {
                _user = new User();
                _user.Load(_xuid);
            }

            return _user;
        }

        protected void GetUserAuthData()
        {
            if (null == _userAuthData && _tryGetUserAuthData && 0 != _xuid)
            {
                IEnumerable<Claim> claims;
                int titleId = 0;

                // Is there a Title Id in the Principal?
                claims = _principal.FindClaims(AuthClaimTypes.TitleId);
                if (1 == claims.Count())
                {
                    Int32.TryParse(claims.ElementAt(0).Value, out titleId);
                }

                KdcUtil.GetUserAuthorizationAndPrivileges(_xuid, titleId, out _userAuthData);
                if (_userAuthData.isSuspended)
                {
                    throw new XblException(HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED, "Banned User!");
                }

                _tryGetUserAuthData = false;
            }
        }

        protected void GetUserIds()
        {
            if (0 == _xuid && 0 == _puid)
            {
                string id;

                // Already in the Principal?
                if (AuthExtensions.TryGetClaimValue(_principal, AuthClaimTypes.Xuid, out id))
                {
                    if (!ulong.TryParse(id, out _xuid))
                    {
                        throw new XblException(HResult.XONLINE_E_XCLAIMPROVIDER_XUIDCLAIM_INVALID, "Invalid Xuid claim");
                    }
                }
                if (AuthExtensions.TryGetClaimValue(_principal, AuthClaimTypes.Puid, out id))
                {
                    if (!ulong.TryParse(id, out _puid))
                    {
                        throw new XblException(HResult.XONLINE_E_XCLAIMPROVIDER_PUIDCLAIM_INVALID, "Invalid Puid claim");
                    }
                }
            }
        }

        // UserStatusToString - this is the value for a new claim for XSts which is currently using the 
        // UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1 date to determine status
        protected static string UserStatusToString(bool isSuspended, bool acceptedTermsOfService)
        {
            if (!isSuspended && acceptedTermsOfService)
            {
                return AuthStatus.Ok;
            }
            else
            {
                return AuthStatus.Maintenance;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\WebConfigService.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests for policy configured in web.config"), AsyncGroup(0, 2)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    public class WebConfig: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("Platforms_Xbox360 requires that the platform type is xbox360.")]
        public class Platforms_Xbox360: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Platforms_Xbox360();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "NotReal");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightPlatform()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Platforms_Xbox360();
            }
        }; //class Platforms_Xbox360

        [TestGroup, Description("Titles_FFFE07D1 requires that the title is 0xfffe07d1.")]
        public class Titles_FFFE07D1: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Token contains the wrong platform.")]
            public void TokenWrongTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Token contains the correct platform.")]
            public void TokenRightTitle()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class Titles_FFFE07D1

        [TestGroup, Description("Privileges_254 requires that privilege 254 is present.")]
        public class Privileges_254: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.Privileges_254();
            }

            [TestCase, Description("Token contains no privileges.")]
            public void TokenWithNoPrivileges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token does not contain the privelege but contains other privileges.")]
            public void TokenWithoutPrivilege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains only the privilege.")]
            public void TokenWithOnlyPrivelege()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains the privilege and some others.")]
            public void TokenWithAdditionalPriveleges()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222 254 255");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }

            [TestCase, Description("Token contains the privilege and some others but the privelege is in a different instance of the attribute.  The expectation is that only the first token claim is used.")]
            public void TokenWithPrivelegeInSeparateAttribute()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "222");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "254");
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "255");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Privileges_254();
            }
        }; //class Privileges_254

        [TestGroup, Description("RequiresClaim_Tiger requires that tiger claim is present.")]
        class RequiresClaim_Tiger: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("The lion claim is present instead.")]
            public void LionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("The tiger claim is present.")]
            public void TigerPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }

            [TestCase, Description("Both the lion and tiger claims are present.")]
            public void TigerAndLionPresent()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://example.com/tiger", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                generatedToken.AddAttribute("http://example.com/lion", "", ClaimValueTypes.String); //wif has a bug, we must provide a value even if we don't care about the value
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.RequiresClaim_Tiger();
            }
        }; //class RequiresClaim_Tiger

        [TestGroup, Description("Requires that the age group claim is 'Old Enough'.")]
        public class EqualsAgeGroup_OldEnough: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.EqualsAgeGroup_OldEnough();
            }

            [TestCase, Description("Pass a token that does not contain the claim.")]
            public void ClaimNotInToken()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "16");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.EqualsAgeGroup_OldEnough();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("{0}", "Too Young")]
            [CompoundCase("{0}", "OldEnough")]
            [CompoundCase("Empty String", "")]
            public void NotMatching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, valueInToken);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.EqualsAgeGroup_OldEnough();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            public void Matching()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Old Enough");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.EqualsAgeGroup_OldEnough();
            }
        }; //class EqualsAgeGroup_OldEnough

        [TestGroup, Description("Require that the awesomeintegers claim is greater than 13.")]
        public class GreaterThanInteger_13: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.GreaterThanInteger_13();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("{0}", "-5")]
            [CompoundCase("{0}", "12")]
            [CompoundCase("{0}", "13")]
            [CompoundCase("Empty String", "")]
            public void NotMatching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeintegers", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.GreaterThanInteger_13();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            [CompoundCase("{0}", "14")]
            [CompoundCase("{0}", "999999999999999999")]
            public void Matching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeintegers", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.GreaterThanInteger_13();
            }
        }; //class GreaterThanInteger_13

        [TestGroup, Description("Require that the awesomeintegers claim is less than 13.")]
        public class LessThanInteger_13: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.LessThanInteger_13();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("{0}", "14")]
            [CompoundCase("{0}", "13")]
            [CompoundCase("Empty String", "", BugID = 63229, BugDatabase = "TFS")]
            public void NotMatching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeintegers", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.LessThanInteger_13();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            [CompoundCase("{0}", "12")]
            [CompoundCase("{0}", "-999999999999999999")]
            public void Matching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeintegers", valueInToken, ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.LessThanInteger_13();
            }
        }; //class LessThanInteger_13

        [TestGroup, Description("Require that the age group claim is 'Old Enough' and that the status claim is 'Single'.")]
        public class SimpleAnd: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.SimpleAnd();
            }

            [TestCase, Description("Pass a token that does not contain the age group claim.")]
            public void MissingAgeClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", "Single", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleAnd();
            }

            [TestCase, Description("Pass a token that does not contain the status claim.")]
            public void MissingStatusClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/agegroup", "Old Enough", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleAnd();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("Age={0} Status={1}", "Too Old", "Single")]
            [CompoundCase("Age={0} Status={1}", "Old Enough", "Unknown")]
            [CompoundCase("Age={0} Status={1}", "", "Single")]
            [CompoundCase("Age={0} Status={1}", "Old Enough", "")]
            public void NotMatching(TestNode self)
            {
                string valueInAge=(string)self.MyValues[0];
                string valueInStatus=(string)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", valueInStatus, ClaimValueTypes.String);
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/agegroup", valueInAge, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleAnd();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            public void Matching()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", "Single", ClaimValueTypes.String);
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/agegroup", "Old Enough", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.SimpleAnd();
            }
        }; //class SimpleAnd

        [TestGroup, Description("Require that the country claim is 10 or that the status claim is 'Single'.")]
        public class SimpleOr: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.SimpleOr();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("Country={0} Status={1}", "15", "Unknown")]
            [CompoundCase("Country={0} Status={1}", "15", "")]
            [CompoundCase("Country={0} Status={1}", "", "Unknown")]
            [CompoundCase("Country={0} Status={1}", "", "")]
            public void NotMatching(TestNode self)
            {
                string valueInCountry=(string)self.MyValues[0];
                string valueInStatus=(string)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", valueInStatus, ClaimValueTypes.String);
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/country", valueInCountry, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleOr();
            }

            [TestCase, Description("Pass a token that does not contain the country claim.  The exception in the or will be bubbled up.")]
            public void NoCountryClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", "Single", ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode = 403;
                client.AddClaimToken(tokenString);
                client.SimpleOr();
            }

            [TestCase, Description("Pass a token that does not contain the status claim.  Since it's OR it's ok due to the first expression being evaluated to true.")]
            public void NoStatusClaim()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/country", "16", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.SimpleOr();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            [CompoundCase("Country={0} Status={1}", "16", "Single")]
            [CompoundCase("Country={0} Status={1}", "15", "Single")]
            [CompoundCase("Country={0} Status={1}", "16", "Unknown")]
            [CompoundCase("Country={0} Status={1}", "16", "")]
            public void Matching(TestNode self)
            {
                string valueInCountry=(string)self.MyValues[0];
                string valueInStatus=(string)self.MyValues[1];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/status", valueInStatus, ClaimValueTypes.String);
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/country", valueInCountry, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.SimpleOr();
            }
        }; //class SimpleOr

        [TestGroup, Description("Require that the height claim is not short.")]
        public class SimpleNot: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.SimpleNot();
            }

            [TestCase, Description("Pass a token that does not contain the claim.")]
            public void ClaimNotInToken()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Country, "16");
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleNot();
            }

            [TestCase, Description("Pass a token with a value that does not match.")]
            [CompoundCase("{0}", "Short")]
            public void NotMatching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/height", valueInToken, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.SimpleNot();
            }

            [TestCase, Description("Pass a token with a value that does match.")]
            [CompoundCase("{0}", "Tall")]
            [CompoundCase("Empty String", "")]
            public void Matching(TestNode self)
            {
                string valueInToken=(string)self.MyValues[0];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/height", valueInToken, ClaimValueTypes.String);
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.SimpleNot();
            }
        }; //class SimpleNot

        [TestGroup, Description("Require that it is not the case that ((the device claim is not xbox360 or the height claim is short or the weight claim is extreme) and the age group claim is 'Too Young')")]
        public class ComplexAndOrNot: TestNode
        {
            [TestCase, Description("Calls the API without providing a token.")]
            public void NoToken()
            {
                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.ComplexAndOrNot();
            }

            [TestCase, Description("Various claims are present or not present, with various values.")]
            //                                                                   devtype,   height,  weight,    agegroup     expected
            [CompoundCase("None Present",                                        null,      null,    null,      null,        403)]
            [CompoundCase("AgeMismatch",                                         null,      null,    null,      "SameAsYou", 403)] //The underlying expression failures are bubbled up
            [CompoundCase("AgeMatch",                                            null,      null,    null,      "Too Young", 403)]
            [CompoundCase("DevTypeMatch HeightMismatch WeightMismatch",          "Xbox360", "Giant", "Great",   null,        403)] //The underlying expression failures are bubbled up
            [CompoundCase("DevTypeMatch HeightMatch WeightMismatch",             "Xbox360", "Short", "Great",   null,        403)] //Since the or's expression is true, we need age to determine the result
            [CompoundCase("DevTypeMatch HeightMatch WeightMismatch AgeMismatch", "Xbox360", "Short", "Great",   "Too Young", 403)]
            [CompoundCase("DevTypeMatch HeightMatch WeightMismatch AgeMatch",    "Xbox360", "Short", "Great",   "NotRight",  200)]
            [CompoundCase("DevTypeMismatch WeightMatch AgeMatch",                "Xbox1",   null,    "Extreme", "Too Young", 403)] //The underlying expression failures are bubbled up
            [CompoundCase("DevTypeMatch WeightMatch AgeMatch",                   "Xbox360", null,    "Extreme", "NotRight",  403)] //The underlying expression failures are bubbled up
            public void ClaimVariations(TestNode self)
            {
                string deviceValue=(string)self.MyValues[0];
                string heightValue=(string)self.MyValues[1];
                string weightValue=(string)self.MyValues[2];
                string ageValue=(string)self.MyValues[3];
                int expectedResult=(int)self.MyValues[4];

                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                if (deviceValue!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.DeviceType, deviceValue);
                }
                if (heightValue!=null)
                {
                    generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/height", heightValue, ClaimValueTypes.String);
                }
                if (weightValue!=null)
                {
                    generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/awesomeuser/height", weightValue, ClaimValueTypes.String);
                }
                if (ageValue!=null)
                {
                    generatedToken.AddAutoTypedAttribute(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, ageValue);
                }
                string tokenString=generatedToken.ToString();

                WebConfigClientBase client=WebConfigClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=expectedResult;
                client.AddClaimToken(tokenString);
                client.ComplexAndOrNot();
            }

        }; //class ComplexAndOrNot
    }; //class WebConfig
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\Stress.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

namespace XstsPolicyEnforcementTests
{
    [TestGroup]
    public class Stress: TestNode
    {
        [TestGroup]
        public class Soap: TestNode
        {
            [TestGroup]
            public class SimpleEcho: TestNode
            {
                string cachedToken;

                public override void PreRun()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", "fffe07d1");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/version", "1");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", "0900000000000000");
                    generatedToken.Assertion.IssueInstant=System.DateTime.UtcNow;
                    generatedToken.Assertion.Conditions.NotBefore=System.DateTime.MinValue;
                    generatedToken.Assertion.Conditions.NotOnOrAfter=System.DateTime.MaxValue;
                    cachedToken=generatedToken.ToString();
                }

                [StressTest]
                public void NoToken_SendReceive_Direct()
                {
                    SimpleClientBase client=SimpleClientBase.CreateClient(ProtocolToUse.Soap, false);
                    string ret=client.Echo("Hello world");
                    ValueCheck.Test("Returned value from Echo", "Hello world", ret);
                }

                [StressTest]
                public void NoToken_SendOnly_Direct()
                {
                    ServerTestFramework.LiveService.TestFdXsts.Soap.SimpleClient client=new ServerTestFramework.LiveService.TestFdXsts.Soap.SimpleClient();
                    HttpClient httpClient=client.GenerateHttpClient();
                    HttpClient.Request request=client.GenerateEchoRequest("Hrello World");
                    httpClient.SendRequest(request);
                }

                [StressTest]
                public void WithToken_SendReceive_Direct()
                {
                    SimpleClientBase client=SimpleClientBase.CreateClient(ProtocolToUse.Soap, false);
                    client.AddClaimToken(cachedToken);
                    string ret=client.Echo("Hello world");
                    ValueCheck.Test("Returned value from Echo", "Hello world", ret);
                }

                [StressTest]
                public void WithToken_SendOnly_Direct()
                {
                    ServerTestFramework.LiveService.TestFdXsts.Soap.SimpleClient client=new ServerTestFramework.LiveService.TestFdXsts.Soap.SimpleClient();
                    client.AddClaimToken(cachedToken);

                    HttpClient httpClient=client.GenerateHttpClient();
                    HttpClient.Request request=client.GenerateEchoRequest("Hrello World");
                    httpClient.SendRequest(request);
                }
            }; //class SimpleEcho

            [TestGroup]
            public class RequiredPrivileges: TestNode
            {
                string cachedToken;

                public override void PreRun()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128 160 230 231 232 233 234 235 240 241 242 243 245 246 247 250 251 252 253 254 255");
                    cachedToken=generatedToken.ToString();
                }

                [StressTest]
                public void NoToken_SendReceive_Direct()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient(ProtocolToUse.Soap, false);
                    client.ExpectedHttpResponseCode=403;
                    client.Privileges_128_160_255();
                }

                [StressTest]
                public void NoToken_SendOnly_Direct()
                {
                    ServerTestFramework.LiveService.TestFdXsts.Soap.AttributeClient client=new ServerTestFramework.LiveService.TestFdXsts.Soap.AttributeClient();
                    HttpClient httpClient=client.GenerateHttpClient();
                    HttpClient.Request request=client.GeneratePrivileges_128_160_255Request();
                    httpClient.SendRequest(request);
                }

                [StressTest]
                public void WithToken_SendReceive_Direct()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient(ProtocolToUse.Soap, false);
                    client.AddClaimToken(cachedToken);
                    client.Privileges_128_160_255();
                }

                [StressTest]
                public void WithToken_SendOnly_Direct()
                {
                    ServerTestFramework.LiveService.TestFdXsts.Soap.AttributeClient client=new ServerTestFramework.LiveService.TestFdXsts.Soap.AttributeClient();
                    client.AddClaimToken(cachedToken);

                    HttpClient httpClient=client.GenerateHttpClient();
                    HttpClient.Request request=client.GeneratePrivileges_128_160_255Request();
                    httpClient.SendRequest(request);
                }
            }; //class RequiredPrivileges
        }; //class Soap

        [TestGroup]
        public class Wcf: TestNode
        {
            [TestGroup]
            public class SimpleEcho: TestNode
            {
                string cachedToken;

                public override void PreRun()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/device/type", "Xbox360");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", "fffe07d1");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/version", "1");
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid", "0900000000000000");
                    generatedToken.Assertion.IssueInstant=System.DateTime.UtcNow;
                    generatedToken.Assertion.Conditions.NotBefore=System.DateTime.MinValue;
                    generatedToken.Assertion.Conditions.NotOnOrAfter=System.DateTime.MaxValue;
                    cachedToken=generatedToken.ToString();
                }

                [StressTest]
                public void NoToken_SendReceive_Direct()
                {
                    SimpleClientBase client=SimpleClientBase.CreateClient(ProtocolToUse.Wcf, false);
                    string ret=client.Echo("Hello world");
                    ValueCheck.Test("Returned value from Echo", "Hello world", ret);
                }

                [StressTest]
                public void WithToken_SendReceive_Direct()
                {
                    SimpleClientBase client=SimpleClientBase.CreateClient(ProtocolToUse.Wcf, false);
                    client.AddClaimToken(cachedToken);
                    string ret=client.Echo("Hello world");
                    ValueCheck.Test("Returned value from Echo", "Hello world", ret);
                }
            }; //class SimpleEcho

            [TestGroup]
            public class RequiredPrivileges: TestNode
            {
                string cachedToken;

                public override void PreRun()
                {
                    XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                    generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges", "128 160 230 231 232 233 234 235 240 241 242 243 245 246 247 250 251 252 253 254 255");
                    cachedToken=generatedToken.ToString();
                }

                [StressTest]
                public void NoToken_SendReceive_Direct()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient(ProtocolToUse.Wcf, false);
                    client.ExpectedHttpResponseCode=403;
                    client.Privileges_128_160_255();
                }

                [StressTest]
                public void WithToken_SendReceive_Direct()
                {
                    AttributeClientBase client=AttributeClientBase.CreateClient(ProtocolToUse.Wcf, false);
                    client.AddClaimToken(cachedToken);
                    client.Privileges_128_160_255();
                }
            }
        }; //class Wcf
    }; //class Stress
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:27:46 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\TokenManipulation.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.TestFdXsts;

using Microsoft.IdentityModel.Claims;

namespace XstsPolicyEnforcementTests
{
    [TestGroup, Description("Tests that mess with tokens."), AsyncGroup(0, 6)]
    [CompoundCase("{0} Direct", ProtocolToUse.Soap, false, Tags="Transport=Direct;Protocol=Soap")]
    [CompoundCase("{0} Direct", ProtocolToUse.Wcf, false, Tags="Transport=Direct;Protocol=Wcf")]
    //[CompoundCase("{0} Direct", ProtocolToUse.Mvc, false, Tags="Transport=Direct;Protocol=Mvc")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Soap, true, Tags="Transport=AuthSg;Protocol=Soap")]
    [CompoundCase("{0} AuthSg", ProtocolToUse.Wcf, true, Tags="Transport=AuthSg;Protocol=Wcf")]
    //[CompoundCase("{0} AuthSg", ProtocolToUse.Mvc, true, Tags="Transport=AuthSg;Protocol=Mvc")]
    public class TokenManipulation: TestNode
    {
        public override void PreRun()
        {
            CreateContextData();
            SetContextData("Protocol", MyValues[0]);
            SetContextData("UseAuthSg", MyValues[1]);
        }

        [TestGroup, Description("Tests to abuse the types specified for values of tokens.")]
        public class ClaimTypes: TestNode
        {
            [TestCase, Description("Specify no type.")]
            public void Title_NoType()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Specify HexBinary correctly.")]
            public void Title_ValidHexBinary()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString(), ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Specify HexBinary but don't give a valid hex string.")]
            public void Title_BadHexBinary()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", "He11o", ClaimValueTypes.HexBinary);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Specify Integer but provide the actual value as unexpected HexBinary.")]
            public void Title_BadInteger()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", "0xFFFE07D1", ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Specify integer and give it the negative integer representation of the title id.")]
            public void Title_NegativeInteger()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", (unchecked((int)0xfffe07d1)).ToString(), ClaimValueTypes.Integer);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class ClaimTypes

        [TestGroup, Description("Change various things to verify that signature validation works.")]
        public class Signature: TestNode
        {
            [TestCase, Description("Alter the issue instant.")]
            public void IssueInstant()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                //change the IssueInstant so that the signature will not match
                ServerTestFramework.Global.RO.Debug("Original TokenString:\n"+tokenString);
                char []tokenStringChars=tokenString.ToCharArray();
                int indIssueInstant=tokenString.IndexOf("IssueInstant");
                tokenStringChars[indIssueInstant+34]=(char)(tokenStringChars[indIssueInstant+34]-1); //change the first millisecond place
                if (tokenStringChars[indIssueInstant+34]<'0')
                {
                    tokenStringChars[indIssueInstant+34]='9';
                }
                tokenString=new string(tokenStringChars);
                ServerTestFramework.Global.RO.Debug("Modified TokenString:\n"+tokenString);

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Alter a claim value.")]
            public void ClaimValue()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
                string tokenString=generatedToken.ToString();

                //change the IssueInstant so that the signature will not match
                ServerTestFramework.Global.RO.Debug("Original TokenString:\n"+tokenString);
                tokenString=tokenString.Replace(0xFFFE07D2.ToString(), 0xFFFE07D1.ToString());
                ServerTestFramework.Global.RO.Debug("Modified TokenString:\n"+tokenString);

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase, Description("Changing the issuer should invalidate the signature.")]
            public void ChangeIssuerAfterSignatureComputed()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Issuer.Value="xwtf.xboxlive.com";
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();
                tokenString=tokenString.Replace("xwtf.xboxlive.com", "xsts.xboxlive.com");

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class Signature

        [TestGroup, Description("Mess with the audience restrictions.")]
        public class Audience: TestNode
        {
            [TestCase]
            public void NoAudience()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase]
            public void DifferentSingleAudience()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://testfdwtf")));
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase]
            public void MultipleRestrictionsOneAudience()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://wrong0")));
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://testfdxsts"))); //matches
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri("http://wrong1")));
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase]
            public void SingleRestrictionMultipleAudiences()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Conditions.AudienceRestrictions.Clear();
                
                generatedToken.Assertion.Conditions.AudienceRestrictions.Add(
                    new Microsoft.IdentityModel.Tokens.Saml2.Saml2AudienceRestriction(new System.Uri[] {
                       new System.Uri("http://wrong0"),
                       new System.Uri("http://testfdxsts"), //matches
                       new System.Uri("http://wrong1")
                    })
                );
                
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class Audience

        [TestGroup, Description("The issuer field is not verified.  Only the mapping signature certificate subject is used.")]
        public class Issuer: TestNode
        {
            [TestCase]
            public void InvalidIssuer()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.Assertion.Issuer.Value="invalid.com";
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class Issuer

        [TestGroup, Description("Variations of valid date ranges.")]
        public class DateRange: TestNode
        {
            [TestCase]
            public void Expired()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.Assertion.Conditions.NotBefore=System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0);
                generatedToken.Assertion.Conditions.NotOnOrAfter=System.DateTime.UtcNow-new System.TimeSpan(0, 1, 0, 0); //1 hour ago
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=401;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }

            [TestCase]
            public void Future()
            {
                XSTSSaml2Token generatedToken=Global.CreateDefaultSaml2Token();
                generatedToken.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
                generatedToken.Assertion.Conditions.NotBefore=System.DateTime.UtcNow+new System.TimeSpan(0, 1, 0, 0); //1 hour in the future
                generatedToken.Assertion.Conditions.NotOnOrAfter=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
                string tokenString=generatedToken.ToString();

                AttributeClientBase client=AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
                client.ExpectedHttpResponseCode=403;
                client.AddClaimToken(tokenString);
                client.Titles_FFFE07D1();
            }
        }; //class DateRange

        [TestCase, Description("Include multiple authorization headers.  This is expected to fail.")]
        public void MultipleAuthHeaders()
        {
            XSTSSaml2Token generatedToken0=Global.CreateDefaultSaml2Token();
            generatedToken0.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D0.ToString());
            string tokenString0=generatedToken0.ToString();

            XSTSSaml2Token generatedToken1=Global.CreateDefaultSaml2Token();
            generatedToken1.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D1.ToString());
            string tokenString1=generatedToken1.ToString();

            XSTSSaml2Token generatedToken2=Global.CreateDefaultSaml2Token();
            generatedToken2.AddAutoTypedAttribute("http://schemas.microsoft.com/xbox/2011/07/claims/title/id", 0xFFFE07D2.ToString());
            string tokenString2=generatedToken2.ToString();

            ProtocolToUse protocol = (ProtocolToUse)GetContextData("Protocol");
            AttributeClientBase client = AttributeClientBase.CreateClient((ProtocolToUse)GetContextData("Protocol"), (bool)GetContextData("UseAuthSg"));
            client.ExpectedHttpResponseCode = (protocol == ProtocolToUse.Wcf) ? 403 : 400;
            client.AddClaimToken(tokenString0);
            client.AddClaimToken(tokenString1);
            client.AddClaimToken(tokenString2);
            client.Titles_FFFE07D1();
        }
    }; //class TokenManipulation
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\XSTSTests\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:27:46 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\XSTSTests\gettokentests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Linq;
using System.Xml.Linq;

using Microsoft.IdentityModel.Tokens;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.SecurityTokenService;

using Microsoft.XboxLive.Auth.Claims;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.TestFdXsts;
using ServerTestFramework.Utilities;

using xonline.common.sql.webstore;
using xonline.common.config;

namespace XSTSTests
{
    //Base class for these tests.
    public class XSTSTestBase : TestNode
    {
        public string GetDelegationToken(KdcUser user, string appTo)
        {
            RSTGenerator gen = Util.CreateDefaultRST();
            gen.AppliesTo = new System.ServiceModel.EndpointAddress(appTo);

            using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
            {                
                tokenReq.SetUser(0, user);

                string token = tokenReq.GetTokenStringFromSTS(gen);

                if (string.IsNullOrEmpty(token))
                {
                    throw new UnexpectedTestResultException("Did not get a token.");
                }
                return tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken);
            }            
        }

        public SecurityToken GenerateFakeToken()
        {
            XSTSSaml2Token generatedToken = new XSTSSaml2Token(XstsUtil.GetXstsSigningCertificate());

            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/device/type", "0");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/title/id", "4294836224");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/title/version", "1");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/user/id", "0x0000000000000000");
            generatedToken.Assertion.IssueInstant = DateTime.MinValue;
            generatedToken.Assertion.Conditions.NotBefore = DateTime.MinValue;
            generatedToken.Assertion.Conditions.NotOnOrAfter = DateTime.MinValue.AddHours(1);
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/user/country", "XX");

            return new Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityToken(generatedToken.Assertion);
        }

        public string GenerateFakeTokenString()
        {
            XSTSSaml2Token generatedToken = new XSTSSaml2Token(XstsUtil.GetXstsSigningCertificate());

            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/device/type", "0");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/title/id", "4294836224");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/title/version", "1");
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/user/id", "0x0000000000000000");
            generatedToken.Assertion.IssueInstant = DateTime.MinValue;
            generatedToken.Assertion.Conditions.NotBefore = DateTime.MinValue;
            generatedToken.Assertion.Conditions.NotOnOrAfter = DateTime.MinValue.AddHours(1);
            generatedToken.AddAttribute("http://schemas.microsoft.com/xbox/2011/02/claims/user/country", "XX");

            return generatedToken.ToString();
        }
    }

    public class XSTSTestGroup : TestNode
    {
        public static Dictionary<string, TestCaseData> LoadedTestCases
        {
            get;
            set;
        }

        private static SettingState lbState;
        private static ActiveAuthHttpConfig.PolicyEntry xstsPolicyState;

        public override void PreRun()
        {
            Util.CallHealthcheck();
            base.PreRun();
            lbState = Global.XEnv.OverrideSetting("ALL", "ALL", "aamodule_useLoadBalancerSslHeaders", "true");
            Global.XEnv.ForceConfigReload("aamodule");
            LoadedTestCases = Util.PushConfiguration(true);
            Util.LoadXSTSConfiguration();
            xstsPolicyState = ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/XSts/xsts.svc/IWSTrust13", true, "MBI", false, true) { AllowedAuthMethods = "WLID10,X509MUTUAL", AllowListHeadersOutgoing = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", AllowListHeadersIncoming = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", Instance = "" });
            
            Util.ReloadAA();
        }

        public override void PostRun()
        {
            if (lbState != null)
                Global.XEnv.RestoreOverrideSettingState(lbState);
            if (xstsPolicyState != null)
            {
                xstsPolicyState.Instance = String.Empty; 
                ActiveAuthHttpConfig.SetPolicyEntry(xstsPolicyState);
            }
            Util.ReloadAA();
        }       
    }
}

namespace XSTSTests.Functional
{
    /// <summary> Tests for calling the XSTS service. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class IssueToken : XSTSTestGroup
    {
        [TestCase, Description("Gets a token from the STS. Two test cases - one through the SG and one through the AASG"), TestCasePriority(2)]
        [CompoundCase("Mainline", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11, false)]
        [CompoundCase("UseAASG", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11, true)]
        public class Mainline : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string tokenType = (string)MyValues[0];
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.TokenType = tokenType;
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.UseAASG = (Boolean)MyValues[1];
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }
                }
            }
        }

        [TestCase, Description("Gets a token from XSTS by passing an XSTS token! Madness. Should fail."), TestCasePriority(2)]                
        public class SneakyXBL20 : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                
                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {                    
                    tokenReq.UseAASG = true;
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    tokenReq.XBL20Header = token;
                    string errorString = "401";
                    try
                    {
                        tokenReq.GetTokenStringFromSTS(gen);
                    }
                    catch (Exception ex)
                    {
                        if (errorString == null || !ex.Message.Contains(errorString))
                            throw;
                    }
                }
            }
        }

        [TestCase, Description("Gets a token that contains an explicitly different but good ownerpuid."), TestCasePriority(2)]
        public class HasOwnerPuid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress("http://allclaims_cert");

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser uChild = Util.CreateUser();
                    KdcUser uParent = Util.CreateUser();

                    UserEditor ueChild = UserEditor.FromPuid(uChild.UserID);
                    UserEditor ueParent = UserEditor.FromPuid(uParent.UserID);

                    ueChild.OwnerPassportPuid = (long)ueParent.UserPassportPuid;

                    tokenReq.SetUser(0, uChild);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }
                }
            }
        }

        [TestCase, Description("Gets a token that contains an explicitly different but bad ownerpuid. The claim should be missing."), TestCasePriority(2)]
        public class HasBadOwnerPuid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress("http://allclaims_cert");

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser uChild = Util.CreateUser();
                    UserEditor ueChild = UserEditor.FromPuid(uChild.UserID);


                    ueChild.OwnerPassportPuid = (long)101;

                    tokenReq.SetUser(0, uChild);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }
                }
            }
        }

        [TestCase, Description("Gets an XSTS token from the old STS. If you call STSv1 with an XSTS appliesTo it will produce a saml 2.0 token by making a server to server call to XSTS."), TestCasePriority(2)]
        public class STSV1 : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    CSGInfo slot = XSTSTokenRequestor.GetSlot();
                    slot.machinePuid = MachineEditor.CreateNew(MachineType.Phone).Id;
                    tokenReq.ServicesToUse = SecurityTokenServices.STS;
                    string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }                    
                }
            }
        }

        [TestGroup, Description("Tests that get a token from XSTS as a WindowsPhone")]
        public class XSTSWP : TestNode
        {
            public const String IssuerCertPath = @".\SuitesData\XSTS\int-net.xboxlive.com.pfx";
            public const String DefaultTitleId = "1481443286";
            public const String DefaultTitleVersion = "1";
            public const String DefaultClientVersion = "1";
            public const String DefaultCertSubjectName = "CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4";
            private static X509Certificate2 validClientCertificate;
            public static X509Certificate2 ValidClientCertificate
            {
                get
                {
                    if (validClientCertificate == null)
                    {
                        Global.RO.Info("Generating Valid WP Client Cert...");
                        CertificateGenerator certGenerator = new CertificateGenerator("CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", false);
                        // We need to add the default key usage
                        certGenerator.SetKeyUsage();
                        // And a custom extended key usage with client auth (1.3.6.1.5.5.7.3.2), and the custom WP key usage
                        certGenerator.SetExtendedKeyUsage("1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1");

                        validClientCertificate = certGenerator.Generate("Valid Generated WP7 Cert", IssuerCertPath);
                    }

                    return validClientCertificate;
                }
            }

            [TestCase, Description("Gets a token from XSTS as a WindowsPhone. These also test the additionalContext claims that can be sent in, namely titleid, titleversion and clientversion."), TestCasePriority(2)]
            [CompoundCase("Mainline", true, null, DefaultTitleId, DefaultTitleVersion, DefaultClientVersion)]
            [CompoundCase("NonexistantClientVersion", true, null, DefaultTitleId, DefaultTitleVersion, "65535")]
            [CompoundCase("HexTitleId", true, "Could not parse TitleId 0x584D07D6", "0x584D07D6", DefaultTitleVersion, DefaultClientVersion)]
            [CompoundCase("HexTitleVersion", true, "Could not parse TitleVersion 0x01", DefaultTitleId, "0x01", DefaultClientVersion)]
            [CompoundCase("HexClientVersion", true, "Could not parse ClientVersion 0x01", DefaultTitleId, DefaultTitleVersion, "0x01")]
            [CompoundCase("WithoutCertificate", false, "Title claim invalid. Not a trusted caller", DefaultTitleId, DefaultTitleVersion, DefaultClientVersion)]
            [CompoundCase("NegativeTitleVersion", true, "Could not parse TitleVersion -1", DefaultTitleId, "-1", DefaultClientVersion)]
            [CompoundCase("NegativeClientVersion", true, "Could not parse ClientVersion -1", DefaultTitleId, DefaultTitleVersion, "-1")]
            [CompoundCase("NonexistantTitleId", true, "0x80151912", "2864434397", DefaultTitleVersion, DefaultClientVersion)]
            [CompoundCase("NonexistantTitleVersion", true, "0x80151912", DefaultTitleId, "65535", DefaultClientVersion)]            
            [CompoundCase("TooBigTitleId", true, "Could not parse TitleId 4294967297", "4294967297", DefaultTitleVersion, DefaultClientVersion)] // This is UInt32.MaxValue + 2
            [CompoundCase("TooBigTitleVersion", true, "Could not parse TitleVersion 4294967297", DefaultTitleId, "4294967297", DefaultClientVersion)] // This is UInt32.MaxValue + 2
            [CompoundCase("TooBigClientVersion", true, "Could not parse ClientVersion 4294967297", DefaultTitleId, DefaultTitleVersion, "4294967297")] // This is UInt32.MaxValue + 2
            [CompoundCase("MissingTitleId", true, "Invalid RST AdditionalContext", null, DefaultTitleVersion, DefaultClientVersion)]
            [CompoundCase("MissingTitleVersion", true, "Invalid RST AdditionalContext", DefaultTitleId, null, DefaultClientVersion)]
            [CompoundCase("MissingClientVersion", true, "Invalid RST AdditionalContext", DefaultTitleId, DefaultTitleVersion, null)]
            public class Simple : XSTSTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    // Games Hub title ID
                    TitleEditor titleEditor = TitleEditor.CreateOrUseExistingId(UInt32.Parse(DefaultTitleId));
                    titleEditor.ConsoleType = 5; // case 5: return XOn.XPLT_MOBILE;
                    titleEditor.RemoveAllVersions();
                    titleEditor.AddVersion(1, 1, 0, 5);

                    Util.LoadXSTSConfiguration();
                }

                public override void Run(RUN_TYPE runType)
                {
                    Boolean useClientCert = (Boolean)MyValues[0];
                    String errorString = (String)MyValues[1];
                    String titleId = (String)MyValues[2];
                    String titleVersion = (String)MyValues[3];
                    String clientVersion = (String)MyValues[4];

                    RSTGenerator gen = Util.CreateDefaultRST();
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    gen.AdditionalContext = new AdditionalContext();

                    if (titleId != null)
                    {
                        gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleId), titleId));
                    }

                    if (titleVersion != null)
                    {
                        gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleVersion), titleVersion));
                    }

                    if (clientVersion != null)
                    {
                        gen.AdditionalContext.Items.Add(new ContextItem(new Uri("http://schemas.microsoft.com/xbox/2011/07/claims/device/clientversion"), clientVersion));
                    }

                    for (int k = 0; k < 2; k++) // Do this twice to trigger both the regular flow as well as the device creation flow. Doesn't matter if we hit error scenarios twice it's ok this is fast :)
                    {
                        using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                        {
                            CSGInfo slot = XSTSTokenRequestor.GetSlot();
                            slot.titleId = 0x584D07D6;
                            slot.titleVersion = 1;
                            tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                            if (useClientCert)
                            {
                                tokenReq.ClientCert = ValidClientCertificate;
                            }
                            tokenReq.UseAASG = true;

                            try
                            {
                                string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                                if (errorString != null)
                                {
                                    throw new UnexpectedTestResultException(String.Format("Didn't get '{0}' error as expected.", errorString));
                                }

                                if (string.IsNullOrEmpty(token))
                                {
                                    throw new UnexpectedTestResultException("Did not get a token.");
                                }

                                Global.RO.Success("Token successfully retrieved.");
                            }
                            catch (UnexpectedTestResultException)
                            {
                                throw;
                            }
                            catch (ExpectedValueCheckException)
                            {
                                throw;
                            }
                            catch (Exception ex)
                            {
                                if (errorString == null)
                                {
                                    throw new UnexpectedTestResultException("Expected request to succeed", ex);
                                }

                                if (ex.Message.Contains(errorString))
                                {
                                    Global.RO.Success("Request failed with expected error: " + errorString);
                                }
                                else if (tokenReq.XErr == errorString)
                                {
                                    Global.RO.Success("Got expected XErr: " + tokenReq.XErr);
                                }
                                else
                                {
                                    throw new UnexpectedTestResultException(String.Format("Didn't get expected error: '{0}'", errorString), ex);
                                }
                            }
                        }
                    }
                }
            }
            
            [TestCase, Description("Attempt to get a token from the STS using a certificate that's valid or invalid in some special way. These include the WindowsPhone8 certs."), TestCasePriority(2)]
            [CompoundCase("ExtraEKU", null, "CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1", "1.3.6.1.5.5.7.3.3" })]
            // Don't know if we should actually be rejecting certs without this KeyUsage
            //[CompoundCase("NoKeyEnciphermentKU", null, "CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", 0xD0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            // This cert will get rejected with a 403 before it even gets to authsg
            //[CompoundCase("NoClientAuthEKU", null, "CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", 0xF0, new String[] { "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("NoWP7EKU", "Title claim invalid. Not a trusted caller", "CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2" })]
            [CompoundCase("InvalidSubjectName", null, "CN=NotAWP7Certificate", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("NonexistantSubject", null, "CN=urn:wp-ac-hash:ABCDEFGHIJK-123456789012345678912345INVALID", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("EmptySubject", null, "CN=urn:wp-ac-hash:", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("EmptySubjectWP8", null, "CN=urn:wp-ac-hash-2:", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("InvalidOUWP8", null, "CN=urn:wp-ac-hash-2:wn9g4-R6gBivWjq9yxMxhACQkjGWzcvs5-3cwypFB-Y,OU=POOP", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]            
            [CompoundCase("ValidCertWP8", null, "CN=urn:wp-ac-hash-2:wn9g4-R6gBivWjq9yxMxhACQkjGWzcvs5-3cwypFB-Y,OU=1234567891234567891234567891234567891234567891234567891234567890", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("EmptyOUWP8", null, "CN=urn:wp-ac-hash-2:wn9g4-R6gBivWjq9yxMxhACQkjGWzcvs5-3cwypFB-Y,OU=", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("NoOUWP8", null, "CN=urn:wp-ac-hash-2:wn9g4-R6gBivWjq9yxMxhACQkjGWzcvs5-3cwypFB-Y", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]            
            [CompoundCase("WP7WP8Prefix", null, "CN=urn:wp-ac-hash-2:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]
            [CompoundCase("WP8WP7Prefix", null, "CN=urn:wp-ac-hash:wn9g4-R6gBivWjq9yxMxhACQkjGWzcvs5-3cwypFB-Y,OU=1234567891234567891234567891234567891234567891234567891234567890", 0xF0, new String[] { "1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1" })]            
            public class VariousCerts : XSTSTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    // Games Hub title ID
                    TitleEditor titleEditor = TitleEditor.CreateOrUseExistingId(0x584D07D6);
                    titleEditor.ConsoleType = 5; // case 5: return XOn.XPLT_MOBILE;
                    titleEditor.RemoveAllVersions();
                    titleEditor.AddVersion(1, 1, 0, 5);

                    Util.LoadXSTSConfiguration();
                }

                public override void Run(RUN_TYPE runType)
                {
                    String errorString = MyValues[0] as String;
                    String certSubject = MyValues[1] as String;
                    Int32 keyUsage = (Int32)MyValues[2];
                    String[] extendedKeyUsage = MyValues[3] as String[];

                    RSTGenerator gen = Util.CreateDefaultRST();
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleId), DefaultTitleId));
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleVersion), DefaultTitleVersion));
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri("http://schemas.microsoft.com/xbox/2011/07/claims/device/clientversion"), DefaultClientVersion));

                    CertificateGenerator certGenerator = new CertificateGenerator(certSubject, false);                    
                    // We need to add the default key usage
                    certGenerator.SetKeyUsage(keyUsage);
                    // And a custom extended key usage with client auth (1.3.6.1.5.5.7.3.2), and the custom WP key usage
                    certGenerator.SetExtendedKeyUsage(extendedKeyUsage);

                    var cert = certGenerator.Generate("Sample WP7 Cert", IssuerCertPath);

                    for (int k = 0; k < 2; k++) // Do this twice to trigger both the regular flow as well as the device creation flow. Doesn't matter if we hit error scenarios twice it's ok this is fast :)
                    {
                        using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                        {
                            CSGInfo slot = XSTSTokenRequestor.GetSlot();
                            slot.machinePuid = 0;
                            slot.titleId = uint.Parse("584D07D6", System.Globalization.NumberStyles.HexNumber);
                            slot.titleVersion = uint.Parse("1", System.Globalization.NumberStyles.HexNumber);
                            tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                            tokenReq.ClientCert = cert;
                            tokenReq.UseAASG = true;

                            try
                            {
                                string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                                if (errorString != null)
                                {
                                    throw new UnexpectedTestResultException(String.Format("Didn't get '{0}' error as expected.", errorString));
                                }

                                if (string.IsNullOrEmpty(token))
                                {
                                    throw new UnexpectedTestResultException("Did not get a token.");
                                }

                                Global.RO.Success("Token successfully retrieved.");
                            }
                            catch (UnexpectedTestResultException)
                            {
                                throw;
                            }
                            catch (Exception ex)
                            {
                                if (errorString == null)
                                {
                                    throw new UnexpectedTestResultException("Expected request to succeed", ex);
                                }

                                String message = null;
                                try
                                {
                                    var resp = XDocument.Parse(ex.Message);
                                    XNamespace sm = "http://schemas.datacontract.org/2004/07/System.ServiceModel";
                                    message = resp.Descendants(sm + "Message").First().Value;
                                }
                                catch
                                {
                                    // We didn't get an exception with a soap body, so just throw it out
                                    throw;
                                }

                                if (!ex.Message.Contains(errorString))
                                {
                                    throw new UnexpectedTestResultException(String.Format("Expected '{0}' error, got '{1}'", errorString, message), ex);
                                }
                                else
                                {
                                    Global.RO.Success("Request failed with expected error: " + errorString);
                                }
                            }
                        }
                    }
                }
            }

            [TestCase, Description("Attempt to get a token from the STS using a cert that's not valid yet"), TestCasePriority(3)]
            public class CertNotValidYet : XSTSTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    // Games Hub title ID
                    TitleEditor titleEditor = TitleEditor.CreateOrUseExistingId(0x584D07D6);
                    titleEditor.ConsoleType = 5; // case 5: return XOn.XPLT_MOBILE;
                    titleEditor.RemoveAllVersions();
                    titleEditor.AddVersion(1, 1, 0, 5);

                    Util.LoadXSTSConfiguration();
                }

                public override void Run(RUN_TYPE runType)
                {
                    RSTGenerator gen = Util.CreateDefaultRST();
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleId), "0x584D07D6"));
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleVersion), "1"));

                    CertificateGenerator certGenerator = new CertificateGenerator("CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", false);
                    // We need to add the default key usage
                    certGenerator.SetKeyUsage();
                    // And a custom extended key usage with client auth (1.3.6.1.5.5.7.3.2), and the custom WP key usage
                    certGenerator.SetExtendedKeyUsage("1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1");
                    certGenerator.Generator.SetNotBefore(DateTime.UtcNow.AddDays(1));

                    var cert = certGenerator.Generate("Not Valid Yet Sample WP7 Cert", IssuerCertPath);

                    using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                    {
                        CSGInfo slot = XSTSTokenRequestor.GetSlot();
                        slot.machinePuid = 0;
                        slot.titleId = uint.Parse("584D07D6", System.Globalization.NumberStyles.HexNumber);
                        slot.titleVersion = uint.Parse("1", System.Globalization.NumberStyles.HexNumber);
                        tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                        tokenReq.ClientCert = cert;
                        tokenReq.UseAASG = true;

                        try
                        {
                            string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                            throw new UnexpectedTestResultException("Expected client certificate to return a 403");
                        }
                        catch (System.Net.WebException we)
                        {
                            ValueCheck.Test("TokenRequest HTTP Response Status Code", System.Net.HttpStatusCode.Forbidden, ((System.Net.HttpWebResponse)we.Response).StatusCode);
                            Global.RO.Success("Recieved 403 as expected");
                        }
                    }
                }
            }

            [TestCase, Description("Attempt to get a token from the STS using a cert that's expired"), TestCasePriority(3)]
            public class ExpiredCert : XSTSTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    // Games Hub title ID
                    TitleEditor titleEditor = TitleEditor.CreateOrUseExistingId(0x584D07D6);
                    titleEditor.ConsoleType = 5; // case 5: return XOn.XPLT_MOBILE;
                    titleEditor.RemoveAllVersions();
                    titleEditor.AddVersion(1, 1, 0, 5);

                    Util.LoadXSTSConfiguration();
                }

                public override void Run(RUN_TYPE runType)
                {
                    RSTGenerator gen = Util.CreateDefaultRST();
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleId), "0x584D07D6"));
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleVersion), "1"));

                    CertificateGenerator certGenerator = new CertificateGenerator("CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", false);
                    // We need to add the default key usage
                    certGenerator.SetKeyUsage();
                    // And a custom extended key usage with client auth (1.3.6.1.5.5.7.3.2), and the custom WP key usage
                    certGenerator.SetExtendedKeyUsage("1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1");
                    certGenerator.Generator.SetNotBefore(DateTime.UtcNow.AddDays(-10));
                    certGenerator.Generator.SetNotAfter(DateTime.UtcNow.AddDays(-5));

                    var cert = certGenerator.Generate("Expired Sample WP7 Cert", IssuerCertPath);

                    using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                    {
                        CSGInfo slot = XSTSTokenRequestor.GetSlot();
                        slot.machinePuid = 0;
                        slot.titleId = uint.Parse("584D07D6", System.Globalization.NumberStyles.HexNumber);
                        slot.titleVersion = uint.Parse("1", System.Globalization.NumberStyles.HexNumber);
                        tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                        tokenReq.ClientCert = cert;
                        tokenReq.UseAASG = true;

                        try
                        {
                            string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                            throw new UnexpectedTestResultException("Expected client certificate to return a 403");
                        }
                        catch (System.Net.WebException we)
                        {
                            ValueCheck.Test("TokenRequest HTTP Response Status Code", System.Net.HttpStatusCode.Forbidden, ((System.Net.HttpWebResponse)we.Response).StatusCode);
                            Global.RO.Success("Recieved 403 as expected");
                        }
                    }
                }
            }

            [TestCase, Description("Attempt to get a token from the STS using a self signed cert"), TestCasePriority(3)]
            public class SelfSignedCert : XSTSTestBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    // Games Hub title ID
                    TitleEditor titleEditor = TitleEditor.CreateOrUseExistingId(0x584D07D6);
                    titleEditor.ConsoleType = 5; // case 5: return XOn.XPLT_MOBILE;
                    titleEditor.RemoveAllVersions();
                    titleEditor.AddVersion(1, 1, 0, 5);

                    Util.LoadXSTSConfiguration();
                }

                public override void Run(RUN_TYPE runType)
                {
                    RSTGenerator gen = Util.CreateDefaultRST();
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleId), "0x584D07D6"));
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.TitleVersion), "1"));

                    CertificateGenerator certGenerator = new CertificateGenerator("CN=urn:wp-ac-hash:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4", false);
                    // We need to add the default key usage
                    certGenerator.SetKeyUsage();
                    // And a custom extended key usage with client auth (1.3.6.1.5.5.7.3.2), and the custom WP key usage
                    certGenerator.SetExtendedKeyUsage("1.3.6.1.5.5.7.3.2", "1.3.6.1.4.1.311.71.1.1");

                    var cert = certGenerator.Generate("Self-Signed Sample WP7 Cert");
                    var n = cert.ToString();
                    n += "";
                    var o = cert.Subject;
                    o += "";

                    using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                    {
                        CSGInfo slot = XSTSTokenRequestor.GetSlot();
                        slot.machinePuid = 0;
                        slot.titleId = uint.Parse("584D07D6", System.Globalization.NumberStyles.HexNumber);
                        slot.titleVersion = uint.Parse("1", System.Globalization.NumberStyles.HexNumber);
                        tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                        tokenReq.ClientCert = cert;
                        tokenReq.UseAASG = true;

                        try
                        {
                            string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                            throw new UnexpectedTestResultException("Expected client certificate to return a 403");
                        }
                        catch (System.Net.WebException we)
                        {
                            ValueCheck.Test("TokenRequest HTTP Response Status Code", System.Net.HttpStatusCode.Forbidden, ((System.Net.HttpWebResponse)we.Response).StatusCode);
                            Global.RO.Success("Recieved 403 as expected");
                        }
                    }
                }
            }
        }

        [TestCase, Description("Gets a token from XSTS while the user is not in xcache. This results in a db lookup, but still a complete token."), TestCasePriority(2)]
        public class NotInXCache : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser u = new KdcUser();                    
                    u.CreateUser(true);
                    tokenReq.UseAASG = true;
                    tokenReq.SetUser(0, u);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }                    
                }

            }
        }

        [TestCase, Description("Gets a token from XSTS using bad xuids in the additional context."), TestCasePriority(2)]
        [CompoundCase("Empty", "")]
        [CompoundCase("Invalid", "0xtrololol")]
        public class BadStringXuidTests : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Principal not authorized";
                string customXuid = (string)MyValues[0];
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);
                gen.XuidOverride = customXuid;

                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();

                try
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }

                tokenReq.Dispose();
            }
        }

        [TestCase, Description("Gets a token from XSTS using xuids that don't match anyone."), TestCasePriority(2)]
        [CompoundCase("Zero", "0x0")]
        [CompoundCase("Max", "0xFFFFFFFFFFFFFFFF")]
        public class MismatchedXuidTests : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Principal not authorized";
                string errorString2 = "Invalid RST";

                string customXuid = (string)MyValues[0];
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);
                gen.XuidOverride = customXuid;

                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                try
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || (!ex.Message.Contains(errorString) && !ex.Message.Contains(errorString2)))
                        throw;
                }
                finally
                {
                    tokenReq.Dispose();
                }
            }
        }

        [TestCase, Description("Gets a token from XSTS but sending a ginormous request."), TestCasePriority(2)]
        public class HugeRequest : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "404"; //Xrl will force a 404
                StringBuilder sb = new StringBuilder();
                for (int k = 0; k < 10000; k++)
                    sb.Append("X");

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);
                gen.BodyOverride = sb.ToString();

                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                try
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
                finally
                {
                    tokenReq.Dispose();
                }
            }
        }

        [TestCase, Description("Gets a token from the STS for a specific user index (Players 1-4)."), TestCasePriority(1)]
        [CompoundCase("UserIndex0_1users", 0, 1)]
        [CompoundCase("UserIndex0_2users", 0, 2)]
        [CompoundCase("UserIndex0_3users", 0, 3)]
        [CompoundCase("UserIndex0_4users", 0, 4)]
        [CompoundCase("UserIndex1_2users", 1, 2)]
        [CompoundCase("UserIndex1_3users", 1, 3)]
        [CompoundCase("UserIndex1_4users", 1, 4)]
        [CompoundCase("UserIndex2_3users", 2, 3)]
        [CompoundCase("UserIndex2_4users", 2, 4)]
        [CompoundCase("UserIndex3_4users", 3, 4)]
        public class UserIndexes : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                int userIndex = (int)MyValues[0];
                int totalUsers = (int)MyValues[1];
                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.UsersInTicket = totalUsers;
                    tokenReq.UserIndex = userIndex;
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }
                    
                }
            }
        }

        [TestCase, Description("Gets a token from XSTS using a banned user - expect a failure."), TestCasePriority(2)]
        public class BannedUser : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.SetUser(0, Util.CreateUser(false, true));

                    string errorString = "Banned User!";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("What. This should not have worked.");
                    }
                    catch (Exception ex)
                    {
                        if (errorString == null || !ex.Message.Contains(errorString))
                            throw;
                    }
                }
            }
        }
        
        [TestCase, Description("Gets a token from XSTS using a user that has not yet signed the TOS, expect a 'Maintenance' status claim."), TestCasePriority(2)]
        public class NoTOS : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.SetUser(0, Util.CreateUser(false, false));

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new Exception("Did not get a token.");
                    }                    
                }
            }
        }
        
        [TestCase, Description("Gets a token from XSTS using a passport that has not been linked to an Xbox Live account. Expect a 'puid not found' error."), TestCasePriority(2)]
        public class UnlinkedPassport : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    long puid;
                    tokenReq.UseAASG = true;
                    KdcUser u = Util.CreateUser(true, false);
                    u.LinkPassport(null);
                    UserEditor ue = UserEditor.FromPuid(u.UserID);
                    puid = ue.UserPassportPuid;
                    ue.UnlinkAllPassports();                    

                    tokenReq.SetUser(0, u);

                    string errorString = "Passport puid " + puid + " not found";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("What. This should not have worked.");
                    }
                    catch (Exception ex)
                    {
                        if (errorString == null || !ex.Message.Contains(errorString))
                            throw;
                    }
                }
            }
        }
        
        [TestCase, Description("Gets a token from the STS for a specific user of a specific age."), TestCasePriority(1)]
        [CompoundCase("17Year", 17)]
        [CompoundCase("10Year", 10)]
        [CompoundCase("30Year", 30)]
        public class Birthdates : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                DateTime birthdate = (DateTime.UtcNow.AddYears(-(int)MyValues[0]));

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                KdcUser u = Util.CreateUser(true, false);
                UserEditor ue = UserEditor.FromPuid(u.UserID);
                ue.Birthdate = birthdate;

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.SetUser(0, u);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new Exception("Did not get a token.");
                    }
                }
            }
        }

        [TestCase, Description("Different device types! These tests send up machine puids that match different device types."), TestCasePriority(1)]
        [CompoundCase("PC", MachineType.PC)]
        [CompoundCase("WindowsPhone7", MachineType.Phone)]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Xbox1", MachineType.Xbox1)] //Should fall under web.
        public class DeviceTypes : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);


                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    CSGInfo slot = new CSGInfo();
                    slot.Initialize();
                    slot.machinePuid = MachineEditor.CreateNew((MachineType)MyValues[0]).Id;

                    slot.ClearServices();
                    slot.AddService((int)XOService.Vortex);
                    slot.AddService((int)XOService.XSts);
                    slot.SetPrivilege((int)XOn.XPRIVILEGE_ADD_FRIEND);

                    string token = tokenReq.GetTokenStringFromSTS(gen, slot);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new Exception("Did not get a token.");
                    }                    
                }
            }
        }
    }

    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class XblToken : XSTSTestGroup
    {
        [TestCase, Description("Gets a token from XSTS requesting the new cached token stuff."), TestCasePriority(2)]
        [CompoundCase("Mainline", "http://schemas.microsoft.com/xbox/2011/07/tokens/xboxlive#1.0", true)]
        public class Mainline : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string tokenType = (string)MyValues[0];

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.TokenType = tokenType;
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    tokenReq.UseAASG = (Boolean)MyValues[1];
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }                    
                }
            }
        }

        [TestCase, Description("Send a bad xbltoken to the AuthSG (TODO:I don't think this test is good... this should go through 'CallService')"), TestCasePriority(2)]
        [CompoundCase("Mainline", "http://schemas.microsoft.com/xbox/2011/07/tokens/xboxlive#1.0", true)]
        public class SpoofedTokenId : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string tokenType = (string)MyValues[0];

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.TokenType = tokenType;
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    tokenReq.UseAASG = (Boolean)MyValues[1];
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    tokenReq.XBL20Header = "<XblToken Id=\"A1B2C3D4E5F5E4D3B2A1000000000000A1B2C3D4E5F5E4D3B2A1000000000000\" />";
                    string errorString = "401";
                    try
                    {
                        tokenReq.GetTokenStringFromSTS(gen);
                    }
                    catch (Exception ex)
                    {
                        if (errorString == null || !ex.Message.Contains(errorString))
                            throw;
                    }

                }
            }
        }
    }

    /// <summary> Tests for calling the XSTS service. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class MultiToken : XSTSTestGroup
    {
        [TestCase, Description("Gets a regular token and a xamiam token from XSTS through the 'console' and uses them against the authsg."), TestCasePriority(2)]
        [CompoundCase("SG", false)]        
        public class XamIAm_Mainline : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator xamGen = Util.CreateDefaultRST();
                RSTGenerator realGen = Util.CreateDefaultRST();

                xamGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.XAM_URL);
                realGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    CSGInfo slot = XSTSTokenRequestor.GetSlot();
                    slot.machinePuid = MachineEditor.CreateNew().Id;

                    xamTokenReq.UseAASG = false;
                    realTokenReq.UseAASG = false;

                    string xamToken = xamTokenReq.GetTokenStringFromSTS(xamGen, slot);
                    string realToken = realTokenReq.GetTokenStringFromSTS(realGen, slot);
                    string token = xamToken + realToken;                    
                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }                    
                }
            }
        }

        [TestCase, Description("Gets a regular token and a xamiam token from XSTS through the AASG and uses them against the authsg. Expect fail due to missing device claims."), TestCasePriority(2)]
        [CompoundCase("SG", false)]
        public class XamIAm_AASG : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator xamGen = Util.CreateDefaultRST();
                RSTGenerator realGen = Util.CreateDefaultRST();

                xamGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.XAM_URL);
                realGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    CSGInfo slot = XSTSTokenRequestor.GetSlot();
                    slot.machinePuid = MachineEditor.CreateNew().Id;

                    xamTokenReq.UseAASG = true;
                    realTokenReq.UseAASG = true;

                    string xamToken = xamTokenReq.GetTokenStringFromSTS(xamGen, slot);
                    string realToken = realTokenReq.GetTokenStringFromSTS(realGen, slot);
                    string token = xamToken + realToken;
                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("Expected failure.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets a xamiam token from xsts and calls the authsg with it. Sends different machine claim values so expect a mismatch failure."), TestCasePriority(2)]
        public class DifferentMachineClaimValues : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator xamGen = Util.CreateDefaultRST();
                RSTGenerator realGen = Util.CreateDefaultRST();

                xamGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.XAM_URL);
                realGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(xamGen);
                    string realToken = realTokenReq.GetTokenStringFromSTS(realGen);
                    string token = xamToken + realToken;
                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("Expected failure.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets a xamiam token from xsts and calls the authsg with it. Sends different claim values so expect a mismatch failure."), TestCasePriority(2)]
        public class DifferentOtherClaimValues : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo = "http://onlyxuidandmachine";
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo);
                RSTGenerator genA = Util.CreateDefaultRST();
                RSTGenerator genB = Util.CreateDefaultRST();

                genA.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                genB.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(genA);
                    string realToken = realTokenReq.GetTokenStringFromSTS(genB);
                    string token = xamToken + realToken;

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("The test case should have \"failed\". The call made it through to the test service when it should have 403d.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets a xamiam token from XSTS and calls the authsg with it. One of them is missing the device claim. Expect failure."), TestCasePriority(2)]
        public class MissingDeviceClaimA : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo1 = "http://onlyxuid";
                string appliesTo2 = "http://onlyxuidandmachine";
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo1);
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo2);

                RSTGenerator genA = Util.CreateDefaultRST();
                RSTGenerator genB = Util.CreateDefaultRST();

                genA.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo1);
                genB.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo2);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(genA);
                    string realToken = realTokenReq.GetTokenStringFromSTS(genB);
                    string token = xamToken + realToken;

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("The test case should have \"failed\". The call made it through to the test service when it should have 403d.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets a xamiam token from xsts and calls the authsg with it. Same as MissingDeviceClaimA but the opposite claim."), TestCasePriority(2)]
        public class MissingDeviceClaimB : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo1 = "http://onlyxuid";
                string appliesTo2 = "http://onlyxuidandmachine";
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo1);
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo2);

                RSTGenerator genA = Util.CreateDefaultRST();
                RSTGenerator genB = Util.CreateDefaultRST();

                genA.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo2);
                genB.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo1);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(genA);
                    string realToken = realTokenReq.GetTokenStringFromSTS(genB);
                    string token = xamToken + realToken;

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("The test case should have \"failed\". The call made it through to the test service when it should have 403d.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets a xamiam token from xsts and calls the authsg with it. No device claim at all."), TestCasePriority(2)]
        public class MissingDeviceClaimBoth : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo = "http://onlyxuid";
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo);
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), xonline.common.config.Component.aamodule, "-1", "ALL", "aamodule_audienceUris", appliesTo);

                RSTGenerator genA = Util.CreateDefaultRST();
                RSTGenerator genB = Util.CreateDefaultRST();

                genA.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                genB.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(genA);
                    string realToken = realTokenReq.GetTokenStringFromSTS(genB);
                    string token = xamToken + realToken;

                    try
                    {
                        Util.CallRPService(token, Util.AUTHSG_URL);
                        throw new Exception("The test case should have \"failed\". The call made it through to the test service when it should have 403d.");
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains("403"))
                            throw ex;
                    }
                }
            }
        }

        [TestCase, Description("Gets 4 different tokens, merges them, and calls the authsg with them. All match so it should just work."), TestCasePriority(2)]
        public class Quadra : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator xamGen = Util.CreateDefaultRST();
                RSTGenerator realGen = Util.CreateDefaultRST();

                xamGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.XAM_URL);
                realGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor xamTokenReq = new XSTSTokenRequestor())
                using (XSTSTokenRequestor realTokenReq = new XSTSTokenRequestor())
                {
                    CSGInfo slot = XSTSTokenRequestor.GetSlot();
                    string xamToken = xamTokenReq.GetTokenStringFromSTS(xamGen, slot);
                    string realToken = realTokenReq.GetTokenStringFromSTS(realGen, slot);
                    string token = xamToken + realToken + xamToken + realToken; //This is the magic. 4 times the fun!                    
                }
            }
        }
    }

    /// <summary> Tests for calling the XSTS service. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class Management : XSTSTestGroup
    {
        [TestCase, Description("Basic Health Check call."), TestCasePriority(2)]
        public class HealthCheck : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                List<string> results = Util.CallHealthcheck();

                foreach (string r in results)
                {
                    Global.RO.Debug(r);
                }

                XDocument d = XDocument.Parse(results[0]);
                string currentColor = d.Element("Healthcheck").Attribute("HealthStatus").Value;


                if (currentColor != "Green" || currentColor == null)
                    throw new Exception("Healthcheck is not working for XSTS. Its color is: " + currentColor);
            }
        }

        [TestCase, Description("Check that the help xmgmt command works."), TestCasePriority(2)]
        public class Xmgmt_Help : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string result = Util.CallXmgmt("help");

                Global.RO.Debug(result);

                if (!result.Contains("EventThrottler help"))
                    throw new Exception("Something was wrong with the help command, it did not run properly. See output.");
            }
        }

        [TestCase, Description("Check that the reload xmgmt command works."), TestCasePriority(2)]
        public class Xmgmt_Reload : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string result = Util.CallXmgmt("reload");

                Global.RO.Debug(result);

                if (!result.Contains("XSts configuration and title info have been reloaded"))
                    throw new Exception("Something was wrong with the reload command, it did not run properly. See output.");
            }
        }

        [TestCase, Description("Check that the list xmgmt command works."), TestCasePriority(2)]
        public class Xmgmt_List : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string result = Util.CallXmgmt("list");

                Global.RO.Debug(result);

                if (!result.Contains("Applies Tos"))
                    throw new Exception("Something was wrong with the list command, it did not run properly. See output.");
            }
        }

        [TestCase, Description("Check that a gibberish xmgmt command gets ignored."), TestCasePriority(2)]
        public class Xmgmt_Hurrgurble : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string result = Util.CallXmgmt("Hurrgurble");

                Global.RO.Debug(result);

                if (!result.Contains("Unknown command"))
                    throw new Exception("Something was wrong with the Hurrgurble command, it ran properly. See output.");
            }
        }
    }

    /// <summary> Tests for calling the XSTS service with delegation tokens. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(2)]
    public class DelegationTokenTests : XSTSTestGroup
    {        
        [TestCase, Description("Use a delegation token to get token from the STS. This uses a client cert to prove it is authorized to use a delegation token on behalf of a user."), TestCasePriority(2)]
        public class DelegationToken : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                base.PreRun();
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);                
                Util.ReloadAA();
            }

            public override void PostRun()
            {
                base.PostRun();
                Util.RemoveDelegationTokenAppTo(bpid, appTo);
                Util.RemoveBusinessPartner(bpid);
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appTo);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.SetUser(0, user);
                        delegationReq.UseAASG = true;
                        delegationGen.UseDelegationToken = true;
                        delegationReq.UseDelegationToken = true;
                        delegationReq.ClientCertNameOverride = cert.Subject;
                        delegationReq.ClientCertThumbprintOverride = cert.Thumbprint;


                        token = delegationReq.GetTokenStringFromSTS(delegationGen);

                        if (string.IsNullOrEmpty(token))
                        {
                            throw new UnexpectedTestResultException("Did not get token from delegation token.");
                        }                        
                    }
                }
            }
        }

        [TestCase, Description("Also sends a xuid along with the request, while pretending to be a console with no client cert. This should not work."), TestCasePriority(2)]
        public class DelegationToken_SG_Xuid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.Xuid), ((xonline.common.service.Puid)user.UserID).ToString()));


                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.SetUser(0, user);

                        string errorString = "Principal not authorized";
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);

                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }
                    }
                }
            }
        }

        [TestCase, Description("Same as _Xuid, but without sending the xuid. Basically pretend to be a console that is being sneaky."), TestCasePriority(2)]
        public class DelegationToken_SG_NoXuid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.SetUser(0, user);
                        string errorString = "Principal not authorized";
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);

                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }
                    }
                }
            }
        }

        [TestCase, Description("Use a delegation token to get token from XSTS. Send an RPS ticket along for the ride to force XSTS to read out a puid. Should fail - we want only one form of auth."), TestCasePriority(2)]
        public class DelegationToken_AndRPSTicket : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.SetUser(0, user);
                        delegationReq.UseAASG = true;
                        delegationReq.ClientCertNameOverride = "_default_";

                        string errorString = "Delegation operation invalid. Principal already has a puid.";
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);
                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }
                    }
                }
            }
        }

        [TestCase, Description("Use a delegation token to get an XSTS but send no cert. Expect failure."), TestCasePriority(2)]
        public class DelegationToken_NoCert : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.SetUser(0, user);
                        delegationReq.UseAASG = true;


                        string errorString = "No client cert claim.";
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);
                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }
                    }
                }
            }
        }

        [TestCase, Description("Use a delegation token to get an XSTS token for a banned user. Expect failure."), TestCasePriority(2)]
        public class DelegationToken_Banned : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                base.PreRun();
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);                
                Util.ReloadAA();
            }

            public override void PostRun()
            {
                base.PostRun();
                Util.RemoveDelegationTokenAppTo(bpid, appTo);                
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appTo);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {

                        //Ban his stupid face
                        UserEditor ue = UserEditor.FromPuid(user.UserID);
                        ue.BannedUntilDate = DateTime.Now.AddDays(10);

                        delegationReq.SetUser(0, user);
                        delegationReq.UseAASG = true;
                        delegationGen.UseDelegationToken = true;
                        delegationReq.UseDelegationToken = true;
                        delegationReq.ClientCertNameOverride = cert.Subject;
                        delegationReq.ClientCertThumbprintOverride = cert.Thumbprint;

                        string errorString = "Banned User!";
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);
                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }
                    }
                }
            }
        }

        [TestCase, Description("Use a delegation token to get an XSTS token using a client cert, but make the cert mismatch everything. Just some random cert."), TestCasePriority(2)]
        public class DelegationTokenMismatch : XSTSTestBase
        {
            Guid bpid;
            Guid bpid2;

            X509Certificate2 cert1bp1;
            X509Certificate2 cert2bp1;

            X509Certificate2 cert1bp2;
            X509Certificate2 cert2bp2;

            string appTo;
            string appTo2;

            public override void PreRun()
            {
                base.PreRun();

                bpid = Util.CreateBusinessPartner();
                bpid2 = Util.CreateBusinessPartner();

                appTo = Util.CreateDelegationTokenAppTo(bpid);
                appTo2 = Util.CreateDelegationTokenAppTo(bpid2);

                cert1bp1 = Util.CreateCert(bpid);
                cert2bp1 = Util.CreateCert(bpid);

                cert1bp2 = Util.CreateCert(bpid2);
                cert2bp2 = Util.CreateCert(bpid2);

                Util.AddBusinessPartnerCert(bpid, cert1bp1);
                Util.AddBusinessPartnerCert(bpid, cert2bp1);

                Util.AddBusinessPartnerCert(bpid2, cert1bp2);
                Util.AddBusinessPartnerCert(bpid2, cert2bp2);

                appTo = Util.CreateDelegationTokenAppTo(bpid);               

                //Ok so the logic is, two business partners have two certs each. I will get a token 
                //from BP1, and use a cert from BP2. Mismatch error should occur.

                Util.ReloadAA();
            }

            public override void PostRun()
            {
                base.PostRun();
                Util.RemoveDelegationTokenAppTo(bpid, appTo);
                Util.RemoveBusinessPartner(bpid);
                Util.RemoveBusinessPartner(bpid2);
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appTo);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new Exception("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.UseAASG = true;
                        delegationGen.UseDelegationToken = true;
                        delegationReq.UseDelegationToken = true;

                        delegationReq.ClientCertNameOverride = cert1bp2.Subject;
                        delegationReq.ClientCertThumbprintOverride = cert1bp2.Thumbprint;

                        string errorString = "Delegation operation invalid. Delegation token to client certificate mismatch."; //Oh noes client cert is bad mmkay.
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);
                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }

                        if (string.IsNullOrEmpty(token))
                        {
                            throw new Exception("Did not get token from delegation token.");
                        }
                    }
                }

            }
        }

        [TestCase, Description("Use a delegation token to get an XSTS token but sending funky cert subjects."), TestCasePriority(2)]
        [CompoundCase("Empty", "", "(401) Unauthorized.")]        
        [CompoundCase("Invalid", "lololthisisn'treal", "Delegation operation invalid. Delegation token to client certificate mismatch.")]
        public class DelegationTokenCertNames : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new Exception("Did not get a token.");
                    }

                    RSTGenerator delegationGen = Util.CreateDefaultRST();
                    delegationGen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);
                    delegationGen.AdditionalContext = new AdditionalContext();
                    delegationGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), tokenReq.GetClaimValue(AuthClaimTypes.DelegationToken)));

                    using (XSTSTokenRequestor delegationReq = new XSTSTokenRequestor())
                    {
                        delegationReq.UseAASG = true;
                        delegationReq.UseDelegationToken = true;
                        delegationReq.ClientCertNameOverride = (string)MyValues[0];
                        delegationGen.UseDelegationToken = true;

                        string errorString = (string)MyValues[1];
                        try
                        {
                            token = delegationReq.GetTokenStringFromSTS(delegationGen);
                            throw new UnexpectedTestResultException("What. This should not have worked.");
                        }
                        catch (Exception ex)
                        {
                            if (errorString == null || !ex.Message.Contains(errorString))
                                throw;
                        }

                        if (string.IsNullOrEmpty(token))
                        {
                            throw new Exception("Did not get token from delegation token.");
                        }
                    }
                }

            }
        }
    }

    [TestGroup, Owner("wisgt"), TestCasePriority(2)]
    public class AASGPartnerCertTests : XSTSTestGroup
    {
        ActiveAuthHttpConfig.PolicyEntry cachedXstsPolicy = null;
        public override void PreRun()
        {
            base.PreRun();
            cachedXstsPolicy = ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/XSts/xsts.svc/IWSTrust13", true, "MBI", false, true) { AllowedAuthMethods = "WLID10,X509TRUSTEDMUTUAL", AllowListHeadersOutgoing = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", AllowListHeadersIncoming = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", Instance=""});            
            Util.ReloadAA();
        }

        public override void PostRun()
        {
            base.PostRun();
            //Set it back to normal mid-test-case-run-settings
            if (cachedXstsPolicy != null)
            {
                cachedXstsPolicy.Instance = String.Empty;
                ActiveAuthHttpConfig.SetPolicyEntry(cachedXstsPolicy);
            }
            Util.ReloadAA();
        }                

        [TestCase, Description("Verifies that the partner cert mapping works")]
        public class AASG_PartnerCert_BVT : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);                
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust13");
                Util.SetBusinessPartnerConnectionPolicy(bpid, "/testfdxstssoap/Simple.asmx");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);
                
                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.SetUser(0, user);
                    tokenReq.UseAASG = true;
                    tokenReq.UseDelegationToken = true;
                    
                    
                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }


                    //For fun. Just to see the identities printed out.
                    List<string> headers = new List<string>();
                    headers.Add(xonline.common.service.XHttpHdr.CERT_SUBJECT + ":" + cert.Subject);
                    headers.Add(xonline.common.service.XHttpHdr.CERT_THUMBPRINT + ":" + cert.Thumbprint);
                    headers.Add(xonline.common.service.XHttpHdr.LOADBALANCER_ISSSL + ":true");

                    Util.CallRPService(token, Util.SERVICE_URL, headers.ToArray());
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);                    
                }                
            }
        }

        [TestCase, Description("Verifies that the request is blocked when there is no partner policy mapping")]
        public class AASG_PartnerCert_NoPartnerMapping : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;
            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));
                    
                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;                    
                    

                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    String expectedError = "The remote server returned an error: (403) Forbidden.";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS succeeded unexpectedly");
                    }
                    catch (UnexpectedTestResultException)
                    {
                        throw;
                    }
                    catch (Exception e)
                    {
                        if (!e.Message.Contains(expectedError))
                        {
                            throw;
                        }

                        Global.RO.Success("GetTokenStringFromSTS failed as expected");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [TestCase, Description("Verifies that the request is blocked when only some other partner cert is mapped")]
        public class AASG_PartnerCert_OtherPartnerAllowed : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;
            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(Guid.NewGuid(), "/xsts/xsts.svc/IWSTrust13");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;                    

                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    String expectedError = "The remote server returned an error: (403) Forbidden.";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS succeeded unexpectedly");
                    }
                    catch (UnexpectedTestResultException)
                    {
                        throw;
                    }
                    catch (Exception e)
                    {
                        if (!e.Message.Contains(expectedError))
                        {
                            throw;
                        }

                        Global.RO.Success("GetTokenStringFromSTS failed as expected");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [TestCase, Description("Verifies that the request is blocked when partner cert is mapped to a different API")]
        public class AASG_PartnerCert_OtherAPIAllowed : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);
                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust14");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;                    

                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    String expectedError = "The remote server returned an error: (403) Forbidden.";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS succeeded unexpectedly");
                    }
                    catch (UnexpectedTestResultException)
                    {
                        throw;
                    }
                    catch (Exception e)
                    {
                        if (!e.Message.Contains(expectedError))
                        {
                            throw;
                        }

                        Global.RO.Success("GetTokenStringFromSTS failed as expected");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [TestCase, Description("Verifies that a request is allowed with multiple partners mapped to the same API")]
        public class AASG_PartnerCert_MultiplePartnersAllowed_First : XSTSTestBase
        {
            Guid bpidOne;
            X509Certificate2 certOne;
            Guid bpidTwo;
            X509Certificate2 certTwo;
            string appTo;
            public override void PreRun()
            {
                // Generate one partner
                certOne = null;
                bpidOne = Util.CreateBusinessPartner(ref certOne);
                appTo = Util.CreateDelegationTokenAppTo(bpidOne);
                Util.SetBusinessPartnerConnectionPolicy(bpidOne, "/xsts/xsts.svc/IWSTrust13");

                // Then generate a second that we will use
                certTwo = null;
                bpidTwo = Util.CreateBusinessPartner(ref certTwo);
                Util.SetBusinessPartnerConnectionPolicy(bpidTwo, "/xsts/xsts.svc/IWSTrust13");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;
                    tokenReq.ClientCertNameOverride = certOne.Subject;
                    tokenReq.ClientCertThumbprintOverride = certOne.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpidOne != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpidOne, appTo);
                    Util.RemoveBusinessPartner(bpidOne);
                }

                if (bpidTwo != Guid.Empty)
                {
                    Util.RemoveBusinessPartner(bpidTwo);
                }
            }
        }

        [TestCase, Description("Verifies that a request is allowed with multiple APIs mapped to the same partner")]
        public class AASG_PartnerCert_MultipleAPIsAllowed_First : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust13");
                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust14");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;
                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [TestCase, Description("Verifies that a request is allowed with multiple partners mapped to the same API")]
        public class AASG_PartnerCert_MultiplePartnersAllowed_Last : XSTSTestBase
        {
            Guid bpidOne;
            X509Certificate2 certOne;
            Guid bpidTwo;
            X509Certificate2 certTwo;
            string appTo;

            public override void PreRun()
            {
                // Generate the second partner
                certTwo = null;
                bpidTwo = Util.CreateBusinessPartner(ref certTwo);
                Util.SetBusinessPartnerConnectionPolicy(bpidTwo, "/xsts/xsts.svc/IWSTrust13");

                // Then the first that we'll use
                certOne = null;
                bpidOne = Util.CreateBusinessPartner(ref certOne);
                Util.SetBusinessPartnerConnectionPolicy(bpidOne, "/xsts/xsts.svc/IWSTrust13");
                appTo = Util.CreateDelegationTokenAppTo(bpidOne);

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;
                    tokenReq.ClientCertNameOverride = certOne.Subject;
                    tokenReq.ClientCertThumbprintOverride = certOne.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpidOne != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpidOne, appTo);
                    Util.RemoveBusinessPartner(bpidOne);
                }

                if (bpidTwo != Guid.Empty)
                {
                    Util.RemoveBusinessPartner(bpidTwo);
                }
            }
        }

        [TestCase, Description("Verifies that a request is allowed with multiple APIs mapped to the same partner")]
        public class AASG_PartnerCert_MultipleAPIsAllowed_Last : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust14");
                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust13");
                
                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;
                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [Ignore("Currently, there is no easy way to point the XSTSTokenRequest at a different endpoint that has only X509TrustedMutual enabled, so we can't ensure the request is blocked")]
        [TestCase, Description("Verifies that the request is blocked when there is no partner cert mapping")]
        public class AASG_PartnerCert_InvalidThumbprint : XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust13");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.SERVICE_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);

                    gen.UseDelegationToken = true;
                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));

                    tokenReq.UseDelegationToken = true;
                    tokenReq.UseAASG = true;
                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint + "NOT VALID!!!";

                    String expectedError = "The remote server returned an error: (403) Forbidden.";
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS succeeded unexpectedly");
                    }
                    catch (UnexpectedTestResultException)
                    {
                        throw;
                    }
                    catch (Exception e)
                    {
                        if (!e.Message.Contains(expectedError))
                        {
                            throw;
                        }

                        Global.RO.Success("GetTokenStringFromSTS failed as expected");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }

        [TestCase, Description("Verifies that the partner cert mapping works")]
        public class AASG_PartnerCertAndXAuth: XSTSTestBase
        {
            Guid bpid;
            X509Certificate2 cert;
            string appTo;

            public override void PreRun()
            {
                cert = null;
                bpid = Util.CreateBusinessPartner(ref cert);
                appTo = Util.CreateDelegationTokenAppTo(bpid);

                Util.SetBusinessPartnerConnectionPolicy(bpid, "/xsts/xsts.svc/IWSTrust13");

                Util.ReloadAA();
            }

            public override void Run(RUN_TYPE runType)
            {
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    KdcUser user = Util.CreateUser();
                    tokenReq.SetUser(0, user);                    

                    gen.AdditionalContext = new AdditionalContext();
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.DelegationToken), GetDelegationToken(user, appTo)));
                    
                    tokenReq.UseAASG = true;
                    tokenReq.UseDelegationToken = true;
                    gen.UseDelegationToken = true;

                    tokenReq.ClientCertNameOverride = cert.Subject;
                    tokenReq.ClientCertThumbprintOverride = cert.Thumbprint;

                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    tokenReq.XBL20Header = token;

                    var newToken = tokenReq.GetTokenFromSTS(gen);
                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("GetTokenStringFromSTS failed.");
                    }
                }
            }

            public override void PostRun()
            {
                if (bpid != Guid.Empty)
                {
                    Util.RemoveDelegationTokenAppTo(bpid, appTo);
                    Util.RemoveBusinessPartner(bpid);
                }
            }
        }
    }

    /// <summary> Tests for calling the XSTS service. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class RSTFieldTests : XSTSTestGroup
    {
        [TestCase, Description("Sends a token in the ActAs"), TestCasePriority(2)]        
        public class ActAs : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";

                string appliesTo = Util.SERVICE_URL;
                RSTGenerator gen = Util.CreateDefaultRST();

                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ActAs = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (ex.Message.Contains("there was no token handlers registered to read a ActAs element."))
                        throw new KnownBugException(1, "We are knowingly not handling this.", ex);

                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }

            }
        }
        [TestCase, Description("Sends a token in the CancelTarget"), TestCasePriority(2)]
        public class CancelTarget : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";

                string appliesTo = Util.SERVICE_URL;
                RSTGenerator gen = Util.CreateDefaultRST();

                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.CancelTarget = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }
        [TestCase, Description("Sends a value in the ClientPseudonym field"), TestCasePriority(2)]
        public class ClientPseudonym : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ClientPseudonym = "TestValue";

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }
        [TestCase, Description("Sends a value in the ComputedKeyAlgorithm field"), TestCasePriority(2)]
        public class ComputedKeyAlgorithm : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ComputedKeyAlgorithm = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }
        [TestCase, Description("Sends a value in the Delegatable field"), TestCasePriority(2)]
        public class Delegatable : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Delegatable = true;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the DelegateTo field"), TestCasePriority(2)]
        public class DelegateTo : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo = Util.SERVICE_URL;
                string errorString = "Invalid RST";
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.DelegateTo = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the DisplayTokenLanguage field"), TestCasePriority(2)]
        public class DisplayTokenLanguage : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST DisplayTokenLanguage";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.DisplayTokenLanguage = "TestValue";
                gen.RequestDisplayToken = true;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Encryption field"), TestCasePriority(2)]
        public class Encryption : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Encryption = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }


        [TestCase, Description("Sends a value in the Forwardable field"), TestCasePriority(2)]
        public class Forwardable : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Forwardable = true;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the InformationCardReference field"), TestCasePriority(2)]
        public class InformationCardReference : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.InformationCardReference = new Microsoft.IdentityModel.Protocols.WSIdentity.InformationCardReference();

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Issuer field"), TestCasePriority(2)]
        public class Issuer : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Issuer = new System.ServiceModel.EndpointAddress("http://someissuer.com");

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the OnBehalfOf field"), TestCasePriority(2)]
        public class OnBehalfOf : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.OnBehalfOf = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (ex.Message.Contains("there was no token handlers registered to read a OnBehalfOf element."))
                        throw new KnownBugException(1, "We are knowingly not handling this.", ex);

                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Participants field"), TestCasePriority(2)]
        public class Participants : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Participants = new Microsoft.IdentityModel.SecurityTokenService.Participants();
                gen.Participants.Primary = new System.ServiceModel.EndpointAddress("http://lol.com");


                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the ProofEncryption field"), TestCasePriority(2)]
        public class ProofEncryption : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ProofEncryption = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Renewing field"), TestCasePriority(2)]
        public class Renewing_Test : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Renewing = new Renewing();

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the RenewTarget field"), TestCasePriority(2)]
        public class RenewTarget : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.RenewTarget = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the RequestDisplayToken field"), TestCasePriority(2)]
        public class RequestDisplayToken : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.RequestDisplayToken = true;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the SecondaryParameters field"), TestCasePriority(2)]
        public class SecondaryParameters : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.SecondaryParameters = new RequestSecurityToken();

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the ValidateTarget field"), TestCasePriority(2)]
        public class ValidateTarget : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ValidateTarget = new SecurityTokenElement(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the AllowPostdating field"), TestCasePriority(2)]
        public class AllowPostdating : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.AllowPostdating = true;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the AuthenticationType field"), TestCasePriority(2)]
        public class AuthenticationType : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.AuthenticationType = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the BinaryExchange field"), TestCasePriority(2)]
        public class BinaryExchange : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.BinaryExchange = new Microsoft.IdentityModel.SecurityTokenService.BinaryExchange(new byte[] { 3, 4 }, new Uri("http://microsoft.com"));

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the CanonicalizationAlgorithm field"), TestCasePriority(2)]
        public class CanonicalizationAlgorithm : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.CanonicalizationAlgorithm = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the EncryptionAlgorithm field"), TestCasePriority(2)]
        public class EncryptionAlgorithm : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.EncryptionAlgorithm = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the EncryptWith field"), TestCasePriority(2)]
        public class EncryptWith : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.EncryptWith = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Entropy field"), TestCasePriority(2)]
        public class Entropy_Test : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Entropy = new Entropy(new byte[] { 3, 4, 5 });

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the KeySizeInBits field"), TestCasePriority(2)]
        public class KeySizeInBits : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.KeySizeInBits = 0;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }
        
        [TestCase, Description("Sends a value in the KeyWrapAlgorithm field"), TestCasePriority(2)]
        public class KeyWrapAlgorithm : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.KeyWrapAlgorithm = "http://testfxsts";

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the Lifetime field"), TestCasePriority(2)]
        public class Lifetime_Test : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.Lifetime = new Lifetime(DateTime.Now, DateTime.Now.AddDays(50));

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the SignatureAlgorithm field"), TestCasePriority(2)]
        public class SignatureAlgorithm : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.SignatureAlgorithm = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the SignWith field"), TestCasePriority(2)]
        public class SignWith : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.SignWith = Util.SERVICE_URL;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Sends a value in the UseKey field"), TestCasePriority(2)]
        public class UseKey_Test : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string errorString = "Invalid RST";
                string appliesTo = Util.SERVICE_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);

                gen.UseKey = new UseKey(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (ex.Message.Contains("The 'UseKey' token contained in the WS-Trust message is not able to create an RsaKeyIdentifierClause"))
                        throw new KnownBugException(1, "We are knowingly not handling this.", ex);

                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Plays around with the ReplyTo field."), TestCasePriority(2)]
        [CompoundCase("NotAnonymous", "http://www.microsoft.com")]
        [CompoundCase("Null", null)]
        [CompoundCase("Empty", "")]
        //[CompoundCase("Invalid", "$sadkshadklh")]        
        public class ReplyTo : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string replyTo = (string)MyValues[0];
                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.ReplyTo = replyTo;

                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                string token = tokenReq.GetTokenStringFromSTS(gen);

                if (string.IsNullOrEmpty(token))
                {
                    throw new UnexpectedTestResultException("Did not get a token.");
                }
            }
        }

        [TestCase, Description("Plays around with the AppliesTo field."), TestCasePriority(2)]
        [CompoundCase("UnrecognizedUri", "http://www.IMadeThisUp.com", "XSts is not configured for the requested 'appliesTo' address 'http://www.imadethisup.com/'.")]
        [CompoundCase("NoAppliesTo", "", "Invalid RST AppliesTo")]
        public class AppliesTo : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string appliesTo = (string)MyValues[0];
                string errorString = (string)MyValues[1];

                RSTGenerator gen = Util.CreateDefaultRST();
                if (!String.IsNullOrEmpty(appliesTo))
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Plays around with invalid values for the RequestType field."), TestCasePriority(2)]
        [CompoundCase("Cancel", WSTrust13Constants.RequestTypes.Cancel, "is not supported")]
        [CompoundCase("Renew", WSTrust13Constants.RequestTypes.Renew, "is not supported")]
        [CompoundCase("Validate", WSTrust13Constants.RequestTypes.Validate, "is not supported")]
        [CompoundCase("Null", null, "Unrecognized RequestType")]
        [CompoundCase("Empty", "", "Unrecognized RequestType")]
        //[CompoundCase("Invalid", "http://Crap.com")]
        public class RequestType_Invalid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string requestType = (string)MyValues[0];
                string errorString = null;
                if (MyValues.Length > 1)
                    errorString = (string)MyValues[1];

                string appliesTo = Util.AUTHSG_URL;
                RSTGenerator gen = Util.CreateDefaultRST();

                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.RequestType = requestType;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Makes sure valid requesttypes work."), TestCasePriority(2)]
        [CompoundCase("Issue", WSTrust13Constants.RequestTypes.Issue)]
        public class RequestType_Valid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string requestType = (string)MyValues[0];

                string appliesTo = Util.AUTHSG_URL;
                RSTGenerator gen = Util.CreateDefaultRST();

                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.RequestType = requestType;


                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                }
            }
        }

        [TestCase, Description("Plays around with invalid values for the KeyType field."), TestCasePriority(2)]
        [CompoundCase("Asymmetric", WSTrust13Constants.KeyTypes.Asymmetric)]
        [CompoundCase("Symmetric", WSTrust13Constants.KeyTypes.Symmetric)]
        [CompoundCase("Empty", "")]
        [CompoundCase("Null", null)]
        public class KeyType_Invalid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {

                string keyType = (string)MyValues[0];
                string errorString = "Invalid RST";

                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.KeyType = keyType;
                if (!String.IsNullOrEmpty(keyType) && keyType.EndsWith("PublicKey"))
                    gen.UseKey = new UseKey(GenerateFakeToken());

                string token = null;

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (ex.Message.Contains("The 'UseKey' token contained in the WS-Trust message is not able to create an RsaKeyIdentifierClause"))
                        throw new KnownBugException(1, "We are knowingly not handling this.", ex);

                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Makes sure valid keytypes work."), TestCasePriority(2)]
        [CompoundCase("Bearer", WSTrust13Constants.KeyTypes.Bearer)]
        public class KeyType_Valid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string keyType = (string)MyValues[0];

                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.KeyType = keyType;
                if (!String.IsNullOrEmpty(keyType) && keyType.EndsWith("PublicKey"))
                    gen.UseKey = new UseKey(GenerateFakeToken());

                string token = null;

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    token = tokenReq.GetTokenStringFromSTS(gen);
                }
            }
        }

        [TestCase, Description("Plays around with different invalid tokentypes."), TestCasePriority(2)]
        [CompoundCase("Kerberos", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Kerberos, "Invalid RST TokenType")]
        [CompoundCase("Invalid", "http://gibberish.com/crapthatisunsupported/", "Requested TokenType 'http://gibberish.com/crapthatisunsupported/' is not supported")]
        [CompoundCase("OasisWssSaml11TokenProfile11", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml11TokenProfile11, "Invalid RST TokenType")]
        [CompoundCase("Rsa", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Rsa, "Invalid RST TokenType")]
        [CompoundCase("Saml11TokenProfile11", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Saml11TokenProfile11, "Invalid RST TokenType")]
        [CompoundCase("Saml2TokenProfile11", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Saml2TokenProfile11, "Invalid RST TokenType")]
        [CompoundCase("UserName", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.UserName, "Invalid RST TokenType")]
        [CompoundCase("X509Certificate", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X509Certificate, "Invalid RST TokenType")]
        public class TokenType_Invalid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string tokenType = (string)MyValues[0];
                string errorString = null;
                if (MyValues.Length > 1)
                    errorString = (string)MyValues[1];
                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.TokenType = tokenType;

                //if (!String.IsNullOrEmpty(tokenType) && gen.TokenType.EndsWith("Kerberos"))
                //gen.UseKey = new UseKey(GenerateFakeToken());

                try
                {
                    XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                    throw new UnexpectedTestResultException("What. This should not have worked.");
                }
                catch (Exception ex)
                {
                    if (ex.Message.Contains("The 'UseKey' token contained in the WS-Trust message is not able to create an RsaKeyIdentifierClause"))
                        throw new KnownBugException(1, "We are knowingly not handling this."); 

                    if (errorString == null || !ex.Message.Contains(errorString))
                        throw;
                }
            }
        }

        [TestCase, Description("Tries out the supported tokentypes."), TestCasePriority(2)]
        [CompoundCase("Null", null)]
        [CompoundCase("Empty", "")]
        [CompoundCase("OasisWssSaml2TokenProfile11", Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11)]
        public class TokenType_Valid : XSTSTestBase
        {
            public override void Run(RUN_TYPE runType)
            {
                string tokenType = (string)MyValues[0];
                string errorString = null;
                if (MyValues.Length > 1)
                    errorString = (string)MyValues[1];
                string appliesTo = Util.AUTHSG_URL;

                RSTGenerator gen = Util.CreateDefaultRST();
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(appliesTo);
                gen.TokenType = tokenType;

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    string token = tokenReq.GetTokenStringFromSTS(gen);
                }
            }
        }
    }

    /*/// <summary> Tests for calling the XSTS service while under DBLimiter's effects. </summary>
    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    public class DBLimiter : XSTSTestGroup
    {
        SettingState orig_kdcsvc_managed_limitThreadPercentThreshold = null;
        SettingState orig_kdcsvc_managed_limitThreadPercentPerPartition = null;
        SettingState orig_kdcsvc_managed_simulateDbLatencyInMs = null;        
        public override void PreRun()
        {
            //save the original settings
            orig_kdcsvc_managed_limitThreadPercentThreshold = Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, 1);
            orig_kdcsvc_managed_limitThreadPercentPerPartition = Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, 1);
            orig_kdcsvc_managed_simulateDbLatencyInMs = Global.XEnv.GetOverrideSettingState("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, 1);            

            //override the settings.  We want throttling enabled after 1 request in progress.  We want 1 thread allowed per partition.  We want highly latent requests.
            float currentMaxThreads = Config.GetIntSetting(Setting.kdcsvc_core_ATQThreads);
            float throttleStartPercent = 100.01f / currentMaxThreads; //account for floating point error
            float percentPerPartition = 100.01f / currentMaxThreads; //account for floating point error
            int dbLatencyInMs = 10000; //1 seconds

            Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentThreshold to: " + throttleStartPercent);
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentThreshold, throttleStartPercent.ToString());
            Global.RO.Debug("Setting kdcsvc_managed_limitThreadPercentPerPartition to: " + percentPerPartition);
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_limitThreadPercentPerPartition, percentPerPartition.ToString());
            Global.RO.Debug("Setting kdcsvc_managed_simulateDbLatencyInMs to: " + dbLatencyInMs);
            Global.XEnv.OverrideSetting("ALL", "ALL", Setting.kdcsvc_managed_simulateDbLatencyInMs, dbLatencyInMs.ToString());            

            Util.ReloadXSTS();
            Util.LoadXSTSConfiguration();
            Util.ResetDBLimiterState();
        }

        public override void PostRun()
        {
            bool needRefresh = false;

            if (orig_kdcsvc_managed_limitThreadPercentThreshold != null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_limitThreadPercentThreshold.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_limitThreadPercentThreshold);
                orig_kdcsvc_managed_limitThreadPercentThreshold = null;
                needRefresh = true;
            }

            if (orig_kdcsvc_managed_limitThreadPercentPerPartition != null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_limitThreadPercentPerPartition.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_limitThreadPercentPerPartition);
                orig_kdcsvc_managed_limitThreadPercentPerPartition = null;
                needRefresh = true;
            }

            if (orig_kdcsvc_managed_simulateDbLatencyInMs != null)
            {
                //restore the original trust setting state
                Global.RO.Debug("Restoring kdcsvc_managed_simulateDbLatencyInMs.");
                Global.XEnv.RestoreOverrideSettingState(orig_kdcsvc_managed_simulateDbLatencyInMs);
                orig_kdcsvc_managed_simulateDbLatencyInMs = null;
                needRefresh = true;
            }

            if (needRefresh)
            {
                Util.ReloadXSTS();
            }
        }

        [TestCase, Description("Gets a token from the STS while we're locking up on these"), TestCasePriority(2)]
        [CompoundCase("Mainline", false)]
        [CompoundCase("UseAASG", true)]
        public class Mainline : XSTSTestBase
        {
            public override void PreRun()
            {
                Util.SaturateUodbPartitions(null);
            }

            public override void Run(RUN_TYPE runType)
            {                
                RSTGenerator gen = Util.CreateDefaultRST();
                gen.TokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11;
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.UseAASG = (Boolean)MyValues[0];
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    string token = tokenReq.GetTokenStringFromSTS(gen);

                    if (string.IsNullOrEmpty(token))
                    {
                        throw new UnexpectedTestResultException("Did not get a token.");
                    }
                }
            }
        }

        
    }*/

    [TestGroup, Owner("wisgt"), TestCasePriority(1)]
    [CompoundCase("SG", false)]
    [CompoundCase("AASG", true)]
    public class XSTSXMLTests : XSTSTestGroup
    {
        public XSTSXMLTests()
        {
            Dictionary<string, TestCaseData> loadedTestCases = Util.PushConfiguration(false);
            foreach (TestCaseData tcd in loadedTestCases.Values)
            {
                XSTSXMLTest tc = new XSTSXMLTest();
                tc.Name = tcd.TestName;

                tc.TaggingData.AddTagValue("Priority", "1");
                AddChild(tc, true, false);
            }
        }
    }

    public class XSTSXMLTest : XSTSTestBase
    {
        public override void Run()
        {
            TestCaseData data = XSTSTestGroup.LoadedTestCases[this.Name];
            try
            {
                bool useAasg = (bool)this.Parent.MyValues[0];
                RSTGenerator gen = Util.CreateDefaultRST();
                try
                {
                    if (!string.IsNullOrEmpty(XSTSTestGroup.LoadedTestCases[this.Name].appliesTo.uri))
                    {
                        gen.AppliesTo = new System.ServiceModel.EndpointAddress(new Uri(XSTSTestGroup.LoadedTestCases[this.Name].appliesTo.uri));
                    }
                }
                catch (System.UriFormatException)
                {
                    gen.AppliesTo = new System.ServiceModel.EndpointAddress(new Uri(Util.AUTHSG_URL));
                }

                if (data.OnDemand && !data.TestOnly)
                    Util.PropTestCaseData(data);

                using (XSTSTokenRequestor tokenReq = new XSTSTokenRequestor())
                {
                    tokenReq.UseAASG = useAasg;
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(gen);

                        if (string.IsNullOrEmpty(token))
                        {
                            throw new UnexpectedTestResultException("Did not get a token.");
                        }

                        if (!string.IsNullOrEmpty(data.ExpectedStatus) && !string.IsNullOrEmpty(data.ExpectedXErr))
                        {
                            if (((int)tokenReq.StatusCode) != int.Parse(data.ExpectedStatus) || tokenReq.XErr != data.ExpectedXErr)
                            {
                                string sMessage = string.Format("Unexpected Status or XErr. Expected (0} (1) received {2} {3}.", data.ExpectedStatus, data.ExpectedXErr, tokenReq.StatusCode, String.IsNullOrEmpty(tokenReq.XErr) ? "<NULL>" : tokenReq.XErr);
                                throw new UnexpectedTestResultException(sMessage);
                            }
                        }
                    }
                    catch (Exception ex) 
                    {
                        if (!string.IsNullOrEmpty(data.ExpectedStatus) && !string.IsNullOrEmpty(data.ExpectedXErr))
                        {
                            if (((int)tokenReq.StatusCode) != int.Parse(data.ExpectedStatus) || tokenReq.XErr != data.ExpectedXErr)
                            {
                                string sMessage = string.Format("Unexpected Status or XErr. Expected (0} (1) received {2} {3}.", data.ExpectedStatus, data.ExpectedXErr, tokenReq.StatusCode, String.IsNullOrEmpty(tokenReq.XErr) ? "<NULL>" : tokenReq.XErr);
                                throw new UnexpectedTestResultException(sMessage, ex);
                            }
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
            }
            finally
            {
                if (data.OnDemand && !data.TestOnly)
                    Util.UnPropTestCaseData(data);
            }
        }
    }
}

namespace XSTSTests.Stress
{
    [TestGroup, Owner("wisgt")]
    public class IssueTokenStress : XSTSTestBase
    {
        private static ActiveAuthHttpConfig.PolicyEntry xstsPolicyState;
        public override void PreRun()
        {
            base.PreRun();
            xstsPolicyState = ActiveAuthHttpConfig.SetPolicyEntry(new ActiveAuthHttpConfig.PolicyEntry("/XSts/xsts.svc/IWSTrust13", true, "MBI", false, true) { AllowedAuthMethods = "WLID10,X509MUTUAL", AllowListHeadersOutgoing = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", AllowListHeadersIncoming = "cache-control,SOAPAction,X-Err,X-ClientType,Last-Modified,Vary,Content-Encoding,Accept-Language,Cookie,Accept-Charset,X-Forwarded-For,x-xbl-contract-version,x-xbl-build-version", Instance = "" });
            Util.ReloadAA();
            PropStressAppliesTos();
        }

        public override void PostRun()
        {
            if (xstsPolicyState != null)
            {
                xstsPolicyState.Instance = String.Empty;
                ActiveAuthHttpConfig.SetPolicyEntry(xstsPolicyState);
            }
            Util.ReloadAA();
        }

        public void PropStressAppliesTos()
        {
            Util.PushConfiguration(true);
            List<TestCaseData.AppliesTo> appliesTos = new List<TestCaseData.AppliesTo>();
            List<string> stressClaims = new List<string>();

            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/delegationtoken");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/device/id");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/device/pdid");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/device/name");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/device/type");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/flowtoken");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/title/id");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/title/version");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/agegroup");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/pxuid");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/clientipport");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/country");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/gamertag");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/language");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/privileges");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/puid");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/status");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/tier");
            stressClaims.Add("http://schemas.microsoft.com/xbox/2011/07/claims/user/xuid");

            for (int k = 0; k < 500; k++)
            {
                TestCaseData.AppliesTo appTo = new TestCaseData.AppliesTo();
                appTo.businessPartnerId = "10000000-0000-0000-0000-000000000001";
                appTo.cert = "MIIC5DCCAcygAwIBAgIQVzSqvBoksLNPAV4cZvaH7zANBgkqhkiG9w0BAQUFADAWMRQwEgYDVQQDEwtTVFNUZXN0Q2VydDAeFw0xMTAyMjYwMDI1NTRaFw0xMjAyMjYwNjI1NTRaMBYxFDASBgNVBAMTC1NUU1Rlc3RDZXJ0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAn6TWPpn3ZTqu3UJMFSiT6IenSbdwkxuDzCnkrSYMCc/sH7QfFy+uBBz+S334QcD5NVh23bzsrVcXwVeTSAnmeAfD4p2Y8prG695DqTZkDzIiEkePotyK2hxNrw1fPjpLNa8Xr24g0fx4LEAIbEFP9Ii59kTKQtBZTzycDW4gwTBT7LmRtbPMSINcdfIClr6Vg/mXFT9Sc79Nh1V3129mZTuyfryOU3M0HILzIKozEr2VAKJKvwe4cRNj0kZEvQCzxzU3bGDGE/HAFh82F90LmBWcEcV53Udzw36sBd1G2wxB1fKsgdUf+ZX1XtXlbOtkfSQVdKTL7C02wajQdntvQQIDAQABoy4wLDALBgNVHQ8EBAMCBPAwHQYDVR0OBBYEFMGbM3cGGXF9wi28sdnRZoHAz+XhMA0GCSqGSIb3DQEBBQUAA4IBAQBc6MzBJ+dAUx+0THVuUPmWyFkqRkkN7XUP+QfqBH4mCNPguxpyqg5CDhakbsCdhVtAxVyyZ5Wht3oFCDISNFI478+4rwKro6oVAGMuw2FXcL6erBLS4GA333oi1WnjxEsj1cpl8L77q095ScWCG7vebixAxC/WnhhfsFlGq1ZDoccIwDhfOgITQtNr9WVxE3zPou8VdLwiW72Am426MSL3N+bblgSsg+gqtmjoVI6nhGuaK4EgrzUkzOjP/CTKDtQH9/WvGqKybmL7tXq3fsHtCLZHCJJkHq8qmwNE91hJAeiiiBNIOKtwlEH9CNuyMNnmLNkY/2U+Tu5H8pkt5YQ4";
                appTo.tokenType = "urn:oasis:names:tc:SAML:2.0:assertion";
                appTo.uri = "http://xstsstress" + k.ToString() + ".com/";
                appTo.validityInterval = "04:00:00.0000000";

                appliesTos.Add(appTo);
            }

            foreach (TestCaseData.AppliesTo appTo in appliesTos)
            {
                Util.PropAppliesTo(appTo);
                Util.MapClaims(appTo.uri, stressClaims);
            }
            Util.ReloadXSTS();
        }

        [StressTest, Description("Gets a token from XSTS")]
        [CompoundCase("Mainline", false)]
        [CompoundCase("UseAASG", true)]
        public class IssueToken_Mainline_Stress : XSTSTestBase
        {
            private RSTGenerator rstGenerator;            

            public override void PreRun()
            {
                rstGenerator = Util.CreateDefaultRST();
                rstGenerator.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);                
            }            
            
            static int loopCount = 0;
            static int loopMax = 499;
            private static object lockObj = new object();
            public override void Run()
            {
                int appToNum;
                lock (lockObj)
                {                    
                    appToNum = loopCount++;
                    if (loopCount == loopMax + 1)
                        loopCount = 0;
                }
                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                try
                {
                    tokenReq.Stress = true;
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    tokenReq.UseAASG = (Boolean)MyValues[0];
                    rstGenerator.AppliesTo = new System.ServiceModel.EndpointAddress("http://xstsstress" + loopCount.ToString() + ".com");
                    string token = tokenReq.GetTokenStringFromSTS(rstGenerator);
                }
                finally
                {
                    tokenReq.Dispose();
                }
            }
        }

        [StressTest, Description("Gets a token from XSTS")]
        [CompoundCase("Mainline", false)]
        [CompoundCase("UseAASG", true)]
        public class IssueToken_Mainline_SingleAppTo_Stress : XSTSTestBase
        {
            private RSTGenerator rstGenerator;            

            public override void PreRun()
            {
                rstGenerator = Util.CreateDefaultRST();
                rstGenerator.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);                                
            }

            public override void Run()
            {
                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                try
                {
                    tokenReq.Stress = true;
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    tokenReq.UseAASG = (Boolean)MyValues[0];
                    string token = tokenReq.GetTokenStringFromSTS(rstGenerator);
                }
                finally
                {
                    tokenReq.Dispose();
                }
            }
        }

        [StressTest, Description("Gets a token from XSTS")]
        public class IssueToken_Bad_Stress : XSTSTestBase
        {
            private RSTGenerator rstGenerator;            

            public override void PreRun()
            {
                rstGenerator = Util.CreateDefaultRST();
                rstGenerator.DisplayTokenLanguage = "TestValue";
                rstGenerator.RequestDisplayToken = true;
                rstGenerator.AppliesTo = new System.ServiceModel.EndpointAddress(Util.AUTHSG_URL);                                
            }

            public override void Run()
            {
                XSTSTokenRequestor tokenReq = new XSTSTokenRequestor();
                try
                {
                    tokenReq.ServicesToUse = SecurityTokenServices.XSTS;
                    try
                    {
                        string token = tokenReq.GetTokenStringFromSTS(rstGenerator);
                    }
                    catch (Exception)
                    {
                        //Gonna fail no matter what. Meant to run alongside other tests that should not fail.
                    }
                }
                finally
                {
                    tokenReq.Dispose();
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\PolicyEnforcementTests\Unit.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.IdentityModel.Tokens;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Tokens;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace XstsPolicyEnforcementTests
{

[TestGroup]
public class Unit : TestNode
{

    public static Report Ro = new Report("Unit");

    [TestGroup]
    public class VersionCompatability : TestNode
    {

        public class MXAVersion
        {
            protected const string Issuer = "xsts.xboxlive.com";
            protected static string[] ClaimTypeFilter = new string[]
            {
                "http://schemas.microsoft.com/xbox/2011/07/claims/user/services"
            };

            public Assembly MXAAssembly
            {
                get;
                private set;
            }
            public Assembly MXAInternalAssembly
            {
                get;
                private set;
            }

            #region Constructors

            static MXAVersion ()
            {
                ConfigurationManager.AppSettings["XAuthdataEnableSignatures"] = "false";
            }

            public MXAVersion (string mxa, string mxai)
            {
                MXAAssembly = Assembly.LoadFrom(mxa);
                MXAInternalAssembly = Assembly.LoadFrom(mxai);
            }

            public MXAVersion (byte[] mxa, byte[] mxai)
            {
                MXAAssembly = Assembly.Load(mxa);
                MXAInternalAssembly = Assembly.Load(mxai);
            }

            public MXAVersion (Assembly mxa, Assembly mxai)
            {
                MXAAssembly = mxa;
                MXAInternalAssembly = mxai;
            }

            #endregion

            public string GetAuthData ()
            {
                List<IClaimsIdentity> identities = GetTestToken();
                return GetAuthData(identities);
            }

            public string GetAuthData (List<IClaimsIdentity> identities)
            {
                object t = CreateXAuthdataToken(identities);
                string ans = WriteToken(t);

                // remove the header string portion "XBL2.0 x="
                int xmlStart = ans.IndexOf('<');
                return (xmlStart > 0 ? ans.Substring(xmlStart) : ans);
            }

            public List<IClaimsIdentity> GetTestToken ()
            {
                //new Claim(GetClaimType("DeviceId"), "FA00FFFFFFFFFFFF", ClaimValueTypes.HexBinary, Issuer),
                //new Claim(GetClaimType("DeviceType"), "1", ClaimValueTypes.Integer, Issuer),
                //new Claim(GetClaimType("FlowToken"), "EF594473B7D97D8D", ClaimValueTypes.HexBinary, Issuer),
                //new Claim(GetClaimType("TitleId"), "FFFE0000", ClaimValueTypes.HexBinary, Issuer),
                //new Claim(GetClaimType("TitleVersion"), "1", ClaimValueTypes.HexBinary, Issuer),
                //new Claim(GetClaimType("AgeGroup"), "Adult", ClaimValueTypes.String, Issuer),
                //new Claim(GetClaimType("ClientIpPort"), "10.124.212.84:65535", GetClaimValueType("IpAddress"), Issuer),
                //new Claim(GetClaimType("Country"), "103", ClaimValueTypes.Integer, Issuer),
                //new Claim(GetClaimType("Gamertag"), "STFUWIB98GSPDRE", Issuer),
                //new Claim(GetClaimType("Language"), "1", ClaimValueTypes.Integer, Issuer),
                //new Claim(GetClaimType("Privileges"), "255", GetClaimValueType("IntegerArray"), Issuer),
                //new Claim(GetClaimType("Puid"), "37FFF893377D2", ClaimValueTypes.HexBinary, Issuer),
                //new Claim(GetClaimType("Tier"), "Gold", Issuer),
                //new Claim(GetClaimType("Xuid"), "9000000000047", ClaimValueTypes.HexBinary, Issuer),

                List<Claim> claims = new List<Claim>();

                foreach (string claimType in GetClaimTypes())
                {
                    if (!ClaimTypeFilter.Contains(claimType))
                    {
                        claims.Add(new Claim(claimType, claimType + " value", GetClaimTypeValueType(claimType), Issuer));
                    }
                }

                List<IClaimsIdentity> identities = new List<IClaimsIdentity>()
                {
                    new ClaimsIdentity(claims, AuthenticationTypes.Federation),
                };

                return identities;
            }

            public List<IClaimsIdentity> ReadAuthData (string authdata)
            {
                object xAuthdataToken = ReadToken(authdata);
                return GetIdentities(xAuthdataToken);
            }

            #region Reflection Helpers

            public string GetClaimType (string name)
            {
                Type actt = MXAAssembly.GetType("Microsoft.XboxLive.Auth.Claims.AuthClaimTypes");
                FieldInfo fi = actt.GetField(name);
                return (string)fi.GetValue(null);
            }

            public IEnumerable<string> GetClaimTypes ()
            {
                Type actt = MXAAssembly.GetType("Microsoft.XboxLive.Auth.Claims.AuthClaimTypes");
                FieldInfo[] fis = actt.GetFields(BindingFlags.Public | BindingFlags.Static);
                return fis.Where(fi => fi.FieldType == typeof(string)).Select(fi => (string)fi.GetValue(null));
            }

            public string GetClaimValueType (string name)
            {
                Type acvtt = MXAAssembly.GetType("Microsoft.XboxLive.Auth.Claims.AuthClaimValueTypes");
                FieldInfo fi = acvtt.GetField(name);
                return (string)fi.GetValue(null);
            }

            public string GetClaimTypeValueType (string claimType)
            {
                Type actt = MXAAssembly.GetType("Microsoft.XboxLive.Auth.Claims.AuthClaimTypes");
                FieldInfo fi = actt.GetField("ValueTypes");
                NameValueCollection vts = (NameValueCollection)fi.GetValue(null);
                return vts[claimType];
            }

            public object CreateXAuthdataToken (List<IClaimsIdentity> identities)
            {
                Type xAuthdataTokenType = MXAInternalAssembly.GetType("Microsoft.XboxLive.Auth.Tokens.XAuthdataToken");
                ConstructorInfo xATTC = xAuthdataTokenType.GetConstructor(new Type[] { typeof(List<IClaimsIdentity>) });

                return xATTC.Invoke(new object[] { identities });
            }

            protected string WriteToken (object t)
            {
                Type xblAuthProtocolHandlerType = MXAAssembly.GetType("Microsoft.XboxLive.Auth.Protocol.XblAuthProtocolHandler");
                ConstructorInfo xAPHTT = xblAuthProtocolHandlerType.GetConstructor(Type.EmptyTypes);
                MethodInfo writeToken = xblAuthProtocolHandlerType.GetMethod("WriteToken", new Type[] { typeof(SecurityToken), typeof(SecurityTokenHandler) });

                Type xAuthdataTokenHandlerType = MXAInternalAssembly.GetType("Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler");
                ConstructorInfo xATHT = xAuthdataTokenHandlerType.GetConstructor(Type.EmptyTypes);

                object protocolHandler = xAPHTT.Invoke(new object[0]);
                object tokenHandler = xATHT.Invoke(new object[0]);
                return (string)writeToken.Invoke(protocolHandler, new object[] { t, tokenHandler });
            }

            protected object ReadToken (string s)
            {
                Type xAuthdataTokenHandlerType = MXAInternalAssembly.GetType("Microsoft.XboxLive.Auth.Tokens.XAuthdataTokenHandler");
                ConstructorInfo xATHT = xAuthdataTokenHandlerType.GetConstructor(Type.EmptyTypes);
                MethodInfo readToken = xAuthdataTokenHandlerType.GetMethod("ReadToken", new Type[] { typeof(string) });

                object tokenHandler = xATHT.Invoke(new object[0]);
                return readToken.Invoke(tokenHandler, new object[] { s });
            }

            protected List<IClaimsIdentity> GetIdentities (object xAuthdataToken)
            {
                Type xAuthdataTokenType = MXAInternalAssembly.GetType("Microsoft.XboxLive.Auth.Tokens.XAuthdataToken");
                PropertyInfo identities = xAuthdataTokenType.GetProperty("Identities");
                return (List<IClaimsIdentity>)identities.GetValue(xAuthdataToken, null);
            }

            #endregion
        }

        public static Dictionary<string, MXAVersion> Versions
        {
            get;
            private set;
        }

        static VersionCompatability ()
        {
            AppDomain.CurrentDomain.AssemblyResolve += FindAssem;

            Versions = new Dictionary<string, MXAVersion>();
            Versions.Add("Current", new MXAVersion("Microsoft.XboxLive.Auth.dll", "Microsoft.XboxLive.Auth.Internal.dll"));
            AddVersion("11.04.0039.00");
        }

        public static void AddVersion (string version)
        {
            Versions.Add(version, new MXAVersion(GetResource("MXA." + version + ".dll"), GetResource("MXAI." + version + ".dll")));
        }

        private const string ResourceBase = "MXAVersions.";

        private static byte[] GetResource (string fileName)
        {
            using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(ResourceBase + fileName))
            {
                byte[] bytes = new byte[stream.Length];
                stream.Read(bytes, 0, bytes.Length);
                return bytes;
            }
        }

        public static Assembly FindAssem (object sender, ResolveEventArgs args)
        {
            AssemblyName asmName = new AssemblyName(args.Name);

            if (asmName.Name.StartsWith("Microsoft.XboxLive.Auth"))
            {
                Version ver = asmName.Version;
                string verString = String.Format("{0:D2}.{1:D2}.{2:D4}.{3:D2}", ver.Major, ver.Minor, ver.Build, ver.Revision);
                MXAVersion version = Versions[verString];

                if (asmName.Name.EndsWith("Internal"))
                {
                    return version.MXAInternalAssembly;
                }
                else
                {
                    return version.MXAAssembly;
                }
            }

            return null;
        }

        public static void PrintIdentities (IEnumerable<IClaimsIdentity> identities)
        {
            StringBuilder sb = new StringBuilder();
            int idCount = 0;

            foreach (IClaimsIdentity identity in identities)
            {
                ++idCount;
                sb.Append("Identity "); sb.Append(idCount); sb.AppendLine();
                sb.Append("  AuthType: "); sb.Append(identity.AuthenticationType); sb.AppendLine();
                sb.AppendLine("  Claims:");

                foreach (Claim claim in identity.Claims)
                {
                    sb.Append("    Claim: "); sb.Append(claim.ClaimType); sb.Append(" ["); sb.Append(claim.Issuer); sb.Append("]"); sb.AppendLine();
                    sb.Append("      ValueType: "); sb.Append(claim.ValueType); sb.AppendLine();
                    sb.Append("      Value    : "); sb.Append(claim.Value); sb.AppendLine();
                }
            }

            Ro.Info(sb.ToString());
        }

        public static void ValueCheckIdentities (List<IClaimsIdentity> expected, List<IClaimsIdentity> got)
        {
            ValueCheck.Test("Identity Count", expected.Count, got.Count);

            MultiEnumerator<IClaimsIdentity> identities = new MultiEnumerator<IClaimsIdentity>(expected, got);
            int idCount = 0;

            foreach (var identityList in identities)
            {
                ++idCount;
                IClaimsIdentity expectedIdentity = identityList[0].Value;
                IClaimsIdentity gotIdentity = identityList[1].Value;

                ValueCheck.Test("Identity " + idCount + " AuthType", expectedIdentity.AuthenticationType, gotIdentity.AuthenticationType);
                ValueCheck.Test("Identity " + idCount + " Claim Count", expectedIdentity.Claims.Count, gotIdentity.Claims.Count);

                int claimCount = 0;
                
                foreach (Claim expectedClaim in expectedIdentity.Claims)
                {
                    ++claimCount;
                    string claimName = expectedClaim.ClaimType;
                    Claim gotClaim = gotIdentity.Claims.FirstOrDefault(c => c.ClaimType == claimName);

                    if (gotClaim == null)
                    {
                        throw new ExpectedValueCheckException("Identity " + idCount + ": Expected Claim " + claimName + " not found in values.");
                    }

                    ValueCheck.Test("Identity " + idCount + " Claim " + claimName + " Issuer", expectedClaim.Issuer, gotClaim.Issuer);
                    ValueCheck.Test("Identity " + idCount + " Claim " + claimName + " ValueType", expectedClaim.ValueType, gotClaim.ValueType);
                    ValueCheck.Test("Identity " + idCount + " Claim " + claimName + " Value", expectedClaim.Value, gotClaim.Value);
                }
            }
        }

        [TestCase]
        public class AllSTSClaimsMatrix : TestNode
        {
            public AllSTSClaimsMatrix ()
            {
                foreach (string ver in Versions.Keys)
                {
                    AddChild(new SpecificVersionTest(ver));
                }
            }
        }

        public class SpecificVersionTest : TestNode
        {
            protected string XstsVersion;
            protected string SourceVersion;
            protected string DestVersion;

            protected SpecificVersionTest () { }

            /// <summary>
            /// Creates a group that sources from the passed in version.
            /// </summary>
            public SpecificVersionTest (string xstsVersion)
            {
                Init(xstsVersion);
            }

            /// <summary>
            /// Creates a group that sources from the passed in versions.
            /// </summary>
            public SpecificVersionTest (string xstsVersion, string sourceVersion)
            {
                Init(xstsVersion, sourceVersion);
            }

            /// <summary>
            /// Creates a test node that uses these versions.
            /// </summary>
            public SpecificVersionTest (string xstsVersion, string sourceVersion, string destVersion)
            {
                Init(xstsVersion, sourceVersion, destVersion);
            }

            protected virtual SpecificVersionTest CreateOneOfSelf ()
            {
                return new SpecificVersionTest();
            }

            private void Init (string xstsVersion)
            {
                Name = "XSTS: " + xstsVersion;

                foreach (string ver in Versions.Keys)
                {
                    SpecificVersionTest child = CreateOneOfSelf();
                    child.Init(xstsVersion, ver);
                    AddChild(child);
                }
            }

            private void Init (string xstsVersion, string sourceVersion)
            {
                Name = "Source: " + sourceVersion;

                foreach (string ver in Versions.Keys)
                {
                    SpecificVersionTest child = CreateOneOfSelf();
                    child.Init(xstsVersion, sourceVersion, ver);
                    AddChild(child);
                }
            }

            private void Init (string xstsVersion, string sourceVersion, string destVersion)
            {
                Name = "Dest: " + destVersion;

                XstsVersion = xstsVersion;
                SourceVersion = sourceVersion;
                DestVersion = destVersion;
            }

            public virtual List<IClaimsIdentity> GetIClaimsIdentityList ()
            {
                return Versions[XstsVersion].GetTestToken();
            }

            public override void Run ()
            {
                // Get XSTS version claims
                List<IClaimsIdentity> claims = GetIClaimsIdentityList();
                PrintIdentities(claims);

                // Then write those out with the source version
                string authdata = Versions[SourceVersion].GetAuthData(claims);
                Ro.Info(authdata);

                // then read them again with the dest version
                List<IClaimsIdentity> authOut = Versions[DestVersion].ReadAuthData(authdata);
                PrintIdentities(authOut);

                // verify that the original claims match the ones read from the dest version
                try
                {
                    ValueCheckIdentities(claims, authOut);
                }
                catch (Exception e)
                {
                    Ro.Error(e.ToString());
                    throw new DidNotExecuteException("Test did not pass; do not want to increment fail count.");
                }
            }
        }

        [TestCase]
        public class ExternalClaimsMatrix : TestNode
        {
            public ExternalClaimsMatrix ()
            {
                foreach (string ver in Versions.Keys)
                {
                    AddChild(new ExternalClaimsSpecificVersionTest(ver));
                }
            }
        }

        public class ExternalClaimsSpecificVersionTest : SpecificVersionTest
        {
            protected const string Issuer = "ExternalClaimsSpecificVersionTest";

            protected ExternalClaimsSpecificVersionTest () { }

            public ExternalClaimsSpecificVersionTest (string version) : base(null, version) { }

            protected override SpecificVersionTest CreateOneOfSelf ()
            {
                return new ExternalClaimsSpecificVersionTest();
            }

            public override List<IClaimsIdentity> GetIClaimsIdentityList ()
            {
                List<Claim> claims = new List<Claim>();

                claims.Add(new Claim("Claim1", "Claim1 value", ClaimValueTypes.String, Issuer));
                claims.Add(new Claim("Claim2", "Claim2 value", ClaimValueTypes.Integer, Issuer));
                claims.Add(new Claim("Claim3", "Claim3 value", ClaimValueTypes.Time, Issuer));

                List<IClaimsIdentity> identities = new List<IClaimsIdentity>()
                {
                    new ClaimsIdentity(claims, AuthenticationTypes.Federation),
                };

                return identities;
            }
        }

    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Contracts\XUserServiceContractV1.cs ===
using System;
using System.ServiceModel;

using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.contract
{   
    [ServiceContract(Name = "IXUser", Namespace = "http://xonline.xuser.V1")]
    public interface IXUser
    {
        [OperationContract(Name = "MachineGet")]
        UserMachine[] MachineGet(ulong userPuid, ulong? machinePuid, string friendlyName, DateTime? since);

        [OperationContract(Name = "MachineTrustLevelSet")]
        [ServiceKnownType(typeof(MachineTrustLevel))]
        void MachineTrustLevelSet(ulong userPuid, ulong machinePuid, MachineTrustLevel trustLevel);

        [OperationContract(Name = "MachineFriendlyNameSet")]
        void MachineFriendlyNameSet(ulong userPuid, ulong machinePuid, string friendlyName);

        [OperationContract(Name = "UserKeyGet")]
        UserKey UserKeyGet(ulong userPuid);

        [OperationContract(Name = "UserKeyReset")]
        UserKey UserKeyReset(ulong userPuid);

        [OperationContract(Name = "GamertagHistoryGetByGamertag")]
        GamertagHistory GamertagHistoryGetByGamertag(string gamertag, DateTime? since, bool details);

        [OperationContract(Name = "GamertagHistoryGetByUserPuid")]
        GamertagHistory GamertagHistoryGetByUserPuid(ulong userPuid, ulong? machinePuid, DateTime? since, bool details);

        [OperationContract(Name = "PassportHistoryGet")]
        PassportHistory PassportHistoryGet(ulong userPuid, ulong? machinePuid, DateTime? since, bool details);

        [OperationContract(Name = "RecoveryHistoryGet")]
        RecoveryHistory RecoveryHistoryGet(ulong userPuid, ulong? machinePuid, DateTime? since, bool details);
        
        [OperationContract(Name = "GamertagHistoryLog")]
        void GamertagHistoryLog(GamertagHistoryDetails gthd);
        
        [OperationContract(Name = "PassportHistoryLog")]
        void PassportHistoryLog(PassportHistoryDetails phd);

        [OperationContract(Name = "RecoveryHistoryLog")]
        void RecoveryHistoryLog(RecoveryHistoryDetails rhd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Contracts\XUserDataContractV1.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;

namespace xonline.xuser.contract
{
    [DataContract(Name = "MachineTrustLevel", Namespace = "http://xonline.xuser.V1")]
    public enum MachineTrustLevel
    {
        [EnumMember]
        Unknown   = -1,
        [EnumMember]
        Untrusted =  0,
        [EnumMember]
        Trusted   =  1,
    }

    [DataContract(Name = "UserKey", Namespace = "http://xonline.xuser.V1")]
    public class UserKey
    {
        public UserKey() { }

        public UserKey(string gamertag, int version, byte[] rawKey, byte[] encryptedKey, byte[] IV, byte[] SPPA, byte[] PPA)
        {
            this.Gamertag = gamertag;
            this.Version = version;
            this.RawKey = rawKey;
            this.EncryptedKey = encryptedKey;
            this.IV = IV;
            this.SPPA = SPPA;
            this.PPA = PPA;
        }

        [DataMember(Name = "Gamertag")]
        public string Gamertag { get; set; }

        [DataMember(Name = "Version")]
        public int Version { get; set; }

        [DataMember(Name = "EncryptedKey")]
        public byte[] EncryptedKey { get; set; }

        [DataMember(Name = "RawKey")]
        public byte[] RawKey { get; set; }

        [DataMember(Name = "IV")]
        public byte[] IV { get; set; }

        [DataMember(Name = "SPPA")]
        public byte[] SPPA { get; set; }

        [DataMember(Name = "PPA")]
        public byte[] PPA { get; set; }

    }


    [DataContract(Name = "UserMachine", Namespace = "http://xonline.xuser.V1")]
    public class UserMachine
    {
        public UserMachine() {
        }

        public UserMachine(
            ulong     userPuid,
            ulong     machinePuid,
            int       daysSeen,
            string    ipAddress,
            DateTime? firstSignIn,
            DateTime? lastSignIn,
            DateTime? lastSignOut,
            string    friendlyName,
            int       trustLevel
        )
        {
            UserPuid     = userPuid;
            MachinePuid  = machinePuid;
            DaysSeen     = daysSeen;

            if (string.IsNullOrEmpty(ipAddress) || (ipAddress == "0.0.0.0"))
                IpAddress = null;
            else {
                IpAddress = ipAddress;
            }

            FirstSignIn  = firstSignIn;
            LastSignIn   = lastSignIn;
            LastSignOut  = lastSignOut;
            FriendlyName = friendlyName;
            TrustLevel   = trustLevel;
        }
        
        [DataMember(Name = "UserPuid")]
        public ulong UserPuid { get; set; }

        [DataMember(Name = "MachinePuid")]
        public ulong MachinePuid { get; set; }

        [DataMember(Name = "DaysSeen")]
        public int DaysSeen { get; set; }
        
        [DataMember(Name = "IpAddress")]
        public string IpAddress { get; set; }

        [DataMember(Name = "FirstSignIn")]
        public DateTime? FirstSignIn { get; set; }

        [DataMember(Name = "LastSignIn")]
        public DateTime? LastSignIn { get; set; }

        [DataMember(Name = "LastSignOut")]
        public DateTime? LastSignOut { get; set; }

        [DataMember(Name = "FriendlyName")]
        public string FriendlyName { get; set; }

        [DataMember(Name = "TrustLevel")]
        public int TrustLevel { get; set; }
    }

    //History
    [DataContract(Name = "HistoryDetails", Namespace = "http://xonline.xuser.V1")]
    [KnownType(typeof(GamertagHistoryDetails))]
    [KnownType(typeof(PassportHistoryDetails))]
    [KnownType(typeof(RecoveryHistoryDetails))]
    public class HistoryDetails : IComparable
    {
        public HistoryDetails()
        {
            Timestamp = DateTime.UtcNow;
        }

        public HistoryDetails(
            ulong userPuid, 
            ulong? machinePuid, 
            string ipAddress,
            uint hr, 
            byte reason
            )
        {
            UserPuid = userPuid;

            MachinePuid = ((machinePuid == null) || (machinePuid == 0)) ? (ulong?)null : machinePuid;
            IpAddress = ((ipAddress == null) || (ipAddress == "0.0.0.0")) ? null : ipAddress;

            Timestamp = DateTime.UtcNow;
            HResult = hr;
            Reason = reason;
        }

        [DataMember(Name = "UserPuid", IsRequired = true)]
        public ulong UserPuid { get; set; }

        [DataMember(Name = "MachinePuid", IsRequired = true)]
        public ulong? MachinePuid { get; set; }

        [DataMember(Name = "IpAddress", IsRequired = true)]
        public string IpAddress { get; set; }

        [DataMember(Name = "Timestamp", IsRequired = true)]
        public DateTime Timestamp { get; set; }

        [DataMember(Name = "Result", IsRequired = true)]
        public uint HResult { get; set; }

        [DataMember(Name = "Reason", IsRequired = true)]
        public byte Reason { get; set; }

        public string Details { get; set; }

        int IComparable.CompareTo(object obj)
        {
            HistoryDetails details = (HistoryDetails)obj;
            return Timestamp < details.Timestamp ? 1 : -1;
        }

        public override string ToString()
        {
            return string.Format(
                "{0} {1}, User = {2}, Machine = {3}, IpAddress = {4}, {5}",
                Timestamp.ToString("yyyy/MM/dd HH:mm:ss.fff"), Reason,
                UserPuid, MachinePuid == null ? "<none>" : MachinePuid.ToString(), IpAddress, Details
            );
        }
    }

    [DataContract(Name = "HistorySummary", Namespace = "http://xonline.xuser.V1")]
    public class HistorySummary
    {
        public HistorySummary()
        {
        }

        public HistorySummary(
            HistoryDetails[] historyDetails
          )
        {
            var uniquePuids = new Dictionary<ulong, bool>();

            Unique = Total = historyDetails.Length;

            foreach (HistoryDetails historyDetail in historyDetails)
            {
                if ((First == null) || (historyDetail.Timestamp < First))
                {
                    First = historyDetail.Timestamp;
                }

                if ((Last == null) || (historyDetail.Timestamp > Last))
                {
                    Last = historyDetail.Timestamp;
                }

                if (!uniquePuids.ContainsKey(historyDetail.UserPuid))
                {
                    uniquePuids.Add(historyDetail.UserPuid, true);
                }
            }

            Unique = uniquePuids.Count;
        }

        [DataMember(Name = "Unique", IsRequired = true)]
        public int Unique { get; set; }

        [DataMember(Name = "Total", IsRequired = true)]
        public int Total { get; set; }

        [DataMember(Name = "First", IsRequired = true)]
        public DateTime? First { get; set; }

        [DataMember(Name = "Last", IsRequired = true)]
        public DateTime? Last { get; set; }
    }

    [DataContract(Name = "GamertagHistoryDetails", Namespace = "http://xonline.xuser.V1")]
    public class GamertagHistoryDetails : HistoryDetails
    {
        public GamertagHistoryDetails()
        {
        }

        public GamertagHistoryDetails(
            ulong userPuid,
            ulong? machinePuid, 
            string ipAddress,
            uint hr, 
            byte reason,
            string oldGamertag, 
            string newGamertag
          ) : base(userPuid, machinePuid, ipAddress, hr, reason)
        {
            OldGamertag = oldGamertag;
            NewGamertag = newGamertag;

            InitDetails();
        }

        public override string ToString()
        {
            return string.Format("{0}, {1}", base.ToString(), Details);
        }

        [DataMember(Name = "OldGamertag", IsRequired = true)]
        public string OldGamertag { get; set; }

        [DataMember(Name = "NewGamertag", IsRequired = true)]
        public string NewGamertag { get; set; }

        public void InitDetails()
        {
            Details = string.Format("OldGamertag = {0}, NewGamertag = {1}",
                     OldGamertag == null ? "<none>" : "'" + OldGamertag + "'",
                     NewGamertag == null ? "<none>" : "'" + NewGamertag + "'");
        }

    }
        
    [DataContract(Name = "GamertagHistory", Namespace = "http://xonline.xuser.V1")]
    public class GamertagHistory : HistorySummary
    {
        public GamertagHistory()
        {
        }

        public GamertagHistory(
            GamertagHistoryDetails[] details
          ) : base(details)
        {
        }

        [DataMember(Name = "Details")]
        public GamertagHistoryDetails[] Details { get; set; }
    }

    [DataContract(Name = "PassportHistoryDetails", Namespace = "http://xonline.xuser.V1")]
    public class PassportHistoryDetails : HistoryDetails
    {
        public PassportHistoryDetails()
        {
        }

        public PassportHistoryDetails(
            ulong userPuid,
            ulong? machinePuid, 
            string ipAddress,
            uint hr, 
            byte reason,
            UInt64? oldPassportPuid,
            UInt64? newPassportPuid
          ) : base(userPuid, machinePuid, ipAddress, hr, reason)
        {
            OldPassportPuid = oldPassportPuid;
            NewPassportPuid = newPassportPuid;

            InitDetails();
        }

        [DataMember(Name = "OldPassportPuid", IsRequired = true)]
        public UInt64? OldPassportPuid { get; set; }

        [DataMember(Name = "NewPassportPuid", IsRequired = true)]
        public UInt64? NewPassportPuid { get; set; }

        public void InitDetails()
        {
            Details = string.Format(
                     "OldPassportPuid = {0}, NewPassportPuid = {1}",
                     OldPassportPuid == null ? "<none>" : "'" + OldPassportPuid + "'",
                     NewPassportPuid == null ? "<none>" : "'" + NewPassportPuid + "'");
        }

    }

    [DataContract(Name = "PassportHistory", Namespace = "http://xonline.xuser.V1")]
    public class PassportHistory : HistorySummary
    {
        public PassportHistory()
        {
        }

        public PassportHistory(
            PassportHistoryDetails[] details
          )
            : base(details)
        {
        }

        [DataMember(Name = "Details", IsRequired = true)]
        public PassportHistoryDetails[] Details { get; set; }
    }

    [DataContract(Name = "RecoveryHistory", Namespace = "http://xonline.xuser.V1")]
    public class RecoveryHistory : HistorySummary
    {
        public RecoveryHistory()
        {
        }

        public RecoveryHistory(
            RecoveryHistoryDetails[] details
          )
            : base(details)
        {
        }

        [DataMember(Name = "Details", IsRequired = true)]
        public RecoveryHistoryDetails[] Details { get; set; }
    }

    [DataContract(Name = "RecoveryHistoryDetails", Namespace = "http://xonline.xuser.V1")]
    public class RecoveryHistoryDetails : HistoryDetails
    {
        public RecoveryHistoryDetails()
        {
        }

        public RecoveryHistoryDetails(
            ulong userPuid,
            ulong machinePuid,
            string ipAddress,
            uint hr,
            byte reason,
            UInt64 passportPuid
          )
            : base(userPuid, machinePuid, ipAddress, hr, reason)
        {
            PassportPuid = passportPuid;

            InitDetails();
        }

        [DataMember(Name = "PassportPuid", IsRequired = true)]
        public UInt64 PassportPuid { get; set; }

        public void InitDetails()
        {
            Details = string.Format("PassportPuid = {0}", PassportPuid);
        }
    }

    [DataContract(Name = "UserMachineHistoryDetails", Namespace = "http://xonline.xuser.V1")]
    public class UserMachineHistoryDetails
    {
        public UserMachineHistoryDetails()
        {
        }

        public UserMachineHistoryDetails(
            ulong userPuid,
            ulong machinePuid,
            DateTime firstSeen,
            DateTime lastSeen,
            int daysSeen,
            string ipAddress)
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;
            FirstSeen = firstSeen;
            LastSeen = lastSeen;
            DaysSeen = daysSeen;
            IpAddress = ipAddress;
        }

        [DataMember(Name = "UserPuid", IsRequired = true)]
        public ulong UserPuid { get; set; }

        [DataMember(Name = "MachinePuid", IsRequired = true)]
        public ulong? MachinePuid { get; set; }

        [DataMember(Name = "FirstSeen", IsRequired = true)]
        public DateTime FirstSeen { get; set; }

        [DataMember(Name = "LastSeen", IsRequired = true)]
        public DateTime LastSeen { get; set; }

        [DataMember(Name = "DaysSeen", IsRequired = true)]
        public int DaysSeen { get; set; }

        [DataMember(Name = "IpAddress", IsRequired = true)]
        public string IpAddress { get; set; }

        // not real days seen. most days seen before a date.
        // it could be less,  but it is definitely no  more.
        public int DaysSeenBefore(DateTime before)
        {
            TimeSpan timespan = before - (DateTime)FirstSeen;
            if (timespan.TotalDays < 0) return 0;
            if (timespan.TotalDays < DaysSeen) return (int)timespan.TotalDays;
            return DaysSeen;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XSTS\test\XSTSTests\Util.cs ===
using System;
using System.Data;
using System.Text;
using System.Text.RegularExpressions;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Cache;
using System.Xml;
using System.Xml.Linq;

using System.IdentityModel.Tokens;
using System.IdentityModel.Selectors;

using Microsoft.IdentityModel.Tokens.Saml2;
using Microsoft.IdentityModel.Tokens;
using Microsoft.IdentityModel.SecurityTokenService;
using Microsoft.IdentityModel.Protocols.WSTrust;

using xonline.common.config;
using xonline.common.utilities2;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.config.sts.interfaces;

using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using ServerTestFramework;
using ServerTestFramework.LiveService.XSTS;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService.TestFdXsts;
using StsTest.WebService;

using Microsoft.Webstore.WstClient;

namespace XSTSTests
{
    public enum SecurityTokenServices { XSTS = 0, STS, Both };

    public class XSTSTokenRequestor : IDisposable
    {
        private string samlTag = "</saml:Assertion>";        
        private Uri audienceUri;
        private Saml2SecurityToken token;
        private string tokenString;
        private bool isDisposed;
        private bool validatingSTSV1;
        bool hasCustomUser;
        
        private static string stressRst;


        public RSTGenerator RSTGen { get; set; }
        public bool TryCallRPService { get; set; }
        public bool Stress { get; set; }
        
        public bool UseWP7ClientCert
        {
            get { return ClientCert != null; }
            set { ClientCert = value ? wp7Cert : null; }
        }
        
        public X509Certificate2 ClientCert { get; set; }

        public SecurityTokenServices ServicesToUse { get; set; }

        public String XBL20Header { get; set; }
        public String AuthorizationHdr { get; set; }

        public HttpStatusCode StatusCode { get; set; }
        public String XErr { get; set; }

        /// <summary>
        /// The index of the user to create the token for
        /// </summary>
        public int UserIndex { get; set; }

        /// <summary>
        /// The total number of users to include in the ticket
        /// </summary>
        public int UsersInTicket { get; set; }

        public bool UseAASG { get; set; }

        public bool UseDelegationToken { get; set; }

        private KdcUser[] users;

        public string ClientCertNameOverride { get; set; }
        public String ClientCertThumbprintOverride { get; set; }

        public XSTSTokenRequestor()
        {
            TryCallRPService = true;
            UserIndex = 0;
            UsersInTicket = 1;
            UseAASG = false;
            users = new KdcUser[4];
            ServicesToUse = SecurityTokenServices.Both;
        }

        private static X509Certificate2 wp7CertForReals = null;
        private static X509Certificate2 wp7Cert
        {
            get
            {
                if (wp7CertForReals == null)
                {
                    GetSecurityTicketBase.AddCertChainToStore();
                    wp7CertForReals = GetSecurityTicketBase.ClientCertificate;
                }

                return wp7CertForReals;
            }
            set { wp7CertForReals = value; }
        }

        public KdcUser GetUser(Int32 index)
        {
            if (users[index] == null)
            {
                users[index] = UserCreator.GetSharedUser();
            }

            return users[index];
        }

        /// <summary>
        /// Stores a previously created user in the token
        /// requestor so that it's used during the request
        /// </summary>
        /// <param name="index"></param>
        /// <param name="user"></param>
        public void SetUser(Int32 index, KdcUser user)
        {
            hasCustomUser = true;
            users[index] = user;
        }

        public void Dispose()
        {
            try
            {
                Dispose(true);
            }
            finally
            {
                GC.SuppressFinalize(this);
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!isDisposed)
            {
                try
                {
                    if (disposing)
                    {
                        for (int i = 0; i < users.Length; i++)
                        {
                            if (users[i] != null && !hasCustomUser)
                            {
                                UserCreator.ReturnSharedUser(users[i]);
                                users[i] = null;
                            }
                        }
                    }
                }
                finally
                {
                    isDisposed = true;
                }
            }
        }

        #region Validation-related methods
        public void ValidateToken(string tokenStr, CSGInfo slot)
        {            
            if (!tokenStr.StartsWith("<XblToken Id=\""))
            {
                Saml2SecurityToken t = Util.ParseToken(tokenStr, audienceUri.ToString());
                TimeSpan expectedTime = Util.ServerConfig.AppliesToes[audienceUri].ValidityInterval.Add(new TimeSpan(0, 5, 0));
                TimeSpan obtainedTime = (t.ValidTo - t.ValidFrom);
                ValueCheck.Test("Got an unexpected validity time for the token.", expectedTime, obtainedTime, TimeSpan.FromSeconds(10));
                ValidateClaims(t, slot);                
            }
            else
            {
                //Add time validation
                //Add getting the thing straight out of the cache                
            }

            if (TryCallRPService)
            {
                string rpServiceResult = Util.CallRPService(tokenStr, audienceUri.ToString());

                //No problem if it's null, it means we had an appliesTo 
                //that the authsg can't understand. So we did not even try.
                if (rpServiceResult != null)
                {
                    ValidateRPServiceResult(rpServiceResult, slot);
                }
            }
        }

        public int GetExpectedClaimCount()
        {
            int expectedInitialCount = Util.GetTrustedClaimCount(audienceUri.ToString());
            int initialCount = Util.ServerConfig.AppliesToes[audienceUri].ClaimTypes.Count;
            ValueCheck.Test("Got an incorrect number of base claims from the database.", expectedInitialCount, initialCount);

            IAppliesTo appTo = Util.ServerConfig.AppliesToes[audienceUri];

            foreach (IAppliesToClaimType t in appTo.ClaimTypes.Values)
            {
                //if (!(t.ClaimType.Private && !appTo.BusinessPartner.Private))
                {
                    string s = t.ClaimTypeUri.ToString();

                    switch (s)
                    {
                        case AuthClaimTypes.DeviceId:
                        case AuthClaimTypes.DeviceName:
                        case AuthClaimTypes.PartnerDeviceId:
                        case AuthClaimTypes.DeviceType:
                        case AuthClaimTypes.TitleId:
                        case AuthClaimTypes.TitleVersion:
                            if (UseAASG && !validatingSTSV1 && !UseWP7ClientCert)
                                initialCount--; //Adjust for AASG;
                            break;
                        case AuthClaimTypes.ParentXuid:
                        case AuthClaimTypes.PartnerParentXuid:
                            KdcUser u = this.GetUser(UserIndex);
                            UserEditor child = UserEditor.FromPuid(u.UserID);
                            UserEditor parent = UserEditor.FromPassportPuid(child.OwnerPassportPuid);
                            if (!parent.Exists)
                                initialCount--;
                            break;
                        default:
                            break;
                    }
                }
            }
            return initialCount;
        }

        public void ValidateClaims(Saml2SecurityToken t, CSGInfo slot)
        {
            List<Saml2Statement> statements = new List<Saml2Statement>(t.Assertion.Statements);

            if (statements.Count > 1)
                throw new Exception("Expected only 1 or 0 SAML statements. Found " + statements.Count);
            foreach (Saml2Statement statement in statements)
            {
                if (statement is Saml2AttributeStatement)
                {
                    Saml2AttributeStatement attribStatement = (Saml2AttributeStatement)statement;
                    int expectedClaimCount = GetExpectedClaimCount();

                    ValueCheck.Test("Got an incorrect number of claims.", expectedClaimCount, attribStatement.Attributes.Count);

                    foreach (Saml2Attribute attrib in attribStatement.Attributes)
                    {
                        ValidateClaim(attrib.Name, attrib.AttributeValueXsiType, attrib.Values.ToArray(), slot);
                    }
                }
            }
        }
        
        public void ValidateRPClaims(List<RPServiceResult> results, CSGInfo slot)
        {
            int expectedClaimCount = GetExpectedClaimCount();
            ValueCheck.Test("Got an incorrect number of claims.", expectedClaimCount, results.Count);
            foreach (RPServiceResult result in results)
            {                   
                ValidateClaim(result.claimName, result.claimType, new string[] { result.value }, slot);                
            }            
        }

        public void ValidateClaimType(string claimName, string claimValueType)
        {
            switch (claimName)
            {
                case AuthClaimTypes.DelegationToken:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.DeviceType:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                case AuthClaimTypes.TitleId:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.TitleVersion:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.Puid:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.Country:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.Privileges:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://schemas.microsoft.com/xbox/types#IntegerArray", claimValueType);
                    break;
                case AuthClaimTypes.PartnerXuid:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.PartnerParentXuid:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.Gamertag:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                case AuthClaimTypes.Tier:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                case AuthClaimTypes.Xuid:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.ParentXuid:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.DeviceName:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                case AuthClaimTypes.ClientIpPort:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://schemas.microsoft.com/xbox/types#IpAddress", claimValueType);
                    break;
                case AuthClaimTypes.DeviceId:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.PartnerDeviceId:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.FlowToken:
                    ValueCheck.Test("Value types did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#hexBinary", claimValueType);
                    break;
                case AuthClaimTypes.Language:
                    ValueCheck.Test("Value type did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#integer", claimValueType);
                    break;
                case AuthClaimTypes.AgeGroup:
                    ValueCheck.Test("Value type did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                case AuthClaimTypes.Status:
                    ValueCheck.Test("Value type did not match on claim '" + claimName + "':", "http://www.w3.org/2001/XMLSchema#string", claimValueType);
                    break;
                default:
                    Global.RO.Warn("Skipping type validation for a claim because Wisgary is lazy. Need to implement automated validation for claim: " + claimName);
                    break;
            }

        }

        public string GetExpectedServiceValue()
        {
            switch (UserIndex)
            {
                case 0:
                    return XOn.XPRIVILEGE_ADD_FRIEND.ToString();
                case 1:
                    return XOn.XPRIVILEGE_FAMILY.ToString();
                case 2:
                    return XOn.XPRIVILEGE_BILLING_SWITCHING.ToString();
                case 3:
                    return XOn.XPRIVILEGE_PURCHASE_CONTENT.ToString();
                default:
                    return "0";
            }
        }

        public void ValidateClaim(string claimName, string claimValueType, string[] claimValues, CSGInfo slot)
        {
            UserEditor user = UserEditor.FromPuid(slot.GetUserPuid(UserIndex));

            if (claimValues.Length != 1)
                throw new Exception("Only expected 1 value per claim.");

            string value = claimValues[0];

            ValidateClaimType(claimName, claimValueType);

            switch (claimName)
            {
                case AuthClaimTypes.DelegationToken:
                    string delT = DecryptAndDeanonymize(Util.ServerConfig.AppliesToes[new Uri(Util.AUTHSG_URL)], value);
                    delT = ASCIIEncoding.ASCII.GetString(Blob.Parse(delT));
                    string dtVersion, dtXuid;
                    DateTime dtIssueTime;
                    GetDTokenValues(delT, out dtVersion, out dtIssueTime, out dtXuid);

                    ValueCheck.Test("Real xuid value and the one in the delegation token did not match.", slot.GetUserPuid(UserIndex), Convert.ToUInt64(dtXuid, 16));
                    ValueCheck.Test("DateTime wasn't in the expected range", DateTime.UtcNow, dtIssueTime, TimeSpan.FromMinutes(5));
                    ValueCheck.Test("Version didn't match.", 1, dtVersion);
                    break;
                case AuthClaimTypes.DeviceType:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(XOn.XboxId.GetPlatformType(slot.machinePuid), claimName), value);
                    break;
                case AuthClaimTypes.TitleId:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.titleId, claimName), value);
                    break;
                case AuthClaimTypes.TitleVersion:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.titleVersion, claimName), value);
                    break;
                case AuthClaimTypes.Puid:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(user.UserPassportPuid, claimName), value);
                    break;
                case AuthClaimTypes.Country:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.GetUserCountryId(UserIndex), claimName), value);
                    break;
                case AuthClaimTypes.Privileges:
                    if (!UseAASG && !validatingSTSV1)
                        ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(GetExpectedServiceValue(), claimName), value);
                    else
                        Global.RO.Warn("Skipping AASG validation for a claim because Wisgary is lazy. Need to implement automated validation for claim: " + claimName);
                    break;
                case AuthClaimTypes.PartnerXuid:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.GetUserPuid(UserIndex), claimName), value);
                    break;
                case AuthClaimTypes.PartnerParentXuid:
                    {
                        UserEditor owner = UserEditor.FromPassportPuid(user.OwnerPassportPuid);
                        ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(owner.Puid, claimName), value);
                    }
                    break;
                case AuthClaimTypes.Gamertag:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(user.Gamertag, claimName), value);
                    break;
                case AuthClaimTypes.Tier:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.GetTier(UserIndex), claimName), value);
                    break;
                case AuthClaimTypes.Xuid:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.GetUserPuid(UserIndex), claimName), value);
                    break;
                case AuthClaimTypes.ClientIpPort:
                    if (UseAASG && !validatingSTSV1)
                        value = value.Substring(0, value.IndexOf(":"));
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(null, claimName), value);
                    break;
                case AuthClaimTypes.DeviceId:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.machinePuid, claimName), value);
                    break;
                case AuthClaimTypes.PartnerDeviceId:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.machinePuid, claimName), value);
                    break;
                case AuthClaimTypes.DeviceName:
                    MachineEditor me = MachineEditor.FromId(slot.machinePuid);
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(me.ConsoleId, claimName), value);
                    break;
                case AuthClaimTypes.FlowToken:
                    if (!UseAASG)
                        ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.flowToken, claimName), value);
                    else
                    {
                        UInt64 temp = Convert.ToUInt64(value, 16);
                        ValueCheck.Test("The generated flowtoken was not a valid flowtoken", true, temp != 0);
                    }
                    break;
                case AuthClaimTypes.ParentXuid:
                    {
                        UserEditor owner = UserEditor.FromPassportPuid(user.OwnerPassportPuid);
                        ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(owner.Puid, claimName), value);
                    }
                    break;
                case AuthClaimTypes.Language:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(slot.GetUserLanguageId(UserIndex), claimName), value);
                    break;
                case AuthClaimTypes.AgeGroup:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", FormatClaimValue(user.AgeGroupId, claimName), value);
                    break;
                case AuthClaimTypes.Status:
                    ValueCheck.Test("Values did not match on claim '" + claimName + "':", GetMaintenanceClaimString(user.Puid), value);
                    break;
                default:
                    Global.RO.Warn("Skipping validation for a claim because Wisgary is lazy. Need to implement automated validation for claim: " + claimName);
                    break;
            }
        }

        public struct RPServiceResult
        {
            public string claimName;
            public string claimType;
            public string value;
            public string originalIssuer;
        }

        public void ValidateRPServiceResult(string result, CSGInfo slot)
        {
            result = result.Trim();
            string[] lines = result.Split(new string[] { "\r\n" }, StringSplitOptions.None);

            List<RPServiceResult> results = new List<RPServiceResult>();
            foreach (string line in lines)
            {
                string trimmedLine = line.Trim();
                if (!String.IsNullOrEmpty(trimmedLine))
                {                    
                    string[] values = trimmedLine.Split(new string[] { " " }, 4, StringSplitOptions.None);
                    RPServiceResult rpResult = new RPServiceResult { claimName = values[0], claimType = values[1], value = values[2], originalIssuer = values[3] };
                    if (rpResult.originalIssuer != "aamodule") //Let's skip the claims that will be in there even 
							       //if they're not listed in the claims list. Namely, 
							       //the extra flowtoken.
                        results.Add(new RPServiceResult { claimName = values[0], claimType = values[1], value = values[2], originalIssuer = values[3] });
                }
            }

            ValidateRPClaims(results, slot);

        }

        public string GetMaintenanceClaimString(ulong userPuid)
        {
            UserEditor ue = UserEditor.FromPuid(userPuid);

            //I'll ban for at least a week.
            bool isBanned = ue.BannedUntilDate > DateTime.UtcNow.AddDays(7);
            //For the invalid case I set it to 100 years less, 35,000 should be an ok indicator that I "went back in time".
            bool acceptedTos = !((DateTime.UtcNow - ue.AcceptedTOSDate).Days > 35000);


            //See: AuthStatus.cs
            if (isBanned || !acceptedTos)
                return "Maintenance";
            else
                return "Ok";
        }

        public string FormatClaimValue(object value, string claimName)
        {
            string ret = String.Empty;

            if (value != null)
                ret = value.ToString();

            switch (claimName)
            {
                case AuthClaimTypes.DeviceType:
                    if (validatingSTSV1)
                    {
                        ret = "WindowsPhone7";
                    }
                    else
                    {
                        switch ((byte)value)
                        {
                            case XOn.XPLT_XBOX360:
                                ret = "Xbox360";
                                break;
                            case XOn.XPLT_PC:
                                ret = "PC";
                                break;
                            case XOn.XPLT_MOBILE:
                                if ((ClientCert != null) || (!String.IsNullOrEmpty(ClientCertNameOverride)) || UseWP7ClientCert)
                                    ret = "WindowsPhone";
                                else
                                    ret = "WindowsPhone7";
                                break;
                            case XOn.XPLT_XBOX1:
                            case XOn.XPLT_WEB:
                            default:
                                ret = "Web";
                                break;
                        }
                    }
                    break;
                case AuthClaimTypes.TitleId:
                    ret = ((uint)value).ToString();
                    break;
                case AuthClaimTypes.TitleVersion:
                    ret = ((uint)value).ToString();
                    break;
                case AuthClaimTypes.Puid:
                    ret = ((long)value).ToString();
                    break;
                case AuthClaimTypes.Country:
                    //We're good.
                    break;
                case AuthClaimTypes.Privileges:
                    break;
                case AuthClaimTypes.PartnerXuid:
                    ret = ((ulong)value).ToString();
                    ret = AnonymizeAndHash(Util.ServerConfig.AppliesToes[audienceUri], ret);
                    break;
                case AuthClaimTypes.PartnerParentXuid:
                    ret = ((ulong)value).ToString();
                    ret = AnonymizeAndHash(Util.ServerConfig.AppliesToes[audienceUri], ret);
                    break;
                case AuthClaimTypes.Gamertag:
                    //We're good.
                    break;
                case AuthClaimTypes.Tier:
                    if (UseAASG)
                        ret = "6"; //Hardcode for now for the AASG case
                    ret = Util.GetTierString(ret);
                    break;
                case AuthClaimTypes.Xuid:
                    ret = ((ulong)value).ToString();
                    break;
                case AuthClaimTypes.ParentXuid:
                    ret = ((ulong)value).ToString();
                    break;
                case AuthClaimTypes.DeviceId:
                    ret = ((ulong)value).ToString("X");
                    break;
                case AuthClaimTypes.PartnerDeviceId:
                    ret = ((ulong)value).ToString("X");
                    ret = AnonymizeAndHash(Util.ServerConfig.AppliesToes[audienceUri], ret);
                    break;
                case AuthClaimTypes.DeviceName:
                    //We're good.
                    break;
                case AuthClaimTypes.Language:
                    //We're good.
                    break;
                case AuthClaimTypes.FlowToken:
                    ret = ((ulong)value).ToString("X");
                    break;
                case AuthClaimTypes.ClientIpPort:
                    ret = Util.LocalIPAddress().ToString() + ":";
                    if (UseAASG)
                    {
                        string tVal = (string)ret;
                        ret = tVal.Substring(0, tVal.IndexOf(":"));
                    }
                    else
                        ret += 0xFFFF.ToString(); //Append SG port.                                   
                    break;
                case AuthClaimTypes.AgeGroup:
                    ret = Util.GetAgeGroupString((int)value);
                    break;
                default:
                    break;
            }

            IAppliesTo appTo = (IAppliesTo)Util.ServerConfig.AppliesToes[audienceUri];

            if (appTo.ClaimTypes.ContainsKey(new Uri(claimName)) && appTo.ClaimTypes[new Uri(claimName)].ClaimType.Encrypted)
                ret = AnonymizeAndEncrypt(Util.ServerConfig.AppliesToes[new Uri(Util.AUTHSG_URL)], ret);

            return ret;
        }

        public static string AnonymizeAndEncrypt(IAppliesTo appliesTo, string s)
        {
            byte[] key = null;
            if (appliesTo.BusinessPartner.Keys.Count > 0)
                key = appliesTo.BusinessPartner.Keys[appliesTo.BusinessPartner.Keys.Count - 1].SymmetricKey;

            if (null != key)
            {
                SymmetricKey encryptor = new SymmetricKey(key, appliesTo.BusinessPartner.Keys[appliesTo.BusinessPartner.Keys.Count - 1].SymmetricIV);

                const int MasterKeyVersion = 1;
                Blob leadingByte = new byte[] { MasterKeyVersion };

                Blob value = encryptor.Encrypt(Anonymize(appliesTo, s));

                return leadingByte.ToString() + value.ToString();
            }
            else
            {   // If no key then we don't encrypt
                return s;
            }
        }

        public static string DecryptAndDeanonymize(IAppliesTo appliesTo, string s)
        {
            byte[] key = null;
            if (appliesTo.BusinessPartner.Keys.Count > 0)
                key = appliesTo.BusinessPartner.Keys[appliesTo.BusinessPartner.Keys.Count - 1].SymmetricKey;

            if (null != key)
            {
                string symmetricKeyVersion = s.Substring(0, 1);
                // Todo: Verify symmetricKeyVersion

                Blob encrypted = Blob.Parse(s.Substring(1));

                // Todo: need to get the right symmetric key
                SymmetricKey decryptor = new SymmetricKey(key, appliesTo.BusinessPartner.Keys[appliesTo.BusinessPartner.Keys.Count - 1].SymmetricIV);

                string decrypted = ASCIIEncoding.ASCII.GetString(decryptor.Decrypt(encrypted));
                int index = decrypted.IndexOf(":");
                int saltLength = int.Parse(decrypted.Substring(0, index));

                return decrypted.Substring(index + saltLength + 1);
            }

            // If no key then we don't encrypt
            return s;
        }


        private static string AnonymizeAndHash(IAppliesTo appliesTo, string s)
        {
            Blob value = GetHashedBytes(Anonymize(appliesTo, s));

            return value.ToString();
        }

        private static byte[] Anonymize(IAppliesTo appliesTo, string s)
        {
            string anonymizedValue = string.Format("{0}:{1}{2}", appliesTo.BusinessPartner.AnonymizingSalt.Length, appliesTo.BusinessPartner.AnonymizingSalt, s);

            return ASCIIEncoding.ASCII.GetBytes(anonymizedValue);
        }

        private static string GetHashedString(string s)
        {
            Blob value = GetHashedBytes(Encoding.ASCII.GetBytes(s));

            return value.ToString();
        }

        private static byte[] GetHashedBytes(byte[] buffer)
        {
            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
            {
                return sha1.ComputeHash(buffer);
            }
        }

        public void GetDTokenValues(string dToken, out string version, out DateTime date, out string xuid)
        {
            version = Regex.Match(dToken, "v=(.)").Groups[1].Value;
            date = DateTime.Parse(Regex.Match(dToken, "d=\"(.*)\"").Groups[1].Value);
            xuid = Regex.Match(dToken, "x=(0x[0-9A-F]*)").Groups[1].Value;
        }

        #endregion Validation-related methods

        #region URL Creation helpers
        /// <summary>
        /// Gets the STS url.
        /// </summary>
        /// <returns></returns>
        public static string BuildServiceUrl()
        {
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(Interface.authsg);
            url = "http://" + viIP.ToString() + "/testfdxstssoap/Simple.Asmx";


            Global.RO.Debug(url);
            return url;
        }
        #endregion URL Creation helpers

        #region Token Getting/Creating helpers
        public static CSGInfo GetSlot()
        {
            CSGInfo slot = new CSGInfo();
            slot.Initialize();
            slot.machinePuid = MachineEditor.CreateNew(MachineType.Xbox360).Id;
            slot.ClearServices();
            slot.AddService((int)XOService.Vortex);
            slot.AddService((int)XOService.XSts);

            slot.SetUserPrivilege(0, (uint)XOn.XPRIVILEGE_ADD_FRIEND);
            slot.SetUserPrivilege(1, (uint)XOn.XPRIVILEGE_FAMILY);
            slot.SetUserPrivilege(2, (uint)XOn.XPRIVILEGE_BILLING_SWITCHING);
            slot.SetUserPrivilege(3, (uint)XOn.XPRIVILEGE_PURCHASE_CONTENT);

            return slot;
        }

        public string GetClaimValue(string claimType)
        {
            if (token is Saml2SecurityToken)
            {
                Saml2SecurityToken t = (Saml2SecurityToken)token;
                List<Saml2Statement> statements = new List<Saml2Statement>(t.Assertion.Statements);

                if (statements.Count > 1)
                    throw new Exception("Expected only 1 or 0 SAML statements. Found " + statements.Count);

                foreach (Saml2Statement statement in statements)
                {
                    if (statement is Saml2AttributeStatement)
                    {
                        Saml2AttributeStatement attribStatement = (Saml2AttributeStatement)statement;

                        foreach (Saml2Attribute attrib in attribStatement.Attributes)
                            if (attrib.Name == claimType)
                                return attrib.Values[0];
                    }
                }
            }
            return null;

        }

        /// <summary>
        /// Gets a token from the STS. Grabs a string then parses it. 
        /// Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public SecurityToken GetTokenFromSTS(RSTGenerator gen)
        {
            RSTGen = gen;
            return GetTokenFromSTS();
        }
        public string GetTokenStringFromSTS(RSTGenerator gen)
        {
            RSTGen = gen;
            return GetTokenStringFromSTS();
        }


        /// <summary>
        /// Gets a token from the STS. Grabs a string then parses it. 
        /// Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public SecurityToken GetTokenFromSTS()
        {
            string tokenString = GetTokenStringFromSTS();
            return token;
        }

        public string GetTokenStringFromSTS()
        {
            CSGInfo slot = XSTSTokenRequestor.GetSlot();
            tokenString = GetTokenStringFromSTS(slot);
            if (!Stress)
            {
                if (!tokenString.StartsWith("<XblToken Id=\""))
                {
                    token = Util.ParseToken(tokenString, RSTGen.AppliesTo.Uri.ToString());
                }
            }

            return tokenString;
        }
        /// <summary>
        /// Generates a request to the STS, fills in some values for the SGInfo, then grabs the token as a string. 
        /// Not the full response, just the token. Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public string GetTokenStringFromSTS(RSTGenerator gen, CSGInfo slot)
        {
            RSTGen = gen;
            return GetTokenStringFromSTS(slot);
        }

        /// <summary>
        /// Generates a request to the STS, fills in some values for the SGInfo, then grabs the token as a string. 
        /// Not the full response, just the token. Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public string GetTokenStringFromSTS(CSGInfo slot)
        {
            string tokenString = null;
            string responseXml = null;

            KdcUser ku = null;

            if (RSTGen.AppliesTo != null)
                audienceUri = RSTGen.AppliesTo.Uri;


            if (ServicesToUse == SecurityTokenServices.STS)
            {
                ku = GetUser(0);
                //Only STS, so let's prep stuff up.
                slot.SetUserPuid(0, ku.UserID);
                slot.SetTier(0, XOn.XONLINE_TIER_GOLD);
                slot.SetRegionInfo(XOn.XONLINE_COUNTRY_KOREA, XOn.XC_LANGUAGE_KOREAN);

                UserEditor ue = UserEditor.FromPuid(ku.UserID);
                ue.CultureId = 1042;
                ue.LanguageId = XOn.XC_LANGUAGE_KOREAN;
                ue.CountryId = (byte)XOn.XONLINE_COUNTRY_KOREA;
            }

            #region XSTS
            if (ServicesToUse == SecurityTokenServices.Both || ServicesToUse == SecurityTokenServices.XSTS)
            {
                if (UseAASG)
                {
                    // AASG Requests just use the first user
                    ku = GetUser(0);

                    UserEditor ue = UserEditor.FromPuid(ku.UserID);
                    if (!Stress)
                    {
                        ue.CultureId = 1042;
                        ue.LanguageId = XOn.XC_LANGUAGE_KOREAN;
                        ue.CountryId = (byte)XOn.XONLINE_COUNTRY_KOREA;
                    }

                    slot.SetRegionInfo(XOn.XONLINE_COUNTRY_KOREA, XOn.XC_LANGUAGE_KOREAN);


                    XSTSAASG aasgReq = new XSTSAASG();
                    if (!String.IsNullOrEmpty(XBL20Header))
                        aasgReq.SneakyXBL20 = XBL20Header;
                    if (!String.IsNullOrEmpty(AuthorizationHdr))
                        aasgReq.AuthorizationHdr = AuthorizationHdr;

                    if (ClientCertNameOverride != null)
                    {
                        aasgReq.ClientCertNameOverride = ClientCertNameOverride;
                    }
                    if (ClientCertThumbprintOverride != null)
                    {
                        aasgReq.ClientCertThumbprintOverride = ClientCertThumbprintOverride;
                    }

                    if (null != RSTGen.AppliesTo)
                    {
                        aasgReq.RPUrl = RSTGen.AppliesTo.Uri.ToString();
                    }

                    responseXml = aasgReq.SendHTTPRequest(RSTGen, ue.Gamertag, ue.UserPassportPuid, ClientCert);
                    
                    StatusCode = aasgReq.StatusCode;
                    XErr = aasgReq.XErr;

                    slot.SetUserPuid(0, ku.UserID);
                    if (UseWP7ClientCert)
                    {
                        string wmid = null;
                        
                        if (ClientCert.Subject.Contains("CN=urn:wp-ac-hash:"))                            
                            wmid = Util.GetWM7IDFromSubjectName(ClientCert.Subject);
                        
                        if (ClientCert.Subject.Contains("CN=urn:wp-ac-hash-2:"))
                            wmid = Util.GetWM8IDFromSubjectName(ClientCert.Subject);
                        
                        if (String.IsNullOrEmpty(wmid))
                            wmid = ClientCert.Thumbprint;
                        try
                        {
                            slot.machinePuid = MachineEditor.FromWMDId(wmid).Id;
                        }
                        catch (Exception)
                        {
                            //This almost guaranteed means we couldn't find it.                             
                            slot.machinePuid = 0;
                        }
                    }
                }
                else
                {
                    XSTSIssueXRL xrl = new XSTSIssueXRL();

                    for (int i = 0; i < UsersInTicket; i++)
                    {
                        ku = GetUser(i);
                        slot.SetUserPuid(i, ku.UserID);
                        slot.SetTier(i, XOn.XONLINE_TIER_GOLD);

                        if (!Stress)
                        {
                            UserEditor ue = UserEditor.FromPuid(ku.UserID);
                            ue.CultureId = 1042;
                            ue.LanguageId = XOn.XC_LANGUAGE_KOREAN;
                            ue.CountryId = (byte)XOn.XONLINE_COUNTRY_KOREA;
                        }

                        slot.SetRegionInfo(XOn.XONLINE_COUNTRY_KOREA, XOn.XC_LANGUAGE_KOREAN);
                    }

                    if (RSTGen.AppliesTo != null)
                        xrl.RPUrl = RSTGen.AppliesTo.Uri.ToString();

                    Puid p = (Puid)slot.GetUserPuid(UserIndex); //For formatting

                    if (null == RSTGen.AdditionalContext)
                    {
                        RSTGen.AdditionalContext = new AdditionalContext();

                        if (RSTGen.XuidOverride == null)
                            RSTGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.Xuid), p.ToString()));
                        else
                            RSTGen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.Xuid), RSTGen.XuidOverride));
                    }

                    xrl.RstGen = RSTGen;
                    xrl.Slot = slot;
                    xrl.ManualSlotSetup = true;

                    if (UseDelegationToken)
                    {
                        xrl.CustomHeader = XHttpHdr.CERT_SUBJECT + ":" + "CN=internal_relying_party.core.live, OU=Xbox Live, O=Microsoft, L=Redmond, S=WA, C=US\r\n";
                        xrl.CustomHeader += XHttpHdr.CERT_THUMBPRINT + ":" + "lolol\r\n";
                    }

                    if (Stress)
                    {
                        // If it's a stress test, we generate the RST once,
                        // and then just cache it for the later requests
                        if (stressRst == null)
                        {
                            stressRst = RSTGen.BuildRST();
                            stressRst = Regex.Replace(stressRst, "0x[0-9A-Fa-f]{16}", "{0}");
                            stressRst = Regex.Replace(stressRst, "<Address>.*</Address>", "<Address>{1}</Address>");
                        }

                        string stressRstActive = String.Format(stressRst, p.ToString(), RSTGen.AppliesTo);

                        xrl.Execute(stressRstActive);
                    }
                    else
                    {
                        xrl.Execute();
                    }

                    byte[] contents;

                    StatusCode = xrl.xAct.httpStatus;
                    XErr = "0x" + xrl.xAct.XErr.ToString("X08");

                    if (xrl.xAct.ResponseContents == null)
                        contents = xrl.xAct.ErrorContents;
                    else
                        contents = xrl.xAct.ResponseContents;

                    using (MemoryStream ms = new MemoryStream(contents))
                    using (StreamReader rdr = new StreamReader(ms))
                    {
                        responseXml = rdr.ReadToEnd();
                    }
                }

                if (!Stress)
                {
                    tokenString = ExtractTokenString(responseXml);

                    if (tokenString != null)
                    {
                        Global.RO.Debug(tokenString);
                    }
                    else
                    {
                        Global.RO.Debug("The token was null.");
                        throw new Exception(responseXml);
                    }

                    
                    ValidateToken(tokenString, slot);
                    
                }
                else
                {
                    if (!responseXml.Contains("Assertion"))
                        throw new Exception(responseXml);

                    if (responseXml.Contains(AuthClaimTypes.Xuid) && !responseXml.Contains(slot.GetUserPuid(UserIndex).ToString()))
                        throw new Exception(responseXml);

                }
            }
            #endregion XSTS

            #region STS
            if (ServicesToUse == SecurityTokenServices.STS || ServicesToUse == SecurityTokenServices.Both)
            {

                STSUtil.GetSecurityTicketParameters gstParams = GetDefaultGSTParams(slot);
                string stsTicket = ServerTestFramework.STS.STSUtil.GetSecurityTicket(gstParams);

                //Now call GetPartner with it.
                GetSecurityTicketAudienceSoap gst = new GetSecurityTicketAudienceSoap();
                gst.AAInfo = new StsTest.AAInfoWrapper(FormatClaimValue("", AuthClaimTypes.ClientIpPort), new Floken(slot.flowToken));
                gst.AAInfo.SamlToken = stsTicket;

                string sts1Token = gst.GetPartnerSecurityTicket(slot.GetUserPuid(UserIndex), Convert.ToUInt32(gstParams.TitleID, 16), Convert.ToUInt32(gstParams.TitleVersion), audienceUri.ToString());
                validatingSTSV1 = true;
                try
                {
                    Global.RO.Debug(sts1Token);
                    ValidateToken(ExtractTokenString(sts1Token), slot);
                    ValidateSTSV1Condition(sts1Token);
                }
                finally
                {
                    validatingSTSV1 = false;
                }

                //If nothing from XSTS, go with the STSv1 one.
                if (ServicesToUse == SecurityTokenServices.STS)
                    tokenString = ExtractTokenString(sts1Token);
            }
            #endregion STS            
            return tokenString;
        }

        #endregion Token Getting/Creating helpers

        #region STSv1 helpers
        public STSUtil.GetSecurityTicketParameters GetDefaultGSTParams(CSGInfo slot)
        {
            UserEditor user = UserEditor.FromPuid(slot.GetUserPuid(UserIndex));

            STSUtil.GetSecurityTicketParameters gstParams = new STSUtil.GetSecurityTicketParameters(XOn.XPLT_MOBILE);
            gstParams.Certificate = ServerTestFramework.STS.STSUtil.GetStsSigningCertificate();
            gstParams.Xuid[0] = slot.GetUserPuid(UserIndex).ToString();
            gstParams.MachineID = slot.machinePuid.ToString();
            gstParams.TitleID = slot.titleId.ToString("X");
            gstParams.TitleVersion = slot.titleVersion.ToString();
            gstParams.Country = new string[] { slot.GetUserCountryId(UserIndex).ToString() };
            gstParams.Country0 = slot.GetUserCountryId(UserIndex).ToString();
            gstParams.Puid0 = user.UserPassportPuid.ToString();

            return gstParams;
        }

        public void ValidateSTSV1Condition(string sts1FullToken)
        {
            string xstsToken = sts1FullToken.Substring(sts1FullToken.IndexOf(samlTag) + samlTag.Length);
            string conditionAssertion = sts1FullToken.Substring(0, sts1FullToken.IndexOf(samlTag) + samlTag.Length);
            Saml2SecurityToken s2t = Util.ParseToken(xstsToken, audienceUri.ToString());

            ValidateSTSV1Expiry(conditionAssertion, s2t);
        }

        public void ValidateSTSV1Expiry(string conditionAssertion, Saml2SecurityToken xstsToken)
        {
            XDocument doc = XDocument.Parse(conditionAssertion);
            DateTime notBefore = DateTime.Parse(doc.Descendants("{urn:oasis:names:tc:SAML:1.0:assertion}Conditions").First().Attribute("NotBefore").Value);
            DateTime notOnOrAfter = DateTime.Parse(doc.Descendants("{urn:oasis:names:tc:SAML:1.0:assertion}Conditions").First().Attribute("NotOnOrAfter").Value);

            ValueCheck.Test("NotBefore did not match the value in the XSTS token.", notBefore.ToUniversalTime(), xstsToken.Assertion.Conditions.NotBefore);
            ValueCheck.Test("NotOnOrAfter did not match the value in the XSTS token.", notOnOrAfter.ToUniversalTime(), xstsToken.Assertion.Conditions.NotOnOrAfter);
        }

        public string ExtractTokenString(string responseXml)
        {
            if (responseXml.Contains(samlTag))
                responseXml = responseXml.Substring(responseXml.IndexOf(samlTag) + samlTag.Length);

            XDocument responseXmlDoc = XDocument.Parse(responseXml);
            string token = null;
            var descendants = responseXmlDoc.Descendants("{urn:oasis:names:tc:SAML:2.0:assertion}Assertion");
            if (descendants.Count() < 1)
                descendants = responseXmlDoc.Descendants("{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAssertion");
            if (descendants.Count() < 1)
                descendants = responseXmlDoc.Descendants("XblToken");
            if (descendants.Count() > 0)
            {
                token = descendants.ElementAt(0).ToString(SaveOptions.DisableFormatting);
            }
            return token;
        }
        #endregion STSv1 helpers
    }

    public struct TestCaseData
    {
        public string TestName;
        public bool OnDemand;
        public bool TestOnly;
        public string ExpectedStatus;
        public string ExpectedXErr;       
        
        public AppliesTo appliesTo;
        public List<string> ClaimUris;

        public struct AppliesTo
        {
            public string uri;
            public string cert;
            public string validityInterval;
            public string businessPartnerId;
            public string tokenType;
            public Int32 validityMinutes;
        }
    }

    public static class Util
    {
        public struct CustomClaim
        {
            public string claimUri;
            public string friendlyTitle;
            public string friendlyDescription;
            public string encrypted;
            public string b_private;
            public string anonymized;
            public string value_type;
        }
        
        public const string SERVICE_URL = "http://testfdxsts/";
        public const string AUTHSG_URL = "http://xboxlive.com/";
        public const string XAM_URL = "http://xam.xboxlive.com/";
        /// <summary>
        /// Creates an RST object with default values.
        /// </summary>
        /// <returns></returns>
        public static RSTGenerator CreateDefaultRST()
        {
            RSTGenerator gen = new RSTGenerator();

            gen.ReplyTo = "http://www.w3.org/2005/08/addressing/anonymous";
            gen.RequestType = WSTrust13Constants.RequestTypes.Issue;
            gen.TokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11;
            gen.KeyType = WSTrust13Constants.KeyTypes.Bearer;

            return gen;
        }

        public static string CallRPService(string token, string appliesToUri)
        {
            return CallRPService(token, appliesToUri, new string[] { });
        }        

        public static string CallRPService(string token, string appliesToUri, string[] headers)
        {
            bool parseFailed = false;
            string rpServiceResult = null;
            Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityToken t = null;
            try
            {
                t = Util.ParseToken(token, appliesToUri);
            }
            catch (Exception)
            {
                //Can't even parse. If we got this far and I'm trying to call it is likely on purpose. Warn.                
                Global.RO.Warn("Parsing the token we are trying to send to the authsg failed, double check to make sure this test case sends a weird token on purpose. Might be XblToken stuff.");
                parseFailed = true;
            }
            
            Collection<Uri> tokenAudiences = null;
            if (!parseFailed)
                tokenAudiences = t.Assertion.Conditions.AudienceRestrictions[0].Audiences;

            if (parseFailed ||
                ((t.Assertion.Conditions.AudienceRestrictions.Count > 0)
                && (tokenAudiences.Count > 0)
                && (tokenAudiences[0].AbsoluteUri.ToString().Contains(Util.SERVICE_URL) //Allow only the things understood 
                    || tokenAudiences[0].AbsoluteUri.ToString().Contains(Util.AUTHSG_URL) //by the AASG.
                    || tokenAudiences[0].AbsoluteUri.ToString().Contains(Util.XAM_URL))))
            {
                SimpleClientBase client = SimpleClientBase.CreateClient(ProtocolToUse.Soap, true);
                client.AddClaimToken(token);

                foreach (string h in headers)
                    client.AdditionalHeaders.Add(h);

                Global.RO.Debug("Service claims:");
                rpServiceResult = client.GetTokenClaimsString();
                Global.RO.Debug(rpServiceResult);
            }
            return rpServiceResult;
        }

        public static List<string> CallHealthcheck()
        {
            string url;
            IPEndPoint viIP;
            List<string> outputs = new List<string>(); //Only one right now.

            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                viIP = Global.XEnv.GetVirtualInterface(Interface.xsts_int);
                url = "http://" + viIP.ToString() + "/xsts/health.ashx";
            }

            //Retries
            int k = 0;
            
            while (++k <= 3)
            {
                try
                {
                    string output = PostRequest(url, "GET", null, false, null);
                    outputs.Add(output);
                    return outputs;
                }
                catch (Exception)
                {
                    if (k == 3) //On our third try, give up.
                        throw;
                }
            }
            
            throw new Exception("How is this even possible. Failed to get a healthcheck in a weird way.");
            
        }

        public static string CallXmgmt(string cmd)
        {
            string output;
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAll(Interface.xsts, "e :xsts " + cmd, out output);

            if (cmd == "reload")
                CallXmgmtSTS(cmd);
            return output;
        }

        public static string CallXmgmtSTS(string cmd)
        {
            string output;
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAll(Interface.xsts, "e :sts " + cmd, out output);
            return output;
        }

        public static void ReloadAA()
        {
            string outputCCR;
            string outputReload;
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.authsg, "aamodule", "aamodule configcacherefresh", out outputCCR);
            Global.RO.Debug(outputCCR);
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.authsg, "aamodule", "aamodule reload", out outputReload);
            Global.RO.Debug(outputReload);

            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.authsg, "authsg", "authsg configcacherefresh", out outputCCR);
            Global.RO.Debug(outputCCR);
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.authsg, "authsg", "authsg reload", out outputReload);
            Global.RO.Debug(outputReload);
        }

        public static void ReloadXSTS()
        {
            string outputCCR;
            string outputReload;
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.xsts, "xsts", "xsts configcacherefresh", out outputCCR);
            Global.RO.Debug(outputCCR);
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(Interface.xsts, "xsts", "xsts reload", out outputReload);
            Global.RO.Debug(outputReload);           
        }


        /// <summary>
        /// Just takes advantage of the fact that XDocument formats xml for you.
        /// </summary>
        /// <param name="xml"></param>
        /// <returns></returns>
        public static string GetFormattedXMLString(string xml)
        {
            XDocument formattedXmlDoc = XDocument.Parse(xml);
            return formattedXmlDoc.ToString();
        }

        public static string GetWM7IDFromSubjectName(string subjectName)
        {
            X500DistinguishedName name = new X500DistinguishedName(subjectName);
            string[] distinguishedNameParts = name.Decode(X500DistinguishedNameFlags.UseCommas | X500DistinguishedNameFlags.DoNotUseQuotes).Split(',');
            string cn = GetDistingushedNamePart("CN=urn:wp-ac-hash:", distinguishedNameParts);                       

            return cn;
        }

        public static string GetWM8IDFromSubjectName(string subjectName)
        {
            X500DistinguishedName name = new X500DistinguishedName(subjectName);
            string[] distinguishedNameParts = name.Decode(X500DistinguishedNameFlags.UseCommas | X500DistinguishedNameFlags.DoNotUseQuotes).Split(',');

            string cn = GetDistingushedNamePart("CN=urn:wp-ac-hash-2:", distinguishedNameParts);            
            if (String.IsNullOrEmpty(cn))
                return String.Empty;
            
            string ou = GetDistingushedNamePart("OU=", distinguishedNameParts);            
            if (String.IsNullOrEmpty(ou))
                return String.Empty;
            
            return cn + ou;
        }        

        private static string GetDistingushedNamePart(string prefix, string[] distinguishedNameParts)
        {
            string namePart;

            foreach (string distinguishedNamePart in distinguishedNameParts)
            {
                namePart = distinguishedNamePart.Trim();
                if (namePart.StartsWith(prefix) && prefix.Length < namePart.Length)
                {
                    return namePart.Substring(prefix.Length);
                }
            }

            return string.Empty;
        }


        private static X509Certificate2 testCert;
        private static X509Certificate2 xboxLiveCert;

        public static X509Certificate2 GetEncryptingCert(string appliesToUri)
        {
            if (appliesToUri.Contains("xboxlive.com") || appliesToUri.Contains("testfdxsts"))
            {
                if (xboxLiveCert == null)
                    xboxLiveCert = XstsUtil.GetXstsEncryptingCertificate();
                return xboxLiveCert;
            }
            else
            {
                if (testCert == null)
                    testCert = new X509Certificate2(@"SuitesData\XSTS\RPCert.pfx", "sts");
                return testCert;
            }
        }


        public static X509Certificate2 GetSigningCert()
        {
            X509Certificate2 cert = new X509Certificate2(@"SuitesData\XSTS\xsts.test.xboxlive.com.pfx", "cr8a2xz8");
            return cert;
        }

        /// <summary>
        /// Turns the token string into a proper SecurityToken object.
        /// </summary>
        /// <param name="xmlString"></param>
        /// <returns></returns>
        public static Saml2SecurityToken ParseToken(string xmlString, string appliesToUri)
        {
            Saml2SecurityToken token = null;

            using (MemoryStream tokenStream = new MemoryStream())
            using (StreamWriter wr = new StreamWriter(tokenStream))
            {
                wr.Write(xmlString);
                wr.Flush();
                tokenStream.Position = 0;

                List<Saml2SecurityToken> tokens = new List<Saml2SecurityToken>();
                Saml2SecurityTokenHandler h = new Saml2SecurityTokenHandler();
                h.Configuration = new Microsoft.IdentityModel.Tokens.SecurityTokenHandlerConfiguration();

                SecurityTokenHandlerCollection collection = SecurityTokenHandlerCollection.CreateDefaultSecurityTokenHandlerCollection();

                // Create the service token resolver from the service certificate.
                List<SecurityToken> serviceTokens = new List<SecurityToken>();
                // This service certificate is considered to have been defined elsewhere
                serviceTokens.Add(new X509SecurityToken(Util.GetEncryptingCert(appliesToUri)));
                SecurityTokenResolver serviceResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(serviceTokens.AsReadOnly(), false);

                h.Configuration.ServiceTokenResolver = serviceResolver;

                // Create the issuer  token resolver from the service certificate.
                List<SecurityToken> issuerTokens = new List<SecurityToken>();
                issuerTokens.Add(new X509SecurityToken(Util.GetSigningCert()));
                SecurityTokenResolver issuerResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(issuerTokens.AsReadOnly(), false);
                h.Configuration.IssuerTokenResolver = issuerResolver;


                token = (Saml2SecurityToken)h.ReadToken(XmlReader.Create(new StringReader(xmlString)));

                //SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<Saml2SecurityToken>(tokens), true);

                //using (XmlReader r = XmlReader.Create(tokenStream))
                //{
                //    token = (Saml2SecurityToken)WSSecurityTokenSerializer.DefaultInstance.ReadToken(r, outOfBandTokenResolver);
                //}
            }
            return token;
        }

        /// <summary>
        /// Turns the token string into a proper SecurityToken object.
        /// </summary>
        /// <param name="xmlString"></param>
        /// <returns></returns>
        public static SamlSecurityToken ParseSts1Token(string xmlString)
        {
            SamlSecurityToken token = null;

            using (MemoryStream tokenStream = new MemoryStream())
            using (StreamWriter wr = new StreamWriter(tokenStream))
            {
                wr.Write(xmlString);
                wr.Flush();
                tokenStream.Position = 0;
                SamlSerializer ssr = new SamlSerializer();

                XmlReader reader = XmlReader.Create(tokenStream);
                List<SecurityToken> tokens = new List<SecurityToken>();

                tokens.Add(new X509SecurityToken(STSUtil.GetStsSigningCertificate()));
                SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<SecurityToken>(tokens), true);
                SecurityToken securityToken = System.ServiceModel.Security.WSSecurityTokenSerializer.DefaultInstance.ReadToken(reader, outOfBandTokenResolver);

                token = securityToken as SamlSecurityToken;
            }

            return token;
        }
        /// <summary>
        /// Creates a user in the database then returns its puid.
        /// </summary>
        /// <returns></returns>
        public static KdcUser CreateUser()
        {
            return CreateUser(true, false);
        }

        /// <summary>
        /// Creates a user in the database then returns its puid.
        /// </summary>
        /// <returns></returns>
        public static KdcUser CreateUser(bool acceptedTou, bool banned)
        {
            KdcUser user = UserCreator.GetSharedUser();

            //Banning/Unsetting TOU user
            UserEditor ue = UserEditor.FromPuid(user.UserID);

            if (banned)
            {
                ue.BannedUntilDate = DateTime.Now.AddDays(10);
            }

            if (!acceptedTou)
            {
                ue.AcceptedTOSDate = DateTime.Now.AddYears(-100);
            }

            return user;
        }

        public static IPAddress LocalIPAddress()
        {
            return IpHelper.GetBestInterface(Global.XEnv.GetVirtualInterface("xsts").Address);
        }

        /// </summary>
        /// Load/Reload configuration data
        /// </summary>
        public static void LoadXSTSConfiguration()
        {
            try
            {
                _serverConfig = GetServerConfig();

            }
            catch (Exception ex)
            {
                Global.RO.Warn(ex.Message);
                Global.RO.Debug("Installing the master key and trying again.");
                XstsUtil.InstallMasterKey();
                _serverConfig = GetServerConfig();
            }
        }        

        public static ISTSConfiguration GetServerConfig()
        {
            ISTSConfigurationProvider configProvider = (ISTSConfigurationProvider)new xonline.config.sts.databaseconfig.DatabaseConfigurationProvider();

            if (null == configProvider)
                return null;

            configProvider.Load();
            return configProvider.STSConfiguration;
        }

        public static string GetTierString(string ret)
        {
            switch (Convert.ToUInt32(ret)) //SWITCHCEPTION
            {
                case XOn.XONLINE_TIER_NEWUSER:
                    ret = "None";
                    break;
                case XOn.XONLINE_TIER_SILVER:
                    ret = "Silver";
                    break;
                case XOn.XONLINE_TIER_GOLD:
                    ret = "Gold";
                    break;
                case XOn.XONLINE_TIER_FAMILY_GOLD:
                    ret = "FamilyGold";
                    break;
                default:
                    break;
            }
            return ret;
        }

        public static string GetAgeGroupString(int ageGroup)
        {
            string ageString = String.Empty;
            switch (Convert.ToUInt32(ageGroup)) //SWITCHCEPTION
            {
                case XOn.PARENTAL_CONTROL_GROUP_RESTRICTED:
                    ageString = "Child";
                    break;
                case XOn.PARENTAL_CONTROL_GROUP_MEDIUM:
                    ageString = "Teen";
                    break;
                case XOn.PARENTAL_CONTROL_GROUP_OPEN:
                    ageString = "Adult";
                    break;
                default: break;
            }
            return ageString;
        }

        private static ISTSConfiguration _serverConfig;

        public static ISTSConfiguration ServerConfig
        {
            get
            {
                return _serverConfig;
            }
        }

        public static Dictionary<string, TestCaseData> PushConfiguration(bool prop)
        {
            string configData;
            using (FileStream fs = new FileStream(@"SuitesData\XSTS\XSTSConfigTests.xml", FileMode.Open))
            using (StreamReader sr = new StreamReader(fs))
            {
                configData = sr.ReadToEnd();
            }

            var config = XElement.Parse(configData);

            #region Set Business Partner types
            var businessPartnerClaimTypes = config.Descendants("BusinessPartnerClaimType");

            foreach (XElement bp in businessPartnerClaimTypes)
            {
                string friendlyName = (String)bp.Element("friendlyName");
                int type = (int)bp.Element("type");
                int requiresCert = (int)bp.Element("requiresCert");
                List<string> bpClaimTypeUris = bp.Element("ClaimUris").Descendants("claimUri").Select(cu => cu.Value).ToList();
                if (prop)
                    PropBusinessPartnerType(type, friendlyName, bpClaimTypeUris, requiresCert);
            }
            #endregion

            #region Set Claim Providers
            var claimProviders = config.Descendants("CustomClaimProvider");

            foreach (XElement bp in claimProviders)
            {                
                string claimProviderId = (string)bp.Element("claimProviderId");
                string friendlyName = (string)bp.Element("friendlyName");
                string assemblyName = (string)bp.Element("assemblyName");                
                
                List<XElement> customClaimElements = bp.Element("CustomClaims").Descendants("CustomClaim").ToList();
                List<string> claimUris = new List<string>();
                List<CustomClaim> customClaimObjects = new List<CustomClaim>();
                foreach (XElement cc in customClaimElements)
                {
                    CustomClaim claim = new CustomClaim() { 
                    claimUri = (string)cc.Element("claimUri"),
                    friendlyTitle = (string)cc.Element("friendlyTitle"),
                    friendlyDescription = (string)cc.Element("friendlyDescription"),
                    encrypted = (string)cc.Element("encrypted"),
                    b_private = (string)cc.Element("private"),
                    anonymized = (string)cc.Element("anonymized"),
                    value_type = (string)cc.Element("value_type")
                    };

                    customClaimObjects.Add(claim);
                    claimUris.Add(claim.claimUri);                    
                }

                if (prop && PropClaimProviderBits())
                {
                    //Temporary try catch just to be safe, this is a dangerous prop because it's propping new data and new bits to the bin folder.
                    //I don't know how this will all work out in an expanded environment and I don't want to risk fully ruining automated runs for one thing. 
                    try
                    {
                        PropClaimProvider(claimProviderId, friendlyName, assemblyName, customClaimObjects);

                        //Just add it to all 3 default ones. (Partner, Private, Legacy)
                        PropBusinessPartnerType(0, friendlyName, claimUris, 0);
                        PropBusinessPartnerType(1, friendlyName, claimUris, 0);
                        PropBusinessPartnerType(2, friendlyName, claimUris, 0);
                    }
                    catch (Exception ex)
                    {
                        Global.RO.Warn("Could not prop custom claim provider. Reason:" + ex.Message);
                    }
                }                
            }
            #endregion

            #region Set Business Partners
            var businessPartners = config.Descendants("BusinessPartner");

            foreach (XElement bp in businessPartners)
            {
                string partnerId = (String)bp.Element("partnerId");
                string friendlyName = (String)bp.Element("friendlyName");
                string salt = (String)bp.Element("salt");
                string priv = (String)bp.Element("private");
                string type = (String)bp.Element("type");
                if (prop)
                    PropBusinessPartner(partnerId, friendlyName, salt, priv, type);
            }
            #endregion
            #region Load test cases and test case data

            var testCases = (from tc in config.Descendants("TestCaseData")
                             let testCaseAppliesTo = tc.Element("AppliesTo")
                             select new TestCaseData
                             {
                                 TestName = (String)tc.Attribute("name"),
                                 OnDemand = (tc.Attribute("OnDemandProp") == null ? false : (bool)tc.Attribute("OnDemandProp")),
                                 TestOnly = (tc.Attribute("TestOnly") == null ? false : (bool)tc.Attribute("TestOnly")),
                                 ExpectedStatus = (tc.Attribute("ExpectedStatus") == null ? string.Empty : (string)tc.Attribute("ExpectedStatus")),
                                 ExpectedXErr = (tc.Attribute("ExpectedXErr") == null ? string.Empty : (string)tc.Attribute("ExpectedXErr")),
                                 appliesTo = new TestCaseData.AppliesTo
                                 {
                                     businessPartnerId = (String)testCaseAppliesTo.Element("businessPartnerId"),
                                     cert = (String)testCaseAppliesTo.Element("cert"),
                                     tokenType = (String)testCaseAppliesTo.Element("tokenType"),
                                     uri = (String)testCaseAppliesTo.Element("uri"),
                                     validityInterval = (String)testCaseAppliesTo.Element("validityInterval"),
                                     // NOTE: We are just using the same value as the validity interval here, this 
                                     // should be updated ones the test data is updated to read in the correct value
                                     validityMinutes = (Int32)TimeSpan.Parse((String)testCaseAppliesTo.Element("validityInterval")).TotalMinutes,
                                 },
                                 ClaimUris = tc.Element("ClaimUris").Descendants("claimUri").Select(cu => cu.Value).ToList(),
                             }).ToDictionary(tcd => tcd.TestName);

            if (prop)
            {
                foreach (var tcd in testCases.Values)
                {
                    //Try catch to avoid failing the whole run if one test case is misconfigured.
                    try
                    {
                        if (!tcd.OnDemand && !tcd.TestOnly)
                            PropTestCaseData(tcd);
                    }
                    catch (Exception ex)
                    {
                        Global.RO.Warn("Could not prop test case data for test case:" + tcd.TestName + " Reason:" + ex.Message);
                    }
                }
                Util.CallXmgmt("reload");
            }
            #endregion
            return testCases;
        }
        
        public static void PropTestCaseData(TestCaseData tcd)
        {
            //Prop the appliesTo data
            PropAppliesTo(tcd.appliesTo);
            //Map the claims
            MapClaims(tcd.appliesTo.uri, tcd.ClaimUris);

            if (tcd.OnDemand)
            {
                Util.CallXmgmt("reload");
                Util.LoadXSTSConfiguration();
            }
        }

        public static void UnPropTestCaseData(TestCaseData tcd)
        {
            UnMapClaims(tcd.appliesTo.uri, tcd.ClaimUris);
            UnPropAppliesTo(tcd.appliesTo);

            if (tcd.OnDemand)
            {
                Util.CallXmgmt("reload");
                Util.LoadXSTSConfiguration();
            }
        }

        private static string PostRequest(string url, string method, byte[] content, bool fKeepAlive, NameValueCollection headers)
        {
            try
            {
                Global.RO.Debug("HTTP Request: {0}", url);

                HttpWebRequest webreq = (HttpWebRequest)WebRequest.Create(url);
                webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                webreq.UserAgent = "XSTSTest/0.1";

                webreq.KeepAlive = fKeepAlive;
                webreq.Method = method;
                webreq.Timeout = 20000;
                webreq.ContentType = "application/soap+xml; charset=utf-8"; // @@@?                                
                webreq.ContentLength = content == null ? 0 : content.Length;

                if (headers != null)
                    webreq.Headers.Add(headers);

                //IFLC header                
                if (!String.IsNullOrEmpty(webreq.Address.Query))
                {
                    byte[] queryStringBytes = System.Text.Encoding.UTF8.GetBytes(webreq.Address.Query.Substring(1));
                    MemoryStream streamQuery = new MemoryStream(queryStringBytes);
                    string sig = LogCollectorCrypto.CreateSignature(streamQuery);
                    webreq.Headers.Add("X-IFLCDIGEST", sig);
                }


                // Set all headers prior to this!
                if (content != null)
                {
                    // This initiates the send, btw                    
                    webreq.GetRequestStream().Write(content, 0, content.Length);
                }

                // Finish and get response
                HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

                // Read body
                StreamReader sr = new StreamReader(webresp.GetResponseStream());
                string contentResponse = sr.ReadToEnd();

                webresp.Close();
                sr.Close();

                return contentResponse;
            }
            catch (WebException we)
            {
                // We throw, so no need to print this
                // ro.Error("Got WebException:\n{0}", we.ToString());
                Global.RO.Warn("WebException: {0}, Status {1}", we.Message, we.Status);

                if (we.Response != null)
                {
                    StreamReader sr = null;
                    try
                    {
                        Global.RO.Debug("WebException Response headers:\n{0}", we.Response.Headers);

                        //                     sr = new StreamReader(we.Response.GetResponseStream());
                        //                     String s = sr.ReadToEnd();

                    }
                    finally
                    {
                        we.Response.Close();
                        if (sr != null)
                            sr.Close();
                    }
                }

                throw;
            }
        }

        #region DB helpers
        public static void PropBusinessPartner(string partnerId, string friendlyName, string salt, string priv, string type)
        {
            if (!CheckBusinessPartner(partnerId))
            {
                using (var wsClient = GetSecDBClient())
                {
                    wsClient.StoredProc = null;
                    wsClient.CommandSql = String.Format("insert into t_sts_business_partner values ('{0}', '{1}', '{2}', {3}, {4})", partnerId, friendlyName, salt, priv, type);
                    var reader = wsClient.ExecuteNonQuery();
                }
            }
        }

        public static void PropAppliesTo(TestCaseData.AppliesTo appTo)
        {
            if (!CheckAppliesTo(appTo))
            {
                using (var wsClient = GetSecDBClient())
                {
                    wsClient.StoredProc = "p_sts_applies_to_set";
                    wsClient.AddParameterObject("vc_applies_to_uri", appTo.uri);
                    wsClient.AddParameterObject("vc_applies_to_cert", appTo.cert);
                    wsClient.AddParameterObject("vc_token_type_uri", appTo.tokenType);
                    wsClient.AddParameterObject("t_validity_interval", "0:0:0");
                    wsClient.AddParameterObject("uid_business_partner_id", appTo.businessPartnerId);
                    wsClient.AddParameterObject("i_validity_minutes", appTo.validityMinutes);
                    //wsClient.CommandSql = String.Format("insert into t_sts_applies_to values ('{0}', '{1}', '{2}', '{3}', '{4}')", appTo.uri, appTo.cert, appTo.validityInterval, appTo.businessPartnerId, appTo.tokenType);
                    var reader = wsClient.ExecuteNonQuery();
                }
            }
        }       

        public static void UnPropAppliesTo(TestCaseData.AppliesTo appTo)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("delete from t_sts_applies_to where vc_applies_to_uri = '{0}'", appTo.uri);
                var reader = wsClient.ExecuteNonQuery();
            }
        }

        public static void PropBusinessPartnerType(int type, string friendlyName, List<string> claimUris, int requiresCert)
        {
            using (var wsClient = GetSecDBClient())
            {
                if (!CheckBusinessPartnerType(type))
                {
                    wsClient.StoredProc = null; 
                    wsClient.CommandSql = String.Format("insert into t_sts_business_partner_type (i_business_partner_type, vc_friendly_name, b_requirescert) values ({0}, '{1}', {2})", type, friendlyName, requiresCert);
                    var reader = wsClient.ExecuteNonQuery();            
                }                
            }
            
            using (var wsClient = GetSecDBClient())
            {
                foreach (string c in claimUris)
                {                    
                    wsClient.StoredProc = null;
                    if (!CheckBusinessPartnerTypeClaimType(type, c))
                    {
                        wsClient.CommandSql = String.Format("insert into t_sts_business_partner_type_claim_type (i_business_partner_type, vc_claim_uri) values ({0}, '{1}')", type, c);
                        var reader = wsClient.ExecuteNonQuery();
                    }                    
                }
            }
        }

        public static bool PropClaimProviderBits()
        {
            string approot = Global.XEnv.GetSetting("setup_approot");
            string fileName = "TestClaimProviders.dll";
            string stfFilePath = @".\SuitesData\XSTS\" + fileName;
            

            string[] servers=Global.XEnv.GetServerListByInterface(Interface.xsts);
            List<IPEndPoint> eps = new List<IPEndPoint>();
            foreach (string serv in servers)
            {
                eps.Add(Global.XEnv.GetInterface(Interface.xmgmtsrv, serv));
            }

            bool propped = false;
            foreach (IPEndPoint ipEp in eps)
            {
                string binPath = String.Format("\\\\{0}\\{1}\\xsts\\bin\\", ipEp.Address, approot.Replace(":", "$"));

                if (File.Exists(binPath + fileName))
                {
                    propped = true;
                }
                else
                {
                    try
                    {
                        File.Copy(stfFilePath, binPath + fileName);
                        propped = true;
                    }
                    catch (Exception ex)
                    {
                        Global.RO.Warn("Could not prop Custom claim provider binaries due to exception:" + ex.Message);
                        propped = false;
                        break;
                    }
                }
            }
            return propped;
        }

        public static void PropClaimProvider(string claimProviderId, string friendlyName, string assemblyName, List<CustomClaim> customClaims)
        {
            using (var wsClient = GetSecDBClient())
            {
                if (!CheckClaimProvider(claimProviderId))
                {
                    wsClient.StoredProc = null;
                    wsClient.CommandSql = String.Format("insert into t_sts_claim_provider (uid_claim_provider_id, vc_friendly_name, vc_assembly) values ('{0}', '{1}', '{2}')", claimProviderId, friendlyName, assemblyName);
                    var reader = wsClient.ExecuteNonQuery();
                }
            }

            using (var wsClient = GetSecDBClient())
            {
                foreach (CustomClaim c in customClaims)
                {
                    wsClient.StoredProc = null;
                    wsClient.ClearParameters();
                    if (!CheckClaim(c.claimUri))
                    {
                        wsClient.StoredProc = "p_sts_claim_set";
                        wsClient.AddParameterObject("vc_claim_uri", c.claimUri);
                        wsClient.AddParameterObject("vc_friendly_title", c.friendlyTitle);
                        wsClient.AddParameterObject("vc_friendly_description", c.friendlyDescription);
                        wsClient.AddParameterObject("b_encrypted", c.encrypted);
                        wsClient.AddParameterObject("b_private", c.b_private);
                        wsClient.AddParameterObject("vc_value_type", c.value_type);                        
                        
                        var reader = wsClient.ExecuteNonQuery();
                    }
                }
            }
            
            using (var wsClient = GetSecDBClient())
            {
                foreach (CustomClaim c in customClaims)
                {
                    wsClient.StoredProc = null;
                    if (!CheckClaimProviderClaim(c.claimUri))
                    {
                        wsClient.CommandSql = String.Format("insert into t_sts_claim_provider_claim_type (uid_claim_provider_id, vc_claim_uri) values ('{0}', '{1}')", claimProviderId, c.claimUri);
                        var reader = wsClient.ExecuteNonQuery();
                    }
                }
            }
        }

        public static void MapClaims(string appliesToUri, List<string> claimUris)
        {
            using (var wsClient = GetSecDBClient())
            {
                foreach (string c in claimUris)
                {
                    if (!CheckClaimMapping(appliesToUri, c, wsClient))
                    {
                        wsClient.StoredProc = null;
                        wsClient.CommandSql = String.Format("insert into t_sts_applies_to_claim values ('{0}', '{1}', 0)", appliesToUri, c);
                        var reader = wsClient.ExecuteNonQuery();
                    }
                }
            }
        }

        public static void UnMapClaims(string appliesToUri, List<string> claimUris)
        {
            using (var wsClient = GetSecDBClient())
            {
                foreach (string c in claimUris)
                {
                    wsClient.StoredProc = null;
                    wsClient.CommandSql = String.Format("delete from t_sts_applies_to_claim where vc_applies_to_uri = '{0}' and vc_claim_uri = '{1}'", appliesToUri, c);
                    var reader = wsClient.ExecuteNonQuery();
                }
            }
        }

        public static bool CheckBusinessPartner(string partnerId)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_business_partner where uid_business_partner_id = '{0}'", partnerId);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }

        public static bool CheckClaimProvider(string providerId)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_claim_provider where uid_claim_provider_id = '{0}'", providerId);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }

        public static bool CheckClaim(string claimUri)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_claim where vc_claim_uri = '{0}'", claimUri);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }
        
        public static bool CheckClaimProviderClaim(string claimUri)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_claim_provider_claim_type where vc_claim_uri = '{0}'", claimUri);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }

        public static bool CheckBusinessPartnerType(int type)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_business_partner_type where i_business_partner_type = {0}", type);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }

        public static bool CheckBusinessPartnerTypeClaimType(int type, string claimUri)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_business_partner_type_claim_type where i_business_partner_type = {0} and vc_claim_uri = '{1}'", type, claimUri);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }
        }

        public static bool CheckAppliesTo(TestCaseData.AppliesTo appTo)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_applies_to where vc_applies_to_uri = '{0}' and vc_applies_to_cert = '{1}' and t_validity_interval = '{2}' and uid_business_partner_id = '{3}' and vc_token_type_uri = '{4}'", appTo.uri, appTo.cert, appTo.validityInterval, appTo.businessPartnerId, appTo.tokenType);
                var reader = wsClient.Execute();

                return reader.HasRows;
            }

        }

        public static bool CheckClaimMapping(string appliesToUri, string claimUri, WSClient wsClient)
        {
            wsClient.StoredProc = null;
            wsClient.CommandSql = String.Format("select * from t_sts_applies_to_claim where vc_applies_to_uri = '{0}' and vc_claim_uri = '{1}'", appliesToUri, claimUri);

            using (var reader = wsClient.Execute())
            {
                return reader.HasRows;
            }
        }

        public static void SetBusinessPartnerConnectionPolicy(Guid businessPartnerId, String policyKey)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                var cmd = npdb.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "[dbo].[p_activeauth_business_partner_connection_policy_set]";

                cmd.Parameters.AddWithValue("uid_business_partner_id", businessPartnerId);
                cmd.Parameters.AddWithValue("vc_policy_key", policyKey);

                cmd.ExecuteNonQuery();
            }

            //StaticNpdb.ExecuteNonQuery(
            //    String.Format(
            //        "insert into t_activeauth_business_partner_connection_policy (uid_business_partner_id, vc_policy_key) values ('{0}', '{1}')",
            //        businessPartnerId,
            //        policyKey));
        }

        public static void ClearBusinessPartnerConnectionPolicy(Guid businessPartnerId)
        {
            StaticNpdb.ExecuteNonQuery(String.Format("delete from t_activeauth_business_partner_connection_policy where uid_business_partner_id = '{0}'", businessPartnerId));
        }

        public static string CreateDelegationTokenAppTo(Guid businessPartnerId)
        {
            string appTo = "http://" + RandomEx.GlobalRandGen.GenerateHexString(8) + "/"; //Hex is a good URL why not.
            TestCaseData.AppliesTo clientCertAppTo = new TestCaseData.AppliesTo()
            {
                businessPartnerId = businessPartnerId.ToString(),
                cert = "",
                validityMinutes = 240,
                validityInterval = "04:00:00",
                tokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Saml2TokenProfile11,
                uri = appTo
            };
            Util.PropAppliesTo(clientCertAppTo);
            Util.MapClaims(clientCertAppTo.uri, new List<string>(new string[] { AuthClaimTypes.DelegationToken }));
            Util.CallXmgmt("reload");
            Util.LoadXSTSConfiguration();

            return appTo;
        }

        public static void RemoveDelegationTokenAppTo(Guid businessPartnerId, string appTo)
        {
            TestCaseData.AppliesTo clientCertAppTo = new TestCaseData.AppliesTo()
            {
                businessPartnerId = businessPartnerId.ToString(),
                cert = "",
                validityMinutes = 240,
                validityInterval = "04:00:00",
                tokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.Saml2TokenProfile11,
                uri = appTo
            };
            Util.UnMapClaims(clientCertAppTo.uri, new List<string>(new string[] { AuthClaimTypes.DelegationToken }));
            Util.UnPropAppliesTo(clientCertAppTo);
        }

        public static Guid CreateBusinessPartner()
        {
            X509Certificate2 cert = null;
            return CreateBusinessPartner(ref cert);
        }

        public static X509Certificate2 CreateCert(Guid businessPartnerId)
        {
            String cn = String.Format("AASGPartnerCert_{0}_{1}", businessPartnerId, Guid.NewGuid());
            CertificateGenerator generator = new CertificateGenerator("CN=" + cn);

            // Chain the certificates up to our test root CA that is in the Cert Trust List
            return generator.Generate(cn, @".\SuitesData\XSTS\int-net.xboxlive.com.pfx");
        }

        public static Guid CreateBusinessPartner(ref X509Certificate2 partnerCert)
        {
            Guid businessPartnerId = Guid.NewGuid();

            if (partnerCert == null)
            {
                partnerCert = CreateCert(businessPartnerId);
            }

            return CreateBusinessPartner(businessPartnerId, partnerCert);
        }

        public static Guid CreateBusinessPartner(Guid businessPartnerId, X509Certificate2 partnerCert)
        {
            String certString = Convert.ToBase64String(partnerCert.GetRawCertData());

            StringBuilder sql = new StringBuilder();

            sql.AppendFormat("insert into t_sts_business_partner (uid_business_partner_id, vc_friendly_name, vc_anonymizing_salt, b_private) values('{0}', 'TestBusinessPartner_{0}', '{1}', '')\n", businessPartnerId, RandomEx.GlobalRandGen.GenerateRandomString(8));
            sql.AppendFormat("insert into t_sts_business_partner_connection_info (uid_business_partner_id, vc_friendly_name, vc_partner_sg_cert) values ('{0}', 'BusinessPartnerConnectionInfo_{0} Cert Subject:{1}', '{2}')\n", businessPartnerId, partnerCert.Subject, certString);

            using (WSClient secdb = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                secdb.CommandSql = sql.ToString();
                secdb.ExecuteNonQuery();
            }

            return businessPartnerId;
        }

        public static void RemoveBusinessPartner(Guid businessPartnerId)
        {
            ClearBusinessPartnerConnectionPolicy(businessPartnerId);

            StringBuilder sql = new StringBuilder();
            sql.AppendFormat("delete from t_sts_business_partner_connection_info where uid_business_partner_id = '{0}'", businessPartnerId);
            sql.AppendFormat("delete from t_sts_business_partner where uid_business_partner_id = '{0}'", businessPartnerId);

            using (WSClient secdb = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                secdb.CommandSql = sql.ToString();
                secdb.ExecuteNonQuery();
            }
        }

        public static void RemoveBusinessPartnerCert(Guid businessPartnerId, X509Certificate2 partnerCert)
        {
            StringBuilder sql = new StringBuilder();
            String certString = Convert.ToBase64String(partnerCert.GetRawCertData());

            sql.AppendFormat("delete from t_sts_business_partner_connection_info where uid_business_partner_id = '{0}' and vc_friendly_name = 'BusinessPartnerConnectionInfo_{0} Cert Subject:{1}' and vc_partner_sg_cert = '{2}'", businessPartnerId, partnerCert.Subject, certString);

            using (WSClient secdb = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                secdb.CommandSql = sql.ToString();
                secdb.ExecuteNonQuery();
            }
        }

        public static void AddBusinessPartnerCert(Guid businessPartnerId, X509Certificate2 partnerCert)
        {
            String certString = Convert.ToBase64String(partnerCert.GetRawCertData());

            StringBuilder sql = new StringBuilder();

            sql.AppendFormat("insert into t_sts_business_partner_connection_info (uid_business_partner_id, vc_friendly_name, vc_partner_sg_cert) values ('{0}', 'BusinessPartnerConnectionInfo_{0} Cert Subject:{1}', '{2}')\n", businessPartnerId, partnerCert.Subject, certString);

            using (WSClient secdb = new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                secdb.CommandSql = sql.ToString();
                secdb.ExecuteNonQuery();
            }
        }

        internal static WSClient GetSecDBClient()
        {
            return new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
        }

        public static int GetTrustedClaimCount(string appliesToUri)
        {
            using (var wsClient = GetSecDBClient())
            {
                wsClient.StoredProc = null;
                wsClient.CommandSql = String.Format("select * from t_sts_applies_to_claim where vc_applies_to_uri = '{0}'", appliesToUri);

                using (var reader = wsClient.Execute())
                {
                    int rows = 0;
                    while (reader.Read() == true)
                        rows++;
                    return rows;
                }
            }
        }
        #endregion DB helpers

        #region DBLimiter helpers
        private static List<KdcUser> saturationUsersUodb;
        private static void PrepareSaturationUsersUodb()
        {
            int partitionCount = GetPhysicalUodbPartitionCount();

            if (saturationUsersUodb == null)
            {
                Global.RO.Info("Creating a set of users evently distributed accross all " + partitionCount + " UODB partitions.");
                List<KdcUser> newUsers = new List<KdcUser>();
                ResizeList(newUsers, partitionCount);
                while (true)
                {
                    //if all partitions have a user we're done
                    bool anyPartitionMissing = false;
                    for (int i = 0; i < partitionCount; ++i)
                    {
                        if (newUsers[i] == null)
                        {
                            anyPartitionMissing = true;
                            break;
                        }
                    }

                    if (!anyPartitionMissing)
                    {
                        break;
                    }

                    //make a new user and see if they landed on an empty slot
                    KdcUser newUser = new KdcUser();
                    newUser.CreateUser(false);

                    int newUserPartition = GetPhysicalUodbPartitionForUser(newUser.UserID);

                    if (newUsers[newUserPartition] == null)
                    {
                        newUsers[newUserPartition] = newUser;
                    }
                }
                saturationUsersUodb = newUsers;

                for (int i = 0; i < partitionCount; ++i)
                {
                    Global.RO.Debug("SaturationUser[" + i + "](" + saturationUsersUodb[i].Gamertag + string.Format(", 0x{0:X}", saturationUsersUodb[i].UserID) + ") is on physical partition " + GetPhysicalUodbPartitionForUser(saturationUsersUodb[i].UserID));
                }

                System.Threading.Thread.Sleep(6000); //we want to make sure these users are in xcache. I hate xcache delays.
            }
        }
        public static void SaturateUodbPartitions(params int[] partitionsToSaturate)
        {            
            int partitionCount = GetPhysicalUodbPartitionCount();

            PrepareSaturationUsersUodb();

            if (partitionsToSaturate == null)
            {
                partitionsToSaturate = new Int32[partitionCount];
                for (int i = 0; i < partitionsToSaturate.Length; ++i)
                {
                    partitionsToSaturate[i] = i;
                }
            }

            XSTSTokenRequestor[] clients = new XSTSTokenRequestor[partitionCount];            
            
            
            foreach (Int32 partition in partitionsToSaturate)
            {
                Global.RO.Info("Saturating UODB partition " + partition + ".");

                clients[partition] = new XSTSTokenRequestor();
                clients[partition].ServicesToUse = SecurityTokenServices.XSTS;
                clients[partition].SetUser(0, saturationUsersUodb[partition]);
                clients[partition].TryCallRPService = false;
                clients[partition].RSTGen = CreateDefaultRST();
                clients[partition].RSTGen.TokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11;
                clients[partition].RSTGen.AppliesTo = new System.ServiceModel.EndpointAddress(new System.Uri(AUTHSG_URL));                
            }

            SendAsyncXSTSReqs(clients);
        }

        public static void SendAsyncXSTSReqs(XSTSTokenRequestor[] reqs)
        {
            ParameterizedThreadStart[] ts = new ParameterizedThreadStart[reqs.Length];
            for (int k = 0; k < reqs.Length; k++)
            {
                ts[k] = new ParameterizedThreadStart(SendAsyncXSTSReq);
            }

            for (int k = 0; k < reqs.Length; k++)
            {
                ts[k].Invoke(reqs[k]);
            }
        }

        private static void SendAsyncXSTSReq(object reqObj)
        {
            XSTSTokenRequestor req= (XSTSTokenRequestor)reqObj;
            req.GetTokenStringFromSTS();
        }

        private static int GetPhysicalUodbPartitionCount()
        {
            return UodbWS.WstPhysicalPartitionCount();
        }
        private static int GetPhysicalUodbPartitionForUser(ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                return ws.GetPhysicalPartition(ws.Partition);
            }
        }
        //Some Luke wtf sprinkled here
        private static void ResizeList<T>(List<T> list, int count)
        {
            if (list.Count < count)
            {
                list.Capacity = count;
            }

            while (list.Count < count)
            {
                list.Add(default(T));
            }

            while (list.Count > count)
            {
                list.RemoveAt(list.Count - 1);
            }
        }
        public static void ResetDBLimiterState()
        {
            saturationUsersUodb = null;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\GamertagHistoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;
using xonline.common.mgmt;
using CORE = xonline.core.history;

namespace xonline.xuser.service
{
    public static class GamertagHistoryExtension
    {
        #region ReadData
        public static void ReadDetail(this GamertagHistoryDetails gthd, WstDataReader reader)
        {
            if (gthd != null)
            {
                gthd.UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                gthd.MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? (Puid?)null : WSClient.GetPuid(reader, "bi_machine_puid");
                gthd.IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                gthd.Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                gthd.HResult = WSClient.GetHResult(reader, "i_hr");
                gthd.Reason = WSClient.GetByte(reader, "ti_reason");

                gthd.OldGamertag = WSClient.IsDBNull(reader, "vc_old_gamertag") ? null : WSClient.GetString(reader, "vc_old_gamertag");
                gthd.NewGamertag = WSClient.IsDBNull(reader, "vc_new_gamertag") ? null : WSClient.GetString(reader, "vc_new_gamertag");

                gthd.InitDetails();
            }
        }

        public static GamertagHistory Read(this GamertagHistory gth, WstDataReader reader, bool details)
        {
            if (gth != null)
            {
                if (!reader.Read())
                {
                    throw new XRLException(
                            HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                            XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                            "Error reading history summary information"
                        );
                }

                gth.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                gth.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                gth.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                gth.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                if (details && reader.NextResult())
                {
                    int i = 0;
                    gth.Details = new GamertagHistoryDetails[gth.Total];

                    while (reader.Read())
                    {
                        gth.Details[i] = new GamertagHistoryDetails();

                        gth.Details[i++].ReadDetail(reader);
                    }
                }
            }
           return gth;
        }

        #endregion

        #region LogData
        public static void LogDetail(this GamertagHistoryDetails gthd, HistoryParams historyParams, string databaseName)
        {
            if (gthd != null)
            {
                Puid hashVal = (Puid)gthd.UserPuid;

                using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // parameterized stored procedures  and  hashes
                    // allow writes to different  tables/partitions

                    ws.StoredProc = historyParams.StoredProc;
                    ws.SetHashVal(hashVal);

                    // add all of the standard fields to the record

                    ws.AddParameter("bi_user_puid", gthd.UserPuid);
                    ws.AddParameter("dt_timestamp", gthd.Timestamp);
                    ws.AddParameter("i_hr", gthd.HResult);
                    ws.AddParameter("ti_reason", (byte)gthd.Reason);

                    // some common fields can be null.  check  that

                    if (gthd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)gthd.MachinePuid);
                    if (gthd.IpAddress != null) ws.AddParameter("vc_ip_address", gthd.IpAddress);
                    ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));
                    if (historyParams.UseHash) ws.AddParameter("si_hash_bucket", ws.Partition);

                    // finally we add the operation specific params
                    // for particular operational details we record

                    GamertagHistoryExtension.AddParams(gthd, ws);

                    // add return value to receive the return value

                    HResult hr = HResult.S_OK;
                    ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                    // execute and convert result set into  history
                    // summary used to test  configured  thresholds

                    try
                    {
                        using (WstDataReader reader = ws.Execute())
                        {
                            if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                                );
                            }

                        }
                    }
                    catch (Exception e)
                    {
                        if (e.InnerException is SqlException)
                        {
                            SqlException sqlExcept = (SqlException)e.InnerException;

                            if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                    "Existing log record found"
                                );
                            }
                        }
                    }
                }
            }
        }

        public static void Log(this GamertagHistoryDetails gthd)
        {
            HResult hr = HResult.S_OK;

            if (gthd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    gthd.Timestamp.ToString()
                    );
            }

            if ((gthd.NewGamertag == null) && (gthd.OldGamertag == null))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewGamertag and OldGamertag cannot be null"
                    );
            }

            if (gthd.OldGamertag == gthd.NewGamertag)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewGamertag and OldGamertag cannot be equal {0}|{1}",
                    gthd.OldGamertag,
                    gthd.NewGamertag
                    );
            }

            if (((gthd.NewGamertag != null) && (gthd.NewGamertag.Length > 16)) || ((gthd.OldGamertag != null) && (gthd.OldGamertag.Length > 16)))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Gamertag too long, max length is 16 bytes long: {0}|{1}",
                    gthd.NewGamertag, gthd.OldGamertag
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)gthd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    gthd.Reason
                    );
            }

            if (gthd.MachinePuid.HasValue == false)
            {
                //because the data contract has the machine puid as IsRequired
                //we cannot leave this null or it crashes inside soap
                //but null is a valid value
                gthd.MachinePuid = 0;
            }
            else if (XOn.XboxId.IsMachinePuid((UInt64)gthd.MachinePuid) == false)
            {
                if (XOn.XboxId.IsXboxcomMachinePuid((UInt64)gthd.MachinePuid))
                {
                    //received an xbox.com machine puid, we then just use the zero'd out puid.
                    gthd.MachinePuid = XOn.XboxId.XboxComMachineBase;
                }
                else
                {
                    throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    gthd.MachinePuid
                    );
                }
            }

            try
            {
                User validateUser = new User(gthd.UserPuid);

                if (string.IsNullOrEmpty(validateUser.Gamertag))
                {
                    //we did not find the machine puid, it is not valid
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "UserPuid is invalid: {0}",
                        gthd.UserPuid
                        );
                }
            }
            catch (Exception e)
            {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId)
                {
                    Logging.NtEvent((ExceptionWithEventId)e, "Error validating user '{0}'", (Puid)gthd.UserPuid);
                }

                throw;
            }

            
            LogDetail(gthd, _userParams, ConfigUtil.SecUserHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
            {
                LogDetail(gthd, _userParamsUODB, ConfigUtil.UodbWebstoreApp);
            }

        }
        #endregion

        private static void AddParams(this GamertagHistoryDetails gthd, WSClient ws)
        {
            if (gthd != null)
            {
                if (gthd.OldGamertag != null) ws.AddParameter("vc_old_gamertag", gthd.OldGamertag);
                if (gthd.NewGamertag != null) ws.AddParameter("vc_new_gamertag", gthd.NewGamertag);
            }
        }

        private static HistoryParams _userParams = new HistoryParams(
            "p_xuser_user_gamertag_history_add",
            Setting.xuacs_userGamertagThreshold,
            Setting.xuacs_userGamertagIntervalDays,
            XEvent.Id.ACCOUNTS_USER_GAMERTAG_THRESHOLD_EXCEEDED,
            "User {0} exceeded gamertag change threshold of {1} unique machines in {2} days",
            (byte)CORE.HistoryReason.PurchaseGamertag
        );

        private static HistoryParams _userParamsUODB = new HistoryParams(
            "p_xuacs_user_gamertag_history_add",
            Setting.xuacs_userGamertagThreshold,
            Setting.xuacs_userGamertagIntervalDays,
            XEvent.Id.ACCOUNTS_USER_GAMERTAG_THRESHOLD_EXCEEDED,
            "User {0} exceeded gamertag change threshold of {1} unique machines in {2} days",
            false,
            (byte)CORE.HistoryReason.PurchaseGamertag
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\Health.cs ===
using System;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

using xonline.common.health;

namespace xonline.xuser.service
{

    public class XUserHealthRequest : BaseHealthRequest
    {
       public override void ProcessRequest( HttpContext ctx )
       {
           if (!IsHealthInitialized)
           {
             Management.Init();

             IsHealthInitialized = true;
           }

           base.ProcessRequest( ctx );

       }
      
       private bool IsHealthInitialized = false;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\ErrorHandler.cs ===
using System;
using System.Collections.ObjectModel;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;

using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.xuser.service
{
    public class ErrorHandler : IServiceBehavior, IErrorHandler
    {
        public ErrorHandler()
        {
        }

        public void AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            IErrorHandler errorHandler = new ErrorHandler();

            foreach (ChannelDispatcherBase channelDispatcherBase in serviceHostBase.ChannelDispatchers)
            {
                ChannelDispatcher channelDispatcher = channelDispatcherBase as ChannelDispatcher;
                channelDispatcher.ErrorHandlers.Add(errorHandler);
            }
        }

        public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
        }

        public bool HandleError(Exception e)
        {
            return true;
        }

        public void ProvideFault(Exception e, MessageVersion version, ref Message fault)
        {
            WebOperationContext webOperationContext = WebOperationContext.Current;

            if (webOperationContext != null)
            {
                HResult hr = XblException.GetHResult(e);
                webOperationContext.OutgoingResponse.Headers.Add("X-Err", hr.ToString());
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\HeuristicExtensions.cs ===
using System;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;
using xonline.common.mgmt;

namespace xonline.xuser.service
{
    public static class HeuristicExtensions
    {
        #region HeuristicChecks
        public static void ThresholdCheck(this Puid hashVal, HistoryParams historyParams, HistorySummary historySummary)
        {
            if (historySummary.Unique > historyParams.Threshold)
            {
                string message = string.Format(historyParams.Message, hashVal, historyParams.Threshold, historyParams.Interval);
                Xom.NtEvent(historyParams.EventId, message);
            }
        }

        public static void HijackingCheck(this HistorySummary hs, HistoryDetails hd)
        {
            // check to see if we are enabled to check  for
            // hijacking attempts. if not then just get out

            int hijackingIntervalHours = Config.GetIntSetting(Setting.xuacs_hijackingIntervalHours);
            if (hijackingIntervalHours <= 0) return;

            DateTime since = DateTime.UtcNow.AddHours(-hijackingIntervalHours);
            UserHistory userHistory = new UserHistory(hd.UserPuid, since, true);
            if (userHistory == null) return;

            HistoryEvent historyEvent = userHistory.Check();
            if (historyEvent != null) historyEvent.Log();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\GamertagHistoryGetByUserPuid.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
//using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// GamertagHistoryGet, for the specified user, 
        /// get the history </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="machinePuid">Machine puid</param>
        /// <param name="since">history since a given date and time</param>
        /// <returns>returns zero or records matching the specified criteria</returns>
        public GamertagHistory GamertagHistoryGetByUserPuid(
            ulong  userPuid, 
            ulong? machinePuid,
            DateTime? since, 
            bool details
            )
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try 
            {
                if (userPuid == 0) 
                {
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid: {0}", (Puid) userPuid);
                }

                //We should pull from SecUserHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecUserHistoryWebstoreApp;
                string storedProcedureName = "p_xuser_user_gamertag_history_get";

                if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_user_gamertag_history_get";
                }

                //GetByUserPuid
                Puid? tempMachinePuid = machinePuid.HasValue ? (Puid)machinePuid : (Puid?)null;
                return GetGamertagByUserPuid(databaseName, storedProcedureName, (Puid)userPuid, tempMachinePuid, since, details);

            }
            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally
            {
                Logging.Log(string.Format(
                    "GamertagHistoryGet|{0}|{1}|{2}|{3}",
                    hr, 
                    (Puid) userPuid,
					machinePuid == null ? "<none>" : machinePuid.ToString(),
                    since.HasValue       ? since.ToString()                : string.Empty
                ));
            }
        }

        private static GamertagHistory GetGamertagHistory(WSClient ws, DateTime? since, bool details)
        {
            if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
            ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
            ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

            using (WstDataReader reader = ws.Execute())
            {
                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (hr.IsSuccess())
                {
                    return GamertagHistoryExtension.Read(new GamertagHistory(), reader, details);
                }
                else
                    return null;
            }
        }

        private static GamertagHistory GetGamertagByUserPuid(string databaseName, string storedProcedureName, Puid userPuid, Puid? machinePuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = storedProcedureName;
                ws.AddParameter("@bi_user_puid", userPuid);

                if (machinePuid != null) ws.AddParameter("@bi_machine_puid", (Puid)machinePuid);
                return GetGamertagHistory(ws, since, details);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\GamertagHistoryLog.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;  
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        public void GamertagHistoryLog(GamertagHistoryDetails gthd)
        {
            try
            {
                if (gthd == null)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Null parameter: GamertagHistoryDetails"
                        );
                }

                GamertagHistoryExtension.Log(gthd);
            }
            catch (Exception e)
            {
                if (gthd != null)
                {
                    Logging.NtEvent(XEvent.Id.ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR, e,
                       "Error in gamertaglog for user {0} on machine {1}",
                       gthd.UserPuid, gthd.MachinePuid == null ? "<None>" : gthd.MachinePuid.ToString());
                }

                throw;
            }
            finally
            {
                if (gthd != null)
                {
                    Logging.Log(string.Format(
                        "GamertagHistoryLog|{0}|{1}|{2}|{3}",
                        (Puid)gthd.UserPuid, (Puid)(gthd.MachinePuid ?? 0), gthd.NewGamertag ?? string.Empty, gthd.OldGamertag ?? string.Empty
                    ));
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\HistoryEvent.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using xonline.common.service;
using xonline.common.mgmt;
using CORE = xonline.core.history;

using xonline.xuser.contract;

namespace xonline.xuser.service
{
    public class HistoryEvent
    {
        private XEvent.Id _eventId;
        private Puid      _userPuid;

        private HistoryDetails[] _userHistoryDetails;
        private Dictionary<Puid?, UserMachineHistoryDetails> _machineHistoryDetails;

        public HistoryEvent(
            XEvent.Id                                   eventId,
            Puid                                        userPuid,
            HistoryDetails[]                            userHistoryDetails,
            Dictionary<Puid?, UserMachineHistoryDetails> machineHistoryDetails
        )
        {
            _eventId               = eventId;
            _userPuid              = userPuid;
            _userHistoryDetails    = userHistoryDetails;
            _machineHistoryDetails = machineHistoryDetails;
        }

        public XEvent.Id EventId {
            get { return _eventId; }
        }

        public Puid UserPuid {
            get { return _userPuid; }
        }

        public Puid? MachinePuid {
            get {
                return _userHistoryDetails[0].MachinePuid;
            }
        }

        public DateTime Timestamp {
            get {
                if (_userHistoryDetails == null) return new DateTime(2002, 11, 22);
                return _userHistoryDetails[_userHistoryDetails.Length - 1].Timestamp;
            }
        }

        public int DaysSeen {
            get {
                int daysSeen = int.MaxValue;

                foreach (HistoryDetails userHistoryDetail in _userHistoryDetails) {
                    ulong machinePuid = (ulong)(userHistoryDetail.MachinePuid ?? 0);
                    int currentDaysSeen = _machineHistoryDetails.ContainsKey(machinePuid) ? _machineHistoryDetails[machinePuid].DaysSeenBefore(userHistoryDetail.Timestamp) : 0;
                    if (currentDaysSeen < daysSeen) daysSeen = currentDaysSeen;
                }

                return daysSeen;
            }
        }

        public void Log()
        {
            Xom.NtEvent(_eventId, ToString());
        }


        public override string ToString()
        {
            string eventString;
            StringBuilder stringBuilder = new StringBuilder();

            switch (_eventId) {
                case XEvent.Id.ACCOUNTS_HIJACKING_WARNING: eventString = "Possible hijacking of"; break;
                case XEvent.Id.ACCOUNTS_HIJACKING_ERROR:   eventString = "Probable hijacking of"; break;
                default:                                   eventString = "Unknown event for";     break;
            }

            stringBuilder.AppendFormat("{0} userPuid {1}, {2} record(s) follow", eventString, _userPuid, _userHistoryDetails.Length);
            stringBuilder.AppendLine();

            foreach (HistoryDetails historyDetail in _userHistoryDetails)
            {
                string ipAddress = historyDetail.IpAddress ?? "             ";
                Puid machinePuid = (Puid) (historyDetail.MachinePuid ?? 0);

                int daysSeen = _machineHistoryDetails.ContainsKey(machinePuid) ?
                    _machineHistoryDetails[machinePuid].DaysSeenBefore(historyDetail.Timestamp) : 0;

                switch ((CORE.HistoryReason)historyDetail.Reason)
                {
                    case CORE.HistoryReason.RecoverAccount:         eventString = "Recovery"; break;
                    case CORE.HistoryReason.PurchaseGamertag:       eventString = "Gamertag"; break;
                    case CORE.HistoryReason.SwitchUserPassport:     eventString = "Passport"; break;
                    case CORE.HistoryReason.PassportChangePassword: eventString = "Password"; break;
                    default:                                        eventString = "Unknown "; break;
                }

                stringBuilder.AppendFormat(
                    "    {0} : {1}, machinePuid {2}, ipAddress {3}, daysSeen {4}",
                    historyDetail.Timestamp.ToString("yyyy/MM/dd HH:mm:ss.fff"),
                    eventString, machinePuid, ipAddress, daysSeen
                );

                stringBuilder.AppendLine();
            }

            return stringBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\GamertagHistoryGetByGamertag.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
//using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// GamertagHistoryGetByGamertag, for the specified user by a specified gamertag, 
        /// get the history </summary>
        /// <param name="gamertag">gamertag name</param>
        /// <param name="since">history since a given date and time</param>
        /// <returns>returns zero or records matching the specified criteria</returns>
        public GamertagHistory GamertagHistoryGetByGamertag(
            string gamertag, 
            DateTime? since, 
            bool details
            )
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            if (String.IsNullOrEmpty(gamertag))
            {
                throw new XRLExceptionWithoutEvent(
                   HResult.XONLINE_E_INVALID_REQUEST,
                   "Gamertag cannot be null or empty"
                   );
            }

            if (gamertag.Length > 16)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Gamertag too long, max length is 16 bytes long: {0}",
                    gamertag
                    );
            }

            try 
            {
                //We should pull from SecUserHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecUserHistoryWebstoreApp;
                string storedProcedureName = "p_xuser_user_gamertag_history_get";

                if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_user_gamertag_history_get";
                }

                //GetByGamertag
      
                storedProcedureName = "p_xuser_gamertag_history_get";

                if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
                {
                   storedProcedureName = "p_xuacs_gamertag_history_get";
                }
                return GetByGamertag(databaseName, storedProcedureName, gamertag, since, details);


            }
            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally
            {
                Logging.Log(string.Format(
                    "GamertagHistoryGet|{0}|{1}|{2}",
                    hr,
                    gamertag != null ? gamertag                            : string.Empty,
                    since.HasValue       ? since.ToString()                : string.Empty
                ));
            }
        }

        private static GamertagHistory GetByGamertag(string databaseName, string storedProcedureName, string gamertag, DateTime? since, bool details)
        {
            SortedList<DateTime, GamertagHistoryDetails> gamertagHistoryList = new SortedList<DateTime, GamertagHistoryDetails>();

            using (WstConnection connection = new WstConnection(databaseName))
            {
                connection.Open();

                for (int i = 0; i < connection.SqlPartitions.Count; i++)
                {
                    using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        ws.StoredProc = storedProcedureName; 
                        ws.PhysicalPartition = i;

                        ws.AddParameter("@vc_gamertag", gamertag);
                        if (since != null) ws.AddParameter("@dt_since", (DateTime)since);
                        ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                        using (WstDataReader reader = ws.Execute())
                        {
                            HResult hr = (uint)ws.GetIntParameter("@hr");
                            if (hr.IsFailure()) throw new XblException(hr, "Error getting history for gamertag '{0}'", gamertag);

                            // the data is strewn across multiple partitions, we need
                            // to sort the history details based on  their  timestamp

                            while (reader.Read())
                            {
                                GamertagHistoryDetails gamertagHistoryDetail = new GamertagHistoryDetails();
                                gamertagHistoryDetail.ReadDetail(reader);
                                gamertagHistoryList.Add(gamertagHistoryDetail.Timestamp, gamertagHistoryDetail);
                            }
                        }
                    }
                }
            }

            // now take all the details from all the partitions and create
            // a proper gamertag history object with all of those  details

            GamertagHistoryDetails[] gamertagHistoryDetails = new GamertagHistoryDetails[gamertagHistoryList.Count];
            gamertagHistoryList.Values.CopyTo(gamertagHistoryDetails, 0);
            GamertagHistory gth = new GamertagHistory(gamertagHistoryDetails);
            if (details)
            {
                gth.Details = gamertagHistoryDetails;
            }
            return gth;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\Counters.cs ===
﻿using System;
using System.Diagnostics;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Dispatcher;

using xonline.common.mgmt;
using xonline.common.exceptions;
using xonline.common.service;

namespace xonline.xuser.service
{
    public class CounterInvoker : IOperationInvoker
    {
        private IOperationInvoker _innerInvoker;
        private Counter _counter;

        public CounterInvoker(IOperationInvoker innerInvoker, Counter counter)
        {
            _innerInvoker = innerInvoker;
            _counter      = counter;
        }

        public object[] AllocateInputs() {
            return _innerInvoker.AllocateInputs();
        }

        public object Invoke(object instance, object[] inputs, out object[] outputs)
        {
            HResult hr = HResult.S_OK;
            XomRequestTimeElapsed elapsedTime = _counter.Start();
  
            try {
                return _innerInvoker.Invoke(instance, inputs, out outputs);
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally {
                _counter.End(elapsedTime.TimeElapsed * 1000, hr);
            }
        }

        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state) {
            return _innerInvoker.InvokeBegin(instance, inputs, callback, state);
        }


        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result) {
            return _innerInvoker.InvokeEnd(instance, out outputs, result);
        }

        public bool IsSynchronous {
            get { return _innerInvoker.IsSynchronous; }
        }
    }

    public class CounterOperationBehavior : IOperationBehavior
    {
        private string _counterName;

        public CounterOperationBehavior(string counterName) {
            _counterName = counterName;
        }

        public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters) {
            return;
        }

        public void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation) {
            throw new NotImplementedException();
        }

        public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation)
        {
            dispatchOperation.Invoker = new CounterInvoker(
                dispatchOperation.Invoker, Counter.Counters[_counterName]
            );
        }

        public void Validate(OperationDescription operationDescription) {
            return;
        }
    }
    
    public class CounterServiceBehavior : IServiceBehavior
    {
        public void  AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) {
 	        return;
        }

        public void  ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            XomPerformanceCounterCategory.InitPerfCtrs();

            foreach (ServiceEndpoint endpoint in serviceDescription.Endpoints)
            {
                foreach (OperationDescription operation in endpoint.Contract.Operations) {
                    if (! operation.Behaviors.Contains(typeof(CounterOperationBehavior))) {
                        string counterName = endpoint.Address.Uri.AbsolutePath + "/" + operation.SyncMethod.Name;
                        operation.Behaviors.Add(new CounterOperationBehavior(Counter.GetInstanceName(counterName)));
                    }
                }
            }
        }

        public void  Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) {
 	        return;
        }
    }
    

    [XomComponentPerformanceCounterCategoryAttr( "XRL" , "Xbox Live Common Per-XRL Counters" )]
    public class Counter : XomPerformanceCounterCategory
    {
        // Publicly visible static instance
        static public Counter Counters = new Counter();

        // Public visible getter
        public Counter this[string instance] {
            get {
                return (Counter) GetInstance(instance);
            }
        }

        public XomRequestTimeElapsed Start()
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            RequestsInProgress.Increment();
            Counters.RequestsInProgress.Increment();

            return timeElapsed;
        }

        public void End(long timeElapsed, HResult hr) 
        {
            RequestsInProgress.Decrement();
            TotalRequests.Increment();
            RequestsPerSec.Increment();
            FailuresPercentageBase.Increment();
            AverageExecutionTime.IncrementBy(timeElapsed);
            AverageExecutionTimeBase.Increment();

            // if there was a failure then  count  that

            if (hr.IsFailure()) {
                FailuresPerSecond.Increment();
                FailuresTotal.Increment();
                FailuresPercentage.Increment();
            }

            // if we are not counting the _total counter
            // then recurse (sort of) and count that too

            if (Counters != this) Counters.End(timeElapsed, hr);
        }


        public static string GetInstanceName(string s)
        {
            // 1. "/" are bad in instance names
            // 2. instance must be <= 127 chars
            // 3. query strings are bad in instance names
            string instanceName = s.Replace('/', '\\');

            if (instanceName.Length > 127) {
                instanceName = instanceName.Substring(0, 127);
            }

            return instanceName;
        }


        [XomPerformanceCounterAttr("Requests, Total", "Total number of requests", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr("Requests, In Progress", "Number of requests in progress", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgress;
        
        [XomPerformanceCounterAttr("Requests, Per Sec", "Number of requests completed per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSec;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time (in ms)", "Average request execution time in the current AppDomain (in ms)", PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time Base", "Base for the average request execution time in the current AppDomain", PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        [XomPerformanceCounterAttr("Failures, Per Sec", "Number of failures per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr("Failures, Total", "Total number of failures", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr("Failures, Percentage", "Request failure percentage", PerformanceCounterType.SampleFraction)]
        public PerformanceCounter FailuresPercentage;

        [XomPerformanceCounterAttr("Failures, Percentage Base", "Base for the request failure percentage", PerformanceCounterType.SampleBase)]
        public PerformanceCounter FailuresPercentageBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\HistoryParams.cs ===
using xonline.common.config;
using xonline.common.service;

using xonline.xuser.contract;

namespace xonline.xuser.service
{
    public class HistoryParams
    {
        private string          _storedProc;
        private string          _thresholdSetting;
        private string          _intervalSetting;
        private XEvent.Id       _eventId;
        private string          _message;
        private byte[]          _reasons;
        public bool             _useHash;

        public HistoryParams(string storedProc, string thresholdSetting, string intervalSetting, XEvent.Id eventId, string message, params byte[] reasons)
        {
            _storedProc       = storedProc;
            _thresholdSetting = thresholdSetting;
            _intervalSetting  = intervalSetting;
            _eventId          = eventId;
            _message          = message;
            _reasons          = reasons;
            _useHash          = true;
        }

        public HistoryParams(string storedProc, string thresholdSetting, string intervalSetting, XEvent.Id eventId, string message, bool useHash, params byte[] reasons)
        {
            _storedProc = storedProc;
            _thresholdSetting = thresholdSetting;
            _intervalSetting = intervalSetting;
            _eventId = eventId;
            _message = message;
            _reasons = reasons;
            _useHash = useHash;
        }

        public string StoredProc       { get { return _storedProc; } }
        public int Threshold           { get { return Config.GetIntSetting(_thresholdSetting); } }
        public int Interval            { get { return Config.GetIntSetting(_intervalSetting); } }
        public XEvent.Id EventId       { get { return _eventId; } }
        public string Message          { get { return _message; } }
        public byte[] Reasons          { get { return _reasons; } }
        public bool UseHash            { get { return _useHash; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\HistoryExtensions.cs ===
using System;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;
using xonline.common.mgmt;

namespace xonline.xuser.service
{
    public static class HistoryExtensions
    {
        public static void Read(this HistorySummary hs, WstDataReader reader, bool readFirst)
        {
            if (readFirst)
            {
                if (!reader.Read())
                {
                    throw new XRLException(
                        HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                        XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                        "Error reading history summary information"
                    );
                }
            }

            hs.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
            hs.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
            hs.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
            hs.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\MachineExtensions.cs ===
using System;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

using xonline.xuser.contract;

namespace xonline.xuser.service
{
    public static class MachineExtensions
    {
        public static void Read(this UserMachine userMachine, WstDataReader reader)
        {
            userMachine.UserPuid     = WSClient.GetUInt64(reader, "bi_user_puid");
            userMachine.MachinePuid  = WSClient.GetUInt64(reader, "bi_machine_puid");
            userMachine.DaysSeen     = WSClient.GetInt32(reader, "i_days_seen");
            userMachine.IpAddress    = WSClient.GetNullableString(reader, "vc_ip_address");
            userMachine.FirstSignIn  = WSClient.GetNullableDateTime(reader, "dt_first_signin");
            userMachine.LastSignIn   = WSClient.GetNullableDateTime(reader, "dt_last_signin");
            userMachine.LastSignOut  = WSClient.GetNullableDateTime(reader, "dt_last_signout");
            userMachine.FriendlyName = WSClient.GetNullableString(reader, "vc_friendly_name");
            userMachine.TrustLevel   = WSClient.GetInt32(reader, "i_trust_level");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\Installer.cs ===
﻿using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.xuser.service
{
    [RunInstaller(true)]
    public class Installer : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class PerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\Logging.cs ===
using System;
using System.Globalization;

using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.xuser.service
{
    internal class Logging
    {

        internal static void Init()
        {
        }

        internal static void NtEvent(ExceptionWithEventId e, string format, params object[] args)
        {
            Xom.NtEvent(((ExceptionWithEventId) e).EventId, (Exception) e, format, args);
        }

        internal static void NtEvent(XEvent.Id eventId, Exception e, string format, params object[] args)
        {
            Xom.NtEvent(eventId, e, format, args);
        }

        internal static void NtEvent(XEvent.Id eventId, string format, params object[] args)
        {
            Xom.NtEvent(eventId, format, args);
        }

        internal static void Log(Exception e)
        {
            Xom.Log(XomAreaName.log, "{0}", e.ToString());
        }
 
        internal static void Log(string logMsg)
        {
            Xom.Log(XomAreaName.log, logMsg);
        }

        internal static ulong MachinePuid {
            get {
                try {
                    AuthHelper helper = new AuthHelper();
                    Claim claim = helper.FindClaim(AuthClaimTypes.DeviceId);
                    return ulong.Parse(claim.Value, NumberStyles.HexNumber);
                }
                catch {
                    return 0;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\MachineTrustLevelSet.cs ===
using System;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Policy;
using Microsoft.XboxLive.Auth.Claims;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// MachineTrustLevelSet, for the specified used, set the trust level
        /// for the specified machine.   Caller must supply a XUID claim  for
        /// the user and if setting the trust level to Trusted,  a device  id
        /// claim.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="machinePuid">Machine puid</param>
        /// <param name="trustLevel">trust level</param>
        public void MachineTrustLevelSet(
            ulong userPuid,
            ulong machinePuid,
            MachineTrustLevel trustLevel
        )
        {
            HResult hr = HResult.S_OK;

            try {
                if (userPuid == 0)
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid, {0}", userPuid);
                else if (machinePuid == 0)
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid machine puid, {0}", machinePuid);

                // when raising the trust on a given machine  then
                // the caller needs to be signed into that machine
                
                else if (trustLevel == MachineTrustLevel.Trusted) {

                    // check for device claim  issued  by  default
                    // issuer (xsts) or if the  call  is  internal

                    AuthHelper authHelper = new AuthHelper();

                    if (! authHelper.IsInternal()) {
                        if (! authHelper.VerifyEquals(AuthClaimTypes.DeviceId, machinePuid)) {
                            throw new XblException(
                                HResult.XONLINE_E_ACCESS_DENIED, "Invalid machine puid, {0}", machinePuid
                            );
                        }
                    }
                }
                
                // they have to set to trusted or untrusted, we do
                // not support any other temporary values like  -1

                else if (trustLevel != MachineTrustLevel.Untrusted) {
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid trust level, {0}", trustLevel);
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_xuser_machine_trust_level_set";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter("@bi_user_puid", userPuid);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@i_trust_level", (int) trustLevel);
                    ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                    using (WstDataReader reader = ws.Execute())
                    {
                        hr = (uint) ws.GetIntParameter("@hr");
                        
                        if (hr.IsFailure()) {
                            throw new XblException(hr, "Error setting trust level for user {0}, machine {1}", (Puid) userPuid, (Puid) machinePuid);
                        }
                    }
                }
            }
            
            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally {
                Logging.Log(string.Format(
                    "MachineTrustLevelSet|{0}|{1}|{2}|{3}", hr, (Puid) userPuid, (Puid) machinePuid, trustLevel
                ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\MachineFriendlyNameSet.cs ===
using System;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// MachineFriendlyNameSet, set a friendly name for the specified machine
        /// so the user can more easily refer to it.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="machinePuid">Machine puid</param>
        /// <param name="friendlyName">User friendly name for machine</param>
        public void MachineFriendlyNameSet(
            ulong userPuid,
            ulong  machinePuid,
            string friendlyName
        )
        {
            HResult hr = HResult.S_OK;

            try
            {
                if (userPuid == 0)
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid, {0}", userPuid);
                else if (machinePuid == 0)
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid machine puid, {0}", machinePuid);
                else if ((friendlyName != null) && (friendlyName.Length > 64)) {
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid friendly name, {0}", friendlyName);
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_xuser_machine_friendly_name_set";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter("@bi_user_puid",     userPuid);
                    ws.AddParameter("@bi_machine_puid",  machinePuid);
                    if (friendlyName != null) ws.AddParameter("@vc_friendly_name", friendlyName);

                    ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                    using (WstDataReader reader = ws.Execute())
                    {
                        hr = (uint) ws.GetIntParameter("@hr");
                        
                        if (hr.IsFailure()) {
                            throw new XblException(hr, "Error setting friendly name for user {0}, machine {1}", (Puid) userPuid, (Puid) machinePuid);
                        }
                    }
                }
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally {
                Logging.Log(string.Format(
                    "MachineFriendlyNameSet|{0}|{1}|{2}|{3}",
                    hr, (Puid) userPuid, (Puid) machinePuid, friendlyName ?? string.Empty
                ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\MachineGet.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// MachineGet, for the specified user, get the machines that match
        /// the specified criteria.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="machinePuid">Machine has this specific machinePuid</param>
        /// <param name="friendlyName">user has given the machine this name</param>
        /// <param name="since">user has signed in or out of the machine after this time</param>
        /// <returns>returns zero or more machine records matching the specified criteria</returns>
        public UserMachine[] MachineGet(
            ulong     userPuid,
            ulong?    machinePuid,
            string    friendlyName,
            DateTime? since
        )
        {
            HResult hr = HResult.S_OK;
            List<UserMachine> machineList = new List<UserMachine>();

            try {
                if (userPuid == 0)
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid, {0}", (Puid) userPuid);
                else if ((machinePuid.HasValue) && (machinePuid == 0)) {
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid machine puid, {0}", (Puid) machinePuid);
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "p_xuser_machine_get";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter("@bi_user_puid", userPuid);
                    ws.AddParameter(ParamType.RETVAL, "@hr", (int) 0);
                    
                    // if the machine is null or the friendly name is null
                    // then we are getting all the machines for this  user

                    if (machinePuid.HasValue) ws.AddParameter("@bi_machine_puid", machinePuid.Value);
                    if (friendlyName != null) ws.AddParameter("@vc_friendly_name", friendlyName);
                    if (since.HasValue) ws.AddParameter("@dt_since", since.Value);

                    using (WstDataReader reader = ws.Execute())
                    {
                        hr = (uint) ws.GetIntParameter("@hr");

                        if (hr.IsFailure())  {
                            throw new XblException(hr, "Error getting machines for user, {0}", (Puid) userPuid);
                        }

                        while (reader.Read()) {
                            UserMachine userMachine = new UserMachine();
                            userMachine.Read(reader);
                            machineList.Add(userMachine);
                        }
                    }

                    return machineList.ToArray();
                }
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally
            {
                Logging.Log(string.Format(
                    "MachineGet|{0}|{1}|{2}|{3}|{4}|{5}",
                    hr, (Puid) userPuid,
                    machinePuid.HasValue ? ((Puid) machinePuid).ToString() : string.Empty,
                    friendlyName != null ? friendlyName                    : string.Empty,
                    since.HasValue       ? since.ToString()                : string.Empty,
                    machineList.Count
                ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\PassportHistoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;
using xonline.common.mgmt;
using CORE = xonline.core.history;

namespace xonline.xuser.service
{
    public static class PassportHistoryExtension
    {
        #region ReadData
        public static void ReadDetail(this PassportHistoryDetails phd, WstDataReader reader)
        {
            if (phd != null)
            {
                phd.UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                phd.MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? (Puid?)null : WSClient.GetPuid(reader, "bi_machine_puid");
                phd.IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                phd.Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                phd.HResult = WSClient.GetHResult(reader, "i_hr");
                phd.Reason = WSClient.GetByte(reader, "ti_reason");

                phd.OldPassportPuid = WSClient.IsDBNull(reader, "bi_old_passport_puid") ? (Puid?)null : WSClient.GetPuid(reader, "bi_old_passport_puid");
                phd.NewPassportPuid = WSClient.IsDBNull(reader, "bi_new_passport_puid") ? (Puid?)null : WSClient.GetPuid(reader, "bi_new_passport_puid");

                phd.InitDetails();
            }
        }

        public static PassportHistory Read(this PassportHistory ph, WstDataReader reader, bool details)
        {
            if (ph != null)
            {
                if (!reader.Read())
                {
                    throw new XRLException(
                            HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                            XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                            "Error reading history summary information"
                        );
                }
                
                ph.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                ph.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                ph.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                ph.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                if (details && reader.NextResult())
                {
                    int i = 0;
                    ph.Details = new PassportHistoryDetails[ph.Total];

                    while (reader.Read())
                    {
                        ph.Details[i] = new PassportHistoryDetails();

                        ph.Details[i++].ReadDetail(reader);
                    }
                }
            }
            return ph;
        }

        #endregion

        #region LogData
        public static void LogDetail(this PassportHistoryDetails phd, HistoryParams historyParams, string databaseName)
        {
            if (phd != null)
            {
                Puid hashVal = (Puid)phd.UserPuid;

                using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // parameterized stored procedures  and  hashes
                    // allow writes to different  tables/partitions

                    ws.StoredProc = historyParams.StoredProc;
                    ws.SetHashVal(hashVal);

                    // add all of the standard fields to the record

                    ws.AddParameter("bi_user_puid", phd.UserPuid);
                    ws.AddParameter("dt_timestamp", phd.Timestamp);
                    ws.AddParameter("i_hr", phd.HResult);
                    ws.AddParameter("ti_reason", (byte)phd.Reason);

                    // some common fields can be null.  check  that

                    if (phd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)phd.MachinePuid);
                    if (phd.IpAddress != null) ws.AddParameter("vc_ip_address", phd.IpAddress);
                    ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));
                    if (historyParams.UseHash) ws.AddParameter("si_hash_bucket", ws.Partition);

                    // finally we add the operation specific params
                    // for particular operational details we record

                    PassportHistoryExtension.AddParams(phd, ws);

                    // add return value to receive the return value

                    HResult hr = HResult.S_OK;
                    ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                    // execute and convert result set into  history
                    // summary used to test  configured  thresholds

                    try
                    {
                        using (WstDataReader reader = ws.Execute())
                        {
                            if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                                );
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        if (e.InnerException is SqlException)
                        {
                            SqlException sqlExcept = (SqlException)e.InnerException;

                            if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                    "Existing log record found"
                                );
                            }
                        }
                    }
                }
            }
        }

        public static void Log(this PassportHistoryDetails phd)
        {
            HResult hr = HResult.S_OK;

            if (phd == null)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter: PassportHistoryDetails"
                    );
            }

            if (phd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    phd.Timestamp.ToString()
                    );
            }

            if (phd.NewPassportPuid == phd.OldPassportPuid)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewPassportPuid cannot be equal to OldPassportPuid: {0}|{1}",
                    phd.NewPassportPuid, phd.OldPassportPuid
                    );
            }

            if ((phd.NewPassportPuid == 0) && (phd.OldPassportPuid == 0))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewPassportPuid and OldPassportPuid cannot both be 0: {0}|{1}",
                    phd.NewPassportPuid, phd.OldPassportPuid
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)phd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    phd.Reason
                    );
            }

            if (phd.MachinePuid.HasValue == false)
            {
                //because the data contract has the machine puid as IsRequired
                //we cannot leave this null or it crashes inside soap
                //but null is a valid value
                phd.MachinePuid = 0;
            }
            else if (XOn.XboxId.IsMachinePuid((UInt64)phd.MachinePuid) == false)
            {
                if (XOn.XboxId.IsXboxcomMachinePuid((UInt64)phd.MachinePuid))
                {
                    //received an xbox.com machine puid, we then just use the zero'd out puid.
                    phd.MachinePuid = XOn.XboxId.XboxComMachineBase;
                }
                else
                {
                    throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    phd.MachinePuid
                    );
                }
            }

            try
            {
                User validateUser = new User(phd.UserPuid);

                if (string.IsNullOrEmpty(validateUser.Gamertag))
                {
                    //we did not find the machine puid, it is not valid
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "UserPuid is invalid: {0}",
                        phd.UserPuid
                        );
                }
            }
            catch (Exception e)
            {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId)
                {
                    Logging.NtEvent((ExceptionWithEventId)e, "Error validating user '{0}'", (Puid)phd.UserPuid);
                }

                throw;
            }

            LogDetail(phd, _userParams, ConfigUtil.SecUserHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
            {
                LogDetail(phd, _userParamsUODB, ConfigUtil.UodbWebstoreApp);
            }

        }
        #endregion

        private static void AddParams(this PassportHistoryDetails phd, WSClient ws)
        {
            if (phd != null)
            {
                if (phd.OldPassportPuid != null) ws.AddParameter("bi_old_passport_puid", (Puid) phd.OldPassportPuid);
                if (phd.NewPassportPuid != null) ws.AddParameter("bi_new_passport_puid", (Puid) phd.NewPassportPuid);
            }
        }

        private static HistoryParams _userParams = new HistoryParams(
            "p_xuser_user_passport_history_add",
            Setting.xuacs_userPassportThreshold,
            Setting.xuacs_userPassportIntervalDays,
            XEvent.Id.ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED,
            "User {0} exceeded passport change threshold of {1} unique machines in {2} days",
            (byte)CORE.HistoryReason.SwitchUserPassport, (byte)CORE.HistoryReason.PassportChangePassword
        );

        private static HistoryParams _userParamsUODB = new HistoryParams(
            "p_xuacs_user_passport_history_add",
            Setting.xuacs_userPassportThreshold,
            Setting.xuacs_userPassportIntervalDays,
            XEvent.Id.ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED,
            "User {0} exceeded passport change threshold of {1} unique machines in {2} days",
            false,
            (byte)CORE.HistoryReason.SwitchUserPassport, (byte)CORE.HistoryReason.PassportChangePassword
        );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\Management.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.xuser.service
{
    public class Management
    {
        public static void Init()
        {
            Config.Assembly = Assembly.GetExecutingAssembly();
            XomLoggingControl.Init();

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(Config.Assembly.GetName().Name + " help:\r\n" +
                                                          "    echo [value] -- Echos the value.\r\n" +
                                                          "\r\n",
                                                        args.RequestId);

                        args.Handled = true;
                        break;

                    case "echo":
                        string val = args.CommandArgs[0];
                        XomControlConnection.SendMessage("Echo:" + val, args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch (Exception e)
            {
                HResult hr = XRLException.ToHResult(e, HResult.E_FAIL);
                XomControlConnection.SendMessage(string.Format("Error: {0}, hr = {1}\r\n\r\n", e.ToString(), hr), args.RequestId);

                Logging.Log(e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\PassportHistoryLog.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        public void PassportHistoryLog(PassportHistoryDetails phd)
        {
            try
            {
                if (phd == null)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Null parameter: PassportHistoryDetails"
                        );
                }

                PassportHistoryExtension.Log(phd);
            }
            catch (Exception e)
            {
                if (phd != null)
                {
                    Logging.NtEvent(XEvent.Id.ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR, e,
                       "Error in passportlog for user {0} on machine {1}",
                       phd.UserPuid, phd.MachinePuid == null ? "<None>" : phd.MachinePuid.ToString());
                }

                throw;
            }
            finally
            {
                if (phd != null)
                {
                    Logging.Log(string.Format(
                        "PassportHistoryLog|{0}|{1}|{2}|{3}",
                        (Puid)phd.UserPuid, (Puid)(phd.MachinePuid ?? 0), phd.NewPassportPuid ?? 0, phd.OldPassportPuid ?? 0
                    ));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\PassportHistoryGet.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
//using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// PassportHistoryGet, for the specified user 
        /// get the history </summary>
        /// <param name="userPuid">User puid</param>
		/// <param name="machinePuid">Machine puid</param>
        /// <param name="since">history since a given date and time</param>
        /// <returns>returns zero or records matching the specified criteria</returns>
        public PassportHistory PassportHistoryGet(
            ulong userPuid, 
			ulong? machinePuid,
            DateTime? since, 
            bool details
            )
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try 
            {
                if (userPuid == 0) 
				{
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid: {0}", (Puid) userPuid);
                }

                //We should pull from SecUserHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecUserHistoryWebstoreApp;

                string storedProcedureName = "p_xuser_user_passport_history_get";

                if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_user_passport_history_get";
                }

                Puid? tempMachinePuid = machinePuid.HasValue ? (Puid)machinePuid : (Puid?)null;

                //GetByUserPuid
                return GetPassportByUserPuid(databaseName, storedProcedureName, (Puid)userPuid, tempMachinePuid, since, details);
            }
            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally
            {
                Logging.Log(string.Format(
                    "PassportHistoryGet|{0}|{1}|{2}|{3}",
                    hr, 
					(Puid) userPuid,
					machinePuid == null ? "<none>" : machinePuid.ToString(),
                    since.HasValue       ? since.ToString()                : string.Empty
                ));
            }

        }

        private static PassportHistory GetPassportHistory(WSClient ws, DateTime? since, bool details)
        {
            if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
            ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
            ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

            using (WstDataReader reader = ws.Execute())
            {
                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (hr.IsSuccess())
                {
                    return PassportHistoryExtension.Read(new PassportHistory(), reader, details);
                }
                else
                    return null;
            }
        }

        private static PassportHistory GetPassportByUserPuid(string databaseName, string storedProcedureName, Puid userPuid, Puid? machinePuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = storedProcedureName; 
                ws.AddParameter("@bi_user_puid", userPuid);
				if (machinePuid != null && machinePuid != 0) 
				{
			        ws.AddParameter("@bi_machine_puid", (Puid) machinePuid);
				}
                return GetPassportHistory(ws, since, details);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\RecoveryHistoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;
using xonline.common.mgmt;
using CORE = xonline.core.history;

namespace xonline.xuser.service
{
    public static class RecoveryHistoryExtension
    {
        #region ReadData
        public static void ReadDetail(this RecoveryHistoryDetails rhd, WstDataReader reader)
        {
            if (rhd != null)
            {
                rhd.UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                rhd.MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? (Puid?)null : WSClient.GetPuid(reader, "bi_machine_puid");
                rhd.IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                rhd.Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                rhd.HResult = WSClient.GetHResult(reader, "i_hr");
                rhd.Reason = WSClient.GetByte(reader, "ti_reason");

                rhd.PassportPuid = WSClient.GetPuid(reader, "bi_user_passport_puid");
                rhd.InitDetails();
            }
        }

        public static RecoveryHistory Read(this RecoveryHistory rh, WstDataReader reader, bool details)
        {
            if (rh != null)
            {
                if (!reader.Read())
                {
                    throw new XRLException(
                            HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                            XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                            "Error reading history summary information"
                        );
                }

                rh.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                rh.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                rh.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                rh.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                if (details && reader.NextResult())
                {
                    int i = 0;
                    rh.Details = new RecoveryHistoryDetails[rh.Total];

                    while (reader.Read())
                    {
                        rh.Details[i] = new RecoveryHistoryDetails();

                        rh.Details[i++].ReadDetail(reader);
                    }
                }
            }
            return rh;
        }

        #endregion

        #region LogData
        public static void LogDetail(this RecoveryHistoryDetails rhd, HistoryParams historyParams, string databaseName)
        {
            if (rhd != null)
            {
                Puid hashVal = (Puid)rhd.UserPuid;

                using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // parameterized stored procedures  and  hashes
                    // allow writes to different  tables/partitions

                    ws.StoredProc = historyParams.StoredProc;
                    ws.SetHashVal(hashVal);

                    // add all of the standard fields to the record

                    ws.AddParameter("bi_user_puid", rhd.UserPuid);
                    ws.AddParameter("dt_timestamp", rhd.Timestamp);
                    ws.AddParameter("i_hr", rhd.HResult);
                    ws.AddParameter("ti_reason", (byte)rhd.Reason);

                    // some common fields can be null.  check  that

                    if (rhd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)rhd.MachinePuid);
                    if (rhd.IpAddress != null) ws.AddParameter("vc_ip_address", rhd.IpAddress);
                    ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));
                    ws.AddParameter("si_hash_bucket", ws.Partition);

                    // finally we add the operation specific params
                    // for particular operational details we record

                    RecoveryHistoryExtension.AddParams(rhd, ws);

                    // add return value to receive the return value

                    HResult hr = HResult.S_OK;
                    ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                    // execute and convert result set into  history
                    // summary used to test  configured  thresholds

                    try
                    {
                        using (WstDataReader reader = ws.Execute())
                        {
                            if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                                );
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        if (e.InnerException is SqlException)
                        {
                            SqlException sqlExcept = (SqlException)e.InnerException;

                            if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                            {
                                throw new XRLException(
                                    hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                    "Existing log record found"
                                );
                            }
                        }
                    }
                }
            }
        }

        public static void Log(this RecoveryHistoryDetails rhd)
        {
            HResult hr = HResult.S_OK;

            if (rhd == null)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter: RecoveryHistoryDetails"
                    );
            }

            if (rhd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    rhd.Timestamp.ToString()
                    );
            }

            if (rhd.PassportPuid == 0)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "PassportPuid is invalid: {0}",
                    rhd.PassportPuid
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)rhd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    rhd.Reason
                    );
            }

            if (rhd.MachinePuid == null || rhd.MachinePuid == 0 || rhd.MachinePuid.HasValue == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter:MachinePuid"
                    );
            }
             
            if (XOn.XboxId.IsMachinePuid((UInt64)rhd.MachinePuid) == false)
            {
                     throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    rhd.MachinePuid
                    );
            }

            try
            {
                User validateUser = new User(rhd.UserPuid);

                if (string.IsNullOrEmpty(validateUser.Gamertag))
                {
                    //we did not find the machine puid, it is not valid
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "UserPuid is invalid: {0}",
                        rhd.UserPuid
                        );
                }
            }
            catch (Exception e)
            {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId)
                {
                    Logging.NtEvent((ExceptionWithEventId)e, "Error validating user '{0}'", (Puid)rhd.UserPuid);
                }

                throw;
            }

            LogDetail(rhd, _userParams, ConfigUtil.SecUserHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
            {
                LogDetail(rhd, _userParamsUODB, ConfigUtil.UodbWebstoreApp);
            }

        }
        #endregion

        private static void AddParams(this RecoveryHistoryDetails rhd, WSClient ws)
        {
            if (rhd != null)
            {
                ws.AddParameter("bi_user_passport_puid", (Puid) rhd.PassportPuid);
            }
        }

        private static HistoryParams _userParams = new HistoryParams(
             "p_xuser_user_recovery_history_add",
             Setting.xuacs_userRecoveryThreshold,
             Setting.xuacs_userRecoveryIntervalDays,
             XEvent.Id.ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED,
             "User {0} exceeded recovery threshold of {1} unique machines in {2} days",
             (byte)CORE.HistoryReason.RecoverAccount
         );

        private static HistoryParams _userParamsUODB = new HistoryParams(
             "p_xuacs_user_recovery_history_add",
             Setting.xuacs_userRecoveryThreshold,
             Setting.xuacs_userRecoveryIntervalDays,
             XEvent.Id.ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED,
             "User {0} exceeded recovery threshold of {1} unique machines in {2} days",
             (byte)CORE.HistoryReason.RecoverAccount
         );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\RecoveryHistoryLog.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        public void RecoveryHistoryLog(RecoveryHistoryDetails rhd)
        {
            try
            {
                if (rhd == null)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Null parameter: RecoveryHistoryDetails"
                        );
                }

                RecoveryHistoryExtension.Log(rhd);
            }
            catch (Exception e)
            {
                if (rhd != null)
                {
                    Logging.NtEvent(XEvent.Id.ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR, e,
                       "Error in recoverylog for user {0} on machine {1}",
                       rhd.UserPuid, rhd.MachinePuid == null ? "<None>" : rhd.MachinePuid.ToString());
                }

                throw;
            }
            finally
            {
                if (rhd != null)
                {
                    Logging.Log(string.Format(
                        "RecoveryHistoryLog|{0}|{1}|{2}",
                        (Puid)rhd.UserPuid,
                        rhd.MachinePuid == null ? "<None>" : rhd.MachinePuid.ToString(),
                        rhd.PassportPuid.ToString()
                    ));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\UserKey.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;

namespace xonline.xuser.server
{
    public static class UserKeyExtensions
    {
        public static void Generate(this UserKey userKey, string gamertag)
        {
            byte[] rawKey, encryptedKey, IV, SPPA, PPA;
            
            KEKCryptoMgr.GenerateNewKey(out IV, out encryptedKey, out rawKey);
            KEKCryptoMgr.GenPPAforDBWrp(gamertag, (byte[]) rawKey.Clone(), out SPPA, out PPA);

            userKey.Gamertag     = gamertag;
            userKey.RawKey       = rawKey;
            userKey.EncryptedKey = encryptedKey;
            userKey.IV           = IV;
            userKey.SPPA         = SPPA;
            userKey.PPA          = PPA;
        }

        public static void Read(this UserKey userKey, WstDataReader reader)
        {
            userKey.Gamertag     = WSClient.GetString(reader, "vc_gamertag");
            userKey.RawKey       = WSClient.GetNullableBytes(reader, "bin_raw_key");
            userKey.EncryptedKey = WSClient.GetNullableBytes(reader, "bin_encrypted_key");
            userKey.IV           = WSClient.GetNullableBytes(reader, "bin_iv");
            userKey.SPPA         = WSClient.GetNullableBytes(reader, "bin_sppa");
            userKey.PPA          = WSClient.GetNullableBytes(reader, "bin_ppa");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\User.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.xuser.service
{
    public class User
    {
        public User(ulong userPuid) 
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_xuser_user_get";
                ws.SetHashVal(userPuid);

                ws.AddParameter("@bi_user_puid", userPuid);

                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.HasRows)
                    {
                        if (!reader.Read())
                        {
                            throw new Exception("Error loading user from database, " + ((Puid)userPuid).ToString());
                        }

                        Xuid = WSClient.GetPuid(reader, "bi_user_puid");
                        Puid = WSClient.GetPuid(reader, "bi_user_passport_puid");
                        Gamertag = WSClient.GetString(reader, "vc_gamertag");
                        Birthdate = WSClient.GetDateTime(reader, "dt_birthdate");
                        Country = WSClient.GetByte(reader, "ti_country_id");
                        Language = WSClient.GetInt32(reader, "i_language_id");
                    }
                }
            }
        }

        public void Reset() 
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // yeah, yeah.  we are using someone elses
                // sproc. hotfixes can be like that.  sigh.
                
                ws.StoredProc = "p_xuacs_set_reset_date";
                ws.SetHashVal(Xuid);

                ws.AddParameter("@userpuid", Xuid);
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                ws.ExecuteScalar();
                HResult hr = (uint) ws.GetIntParameter("@hr");

                if (hr.IsFailure())
                {
                    throw new XblException(hr, "Error saving user to database, {0}", (Puid) Xuid);
                }
            }
        }
        
        public ulong Xuid         { get; private set; }
        public ulong Puid         { get; private set; }
        public string Gamertag    { get; private set; }
        public DateTime Birthdate { get; private set; }
        public int Country        { get; private set; }
        public int Language       { get; private set; }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\RecoveryHistoryGet.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

using Microsoft.Webstore.WstClient;
//using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// RecoveryHistoryGet, for the specified user 
        /// get the history </summary>
        /// <param name="userPuid">User puid</param>
		/// <param name="machinePuid">Machine puid</param>
        /// <param name="ipaddress">ipaddress name</param>
        /// <param name="since">history since a given date and time</param>
        /// <returns>returns zero or records matching the specified criteria</returns>
        public RecoveryHistory RecoveryHistoryGet(
            ulong userPuid, 
			ulong? machinePuid,
            DateTime? since, 
            bool details
            )
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try 
            {
                if (userPuid == 0) 
				{
                    throw new XblException(HResult.XONLINE_E_INVALID_REQUEST, "Invalid user puid: {0}", (Puid) userPuid);
                }

                //We should pull from SecUserHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecUserHistoryWebstoreApp;

                string storedProcedureName = "p_xuser_user_recovery_history_get";

                if (Config.GetBoolSetting(Setting.xuser_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_user_recovery_history_get";
                }

                Puid? tempMachinePuid = machinePuid.HasValue ? (Puid)machinePuid : (Puid?)null;

                //GetByUserPuid
                return GetRecoveryByUserPuid(databaseName, storedProcedureName, (Puid)userPuid, tempMachinePuid, since, details);
            }
            catch (Exception e) {
                hr = XblException.GetHResult(e);
                throw;
            }

            finally
            {
                Logging.Log(string.Format(
                    "RecoveryHistoryGet|{0}|{1}|{2}|{3}",
                    hr, 
					(Puid) userPuid,
					machinePuid == null ? "<none>" : machinePuid.ToString(),
                    since.HasValue       ? since.ToString()                : string.Empty
                ));
            }
             
        }

        private static RecoveryHistory GetRecoveryHistory(WSClient ws, DateTime? since, bool details)
        {
            if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
            ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
            ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

            using (WstDataReader reader = ws.Execute())
            {
                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (hr.IsSuccess())
                {
                    return RecoveryHistoryExtension.Read(new RecoveryHistory(), reader, details);
                }
                else
                    return null;
            }
        }

        private static RecoveryHistory GetRecoveryByUserPuid(string databaseName, string storedProcedureName, Puid userPuid, Puid? machinePuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = storedProcedureName;
                ws.AddParameter("@bi_user_puid", userPuid);
                if (machinePuid != null && machinePuid != 0) 
				{
			        ws.AddParameter("@bi_machine_puid", (Puid) machinePuid);
				}
                return GetRecoveryHistory(ws, since, details);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\ServiceHostFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;

using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomIisInstallerAttribute(Interface.xuser_int)]
[assembly: ConfigAttribute(Component.xuser)]

namespace xonline.xuser.service
{
    /// <summary>
    /// This is the class that hooks into the service host initialization performed by IIS. It 
    /// adds event handlers for the state transition events and is the place where you can put 
    /// init code. XUser.svc sets its ServiceHost object's factory property to this one.
    /// </summary>
    public class ServiceHostFactory : ServiceHostFactoryBase
    {
        public override System.ServiceModel.ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses)
        {
            ServiceHost host = new ServiceHost(typeof(XUser), baseAddresses);

            host.Description.Behaviors.Add(new ErrorHandler());
            host.Description.Behaviors.Add(new CounterServiceBehavior());

            host.Opening += new EventHandler(ServiceHost_Opening);
            host.Opened += new EventHandler(ServiceHost_Opened);
            host.Closing += new EventHandler(ServiceHost_Closing);
            host.Closed += new EventHandler(ServiceHost_Closed);
            host.Faulted += new EventHandler(ServiceHost_Faulted);
            host.UnknownMessageReceived += new EventHandler<UnknownMessageReceivedEventArgs>(ServiceHost_UnknownMessageReceived);

            return host;
        }

        void ServiceHost_Opening(object sender, EventArgs e)
        {
        }

        void ServiceHost_Opened(object sender, EventArgs e)
        {
            EventBuilder.ShowSGInfo = false;
            Management.Init();
            Logging.Init();
        }

        void ServiceHost_Closing(object sender, EventArgs e)
        {
        }

        void ServiceHost_Closed(object sender, EventArgs e)
        {
        }

        void ServiceHost_Faulted(object sender, EventArgs e)
        {
        }

        void ServiceHost_UnknownMessageReceived(object sender, UnknownMessageReceivedEventArgs e)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\UserKeyGet.cs ===
using System;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.xuser.contract;

using Microsoft.IdentityModel;
using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// UserKeyGet, for the specified user, get the user key.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <returns>returns the key</returns>
        public UserKey UserKeyGet(
            ulong userPuid
        )
        {
            string gamertag = string.Empty;
            HResult hr = HResult.S_OK;

            try {
                User user = new User(userPuid);

                // construct an empty key object,  fill it in using
                // the data we find in the  database  (by gamertag)

                UserKey userKey = new UserKey();
                userKey.Load(gamertag = user.Gamertag);
                return userKey;
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId) {
                    Logging.NtEvent((ExceptionWithEventId) e, "Error getting key for user '{0}'", (Puid) userPuid);
                }

                throw;
            }

            finally {
                ulong machinePuid = Logging.MachinePuid;

                Logging.Log(string.Format(
                    "UserKeyGet|{0}|{1}|{2}|{3}",
                    hr, (Puid) userPuid, (Puid) machinePuid, gamertag
                ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\UserKeyExtensions.cs ===
using System;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.service;
using xonline.common.user;
using xonline.common.sql.webstore;
using xonline.common.crypto;
using xonline.xuser.contract;


namespace xonline.xuser.service
{
    public static class UserKeyExtensions
    {
        public static void Generate(this UserKey userKey, string gamertag)
        {
            byte[] rawKey, encryptedKey, IV, SPPA, PPA;

            KEKCryptoMgr.GenerateNewKey(out IV, out encryptedKey, out rawKey);
            KEKCryptoMgr.GenPPAforDBWrp(gamertag, (byte[]) rawKey.Clone(), out SPPA, out PPA);

            userKey.Gamertag     = gamertag;
            userKey.Version      = KEKCryptoMgr.GetKeyVersion();
            userKey.RawKey       = rawKey;
            userKey.EncryptedKey = encryptedKey;
            userKey.IV           = IV;
            userKey.SPPA         = SPPA;
            userKey.PPA          = PPA;
        }


        public static void Save(this UserKey userKey)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "p_xuser_key_reset";

                ws.AddParameter("@vc_gamertag", userKey.Gamertag);
                ws.AddParameter("@i_key_enc_key_version", userKey.Version);
                ws.AddParameter("@bin_key", userKey.EncryptedKey);
                ws.AddParameter("@bin_iv", userKey.IV);
                ws.AddParameter("@bin_sppa", userKey.SPPA);
                ws.AddParameter("@bin_ppa", userKey.PPA);
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                ws.SetHashVal(userKey.Gamertag);
                ws.ExecuteScalar();

                HResult hr = (uint) ws.GetIntParameter("@hr");

                if (hr.IsFailure()) {
                    throw new XblException(hr, "Error resetting user key for user '{0}'" + userKey.Gamertag);
                }
            }
        }


        public static UserKey Load(this UserKey userKey, string gamertag)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_xuser_key_get";
                ws.AddParameter("@vc_gamertag", gamertag);
                ws.SetHashVal(gamertag);

                using (WstDataReader reader = ws.Execute())
                {
                    if (! reader.Read()) {
                        throw new XblException(
                            HResult.XONLINE_E_XUSER_KEY_NOT_FOUND, "Error loading for user '{0}'", gamertag
                        );
                    }

                    userKey.Gamertag     = WSClient.GetString(reader, "vc_gamertag");
                    userKey.Version      = WSClient.GetInt32(reader, "i_key_enc_key_version");
                    userKey.IV           = WSClient.GetNullableBytes(reader, "bin_iv");
                    userKey.EncryptedKey = WSClient.GetNullableBytes(reader, "bin_key");
                    userKey.SPPA         = WSClient.GetNullableBytes(reader, "bin_sppa");
                    userKey.PPA          = WSClient.GetNullableBytes(reader, "bin_ppa");

                    // if we have the encrypted key the we need to decrypt
                    // it.  because C# is stupid, we need a local variable

                    if ((userKey.EncryptedKey != null) && (userKey.EncryptedKey.Length > 0))
                    {
                        try
                        {
                            byte[] rawKey;
                            KEKCryptoMgr.DecryptWithKEK(userKey.Version, userKey.IV, userKey.EncryptedKey, out rawKey);
                            userKey.RawKey = rawKey;
                        }
                        catch (Exception e) {
                            throw new XblException(
                                HResult.XONLINE_E_XUSER_KEY_DECRYPTION_ERROR, e, "Error loading for user '{0}'", gamertag
                            );
                        }
                    }
                }

                return userKey;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\UserKeyReset.cs ===
using System;

using xonline.common.exceptions;
using xonline.common.service;
using xonline.xuser.contract;

using Microsoft.XboxLive.Auth.Policy;

namespace xonline.xuser.service
{
    public partial class XUser : IXUser
    {
        /// <summary>
        /// Reset the keys for the specified user.  We could lookup the
        /// gamertag, but there are races if it is  being  changed.  So
        /// force them to pass it in.
        /// 
        /// Note also even though we reset both the xbox1 and xenon key
        /// we only return the xenon key to the user.
        /// </summary>
        /// <param name="gamertag">Gamertag used to generate the key</param>
        /// <returns>returns the key</returns>
        public UserKey UserKeyReset(
            ulong userPuid
        )
        {
            HResult hr = HResult.S_OK;
            string gamertag = string.Empty;

            try {
            
                // get user (to get gamertag and find key partition)
            
                User user = new User(userPuid);

                // construct an empty key object,  fill it in using
                // generate,  and then save the key to the database

                UserKey userKey = new UserKey();
                userKey.Generate(gamertag = user.Gamertag);
                userKey.Save();

                // set user reset date so kdc  invalidates  tickets
                user.Reset();
                
                // and return the newly generated key to the caller
                return userKey;
            }

            catch (Exception e) {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId) {
                    Logging.NtEvent((ExceptionWithEventId)e, "Error resetting key for user '{0}'", (Puid) userPuid);
                }

                throw;
            }

            finally
            {
                ulong machinePuid = Logging.MachinePuid;

                Logging.Log(string.Format(
                    "UserKeyReset|{0}|{1}|{2}|{3}",
                    hr, (Puid) userPuid, (Puid) machinePuid, gamertag
                ));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\XUser.cs ===
using xonline.xuser.contract;
using xonline.common.service;

namespace xonline.xuser.service {
    public partial class XUser : FrontEndApp, IXUser {
        // all the XUser methods are in separate files
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\BasicTest.cs ===
using System;

using xonline.common.service;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

using System.ServiceModel;
using xonline.xuser.soap;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1), Description("General tests, not for any specific API.")]
    public class BasicTest: TestNode
    {
        [TestCase, Ignore("Here only as a helper to install the master key manually if for some reason the client is missing that standard prerequisite.  Not a real test.")]
        public void ManualInstallMasterKey()
        {
            if (!ServerTestFramework.LiveService.XSTS.XstsUtil.IsMasterKeyInstalled())
            {
                ServerTestFramework.LiveService.XSTS.XstsUtil.InstallMasterKey();
            }
        }

        [TestCase, Description("Test URL Long injection")]
        public void LongUrl()
        {
            String inputMessage = "xuser/xuser.svc=" + RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(1200, 1200);

            Puid userPuid = XUserTestUtil.CreateUser(null, "XUserTester2");
            xonline.xuser.soap.XUserTestSoapClient client = XUserTestUtil.GetUserClient(inputMessage);
            XUserTestUtil.ExecuteCallExpecting400(delegate{client.UserKeyGet(userPuid, true);});
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\AuthTestHelper.cs ===
//-----------------------------------------------------------------------
// <copyright file="AuthTestHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections.ObjectModel;
using System.Security.Principal;
using System.Threading;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth.Claims;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.XSTS;

namespace XUserTests
{
    public static class AuthTestHelper
    {
        public static Claim MakeSystemClaim(string name, string value, string type)
        {
            return new Claim(name, value, type, "System");
        }

        public static Claim MakeXstsClaim(string name, string value, string type)
        {
            return new Claim(name, value, type, "xsts.xboxlive.com");
        }

        public static Claim MakeUserPuidClaim(ulong puid)
        {
            return MakeXstsClaim(AuthClaimTypes.Xuid, puid.ToString(), AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid]);
        }

        public static Claim MakeMachinePuidClaim(ulong puid)
        {
            return MakeXstsClaim(AuthClaimTypes.DeviceId, puid.ToString("X16"), AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId]);
        }
    }
}

///////////

namespace Microsoft.Xbox.Devices.Test.Integration.Common
{
    public static class AuthTestHelper
    {
        // All values borrowed from Platform.MvcSample
        private const string Issuer = "xsts.xboxlive.com";

        public static ClaimsPrincipal GetClaimsPrincipal(ulong xuid)
        {
            return GetClaimsPrincipal(xuid, Convert.ToUInt32("FFFE0000", 16), "1", Convert.ToUInt64("FA00FFFFFFFFFFFF", 16));
        }

        public static ClaimsPrincipal GetClaimsPrincipal(ulong xuid, ulong deviceId)
        {
            return GetClaimsPrincipal(xuid, Convert.ToUInt32("FFFE0000", 16), "1", deviceId);
        }

        public static ClaimsPrincipal GetClaimsPrincipal(ulong? xuid, uint? titleId, string platformType, ulong? deviceId)
        {
            Collection<Claim> claims = new Collection<Claim>()
            {
                new Claim(AuthClaimTypes.AgeGroup, "Adult", AuthClaimTypes.ValueTypes[AuthClaimTypes.AgeGroup], Issuer),
                new Claim(AuthClaimTypes.ClientIpPort, "10.124.212.84:65535", AuthClaimTypes.ValueTypes[AuthClaimTypes.ClientIpPort], Issuer),
                new Claim(AuthClaimTypes.Country, "103", AuthClaimTypes.ValueTypes[AuthClaimTypes.Country], Issuer),
                new Claim(AuthClaimTypes.FlowToken, "EF594473B7D97D8D", AuthClaimTypes.ValueTypes[AuthClaimTypes.FlowToken], Issuer),
                new Claim(AuthClaimTypes.Gamertag, "STFUWIB98GSPDRE", AuthClaimTypes.ValueTypes[AuthClaimTypes.Gamertag], Issuer),
                new Claim(AuthClaimTypes.Language, "1", AuthClaimTypes.ValueTypes[AuthClaimTypes.Language], Issuer),
                new Claim(AuthClaimTypes.Privileges, "255", AuthClaimTypes.ValueTypes[AuthClaimTypes.Privileges], Issuer),
                new Claim(AuthClaimTypes.Puid, "37FFF893377D2", AuthClaimTypes.ValueTypes[AuthClaimTypes.Puid], Issuer),
                new Claim(AuthClaimTypes.Tier, "Gold", AuthClaimTypes.ValueTypes[AuthClaimTypes.Tier], Issuer),
                new Claim(AuthClaimTypes.TitleVersion, "1", AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleVersion], Issuer),
            };

            if (deviceId.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.DeviceId, deviceId.Value.ToString("X"), AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceId], Issuer));
            }

            if (!String.IsNullOrEmpty(platformType))
            {
                claims.Add(new Claim(AuthClaimTypes.DeviceType, platformType, AuthClaimTypes.ValueTypes[AuthClaimTypes.DeviceType], Issuer));
            }

            if (titleId.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.TitleId, titleId.Value.ToString("D"), AuthClaimTypes.ValueTypes[AuthClaimTypes.TitleId], Issuer));
            }

            if (xuid.HasValue)
            {
                claims.Add(new Claim(AuthClaimTypes.Xuid, xuid.Value.ToString("D"), AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid], Issuer));
            }

            Collection<IClaimsIdentity> identities = new Collection<IClaimsIdentity>()
            {
                new ClaimsIdentity(claims, AuthenticationTypes.Federation)
            };

            return new ClaimsPrincipal(identities);
        }

        public static void SetClaimsOnThread(ulong callerXuid)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid);
        }

        public static void SetClaimsOnThread(ulong callerXuid, ulong deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, deviceId);
        }

        public static void SetClaimsOnThread(ulong? callerXuid, uint? titleId, uint? platformType, ulong? deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, titleId, platformType.ToString(), deviceId);
        }

        public static void SetClaimsOnThread(ulong? callerXuid, uint? titleId, string platformType, ulong? deviceId)
        {
            Thread.CurrentPrincipal = GetClaimsPrincipal(callerXuid, titleId, platformType, deviceId);
        }

        public static void SetClaimsOnThread(IPrincipal principal)
        {
            Thread.CurrentPrincipal = principal;
        }

        public static string GetXSTSTestToken(ulong userId, ulong machineId, uint titleId)
        {
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.userPuid0 = userId;
            slot.machinePuid = machineId;
            slot.titleId = titleId;

            SimpleXSTSClient clt = new SimpleXSTSClient();
            string s = clt.GetTokenStringFromSTS(SimpleXSTSClient.CreateDefaultRST(), slot, 0);
            return string.Format("Authorization: XBL2.0 x={0}", s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\Service\UserNotify.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Web;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.feapp;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.xuser.contract;

namespace xonline.xuser.service
{
    public class UserNotifyEntry : WireData
    {
        public  string SgAddress;
        public  int    Id;
        public  Puid   MachinePuid;
        public  string IpAddress;
        public  Puid[] UserPuids;
        public  bool   SignIn;

        public override WireData ReadStream(BinaryReader reader)
        {
            reader.ReadInt16(); // notification type   - don't need;
            reader.ReadInt16(); // notification length - don't need;

            SgAddress   = new IPAddress(reader.ReadUInt32()).ToString();
            Id          = reader.ReadInt32();
            MachinePuid = (Puid) reader.ReadInt64();

            reader.ReadBytes(4); // reserved bytes - don't need

            // simplify the logic further down by filtering out all
            // of the invalid user puids here (those set  to  zero)

            List<Puid> userPuids = new List<Puid>();

            for (int i = 0; i < 4; i++) {
                Puid userPuid = (Puid) reader.ReadInt64();
                if (userPuid != 0) userPuids.Add(userPuid);
            }

            // make our puids easy to access (an array) and read in
            // the  notification type  (SignIn == 0,  Signout == 1)

            UserPuids = userPuids.ToArray();
            IpAddress = new IPAddress(reader.ReadUInt32()).ToString();
            SignIn    = reader.ReadInt32() == 0;

            return this;
        }
    }


    public class UserNotifyRequest : XRLObject2
    {
        public UserNotifyEntry[] UserNotifyEntries = new UserNotifyEntry[0];

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            List<UserNotifyEntry> userNotifyEntries = new List<UserNotifyEntry>();

            while (binaryReader.BaseStream.Position < binaryReader.BaseStream.Length)
            {
                UserNotifyEntry userNotifyEntry = new UserNotifyEntry();
                userNotifyEntry.ReadStream(binaryReader);
                userNotifyEntries.Add(userNotifyEntry);
            }

            UserNotifyEntries = userNotifyEntries.ToArray();
            return this;
        }
    }
    

    
    public class UserNotifyResponse : XRLObject2 {
    }

    public class UserNotify : FrontEndHandler<UserNotifyRequest, UserNotifyResponse>
    {
        public override HResult ProcessRequest(
            HttpContext              context,
            UserNotifyRequest      request,
            out UserNotifyResponse response
        )
        {
            HResult hr = HResult.S_OK;
            Exception savedException = null;
            response = new UserNotifyResponse();

            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE)) {
                    for (int i = 0; i < request.UserNotifyEntries.Length; i++) {
                        try {
                            ProcessEntry(ws, request.UserNotifyEntries[i]);
                        }

                        catch (Exception e) {
                            if (hr == HResult.S_OK) hr = XblException.GetHResult(e);
                            if (savedException == null) savedException = e;
                        }
                    }
                }
            }

            finally {
                if (savedException != null) throw savedException;
            }

            return hr;
        }


        public void ProcessEntry(WSClient ws, UserNotifyEntry entry)
        {
            HResult hr = HResult.S_OK;
            Exception savedException = null;

            try {
                for (int i = 0; i < entry.UserPuids.Length; i++)
                {
                    // write a separate record for each user in the entry
                    // each one will be on a different database partition

                    try {
                        ws.Parameters.Clear();
                        ws.StoredProc = "p_xuser_machine_signinout";
                        ws.SetHashVal(entry.UserPuids[i]);

                        ws.AddParameter("@bi_user_puid",    entry.UserPuids[i]);
                        ws.AddParameter("@bi_machine_puid", entry.MachinePuid);
                        ws.AddParameter("@vc_ip_address",   entry.IpAddress);
                        ws.AddParameter("@b_is_signin",     entry.SignIn ? 1 : 0);

                        ws.ExecuteNonQuery();
                    }

                    // keep going if we run into an exception,  but  keep
                    // the status around so we can properly log the error

                    catch (Exception e) {
                        if (savedException == null) savedException = e;
                        if (hr == HResult.S_OK) hr = XblException.GetHResult(e);
                    }
                }
            }

            // log a single row for each entry (containing all the users)
            // UserNotify|hr|id|machinePuid|IpAddress|SignIn|User0|......

            finally
            {
                string s = string.Format(
                    "UserNotify|{0}|{1}|0x{2}|{3}|{4}|{5}", hr, entry.SgAddress, entry.Id.ToString("X8"),
                    entry.MachinePuid, entry.IpAddress, entry.SignIn
                );

                for (int i = 0; i < entry.UserPuids.Length; i++) {
                    s += "|" + entry.UserPuids[i].ToString();
                }

                Logging.Log(s);
            }

            if (savedException != null) throw savedException;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\GamertagHistoryGetByUserPuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class GamertagHistoryGetByUserPuid : GreaterDoubleWriteTestGroup
    {
        public static GamertagHistory GamertagHistoryGetByUserPuidVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling GamertagHistoryGetByUserPuid: UserPuid=" + userPuid + ", MachinePuid=" + machinePuid + ", Since=" + since + ", Details=" + details);
            GamertagHistory ret = client.GamertagHistoryGetByUserPuid((ulong)userPuid, true, (ulong?)machinePuid, true, since, true, details, true);
            Global.RO.Debug("GamertagHistoryGetByUserPuid returned: " + HistoryCommon.GamertagHistoryStringer(ret));
            return ret;
        }

        public static GamertagHistory GamertagHistoryGetByUserPuidVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details)
        {
            return GamertagHistoryGetByUserPuidVerbose(userPuid, machinePuid, since, details, null);
        }

        public static void ComputeAndVerifyGamertagHistory(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, GamertagHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a GamertagHistory that contains the expected result
            GamertagHistory expectedResult = new GamertagHistory();

            UserGamertagHistoryEditor.UserGamertagHistoryEntry []allHistories = UserGamertagHistoryEditor.FromUserPuid(userPuid, isSecMHDB).GetAllHistory();
            HashSet<ulong?> uniqueMachines = new HashSet<ulong?>();
            int totalEntries = 0;
            System.DateTime ?first = null;
            System.DateTime ?last = null;
            List<GamertagHistoryDetails> detailsExpectedInResult = new List<GamertagHistoryDetails>();
            foreach (UserGamertagHistoryEditor.UserGamertagHistoryEntry entry in allHistories)
            {
                if (since == null || entry.TimeStamp >= since)
                {
                    if ((machinePuid == null || machinePuid == entry.MachinePuid))
                    {
                        ++totalEntries;

                        if (first == null || first > entry.TimeStamp)
                        {
                            first = entry.TimeStamp;
                        }

                        if (last == null || last < entry.TimeStamp)
                        {
                            last = entry.TimeStamp;
                        }

                        if (!uniqueMachines.Contains(entry.MachinePuid))
                        {
                            uniqueMachines.Add(entry.MachinePuid);
                        }

                        if (details)
                        {
                            GamertagHistoryDetails detail = new GamertagHistoryDetails();
                            detail.MachinePuid = entry.MachinePuid;
                            detail.UserPuid = userPuid;
                            detail.IpAddress = entry.IpAddress;
                            detail.Timestamp = entry.TimeStamp;
                            detail.Result = entry.Hr;
                            detail.Reason = entry.Reason;
                            detail.OldGamertag = entry.OldGamertag;
                            detail.NewGamertag = entry.NewGamertag;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total = totalEntries;
            expectedResult.Unique = uniqueMachines.Count;
            expectedResult.First = first;
            expectedResult.Last = last;
            expectedResult.Details = detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details = null;
            }

            //Verify
            HistoryCommon.VerifyGamertagHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            GamertagHistory ret = GamertagHistoryGetByUserPuidVerbose(userPuid, machinePuid, since, details);
            ComputeAndVerifyGamertagHistory(userPuid, machinePuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithMachinePuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoMachinePuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoMachinePuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithMachinePuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithMachinePuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithMachinePuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoMachinePuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithMachinePuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithMachinePuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithMachinePuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe=UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, "OldyA", "NewyA", 1, useSecUHDB));
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, "OldyB", "NewyB", 2, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",                 0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",                 1,    null, false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",           0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",           1,    2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",           0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",           1,    4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",               0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",               1,    null, true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",         0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",         1,    2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",         0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",         1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            int ?passMachinePuid = (self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor []machs=new MachineEditor[]{MachineEditor.CreateNew(), MachineEditor.CreateNew()};

            UserGamertagHistoryEditor ughe=UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machs[0].Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, "OldyA", "NewyC", 1, useSecUHDB));
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machs[0].Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, "OldyA", "NewyD", 2, useSecUHDB));
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machs[1].Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, "OldyB", "NewyE", 3, useSecUHDB));

            ulong ?machinePuid=(passMachinePuid!=null?machs[(int)passMachinePuid].Id:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //User puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird machine puids.")]
            [CompoundCase("null",    null)]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void MachinePuids(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);

                UserEditor user = UserEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecUHDB));

                CallAndVerify(user.Puid, machinePuid, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string ipAddress = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                byte reason = (byte)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", reason, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird gamertags.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("MaxSize", "STFU0123456789AB")]
            //[CompoundCase("NullChar", "\0")]  //This is just a little too evil.  Requires some unusually bad data to be placed in the database manually.
            public void Gamertags(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string gamertags = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, gamertags, gamertags, 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            for (int i=0; i<1000; ++i)
            {
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, "Oldy"+i, "Newy"+(i+1), (byte)(i%10+1), useSecUHDB));
            }

            CallAndVerify(user.Puid, null, null, true, useSecUHDB);
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "A", "B", 1, useSecUHDB));

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{GamertagHistoryGetByUserPuidVerbose(user.Puid, mach.Id, null, true, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\GamertagHistoryGetByGamertag.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class GamertagHistoryGetByGamertag : GreaterDoubleWriteTestGroup
    {
        public static GamertagHistory GamertagHistoryGetByGamertagVerbose(string gamertag, DateTime? since, bool details, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling GamertagHistoryGetByGamertag: Gamertag=" + gamertag + ", Since=" + since + ", Details=" + details);
            GamertagHistory ret = client.GamertagHistoryGetByGamertag(gamertag, since, true, details, true);
            Global.RO.Debug("GamertagHistoryGetByGamertag returned: " + HistoryCommon.GamertagHistoryStringer(ret));
            return ret;
        }

        public static GamertagHistory GamertagHistoryGetByGamertagVerbose(string gamertag, DateTime? since, bool details)
        {
            return GamertagHistoryGetByGamertagVerbose(gamertag, since, details, null);
        }

        public static void ComputeAndVerifyGamertagHistory(string gamertag, System.DateTime ?since, bool details, GamertagHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a GamertagHistory that contains the expected result
            GamertagHistory expectedResult = new GamertagHistory();

            UserGamertagHistoryEditor.UserGamertagHistoryEntry []allHistories = UserGamertagHistoryEditor.GetAllHistoryForGamertag(gamertag, isSecMHDB);
            HashSet<ulong> uniqueUsers = new HashSet<ulong>();
            int totalEntries = 0;
            System.DateTime ?first = null;
            System.DateTime ?last = null;
            List<GamertagHistoryDetails> detailsExpectedInResult = new List<GamertagHistoryDetails>();
            foreach (UserGamertagHistoryEditor.UserGamertagHistoryEntry entry in allHistories)
            {
                if (since == null || entry.TimeStamp >= since)
                {
                    if ((entry.OldGamertag != null && (gamertag.ToLower() == entry.OldGamertag.ToLower())) ||
                        (entry.NewGamertag != null && (gamertag.ToLower() == entry.NewGamertag.ToLower())))
                    {
                        ++totalEntries;

                        if (first == null || first > entry.TimeStamp)
                        {
                            first = entry.TimeStamp;
                        }

                        if (last == null || last < entry.TimeStamp)
                        {
                            last = entry.TimeStamp;
                        }

                        if (!uniqueUsers.Contains(entry.UserPuid))
                        {
                            uniqueUsers.Add(entry.UserPuid);
                        }

                        if (details)
                        {
                            GamertagHistoryDetails detail = new GamertagHistoryDetails();
                            detail.MachinePuid = entry.MachinePuid;
                            detail.UserPuid = entry.UserPuid;
                            detail.IpAddress = entry.IpAddress;
                            detail.Timestamp = entry.TimeStamp;
                            detail.Result = entry.Hr;
                            detail.Reason = entry.Reason;
                            detail.OldGamertag = entry.OldGamertag;
                            detail.NewGamertag = entry.NewGamertag;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total = totalEntries;
            expectedResult.Unique = uniqueUsers.Count;
            expectedResult.First = first;
            expectedResult.Last = last;
            expectedResult.Details = detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details = null;
            }

            //Verify
            HistoryCommon.VerifyGamertagHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(string gamertag, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            GamertagHistory ret = GamertagHistoryGetByGamertagVerbose(gamertag, since, details);

            if (gamertag == null)
            {
                throw new UnexpectedTestResultException("Call unexpectedly succeeded with gamertag was null.");
            }

            ComputeAndVerifyGamertagHistory(gamertag, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoDate NoDetails MatchOld",     false, false, false)]
        [CompoundCase("WithDate NoDetails MatchOld",   true,  false, false)]
        [CompoundCase("NoDate WithDetails MatchOld",   false, true,  false)]
        [CompoundCase("WithDate WithDetails MatchOld", true,  true,  false)]
        [CompoundCase("NoDate NoDetails MatchNew",     false, false, true)]
        [CompoundCase("WithDate NoDetails MatchNew",   true,  false, true)]
        [CompoundCase("NoDate WithDetails MatchNew",   false, true,  true)]
        [CompoundCase("WithDate WithDetails MatchNew", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passPastDate = (bool)self.MyValues[0];
            bool passDetailsFlag = (bool)self.MyValues[1];
            bool matchOnNewGamertag = (bool)self.MyValues[2];

            UserEditor userA = UserEditor.CreateNew();
            UserEditor userB = UserEditor.CreateNew();
            UserEditor userC = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(userA.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userA.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, userB.Gamertag, userC.Gamertag, 1, useSecUHDB));

            string gamertagToPass = (matchOnNewGamertag ? userC.Gamertag : userB.Gamertag);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(gamertagToPass, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Do a lookup for a gamertag that has no history.")]
        [CompoundCase("NoDate NoDetails",     false, false)]
        [CompoundCase("WithDate NoDetails",   true,  false)]
        [CompoundCase("NoDate WithDetails",   false, true)]
        [CompoundCase("WithDate WithDetails", true,  true)]
        public void NoMatch(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passPastDate = (bool)self.MyValues[0];
            bool passDetailsFlag = (bool)self.MyValues[1];

            UserEditor user = UserEditor.CreateNew();

            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Gamertag, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("MatchOld NoDate NoDetails",         false, null, false)]
        [CompoundCase("MatchOld DateAfterAll NoDetails",   false, 0,    false)]
        [CompoundCase("MatchOld DateAfterOne NoDetails",   false, 2,    false)]
        [CompoundCase("MatchOld DateAfterTwo NoDetails",   false, 4,    false)]
        [CompoundCase("MatchNew NoDate NoDetails",         true,  null, false)]
        [CompoundCase("MatchNew DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("MatchNew DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("MatchNew DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("MatchOld NoDate WithDetails",       false, null, true)]
        [CompoundCase("MatchOld DateAfterAll WithDetails", false, 0,    true)]
        [CompoundCase("MatchOld DateAfterOne WithDetails", false, 2,    true)]
        [CompoundCase("MatchOld DateAfterTwo WithDetails", false, 4,    true)]
        [CompoundCase("MatchNew NoDate WithDetails",       true,  null, true)]
        [CompoundCase("MatchNew DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("MatchNew DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("MatchNew DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            bool matchOnNewGamertag = (bool)self.MyValues[0];
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor userA = UserEditor.CreateNew();
            UserEditor userB = UserEditor.CreateNew();
            UserEditor userC = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(userA.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userA.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, userA.Gamertag, userC.Gamertag, 1, useSecUHDB));
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userA.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, userC.Gamertag, userB.Gamertag, 2, useSecUHDB));

            string gamertagToPass = (matchOnNewGamertag ? userB.Gamertag : userA.Gamertag);
            System.DateTime ?sinceDate = (dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(gamertagToPass, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("{0}Match NoDetails DifferentMachines",   0, false, true)]
        [CompoundCase("{0}Match NoDetails DifferentMachines",   1, false, true)]
        [CompoundCase("{0}Match NoDetails DifferentMachines",   2, false, true)]
        [CompoundCase("{0}Match NoDetails DifferentMachines",   3, false, true)]
        [CompoundCase("{0}Match WithDetails DifferentMachines", 0, true,  true)]
        [CompoundCase("{0}Match WithDetails DifferentMachines", 1, true,  true)]
        [CompoundCase("{0}Match WithDetails DifferentMachines", 2, true,  true)]
        [CompoundCase("{0}Match WithDetails DifferentMachines", 3, true,  true)]
        [CompoundCase("{0}Match WithDetails SameMachine",       0, true,  false)]
        [CompoundCase("{0}Match WithDetails SameMachine",       1, true,  false)]
        [CompoundCase("{0}Match WithDetails SameMachine",       2, true,  false)]
        [CompoundCase("{0}Match WithDetails SameMachine",       3, true,  false)]
        public void SixRowsDifferentUsers(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            int numberMatch = (int)self.MyValues[0];
            bool passDetailsFlag = (bool)self.MyValues[1];
            bool differentMachines = (bool)self.MyValues[2];

            UserEditor userA=UserEditor.CreateNew(); //seen on 0
            UserEditor userB=UserEditor.CreateNew(); //seen on 1
            UserEditor userC=UserEditor.CreateNew(); //seen on 2
            UserEditor userD=UserEditor.CreateNew(); //seen on 3
            UserEditor userE=UserEditor.CreateNew(); //filler
            UserEditor []userMatchCountIndex = new UserEditor[]{userA, userB, userC, userD};
            MachineEditor []machs;
            if (differentMachines)
            {
                machs = new MachineEditor[]{MachineEditor.CreateNew(), MachineEditor.CreateNew(), MachineEditor.CreateNew(), MachineEditor.CreateNew(), MachineEditor.CreateNew(), MachineEditor.CreateNew()};
            }
            else
            {
                MachineEditor mach = MachineEditor.CreateNew();
                machs = new MachineEditor[]{mach, mach, mach, mach, mach, mach};
            }

            UserGamertagHistoryEditor ugheB = UserGamertagHistoryEditor.FromUserPuid(userB.Puid, useSecUHDB);
            ugheB.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userB.Puid, machs[0].Id, "1.1.1.1", now-new System.TimeSpan(0, 0, 1), 0x80000001, userB.Gamertag, userE.Gamertag, 1, useSecUHDB));

            UserGamertagHistoryEditor ugheC = UserGamertagHistoryEditor.FromUserPuid(userC.Puid, useSecUHDB);
            ugheC.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userC.Puid, machs[1].Id, "1.1.1.2", now-new System.TimeSpan(0, 0, 2), 0x80000007, userC.Gamertag, userC.Gamertag, 3, useSecUHDB));
            ugheC.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userC.Puid, machs[2].Id, "1.1.1.3", now-new System.TimeSpan(0, 0, 5), 0x80000006, userD.Gamertag, userE.Gamertag, 2, useSecUHDB));

            UserGamertagHistoryEditor ugheD = UserGamertagHistoryEditor.FromUserPuid(userD.Puid, useSecUHDB);
            ugheD.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userD.Puid, machs[3].Id, "1.1.1.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, userE.Gamertag, userC.Gamertag, 1, useSecUHDB));
            ugheD.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userD.Puid, machs[4].Id, "1.1.1.5", now-new System.TimeSpan(0, 0, 4), 0x80000006, userD.Gamertag, null, 2, useSecUHDB));
            ugheD.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userD.Puid, machs[5].Id, "1.1.1.6", now-new System.TimeSpan(0, 0, 3), 0x80000005, null, userD.Gamertag, 3, useSecUHDB));

            CallAndVerify(userMatchCountIndex[numberMatch].Gamertag, null, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Pass a weird value for gamertag.")]
        [CompoundCase("null", null,                         "Gamertag cannot be null or empty")]
        [CompoundCase("EmptyString", "",                    "Gamertag cannot be null or empty")]
        [CompoundCase("TooLongString", "ThisIsJustTooLong", "Gamertag too long")]
        public void BadGamertag(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            string gamertagToPass = (string)self.MyValues[0];
            string expectedSoapError = (string)self.MyValues[1];

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate{CallAndVerify(gamertagToPass, null, true, useSecUHDB);}, expectedSoapError);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //User puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird machine puids.")]
            [CompoundCase("null",    null)]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void MachinePuids(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);

                UserEditor user = UserEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, user.Gamertag, user.Gamertag, 1, useSecUHDB));

                CallAndVerify(user.Gamertag, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string ipAddress = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, user.Gamertag, user.Gamertag, 1, useSecUHDB));

                CallAndVerify(user.Gamertag, null, true, useSecUHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                byte reason = (byte)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, user.Gamertag, user.Gamertag, reason, useSecUHDB));

                CallAndVerify(user.Gamertag, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird gamertags in the db.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("MaxSize", "STFU0123456789AB")]
            public void Gamertags(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string gamertags = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, user.Gamertag, gamertags, 1, useSecUHDB));

                CallAndVerify(user.Gamertag, null, true, useSecUHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            for (int i=0; i<1000; ++i)
            {
                ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, user.Gamertag, user.Gamertag, (byte)(i%10+1), useSecUHDB));
            }

            CallAndVerify(user.Gamertag, null, true, useSecUHDB);
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserGamertagHistoryEditor ughe = UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "A", "B", 1, useSecUHDB));

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{GamertagHistoryGetByGamertagVerbose(user.Gamertag, null, true, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\MachineFriendlyNameSet.cs ===
using System;
using System.ServiceModel;

using XUserTests;
using xonline.common.service;
using xonline.xuser.soap;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    class MachineFriendlyNameSet: TestNode
    {
        public static void MachineFriendlyNameSetVerbose(ulong userPuid, ulong machinePuid, string friendlyName, XUserTestSoapClient client)
        {
            if (client==null)
            {
                client=new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling MachineFriendlyNameSet: userPuid="+string.Format("0x{0:X}", userPuid)+" machinePuid="+string.Format("0x{0:X}", machinePuid)+" friendlyName="+friendlyName);
            client.MachineFriendlyNameSet(userPuid, true, machinePuid, true, friendlyName);
            Global.RO.Debug("MachineFriendlyNameSet returned.");
        }

        public static void MachineFriendlyNameSetVerbose(ulong userPuid, ulong machinePuid, string friendlyName)
        {
            MachineFriendlyNameSetVerbose(userPuid, machinePuid, friendlyName, null);
        }

        // --

        [TestCase, Description("Valid mainline case.  Auth with internal claim.  Updating an existing history record with a regular name.")]
        public void MainlineInternalClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
            MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName);

            ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
        }

        [TestCase, Description("Valid mainline case.  Auth with user claim.  Updating an existing history record with a regular name.")]
        public void MainlineUserClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});

            string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
            MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName, client);

            ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
        }

        [TestCase, Description("User does not have an existing history entry.  XUser should create one in that case.")]
        public void NoPreviousHistory()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
            MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName);

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(user.Puid, mach.Id);
            ValueCheck.Test("History entry was created", true, umh.Exists);
            ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
            ValueCheck.TestDifferent("HashBucket for new history entry", 0, umh.HashBucket);
        }

        [TestCase, Description("Create history for different machine platforms.")]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void Platforms(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(mtype);
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
            MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName);

            ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
        }

        [TestCase, Description("Tests for various name lengths.")]
        [CompoundCase("Zero",        0,  true)]
        [CompoundCase("One",         1,  true)]
        [CompoundCase("MaxMinusOne", 63, true)]
        [CompoundCase("Max",         64, true)]
        [CompoundCase("MaxPlusOne",  65, false)]
        public void NameLength(TestNode self)
        {
            int nameLength=(int)self.MyValues[0];
            bool shouldWork=(bool)self.MyValues[1];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            string friendlyName=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(nameLength);

            if (shouldWork)
            {
                MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName);
                ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
            }
            else
            {
                string origName=umh.FriendlyName;
                XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName);
                },
                    "Invalid friendly name");

                ValueCheck.Test("Machine friendly name in DB", origName, umh.FriendlyName);
            }
        }

        [TestCase, Description("Pass null for friendly name.")]
        public void NameNull()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            MachineFriendlyNameSetVerbose(user.Puid, mach.Id, null);

            ValueCheck.Test("Machine friendly name in DB", (string)null, umh.FriendlyName);
        }

        [TestCase, Description("User does not exist.  Should fail.")]
        public void UserDoesNotExist()
        {
            ulong userPuid=UserEditor.AllocatePuid();
            MachineEditor mach=MachineEditor.CreateNew();

            string friendlyName=userPuid+" on "+mach.ConsoleId;
            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                MachineFriendlyNameSetVerbose(userPuid, mach.Id, friendlyName);
            },
                "Error setting friendly name for user");

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(userPuid, mach.Id);
            ValueCheck.Test("History entry was created", false, umh.Exists);
        }

        [TestCase, Description("Machine does not exist.  There is no foreign key constraint for machine, so it is allowed.")]
        public void MachineDoesNotExist()
        {
            UserEditor user=UserEditor.CreateNew();
            ulong machPuid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);

            string friendlyName=user.Gamertag+" on "+machPuid;
            MachineFriendlyNameSetVerbose(user.Puid, machPuid, friendlyName);

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(user.Puid, machPuid);
            ValueCheck.Test("History entry was created", true, umh.Exists);
            ValueCheck.Test("Machine friendly name in DB", friendlyName, umh.FriendlyName);
        }

        [TestCase, Description("No authorization header is provided.")]
        public void NoAuthHeader()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            string originalName=umh.FriendlyName;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.AllowAuthHeaderToBeAdded=false;

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
                MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName, client);
            });

            ValueCheck.Test("Machine friendly name in DB", originalName, umh.FriendlyName);
        }

        [TestCase, Description("No claims in the xauthdata.")]
        public void NoClaims()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            string originalName=umh.FriendlyName;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                string friendlyName=user.Gamertag+" on "+mach.ConsoleId;
                MachineFriendlyNameSetVerbose(user.Puid, mach.Id, friendlyName, client);
            });

            ValueCheck.Test("Machine friendly name in DB", originalName, umh.FriendlyName);
        }

        [TestCase, Description("XAuthdata contains the wrong user in the claim.")]
        public void WrongUserInClaim()
        {
            UserEditor userForCall=UserEditor.CreateNew();
            UserEditor userForClaim=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            UserMachineHistoryEditor umhCall=UserMachineHistoryEditor.CreateOrUseExisting(userForCall.Puid, mach.Id);
            UserMachineHistoryEditor umhClaim=UserMachineHistoryEditor.CreateOrUseExisting(userForClaim.Puid, mach.Id);

            string origCallName=umhCall.FriendlyName;
            string origClaimName=umhClaim.FriendlyName;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userForClaim.Puid)});

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                string friendlyName=userForCall.Gamertag+" on "+mach.ConsoleId;
                MachineFriendlyNameSetVerbose(userForCall.Puid, mach.Id, friendlyName, client);
            });

            ValueCheck.Test("Machine friendly name in DB for caller user puid", origCallName, umhCall.FriendlyName);
            ValueCheck.Test("Machine friendly name in DB for claim user puid", origClaimName, umhClaim.FriendlyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\MachineTrustLevelSet.cs ===
using System;
using System.ServiceModel;
using XUserTests;

using xonline.common.service;
using xonline.xuser.soap;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    class MachineTrustLevelSet: TestNode
    {
        public static void MachineTrustLevelSetVerbose(ulong userPuid, ulong machinePuid, MachineTrustLevel trustLevel, XUserTestSoapClient client)
        {
            if (client==null)
            {
                client=new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling MachineTrustLevelSet: userPuid="+string.Format("0x{0:X}", userPuid)+" machinePuid="+string.Format("0x{0:X}", machinePuid)+" trustLevel="+trustLevel);
            client.MachineTrustLevelSet(userPuid, true, machinePuid, true, trustLevel, true);
            Global.RO.Debug("MachineTrustLevelSet returned.");
        }

        public static void MachineTrustLevelSetVerbose(ulong userPuid, ulong machinePuid, MachineTrustLevel trustLevel)
        {
            MachineTrustLevelSetVerbose(userPuid, machinePuid, trustLevel, null);
        }

        // --

        [TestCase, Description("Valid mainline case.  Auth with internal claim.  Updating an existing history record.  Demoting trust can be done with the internal claim.")]
        public void MainlineInternalClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            umh.TrustLevel=1;

            MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Untrusted);

            ValueCheck.Test("Machine trust level in DB", 0, umh.TrustLevel);
        }

        [TestCase, Description("Valid mainline case.  Auth with user claim.  Updating an existing history record.  Demoting trust can be done with only a user claim (does not require a machine claim)")]
        public void MainlineUserClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            umh.TrustLevel=1;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});

            MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Untrusted, client);

            ValueCheck.Test("Machine trust level in DB", 0, umh.TrustLevel);
        }

        [TestCase, Description("User does not have an existing history entry.  XUser should create one in that case.")]
        public void NoPreviousHistory()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted);

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(user.Puid, mach.Id);
            ValueCheck.Test("History entry was created", true, umh.Exists);
            ValueCheck.Test("Machine trust level in DB", 1, umh.TrustLevel);
            ValueCheck.TestDifferent("HashBucket for new history entry", 0, umh.HashBucket);
        }

        [TestCase, Description("Create history for different machine platforms.")]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void Platforms(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew(mtype);
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);

            MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted);

            ValueCheck.Test("Machine trust level in DB", 1, umh.TrustLevel);
        }

        [TestCase, Description("Attempt to set various trust levels.")]
        [CompoundCase("{0}", MachineTrustLevel.Trusted)]
        [CompoundCase("{0}", MachineTrustLevel.Untrusted)]
        public void ValidTrustLevels(TestNode self)
        {
            MachineTrustLevel level=(MachineTrustLevel)self.MyValues[0];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            umh.TrustLevel=999; //just need something different than the tests will ever set, so we can validate that it changed

            MachineTrustLevelSetVerbose(user.Puid, mach.Id, level);

            int levelAsInt=XUserTestUtil.TranslateSoapEnumTrustLevel(level);
            ValueCheck.Test("Machine trust level in DB", levelAsInt, umh.TrustLevel);
        }

        [TestCase, Description("Attempt to set various invalid trust levels.")]
        [CompoundCase("{0}", MachineTrustLevel.Unknown)] //Valid enum, but you may not set your machine to unknown.  Unknown was a temporary transitional state.
        public void InvalidTrustLevels(TestNode self)
        {
            MachineTrustLevel level=(MachineTrustLevel)self.MyValues[0];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            umh.TrustLevel=999; //just need something different than the tests will ever set, so we can validate that it changed

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                MachineTrustLevelSetVerbose(user.Puid, mach.Id, level);
            },
                "Invalid trust level");

            ValueCheck.Test("Machine trust level in DB", 999, umh.TrustLevel);
        }

        [TestCase, Description("Promoting a machine to trusted requires either an internal claim or a user+machine claim.")]
        [CompoundCase("InternalClaim",    false, false, false, true)]
        [CompoundCase("UserClaim",        true,  true,  false, false)]
        [CompoundCase("MachineClaim",     true,  false, true,  false)]
        [CompoundCase("UserMachineClaim", true,  true,  true,  true)]
        public void TrustPromotion(TestNode self)
        {
            bool replaceClaims=(bool)self.MyValues[0]; //default is internal claim unless we replace it
            bool includeUserClaim=(bool)self.MyValues[1];
            bool includeMachineClaim=(bool)self.MyValues[2];
            bool shouldWork=(bool)self.MyValues[3];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            umh.TrustLevel=0;

            XUserTestSoapClient client=new XUserTestSoapClient();
            if (replaceClaims)
            {
                System.Collections.Generic.List<Microsoft.IdentityModel.Claims.Claim> claimsList=new System.Collections.Generic.List<Microsoft.IdentityModel.Claims.Claim>();

                if (includeUserClaim)
                {
                    claimsList.Add(AuthTestHelper.MakeUserPuidClaim(user.Puid));
                }

                if (includeMachineClaim)
                {
                    claimsList.Add(AuthTestHelper.MakeMachinePuidClaim(mach.Id));
                }

                client.ReplaceXAuthdataClaims(claimsList.ToArray());
            }

            if (shouldWork)
            {
                MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted, client);
                ValueCheck.Test("Machine trust level in DB", 1, umh.TrustLevel);
            }
            else
            {
                try
                {
                    MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted, client);
                    throw new UnexpectedTestResultException("Request unexpectedly succeeded.");
                }
                catch (System.Net.WebException e)
                {
                    Global.RO.Debug("Got expected exception: "+e.Message);
                }
                catch (System.Web.Services.Protocols.SoapException e)
                {
                    Global.RO.Debug("Got expected exception: "+e.Message);
                }

                ValueCheck.Test("Machine trust level in DB", 0, umh.TrustLevel);
            }
        }

        [TestCase, Description("User does not exist.  Should fail.")]
        public void UserDoesNotExist()
        {
            ulong userPuid=UserEditor.AllocatePuid();
            MachineEditor mach=MachineEditor.CreateNew();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                MachineTrustLevelSetVerbose(userPuid, mach.Id, MachineTrustLevel.Trusted);
            },
                "Error setting trust level for user");

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(userPuid, mach.Id);
            ValueCheck.Test("History entry was created", false, umh.Exists);
        }

        [TestCase, Description("Machine does not exist.  There is no foreign key constraint for machine, so it is allowed.")]
        public void MachineDoesNotExist()
        {
            UserEditor user=UserEditor.CreateNew();
            ulong machPuid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);

            MachineTrustLevelSetVerbose(user.Puid, machPuid, MachineTrustLevel.Trusted);

            UserMachineHistoryEditor umh=UserMachineHistoryEditor.FromId(user.Puid, machPuid);
            ValueCheck.Test("History entry was created", true, umh.Exists);
            ValueCheck.Test("Machine trust level in DB", 1, umh.TrustLevel);
        }

        [TestCase, Description("No authorization header is provided.")]
        public void NoAuthHeader()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            int originalTrust=umh.TrustLevel;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.AllowAuthHeaderToBeAdded=false;

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted, client);
            });

            ValueCheck.Test("Machine trust level in DB", originalTrust, umh.TrustLevel);
        }

        [TestCase, Description("No claims in the xauthdata.")]
        public void NoClaims()
        {
            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();
            UserMachineHistoryEditor umh=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            int originalTrust=umh.TrustLevel;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                MachineTrustLevelSetVerbose(user.Puid, mach.Id, MachineTrustLevel.Trusted, client);
            });

            ValueCheck.Test("Machine trust level in DB", originalTrust, umh.TrustLevel);
        }

        [TestCase, Description("XAuthdata contains the wrong user in the claim.")]
        public void WrongUserInClaim()
        {
            UserEditor userForCall=UserEditor.CreateNew();
            UserEditor userForClaim=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            UserMachineHistoryEditor umhCall=UserMachineHistoryEditor.CreateOrUseExisting(userForCall.Puid, mach.Id);
            UserMachineHistoryEditor umhClaim=UserMachineHistoryEditor.CreateOrUseExisting(userForClaim.Puid, mach.Id);

            int originalTrustCall=umhCall.TrustLevel;
            int originalTrustClaim=umhClaim.TrustLevel;

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userForClaim.Puid)});

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                MachineTrustLevelSetVerbose(userForCall.Puid, mach.Id, MachineTrustLevel.Trusted, client);
            });

            ValueCheck.Test("Machine trust level in DB for call user", originalTrustCall, umhCall.TrustLevel);
            ValueCheck.Test("Machine trust level in DB for claim user", originalTrustClaim, umhClaim.TrustLevel);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\HistoryCommon.cs ===
using xonline.common.service;
using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

//!NOTE: This file is copied straight from the XMachine tests.  At some point we should consider finding a common place for this instead of copying it...

namespace XUserTests
{
    /// <summary> Represents a group of tests than need to be tested with the database double write enabled/disabled.  Sets the XUser double write setting and then reloads the config on the service. </summary>
    public class GreaterDoubleWriteTestGroup: TestNode
    {
        private bool enabled;
        private SettingState doubleWriteSetting=null;

        public override void PreRun()
        {
            enabled=(bool)MyValues[0];
            doubleWriteSetting=Global.XEnv.OverrideSetting("ALL", "ALL", xonline.common.config.Setting.xuser_doubleWriteHistory, enabled.ToString());

            CreateContextData();
            SetContextData("DoubleWriteEnabled", enabled);

            XUserTestUtil.ReloadConfig();
        }

        public override void PostRun()
        {
            if (doubleWriteSetting!=null)
            {
                Global.XEnv.RestoreOverrideSettingState(doubleWriteSetting);
                doubleWriteSetting=null;

                XUserTestUtil.ReloadConfig();
            }
        }

        protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
        {
            instances.Add(new CompoundCaseAttribute("DoubleWriteEnabled", true));
            instances.Add(new CompoundCaseAttribute("DoubleWriteDisabled", false));
        }

        public static bool IsDoubleWrite(TestNode node)
        {
            return (bool)node.GetContextData("DoubleWriteEnabled");
        }
    }

    // --

    public class HistoryCommon: TestNode
    {
        public static ulong TruncateXboxComMachinePuid(ulong puid)
        {
            return (ulong)TruncateXboxComMachinePuid((ulong?)puid);
        }

        public static ulong? TruncateXboxComMachinePuid(ulong ?puid)
        {
            if (puid==null)
            {
                return null;
            }
            else if ((((ulong)puid)&0xffff000000000000)==0xffed000000000000)
            {
                return 0xffed000000000000;
            }
            else
            {
                return puid;
            }
        }

        public static bool NullableDatetimeEquals(System.DateTime ?left, System.DateTime ?right, int tolleranceInMs)
        {
            if (left==null || right==null)
            {
                return (left==right);
            }
            else
            {
                return System.Math.Abs(((System.DateTime)left-(System.DateTime)right).TotalMilliseconds)<=tolleranceInMs;
            }
        }

        // --

        public static string HistorySummaryStringer(HistorySummary hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "HistorySummary(First="+hist.First+" Last="+hist.Last+" Total="+hist.Total+" Unique="+hist.Unique+")";
        }

        public static string HistorySummaryStringer(object hist)
        {
            if (hist is HistorySummary)
            {
                return HistorySummaryStringer((HistorySummary)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool HistorySummaryEquals(HistorySummary left, HistorySummary right)
        {
            return NullableDatetimeEquals(left.First, right.First, 1) &&
                NullableDatetimeEquals(left.Last, right.Last, 1) &&
                left.Total==right.Total &&
                left.Unique==right.Unique;
        }

        // --

        public static string HistoryDetailsStringer(HistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "HistoryDetails(UserPuid="+string.Format("0x{0:X}", hist.UserPuid)+" MachinePuid="+string.Format("0x{0:X}", hist.MachinePuid)+" IpAddress="+hist.IpAddress+" Timestamp="+hist.Timestamp+" Result="+string.Format("0x{0:X}", hist.Result)+" Reason="+(int)hist.Reason+/*" Details="+hist.Details+*/")";
        }

        public static string HistoryDetailsStringer(object hist)
        {
            if (hist is HistoryDetails)
            {
                return HistoryDetailsStringer((HistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool HistoryDetailsEquals(HistoryDetails left, HistoryDetails right)
        {
            return left.UserPuid==right.UserPuid &&
                left.MachinePuid==right.MachinePuid &&
                left.IpAddress==right.IpAddress &&
                NullableDatetimeEquals(left.Timestamp, right.Timestamp, 1) &&
                left.Result==right.Result &&
                left.Reason==right.Reason; // &&
                //left.Details==right.Details;
        }

        // --

        public static string GamertagHistoryDetailsStringer(GamertagHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "GamertagHistoryDetails(OldGamertag="+hist.OldGamertag+" NewGamertag="+hist.NewGamertag+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string GamertagHistoryDetailsStringer(object hist)
        {
            if (hist is GamertagHistoryDetails)
            {
                return GamertagHistoryDetailsStringer((GamertagHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool GamertagHistoryDetailsEquals(GamertagHistoryDetails left, GamertagHistoryDetails right)
        {
            return left.OldGamertag==right.OldGamertag &&
                left.NewGamertag==right.NewGamertag &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string GamertagHistoryStringer(GamertagHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "GamertagHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", GamertagHistoryDetailsStringer)+"))";
        }

        public static string GamertagHistoryStringer(object hist)
        {
            if (hist is GamertagHistory)
            {
                return GamertagHistoryStringer((GamertagHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyGamertagHistory(GamertagHistory expect, GamertagHistory got)
        {
            ValueCheck.TestAllUnordered("GamertagHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("GamertagHistory.Details", expect.Details, got.Details, HistoryCommon.GamertagHistoryDetailsEquals, HistoryCommon.GamertagHistoryDetailsStringer);
        }

        // --

        public static string PassportHistoryDetailsStringer(PassportHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "PassportHistoryDetails(OldPassportPuid="+string.Format("0x{0:X}", hist.OldPassportPuid)+" NewPassportPuid="+string.Format("0x{0:X}", hist.NewPassportPuid)+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string PassportHistoryDetailsStringer(object hist)
        {
            if (hist is PassportHistoryDetails)
            {
                return PassportHistoryDetailsStringer((PassportHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool PassportHistoryDetailsEquals(PassportHistoryDetails left, PassportHistoryDetails right)
        {
            return left.OldPassportPuid==right.OldPassportPuid &&
                left.NewPassportPuid==right.NewPassportPuid &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string PassportHistoryStringer(PassportHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "PassportHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", PassportHistoryDetailsStringer)+"))";
        }

        public static string PassportHistoryStringer(object hist)
        {
            if (hist is PassportHistory)
            {
                return PassportHistoryStringer((PassportHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyPassportHistory(PassportHistory expect, PassportHistory got)
        {
            ValueCheck.TestAllUnordered("PassportHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("PassportHistory.Details", expect.Details, got.Details, HistoryCommon.PassportHistoryDetailsEquals, HistoryCommon.PassportHistoryDetailsStringer);
        }

        // --

        public static string RecoveryHistoryDetailsStringer(RecoveryHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "RecoveryHistoryDetails(PassportPuid="+string.Format("0x{0:X}", hist.PassportPuid)+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string RecoveryHistoryDetailsStringer(object hist)
        {
            if (hist is RecoveryHistoryDetails)
            {
                return RecoveryHistoryDetailsStringer((RecoveryHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool RecoveryHistoryDetailsEquals(RecoveryHistoryDetails left, RecoveryHistoryDetails right)
        {
            return left.PassportPuid==right.PassportPuid &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string RecoveryHistoryStringer(RecoveryHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "RecoveryHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", RecoveryHistoryDetailsStringer)+"))";
        }

        public static string RecoveryHistoryStringer(object hist)
        {
            if (hist is RecoveryHistory)
            {
                return RecoveryHistoryStringer((RecoveryHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyRecoveryHistory(RecoveryHistory expect, RecoveryHistory got)
        {
            ValueCheck.TestAllUnordered("RecoveryHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("RecoveryHistory.Details", expect.Details, got.Details, HistoryCommon.RecoveryHistoryDetailsEquals, HistoryCommon.RecoveryHistoryDetailsStringer);
        }
    }

    // --

    public abstract class LogAccumulatorAndCaller<CallType, DbType>
    {
        private System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.List<DbType>> expectedLogs=new System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.List<DbType>>();

        public abstract DbType ConvertCallTypeToDbType(CallType log);
        public abstract DbType[] GetActualRowsFromDb(ulong userPuid, bool hitSecHistoryDbInsteadOfUodb);
        public abstract ulong GetUserPuid(CallType log);
        public abstract ulong GetUserPuid(DbType log);
        public abstract void SetHashBucket(DbType log, short bucket);

        public delegate void CallDelegate(CallType data);
        public void CallAndAccumulate(CallDelegate method, CallType data)
        {
            ulong userPuid=0;
            if (data!=null)
            {
                userPuid=GetUserPuid(data);

                if (!expectedLogs.ContainsKey(userPuid))
                {
                    expectedLogs.Add(userPuid, new System.Collections.Generic.List<DbType>());
                }
            }

            method(data);

            //db should only be written to if the call succeeded

            if (data!=null)
            {
                expectedLogs[userPuid].Add(ConvertCallTypeToDbType(data));
            }
        }

        public void Verify(bool isDoubleWriteEnabled)
        {
            foreach (ulong userPuid in expectedLogs.Keys)
            {
                DbType []actualLogsInUodb=GetActualRowsFromDb(userPuid, false);
                DbType []actualLogsInSecHistoryDb=GetActualRowsFromDb(userPuid, true);

                Global.RO.Debug("Rows for user 0x"+string.Format("{0:X}", userPuid)+" in Uodb: "+actualLogsInUodb.Length);
                Global.RO.Debug("Rows for user 0x"+string.Format("{0:X}", userPuid)+" in SecUserHistoryDb: "+actualLogsInSecHistoryDb.Length);

                if (isDoubleWriteEnabled)
                {
                    FixHashBucket(expectedLogs[userPuid], false);
                    ValueCheck.TestAllUnordered<DbType>("Rows in Uodb for user 0x"+string.Format("{0:X}", userPuid), expectedLogs[userPuid], actualLogsInUodb);
                    FixHashBucket(expectedLogs[userPuid], true);
                    ValueCheck.TestAllUnordered<DbType>("Rows in SecUserHistoryDb for user 0x"+string.Format("{0:X}", userPuid), expectedLogs[userPuid], actualLogsInSecHistoryDb);
                }
                else
                {
                    FixHashBucket(expectedLogs[userPuid], false);
                    ValueCheck.TestAllUnordered<DbType>("Rows in Uodb for user 0x"+string.Format("{0:X}", userPuid), new DbType[0], actualLogsInUodb);
                    FixHashBucket(expectedLogs[userPuid], true);
                    ValueCheck.TestAllUnordered<DbType>("Rows in SecUserHistoryDb for user 0x"+string.Format("{0:X}", userPuid), expectedLogs[userPuid], actualLogsInSecHistoryDb);
                }
            }
        }

        private void FixHashBucket(System.Collections.Generic.IEnumerable<DbType> entries, bool forSecHistoryDbInsteadOfUodb)
        {
            foreach (DbType dbt in entries)
            {
                ulong userPuid=GetUserPuid(dbt);
                if (forSecHistoryDbInsteadOfUodb)
                {
                    SetHashBucket(dbt, (short)WebstoreDB.GetHashBucket(xonline.common.config.ConfigUtil.SecUserHistoryWebstoreApp, userPuid));
                }
                else
                {
                    SetHashBucket(dbt, (short)UodbWS.GetHashBucket(userPuid));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\MachineGet.cs ===
using System;
using XUserTests;
using xonline.common.service;
using xonline.xuser.soap;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using System.ServiceModel;

namespace XUserTests
{
    [TestGroup, Owner("WisgT"), TestCasePriority(1)]
    class MachineGet : XUserTestGroup
    {

        [TestCase, Description("Verifies functionality for a user on one console")]
        public void SingleMachineFromPuid()
        {

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory("XE.067303653001", "XUser1Machin");

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);
            
        }

        [TestCase, Description("Attempts to get a machine list for a user not in the XSTS header")]
        public void SingleMachineUserPuidNotInSTS()
        {

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory("XE.067303653001", "XUser1Machin");
            UserMachineHistoryEditor ume2 = XUserTestUtil.CreateUserMachineHistory("XE.067303653002", "XUser2Machin");
            xonline.xuser.soap.UserMachine[] machines;
            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            try
            {
                machines = client.MachineGet(ume.UserPuid, null, null, null, ume2.UserPuid, null);
                throw new UnexpectedTestResultException("MachineGet should have thrown System.Net.WebException");
            }
            catch (System.Net.WebException)
            {
            }

        }

        [TestCase, Description("Attempts to get a machine list with NO XSTS header")]
        public void SingleMachineUserPuidNoSTS()
        {

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory("XE.067303653001", "XUser1Machin");
            UserMachineHistoryEditor ume2 = XUserTestUtil.CreateUserMachineHistory("XE.067303653002", "XUser2Machin");
            xonline.xuser.soap.UserMachine[] machines;
            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            try
            {
                machines = client.MachineGet(ume.UserPuid, true, null, false, null, null, false);
                throw new UnexpectedTestResultException("MachineGet should have thrown System.Net.WebException");
            }
            catch (System.Net.WebException)
            {
            }

        }


        [TestCase, Description("Verifies functionality for no consoles")]
        public void MachineGetPuidNoMachinesTest()
        {
            Puid puid = XUserTestUtil.CreateUser();
            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet((ulong)puid, null, null, null);
            if (machines.Length != 0)
            {
                throw new ExpectedNotValueCheckException(
                    string.Format("Expected 0 result from MachineGet got: {0}", machines.Length));
            }
        }

        [TestCase, Description("Verifies a user on multiple consoles")]
        public void MultipleMachinesFromPuid()
        {
            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(100000, 10);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[0].UserPuid, null, null, null);
            if (machines.Length != 10)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 10 results from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.VerifyMachines(machines, umes);
        }

        [TestCase, Description("Verifies FirstSign is correctly updated when dt_first_signin is updated")]
        public void NonNullFirstSignin()
        {
            // We want a fresh machine that has a NULL in the dt_first_signin
            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length > 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);

            ume.FirstSignin = DateTime.Now.AddDays(-5);
            machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);

            
        }

        [TestCase, Description("Verifies LastSign is correctly updated when dt_last_signin is updated")]
        public void NonNullLastSignin()
        {

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);

            ume.LastSignin = DateTime.Now.AddDays(-2);
            machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);

            
        }

        [TestCase, Description("Verifies functionality for Machine Puid Lookup")]
        public void mPuidValid()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(110000, 5);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[0].UserPuid, umes[0].MachinePuid, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], umes[0]);
            
        }

        [TestCase, Description("Verifies functionality for Machine Puid Lookup")]
        public void MPuid0Valid()
        {
            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(110000, 5);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[0].UserPuid, ume.MachinePuid, null, null);
            if (machines.Length != 0)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            
        }

        [TestCase, Description("Verifies functionality for Machine Friendly Lookup")]
        public void FriendlyName1Valid()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(120000, 5, true);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[1].UserPuid, null, umes[3].FriendlyName, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], umes[3]);
            
        }

        [TestCase, Description("Verifies functionality for Machine Friendly Lookup no results")]
        public void FriendlyName0Valid()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(120000, 5, true);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[1].UserPuid, null, umes[3].FriendlyName + "a", null);
            if (machines.Length != 0)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            
        }

        [TestCase, Description("Verifies functionality for Machine date Lookup using old schema entries")]
        public void SinceOldSchema()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(0, 10, false);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            // (dt_last_signin > @dt_since OR dt_last_signout > @dt_since)
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[1].UserPuid, null, null, umes[4].LastSeen);
            if (machines.Length != 5)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 5 result from MachineGet got: {0}", machines.Length));
            }
            //XUserTestUtil.VerifyMachines(machines.A, umes);
            
        }

        [TestCase, Description("Verifies functionality for Machine date Lookup using new schema entries")]
        public void SinceNewSchema()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(0, 10, true);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            // (dt_last_signin > @dt_since OR dt_last_signout > @dt_since)
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[1].UserPuid, null, null, umes[4].LastSignout);
            if (machines.Length != 5)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 5 result from MachineGet got: {0}", machines.Length));
            }
            //XUserTestUtil.VerifyMachines(machines.A, umes);
            
        }

        [TestCase, Description("Verifies functionality for MachineGet with all fields")]
        public void AllFieldsSearch1Valid()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(142000, 10, true);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            // (dt_last_signin > @dt_since OR dt_last_signout > @dt_since)
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[7].UserPuid, umes[7].MachinePuid, umes[7].FriendlyName, umes[4].LastSignout);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            
        }

        [TestCase, Description("Verifies functionality for MachineGet with all fields for no results")]
        public void AllFieldsSearch0Valid()
        {

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(143000, 10, true);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();
            // (dt_last_signin > @dt_since OR dt_last_signout > @dt_since)
            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umes[3].UserPuid, umes[3].MachinePuid, umes[3].FriendlyName, umes[4].LastSignout);
            if (machines.Length != 0)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 0 result from MachineGet got: {0}", machines.Length));
            }
            
        }

        [TestCase, Description("Verifies functionality for a user on one PC")]
        public void SinglePCFromPuid()
        {

            UserEditor ue = UserEditor.CreateNew();
            MachineEditor me = MachineEditor.CreateNew(MachineType.PC);
            UserMachineHistoryEditor ume = UserMachineHistoryEditor.CreateOrUseExisting(ue.Puid, me.Id);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);
            
        }

        [TestCase, Description("Verifies functionality for a user on one PC")]
        public void SinglePhoneFromPuid()
        {

            UserEditor ue = UserEditor.CreateNew();
            MachineEditor me = MachineEditor.CreateNew(MachineType.Phone);
            UserMachineHistoryEditor ume = UserMachineHistoryEditor.CreateOrUseExisting(ue.Puid, me.Id);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);
            
        }

        [TestCase, Description("Verifies functionality for Duplicate consoles")]
        public void DuplicateMachineTest()
        {

            MachineEditor me1 = MachineEditor.CreateNew(MachineType.Xbox360);
            ulong dupePuid2 = XUserTestUtil.CreateDuplicateXbox360Machine(me1.ConsoleId);
            UserEditor ue = UserEditor.CreateNew();
            MachineEditor me2 = MachineEditor.CreateOrUseExistingId(dupePuid2);
            UserMachineHistoryEditor ume = UserMachineHistoryEditor.CreateOrUseExisting(ue.Puid, me1.Id);

            XUserTestSoapClient client = XUserTestUtil.GetUserClient();

            xonline.xuser.soap.UserMachine[] machines = client.MachineGet(ume.UserPuid, null, null, null);
            if (machines.Length != 1)
            {
                throw new ExpectedValueCheckException(
                        string.Format("Expected 1 result from MachineGet got: {0}", machines.Length));
            }
            XUserTestUtil.PrintMachines(machines);
            XUserTestUtil.VerifyMachine(machines[0], ume);
            me1.CompletelyRemoveMachine();
            me2.CompletelyRemoveMachine();
            
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\GamerTagHistoryLog.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.xuser.soap;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class GamertagHistoryLog : GreaterDoubleWriteTestGroup
    {
        public static void GamertagHistoryLogVerbose(GamertagHistoryDetails gthd, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling GamertagHistoryLog: gthd=" + HistoryCommon.GamertagHistoryDetailsStringer(gthd));
            client.GamertagHistoryLog(gthd);
            Global.RO.Debug("GamertagHistoryLog returned.");
        }

        public static void GamertagHistoryLogVerbose(GamertagHistoryDetails gthd)
        {
            GamertagHistoryLogVerbose(gthd, null);
        }

        public class CallAndVerifier : LogAccumulatorAndCaller<GamertagHistoryDetails, UserGamertagHistoryEditor.UserGamertagHistoryEntry>
        {
            public override UserGamertagHistoryEditor.UserGamertagHistoryEntry ConvertCallTypeToDbType(GamertagHistoryDetails log)
            {
                return new UserGamertagHistoryEditor.UserGamertagHistoryEntry
                {
                    UserPuid    = log.UserPuid,
                    MachinePuid = HistoryCommon.TruncateXboxComMachinePuid(log.MachinePuid),
                    IpAddress   = log.IpAddress,
                    TimeStamp   = log.Timestamp,
                    Hr          = log.Result,
                    OldGamertag = log.OldGamertag,
                    NewGamertag = log.NewGamertag,
                    Reason      = (byte)log.Reason,
                    HashBucket  = -1 //recomputed later to be correct
                };
            }

            public override UserGamertagHistoryEditor.UserGamertagHistoryEntry[] GetActualRowsFromDb(ulong userPuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return UserGamertagHistoryEditor.FromUserPuid(userPuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetUserPuid(GamertagHistoryDetails log)
            {
                return log.UserPuid;
            }

            public override ulong GetUserPuid(UserGamertagHistoryEditor.UserGamertagHistoryEntry log)
            {
                return log.UserPuid;
            }

            public override void SetHashBucket(UserGamertagHistoryEditor.UserGamertagHistoryEntry log, short bucket)
            {
                log.HashBucket = bucket;
            }
        }

        //Get a unique puid in the correct range but no actual user created for it
        public static ulong AllocateUserPuid()
        {
            return UserEditor.AllocatePuid();
        }

        //create a user and return their puid
        public static ulong GenerateUserPuid()
        {
            return UserEditor.CreateNew().Puid;
        }

        public static ulong GenerateMachinePuid()
        {
            return MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
        }

        public static GamertagHistoryDetails GenerateDetails(ulong userPuid, ulong? machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, string oldGamertag, string newGamertag)
        {
            UserEditor user = null;

            if (newGamertag == "_" || oldGamertag == "_")
            {
                user = UserEditor.CreateNew();
            }

            // The underscore is just a signal character to use the auto generated gamertag so that we can still pass in null when we want to.
            if (newGamertag == "_")
            {
                newGamertag = user.Gamertag;
            }

            if (oldGamertag == "_")
            {
                string baseGt = newGamertag;
                if (baseGt == null || baseGt.Length < 5)
                {
                    baseGt = user.Gamertag;
                }

                oldGamertag = baseGt.Substring(0, baseGt.Length-4) + "_old";
                if (oldGamertag.Length > 15)
                {
                    oldGamertag = oldGamertag.Substring(oldGamertag.Length-15, 15);
                }
            }

            return new GamertagHistoryDetails
            {
                UserPuid = userPuid,
                MachinePuid = machinePuid,
                IpAddress = ip,
                Timestamp = timestamp,
                Result = hr,
                Reason = reason,
                OldGamertag = oldGamertag,
                NewGamertag = newGamertag,
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are invalid platforms.")]
        [CompoundCase("0x{0:X}", (ulong)0,                  "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)1,                  "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000, "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid")]
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are valid.  XUser only validates the range, not that the machine exists.")]
        [CompoundCase("{0}", MachineType.Xbox1)]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        [CompoundCase("XboxComZero", (ulong)0xffed000000000000)]
        [CompoundCase("XboxComNonzero", (ulong)0xffed0000ffffffff)]
        [CompoundCase("null",    null)]
        public void VariousValidMachinePuids(TestNode self)
        {
            ulong ?machinePuid;
            if (self.MyValues[0] == null)
            {
                machinePuid = null;
            }
            else if (self.MyValues[0] is MachineType)
            {
                machinePuid = MachineEditor.AllocateMachinePuid((MachineType)self.MyValues[0]);
            }
            else
            {
                machinePuid = (ulong)self.MyValues[0];
            }

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}",    (ulong)0,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)1,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)0xFFFFFFFFFFFFFFFF, "UserPuid is invalid")]
        [CompoundCase("ValidRange", null,                      "UserPuid is invalid")]
        public void VariousInvalidUserPuids(TestNode self)
        {
            ulong userPuid = (self.MyValues[0]!=null?(ulong)self.MyValues[0]:AllocateUserPuid());
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(userPuid, GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip = (string)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), ip, System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp = (System.DateTime)MyValues[0];
                string expectedSoapError = (string)MyValues[1];

                GamertagHistoryDetails ghd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", timestamp, 0x80000000, 1, "_", "_");

                CallAndVerifier cav = new CallAndVerifier();
                if (expectedSoapError == null)
                {
                    cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd);
                }
                else
                {
                    XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                        {
                            cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd);
                        },
                        expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult = (uint)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, hresult, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, "_", "_"));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for OldGamertag and NewGamertag.")]
        [CompoundCase("OldGamertag=EmptyString",    "",                 "_",                 null)]
        [CompoundCase("OldGamertag=null",           null,               "_",                 null)]
        [CompoundCase("OldGamertag=MaxValid",      "STFU0123456789A",   "_",                 null)]
        [CompoundCase("OldGamertag=MaxInvalid",    "STFU0123456789AB",  "_",                 null)] //Technically this is also invalid.  However it does fit in the DB... so it was decided to just accept it anyways for now.
        [CompoundCase("OldGamertag=BiggerThanMax", "STFU0123456789ABC", "_",                 "Gamertag too long")]
        [CompoundCase("OldGamertag=LineBreak",      "\n",               "_",                 null)]
        [CompoundCase("NewGamertag=EmptyString",    "_",                "",                  null)]
        [CompoundCase("NewGamertag=null",           "_",                null,                null)]
        [CompoundCase("NewGamertag=MaxValid",       "_",                "STFU0123456789A",   null)]
        [CompoundCase("NewGamertag=MaxInvalid",     "_",                "STFU0123456789AB",  null)] //Technically this is also invalid.  However it does fit in the DB... so it was decided to just accept it anyways for now.
        [CompoundCase("NewGamertag=BiggerThanMax",  "_",                "STFU0123456789ABC", "Gamertag too long")]
        [CompoundCase("BothGamertag=null",          null,               null,                "cannot be null")]
        [CompoundCase("OldGamertag=NewGamertag",    "SameOldAndNew",    "SameOldAndNew",     "NewGamertag and OldGamertag cannot be equal")]
        public void VariousGamertags(TestNode self)
        {
            string gamertagOld = (string)self.MyValues[0];
            string gamertagNew = (string)self.MyValues[1];
            string expectedSoapError = (string)self.MyValues[2];

            GamertagHistoryDetails ghd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, gamertagOld, gamertagNew);

            CallAndVerifier cav = new CallAndVerifier();
            if (expectedSoapError == null)
            {
                cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd);
            }
            else
            {
                XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                    {
                        cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd);
                    },
                    expectedSoapError);
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same user puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong []machinePuid = new ulong[]{GenerateMachinePuid(), GenerateMachinePuid()};
            ulong userPuid = GenerateUserPuid();

            CallAndVerifier cav = new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(GamertagHistoryLogVerbose, GenerateDetails(userPuid, machinePuid[i%2], "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, "_", "_"));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same user puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameUsersSameTime(TestNode self)
        {
            bool isDataTheSame = (bool)self.MyValues[0];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            System.DateTime now = System.DateTime.UtcNow;
            GamertagHistoryDetails ghd1 = GenerateDetails(userPuid, machinePuid, "1.2.3.4", now, 0x80000000, 1, "_", "_");
            GamertagHistoryDetails ghd2 = ghd1;

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd1);

            if (!isDataTheSame)
            {
                ghd2=GenerateDetails(userPuid, machinePuid, "1.2.3.5", now, 0x80000001, 2, "_", "_");
            }

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(GamertagHistoryLogVerbose, ghd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(GamertagHistoryLogVerbose, null);
                },
                "Null parameter: GamertagHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            GamertagHistoryDetails ghd = GenerateDetails(userPuid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_");

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userPuid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{GamertagHistoryLogVerbose(ghd, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\PassportHistoryGet.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class PassportHistoryGet : GreaterDoubleWriteTestGroup
    {
        public static PassportHistory PassportHistoryGetVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling PassportHistoryGet: UserPuid=" + userPuid + ", MachinePuid=" + machinePuid + ", Since=" + since + ", Details=" + details);
            PassportHistory ret = client.PassportHistoryGet((ulong)userPuid, true, (ulong?)machinePuid, true, since, true, details, true);
            Global.RO.Debug("PassportHistoryGet returned: " + HistoryCommon.PassportHistoryStringer(ret));
            return ret;
        }

        public static PassportHistory PassportHistoryGetVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details)
        {
            return PassportHistoryGetVerbose(userPuid, machinePuid, since, details, null);
        }

        public static void ComputeAndVerifyPassportHistory(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, PassportHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a PassportHistory that contains the expected result
            PassportHistory expectedResult = new PassportHistory();

            UserPassportHistoryEditor.UserPassportHistoryEntry []allHistories = UserPassportHistoryEditor.FromUserPuid(userPuid, isSecMHDB).GetAllHistory();
            HashSet<ulong?> uniqueMachines = new HashSet<ulong?>();
            int totalEntries = 0;
            System.DateTime ?first = null;
            System.DateTime ?last = null;
            List<PassportHistoryDetails> detailsExpectedInResult = new List<PassportHistoryDetails>();
            foreach (UserPassportHistoryEditor.UserPassportHistoryEntry entry in allHistories)
            {
                if (since == null || entry.TimeStamp >= since)
                {
                    if ((machinePuid == null || machinePuid == entry.MachinePuid))
                    {
                        ++totalEntries;

                        if (first == null || first > entry.TimeStamp)
                        {
                            first = entry.TimeStamp;
                        }

                        if (last == null || last < entry.TimeStamp)
                        {
                            last = entry.TimeStamp;
                        }

                        if (!uniqueMachines.Contains(entry.MachinePuid))
                        {
                            uniqueMachines.Add(entry.MachinePuid);
                        }

                        if (details)
                        {
                            PassportHistoryDetails detail = new PassportHistoryDetails();
                            detail.MachinePuid = entry.MachinePuid;
                            detail.UserPuid = userPuid;
                            detail.IpAddress = entry.IpAddress;
                            detail.Timestamp = entry.TimeStamp;
                            detail.Result = entry.Hr;
                            detail.Reason = entry.Reason;
                            detail.OldPassportPuid=entry.OldPassport;
                            detail.NewPassportPuid=entry.NewPassport;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total = totalEntries;
            expectedResult.Unique = uniqueMachines.Count;
            expectedResult.First = first;
            expectedResult.Last = last;
            expectedResult.Details = detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details = null;
            }

            //Verify
            HistoryCommon.VerifyPassportHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            PassportHistory ret = PassportHistoryGetVerbose(userPuid, machinePuid, since, details);
            ComputeAndVerifyPassportHistory(userPuid, machinePuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithMachinePuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoMachinePuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 1, 2, 1, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoMachinePuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithMachinePuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithMachinePuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithMachinePuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoMachinePuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithMachinePuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithMachinePuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithMachinePuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserPassportHistoryEditor mghe=UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, 3, 4, 1, useSecUHDB));
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, 5, 6, 2, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",                 0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",                 1,    null, false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",           0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",           1,    2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",           0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",           1,    4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",               0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",               1,    null, true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",         0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",         1,    2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",         0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",         1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            int ?passMachinePuid = (self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor []machs=new MachineEditor[]{MachineEditor.CreateNew(), MachineEditor.CreateNew()};

            UserPassportHistoryEditor mghe=UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machs[0].Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, 7, 8, 1, useSecUHDB));
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machs[0].Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, 9, 10, 2, useSecUHDB));
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machs[1].Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, 11, 12, 3, useSecUHDB));

            ulong ?machinePuid=(passMachinePuid!=null?machs[(int)passMachinePuid].Id:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //User puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird machine puids.")]
            [CompoundCase("null",    null)]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void MachinePuids(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);

                UserEditor user = UserEditor.CreateNew();

                UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 13, 14, 1, useSecUHDB));

                CallAndVerify(user.Puid, machinePuid, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string ipAddress = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, 15, 16, 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                byte reason = (byte)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 17, 18, reason, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Various passport values.")]
            [CompoundCase("null", null)]
            [CompoundCase("MinValue", (ulong)0)]
            [CompoundCase("MaxValue", (ulong)0xffffffffffffffff)]
            public void Passports(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong ?passport = null;
                if (self.MyValues[0] != null)
                {
                    passport = (ulong)self.MyValues[0];
                }

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, passport, passport, 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            for (int i=0; i<1000; ++i)
            {
                mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, (ulong)i, (ulong)i*3, (byte)(i%10+1), useSecUHDB));
            }

            CallAndVerify(user.Puid, null, null, true, useSecUHDB);
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserPassportHistoryEditor mghe = UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            mghe.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, 98, 99, 1, useSecUHDB));

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{PassportHistoryGetVerbose(user.Puid, mach.Id, null, true, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\RecoveryHistoryGet.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class RecoveryHistoryGet : GreaterDoubleWriteTestGroup
    {
        public static RecoveryHistory RecoveryHistoryGetVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling RecoveryHistoryGet: UserPuid=" + userPuid + ", MachinePuid=" + machinePuid + ", Since=" + since + ", Details=" + details);
            RecoveryHistory ret = client.RecoveryHistoryGet((ulong)userPuid, true, (ulong?)machinePuid, true, since, true, details, true);
            Global.RO.Debug("RecoveryHistoryGet returned: " + HistoryCommon.RecoveryHistoryStringer(ret));
            return ret;
        }

        public static RecoveryHistory RecoveryHistoryGetVerbose(Puid userPuid, Puid ?machinePuid, DateTime? since, bool details)
        {
            return RecoveryHistoryGetVerbose(userPuid, machinePuid, since, details, null);
        }

        public static void ComputeAndVerifyRecoveryHistory(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, RecoveryHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a RecoveryHistory that contains the expected result
            RecoveryHistory expectedResult = new RecoveryHistory();

            UserRecoveryHistoryEditor.UserRecoveryHistoryEntry []allHistories = UserRecoveryHistoryEditor.FromUserPuid(userPuid, isSecMHDB).GetAllHistory();
            HashSet<ulong?> uniqueMachines = new HashSet<ulong?>();
            int totalEntries = 0;
            System.DateTime ?first = null;
            System.DateTime ?last = null;
            List<RecoveryHistoryDetails> detailsExpectedInResult = new List<RecoveryHistoryDetails>();
            foreach (UserRecoveryHistoryEditor.UserRecoveryHistoryEntry entry in allHistories)
            {
                if (since == null || entry.TimeStamp >= since)
                {
                    if ((machinePuid == null || machinePuid == entry.MachinePuid))
                    {
                        ++totalEntries;

                        if (first == null || first > entry.TimeStamp)
                        {
                            first = entry.TimeStamp;
                        }

                        if (last == null || last < entry.TimeStamp)
                        {
                            last = entry.TimeStamp;
                        }

                        if (!uniqueMachines.Contains(entry.MachinePuid))
                        {
                            uniqueMachines.Add(entry.MachinePuid);
                        }

                        if (details)
                        {
                            RecoveryHistoryDetails detail = new RecoveryHistoryDetails();
                            detail.MachinePuid = entry.MachinePuid;
                            detail.UserPuid = userPuid;
                            detail.IpAddress = entry.IpAddress;
                            detail.Timestamp = entry.TimeStamp;
                            detail.Result = entry.Hr;
                            detail.Reason = entry.Reason;
                            detail.PassportPuid=entry.PassportPuid;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total = totalEntries;
            expectedResult.Unique = uniqueMachines.Count;
            expectedResult.First = first;
            expectedResult.Last = last;
            expectedResult.Details = detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details = null;
            }

            //Verify
            HistoryCommon.VerifyRecoveryHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid userPuid, Puid ?machinePuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            RecoveryHistory ret = RecoveryHistoryGetVerbose(userPuid, machinePuid, since, details);
            ComputeAndVerifyRecoveryHistory(userPuid, machinePuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithMachinePuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoMachinePuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 1, 1, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoMachinePuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithMachinePuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithMachinePuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithMachinePuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoMachinePuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithMachinePuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithMachinePuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithMachinePuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithMachinePuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserRecoveryHistoryEditor ughe=UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, 4, 1, useSecUHDB));
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, 6, 2, useSecUHDB));

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",                 0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",                 1,    null, false)]
        [CompoundCase("NoMachinePuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",           0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",           1,    2,    false)]
        [CompoundCase("NoMachinePuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",           0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",           1,    4,    false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",               0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",               1,    null, true)]
        [CompoundCase("NoMachinePuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",         0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",         1,    2,    true)]
        [CompoundCase("NoMachinePuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",         0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",         1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now = System.DateTime.UtcNow;
            bool useSecUHDB = !IsDoubleWrite(self);
            int ?passMachinePuid = (self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod = (self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor []machs=new MachineEditor[]{MachineEditor.CreateNew(), MachineEditor.CreateNew()};

            UserRecoveryHistoryEditor ughe=UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machs[0].Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, 8, 1, useSecUHDB));
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machs[0].Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, 10, 2, useSecUHDB));
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machs[1].Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, 12, 3, useSecUHDB));

            ulong ?machinePuid=(passMachinePuid!=null?machs[(int)passMachinePuid].Id:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoMachinePuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithMachinePuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoMachinePuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoMachinePuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithMachinePuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool passMachinePuid = (bool)self.MyValues[0];
            bool passPastDate = (bool)self.MyValues[1];
            bool passDetailsFlag = (bool)self.MyValues[2];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            ulong ?machinePuid = (passMachinePuid?(ulong?)mach.Id:(ulong?)null);
            System.DateTime ?sinceDate = (passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(user.Puid, machinePuid, sinceDate, passDetailsFlag, useSecUHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //User puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird machine puids.")]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void MachinePuids(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong machinePuid = (ulong)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();

                UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 14, 1, useSecUHDB));

                CallAndVerify(user.Puid, machinePuid, null, true, useSecUHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                string ipAddress = (string)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, 16, 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                byte reason = (byte)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 18, reason, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }

            [TestCase, Description("Various passport values.")]
            [CompoundCase("MinValue", (ulong)0)]
            [CompoundCase("MaxValue", (ulong)0xffffffffffffffff)]
            public void Passports(TestNode self)
            {
                bool useSecUHDB = !IsDoubleWrite(self);
                ulong passport = (ulong)self.MyValues[0];

                UserEditor user = UserEditor.CreateNew();
                MachineEditor mach = MachineEditor.CreateNew();

                UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, passport, 1, useSecUHDB));

                CallAndVerify(user.Puid, null, null, true, useSecUHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            for (int i=0; i<1000; ++i)
            {
                ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, (ulong)i, (byte)(i%10+1), useSecUHDB));
            }

            CallAndVerify(user.Puid, null, null, true, useSecUHDB);
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            UserEditor user = UserEditor.CreateNew();
            MachineEditor mach = MachineEditor.CreateNew();

            UserRecoveryHistoryEditor ughe = UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
            ughe.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 18, 1, useSecUHDB));

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{RecoveryHistoryGetVerbose(user.Puid, mach.Id, null, true, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\PassportHistoryLog.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.xuser.soap;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class PassportHistoryLog : GreaterDoubleWriteTestGroup
    {
        public static void PassportHistoryLogVerbose(PassportHistoryDetails gthd, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling PassportHistoryLog: gthd=" + HistoryCommon.PassportHistoryDetailsStringer(gthd));
            client.PassportHistoryLog(gthd);
            Global.RO.Debug("PassportHistoryLog returned.");
        }

        public static void PassportHistoryLogVerbose(PassportHistoryDetails gthd)
        {
            PassportHistoryLogVerbose(gthd, null);
        }

        public class CallAndVerifier : LogAccumulatorAndCaller<PassportHistoryDetails, UserPassportHistoryEditor.UserPassportHistoryEntry>
        {
            public override UserPassportHistoryEditor.UserPassportHistoryEntry ConvertCallTypeToDbType(PassportHistoryDetails log)
            {
                return new UserPassportHistoryEditor.UserPassportHistoryEntry
                {
                    UserPuid    = log.UserPuid,
                    MachinePuid = HistoryCommon.TruncateXboxComMachinePuid(log.MachinePuid),
                    IpAddress   = log.IpAddress,
                    TimeStamp   = log.Timestamp,
                    Hr          = log.Result,
                    OldPassport = log.OldPassportPuid,
                    NewPassport = log.NewPassportPuid,
                    Reason      = (byte)log.Reason,
                    HashBucket  = -1 //recomputed later to be correct
                };
            }

            public override UserPassportHistoryEditor.UserPassportHistoryEntry[] GetActualRowsFromDb(ulong userPuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return UserPassportHistoryEditor.FromUserPuid(userPuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetUserPuid(PassportHistoryDetails log)
            {
                return log.UserPuid;
            }

            public override ulong GetUserPuid(UserPassportHistoryEditor.UserPassportHistoryEntry log)
            {
                return log.UserPuid;
            }

            public override void SetHashBucket(UserPassportHistoryEditor.UserPassportHistoryEntry log, short bucket)
            {
                log.HashBucket = bucket;
            }
        }

        //Get a unique puid in the correct range but no actual user created for it
        public static ulong AllocateUserPuid()
        {
            return UserEditor.AllocatePuid();
        }

        //create a user and return their puid
        public static ulong GenerateUserPuid()
        {
            return UserEditor.CreateNew().Puid;
        }

        public static ulong GenerateMachinePuid()
        {
            return MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
        }

        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        public static PassportHistoryDetails GenerateDetails(ulong userPuid, ulong? machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, ulong ?oldPassportPuid, ulong ?newPassportPuid)
        {
            return new PassportHistoryDetails
            {
                UserPuid = userPuid,
                MachinePuid = machinePuid,
                IpAddress = ip,
                Timestamp = timestamp,
                Result = hr,
                Reason = reason,
                OldPassportPuid = oldPassportPuid,
                NewPassportPuid = newPassportPuid,
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are invalid platforms.")]
        [CompoundCase("0x{0:X}", (ulong)0,                  "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)1,                  "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000, "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid")]
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are valid.  XUser only validates the range, not that the machine exists.")]
        [CompoundCase("{0}",            MachineType.Xbox1)]
        [CompoundCase("{0}",            MachineType.Xbox360)]
        [CompoundCase("{0}",            MachineType.PC)]
        [CompoundCase("{0}",            MachineType.Phone)]
        [CompoundCase("XboxComZero",    (ulong)0xffed000000000000)]
        [CompoundCase("XboxComNonzero", (ulong)0xffed0000ffffffff)]
        [CompoundCase("null",           null)]
        public void VariousValidMachinePuids(TestNode self)
        {
            ulong ?machinePuid;
            if (self.MyValues[0] == null)
            {
                machinePuid = null;
            }
            else if (self.MyValues[0] is MachineType)
            {
                machinePuid = MachineEditor.AllocateMachinePuid((MachineType)self.MyValues[0]);
            }
            else
            {
                machinePuid = (ulong)self.MyValues[0];
            }

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}",    (ulong)0,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)1,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)0xFFFFFFFFFFFFFFFF, "UserPuid is invalid")]
        [CompoundCase("ValidRange", null,                      "UserPuid is invalid")]
        public void VariousInvalidUserPuids(TestNode self)
        {
            ulong userPuid = (self.MyValues[0]!=null?(ulong)self.MyValues[0]:AllocateUserPuid());
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(userPuid, GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip = (string)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), ip, System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp = (System.DateTime)MyValues[0];
                string expectedSoapError = (string)MyValues[1];

                PassportHistoryDetails ghd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", timestamp, 0x80000000, 1, RandomPuid(), RandomPuid());

                CallAndVerifier cav = new CallAndVerifier();
                if (expectedSoapError == null)
                {
                    cav.CallAndAccumulate(PassportHistoryLogVerbose, ghd);
                }
                else
                {
                    XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(PassportHistoryLogVerbose, ghd);}, expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult = (uint)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, hresult, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid(), RandomPuid()));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for OldPassportPuid and NewPassportPuid.")]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0,           null,               null)]
        [CompoundCase("OldPassportPuid=0x{0:X}",   0xffffffffffffffff, null,               null)]
        [CompoundCase("NewPassportPuid=0x{1:X}",   null,               (ulong)0,           null)]
        [CompoundCase("NewPassportPuid=0x{1:X}",   null,               0xffffffffffffffff, null)]
        [CompoundCase("BothNull",                  null,               null,               "NewPassportPuid cannot be equal to OldPassportPuid")]
        [CompoundCase("BothSame",                  0xffffffffffffffff, 0xffffffffffffffff, "NewPassportPuid cannot be equal to OldPassportPuid")]
        public void VariousPassportPuids(TestNode self)
        {
            ulong ?pppOld = (self.MyValues[0]==null?(ulong?)null:(ulong)self.MyValues[0]);
            ulong ?pppNew = (self.MyValues[1]==null?(ulong?)null:(ulong)self.MyValues[1]);
            string expectedSoapError = (string)self.MyValues[2];

            PassportHistoryDetails phd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, pppOld, pppNew);

            CallAndVerifier cav = new CallAndVerifier();
            if (expectedSoapError == null)
            {
                cav.CallAndAccumulate(PassportHistoryLogVerbose, phd);
            }
            else
            {
                XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(PassportHistoryLogVerbose, phd);}, expectedSoapError);
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same user puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong []machinePuid = new ulong[]{GenerateMachinePuid(), GenerateMachinePuid()};
            ulong userPuid = GenerateUserPuid();

            CallAndVerifier cav = new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(PassportHistoryLogVerbose, GenerateDetails(userPuid, machinePuid[i%2], "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, RandomPuid(), RandomPuid()));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same user puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameUsersSameTime(TestNode self)
        {
            bool isDataTheSame = (bool)self.MyValues[0];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            System.DateTime now = System.DateTime.UtcNow;
            PassportHistoryDetails ghd1 = GenerateDetails(userPuid, machinePuid, "1.2.3.4", now, 0x80000000, 1, RandomPuid(), RandomPuid());
            PassportHistoryDetails ghd2 = ghd1;

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(PassportHistoryLogVerbose, ghd1);

            if (!isDataTheSame)
            {
                ghd2=GenerateDetails(userPuid, machinePuid, "1.2.3.5", now, 0x80000001, 2, RandomPuid(), RandomPuid());
            }

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(PassportHistoryLogVerbose, ghd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(PassportHistoryLogVerbose, null);
                },
                "Null parameter: PassportHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            PassportHistoryDetails ghd = GenerateDetails(userPuid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid());

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userPuid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{PassportHistoryLogVerbose(ghd, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\RecoveryHistoryLog.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.xuser.soap;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class RecoveryHistoryLog : GreaterDoubleWriteTestGroup
    {
        public static void RecoveryHistoryLogVerbose(RecoveryHistoryDetails gthd, XUserTestSoapClient client)
        {
            if (client == null)
            {
                client = new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling RecoveryHistoryLog: gthd=" + HistoryCommon.RecoveryHistoryDetailsStringer(gthd));
            client.RecoveryHistoryLog(gthd);
            Global.RO.Debug("RecoveryHistoryLog returned.");
        }

        public static void RecoveryHistoryLogVerbose(RecoveryHistoryDetails gthd)
        {
            RecoveryHistoryLogVerbose(gthd, null);
        }

        public class CallAndVerifier : LogAccumulatorAndCaller<RecoveryHistoryDetails, UserRecoveryHistoryEditor.UserRecoveryHistoryEntry>
        {
            public override UserRecoveryHistoryEditor.UserRecoveryHistoryEntry ConvertCallTypeToDbType(RecoveryHistoryDetails log)
            {
                return new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry
                {
                    UserPuid     = log.UserPuid,
                    MachinePuid  = HistoryCommon.TruncateXboxComMachinePuid(log.MachinePuid.Value), //This line really is correct.  An null dereference exception should never occur here because the call to the service to log a null machine puid should fail.  If that call is not failing, the service has a bug.
                    IpAddress    = log.IpAddress,
                    TimeStamp    = log.Timestamp,
                    Hr           = log.Result,
                    PassportPuid = log.PassportPuid,
                    Reason       = (byte)log.Reason,
                    HashBucket   = -1 //recomputed later to be correct
                };
            }

            public override UserRecoveryHistoryEditor.UserRecoveryHistoryEntry[] GetActualRowsFromDb(ulong userPuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return UserRecoveryHistoryEditor.FromUserPuid(userPuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetUserPuid(RecoveryHistoryDetails log)
            {
                return log.UserPuid;
            }

            public override ulong GetUserPuid(UserRecoveryHistoryEditor.UserRecoveryHistoryEntry log)
            {
                return log.UserPuid;
            }

            public override void SetHashBucket(UserRecoveryHistoryEditor.UserRecoveryHistoryEntry log, short bucket)
            {
                log.HashBucket = bucket;
            }
        }

        //Get a unique puid in the correct range but no actual user created for it
        public static ulong AllocateUserPuid()
        {
            return UserEditor.AllocatePuid();
        }

        //create a user and return their puid
        public static ulong GenerateUserPuid()
        {
            return UserEditor.CreateNew().Puid;
        }

        public static ulong GenerateMachinePuid()
        {
            return MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
        }

        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        public static RecoveryHistoryDetails GenerateDetails(ulong userPuid, ulong ?machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, ulong passportPuid)
        {
            return new RecoveryHistoryDetails
            {
                UserPuid = userPuid,
                MachinePuid = machinePuid,
                IpAddress = ip,
                Timestamp = timestamp,
                Result = hr,
                Reason = reason,
                PassportPuid = passportPuid,
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are invalid platforms.")]
        [CompoundCase("0x{0:X}",        (ulong)0,                  "Null parameter:MachinePuid")]
        [CompoundCase("0x{0:X}",        (ulong)1,                  "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}",        (ulong)0xABCD000012340000, "MachinePuid is invalid")]
        [CompoundCase("0x{0:X}",        (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid")]
        [CompoundCase("XboxComZero",    (ulong)0xffed000000000000, "MachinePuid is invalid")] //not possible to recover a console to xbox.com
        [CompoundCase("XboxComNonzero", (ulong)0xffed0000ffffffff, "MachinePuid is invalid")] //not possible to recover a console to xbox.com
        [CompoundCase("null",           null,                      "Null parameter:MachinePuid")] //db does not support this
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong ?machinePuid = (self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid that are valid.  XUser only validates the range, not that the machine exists.")]
        [CompoundCase("{0}",            MachineType.Xbox1)]
        [CompoundCase("{0}",            MachineType.Xbox360)]
        [CompoundCase("{0}",            MachineType.PC)]
        [CompoundCase("{0}",            MachineType.Phone)]
        public void VariousValidMachinePuids(TestNode self)
        {
            ulong machinePuid;
            if (self.MyValues[0] is MachineType)
            {
                machinePuid = MachineEditor.AllocateMachinePuid((MachineType)self.MyValues[0]);
            }
            else
            {
                machinePuid = (ulong)self.MyValues[0];
            }

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}",    (ulong)0,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)1,                  "UserPuid is invalid")]
        [CompoundCase("0x{0:X}",    (ulong)0xFFFFFFFFFFFFFFFF, "UserPuid is invalid")]
        [CompoundCase("ValidRange", null,                      "UserPuid is invalid")]
        public void VariousInvalidUserPuids(TestNode self)
        {
            ulong userPuid = (self.MyValues[0]!=null?(ulong)self.MyValues[0]:AllocateUserPuid());
            string expectedSoapError = (string)self.MyValues[1];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(userPuid, GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip = (string)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), ip, System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp = (System.DateTime)MyValues[0];
                string expectedSoapError = (string)MyValues[1];

                RecoveryHistoryDetails ghd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", timestamp, 0x80000000, 1, RandomPuid());

                CallAndVerifier cav = new CallAndVerifier();
                if (expectedSoapError == null)
                {
                    cav.CallAndAccumulate(RecoveryHistoryLogVerbose, ghd);
                }
                else
                {
                    XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(RecoveryHistoryLogVerbose, ghd);}, expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult = (uint)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, hresult, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason = (byte)self.MyValues[0];

            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid()));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for PassportPuid.")]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0,                  "PassportPuid is invalid")]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0x7fffffffffffffff, null)]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0x8000000000000000, null)]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0xffffffffffffffff, null)]
        public void VariousPassportPuids(TestNode self)
        {
            ulong ppp = (ulong)self.MyValues[0];
            string expectedSoapError = (string)self.MyValues[1];

            RecoveryHistoryDetails phd = GenerateDetails(GenerateUserPuid(), GenerateMachinePuid(), "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, ppp);

            CallAndVerifier cav = new CallAndVerifier();
            if (expectedSoapError == null)
            {
                cav.CallAndAccumulate(RecoveryHistoryLogVerbose, phd);
            }
            else
            {
                XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                    {
                        cav.CallAndAccumulate(RecoveryHistoryLogVerbose, phd);
                    },
                    expectedSoapError);
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same user puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong []machinePuid = new ulong[]{GenerateMachinePuid(), GenerateMachinePuid()};
            ulong userPuid = GenerateUserPuid();

            CallAndVerifier cav = new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(RecoveryHistoryLogVerbose, GenerateDetails(userPuid, machinePuid[i%2], "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, RandomPuid()));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same user puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameUsersSameTime(TestNode self)
        {
            bool isDataTheSame = (bool)self.MyValues[0];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            System.DateTime now = System.DateTime.UtcNow;
            RecoveryHistoryDetails ghd1 = GenerateDetails(userPuid, machinePuid, "1.2.3.4", now, 0x80000000, 1, RandomPuid());
            RecoveryHistoryDetails ghd2 = ghd1;

            CallAndVerifier cav = new CallAndVerifier();
            cav.CallAndAccumulate(RecoveryHistoryLogVerbose, ghd1);

            if (!isDataTheSame)
            {
                ghd2=GenerateDetails(userPuid, machinePuid, "1.2.3.5", now, 0x80000001, 2, RandomPuid());
            }

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(RecoveryHistoryLogVerbose, ghd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav = new CallAndVerifier();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(RecoveryHistoryLogVerbose, null);
                },
                "Null parameter: RecoveryHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Basic mainline test that does not put xauthdata in the http request or puts irrelevent xauthdata in the request.")]
        [CompoundCase("NoHeader",  false, false)]
        [CompoundCase("NoClaim",   true,  false)]
        [CompoundCase("UserClaim", true,  true)]
        public void XAuthData(TestNode self)
        {
            bool useSecUHDB = !IsDoubleWrite(self);
            bool allowHeader = (bool)self.MyValues[0];
            bool setClaim = (bool)self.MyValues[1];

            ulong userPuid = GenerateUserPuid();
            ulong machinePuid = GenerateMachinePuid();
            RecoveryHistoryDetails rhd = GenerateDetails(userPuid, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid());

            XUserTestSoapClient client = new XUserTestSoapClient();

            if (!allowHeader)
            {
                client.AllowAuthHeaderToBeAdded = allowHeader;
            }
            else
            {
                if (!setClaim)
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);
                }
                else
                {
                    client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userPuid)});
                }
            }

            XUserTestUtil.ExecuteCallExpecting403(delegate{RecoveryHistoryLogVerbose(rhd, client);});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\UserKeyGet.cs ===
using System;
using System.ServiceModel;
using XUserTests;

using xonline.common.service;
using xonline.xuser.soap;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    class UserKeyGet : TestNode
    {
        public static UserKey UserKeyGetVerbose(ulong userPuid, XUserTestSoapClient client)
        {
            if (client==null)
            {
                client=new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling UserKeyGet: userPuid="+string.Format("0x{0:X}", userPuid));
            UserKey ret=client.UserKeyGet(userPuid, true);
            Global.RO.Debug("UserKeyGet returned: "+XUserTestUtil.UserKeyStringer(ret));
            return ret;
        }

        public static UserKey UserKeyGetVerbose(ulong userPuid)
        {
            return UserKeyGetVerbose(userPuid, null);
        }

        // -

        [TestCase, Description("Mainline case of getting a key for an existing user.  Auth using the internal claim.")]
        public void MainlineInternalClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            UserKey ret=UserKeyGetVerbose(user.Puid);
            XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);
        }

        [TestCase, Description("Mainline case of getting a key for an existing user.  Auth using the user claim.")]
        public void MainlineUserClaim()
        {
            UserEditor user=UserEditor.CreateNew();

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});

            UserKey ret=UserKeyGetVerbose(user.Puid, client);
            XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);
        }

        [TestCase, Description("Attempt to reset a user that doesn't exist.")]
        public void UserDoesNotExist()
        {
            ulong unusedUserPuid=UserEditor.AllocatePuid();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                UserKeyGetVerbose(unusedUserPuid);
            },
                "Value does not fall within the expected range");
        }

        [TestCase, Description("No authorization header present.")]
        public void NoAuthHeader()
        {
            XUserTestSoapClient client=new XUserTestSoapClient();
            client.AllowAuthHeaderToBeAdded=false;

            UserEditor user=UserEditor.CreateNew();

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyGetVerbose(user.Puid, client);
            });
        }

        [TestCase, Description("XAuthdata contains no claims.")]
        public void NoClaims()
        {
            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);

            UserEditor user=UserEditor.CreateNew();

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyGetVerbose(user.Puid, client);
            });
        }

        [TestCase, Description("XAuthdata contains the wrong user in the claim.")]
        public void WrongUserInClaim()
        {
            UserEditor userForCall=UserEditor.CreateNew();
            UserEditor userForClaim=UserEditor.CreateNew();

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userForClaim.Puid)});

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyGetVerbose(userForCall.Puid, client);
            });
        }

        [TestCase, Description("Pass a machine puid instead of a user puid")]
        [CompoundCase("Xbox1", MachineType.Xbox1)]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Xbox360Legacy", true)]
        [CompoundCase("PC", MachineType.PC)]
        public void PassMachinePuid(TestNode self)
        {
            MachineEditor mach=null;
            if (self.MyValues[0] is MachineType)
            {
                mach=MachineEditor.CreateNew((MachineType)self.MyValues[0]);
            }
            else if (self.MyValues[0] is bool)
            {
                mach=MachineEditor.CreateLegacyXbox360();
            }

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                UserKeyGetVerbose(mach.Id);
            },
                "Value does not fall within the expected range");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\UserKeyReset.cs ===
using System;
using XUserTests;
using System.ServiceModel;

using xonline.common.service;
using xonline.xuser.soap;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    class UserKeyReset: TestNode
    {
        public static UserKey UserKeyResetVerbose(ulong userPuid, XUserTestSoapClient client)
        {
            if (client==null)
            {
                client=new XUserTestSoapClient();
            }

            Global.RO.Debug("Calling UserKeyReset: userPuid="+string.Format("0x{0:X}", userPuid));
            UserKey ret=client.UserKeyReset(userPuid, true);
            Global.RO.Debug("UserKeyReset returned: "+XUserTestUtil.UserKeyStringer(ret));
            return ret;
        }

        public static UserKey UserKeyResetVerbose(ulong userPuid)
        {
            return UserKeyResetVerbose(userPuid, null);
        }

        // --

        [TestCase, Description("Mainline case of resetting an existing user.  Auth using the internal claim.")]
        public void MainlineInternalClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            UserKey origKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            System.DateTime origResetDate=user.ResetDate;
            Global.RO.Debug("Original key: "+XUserTestUtil.UserKeyStringer(origKey));

            System.Threading.Thread.Sleep(10); //put some delay between creation and reset so that we can correctly validate that the reset date is changing
            UserKey ret=UserKeyResetVerbose(user.Puid);
            XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);

            UserKey newKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            XUserTestUtil.ValidateKeysAreDifferent(origKey, newKey);
            ValueCheck.TestGreaterThan("User ResetDate", origResetDate, user.ResetDate);
        }

        [TestCase, Description("Mainline case of resetting an existing user.  Auth using the user claim.")]
        public void MainlineUserClaim()
        {
            UserEditor user=UserEditor.CreateNew();
            UserKey origKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            System.DateTime origResetDate=user.ResetDate;
            Global.RO.Debug("Original key: "+XUserTestUtil.UserKeyStringer(origKey));

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(user.Puid)});

            System.Threading.Thread.Sleep(10); //put some delay between creation and reset so that we can correctly validate that the reset date is changing
            UserKey ret=UserKeyResetVerbose(user.Puid, client);
            XUserTestUtil.ValidateUserKeyAgainstUserEditor(ret, user);

            UserKey newKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            XUserTestUtil.ValidateKeysAreDifferent(origKey, newKey);
            ValueCheck.TestGreaterThan("User ResetDate", origResetDate, user.ResetDate);
        }

        [TestCase, Description("Attempt to reset a user that doesn't exist.")]
        public void UserDoesNotExist()
        {
            ulong unusedUserPuid=UserEditor.AllocatePuid();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                UserKeyResetVerbose(unusedUserPuid);
            },
                "Value does not fall within the expected range");
        }

        [TestCase, Description("No authorization header present.")]
        public void NoAuthHeader()
        {
            XUserTestSoapClient client=new XUserTestSoapClient();
            client.AllowAuthHeaderToBeAdded=false;

            UserEditor user=UserEditor.CreateNew();
            UserKey origKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyResetVerbose(user.Puid, client);
            });

            UserKey newKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            XUserTestUtil.ValidateKeysAreSame(origKey, newKey);
        }

        [TestCase, Description("XAuthdata contains no claims.")]
        public void NoClaims()
        {
            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[0]);

            UserEditor user=UserEditor.CreateNew();
            UserKey origKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyResetVerbose(user.Puid, client);
            });

            UserKey newKey=XUserTestUtil.PopulateUserKeyFromUserEditor(user);
            XUserTestUtil.ValidateKeysAreSame(origKey, newKey);
        }

        [TestCase, Description("XAuthdata contains the wrong user in the claim.")]
        public void WrongUserInClaim()
        {
            UserEditor userForCall=UserEditor.CreateNew();
            UserEditor userForClaim=UserEditor.CreateNew();
            UserKey origKeyCall=XUserTestUtil.PopulateUserKeyFromUserEditor(userForCall);
            UserKey origKeyClaim=XUserTestUtil.PopulateUserKeyFromUserEditor(userForClaim);

            XUserTestSoapClient client=new XUserTestSoapClient();
            client.ReplaceXAuthdataClaims(new Microsoft.IdentityModel.Claims.Claim[]{AuthTestHelper.MakeUserPuidClaim(userForClaim.Puid)});

            XUserTestUtil.ExecuteCallExpecting403(delegate
            {
                UserKeyResetVerbose(userForCall.Puid, client);
            });

            UserKey newKeyCall=XUserTestUtil.PopulateUserKeyFromUserEditor(userForCall);
            XUserTestUtil.ValidateKeysAreSame(origKeyCall, newKeyCall);
            UserKey newKeyClaim=XUserTestUtil.PopulateUserKeyFromUserEditor(userForClaim);
            XUserTestUtil.ValidateKeysAreSame(origKeyClaim, newKeyClaim);
        }

        [TestCase, Description("Pass a machine puid instead of a user puid")]
        [CompoundCase("Xbox1", MachineType.Xbox1)]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Xbox360Legacy", true)]
        [CompoundCase("PC", MachineType.PC)]
        public void PassMachinePuid(TestNode self)
        {
            MachineEditor mach=null;
            if (self.MyValues[0] is MachineType)
            {
                mach=MachineEditor.CreateNew((MachineType)self.MyValues[0]);
            }
            else if (self.MyValues[0] is bool)
            {
                mach=MachineEditor.CreateLegacyXbox360();
            }

            byte []origKey=mach.GetEncryptedKey();

            XUserTestUtil.ExecuteCallExpectingSoapError(delegate
            {
                UserKeyResetVerbose(mach.Id);
            },
                "Value does not fall within the expected range");

            byte []newKey=mach.GetEncryptedKey();
            ValueCheck.TestAll("Machine Key was not changed", origKey, newKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\XUserProxy\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("XONLINE")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\Stress.cs ===
using System;
using System.Collections.Generic;
using XUserTests;
using xonline.common.service;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using xonline.xuser.soap;

namespace XUserTests
{
    [TestGroup, Owner("WisgT"), TestCasePriority(1)]
    public class Stress : TestNode
    {
        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        [TestGroup]
        class Others: TestNode //temporarily partitioned off so that the annoyingly long prerun isn't forced onto the tests that don't need it
        {
            public class MachineData
            {
                public ulong MachinePuid;
                public string FriendlyName;
                public DateTime? LastSignin;
                public DateTime? LastSignout;
                public UserMachineHistoryEditor ume;
            }
            //-
            public class UserMachineInfo
            {
                public ulong UserPuid;
                public string Gamertag;

                public List<MachineData> machineData;
                public byte[] XenonKey;
                public byte[] XenonEncKey;
                public byte[] XenonIv;
                public UserMachineInfo()
                {
                    machineData = new List<MachineData>();
                }
            };

            public static TimedQueue<UserMachineInfo> userMachineCache;
            public static Random _ran = new Random();
            public static UserMachineInfo GetCachedOrCreateNew()
            {
                UserMachineInfo umi = userMachineCache.PopFront();
                if (umi == null)
                {
                    //Random ran = new Random();
                    umi = new UserMachineInfo();
                    UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(0, (ulong)_ran.Next(1, 10), true);
                    UserEditor ue = UserEditor.FromPuid(umes[0].UserPuid);
                    umi.Gamertag = ue.Gamertag;
                    umi.UserPuid = ue.Puid;
                    umi.XenonKey = ue.XenonKey;
                    umi.XenonEncKey = ue.XenonEncKey;
                    umi.XenonIv = ue.XenonIv;
                    Global.RO.Debug("User:  {0} (0x{1:X}) History count: {2}", ue.Gamertag, ue.Puid, umes.Length);
                    foreach (UserMachineHistoryEditor ume in umes)
                    {
                        MachineData md = new MachineData();
                        md.MachinePuid = ume.MachinePuid;
                        md.FriendlyName = ume.FriendlyName;
                        md.LastSignin = ume.LastSignin;
                        md.LastSignout = ume.LastSignout;
                        md.ume = ume;
                        umi.machineData.Add(md);
                    }

                }
                else
                {
                    // this is to prevent in the ume from pulling data from the server inside the stress test
                    //foreach (MachineData md in umi.machineData)
                    //{
                    //    md.FriendlyName = md.ume.FriendlyName;
                    //    md.LastSignin = md.ume.LastSignin;
                    //    md.LastSignout = md.ume.LastSignout;
                    //}

                }
                return umi;
            }

            // -


            public override void PreRun()
            {


                if (userMachineCache == null)
                {
                    if (!ServerTestFramework.LiveService.XSTS.XstsUtil.IsMasterKeyInstalled())
                    {
                        ServerTestFramework.LiveService.XSTS.XstsUtil.InstallMasterKey();
                    }
                    userMachineCache = new TimedQueue<UserMachineInfo>();
                    userMachineCache.MinimumReuseTime = new TimeSpan(0, 0, 0, 1, 0); //a user machine history may not be used more than once every 1 second.  This is arbitrary just to cause us to use a larger pool of machines so that there are fewer cache hits.
                }
                //
                // pre-populate user machines into the queue before any tests start
                //
                List<UserMachineInfo> umis = new List<UserMachineInfo>();
                for (int i = 0; i < 500 - userMachineCache.Count; i++)
                {
                    umis.Add(GetCachedOrCreateNew());
                }

                foreach (UserMachineInfo umi in umis)
                {
                    userMachineCache.PushBack(umi);
                }
            }

            // -----

            [StressTest, Description("Spits out the status of the cache.")]
            public void PrintStatus()
            {
                Global.RO.Debug("userCache.Count: {0}", userMachineCache.Count);
            }

            [StressTest]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", 5)]
            public void MachineGetMultiple(TestNode self)
            {
                int umiCount = (int)self.MyValues[0];

                //grab user machines from the cache or create them if the cache ran out
                UserMachineInfo[] umis = new UserMachineInfo[umiCount];
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();

                for (int i = 0; i < umiCount; ++i)
                {
                    umis[i] = GetCachedOrCreateNew();
                    xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umis[i].UserPuid, null, null, null);
                    ValueCheck.Test("Returned array length", machines.Length, umis[i].machineData.Count);
                    ValueCheck.Test("User Puid", machines[0].UserPuid, umis[i].UserPuid);
                }

                //return the machines to the cache if it had no problems
                for (int i = 0; i < umiCount; ++i)
                {
                    userMachineCache.PushBack(umis[i]);
                }
            }

            [StressTest]
            public void MachineGetByMachinePuid()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();
                Random rand = new Random();
                int index = rand.Next(0, umi.machineData.Count);
                xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umi.UserPuid, umi.machineData[index].MachinePuid, null, null);
                //
                // Do basic verification
                //
                ValueCheck.Test("Returned array length", 1, machines.Length);
                ValueCheck.Test("User Puid", machines[0].UserPuid, umi.UserPuid);
                ValueCheck.Test("Machine Puid", machines[0].MachinePuid, umi.machineData[index].MachinePuid);

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void MachineGetByFriendlyName()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();
                Random rand = new Random();
                int index = rand.Next(0, umi.machineData.Count);
                xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umi.UserPuid, null, umi.machineData[index].FriendlyName, null);
                //
                // Do basic verification
                //
                ValueCheck.Test("Returned array length", 1, machines.Length);
                ValueCheck.Test("User Puid", machines[0].UserPuid, umi.UserPuid);
                ValueCheck.Test("Machine Puid", machines[0].MachinePuid, umi.machineData[index].MachinePuid);

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void MachineGetByDate()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();
                Random rand = new Random();
                int index = rand.Next(0, umi.machineData.Count);
                xonline.xuser.soap.UserMachine[] machines = client.MachineGet(umi.UserPuid, null, null, umi.machineData[index].LastSignin);
                //
                // Do basic verification
                //

                ValueCheck.Test("User Puid", machines[0].UserPuid, umi.UserPuid);

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void MachineFriendlyNameSet()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();
                string newName;
                Random rand = new Random();
                int index = rand.Next(0, umi.machineData.Count);
                int last = umi.machineData[index].FriendlyName.LastIndexOf(' ');
                if (last > 0)
                {
                    newName = umi.machineData[index].FriendlyName.Remove(last);
                }
                else
                {
                    newName = umi.machineData[index].FriendlyName;
                }

                newName = string.Format("{0} {1}", newName, rand.Next(1, 999999));
                client.MachineFriendlyNameSet(umi.UserPuid, true, umi.machineData[index].MachinePuid, true, newName);
                umi.machineData[index].FriendlyName = newName;

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void MachineTrustLevelSet()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();
                Random rand = new Random();
                int index = rand.Next(0, umi.machineData.Count);

                client.MachineTrustLevelSet(umi.UserPuid, true, umi.machineData[index].MachinePuid, true, (xonline.xuser.soap.MachineTrustLevel)rand.Next(0, 1), true);

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void UserKeyGet()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();

                xonline.xuser.soap.UserKey key = client.UserKeyGet(umi.UserPuid, true);
                // Do basic verification
                ValueCheck.Test("User Gamertag", key.Gamertag, umi.Gamertag);
                ValueCheck.Test("Machine encrypted key", key.RawKey, umi.XenonKey);

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            public void UserKeyReset()
            {
                //grab user machine history from the cache or create them if the cache ran out
                UserMachineInfo umi = GetCachedOrCreateNew();
                XUserTestSoapClient client = XUserTestUtil.GetUserClient();

                xonline.xuser.soap.UserKey key = client.UserKeyReset(umi.UserPuid, true);
                // Do basic verification
                ValueCheck.Test("User Gamertag", key.Gamertag, umi.Gamertag);
                ValueCheck.TestDifferent("Machine encrypted key", key.EncryptedKey, umi.XenonEncKey);
                ValueCheck.TestDifferent("Machine raw key", key.RawKey, umi.XenonKey);
                ValueCheck.TestDifferent("Machine IV", key.IV, umi.XenonIv);

                umi.XenonIv = key.IV;
                umi.XenonEncKey = key.EncryptedKey;
                umi.XenonKey = key.RawKey;

                //return the user machine history to the cache if it had no problems
                userMachineCache.PushBack(umi);
            }

            [StressTest]
            [CompoundCase("{0}", 1)]
            [CompoundCase("{0}", 10)]
            [CompoundCase("{0}", 25)]
            [CompoundCase("{0}", 50)]
            [CompoundCase("{0}", 75)]
            [CompoundCase("{0}", 100)]
            [CompoundCase("{0}", 200)]
            public void UserNotifyStress(TestNode self)
            {
                int umiCount = (int)self.MyValues[0];

                //grab user machines from the cache or create them if the cache ran out
                List<UserMachineInfo> umis = new List<UserMachineInfo>();
                XUserNotify xuserPost = new XUserNotify();

                for (int i = 0; i < umiCount; )
                {
                    int k = 0;
                    UserMachineInfo umi = GetCachedOrCreateNew();
                    umis.Add(umi);
                    for (k = 0; k < umiCount - i && k < umi.machineData.Count; k++)
                    {
                        xuserPost.SetUserMachinePair((Int64)umi.machineData[k].MachinePuid, (Int64)umi.UserPuid);
                        xuserPost.FillStream();
                    }
                    i += k;
                }

                HttpStatusCode resp = xuserPost.GetResponse();
                if (resp != HttpStatusCode.OK)
                {
                    throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
                }

                //return the machines to the cache if it had no problems
                foreach( UserMachineInfo umi in umis)
                {
                    userMachineCache.PushBack(umi);
                }
            }
        } //class Others

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        public class UserInfo
        {
            public ulong Puid;
            public string Gamertag;
        }

        public class TestNodeWithPrivateUserCache: TestNode
        {
            private TimedQueue<UserInfo> userCache;

            protected UserInfo GetCachedUser()
            {
                UserInfo uinfo=userCache.PopFront();
                if (uinfo==null)
                {
                    uinfo=GenerateNewUser();
                }

                return uinfo;
            }

            protected virtual UserInfo GenerateNewUser()
            {
                UserEditor uedit=UserEditor.CreateNew();
                UserInfo uinfo=new UserInfo();
                uinfo.Puid=uedit.Puid;
                uinfo.Gamertag=uedit.Gamertag;
                return uinfo;
            }

            protected void ReturnToCache(UserInfo uinfo)
            {
                userCache.PushBack(uinfo);
            }

            public TestNodeWithPrivateUserCache()
            {
                userCache=new TimedQueue<UserInfo>();
                userCache.MinimumReuseTime=new TimeSpan(0,0,0,0,100); //a user may not be used more than once every 100ms.  This is arbitrary just to cause us to use a larger pool of users so that there are fewer cache hits.
            }
        }

        [StressTest]
        public class GamertagHistoryLog: TestNodeWithPrivateUserCache
        {
            public override void Run()
            {
                UserInfo user=GetCachedUser();

                GamertagHistoryDetails ghd=new GamertagHistoryDetails
                {
                    UserPuid=user.Puid,
                    MachinePuid=0xfa00ff88ff007770,
                    IpAddress="255.254.253.252",
                    Timestamp=System.DateTime.UtcNow,
                    Result=0,
                    Reason=1,
                    OldGamertag="OldStress",
                    NewGamertag="NewStress",
                };

                new XUserSoapClient().GamertagHistoryLog(ghd);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class PassportHistoryLog: TestNodeWithPrivateUserCache
        {
            public override void Run()
            {
                UserInfo user=GetCachedUser();

                PassportHistoryDetails phd=new PassportHistoryDetails
                {
                    UserPuid=user.Puid,
                    MachinePuid=0xfa00ff88ff007771,
                    IpAddress="254.253.252.251",
                    Timestamp=System.DateTime.UtcNow,
                    Result=0,
                    Reason=1,
                    OldPassportPuid=RandomPuid(),
                    NewPassportPuid=RandomPuid()
                };

                new XUserSoapClient().PassportHistoryLog(phd);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class RecoveryHistoryLog: TestNodeWithPrivateUserCache
        {
            public override void Run()
            {
                UserInfo user=GetCachedUser();

                RecoveryHistoryDetails rhd=new RecoveryHistoryDetails
                {
                    UserPuid=user.Puid,
                    MachinePuid=0xfa00ff88ff007772,
                    IpAddress="253.252.251.250",
                    Timestamp=System.DateTime.UtcNow,
                    Result=0,
                    Reason=1,
                    PassportPuid=RandomPuid()
                };

                new XUserSoapClient().RecoveryHistoryLog(rhd);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class GamertagHistoryGetByUserPuid: TestNodeWithPrivateUserCache
        {
            protected override UserInfo GenerateNewUser()
            {
                UserInfo user=base.GenerateNewUser();

                MachineEditor machA=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machB=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machC=MachineEditor.CreateNew(MachineType.Xbox360);

                bool useSecUHDB=!xonline.common.config.Config.GetBoolSetting("xuser_doubleWriteHistory");
                UserGamertagHistoryEditor histEdit=UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                histEdit.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machA.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, "OldyStressA", "NewyStressB", 1, useSecUHDB));
                histEdit.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machB.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, "OldyStressC", "NewyStressD", 1, useSecUHDB));
                histEdit.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid, machC.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, "OldyStressE", "NewyStressF", 1, useSecUHDB));

                return user;
            }

            public override void Run()
            {
                UserInfo user=GetCachedUser();

                GamertagHistory ret=new XUserSoapClient().GamertagHistoryGetByUserPuid(user.Puid, true, null, true, null, true, true, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class GamertagHistoryGetByGamertag: TestNodeWithPrivateUserCache
        {
            protected override UserInfo GenerateNewUser()
            {
                UserInfo user=base.GenerateNewUser();

                MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                UserEditor userOtherA=UserEditor.CreateNew();
                UserEditor userOtherB=UserEditor.CreateNew();

                bool useSecUHDB=!xonline.common.config.Config.GetBoolSetting("xuser_doubleWriteHistory");

                UserGamertagHistoryEditor histEditX=UserGamertagHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                histEditX.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(user.Puid,       mach.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, user.Gamertag, "NewyStressB", 1, useSecUHDB));

                UserGamertagHistoryEditor histEditA=UserGamertagHistoryEditor.FromUserPuid(userOtherA.Puid, useSecUHDB);
                histEditA.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userOtherA.Puid, mach.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, user.Gamertag, "NewyStressD", 1, useSecUHDB));

                UserGamertagHistoryEditor histEditB=UserGamertagHistoryEditor.FromUserPuid(userOtherB.Puid, useSecUHDB);
                histEditB.SetHistory(new UserGamertagHistoryEditor.UserGamertagHistoryEntry(userOtherB.Puid, mach.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, "OldyStressE", user.Gamertag, 1, useSecUHDB));

                return user;
            }

            public override void Run()
            {
                UserInfo user=GetCachedUser();

                GamertagHistory ret=new XUserSoapClient().GamertagHistoryGetByGamertag(user.Gamertag, null, true, true, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class PassportHistoryGet: TestNodeWithPrivateUserCache
        {
            protected override UserInfo GenerateNewUser()
            {
                UserInfo user=base.GenerateNewUser();

                MachineEditor machA=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machB=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machC=MachineEditor.CreateNew(MachineType.Xbox360);

                bool useSecUHDB=!xonline.common.config.Config.GetBoolSetting("xuser_doubleWriteHistory");
                UserPassportHistoryEditor histEdit=UserPassportHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                histEdit.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machA.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecUHDB));
                histEdit.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machB.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecUHDB));
                histEdit.SetHistory(new UserPassportHistoryEditor.UserPassportHistoryEntry(user.Puid, machC.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, RandomPuid(), RandomPuid(), 1, useSecUHDB));

                return user;
            }

            public override void Run()
            {
                UserInfo user=GetCachedUser();

                PassportHistory ret=new XUserSoapClient().PassportHistoryGet(user.Puid, true, null, true, null, true, true, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }

        [StressTest]
        public class RecoveryHistoryGet: TestNodeWithPrivateUserCache
        {
            protected override UserInfo GenerateNewUser()
            {
                UserInfo user=base.GenerateNewUser();

                MachineEditor machA=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machB=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machC=MachineEditor.CreateNew(MachineType.Xbox360);

                bool useSecUHDB=!xonline.common.config.Config.GetBoolSetting("xuser_doubleWriteHistory");
                UserRecoveryHistoryEditor histEdit=UserRecoveryHistoryEditor.FromUserPuid(user.Puid, useSecUHDB);
                histEdit.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machA.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(0, 0, 0), 0, RandomPuid(), 1, useSecUHDB));
                histEdit.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machB.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0, RandomPuid(), 1, useSecUHDB));
                histEdit.SetHistory(new UserRecoveryHistoryEditor.UserRecoveryHistoryEntry(user.Puid, machC.Id, "128.128.128.128", System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0), 0, RandomPuid(), 1, useSecUHDB));

                return user;
            }

            public override void Run()
            {
                UserInfo user=GetCachedUser();

                RecoveryHistory ret=new XUserSoapClient().RecoveryHistoryGet(user.Puid, true, null, true, null, true, true, true);
                ValueCheck.Test("Result was returned", true, ret!=null);
                ValueCheck.Test("Number of details returned", 3, ret.Details.Length);

                //return to cache only if it had no problems
                ReturnToCache(user);
            }
        }
    }; //class Stress
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\XUserSoapClient.cs ===
// -------------------------------------------------------------------------------
// class XUserSoapXBL
//
// The wsdl generated class XUser (XUserSoap.cs) can't be used as is
// because it is hard-coded to a specific machine.
// 
// This class provides an implementation that derives from XUser but uses 
// configuration information to send the request to the real XUser servers
//
// -------------------------------------------------------------------------------

using System;
using System.Net;
using System.Web;
using System.Threading;

using xonline.common.service;
using xonline.common.config;
using Microsoft.Xbox.Devices.Test.Integration.Common;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using Microsoft.XboxLive.Auth.Tokens;
using xonline.xuser.soap;

namespace xonline.xuser.soap 
{
    public class XUserTestSoapClient : XUserSoapClient
    {
        public bool AllowAuthHeaderToBeAdded = true;

        public XUserTestSoapClient()
        {
        }

        public XUserTestSoapClient(string subUrl, bool provideNoClaimsByDefault): this(provideNoClaimsByDefault)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xuser_int, Config.SiteId);
            string url = string.Format("{0}://{1}:{2}/{3}", "http", viInfo.IPAddressString, viInfo.Port, subUrl);
            this.Url = url;
        }

        //!TODO: Delete this after all old tests are updated
        public XUserTestSoapClient(bool provideNoClaimsByDefault)
        {
            //Old soap client didn't set any claims by default.  New one sets internal claim by default.  This makes the new one act more like the old one.
            if (provideNoClaimsByDefault)
            {
                System.Reflection.FieldInfo fi = typeof(XUserSoapClient).GetField("_claimsPrincipal", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
                fi.SetValue(this, null);

                Thread.CurrentPrincipal = new System.Security.Principal.GenericPrincipal(new System.Security.Principal.GenericIdentity("", ""), new string[0]);
            }
        }

        //
        // Overrides for injecting the correct token into the request
        //

        public xonline.xuser.soap.UserMachine[] MachineGet(ulong userPuid, System.Nullable<ulong> machinePuid, string friendlyName, System.Nullable<System.DateTime> since, ulong userId, System.Nullable<ulong> deviceId)
        {
            bool machinePuidSpecified = false;
            bool sinceSpecified = false;
            if (machinePuid.HasValue)
            {
                machinePuidSpecified = true;
            }
            if (deviceId.HasValue)
            {
                AuthTestHelper.SetClaimsOnThread(userId, deviceId.Value);
            }
            else
            {
                AuthTestHelper.SetClaimsOnThread(userId);
            }
            if (since.HasValue)
            {
                sinceSpecified = true;
            }
            return base.MachineGet(userPuid, true, machinePuid, machinePuidSpecified, friendlyName, since, sinceSpecified);
        }

        public xonline.xuser.soap.UserMachine[] MachineGet(ulong userPuid, System.Nullable<ulong> machinePuid, string friendlyName, System.Nullable<System.DateTime> since)
        {
            return MachineGet(userPuid, machinePuid, friendlyName, since, userPuid, machinePuid);
        }

        public void ReplaceXAuthdataClaims(System.Collections.Generic.IEnumerable<Claim> newClaims)
        {
            IClaimsPrincipal cp=GetDefaultClaimsPrincipal();
            cp.Identities[0].Claims.Clear();
            foreach (Claim c in newClaims)
            {
                cp.Identities[0].Claims.Add(c);
            }
        }

        private IClaimsPrincipal GetDefaultClaimsPrincipal()
        {
            System.Reflection.FieldInfo fi = typeof(XUserSoapClient).GetField("_claimsPrincipal", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
            return (IClaimsPrincipal)fi.GetValue(this);
        }

        protected override WebRequest GetWebRequest(Uri url)
        {
            //!TODO: Delete this after all the old tests are updated
            //The older tests do some funky things with Thread.CurrentPrincipal.  This exists to allow that to continue working now that we're using the real xuser proxy instead of a duplicated old copy of it.
            if (AllowAuthHeaderToBeAdded && Thread.CurrentPrincipal != null && Thread.CurrentPrincipal is IClaimsPrincipal)
            {
                IClaimsPrincipal claimsPrincipal = Thread.CurrentPrincipal as IClaimsPrincipal;
                if (claimsPrincipal != null && claimsPrincipal.Identities.Count > 0)
                {
                    System.Reflection.FieldInfo fi = typeof(XUserSoapClient).GetField("_claimsPrincipal", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
                    fi.SetValue(this, claimsPrincipal);
                }
            }

            //Let the real client code do it's thing.
            WebRequest req = base.GetWebRequest(url);

            if (!AllowAuthHeaderToBeAdded)
            {
                req.Headers.Remove("Authorization");
            }

            return req;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\UserNotify.cs ===
using System;
using System.ServiceModel;
using System.Net;
using System.IO;
using XUserTests;

using xonline.common.service;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XUserTests
{
    [TestGroup, Owner("WisgT"), TestCasePriority(1)]
    class UserNotify : TestNode
    {

        [TestCase, Description("Verifies basic UserNotify functionality")]
        public void BasicTest()
        {

            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            Global.RO.Debug("Machine {0}, User: {1}", ume.MachinePuid, ume.UserPuid);
            xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }
            if (ume.LastSignin == null)
            {
                throw new ExpectedValueCheckException("LastSignin not set");
            }

            if (ume.LastSignout != null)
            {
                throw new ExpectedValueCheckException("LastSigout was set");
            }
        }

        [TestCase, Description("Sets the Sign and out fields")]
        public void SignInAndOut()
        {

            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException(
                           string.Format("Expected {0} result from UserNotify got: {1}", HttpStatusCode.OK, resp));
            }
            System.Threading.Thread.Sleep(1000);
            // need a new instance after sending
            xuserPost = new XUserNotify();
            xuserPost._SingOut = 1;
            xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
            resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }

            if (ume.LastSignin == null)
            {
                throw new ExpectedValueCheckException("LastSignin not set");
            }

            if (ume.LastSignout == null)
            {
                throw new ExpectedValueCheckException("LastSignout not set");
            }

            if (ume.LastSignout < ume.LastSignin)
            {
                throw new ExpectedValueCheckException("LastSignout < LastSignin", ume.LastSignout, ume.LastSignin);
            }
        }

        [TestCase, Description("Sets the Sign and out fields in the same post")]
        public void SignInAndOutInSamePost()
        {

            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
            xuserPost.FillStream();

            // need a new instance after sending
            xuserPost._SingOut = 1;
            xuserPost.FillStream();
            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }

            if (ume.LastSignin == null)
            {
                throw new ExpectedValueCheckException("LastSignin not set");
            }

            if (ume.LastSignout == null)
            {
                throw new ExpectedValueCheckException("LastSignout not set");
            }
            // todo: time might be ==
            if (ume.LastSignout < ume.LastSignin)
            {
                throw new ExpectedValueCheckException("LastSignout < LastSignin", ume.LastSignout, ume.LastSignin);
            }
            Global.RO.Debug("LastSignout: {0} LastSignin: {1}", ume.LastSignout, ume.LastSignin);
        }

        [TestCase, Description("Verifies that machine history is created for each user")]
        public void MultipleUsersPerMachine()
        {

            XUserNotify xuserPost = new XUserNotify();

            MachineEditor me = MachineEditor.CreateNew();
            UserEditor[] ues = XUserTestUtil.CreateUserEditors(4);
            Int64[] puids = new Int64[ues.Length];
            for (int i = 0; i < ues.Length; i++)
            {
                puids[i] = (Int64)ues[i].Puid;
            }
            xuserPost.SetUserMachinePair((Int64)me.Id, puids);

            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }

            UserMachineHistoryEditor[] umes = new UserMachineHistoryEditor[ues.Length];
            for (int i = 0; i < ues.Length; i++)
            {
                umes[i] = UserMachineHistoryEditor.FromId(ues[i].Puid, me.Id);
            }
            int index = 0;
            foreach (UserMachineHistoryEditor ume in umes)
            {
                if (ume.LastSignin == null)
                {
                    throw new ExpectedValueCheckException(
                        string.Format("LastSignin not set for index{0}", index));
                }

                if (ume.LastSignout != null)
                {
                    throw new ExpectedValueCheckException(
                        string.Format("LastSigout was set for index{0}", index));

                }
                index++;
            }

        }


        [TestCase, Description("Duplicate entries should not causes any issues")]
        [CompoundCase("{0}", 5)]
        [CompoundCase("{0}", 20)]
        public void DuplicatesInPost(TestNode self)
        {

            int count = (int)self.MyValues[0];
            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
            for (int i = 0; i < count; i++)
            {
                xuserPost.FillStream();
            }

            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }
            if (ume.LastSignin == null)
            {
                throw new ExpectedValueCheckException("LastSignin not set");
            }

            if (ume.LastSignout != null)
            {
                throw new ExpectedValueCheckException("LastSigout was set");
            }

        }

        [TestCase, Description("Sends an incomplete post")]
        public void PartialPost()
        {
            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(0, 3, false);
            for (int i = 0; i < umes.Length - 1; i++)
            {
                xuserPost.SetUserMachinePair((Int64)umes[i].MachinePuid, (Int64)umes[i].UserPuid);
                xuserPost.FillStream();
            }
            BinaryWriter bw = xuserPost.OpenStreamWriter();
            xuserPost.SetUserMachinePair((Int64)umes[umes.Length - 1].MachinePuid, (Int64)umes[umes.Length - 1].UserPuid);
            bw.Write((Int16)xuserPost._notificationType);
            bw.Write((Int16)xuserPost._notificationLength);
            bw.Write((UInt32)xuserPost._sgIp);
            bw.Write((UInt32)xuserPost._spi);
            bw.Write((UInt64)xuserPost._mPuid);
            bw.Write((UInt32)xuserPost._reserved);

            //Int64[4]  puids
            foreach (ulong uPuid in xuserPost._uPuids)
            {
                bw.Write((UInt64)uPuid);
            }
            bw.Write((UInt32)xuserPost._clientIp + 1); // host reveres client IP

            // missing the last Uint32
            try
            {
                HttpStatusCode resp = xuserPost.GetResponse();
                if (resp != HttpStatusCode.OK)
                {
                    throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
                }
            }
            catch (System.Net.WebException)
            {
            }
            for (int i = 0; i < umes.Length; i++)
            {
                if (umes[i].LastSignin != null)
                {
                    throw new ExpectedValueCheckException(
                        string.Format("LastSignin set for ume {0}", i));
                }

                if (umes[i].LastSignout != null)
                {
                    throw new ExpectedValueCheckException(
                        string.Format("LastSignin set for ume {0}", i));
                }
            }

        }

        [TestCase, Description("Sends a list of notifies to modify")]
        [CompoundCase("{0}", 10)]
        [CompoundCase("{0}", 200)]
        public void BufferedPost(TestNode self)
        {
            int umiCount = (int)self.MyValues[0];
            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor[] umes = XUserTestUtil.CreateUserMachineHistorys(0, Convert.ToUInt64(umiCount), false);
            foreach (UserMachineHistoryEditor ume in umes)
            {
                xuserPost.SetUserMachinePair((Int64)ume.MachinePuid, (Int64)ume.UserPuid);
                xuserPost.FillStream();
            }

            HttpStatusCode resp = xuserPost.GetResponse();
            if (resp != HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.OK, resp);
            }

            foreach (UserMachineHistoryEditor ume in umes)
            {
                if (ume.LastSignin == null)
                {
                    throw new ExpectedValueCheckException("LastSignin not set");
                }

                if (ume.LastSignout != null)
                {
                    throw new ExpectedValueCheckException("LastSigout was set");
                }
            }
        }

        [TestCase(BugID = 116484, BugDatabase = "TFS"), Description("Verifies that we error on a nonexistent user PUID")]
        public void InvalidUserPuid()
        {

            XUserNotify xuserPost = new XUserNotify();

            UserEditor ue = UserEditor.CreateNew();
            MachineEditor me = MachineEditor.CreateNew();
            xuserPost.SetUserMachinePair((Int64)me.Id, (Int64)ue.Puid);
            ue.CompletelyRemoveUser();
            HttpStatusCode resp = HttpStatusCode.Forbidden;
            try
            {

                resp = xuserPost.GetResponse();
                //throw new UnexpectedTestResultException("Post should have thrown System.Net.WebException");
            }
            catch (System.Net.WebException)
            {

            }
            if (resp == HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.Forbidden, resp);
            }
        }

        [TestCase(BugID = 116484, BugDatabase = "TFS"), Description("User PUID and Machine PUID swapped")]
        public void SwappedUserandMachinePuids()
        {

            XUserNotify xuserPost = new XUserNotify();

            UserMachineHistoryEditor ume = XUserTestUtil.CreateUserMachineHistory(null, null);
            xuserPost.SetUserMachinePair((Int64)ume.UserPuid, (Int64)ume.MachinePuid);
            HttpStatusCode resp = HttpStatusCode.Forbidden;
            try
            {
                resp = xuserPost.GetResponse();
            }
            catch (System.Net.WebException)
            {
            }
            if (resp == HttpStatusCode.OK)
            {
                throw new ExpectedValueCheckException("Unexpected result from UserNotify got", HttpStatusCode.Forbidden, resp);
            }
            if (ume.LastSignin != null)
            {
                throw new ExpectedValueCheckException("LastSignin was set");
            }

            if (ume.LastSignout != null)
            {
                throw new ExpectedValueCheckException("LastSigout was set");
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\test\stf\XUserTestsUtils.cs ===
using System;
using System.Text;
using System.ServiceModel;
using System.Net;
using System.Collections;
using System.Web;
using System.IO;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
//using xonline.xuser.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.xuser.soap;

namespace XUserTests
{
    public class XUserTestGroup : TestNode
    {
        public static bool checkedMaster = false;
        public override void PreRun()
        {
            if (checkedMaster == false)
            {
                if (!ServerTestFramework.LiveService.XSTS.XstsUtil.IsMasterKeyInstalled())
                {
                    ServerTestFramework.LiveService.XSTS.XstsUtil.InstallMasterKey();
                }
                checkedMaster = true;
            }
            base.PreRun();
        }
    }

    public class XUserTestUtil
    {
        // IMPORTANT:
        // If this is set to true, tests will validate specific error messages returned from the server to ensure that the correct failure is happening.
        // However a default installation of xuser prevents detailed errors from being returned to the caller.  So by default this is false and we only validate that "any error" occurs.
        // To enable exception details coming back from the server, edit web.config and edit this line, changing the value from false to true: <serviceDebug includeExceptionDetailInFaults="true"/>
        public static bool ValidateErrorDetails = true;

        // --

                public static string UserKeyStringer(UserKey uk)
        {
            if (uk==null)
            {
                return "";
            }

            return "UserKey(Gamertag="+uk.Gamertag+" EncryptedKey=0x"+Hexer.tohex(uk.EncryptedKey)+" RawKey=0x"+Hexer.tohex(uk.RawKey)+" Version="+uk.Version+" IV=0x"+Hexer.tohex(uk.IV)+" PPA=0x"+Hexer.tohex(uk.PPA)+" SPPA=0x"+Hexer.tohex(uk.SPPA)+")";
        }

        public static void ValidateUserKeyAgainstUserEditor(UserKey uk, UserEditor ue)
        {
            ValueCheck.Test("Gamertag in UserKey", ue.Gamertag, uk.Gamertag);
            ValueCheck.TestAll("EncryptedKey in UserKey", ue.XenonEncKey, uk.EncryptedKey);
            ValueCheck.TestAll("RawKey in UserKey", ue.XenonKey, uk.RawKey);
            ValueCheck.TestAll("IV in UserKey", ue.XenonIv, uk.IV);
            ValueCheck.TestAll("PPA in UserKey", ue.XenonPpa2, uk.PPA);
            ValueCheck.TestAll("SPPA in UserKey", ue.XenonSppa1, uk.SPPA);
            ValueCheck.Test("Version in UserKey", ue.XenonKeyVersion, uk.Version);
        }

        public static void ValidateKeysAreDifferent(UserKey uk1, UserKey uk2)
        {
            ValueCheck.TestNotAll("EncryptedKey in UserKey", uk1.EncryptedKey, uk2.EncryptedKey);
            ValueCheck.TestNotAll("RawKey in UserKey", uk1.RawKey, uk2.RawKey);
            ValueCheck.TestNotAll("IV in UserKey", uk1.IV, uk2.IV);
            ValueCheck.TestNotAll("PPA in UserKey", uk1.PPA, uk2.PPA);
            ValueCheck.TestNotAll("SPPA in UserKey", uk1.SPPA, uk2.SPPA);
        }

        public static void ValidateKeysAreSame(UserKey uk1, UserKey uk2)
        {
            ValueCheck.Test("Gamertag in UserKey", uk1.Gamertag, uk2.Gamertag);
            ValueCheck.TestAll("EncryptedKey in UserKey", uk1.EncryptedKey, uk2.EncryptedKey);
            ValueCheck.TestAll("RawKey in UserKey", uk1.RawKey, uk2.RawKey);
            ValueCheck.TestAll("IV in UserKey", uk1.IV, uk2.IV);
            ValueCheck.TestAll("PPA in UserKey", uk1.PPA, uk2.PPA);
            ValueCheck.TestAll("SPPA in UserKey", uk1.SPPA, uk2.SPPA);
            ValueCheck.Test("Version in UserKey", uk1.Version, uk2.Version);
        }

        public static UserKey PopulateUserKeyFromUserEditor(UserEditor ue)
        {
            UserKey uk=new UserKey();
            uk.Gamertag=ue.Gamertag;
            uk.EncryptedKey=ue.XenonEncKey;
            uk.RawKey=ue.XenonKey;
            uk.IV=ue.XenonIv;
            uk.PPA=ue.XenonPpa2;
            uk.SPPA=ue.XenonSppa1;
            uk.Version=ue.XenonKeyVersion;
            return uk;
        }

        // --

        public static UserMachineHistoryEditor CreateUserMachineHistory(string consoleId, string gamerTag)
        {
            Puid xuid;
            UserEditor ue;
            MachineEditor me;
            UserMachineHistoryEditor ume;

            if (gamerTag == null)
            {
                ue = UserEditor.CreateNew(UserCreationType.Xbox360);
            }
            else
            {
                ue = UserEditor.CreateOrUseExistingGamerTag(gamerTag, UserCreationType.Xbox360);
            }

            if (consoleId == null)
            {
                me = MachineEditor.CreateNew(MachineType.Xbox360);
                xuid = (Puid)me.Id;
            }
            else
            {
                me = MachineEditor.CreateOrUseExistingName(consoleId);
                xuid = (Puid)me.Id;
            }
            ume = UserMachineHistoryEditor.CreateOrUseExisting(ue.Puid, (ulong)xuid);
            
            Global.RO.Debug("Created Machine History for Console: {0} ({1}) GT: {2} (0x{3:X016})", me.ConsoleId, xuid, ue.Gamertag, ue.Puid);
            return ume;
        }

        public static UserMachineHistoryEditor[] CreateUserMachineHistorys(ulong? startId, ulong count, bool useNewSchema)
        {
            UserEditor ue;
            UserMachineHistoryEditor[] umes = new UserMachineHistoryEditor[count];
            ue = UserEditor.CreateNew(UserCreationType.Xbox360);
            for (ulong i = 0; i < count; i++)
            {
                if (startId == 0)
                {
                    umes[i] = XUserTestUtil.CreateUserMachineHistory(null, ue.Gamertag);
                }
                else
                {
                    umes[i] = XUserTestUtil.CreateUserMachineHistory(string.Format("XE.{0:d012}", startId + i), ue.Gamertag);
                }
                if (useNewSchema == true)
                {
                    umes[i].FriendlyName = string.Format("FN_{0}_{1}", ue.Gamertag, i);
                    umes[i].FirstSignin = DateTime.Now.AddDays((double)i - (double)count);
                    umes[i].LastSignin = DateTime.Now.AddDays(((double)i - (double)count) + 2);
                    umes[i].LastSignout = DateTime.Now.AddDays(((double)i - (double)count) + 2.1);
                }
                else
                {
                    umes[i].FirstSeen = DateTime.Now.AddDays((double)i - (double)count);
                    umes[i].LastSeen = DateTime.Now.AddDays(((double)i - (double)count) + 2.1);
                }
            }
            return umes;
        }

        public static UserMachineHistoryEditor[] CreateUserMachineHistorys(ulong startId, ulong count)
        {
            return CreateUserMachineHistorys(startId, count, false);
        }

        // Create some machines
        public static Puid CreateUser(Puid? xuid, string gamerTag)
        {
            UserEditor ue;
            if (gamerTag == null)
            {
                ue = UserEditor.CreateNew(UserCreationType.Xbox360);
                Global.RO.Debug("CreateNewUser: 0x{0:X016}", ue.Puid);
            }
            else
            {
                ue = UserEditor.CreateOrUseExistingGamerTag(gamerTag, UserCreationType.Xbox360);
                Global.RO.Debug("CreateOrUseExistingGamerTag PUID: 0x{0:X016} GT: {1}", ue.Puid, gamerTag);
            }

            if (xuid != null)
            {
                UserMachineHistoryEditor ume = UserMachineHistoryEditor.CreateOrUseExisting(ue.Puid, (ulong)xuid);
            }
            return (Puid)ue.Puid;
        }
        
        public static UserEditor[] CreateUserEditors(int count)
        {
            return CreateUserEditors(count, UserCreationType.Xbox360);
        }

        public static UserEditor[] CreateUserEditors(int count, UserCreationType type)
        {
            UserEditor[] ues = new UserEditor[count];

            for (int i = 0; i < count; i++)
            {
                ues[i] = UserEditor.CreateNew(type);
            }
            return ues;
        }

        public static Puid CreateUser(Puid? xuid)
        {
            return CreateUser(xuid, null);
        }
        public static Puid CreateUser()
        {
            return (Puid)CreateUser(null, null);
        }

        public static Puid CreateMachine(string consoleId)
        {
            MachineEditor me = MachineEditor.CreateOrUseExistingName(consoleId);
            return (Puid)me.Id;
        }

        public static Puid CreateMachine(Puid xuid)
        {
            MachineEditor me;
            if (xuid != 0)
            {
                me = MachineEditor.CreateOrUseExistingId((ulong)xuid);
            }
            else
            {
                me = MachineEditor.CreateNew(MachineType.Xbox360);
            }
            return (Puid) me.Id;
        }

        public static Puid CreateMachine()
        {
 
            return CreateMachine(0);
        }

        //XUser will block calls that exceed the content length and return 400.
        public static void ExecuteCallExpecting400(SimpleCall call)
        {
            try
            {
                call();
            }
            catch (System.Net.WebException we)
            {
                if (we.Message.ToString().Contains("request failed with HTTP status 400"))
                {
                    Global.RO.Debug("Got expected HTTP error: " + we.Message);
                    return;
                }

                throw;
            }

            throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
        }

        public static void ExecuteCallExpecting403(SimpleCall call)
        {
            try
            {
                call();
            }
            catch (System.Net.WebException we)
            {
                if (we.Message.ToString().Contains("request failed with HTTP status 403"))
                {
                    Global.RO.Debug("Got expected HTTP error: " + we.Message);
                    return;
                }

                throw;
            }

            throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
        }

        public delegate void SimpleCall();

        public static void ExecuteCallExpectingSoapError(SimpleCall call, string substringMatch)
        {
            if (ValidateErrorDetails)
            {
                try
                {
                    call();
                }
                catch (System.Web.Services.Protocols.SoapException se)
                {
                    if (se.Message.ToLower().Contains(substringMatch.ToLower()))
                    {
                        Global.RO.Debug("Got expected SOAP error: "+se.Message);
                        return;
                    }

                    throw;
                }

                throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
            }
            else //Do NOT validate specific errors
            {
                try
                {
                    call();
                }
                catch (System.Web.Services.Protocols.SoapHeaderException)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Call unexpectedly succeeded.");
            }
        }

        public static ulong CreateDuplicateXbox360Machine(string consoleId)
        {
            KdcClientXbox360 client=new KdcClientXbox360();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.ConsoleId=consoleId;
            client.XmacsRequest.Input.ConsoleCert=new ConsoleCertificate();
            client.XmacsRequest.Input.ConsoleCert.SetConsoleIdFromGamertag(client.XmacsRequest.Input.ConsoleId);
            client.XmacsRequest.Input.ConsoleCert.ConsolePublicKey.GenerateRandomKey();
            client.XmacsRequest.Input.ConsoleCert.Sign();
            client.ExecuteXmacs(true);

            ulong puid=client.XmacsOutput.MachineId;
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2}", puid, client.XmacsOutput.ConsoleId, Hexer.tohex(client.XmacsRequest.Input.FindConsoleCertificateInPreauths().ComputeHash()));
            return puid;
        }

        public static string CreateUnlimitedPCVoucher()
        {
            string voucher=TokendbWS.CreatePanoramaVoucher(-1);
            Global.RO.Debug("Created new unlimited use count PC voucher: "+voucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher))+")"); //CreatePanoramaVoucher already has debug output
            return voucher;
        }

        public static ulong CreatePCMachine(string voucher)
        {
            KdcClientPC client=new KdcClientPC();
            client.CreateXmacsRequest();
            client.XmacsRequest.Input.SponsorToken=voucher;
            client.ExecuteXmacs(true);

            ulong puid=client.XmacsOutput.MachineId;
            Global.RO.Debug("Created PC: MachineId=0x{0:X} ConsoleId={1} Voucher={2}(Hash=0x{3}) PcId=0x{4}", 
                            puid, client.XmacsOutput.ConsoleId, voucher, Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher)), client.XmacsRequest.Input.PcId);
            return puid;
        }

        public static ulong CreatePhoneMachine()
        {
            //TODO: At some point in the future maybe use the sts client to do this?
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Phone);
            Global.RO.Debug("Created Phone: MachineId=0x{0:X} ConsoleId={1}", mach.Id, mach.ConsoleId);
            return mach.Id;
        }

        public static BasicHttpBinding DefaultBasicHttpBinding(string wsbName)
        {
            BasicHttpBinding wsb = new BasicHttpBinding();
            wsb.Name = wsbName;
            wsb.CloseTimeout = TimeSpan.Parse("00:01:00");
            wsb.OpenTimeout = TimeSpan.Parse("00:01:00");
            wsb.ReceiveTimeout = TimeSpan.Parse("00:10:00");
            wsb.SendTimeout = TimeSpan.Parse("00:01:00");

            wsb.BypassProxyOnLocal = false;
            wsb.HostNameComparisonMode =
                System.ServiceModel.HostNameComparisonMode.StrongWildcard;
            wsb.MaxBufferPoolSize = 524288;
            wsb.MaxReceivedMessageSize = 6553600;
            wsb.MessageEncoding =
                System.ServiceModel.WSMessageEncoding.Text;
            wsb.TextEncoding = System.Text.Encoding.UTF8;
            wsb.UseDefaultWebProxy = true;
            wsb.AllowCookies = false;

            wsb.Security.Transport.ProxyCredentialType = HttpProxyCredentialType.None;
            wsb.Security.Mode = BasicHttpSecurityMode.None;

            return wsb;
        }

        public static xonline.xuser.soap.XUserTestSoapClient GetUserClient()
        {
            return new xonline.xuser.soap.XUserTestSoapClient(true); 
        }

        public static xonline.xuser.soap.XUserTestSoapClient GetUserClient(string subUrl)
        {
            return new xonline.xuser.soap.XUserTestSoapClient(subUrl, true);
        }

        public static void VerifyMachines(xonline.xuser.soap.UserMachine[] machines, UserMachineHistoryEditor[] umes)
        {
            foreach (xonline.xuser.soap.UserMachine machine in machines)
            {
                bool found = false;
                foreach (UserMachineHistoryEditor ume in umes)
                {
                    if (machine.MachinePuid == ume.MachinePuid)
                    {
                        VerifyMachine(machine, ume);
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new ExpectedValueCheckException("No Maching consoles were found in USerMachineHistoryEditor");
                }
            }
        }

        public static void VerifyMachine(xonline.xuser.soap.UserMachine machine, UserMachineHistoryEditor ume)
        {
           
            if (machine.MachinePuid != ume.MachinePuid)
            {
                throw new ExpectedValueCheckException(
                        string.Format("machine.MachinePuid (0x{0:X016}) != ume.MachinePuid (0x{1:X016})", machine.MachinePuid, ume.MachinePuid)); 
            }

            if (ume.FirstSignin != null)
            {
                if (machine.FirstSignIn != ume.FirstSignin)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("machine.FirstSignIn ({0}) != ume.FirstSignin ({1})", machine.FirstSignIn, ume.FirstSignin));
                }
            }
            else
            {
                if (machine.FirstSignIn != ume.FirstSeen)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("machine.FirstSignIn ({0}) != ume.FirstSignin ({1})", machine.FirstSignIn, ume.FirstSeen));
                }
            }

            if (ume.LastSignin != null)
            {
                if (machine.LastSignIn != ume.LastSignin)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("machine.LastSignIn ({0}) != ume.FirstSignin ({1})", machine.LastSignIn, ume.LastSignin));
                }
            }
            else
            {
                if (machine.LastSignIn != ume.LastSeen)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("machine.LastSignIn ({0}) != ume.FirstSignin ({1})", machine.LastSignIn, ume.LastSeen));
                }
            }

            if (ume.LastSignout != null)
            {
                if (machine.LastSignOut != ume.LastSignout)
                {
                    throw new ExpectedValueCheckException(
                            string.Format("machine.LastSignOut ({0}) != ume.LastSignout ({1})", machine.LastSignOut, ume.LastSignout));
                }
            }

            if (machine.DaysSeen != ume.DaysSeen)
            {
                throw new ExpectedValueCheckException(
                        string.Format("machine.DaysSeen ({0}) != ume.DaysSeen ({1})", machine.DaysSeen, ume.DaysSeen));
            }
            if (machine.IpAddress == null)
            {
                if (ume.IPAddress != null && ume.IPAddress.Length > 0)
                {
                    throw new ExpectedValueCheckException(
                                        string.Format("machine.IpAddress ({0}) != ume.IpAddress ({1})", machine.IpAddress, ume.IPAddress));
                }
            }
            else if (machine.IpAddress != ume.IPAddress)
            {
                throw new ExpectedValueCheckException(
                    string.Format("machine.IpAddress ({0}) != ume.IpAddress ({1})", machine.IpAddress, ume.IPAddress));
            }

            if (machine.TrustLevel != ume.TrustLevel)
            {
                throw new ExpectedValueCheckException(
                    string.Format("machine.TrustLevel ({0}) != ume.TrustLevel ({1})", machine.TrustLevel, ume.TrustLevel));
            }

        }

        public static void PrintMachines(xonline.xuser.soap.UserMachine[] machines)
        {
            Global.RO.Debug("Count: {0}", machines.Length);
            if (machines.Length > 0)
            {
                Global.RO.Debug("{0,-18} {1,-22} {2,-22} {3,-22} {4,8} {5,-22} {6,-18} {7,10}",
                    "Machine Puid", "FirstSignIn", "LastSignIn", "LastSignOut",
                    "DaysSeen", "FriendlyName", "IpAddress", "TrustLevel");
                foreach (xonline.xuser.soap.UserMachine machine in machines)
                {
                    Global.RO.Debug("0x{0:X016} {1,-22} {2,-22} {3,-22} {4,8} {5,-22} {6,-18} {7,10}",
                         machine.MachinePuid, machine.FirstSignIn, machine.LastSignIn,
                         machine.LastSignOut, machine.DaysSeen,
                         machine.FriendlyName ?? string.Empty,
                         machine.IpAddress ?? string.Empty,
                         machine.TrustLevel
                     );
                }
            }
        }

        public static void PrintGamertagHistory(xonline.xuser.soap.GamertagHistory gth)
        {
            Global.RO.Debug("Count: {0} (Unique: {1})", gth.Total, gth.Unique);

            if (gth.Details != null && gth.Details.Length > 0)
            {
                Global.RO.Debug("{0,-18} {1,-18} {2,-18} {3,-18} {4,-18}",
                    "Machine Puid", "IpAddress", "NewGamerTag", "OldGamerTag", "User Puid");

                foreach (GamertagHistoryDetails gthd in gth.Details)
                {
                    PrintGamertagHistoryDetail(gthd);
                }
            }
        }

        public static void PrintGamertagHistoryDetail(xonline.xuser.soap.GamertagHistoryDetails gthd)
        {
            Global.RO.Debug("0x{0:X016} {1,-18} {2,-18} {3,-18} 0x{4:X016}",
                gthd.MachinePuid,
                gthd.IpAddress ?? string.Empty,
                gthd.NewGamertag ?? string.Empty,
                gthd.OldGamertag ?? string.Empty,
                gthd.UserPuid);
            
        }

        public static void PrintPassportHistory(xonline.xuser.soap.PassportHistory ph)
        {
            Global.RO.Debug("Count: {0} (Unique: {1})", ph.Total, ph.Unique);

            if (ph.Details != null && ph.Details.Length > 0)
            {
                Global.RO.Debug("{0,-18} {1,-18} {2,-18} {3,-18} {4,-18}",
                    "Machine Puid", "IpAddress", "NewPassportPuid", "OldPassportPuid", "User Puid");

                foreach (PassportHistoryDetails phd in ph.Details)
                {
                    PrintPassportHistoryDetail(phd);
                }
            }
        }

        public static void PrintPassportHistoryDetail(xonline.xuser.soap.PassportHistoryDetails phd)
        {
            Global.RO.Debug("0x{0:X016} {1,-18} 0x{2:X016} 0x{3:X016} 0x{4:X016}",
                phd.MachinePuid,
                phd.IpAddress ?? string.Empty,
                phd.NewPassportPuid,
                phd.OldPassportPuid,
                phd.UserPuid);
        }

        public static void PrintRecoveryHistory(xonline.xuser.soap.RecoveryHistory rh)
        {
            Global.RO.Debug("Count: {0} (Unique: {1})", rh.Total, rh.Unique);

            if (rh.Details != null && rh.Details.Length > 0)
            {
                Global.RO.Debug("{0,-18} {1,-18} {2,-18} {3,-18}",
                    "Machine Puid", "IpAddress", "Passport Puid", "User Puid");

                foreach (RecoveryHistoryDetails rhd in rh.Details)
                {
                    PrintRecoveryHistoryDetail(rhd);
                }
            }
        }

        public static void PrintRecoveryHistoryDetail(xonline.xuser.soap.RecoveryHistoryDetails rhd)
        {
            Global.RO.Debug("0x{0:X016} {1,-18} 0x{2:X016} 0x{3:X016}",
                rhd.MachinePuid,
                rhd.IpAddress ?? string.Empty,
                rhd.PassportPuid,
                rhd.UserPuid);
        }

        public static void PrintHistoryDetail(xonline.xuser.soap.HistoryDetails[] hd)
        {
            Global.RO.Debug("HistoryDetails Count: {0}", hd.Length);

            foreach (HistoryDetails hds in hd)
            {
                Global.RO.Debug("0x{0:X016} {1,-18} 0x{3:X016}",
                    hds.MachinePuid,
                    hds.IpAddress ?? string.Empty,
                    hds.UserPuid);
            }
        }

        public static string ByteToString(byte[] arrayValue)
        {
            // BitConverted adds '-' which I don't want for these
            StringBuilder sb = new StringBuilder("0x");
            foreach (byte bt in arrayValue)
            {
                sb = sb.Append(Convert.ToString(bt, 16).ToUpper());
            }

            return sb.ToString();
        }

        public static void PrintUserKey(xonline.xuser.soap.UserKey key)
        {
            Global.RO.Debug("{0,-13} {1:,-7} {2,-36} {3,-36} {4,-36} {5,-19} {6,-36}",
                "Gamertag", "Version", "IV", "Encrypted key", "Raw Key", "PPA", "SPPA");

            Global.RO.Debug("{0,-13} {1,-7} {2,-36} {3,-36} {4,-36} {5,-19} {6,-36}",
                key.Gamertag, key.Version,
                ByteToString(key.IV),
                ByteToString(key.EncryptedKey),
                ByteToString(key.RawKey),
                ByteToString(key.PPA),
                ByteToString(key.SPPA)
                );
        }

        public static bool ByteArraysEqual(byte[] b1, byte[] b2)
        {
            if (b1 == b2)
                return true;
            if (b1 == null || b2 == null)
                return false;
            if (b1.Length != b2.Length)
                return false;

            for (int i = 0; i < b1.Length; i++)
            {
                if (b1[i] != b2[i])
                    return false;
            }
            return true; 
        }

        public static void VerifyUserKey(xonline.xuser.soap.UserKey userKey, UserEditor userEditor)
        {
            if (userKey.Gamertag != userEditor.Gamertag)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.MachinePuid {0} != userEditor.MachinePuid {1}", userKey.Gamertag, userEditor.Gamertag));
            }

            if (userKey.Version != userEditor.XenonKeyVersion)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.Version {0} != userEditor.XenonKeyVersion {1}", userKey.Version, userEditor.XenonKeyVersion));
            }

            if (!ByteArraysEqual(userKey.IV, userEditor.XenonIv))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.IV {0} != userEditor.XenonIv {1}", ByteToString(userKey.IV), ByteToString(userEditor.XenonIv)));
            }
            
            if (!ByteArraysEqual(userKey.EncryptedKey, userEditor.XenonEncKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.EncryptedKey {0} != userEditor.XenonEncKey {1}", ByteToString(userKey.EncryptedKey), ByteToString(userEditor.XenonEncKey)));
            }

            if (!ByteArraysEqual(userKey.PPA, userEditor.XenonPpa2))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.PPA {0} != userEditor.XenonPpa2 {1}", ByteToString(userKey.PPA), ByteToString(userEditor.XenonPpa2)));
            }
            
            if (!ByteArraysEqual(userKey.SPPA, userEditor.XenonSppa1))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.SPPA {0} != userEditor.XenonSppa1 {1}", ByteToString(userKey.SPPA), ByteToString(userEditor.XenonSppa1)));
            }

            if (!ByteArraysEqual(userKey.RawKey, userEditor.XenonKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.RawKey {0} != userEditor.XenonKey {1}", ByteToString(userKey.RawKey), ByteToString(userEditor.XenonKey)));
            }
        }

        public static void VerifyResetUserKey(xonline.xuser.soap.UserKey userKey, xonline.xuser.soap.UserKey userKey2)
        {
            if (userKey.Gamertag != userKey2.Gamertag)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.MachinePuid {0} != userKey2.MachinePuid {1}", userKey.Gamertag, userKey2.Gamertag));
            }

            if (userKey.Version != userKey2.Version)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.Version {0} != userKey2.XenonKeyVersion {1}", userKey.Version, userKey2.Version));
            }

            if (ByteArraysEqual(userKey.IV, userKey2.IV))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.IV {0} == userKey2.XenonIv {1}", ByteToString(userKey.IV), ByteToString(userKey2.IV)));
            }

            if (ByteArraysEqual(userKey.EncryptedKey, userKey2.EncryptedKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.EncryptedKey {0} == userKey2.XenonEncKey {1}", ByteToString(userKey.EncryptedKey), ByteToString(userKey2.EncryptedKey)));
            }

            if (ByteArraysEqual(userKey.PPA, userKey2.PPA))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.PPA {0} == userKey2.XenonPpa2 {1}", ByteToString(userKey.PPA), ByteToString(userKey2.PPA)));
            }

            if (ByteArraysEqual(userKey.SPPA, userKey2.SPPA))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.SPPA {0} == userKey2.XenonSppa1 {1}", ByteToString(userKey.SPPA), ByteToString(userKey2.SPPA)));
            }


            if (ByteArraysEqual(userKey.RawKey, userKey2.RawKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.RawKey {0} == userKey2.XenonKey {1}", ByteToString(userKey.RawKey), ByteToString(userKey2.RawKey)));
            }
        }

        public static void CompairUserKey(xonline.xuser.soap.UserKey userKey, xonline.xuser.soap.UserKey userKey2)
        {
            if (userKey.Gamertag != userKey2.Gamertag)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.MachinePuid {0} != userKey2.MachinePuid {1}", userKey.Gamertag, userKey2.Gamertag));
            }

            if (userKey.Version != userKey2.Version)
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.Version {0} != userKey2.XenonKeyVersion {1}", userKey.Version, userKey2.Version));
            }

            if (!ByteArraysEqual(userKey.IV, userKey2.IV))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.IV {0} != userKey2.XenonIv {1}", ByteToString(userKey.IV), ByteToString(userKey2.IV)));
            }

            if (!ByteArraysEqual(userKey.EncryptedKey, userKey2.EncryptedKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.EncryptedKey {0} != userKey2.XenonEncKey {1}", ByteToString(userKey.EncryptedKey), ByteToString(userKey2.EncryptedKey)));
            }

            if (!ByteArraysEqual(userKey.PPA, userKey2.PPA))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.PPA {0} != userKey2.XenonPpa2 {1}", ByteToString(userKey.PPA), ByteToString(userKey2.PPA)));
            }

            if (!ByteArraysEqual(userKey.SPPA, userKey2.SPPA))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.SPPA {0} != userKey2.XenonSppa1 {1}", ByteToString(userKey.SPPA), ByteToString(userKey2.SPPA)));
            }

            if (!ByteArraysEqual(userKey.RawKey, userKey2.RawKey))
            {
                throw new ExpectedValueCheckException(
                        string.Format("userKey.RawKey {0} != userKey2.XenonKey {1}", ByteToString(userKey.RawKey), ByteToString(userKey2.RawKey)));
            }
        }

        public static int TranslateSoapEnumTrustLevel(xonline.xuser.soap.MachineTrustLevel mtl)
        {
            if (mtl == xonline.xuser.soap.MachineTrustLevel.Unknown)
            {
                return -1;
            }
            else if (mtl == xonline.xuser.soap.MachineTrustLevel.Untrusted)
            {
                return 0;
            }
            else if (mtl == xonline.xuser.soap.MachineTrustLevel.Trusted)
            {
                return 1;
            }
            else
            {
                throw new UnexpectedTestResultException("Unhandled trest level: " + mtl);
            }
        }

        public static void ReloadConfig()
        {
            String xmgmtText;
            
            if(!ManagementConsole.ExecuteOnAllIISProcess(Interface.xuser, "xuser", "xuser configcacherefresh", out xmgmtText))
            {
                // This just means that XUser isn't running yet so we can ignore this error
                if (!xmgmtText.Contains("No process id for w3wp:xuser seems to be running"))
                {
                    throw new UnexpectedTestResultException("Unable to reload configuration: " + xmgmtText);
                }
            }
        }
    }

    class XUserNotify
    {
        WebRequest _request;
        HttpWebResponse _responce;
        BinaryWriter _binaryWriter = null;
        string _url;
        bool _isStreamFilled = false;
        public Int16 _notificationType = 0;      // notification type - ignored
        public Int16 _notificationLength = 55;   // notification length - ignored
        public Int32 _sgIp = 0;                  // IPAddress of SG - ignored
        public Int32 _spi = 0;                   // SPI - logged only
        public Int64 _mPuid = 0;                 // machine puid
        public Int32 _reserved = 0;              // reserved
        public Int64[] _uPuids;                  // array of user puids
        public Int32 _clientIp = 0;              // Client IP address
        public Int32 _SingOut = 0;               // Singin == 0 Signout == 1

        public XUserNotify()
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xuser_int, Config.SiteId);
            _url = string.Format("{0}://{1}:{2}/XUser/UserNotify.ashx", viInfo.Protocol, viInfo.IPAddressString, viInfo.Port);
            //_url = string.Format("{0}://{1}:{2}/XUser/UserNotify.ashx", viInfo.Protocol, "S1XBLXMCHIIS801", "13060");
            BuildRequest();
        }

        public XUserNotify(string url)
        {
            _url = url;
            BuildRequest();
        }

        private void BuildRequest()
        {
            _request = WebRequest.Create(_url);
            _request.Method = "POST";
            _request.ContentType = "xon/0";
            _uPuids = new Int64[4];
            for (int i = 0; i < _uPuids.Length; i++)
            {
                _uPuids[i] = 0;
            }
            _sgIp = BitConverter.ToInt32(IPAddress.Parse("157.54.131.10").GetAddressBytes(), 0);
            SetLocalIPAddress();
        }

        public void SetLocalIPAddress()
        {
            IPAddress[] ipAddresses = Dns.GetHostAddresses(Dns.GetHostName());
            foreach (IPAddress ipAddress in ipAddresses)
            {
                if (ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    _clientIp = BitConverter.ToInt32(ipAddress.GetAddressBytes(), 0);
                    break;
                }
            }
        }
        //
        // We allow for calling this publicly to create partial streams
        //
        public BinaryWriter OpenStreamWriter()
        {

            if (_binaryWriter == null)
            {
                _binaryWriter = new BinaryWriter(_request.GetRequestStream());
            }

            return _binaryWriter;
        }

        public void CloseStreamWriter()
        {
            if (_binaryWriter != null)
            {
                _binaryWriter.Close();
                _binaryWriter = null;
            }
        }

        public HttpStatusCode GetResponse()
        {
            HttpStatusCode retcode;
            // we do this to allow for multiple direct stream fills
            if (!_isStreamFilled)
            {
                FillStream();
            }
            CloseStreamWriter();
            //
            // Execute the query Framework will handle any exceptions
            //
            _responce = (HttpWebResponse)_request.GetResponse();
            if (_responce != null)
            {
                StreamReader sr = new StreamReader(_responce.GetResponseStream());
                string ret = sr.ReadToEnd();
                if (ret.Length > 0)
                {
                    Global.RO.Debug("Http Response: \"{0}\"", ret);
                }
            }
            retcode = _responce.StatusCode;
            _responce.Close();
            //BuildRequest();
            return retcode;

        }

        public void SetUserMachinePair(Int64 mPuid, Int64 uPuid)
        {
            Int64[] uPuids = new Int64[1];
            uPuids[0] = uPuid;
            SetUserMachinePair(mPuid, uPuids);
        }
        public void FillStream()
        {
            //
            // Designed to be called multiple times publicly to add more items to the stream
            //
            _isStreamFilled = true;
            BinaryWriter bw = OpenStreamWriter();
            bw.Write((Int16)_notificationType);     // notification type - ignored
            bw.Write((Int16)_notificationLength);   // notification length - ignored
            bw.Write((UInt32)_sgIp);                // IPAddress of SG  ignored.
            bw.Write((UInt32)_spi);                 // SPI  logged only
            bw.Write((UInt64)_mPuid);               // machine puid
            bw.Write((UInt32)_reserved);            // reserved  ignored

            //Int64[4] puids
            foreach (ulong uPuid in _uPuids)
            {
                bw.Write((UInt64)uPuid);
            }
            bw.Write((UInt32)_clientIp);            // host reveres client ip
            bw.Write((UInt32)_SingOut);             // Signin == 0 Signout == 1
        }

        public void SetUserMachinePair(Int64 mPuid, Int64[] uPuids)
        {
            _mPuid = mPuid; 
            int count = 0;

            if (uPuids.Length > 4)
            {
                throw new ExpectedValueCheckException("uPuids list must have 4 or less items");
            }
            // Int64[4] puids
            foreach (Int64 uPuid in uPuids)
            {
                _uPuids[count] = uPuid;
                count++;
            }

            //
            // make sure the rest of the PUIDs are empty
            //
            while (count < 4)
            {
                _uPuids[count] = 0;
                count++;
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\XUserProxy\XUserSoapClient.cs ===
// -------------------------------------------------------------------------------
// class XUserSoapXBL
//
// The wsdl generated class XUser (XUserSoap.cs) can't be used as is
// because it is hard-coded to a specific machine.
// 
// This class provides an implementation that derives from XUser but uses 
// configuration information to send the request to the real XUser servers
//
// -------------------------------------------------------------------------------

using System;
using System.Net;
using System.Web;
using System.Threading;

using xonline.common.config;

using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;

using Microsoft.XboxLive.Auth.Tokens;

namespace xonline.xuser.soap
{
    public class XUserSoapClient : XUser
    {
        private string _urlPrefix;
        private IClaimsPrincipal _claimsPrincipal;

        public XUserSoapClient()
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xuser_int, Config.SiteId);
            _urlPrefix = viInfo.Protocol + "://" + viInfo.IPAddressString + ":" + viInfo.Port;

            Uri uri = new Uri(this.Url);
            this.Url = _urlPrefix + uri.LocalPath;

            _claimsPrincipal = new ClaimsPrincipal();
            IClaimsIdentity identity = new ClaimsIdentity();

            identity.Claims.Add(new Claim("http://schemas.microsoft.com/xbox/2011/07/claims/internal", Config.ComponentName, ClaimValueTypes.String, "System"));
            _claimsPrincipal.Identities.Add(identity);
        }

        // This code exists in order to load balance the connection to the
        // various XUser boxes that sit behind a VIP
        //  
        // See http://support.microsoft.com/kb/2551125 as to why it was done
        // this way instead of using ConnectionGroupName
        protected override WebRequest GetWebRequest(Uri uri)
        {
            WebRequest webRequest = base.GetWebRequest(uri);
            HttpWebRequest httpWebRequest = webRequest as HttpWebRequest;

            if (httpWebRequest != null)
            {
                httpWebRequest.KeepAlive = false;

                if (_claimsPrincipal != null) {
                    httpWebRequest.SetXAuthdata(_claimsPrincipal);
                }
            }

            return webRequest;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\XUserProxy\XUserSoap.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4963
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

#pragma warning disable 1591

namespace xonline.xuser.soap {


// 
// Assembly WebServiceStudio Version = 2.0.50727.4963
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BasicHttpBinding_IXUser", Namespace="http://tempuri.org/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(HistoryDetails))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(HistorySummary))]
public partial class XUser : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public XUser() {
        this.Url = "http://127.0.0.1:13060/xuser/xuser.svc";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/MachineGet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
    public UserMachine[] MachineGet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string friendlyName, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool sinceSpecified) {
        object[] results = this.Invoke("MachineGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    friendlyName,
                    since,
                    sinceSpecified});
        return ((UserMachine[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMachineGet(ulong userPuid, bool userPuidSpecified, System.Nullable<ulong> machinePuid, bool machinePuidSpecified, string friendlyName, System.Nullable<System.DateTime> since, bool sinceSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MachineGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    friendlyName,
                    since,
                    sinceSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserMachine[] EndMachineGet(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserMachine[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/MachineTrustLevelSet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void MachineTrustLevelSet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, ulong machinePuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, MachineTrustLevel trustLevel, [System.Xml.Serialization.XmlIgnoreAttribute()] bool trustLevelSpecified) {
        this.Invoke("MachineTrustLevelSet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    trustLevel,
                    trustLevelSpecified});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMachineTrustLevelSet(ulong userPuid, bool userPuidSpecified, ulong machinePuid, bool machinePuidSpecified, MachineTrustLevel trustLevel, bool trustLevelSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MachineTrustLevelSet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    trustLevel,
                    trustLevelSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMachineTrustLevelSet(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/MachineFriendlyNameSet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void MachineFriendlyNameSet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, ulong machinePuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string friendlyName) {
        this.Invoke("MachineFriendlyNameSet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    friendlyName});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMachineFriendlyNameSet(ulong userPuid, bool userPuidSpecified, ulong machinePuid, bool machinePuidSpecified, string friendlyName, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MachineFriendlyNameSet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    friendlyName}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMachineFriendlyNameSet(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/UserKeyGet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public UserKey UserKeyGet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified) {
        object[] results = this.Invoke("UserKeyGet", new object[] {
                    userPuid,
                    userPuidSpecified});
        return ((UserKey)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUserKeyGet(ulong userPuid, bool userPuidSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UserKeyGet", new object[] {
                    userPuid,
                    userPuidSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserKey EndUserKeyGet(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserKey)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/UserKeyReset", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public UserKey UserKeyReset(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified) {
        object[] results = this.Invoke("UserKeyReset", new object[] {
                    userPuid,
                    userPuidSpecified});
        return ((UserKey)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUserKeyReset(ulong userPuid, bool userPuidSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UserKeyReset", new object[] {
                    userPuid,
                    userPuidSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserKey EndUserKeyReset(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserKey)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/GamertagHistoryGetByGamertag", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public GamertagHistory GamertagHistoryGetByGamertag([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string gamertag, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool sinceSpecified, bool details, [System.Xml.Serialization.XmlIgnoreAttribute()] bool detailsSpecified) {
        object[] results = this.Invoke("GamertagHistoryGetByGamertag", new object[] {
                    gamertag,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified});
        return ((GamertagHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGamertagHistoryGetByGamertag(string gamertag, System.Nullable<System.DateTime> since, bool sinceSpecified, bool details, bool detailsSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GamertagHistoryGetByGamertag", new object[] {
                    gamertag,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public GamertagHistory EndGamertagHistoryGetByGamertag(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((GamertagHistory)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/GamertagHistoryGetByUserPuid", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public GamertagHistory GamertagHistoryGetByUserPuid(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool sinceSpecified, bool details, [System.Xml.Serialization.XmlIgnoreAttribute()] bool detailsSpecified) {
        object[] results = this.Invoke("GamertagHistoryGetByUserPuid", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified});
        return ((GamertagHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGamertagHistoryGetByUserPuid(ulong userPuid, bool userPuidSpecified, System.Nullable<ulong> machinePuid, bool machinePuidSpecified, System.Nullable<System.DateTime> since, bool sinceSpecified, bool details, bool detailsSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GamertagHistoryGetByUserPuid", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public GamertagHistory EndGamertagHistoryGetByUserPuid(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((GamertagHistory)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/PassportHistoryGet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public PassportHistory PassportHistoryGet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool sinceSpecified, bool details, [System.Xml.Serialization.XmlIgnoreAttribute()] bool detailsSpecified) {
        object[] results = this.Invoke("PassportHistoryGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified});
        return ((PassportHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPassportHistoryGet(ulong userPuid, bool userPuidSpecified, System.Nullable<ulong> machinePuid, bool machinePuidSpecified, System.Nullable<System.DateTime> since, bool sinceSpecified, bool details, bool detailsSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PassportHistoryGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public PassportHistory EndPassportHistoryGet(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((PassportHistory)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/RecoveryHistoryGet", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public RecoveryHistory RecoveryHistoryGet(ulong userPuid, [System.Xml.Serialization.XmlIgnoreAttribute()] bool userPuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<ulong> machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool machinePuidSpecified, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] [System.Xml.Serialization.XmlIgnoreAttribute()] bool sinceSpecified, bool details, [System.Xml.Serialization.XmlIgnoreAttribute()] bool detailsSpecified) {
        object[] results = this.Invoke("RecoveryHistoryGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified});
        return ((RecoveryHistory)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRecoveryHistoryGet(ulong userPuid, bool userPuidSpecified, System.Nullable<ulong> machinePuid, bool machinePuidSpecified, System.Nullable<System.DateTime> since, bool sinceSpecified, bool details, bool detailsSpecified, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RecoveryHistoryGet", new object[] {
                    userPuid,
                    userPuidSpecified,
                    machinePuid,
                    machinePuidSpecified,
                    since,
                    sinceSpecified,
                    details,
                    detailsSpecified}, callback, asyncState);
    }
    
    /// <remarks/>
    public RecoveryHistory EndRecoveryHistoryGet(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((RecoveryHistory)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/GamertagHistoryLog", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void GamertagHistoryLog([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] GamertagHistoryDetails gthd) {
        this.Invoke("GamertagHistoryLog", new object[] {
                    gthd});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGamertagHistoryLog(GamertagHistoryDetails gthd, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GamertagHistoryLog", new object[] {
                    gthd}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGamertagHistoryLog(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/PassportHistoryLog", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void PassportHistoryLog([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] PassportHistoryDetails phd) {
        this.Invoke("PassportHistoryLog", new object[] {
                    phd});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPassportHistoryLog(PassportHistoryDetails phd, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PassportHistoryLog", new object[] {
                    phd}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPassportHistoryLog(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://xonline.xuser.V1/IXUser/RecoveryHistoryLog", RequestNamespace="http://xonline.xuser.V1", ResponseNamespace="http://xonline.xuser.V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void RecoveryHistoryLog([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] RecoveryHistoryDetails rhd) {
        this.Invoke("RecoveryHistoryLog", new object[] {
                    rhd});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRecoveryHistoryLog(RecoveryHistoryDetails rhd, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RecoveryHistoryLog", new object[] {
                    rhd}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRecoveryHistoryLog(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class UserMachine {
    
    /// <remarks/>
    public int DaysSeen;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool DaysSeenSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<System.DateTime> FirstSignIn;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool FirstSignInSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string FriendlyName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string IpAddress;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<System.DateTime> LastSignIn;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool LastSignInSpecified;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<System.DateTime> LastSignOut;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool LastSignOutSpecified;
    
    /// <remarks/>
    public ulong MachinePuid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool MachinePuidSpecified;
    
    /// <remarks/>
    public int TrustLevel;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool TrustLevelSpecified;
    
    /// <remarks/>
    public ulong UserPuid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool UserPuidSpecified;
}

/// <remarks/>
[System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportHistoryDetails))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RecoveryHistoryDetails))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagHistoryDetails))]
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class HistoryDetails {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string IpAddress;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> MachinePuid;
    
    /// <remarks/>
    public byte Reason;
    
    /// <remarks/>
    public uint Result;
    
    /// <remarks/>
    public System.DateTime Timestamp;
    
    /// <remarks/>
    public ulong UserPuid;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class PassportHistoryDetails : HistoryDetails {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> NewPassportPuid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<ulong> OldPassportPuid;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class RecoveryHistoryDetails : HistoryDetails {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=false)]
    public ulong PassportPuid;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class GamertagHistoryDetails : HistoryDetails {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string NewGamertag;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string OldGamertag;
}

/// <remarks/>
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RecoveryHistory))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportHistory))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagHistory))]
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class HistorySummary {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<System.DateTime> First;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public System.Nullable<System.DateTime> Last;
    
    /// <remarks/>
    public int Total;
    
    /// <remarks/>
    public int Unique;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class RecoveryHistory : HistorySummary {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
    public RecoveryHistoryDetails[] Details;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class PassportHistory : HistorySummary {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
    public PassportHistoryDetails[] Details;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class GamertagHistory : HistorySummary {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
    public GamertagHistoryDetails[] Details;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public partial class UserKey {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary", IsNullable=true)]
    public byte[] EncryptedKey;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
    public string Gamertag;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary", IsNullable=true)]
    public byte[] IV;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary", IsNullable=true)]
    public byte[] PPA;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary", IsNullable=true)]
    public byte[] RawKey;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary", IsNullable=true)]
    public byte[] SPPA;
    
    /// <remarks/>
    public int Version;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIgnoreAttribute()]
    public bool VersionSpecified;
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("WebServiceStudio", "0.0.0.0")]
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://xonline.xuser.V1")]
public enum MachineTrustLevel {
    
    /// <remarks/>
    Unknown,
    
    /// <remarks/>
    Untrusted,
    
    /// <remarks/>
    Trusted,
}


}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\azure\xlfs\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_servicexml_none_12.4.56.0_none_332a9f65d8d63368
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=servicexml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.manifest
XP_MANIFEST_PATH=manifests\x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.cat
XP_CATALOG_PATH=manifests\x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.cat
XP_PAYLOAD_PATH=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=servicexml,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xuser\XUserProxy\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XUserProxy")]
[assembly: AssemblyDescription("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b5359f1d-bbd7-4a63-8461-edab22c56bdd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\azure\xlfs\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_servicexml_none_12.4.56.0_none_332a9f65d8d63368
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=servicexml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.manifest
XP_MANIFEST_PATH=manifests\x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.cat
XP_CATALOG_PATH=manifests\x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38.cat
XP_PAYLOAD_PATH=x86_servicexml_no-public-key_12.4.56.0_x-ww_88608b38
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=servicexml,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\lsmonitor\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_lsmmonitor_none_12.4.56.0_none_ba4d6e46584b5b08
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsmmonitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.manifest
XP_MANIFEST_PATH=manifests\x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.cat
XP_CATALOG_PATH=manifests\x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.cat
XP_PAYLOAD_PATH=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsmmonitor,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\lsmonitor\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

CHECKSCRIPT=$(INETROOT)\private\setup\inc\checkServiceManifest.vbs


!IF "$(SERVICE_MANIFESTS)"==""
SERVICE_MANIFESTS=service.xml
!ENDIF

!IF "$(SERVICE_MANIFEST_DROP)"==""
SERVICE_MANIFEST_DROP=$(_NT386TREE)\
!ENDIF

Validate-Service-Manifests:
!IF "$(LINKONLY)"=="1"
    @echo Build_status Validating service manifest ...
    @for %f in ($(SERVICE_MANIFESTS)) do ( \
        @echo $(CHECKSCRIPT) %f $(SERVICE_MANIFEST_DROP) $(MSI_EXCEPTIONS) & \
        @cscript //e:jscript //NOLOGO $(CHECKSCRIPT) %f $(SERVICE_MANIFEST_DROP) $(MSI_EXCEPTIONS) \
    )
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\lsmonitor\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_lsmmonitor_none_12.4.56.0_none_ba4d6e46584b5b08
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsmmonitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.manifest
XP_MANIFEST_PATH=manifests\x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.cat
XP_CATALOG_PATH=manifests\x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a.cat
XP_PAYLOAD_PATH=x86_lsmmonitor_no-public-key_12.4.56.0_x-ww_95a5bd4a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsmmonitor,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\octopus\extendedFAST\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_extendedservicexml_none_12.4.56.0_none_2d57299772e2d913
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=extendedservicexml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.manifest
XP_MANIFEST_PATH=manifests\x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.cat
XP_CATALOG_PATH=manifests\x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.cat
XP_PAYLOAD_PATH=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=extendedservicexml,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\octopus\extendedFAST\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_extendedservicexml_none_12.4.56.0_none_2d57299772e2d913
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=extendedservicexml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.manifest
XP_MANIFEST_PATH=manifests\x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.cat
XP_CATALOG_PATH=manifests\x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1.cat
XP_PAYLOAD_PATH=x86_extendedservicexml_no-public-key_12.4.56.0_x-ww_7e0172b1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=extendedservicexml,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\octopus\xdl\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

OUTPUTDIR=$(_NT386TREE)\msi\esp

XDLC=$(INETROOT)\public\ext\xonline-ext\xdlc\xdlc.exe
XDLROOT=$(INETROOT)\private\setup\octopus\xdl\definition

CONFIGGENTOOL=$(INETROOT)\public\ext\xonline-ext\ConfigGenerator\ConfigGenerator.exe
CONFIGTEMPLATE=..\configuration\xblob\config-template.xml
CONFIGOUTPUT=$(OUTPUTDIR)\configuration\xblob\configuration.xml
SERVICEXMLROOT=$(OUTPUTDIR)


Generate-Service-Manifests:
!IF "$(BUILD_PASS)"=="PASS0"
    @echo Build_status Generating service manifest ...
    @cmd /c $(XDLC) $(XDLROOT) $(OUTPUTDIR)
!ENDIF

Generate-Xblob-Config:
!IF "$(BUILD_PASS)"=="PASS2"
    @echo Build_status Generating xblob config ...
    @cmd /c $(CONFIGGENTOOL) /configoutput:"$(CONFIGOUTPUT)" /configtemplate:"$(CONFIGTEMPLATE)" /servicexmlpath:"$(SERVICEXMLROOT)" /defaultserver:"##_XBLOBMACHINE_##" /removeroles:"SiteConfiguration;Xds;SgServer;ActiveAuthAllGateway;ActiveAuthGateway;ActiveAuthClientAuthGateway;ActiveAuthLegacyGateway;ActiveAuthServicesGateway;ActiveAuthClientAuthServicesGateway;ActiveAuthAsyncServicesGateway;ActiveAuthAvatarGateway;ActiveAuthVortexGateway;Configure Partner Access Control" /clearallroles
!ENDIF

Copy-Configuration-Files:
!IF "$(BUILD_PASS)"=="PASS2"
    xcopy /s /v $(INETROOT)\private\setup\octopus\configuration\* $(_NT386TREE)\msi\esp\configuration\*
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\octopus\xdl\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xdl_none_12.4.56.0_none_b4e82ec5192af6c2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xdl
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.manifest
XP_MANIFEST_PATH=manifests\x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.cat
XP_CATALOG_PATH=manifests\x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.cat
XP_PAYLOAD_PATH=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xdl,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\octopus\xdl\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xdl_none_12.4.56.0_none_b4e82ec5192af6c2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xdl
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.manifest
XP_MANIFEST_PATH=manifests\x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.cat
XP_CATALOG_PATH=manifests\x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16.cat
XP_PAYLOAD_PATH=x86_xdl_no-public-key_12.4.56.0_x-ww_bed4df16
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xdl,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\SQLSetup\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
      -mkdir $(_NT386TREE)\msi\SQLSetup
      -$(_NT386TREE)\tools\xmlprep\xmlprep.exe service.xml > $(_NT386TREE)\msi\SQLSetup\service.xml
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobbase\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
      -mkdir $(_NT386TREE)\msi\xblobbase
      -robocopy Tools $(_NT386TREE)\msi\xblobbase\Tools *.* /R:0 /NP /NJH /NJS /A-:R
      -robocopy MSI $(_NT386TREE)\msi\xblobbase\MSI *.* /R:0 /NP /NJH /NJS /A-:R
      -robocopy $(XONEXTPATH)\webstore\5.5.2421.0000\WstClientlib\disk1 $(_NTTREE)\webstore55\WstClientlib /MIR /R:0 /NP /NJH /NJS /A-:R
      -robocopy $(XONEXTPATH)\webstore\5.5.2421.0000\WstSetup\disk1 $(_NTTREE)\webstore55\WstSetup /MIR /R:0 /NP /NJH /NJS /A-:R
      -$(_NT386TREE)\tools\xmlprep\xmlprep.exe service.xml > $(_NT386TREE)\msi\xblobbase\service.xml
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobbase\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblobbase_1_none_12.4.56.0_none_21121ee854dc2917
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblobbase_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.manifest
XP_MANIFEST_PATH=manifests\x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.cat
XP_CATALOG_PATH=manifests\x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.cat
XP_PAYLOAD_PATH=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblobbase_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobbase\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblobbase_1_none_12.4.56.0_none_21121ee854dc2917
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblobbase_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.manifest
XP_MANIFEST_PATH=manifests\x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.cat
XP_CATALOG_PATH=manifests\x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef.cat
XP_PAYLOAD_PATH=x86__xblobbase_1_no-public-key_12.4.56.0_x-ww_f448eeef
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblobbase_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobprep\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
      -robocopy . $(_NT386TREE)\msi\xblobprep *.xml *.msi CreateTraceShare.cmd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_3_none_12.4.56.0_none_2758e45a43f77aac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_MANIFEST_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_CATALOG_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_PAYLOAD_PATH=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobprep\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblobprep_0_none_12.4.56.0_none_393914383264632c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblobprep_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.manifest
XP_MANIFEST_PATH=manifests\x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.cat
XP_CATALOG_PATH=manifests\x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.cat
XP_PAYLOAD_PATH=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblobprep_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\setup\xblobprep\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblobprep_0_none_12.4.56.0_none_393914383264632c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblobprep_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.manifest
XP_MANIFEST_PATH=manifests\x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.cat
XP_CATALOG_PATH=manifests\x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a.cat
XP_PAYLOAD_PATH=x86__xblobprep_0_no-public-key_12.4.56.0_x-ww_cc57320a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblobprep_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__common_3_none_12.4.56.0_none_2758e45a43f77aac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_MANIFEST_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_CATALOG_PATH=manifests\x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4.cat
XP_PAYLOAD_PATH=x86__common_3_no-public-key_12.4.56.0_x-ww_e3ca9af4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_common_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\querydb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\querydb
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\querydb\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\querydb\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__querydb_1_none_12.4.56.0_none_9dc7662cf9e13175
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_querydb_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.manifest
XP_MANIFEST_PATH=manifests\x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.cat
XP_CATALOG_PATH=manifests\x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.cat
XP_PAYLOAD_PATH=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_querydb_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\querydb\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__querydb_1_none_12.4.56.0_none_9dc7662cf9e13175
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_querydb_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.manifest
XP_MANIFEST_PATH=manifests\x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.cat
XP_CATALOG_PATH=manifests\x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f.cat
XP_PAYLOAD_PATH=x86__querydb_1_no-public-key_12.4.56.0_x-ww_7325f52f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_querydb_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\stats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\xstats
    for /f %i in ('dir /b stats*.sql') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\xstats\%i
    copy scripts.txt               $(_NT386TREE)\xdb\xstats\scripts.txt
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\stats\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__stats_0_none_12.4.56.0_none_782a9679c5a44551
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_stats_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.manifest
XP_MANIFEST_PATH=manifests\x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.cat
XP_CATALOG_PATH=manifests\x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.cat
XP_PAYLOAD_PATH=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_stats_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\xmatch\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\xmatch
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\xmatch\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\stats\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__stats_0_none_12.4.56.0_none_782a9679c5a44551
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_stats_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.manifest
XP_MANIFEST_PATH=manifests\x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.cat
XP_CATALOG_PATH=manifests\x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7.cat
XP_PAYLOAD_PATH=x86__stats_0_no-public-key_12.4.56.0_x-ww_af74cfe7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_stats_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\xmatch\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmatch_0_none_12.4.56.0_none_4a1c2872106c9db5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmatch_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.manifest
XP_MANIFEST_PATH=manifests\x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.cat
XP_CATALOG_PATH=manifests\x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.cat
XP_PAYLOAD_PATH=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmatch_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\genealogy\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\genealogy
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\genealogy\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\lookup\xmatch\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmatch_0_none_12.4.56.0_none_4a1c2872106c9db5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmatch_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.manifest
XP_MANIFEST_PATH=manifests\x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.cat
XP_CATALOG_PATH=manifests\x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733.cat
XP_PAYLOAD_PATH=x86__xmatch_0_no-public-key_12.4.56.0_x-ww_5cf44733
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmatch_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\genealogy\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__genealogy_2_none_12.4.56.0_none_a2e1fc0ab757d5a1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_genealogy_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.manifest
XP_MANIFEST_PATH=manifests\x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.cat
XP_CATALOG_PATH=manifests\x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.cat
XP_PAYLOAD_PATH=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_genealogy_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\genealogy\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__genealogy_2_none_12.4.56.0_none_a2e1fc0ab757d5a1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_genealogy_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.manifest
XP_MANIFEST_PATH=manifests\x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.cat
XP_CATALOG_PATH=manifests\x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb.cat
XP_PAYLOAD_PATH=x86__genealogy_2_no-public-key_12.4.56.0_x-ww_ed30e9cb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_genealogy_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\provisioning\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\provisioning
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\provisioning\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\provisioning\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__provisioning_1_none_12.4.56.0_none_b0595b4e780365b8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_provisioning_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.manifest
XP_MANIFEST_PATH=manifests\x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.cat
XP_CATALOG_PATH=manifests\x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.cat
XP_PAYLOAD_PATH=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_provisioning_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\provisioning\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__provisioning_1_none_12.4.56.0_none_b0595b4e780365b8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_provisioning_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.manifest
XP_MANIFEST_PATH=manifests\x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.cat
XP_CATALOG_PATH=manifests\x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74.cat
XP_PAYLOAD_PATH=x86__provisioning_1_no-public-key_12.4.56.0_x-ww_e5824d74
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_provisioning_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\toolsdb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\toolsdb
    for /f %i in ('dir /b *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\toolsdb\%i
    for /f %i in ('dir /b *.sql') do CL /EP /I..\common %i 2>NUL | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\toolsdb\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\toolsdb\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__toolsdb_2_none_12.4.56.0_none_6f2013f2b9e71009
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_toolsdb_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.manifest
XP_MANIFEST_PATH=manifests\x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.cat
XP_CATALOG_PATH=manifests\x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.cat
XP_PAYLOAD_PATH=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_toolsdb_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb\toolsdb\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__toolsdb_2_none_12.4.56.0_none_6f2013f2b9e71009
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_toolsdb_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.manifest
XP_MANIFEST_PATH=manifests\x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.cat
XP_CATALOG_PATH=manifests\x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43.cat
XP_PAYLOAD_PATH=x86__toolsdb_2_no-public-key_12.4.56.0_x-ww_e6fb8a43
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_toolsdb_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb_template\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
	xcopy /s /v /y $(BASEDIR)\private\sql\prodbase\npdb\ddl\* $(BASEDIR)\private\sql\npdb_template\ddl\*
	xcopy /s /v /y $(BASEDIR)\private\sql\prodbase\npdb\dml\* $(BASEDIR)\private\sql\npdb_template\dml\*
	xcopy /s /v /y $(BASEDIR)\private\sql\npdb_template\dml_override\* $(BASEDIR)\private\sql\npdb_template\dml\*
	
    $(EXTPATH)\xonline-ext\manicopy\manicopy.exe -m:manifest.xml -d:$(_NT386TREE)\npdb_template -v:$(_BLDVERMAJOR).$(_BLDVERMINOR).$(_BLDNUMMAJOR).$(_BLDNUMMINOR) -u
    
    type deployment.xml | perl -pe "s/\{BUILDNUMBER\}/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > $(_NT386TREE)\npdb_template\deployment.xml
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb_template\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__npdb_template_none_12.4.56.0_none_3b4b1b1580cc5fa6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_npdb_template
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910.manifest
XP_MANIFEST_PATH=manifests\x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910.cat
XP_CATALOG_PATH=manifests\x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910.cat
XP_PAYLOAD_PATH=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_npdb_template,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\sql\npdb_template\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__npdb_template_none_12.4.56.0_none_3b4b1b1580cc5fa6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_npdb_template
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__npdb_template_no-public-key_12.4.56.0_x-ww_ebc51910
XP_MANIFEST_DIR