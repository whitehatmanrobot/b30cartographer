Phase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsSleeping_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_IsSleeping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME * This,
            /* [out] */ LANGID *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pDest,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void *pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwTransBuf,
    /* [out] */ UINT *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME * This,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME * This,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME2 * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME2 * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME2 * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME2 * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME2 * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME2 * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME2 * This,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unsleep )( 
            IActiveIME2 * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME2_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME2_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)


#define IActiveIME2_Sleep(This)	\
    (This)->lpVtbl -> Sleep(This)

#define IActiveIME2_Unsleep(This,fDead)	\
    (This)->lpVtbl -> Unsleep(This,fDead)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME2_Sleep_Proxy( 
    IActiveIME2 * This);


void __RPC_STUB IActiveIME2_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME2_Unsleep_Proxy( 
    IActiveIME2 * This,
    /* [in] */ BOOL fDead);


void __RPC_STUB IActiveIME2_Unsleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dinputd.h ===
/****************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputd.h
 *  Content:    DirectInput include file for device driver implementors
 *
 ****************************************************************************/
#ifndef __DINPUTD_INCLUDED__
#define __DINPUTD_INCLUDED__

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0800
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

DEFINE_GUID(IID_IDirectInputEffectDriver,   0x02538130,0x898F,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(IID_IDirectInputJoyConfig,      0x1DE12AB1,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputPIDDriver,      0xEEC6993A,0xB3FD,0x11D2,0xA9,0x16,0x00,0xC0,0x4F,0xB9,0x86,0x38);

DEFINE_GUID(IID_IDirectInputJoyConfig8,     0xeb0d7dfa,0x1990,0x4f27,0xb4,0xd6,0xed,0xf2,0xee,0xc4,0xa4,0x4c);

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputEffectDriver
 *
 ****************************************************************************/

typedef struct DIOBJECTATTRIBUTES {
    DWORD   dwFlags;
    WORD    wUsagePage;
    WORD    wUsage;
} DIOBJECTATTRIBUTES, *LPDIOBJECTATTRIBUTES;
typedef const DIOBJECTATTRIBUTES *LPCDIOBJECTATTRIBUTES;

typedef struct DIFFOBJECTATTRIBUTES {
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
} DIFFOBJECTATTRIBUTES, *LPDIFFOBJECTATTRIBUTES;
typedef const DIFFOBJECTATTRIBUTES *LPCDIFFOBJECTATTRIBUTES;

typedef struct DIOBJECTCALIBRATION {
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIOBJECTCALIBRATION, *LPDIOBJECTCALIBRATION;
typedef const DIOBJECTCALIBRATION *LPCDIOBJECTCALIBRATION;

typedef struct DIEFFECTATTRIBUTES {
    DWORD   dwEffectId;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    DWORD   dwCoords;
} DIEFFECTATTRIBUTES, *LPDIEFFECTATTRIBUTES;
typedef const DIEFFECTATTRIBUTES *LPCDIEFFECTATTRIBUTES;

typedef struct DIFFDEVICEATTRIBUTES {
    DWORD   dwFlags;
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
} DIFFDEVICEATTRIBUTES, *LPDIFFDEVICEATTRIBUTES;
typedef const DIFFDEVICEATTRIBUTES *LPCDIFFDEVICEATTRIBUTES;

typedef struct DIDRIVERVERSIONS {
    DWORD   dwSize;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
} DIDRIVERVERSIONS, *LPDIDRIVERVERSIONS;
typedef const DIDRIVERVERSIONS *LPCDIDRIVERVERSIONS;

typedef struct DIDEVICESTATE {
    DWORD   dwSize;
    DWORD   dwState;
    DWORD   dwLoad;
} DIDEVICESTATE, *LPDIDEVICESTATE;

#define DEV_STS_EFFECT_RUNNING  DIEGES_PLAYING

#ifndef DIJ_RINGZERO

typedef struct DIHIDFFINITINFO {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
} DIHIDFFINITINFO, *LPDIHIDFFINITINFO;

#undef INTERFACE
#define INTERFACE IDirectInputEffectDriver

DECLARE_INTERFACE_(IDirectInputEffectDriver, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE) PURE;
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE) PURE;
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD) PURE;
};

typedef struct IDirectInputEffectDriver *LPDIRECTINPUTEFFECTDRIVER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffectDriver_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->lpVtbl->DeviceID(p,a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->lpVtbl->Escape(p,a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->lpVtbl->SetGain(p,a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->lpVtbl->SendForceFeedbackCommand(p,a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->lpVtbl->GetForceFeedbackState(p,a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->lpVtbl->DownloadEffect(p,a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->lpVtbl->DestroyEffect(p,a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->lpVtbl->StartEffect(p,a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->lpVtbl->StopEffect(p,a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->lpVtbl->GetEffectStatus(p,a,b,c)
#else
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->AddRef()
#define IDirectInputEffectDriver_Release(p) (p)->Release()
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->DeviceID(a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->Escape(a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->SetGain(a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->SendForceFeedbackCommand(a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->GetForceFeedbackState(a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->DownloadEffect(a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->DestroyEffect(a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->StartEffect(a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->StopEffect(a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->GetEffectStatus(a,b,c)
#endif


#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputJoyConfig
 *
 ****************************************************************************/

/****************************************************************************
 *
 *      Definitions copied from the DDK
 *
 ****************************************************************************/

#ifndef JOY_HW_NONE

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_TWO_2A_2B_WITH_Y         12
#define JOY_HW_LASTENTRY                13


/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* reserved for future use -> as link to next possible dword */
#define JOY_US_RESERVED         0x80000000l     /* reserved */


/* Settings for TypeInfo Flags1 */
#define JOYTYPE_ZEROGAMEENUMOEMDATA     0x00000001l /* Zero GameEnum's OEM data field */
#define JOYTYPE_NOAUTODETECTGAMEPORT    0x00000002l /* Device does not support Autodetect gameport*/
#define JOYTYPE_NOHIDDIRECT             0x00000004l /* Do not use HID directly for this device */
#define JOYTYPE_DEFAULTPROPSHEET        0x80000000l /* CPL overrides custom property sheet */

/* Settings for TypeInfo Flags2 */
#define JOYTYPE_DEVICEHIDE              0x00010000l /* Hide unclassified devices */
#define JOYTYPE_MOUSEHIDE               0x00020000l /* Hide mice */
#define JOYTYPE_KEYBHIDE                0x00040000l /* Hide keyboards */
#define JOYTYPE_GAMEHIDE                0x00080000l /* Hide game controllers */
#define JOYTYPE_HIDEACTIVE              0x00100000l /* Hide flags are active */
#define JOYTYPE_INFOMASK                0x00E00000l /* Mask for type specific info */
#define JOYTYPE_INFODEFAULT             0x00000000l /* Use default axis mappings */
#define JOYTYPE_INFOYYPEDALS            0x00200000l /* Use Y as a combined pedals axis */
#define JOYTYPE_INFOZYPEDALS            0x00400000l /* Use Z for accelerate, Y for brake */
#define JOYTYPE_INFOYRPEDALS            0x00600000l /* Use Y for accelerate, R for brake */
#define JOYTYPE_INFOZRPEDALS            0x00800000l /* Use Z for accelerate, R for brake */
#define JOYTYPE_INFOZISSLIDER           0x00200000l /* Use Z as a slider */
#define JOYTYPE_INFOZISZ                0x00400000l /* Use Z as Z axis */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

/*
 *  dwTimeout - value at which to timeout joystick polling
 *  jrvRanges - range of values app wants returned for axes
 *  jpDeadZone - area around center to be considered
 *               as "dead". specified as a percentage
 *               (0-100). Only X & Y handled by system driver
 */
typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;
    JOYRANGE    jrvRanges;
    JOYPOS      jpDeadZone;
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
/*
 *  jrvHardware - values returned by hardware
 *  dwPOVValues - POV values returned by hardware
 *  dwCalFlags  - what has been calibrated
 */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];
    DWORD       dwCalFlags;
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
/*
 *  hws             - hardware settings
 *  dwUsageSettings - usage settings
 *  hwv             - values returned by hardware
 *  dwType          - type of joystick
 *  dwReserved      - reserved for OEM drivers
 */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;
    DWORD               dwUsageSettings;
    JOYREGHWVALUES      hwv;
    DWORD               dwType;
    DWORD               dwReserved;
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

#endif

#ifndef DIJ_RINGZERO

#define MAX_JOYSTRING 256
typedef BOOL (FAR PASCAL * LPDIJOYTYPECALLBACK)(LPCWSTR, LPVOID);

#ifndef MAX_JOYSTICKOEMVXDNAME
#define MAX_JOYSTICKOEMVXDNAME 260
#endif

#define DITC_REGHWSETTINGS          0x00000001
#define DITC_CLSIDCONFIG            0x00000002
#define DITC_DISPLAYNAME            0x00000004
#define DITC_CALLOUT                0x00000008
#define DITC_HARDWAREID             0x00000010
#define DITC_FLAGS1                 0x00000020
#define DITC_FLAGS2                 0x00000040
#define DITC_MAPFILE                0x00000080



/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYTYPEINFO_DX5 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
} DIJOYTYPEINFO_DX5, *LPDIJOYTYPEINFO_DX5;
typedef const DIJOYTYPEINFO_DX5 *LPCDIJOYTYPEINFO_DX5;

/* This structure is defined for DirectX 6.1 compatibility */
typedef struct DIJOYTYPEINFO_DX6 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
} DIJOYTYPEINFO_DX6, *LPDIJOYTYPEINFO_DX6;
typedef const DIJOYTYPEINFO_DX6 *LPCDIJOYTYPEINFO_DX6;

typedef struct DIJOYTYPEINFO {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
#if(DIRECTINPUT_VERSION >= 0x0800)
    DWORD dwFlags2;
    WCHAR wszMapFile[MAX_JOYSTRING];
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
} DIJOYTYPEINFO, *LPDIJOYTYPEINFO;
typedef const DIJOYTYPEINFO *LPCDIJOYTYPEINFO;
#define DIJC_GUIDINSTANCE           0x00000001
#define DIJC_REGHWCONFIGTYPE        0x00000002
#define DIJC_GAIN                   0x00000004
#define DIJC_CALLOUT                0x00000008
#define DIJC_WDMGAMEPORT            0x00000010

/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYCONFIG_DX5 {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
} DIJOYCONFIG_DX5, *LPDIJOYCONFIG_DX5;
typedef const DIJOYCONFIG_DX5 *LPCDIJOYCONFIG_DX5;

typedef struct DIJOYCONFIG {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    GUID  guidGameport;
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
    } DIJOYCONFIG, *LPDIJOYCONFIG;
typedef const DIJOYCONFIG *LPCDIJOYCONFIG;


#define DIJU_USERVALUES             0x00000001
#define DIJU_GLOBALDRIVER           0x00000002
#define DIJU_GAMEPORTEMULATOR       0x00000004

typedef struct DIJOYUSERVALUES {
    DWORD dwSize;
    JOYREGUSERVALUES ruv;
    WCHAR wszGlobalDriver[MAX_JOYSTRING];
    WCHAR wszGameportEmulator[MAX_JOYSTRING];
} DIJOYUSERVALUES, *LPDIJOYUSERVALUES;
typedef const DIJOYUSERVALUES *LPCDIJOYUSERVALUES;

DEFINE_GUID(GUID_KeyboardClass, 0x4D36E96B,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MediaClass,    0x4D36E96C,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MouseClass,    0x4D36E96F,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_HIDClass,      0x745A17A0,0x74D3,0x11D0,0xB6,0xFE,0x00,0xA0,0xC9,0x0F,0x57,0xDA);

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig

DECLARE_INTERFACE_(IDirectInputJoyConfig, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenConfigKey)(THIS_ UINT,DWORD,PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig *LPDIRECTINPUTJOYCONFIG;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->lpVtbl->SetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->lpVtbl->OpenConfigKey(p,a,b,c)
#else
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig_Release(p) (p)->Release()
#define IDirectInputJoyConfig_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->SetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->OpenConfigKey(a,b,c)
#endif

#endif /* DIJ_RINGZERO */

#if(DIRECTINPUT_VERSION >= 0x0800)

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig8

DECLARE_INTERFACE_(IDirectInputJoyConfig8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig8 methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD,LPWSTR) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenAppStatusKey)(THIS_ PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig8 *LPDIRECTINPUTJOYCONFIG8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig8_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->lpVtbl->SetTypeInfo(p,a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->lpVtbl->OpenAppStatusKey(p,a)
#else
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig8_Release(p) (p)->Release()
#define IDirectInputJoyConfig8_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig8_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->SetTypeInfo(a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->OpenAppStatusKey(a)
#endif

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  Notification Messages
 *
 ****************************************************************************/

/* RegisterWindowMessage with this to get DirectInput notification messages */
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGA  "DIRECTINPUT_NOTIFICATION_MSGSTRING"
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGW  L"DIRECTINPUT_NOTIFICATION_MSGSTRING"

#ifdef UNICODE
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGW
#else
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGA
#endif

#define DIMSGWP_NEWAPPSTART         0x00000001
#define DIMSGWP_DX8APPSTART         0x00000002
#define DIMSGWP_DX8MAPPERAPPSTART   0x00000003

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define DIRECTINPUT_REGSTR_KEY_LASTAPPA     "MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA  "MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONA     "Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEA        "Name"
#define DIRECTINPUT_REGSTR_VAL_IDA          "Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERA      "UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTA   "MostRecentStart"

#define DIRECTINPUT_REGSTR_KEY_LASTAPPW     L"MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW  L"MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONW     L"Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEW        L"Name"
#define DIRECTINPUT_REGSTR_VAL_IDW          L"Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERW      L"UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTW   L"MostRecentStart"

#ifdef UNICODE
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPW
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONW
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEW
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDW
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERW
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTW
#else
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPA
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONA
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEA
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDA
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERA
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTA
#endif


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

#define DIERR_NOMOREITEMS               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NO_MORE_ITEMS)

/*
 *  Device driver-specific codes.
 */

#define DIERR_DRIVERFIRST               0x80040300L
#define DIERR_DRIVERLAST                0x800403FFL

/*
 *  Unless the specific driver has been precisely identified, no meaning 
 *  should be attributed to these values other than that the driver 
 *  originated the error.  However, to illustrate the types of error that 
 *  may be causing the failure, the PID force feedback driver distributed 
 *  with DirectX 7 could return the following errors:
 *
 *  DIERR_DRIVERFIRST + 1   
 *      The requested usage was not found.
 *  DIERR_DRIVERFIRST + 2   
 *      The parameter block couldn't be	downloaded to the device.
 *  DIERR_DRIVERFIRST + 3   
 *      PID initialization failed.
 *  DIERR_DRIVERFIRST + 4   
 *      The provided values couldn't be scaled.
 */


/*
 *  Device installer errors.
 */

/*
 *  Registry entry or DLL for class installer invalid
 *  or class installer not found.
 */
#define DIERR_INVALIDCLASSINSTALLER     0x80040400L

/*
 *  The user cancelled the install operation.
 */
#define DIERR_CANCELLED                 0x80040401L

/*
 *  The INF file for the selected device could not be
 *  found or is invalid or is damaged.
 */
#define DIERR_BADINF                    0x80040402L

/****************************************************************************
 *
 *  Map files
 *
 ****************************************************************************/

/*
 *  Delete particular data from default map file.
 */
#define DIDIFT_DELETE                   0x01000000

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUTD_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* ndef _MAC */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _MAC
/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif
#endif  /* ndef _MAC */

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

#ifndef _MAC
_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif  /* ndef _MAC */


#ifndef _MAC
#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif
#endif  /* ndef _MAC */


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#ifndef _MAC
#define diskfree_t  _diskfree_t
#endif  /* ndef _MAC */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#ifndef MAKE_FOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT        1
#define DMUS_DOWNLOADINFO_WAVE              2
#define DMUS_DOWNLOADINFO_INSTRUMENT2       3   /* New version for better DLS2 support. */

/* Support for oneshot and streaming wave data 
 */
#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   /* Wave articulation data */
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   /* One chunk of a streaming */
#define DMUS_DOWNLOADINFO_ONESHOTWAVE       6

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;             
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;                        
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;                                      
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE]; 
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;       
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

typedef struct _DMUS_WAVEARTDL
{
    ULONG               ulDownloadIdIdx;    /* Download ID's of each buffer */
    ULONG               ulBus;              /* Playback bus */
    ULONG               ulBuffers;          /* Buffers */
    ULONG               ulMasterDLId;       /* Download ID of master voice of slave group */
    USHORT              usOptions;          /* Same as DLS2 region options */
}   DMUS_WAVEARTDL,
    *LPDMUS_WAVEARTDL;

typedef struct _DMUS_WAVEDL
{
    ULONG               cbWaveData;         /* Bytes of wave data */
}   DMUS_WAVEDL,
    *LPDMUS_WAVEDL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dispdib.h ===
/****************************************************************************/
/*                                                                          */
/*        DISPDIB.H - Include file for DisplayDib() function.               */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef __DISPDIB_H__
#define __DISPDIB_H__

// DisplayDib() error return codes
#define DISPLAYDIB_NOERROR          0x0000  // success
#define DISPLAYDIB_NOTSUPPORTED     0x0001  // function not supported
#define DISPLAYDIB_INVALIDDIB       0x0002  // null or invalid DIB header
#define DISPLAYDIB_INVALIDFORMAT    0x0003  // invalid DIB format
#define DISPLAYDIB_INVALIDTASK      0x0004  // not called from current task
#define DISPLAYDIB_STOP             0x0005  // stop requested
#define DISPLAYDIB_NOTACTIVE	    0x0006  // DisplayDibWindow not foreground
#define DISPLAYDIB_BADSIZE          0x0007  //

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_NOFLIP           0x0800  // dont page flip
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE             0x000F  // mask for display mode
#define DISPLAYDIB_MODE_DEFAULT     0x0000  // default display mode
#define DISPLAYDIB_MODE_320x200x8   0x0001  // 320-by-200
#define DISPLAYDIB_MODE_320x240x8   0x0005  // 320-by-240

//
// a Win32 app must use the window class the function
// versions are not available
//
#ifndef _WIN32

// function prototypes
UINT FAR PASCAL DisplayDib(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, WORD wFlags);
UINT FAR PASCAL DisplayDibEx(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, WORD wFlags);

#define DisplayDibBegin() DisplayDib(NULL, NULL, DISPLAYDIB_BEGIN|DISPDIB_NOWAIT)
#define DisplayDibEnd()   DisplayDib(NULL, NULL, DISPLAYDIB_END|DISPDIB_NOWAIT)

#endif

//
//  DisplayDibWindow class.
//
//  simple interface to DISPDIB as a window class.
//  draw images and create a fullscreen window in one easy step.
//
//  advantages over calling the APIs directly.
//
//      if you show the window it will handle enabling/disabling
//      fullscreen mode when it has a activation.
//
//      while in fullscreen mode, window will be sized to
//      cover entire display preventing other apps from getting
//      clicked on. (when visible)
//
//      if window looses activation, fullscreen mode will be disabled
//      DDM_DRAW will return DISPLAYDIB_NOTACTIVE if you try to draw
//
//      forwards all mouse and keyboard events to owner, easy way
//      to take over entire screen.
//
//      alows interop with a Win32 application (via WM_COPYDATA)
//      NOTE WM_COPYDATA does not actualy copy anything if the
//      window belongs to the calling thread.  it will do a copy
//      if the window is owned by another thread....
//
//  you can use a DisplayDibWindow in two ways.....
//
//      hidden window
//
//          if the window is hidden, you must use the
//          DDM_BEGIN and DDM_END message to enable/disable
//          fullscreen mode manualy when your app is activated deactivated.
//
//      visible toplevel window
//
//          if you show the window it will take over the entire screen
//          and forward all mouse/keyboard input to its owner.
//
//          it will enter fullscreen automaticly when it is shown.
//
//          it will leave fullscreen and hide it self it another app
//          grabs the focus.
//
//  class name:     "DisplayDibWindow"
//                  class is registered when DISPDIB.DLL is loaded.
//                  as a global class.
//
//  messages:
//
//      DDM_SETFMT  set new DIB format or program a new palette
//
//		    fullscreen mode, will use best mode
//                  for displaying the passed DIB format.
//		    defaul is 320x240x8 tripple buffered
//
//                  the palette will be programed with the color
//                  table of the passed BITMAPINFOHEADER.
//
//                  the format is a BITMAPINFOHEADER followed by a color table.
//
//                  you must set a format before doing a begin, end or draw
//                  you can set a 320x200 or a 320x24 mode by selecting
//                  a DIB of the format you want.
//
//                  if you do a setfmt while fullscreen mode is active only the
//                  the palette will be changed the new size (if any) wont
//                  happen until the next begin.
//
//	    wParam = 0
//          lParam = LPBITMAPINFOHEADER
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_DRAW    draws DIB data to fullscreen
//                  format is assumed the same as format passed to
//                  DDM_BEGIN or DDM_FMT
//
//          wParam = flags
//          lParam = bits pointer.
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_CLOSE   destroy window *and* free the DLL
//
//      DDM_BEGIN   enter DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_END     leave DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      WM_COPYDATA allows a Win32 app to send a DDM_ message, that requires
//      a pointer.
//
//          wParam = hwnd of sender
//          lParam = PCOPYDATASTRUCT
//                  dwData      - LOWORD: DDM_* message value.
//                  dwData      - HIWORD: wParam for message
//                  lpData      - lParam (pointer to a BITMAPINFOHEADER or bits)
//                  cbData      - size of data
//
//          returns   0 if success else DISPLAYDIB_* error code.
//

#define DISPLAYDIB_WINDOW_CLASS     "DisplayDibWindow"
#define DISPLAYDIB_DLL              "DISPDIB.DLL"

#define DDM_SETFMT      WM_USER+0
#define DDM_DRAW        WM_USER+1
#define DDM_CLOSE       WM_USER+2
#define DDM_BEGIN       WM_USER+3
#define DDM_END         WM_USER+4

//
// inline function to send a message to a DisplayDibWindow
//
__inline UINT DisplayDibWindowMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, DWORD cbSize)
{
#if defined(_WIN32) || defined(WIN32)
        COPYDATASTRUCT cds;
        cds.dwData = MAKELONG(msg, wParam);
        cds.cbData = lParam ? cbSize : 0;
        cds.lpData = (LPVOID)lParam;
        return (UINT)SendMessage(hwnd, WM_COPYDATA, (WPARAM)(HWND)NULL, (LPARAM)(LPVOID)&cds);
#else
        return (UINT)SendMessage(hwnd, msg, wParam, lParam);
#endif
}

//
// inline function to create a DisplayDibWindow
//
__inline HWND DisplayDibWindowCreateEx(HWND hwndParent, HINSTANCE hInstance, DWORD dwStyle)
{
#if defined(_WIN32) || defined(WIN32)
    DWORD show = 2;
    DWORD zero = 0;
    LPVOID params[4] = {NULL, &zero, &show, 0};

    if ((UINT)LoadModule(DISPLAYDIB_DLL, &params) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#else
    if ((UINT)LoadLibrary(DISPLAYDIB_DLL) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#endif

    return CreateWindow(DISPLAYDIB_WINDOW_CLASS,"",dwStyle,0, 0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN),
            hwndParent, NULL,
            (hInstance ? hInstance : GetWindowInstance(hwndParent)), NULL);
}

//
//  helper macros for a DisplayDibWindow
//
//  DisplayDibWindowCreate
//
//      used to create a toplevel WS_POPUP window.
//
//  DisplayDibWindowCreateEx
//
//      used to create a non-toplevel window, of a custom style.
//
//  DisplayDibWindowSetFmt
//
//      macro to send the DDM_SETFMT message.
//
//  DisplayDibWindowDraw
//
//      macro to send the DDM_DRAW message
//
//  DisplayDibWindowBegin
//
//      macro used to show the window
//
//  DisplayDibWindowEnd
//
//      macro used to hide the window
//
//  DisplayDibWindowBeginEx
//
//      macro used to send a DDM_BEGIN message, used with hidden windows
//
//  DisplayDibWindowEndEx
//
//      macro used to send a DDM_END message, used with hidden windows
//
//  DisplayDibWindowClose
//
//      macro used to send a DDM_CLOSE message
//      this will destroy the window and free the DLL.
//
//  NOTES
//      warning DisplayDibWindowBegin/End will show the DisplayDibWindow
//      this will steal actiation away from your app. all mouse keyboard
//      input will go to the dispdib window and it will forward it to
//      its owner (make sure you set the right owner on create)
//
//      this may cause a problem for your app, you can keep the window
//      hidden be using the DDM_BEGIN/END messages in this case.
//
#define DisplayDibWindowCreate(hwndP, hInstance)        DisplayDibWindowCreateEx(hwndP, hInstance, WS_POPUP)
#define DisplayDibWindowSetFmt(hwnd, lpbi)              DisplayDibWindowMessage(hwnd, DDM_SETFMT, 0, (LPARAM)(LPVOID)(lpbi), sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD))
#define DisplayDibWindowDraw(hwnd, flags, bits, size)   DisplayDibWindowMessage(hwnd, DDM_DRAW, (WPARAM)(UINT)(flags), (LPARAM)(LPVOID)(bits), (DWORD)(size))

#ifdef __cplusplus
#define DisplayDibWindowBegin(hwnd)                     ::ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ::ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd, f)                ::SendMessage(hwnd, DDM_BEGIN, (WPARAM)(UINT)(f), 0)
#define DisplayDibWindowEndEx(hwnd)                     ::SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     ::SendMessage(hwnd, DDM_CLOSE, 0, 0)
#else
#define DisplayDibWindowBegin(hwnd)                     ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd)                   SendMessage(hwnd, DDM_BEGIN, 0, 0)
#define DisplayDibWindowEndEx(hwnd)                     SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     SendMessage(hwnd, DDM_CLOSE, 0, 0)
#endif

#endif // _DISPDIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dls2.h ===
/*
 
 	dls2.h
 	
 	Description:
 
 	Interface defines and structures for the DLS2 extensions of DLS.
 
 
     Written by Microsoft 1998.  Released for public use.
 
*/
 
#ifndef _INC_DLS2
#define _INC_DLS2
 
/*
     FOURCC's used in the DLS2 file, in addition to DLS1 chunks
*/
 
#define FOURCC_RGN2  mmioFOURCC('r','g','n','2')
#define FOURCC_LAR2  mmioFOURCC('l','a','r','2')
#define FOURCC_ART2  mmioFOURCC('a','r','t','2')
#define FOURCC_CDL   mmioFOURCC('c','d','l',' ')
#define FOURCC_DLID	 mmioFOURCC('d','l','i','d')
 
/*
     Articulation connection graph definitions. These are in addition to
     the definitions in the DLS1 header.
*/
 
/* Generic Sources (in addition to DLS1 sources. */
#define CONN_SRC_POLYPRESSURE		0x0007	/* Polyphonic Pressure */
#define CONN_SRC_CHANNELPRESSURE		0x0008	/* Channel Pressure */
#define CONN_SRC_VIBRATO			0x0009	/* Vibrato LFO */
#define CONN_SRC_MONOPRESSURE       	0x000a  /* MIDI Mono pressure */
 
 
/* Midi Controllers */
#define CONN_SRC_CC91			0x00db	/* Reverb Send */
#define CONN_SRC_CC93			0x00dd	/* Chorus Send */
 
 
/* Generic Destinations */
#define CONN_DST_GAIN			0x0001	/* Same as CONN_DST_ ATTENUATION, but more appropriate terminology. */
#define CONN_DST_KEYNUMBER 0x0005  /* Key Number Generator */
 
/* Audio Channel Output Destinations */
#define CONN_DST_LEFT			0x0010	/* Left Channel Send */
#define CONN_DST_RIGHT			0x0011	/* Right Channel Send */
#define CONN_DST_CENTER			0x0012	/* Center Channel Send */
#define CONN_DST_LEFTREAR			0x0013	/* Left Rear Channel Send */
#define CONN_DST_RIGHTREAR			0x0014	/* Right Rear Channel Send */
#define CONN_DST_LFE_CHANNEL		0x0015	/* LFE Channel Send */
#define CONN_DST_CHORUS			0x0080	/* Chorus Send */
#define CONN_DST_REVERB			0x0081	/* Reverb Send */
 
/* Vibrato LFO Destinations */
#define CONN_DST_VIB_FREQUENCY		0x0114	/* Vibrato Frequency */
#define CONN_DST_VIB_STARTDELAY		0x0115	/* Vibrato Start Delay */
 
/* EG1 Destinations */
#define CONN_DST_EG1_DELAYTIME		0x020B	/* EG1 Delay Time */
#define CONN_DST_EG1_HOLDTIME		0x020C	/* EG1 Hold Time */
#define CONN_DST_EG1_SHUTDOWNTIME		0x020D	/* EG1 Shutdown Time */
 
 
/*	EG2 Destinations */
#define CONN_DST_EG2_DELAYTIME		0x030F	/* EG2 Delay Time */
#define CONN_DST_EG2_HOLDTIME		0x0310	/* EG2 Hold Time */
 
 
/* Filter Destinations */
#define CONN_DST_FILTER_CUTOFF		0x0500	/* Filter Cutoff Frequency */
#define CONN_DST_FILTER_Q			0x0501	/* Filter Resonance */
 
 
/* Transforms */
#define CONN_TRN_CONVEX			0x0002	/* Convex Transform */
#define CONN_TRN_SWITCH			0x0003	/* Switch Transform */
 
 
/*	Conditional chunk operators */
 #define DLS_CDL_AND			0x0001	/* X = X & Y */
 #define DLS_CDL_OR			0x0002	/* X = X | Y */
 #define DLS_CDL_XOR			0x0003	/* X = X ^ Y */
 #define DLS_CDL_ADD			0x0004	/* X = X + Y */
 #define DLS_CDL_SUBTRACT		0x0005	/* X = X - Y */
 #define DLS_CDL_MULTIPLY		0x0006	/* X = X * Y */
 #define DLS_CDL_DIVIDE		0x0007	/* X = X / Y */
 #define DLS_CDL_LOGICAL_AND	0x0008	/* X = X && Y */
 #define DLS_CDL_LOGICAL_OR		0x0009	/* X = X || Y */
 #define DLS_CDL_LT			0x000A	/* X = (X < Y) */
 #define DLS_CDL_LE			0x000B	/* X = (X <= Y) */
 #define DLS_CDL_GT			0x000C	/* X = (X > Y) */
 #define DLS_CDL_GE			0x000D	/* X = (X >= Y) */
 #define DLS_CDL_EQ			0x000E	/* X = (X == Y) */
 #define DLS_CDL_NOT			0x000F	/* X = !X */
 #define DLS_CDL_CONST		0x0010	/* 32-bit constant */
 #define DLS_CDL_QUERY		0x0011	/* 32-bit value returned from query */
 #define DLS_CDL_QUERYSUPPORTED	0x0012	/* Test to see if query is supported by synth */
 
/*
  Loop and release
*/

#define WLOOP_TYPE_RELEASE 1

/*
  WaveLink chunk <wlnk-ck>
*/

#define F_WAVELINK_MULTICHANNEL 0x0002


/*
  DLSID queries for <cdl-ck>
*/

DEFINE_GUID(DLSID_GMInHardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_GSInHardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_XGInHardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS1, 0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS2, 0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(DLSID_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_ManufacturersID, 0xb03e1181, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_ProductID, 0xb03e1182, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

#endif	/* _INC_DLS2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dlcapi.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    dlcapi.h

Abstract:

    This module defines 32-bit Windows/NT DLC structures and manifests

Revision History:

--*/

#ifndef _DLCAPI_
#define _DLCAPI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// DLC Command Codes
//

#define LLC_DIR_INTERRUPT               0x00
#define LLC_DIR_OPEN_ADAPTER            0x03
#define LLC_DIR_CLOSE_ADAPTER           0x04
#define LLC_DIR_SET_MULTICAST_ADDRESS   0x05
#define LLC_DIR_SET_GROUP_ADDRESS       0x06
#define LLC_DIR_SET_FUNCTIONAL_ADDRESS  0x07
#define LLC_DIR_READ_LOG                0x08
#define LLC_TRANSMIT_FRAMES             0x09
#define LLC_TRANSMIT_DIR_FRAME          0x0A
#define LLC_TRANSMIT_I_FRAME            0x0B
#define LLC_TRANSMIT_UI_FRAME           0x0D
#define LLC_TRANSMIT_XID_CMD            0x0E
#define LLC_TRANSMIT_XID_RESP_FINAL     0x0F
#define LLC_TRANSMIT_XID_RESP_NOT_FINAL 0x10
#define LLC_TRANSMIT_TEST_CMD           0x11
#define LLC_DLC_RESET                   0x14
#define LLC_DLC_OPEN_SAP                0x15
#define LLC_DLC_CLOSE_SAP               0x16
#define LLC_DLC_REALLOCATE_STATIONS     0x17
#define LLC_DLC_OPEN_STATION            0x19
#define LLC_DLC_CLOSE_STATION           0x1A
#define LLC_DLC_CONNECT_STATION         0x1B
#define LLC_DLC_MODIFY                  0x1C
#define LLC_DLC_FLOW_CONTROL            0x1D
#define LLC_DLC_STATISTICS              0x1E
#define LLC_DIR_INITIALIZE              0x20
#define LLC_DIR_STATUS                  0x21
#define LLC_DIR_TIMER_SET               0x22
#define LLC_DIR_TIMER_CANCEL            0x23
#define LLC_BUFFER_GET                  0x26
#define LLC_BUFFER_FREE                 0x27
#define LLC_RECEIVE                     0x28
#define LLC_RECEIVE_CANCEL              0x29
#define LLC_RECEIVE_MODIFY              0x2A
#define LLC_DIR_TIMER_CANCEL_GROUP      0x2C
#define LLC_DIR_SET_EXCEPTION_FLAGS     0x2D
#define LLC_BUFFER_CREATE               0x30
#define LLC_READ                        0x31
#define LLC_READ_CANCEL                 0x32
#define LLC_DLC_SET_THRESHOLD           0x33
#define LLC_DIR_CLOSE_DIRECT            0x34
#define LLC_DIR_OPEN_DIRECT             0x35
#define LLC_MAX_DLC_COMMAND             0x37

//
// forward definitions
//

union _LLC_PARMS;
typedef union _LLC_PARMS LLC_PARMS, *PLLC_PARMS;

//
// Parameters. Can be pointer to a parameter table (32-bit flat address),
// a single 32-bit ULONG, 2 16-bit USHORTs or 4 8-bit BYTEs
//

typedef union {

    PLLC_PARMS pParameterTable;     // pointer to the parameter table

    struct {
        USHORT usStationId;         // Station id
        USHORT usParameter;         // optional parameter
    } dlc;

    struct {
        USHORT usParameter0;        // first optional parameter
        USHORT usParameter1;        // second optional parameter
    } dir;

    UCHAR auchBuffer[4];            // group/functional address

    ULONG ulParameter;

} CCB_PARMS;

//
// LLC_CCB - the Command Control Block structure
//

typedef struct _LLC_CCB {
    UCHAR uchAdapterNumber;         // Adapter 0 or 1
    UCHAR uchDlcCommand;            // DLC command
    UCHAR uchDlcStatus;             // DLC command completion code
    UCHAR uchReserved1;             // reserved for DLC DLL
    struct _LLC_CCB* pNext;         // CCB chain
    ULONG ulCompletionFlag;         // used in command completion
    CCB_PARMS u;                    // parameters
    HANDLE hCompletionEvent;        // event for command completion
    UCHAR uchReserved2;             // reserved for DLC DLL
    UCHAR uchReadFlag;              // set when special READ CCB chained
    USHORT usReserved3;             // reserved for DLC DLL
} LLC_CCB, *PLLC_CCB;

//
// transmit/receive buffers
//

union _LLC_BUFFER;
typedef union _LLC_BUFFER LLC_BUFFER, *PLLC_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next DLC buffer in frame
    USHORT cbFrame;                 // length of the whole received frame
    USHORT cbBuffer;                // length of this segment
    USHORT offUserData;             // offset of data from descriptor header
    USHORT cbUserData;              // length of the data
} LLC_NEXT_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
    UCHAR cbLanHeader;              // length of the lan header
    UCHAR cbDlcHeader;              // length of the DLC header
    UCHAR auchLanHeader[32];        // lan header of the received frame
    UCHAR auchDlcHeader[4];         // dlc header of the received frame
    USHORT usPadding;               // data begins from offset 64 !!!
} LLC_NOT_CONTIGUOUS_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
} LLC_CONTIGUOUS_BUFFER;

//
// Received frames are returned in these data structures
//

union _LLC_BUFFER {

    PLLC_BUFFER pNext;

    LLC_NEXT_BUFFER Next;

    struct LlcNextBuffer {
        LLC_NEXT_BUFFER Header;
        UCHAR auchData[];
    } Buffer;

    LLC_NOT_CONTIGUOUS_BUFFER NotContiguous;

    struct {
        LLC_NOT_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } NotCont;

    LLC_CONTIGUOUS_BUFFER Contiguous;

    struct {
        LLC_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } Cont;

};

//
// This structure is used by BUFFER.GET, BUFFER.FREE and TRANSMIT
//

struct _LLC_XMIT_BUFFER;
typedef struct _LLC_XMIT_BUFFER LLC_XMIT_BUFFER, *PLLC_XMIT_BUFFER;

struct _LLC_XMIT_BUFFER {
    PLLC_XMIT_BUFFER pNext;         // next buffer (or NULL)
    USHORT usReserved1;             //
    USHORT cbBuffer;                // length of transmitted data
    USHORT usReserved2;             //
    USHORT cbUserData;              // length of optional header
    UCHAR auchData[];               // optional header and transmitted data
};

#define LLC_XMIT_BUFFER_SIZE sizeof(LLC_XMIT_BUFFER)

//
// CCB parameter tables
//

typedef struct {
    HANDLE hBufferPool;             // handle of new buffer pool
    PVOID pBuffer;                  // any buffer in memory
    ULONG cbBufferSize;             // buffer size in bytes
    ULONG cbMinimumSizeThreshold;   // minimum locked size
} LLC_BUFFER_CREATE_PARMS, *PLLC_BUFFER_CREATE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments
    ULONG ulReserved;
    PLLC_XMIT_BUFFER pFirstBuffer;  // buffer chain
} LLC_BUFFER_FREE_PARMS, *PLLC_BUFFER_FREE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments

    //
    // cBuffersToGet: number of buffers to get. If 0, the returned buffer list
    // may consist of segment of different size
    //

    USHORT cBuffersToGet;

    //
    // cbBufferSize: size of the requested buffers. This will be rounded up to
    // the next largest segment size: 256, 512, 1024, 2048 or 4096
    //

    USHORT cbBufferSize;
    PLLC_XMIT_BUFFER pFirstBuffer;
} LLC_BUFFER_GET_PARMS, *PLLC_BUFFER_GET_PARMS;

//
// parameter table for DLC.CONNECT.STATION
//

typedef struct {
    USHORT usStationId;             // SAP or direct station ID, defines the pool
    USHORT usReserved;
    PUCHAR pRoutingInfo;            // offset to the routing info
} LLC_DLC_CONNECT_PARMS, *PLLC_DLC_CONNECT_PARMS;

//
// DLC_FLOW_CONTROL Options:
//

#define LLC_RESET_LOCAL_BUSY_USER   0x80
#define LLC_RESET_LOCAL_BUSY_BUFFER 0xC0
#define LLC_SET_LOCAL_BUSY_USER     0

typedef struct {
    USHORT usRes;
    USHORT usStationId;             // SAP or link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max transmits without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchReserved1;
    USHORT usMaxInfoFieldLength;    // Only for link stations, NEW!!!
    UCHAR uchAccessPriority;        // token ring access priority
    UCHAR auchReserved3[4];
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
} LLC_DLC_MODIFY_PARMS, *PLLC_DLC_MODIFY_PARMS;

#define LLC_XID_HANDLING_IN_APPLICATION 0x08
#define LLC_XID_HANDLING_IN_DLC         0
#define LLC_INDIVIDUAL_SAP              0x04
#define LLC_GROUP_SAP                   0x02
#define LLC_MEMBER_OF_GROUP_SAP         0x01

typedef struct {
    USHORT usStationId;             // SAP or link station id
    USHORT usUserStatValue;         // reserved for user
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchMaxMembers;            // maximum members for group SAP
    USHORT usMaxI_Field;            // maximum length of the Info field
    UCHAR uchSapValue;              // SAP value to be assigned
    UCHAR uchOptionsPriority;       // SAP options and access priority
    UCHAR uchcStationCount;         // maximum number of link stations in sap
    UCHAR uchReserved2[2];          //
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
    ULONG DlcStatusFlags;           // User notify flag for DLC status changes
    UCHAR uchReserved3[8];          // reserved
    UCHAR cLinkStationsAvail;       // total number of available link stations
} LLC_DLC_OPEN_SAP_PARMS, *PLLC_DLC_OPEN_SAP_PARMS;

typedef struct {
    USHORT usSapStationId;          // SAP station id
    USHORT usLinkStationId;         // Link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchRemoteSap;             // remote SAP of the link
    USHORT usMaxI_Field;            // max I field length
    UCHAR uchAccessPriority;        // token ring access priority
    PVOID pRemoteNodeAddress;       // pointer to the destination address
} LLC_DLC_OPEN_STATION_PARMS, *PLLC_DLC_OPEN_STATION_PARMS;

#define LLC_INCREASE_LINK_STATIONS  0
#define LLC_DECREASE_LINK_STATIONS  0x80

typedef struct {
    USHORT usStationId;             // ID of affected SAP
    UCHAR uchOption;                // increase of decrease indicator
    UCHAR uchStationCount;
    UCHAR uchStationsAvailOnAdapter;
    UCHAR uchStationsAvailOnSap;
    UCHAR uchTotalStationsOnAdapter;
    UCHAR uchTotalStationsOnSap;
} LLC_DLC_REALLOCATE_PARMS, *PLLC_DLC_REALLOCATE_PARMS;

typedef struct {
    USHORT usStationId;             // SAP station ID
    USHORT cBufferThreshold;        // SAP buffer pool Threshold number
    PVOID AlertEvent;               // alerting event
} LLC_DLC_SET_THRESHOLD_PARMS, *PLLC_DLC_SET_THRESHOLD_PARMS;

typedef struct {
    PVOID TraceBuffer;              // trace buffer
    ULONG TraceBufferSize;          // trace buffer size
    ULONG TraceFlags;               // various trace flags
} LLC_TRACE_INITIALIZE_PARMS, *PLLC_TRACE_INITIALIZE_PARMS;

#define LLC_DLC_RESET_STATISTICS    0x80
#define LLC_DLC_READ_STATISTICS     0

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} DLC_SAP_LOG, *PDLC_SAP_LOG;

typedef struct {
    USHORT cI_FramesTransmitted;
    USHORT cI_FramesReceived;
    UCHAR cI_FrameReceiveErrors;
    UCHAR cI_FrameTransmissionErrors;
    USHORT cT1_ExpirationCount;     // Note: not OUT data xfer mode
    UCHAR uchLastCmdRespReceived;
    UCHAR uchLastCmdRespTransmitted;
    UCHAR uchPrimaryState;
    UCHAR uchSecondaryState;
    UCHAR uchSendStateVariable;
    UCHAR uchReceiveStateVariable;
    UCHAR uchLastNr;                // last received NR
    UCHAR cbLanHeader;
    UCHAR auchLanHeader[32];
} DLC_LINK_LOG, *PDLC_LINK_LOG;

typedef union {
    DLC_SAP_LOG Sap;
    DLC_LINK_LOG Link;
} LLC_DLC_LOG_BUFFER, *PLLC_DLC_LOG_BUFFER;

typedef struct {
    USHORT usStationId;             // ID of a SAP or a link station
    USHORT cbLogBufSize;            //
    PLLC_DLC_LOG_BUFFER pLogBuf;    // offset to the log buffer
    USHORT usActLogLength;          // length of returned log
    UCHAR uchOptions;               // command options (bit7 resets log params)
} LLC_DLC_STATISTICS_PARMS, *PLLC_DLC_STATISTICS_PARMS;

typedef struct {
    USHORT usBringUps;              // Token Ring adapter bring up error code
    UCHAR Reserved[30];             // everything else specific to DOS or OS/2
} LLC_DIR_INITIALIZE_PARMS, *PLLC_DIR_INITIALIZE_PARMS;

typedef struct {
    USHORT usOpenErrorCode;         // open adapter errors detected
    USHORT usOpenOptions;           // various options
    UCHAR auchNodeAddress[6];       // adapters LAN address
    UCHAR auchGroupAddress[4];      // multicast address added in the open
    UCHAR auchFunctionalAddress[4]; // added token ring functional address
    USHORT usReserved1;
    USHORT usReserved2;
    USHORT usMaxFrameSize;          // maximum frame size defined in NDIS
    USHORT usReserved3[4];
    USHORT usBringUps;              // Bring up errors, TR only
    USHORT InitWarnings;
    USHORT usReserved4[3];
} LLC_ADAPTER_OPEN_PARMS, *PLLC_ADAPTER_OPEN_PARMS;

typedef struct {
    UCHAR uchDlcMaxSaps;
    UCHAR uchDlcMaxStations;
    UCHAR uchDlcMaxGroupSaps;
    UCHAR uchDlcMaxGroupMembers;
    UCHAR uchT1_TickOne;            // Short timer interval (for 1 - 5)
    UCHAR uchT2_TickOne;
    UCHAR uchTi_TickOne;
    UCHAR uchT1_TickTwo;            // Long timer interval (for 6 - 10)
    UCHAR uchT2_TickTwo;
    UCHAR uchTi_TickTwo;
} LLC_DLC_PARMS, *PLLC_DLC_PARMS;

//
// The ethernet mode selects the LAN header format of ethernet. SNA
// applications should use the default parameter, that has been defined in the
// registry. The applications using connectionless DLC services should select
// the ethernet LLC LAN header format they are using (usually 802.3)
//

typedef enum {
    LLC_ETHERNET_TYPE_DEFAULT,      // use the parameter value set in registry
    LLC_ETHERNET_TYPE_AUTO,         // automatic header type selction for links
    LLC_ETHERNET_TYPE_802_3,        // use always 802.3 lan headers
    LLC_ETHERNET_TYPE_DIX           // use always LLC on DIX SNA type.
} LLC_ETHERNET_TYPE, *PLLC_ETHERNET_TYPE;

typedef struct {
    PVOID hBufferPool;
    PVOID pSecurityDescriptor;
    LLC_ETHERNET_TYPE LlcEthernetType;
} LLC_EXTENDED_ADAPTER_PARMS, *PLLC_EXTENDED_ADAPTER_PARMS;

typedef struct {
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms;      // ADAPTER_PARMS
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms; // DIRECT_PARMS
    PLLC_DLC_PARMS pDlcParms;                   // DLC_PARMS
    PVOID pReserved1;                           // NCB_PARMS
} LLC_DIR_OPEN_ADAPTER_PARMS, *PLLC_DIR_OPEN_ADAPTER_PARMS;

typedef struct {
    UCHAR auchMulticastAddress[6];  // 48 bit multicast address
} LLC_DIR_MULTICAST_ADDRESS, *PLLC_DIR_MULTICAST_ADDRESS;

#define LLC_DIRECT_OPTIONS_ALL_MACS 0x1880

typedef struct {
    USHORT Reserved[4];
    USHORT usOpenOptions;
    USHORT usEthernetType;
    ULONG ulProtocolTypeMask;
    ULONG ulProtocolTypeMatch;
    USHORT usProtocolTypeOffset;
} LLC_DIR_OPEN_DIRECT_PARMS, *PLLC_DIR_OPEN_DIRECT_PARMS;

typedef struct {
    UCHAR cLineError;
    UCHAR cInternalError;
    UCHAR cBurstError;
    UCHAR cAC_Error;
    UCHAR cAbortDelimiter;
    UCHAR uchReserved1;
    UCHAR cLostFrame;
    UCHAR cReceiveCongestion;
    UCHAR cFrameCopiedError;
    UCHAR cFrequencyError;
    UCHAR cTokenError;
    UCHAR uchReserved2;
    UCHAR uchReserved3;
    UCHAR uchReserved4;
} LLC_ADAPTER_LOG_TR, *PLLC_ADAPTER_LOG_TR;

typedef struct {
    UCHAR cCRC_Error;
    UCHAR uchReserved1;
    UCHAR cAlignmentError;
    UCHAR uchReserved2;
    UCHAR cTransmitError;
    UCHAR uchReserved3;
    UCHAR cCollisionError;
    UCHAR cReceiveCongestion;
    UCHAR uchReserved[6];
} LLC_ADAPTER_LOG_ETH, *PLLC_ADAPTER_LOG_ETH;

typedef union {
    LLC_ADAPTER_LOG_TR Tr;
    LLC_ADAPTER_LOG_ETH Eth;
} LLC_ADAPTER_LOG, *PLLC_ADAPTER_LOG;

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} LLC_DIRECT_LOG, *PLLC_DIRECT_LOG;

typedef union {
    LLC_ADAPTER_LOG Adapter;
    LLC_DIRECT_LOG Dir;

    struct {
        LLC_ADAPTER_LOG Adapter;
        LLC_DIRECT_LOG Dir;
    } both;

} LLC_DIR_READ_LOG_BUFFER, *PLLC_DIR_READ_LOG_BUFFER;

#define LLC_DIR_READ_LOG_ADAPTER    0
#define LLC_DIR_READ_LOG_DIRECT     1
#define LLC_DIR_READ_LOG_BOTH       2

typedef struct {
    USHORT usTypeId;                    // 0=adapter, 1=direct, 2=both logs
    USHORT cbLogBuffer;                 // size of log buffer
    PLLC_DIR_READ_LOG_BUFFER pLogBuffer;// pointer to log buffer
    USHORT cbActualLength;              // returned size of log buffer
} LLC_DIR_READ_LOG_PARMS, *PLLC_DIR_READ_LOG_PARMS;

typedef struct {
    ULONG ulAdapterCheckFlag;
    ULONG ulNetworkStatusFlag;
    ULONG ulPcErrorFlag;
    ULONG ulSystemActionFlag;
} LLC_DIR_SET_EFLAG_PARMS, *PLLC_DIR_SET_EFLAG_PARMS;

#define LLC_ADAPTER_ETHERNET    0x0010
#define LLC_ADAPTER_TOKEN_RING  0x0040

typedef struct {
    UCHAR auchPermanentAddress[6];  // permanent encoded address
    UCHAR auchNodeAddress[6];       // adapter's network address
    UCHAR auchGroupAddress[4];      // adapter's group address
    UCHAR auchFunctAddr[4];         // adapter's functional address
    UCHAR uchMaxSap;                // maximum allowable SAP
    UCHAR uchOpenSaps;              // number of currently open saps
    UCHAR uchMaxStations;           // max number of stations (always 253)
    UCHAR uchOpenStation;           // number of open stations (only up to 253)
    UCHAR uchAvailStations;         // number of available stations (always 253)
    UCHAR uchAdapterConfig;         // adapter configuration flags
    UCHAR auchReserved1[10];        // microcode level
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulMaxFrameLength;         // maximum frame length (only in Windows/Nt)
    USHORT usLastNetworkStatus;
    USHORT usAdapterType;           // THIS BYTE IS NOT USED IN DOS DLC !!!
} LLC_DIR_STATUS_PARMS, *PLLC_DIR_STATUS_PARMS;


#define LLC_OPTION_READ_STATION 0
#define LLC_OPTION_READ_SAP     1
#define LLC_OPTION_READ_ALL     2

#define LLC_EVENT_SYSTEM_ACTION         0x0040
#define LLC_EVENT_NETWORK_STATUS        0x0020
#define LLC_EVENT_CRITICAL_EXCEPTION    0x0010
#define LLC_EVENT_STATUS_CHANGE         0x0008
#define LLC_EVENT_RECEIVE_DATA          0x0004
#define LLC_EVENT_TRANSMIT_COMPLETION   0x0002
#define LLC_EVENT_COMMAND_COMPLETION    0x0001
#define LLC_READ_ALL_EVENTS             0x007F

//
// LLC_STATUS_CHANGE indications
// The returned status value may be an inclusive-OR of several flags
//

#define LLC_INDICATE_LINK_LOST              0x8000
#define LLC_INDICATE_DM_DISC_RECEIVED       0x4000
#define LLC_INDICATE_FRMR_RECEIVED          0x2000
#define LLC_INDICATE_FRMR_SENT              0x1000
#define LLC_INDICATE_RESET                  0x0800
#define LLC_INDICATE_CONNECT_REQUEST        0x0400
#define LLC_INDICATE_REMOTE_BUSY            0x0200
#define LLC_INDICATE_REMOTE_READY           0x0100
#define LLC_INDICATE_TI_TIMER_EXPIRED       0x0080
#define LLC_INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define LLC_INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define LLC_INDICATE_LOCAL_STATION_BUSY     0x0001

typedef struct {
    USHORT usStationId;
    UCHAR uchOptionIndicator;
    UCHAR uchEventSet;
    UCHAR uchEvent;
    UCHAR uchCriticalSubset;
    ULONG ulNotificationFlag;

    union {

        struct {
            USHORT usCcbCount;
            PLLC_CCB pCcbCompletionList;
            USHORT usBufferCount;
            PLLC_BUFFER pFirstBuffer;
            USHORT usReceivedFrameCount;
            PLLC_BUFFER pReceivedFrame;
            USHORT usEventErrorCode;
            USHORT usEventErrorData[3];
        } Event;

        struct {
            USHORT usStationId;
            USHORT usDlcStatusCode;
            UCHAR uchFrmrData[5];
            UCHAR uchAccessPritority;
            UCHAR uchRemoteNodeAddress[6];
            UCHAR uchRemoteSap;
            UCHAR uchReserved;
            USHORT usUserStatusValue;
        } Status;

    } Type;

} LLC_READ_PARMS, *PLLC_READ_PARMS;

//
// This data structure gives the best performance in Windows/Nt: The DLC driver
// must copy the CCB and the parameter table. If the driver knows that the
// parameter table is concatenated to the CCB, it can copy both structures at
// once. NOTE: The pointer to the parameter table MUST still be present in the
// CCB
//

typedef struct {
    LLC_CCB Ccb;
    LLC_READ_PARMS Parms;
} LLC_READ_COMMAND, *PLLC_READ_COMMAND;

//
// New receive types for direct stations, these types are ignored if the direct
// station was opened with a specific ethernet type
//

#define LLC_DIR_RCV_ALL_TR_FRAMES       0
#define LLC_DIR_RCV_ALL_MAC_FRAMES      1
#define LLC_DIR_RCV_ALL_8022_FRAMES     2
#define LLC_DIR_RCV_ALL_FRAMES          4
#define LLC_DIR_RCV_ALL_ETHERNET_TYPES  5

#define LLC_CONTIGUOUS_MAC      0x80
#define LLC_CONTIGUOUS_DATA     0x40
#define LLC_NOT_CONTIGUOUS_DATA 0x00

//
// LLC_BREAK (0x20) is not supported by Windows/Nt
//

#define LLC_RCV_READ_INDIVIDUAL_FRAMES  0
#define LLC_RCV_CHAIN_FRAMES_ON_LINK    1
#define LLC_RCV_CHAIN_FRAMES_ON_SAP     2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    USHORT usUserLength;            // length of user data in buffer header
    ULONG ulReceiveFlag;            // the received data handler
    PLLC_BUFFER pFirstBuffer;       // first buffer in the pool
    UCHAR uchOptions;               // defines how the frame is received
    UCHAR auchReserved1[3];
    UCHAR uchRcvReadOption;         // defines if rcv frames are chained
} LLC_RECEIVE_PARMS, *PLLC_RECEIVE_PARMS;

#define LLC_CHAIN_XMIT_COMMANDS_ON_LINK 0
#define LLC_COMPLETE_SINGLE_XMIT_FRAME  1
#define LLC_CHAIN_XMIT_COMMANDS_ON_SAP  2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    UCHAR uchTransmitFs;            // token-ring frame status
    UCHAR uchRemoteSap;             // remote destination SAP
    PLLC_XMIT_BUFFER pXmitQueue1;   // first link list of frame segments
    PLLC_XMIT_BUFFER pXmitQueue2;   // another segment list returuned to pool
    USHORT cbBuffer1;               // length of buffer 1
    USHORT cbBuffer2;               // length of buffer 2
    PVOID pBuffer1;                 // yet another segment
    PVOID pBuffer2;                 // this is the last segment of frame
    UCHAR uchXmitReadOption;        // defines completion event for READ
} LLC_TRANSMIT_PARMS,  *PLLC_TRANSMIT_PARMS;

#define LLC_FIRST_DATA_SEGMENT  0x01
#define LLC_NEXT_DATA_SEGMENT   0x02

typedef struct {
    UCHAR eSegmentType;             // defines if first or next segment of frame
    UCHAR boolFreeBuffer;           // if set, this buffer is released to pool
    USHORT cbBuffer;                // length of this buffer
    PVOID pBuffer;
} LLC_TRANSMIT_DESCRIPTOR, *PLLC_TRANSMIT_DESCRIPTOR;

//
// The frames types returned in the first receive buffer or used with the
// TRANSMIT_FRAMES command.  A direct station may also send only ethernet
// frames. The ethernet types are only for transmit. Types 0x0019 - 0x05DC
// are reserved
//

enum _LLC_FRAME_TYPES {                     // Purpose:
    LLC_DIRECT_TRANSMIT         = 0x0000,   // transmit
    LLC_DIRECT_MAC              = 0x0002,   // receive
    LLC_I_FRAME                 = 0x0004,   // receive & transmit
    LLC_UI_FRAME                = 0x0006,   // receive & transmit
    LLC_XID_COMMAND_POLL        = 0x0008,   // receive & transmit
    LLC_XID_COMMAND_NOT_POLL    = 0x000A,   // receive & transmit
    LLC_XID_RESPONSE_FINAL      = 0x000C,   // receive & transmit
    LLC_XID_RESPONSE_NOT_FINAL  = 0x000E,   // receive & transmit
    LLC_TEST_RESPONSE_FINAL     = 0x0010,   // receive & transmit
    LLC_TEST_RESPONSE_NOT_FINAL = 0x0012,   // receive & transmit
    LLC_DIRECT_8022             = 0x0014,   // receive (direct station)
    LLC_TEST_COMMAND_POLL       = 0x0016,   // transmit
    LLC_DIRECT_ETHERNET_TYPE    = 0x0018,   // receive (direct station)
    LLC_LAST_FRAME_TYPE         = 0x001a,   // reserved
    LLC_FIRST_ETHERNET_TYPE     = 0x05DD    // transmit (>)
};

typedef struct {
    LLC_CCB Ccb;                    // use this as transmit CCB
    USHORT usStationId;
    USHORT usFrameType;             // DLC frame or ethernet type
    UCHAR uchRemoteSap;             // used with UI, TEST, XID frames
    UCHAR uchXmitReadOption;
    UCHAR Reserved2[2];
    ULONG cXmitBufferCount;
    LLC_TRANSMIT_DESCRIPTOR aXmitBuffer[1];
} LLC_TRANSMIT2_COMMAND, *PLLC_TRANSMIT2_COMMAND;

//
// LLC_TRANSMIT2_VAR_PARMS - this macro allocates space for variable length
// descriptor array, eg: LLC_TRANSMIT2_VAR_PARMS(8) TransmitParms;
//

#define LLC_TRANSMIT2_VAR_PARMS(a)\
struct {\
    LLC_CCB Ccb;\
    USHORT usStationId;\
    USHORT usFrameType;\
    UCHAR uchRemoteSap;\
    UCHAR uchXmitReadOption;\
    UCHAR uchReserved2[2];\
    ULONG cXmitBufferCount;\
    LLC_TRANSMIT_DESCRIPTOR XmitBuffer[(a)];\
}

//
// LLC_PARMS - All CCB parameter tables can be referred to using this union
//

union _LLC_PARMS {
    LLC_BUFFER_FREE_PARMS BufferFree;
    LLC_BUFFER_GET_PARMS BufferGet;
    LLC_DLC_CONNECT_PARMS DlcConnectStation;
    LLC_DLC_MODIFY_PARMS DlcModify;
    LLC_DLC_OPEN_SAP_PARMS DlcOpenSap;
    LLC_DLC_OPEN_STATION_PARMS DlcOpenStation;
    LLC_DLC_REALLOCATE_PARMS DlcReallocate;
    LLC_DLC_SET_THRESHOLD_PARMS DlcSetThreshold;
    LLC_DLC_STATISTICS_PARMS DlcStatistics;
    LLC_DIR_INITIALIZE_PARMS DirInitialize;
    LLC_DIR_OPEN_ADAPTER_PARMS DirOpenAdapter;
    LLC_DIR_OPEN_DIRECT_PARMS DirOpenDirect;
    LLC_DIR_READ_LOG_PARMS DirReadLog;
    LLC_DIR_SET_EFLAG_PARMS DirSetEventFlag;
    LLC_DIR_STATUS_PARMS DirStatus;
    LLC_READ_PARMS Read;
    LLC_RECEIVE_PARMS Receive;
    LLC_TRANSMIT_PARMS Transmit;
    LLC_TRANSMIT2_COMMAND Transmit2;
    LLC_TRACE_INITIALIZE_PARMS TraceInitialize;
};

//
// LLC_STATUS - enumerates the return codes which appear in the CCB uchDlcStatus
// field
//

typedef enum _LLC_STATUS {
    LLC_STATUS_SUCCESS                      = 0x00,
    LLC_STATUS_INVALID_COMMAND              = 0x01,
    LLC_STATUS_DUPLICATE_COMMAND            = 0x02,
    LLC_STATUS_ADAPTER_OPEN                 = 0x03,
    LLC_STATUS_ADAPTER_CLOSED               = 0x04,
    LLC_STATUS_PARAMETER_MISSING            = 0x05,
    LLC_STATUS_INVALID_OPTION               = 0x06,
    LLC_STATUS_COMMAND_CANCELLED_FAILURE    = 0x07,
    LLC_STATUS_ACCESS_DENIED                = 0x08,   // not used in Windows/Nt
    LLC_STATUS_ADAPTER_NOT_INITIALIZED      = 0x09,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_USER            = 0x0A,
    LLC_STATUS_COMMAND_CANCELLED_CLOSED     = 0x0B,   // not used in Windows/Nt
    LLC_STATUS_SUCCESS_NOT_OPEN             = 0x0C,
    LLC_STATUS_TIMER_ERROR                  = 0x11,
    LLC_STATUS_NO_MEMORY                    = 0x12,
    LLC_STATUS_INVALID_LOG_ID               = 0x13,   // not used in Windows/Nt
    LLC_STATUS_LOST_LOG_DATA                = 0x15,
    LLC_STATUS_BUFFER_SIZE_EXCEEDED         = 0x16,
    LLC_STATUS_INVALID_BUFFER_LENGTH        = 0x18,
    LLC_STATUS_INADEQUATE_BUFFERS           = 0x19,
    LLC_STATUS_USER_LENGTH_TOO_LARGE        = 0x1A,
    LLC_STATUS_INVALID_PARAMETER_TABLE      = 0x1B,
    LLC_STATUS_INVALID_POINTER_IN_CCB       = 0x1C,
    LLC_STATUS_INVALID_ADAPTER              = 0x1D,
    LLC_STATUS_LOST_DATA_NO_BUFFERS         = 0x20,
    LLC_STATUS_LOST_DATA_INADEQUATE_SPACE   = 0x21,
    LLC_STATUS_TRANSMIT_ERROR_FS            = 0x22,
    LLC_STATUS_TRANSMIT_ERROR               = 0x23,
    LLC_STATUS_UNAUTHORIZED_MAC             = 0x24,   // not used in Windows/Nt
    LLC_STATUS_MAX_COMMANDS_EXCEEDED        = 0x25,   // not used in Windows/Nt
    LLC_STATUS_LINK_NOT_TRANSMITTING        = 0x27,
    LLC_STATUS_INVALID_FRAME_LENGTH         = 0x28,
    LLC_STATUS_INADEQUATE_RECEIVE           = 0x30,   // not used in Windows/Nt
    LLC_STATUS_INVALID_NODE_ADDRESS         = 0x32,
    LLC_STATUS_INVALID_RCV_BUFFER_LENGTH    = 0x33,
    LLC_STATUS_INVALID_XMIT_BUFFER_LENGTH   = 0x34,
    LLC_STATUS_INVALID_STATION_ID           = 0x40,
    LLC_STATUS_LINK_PROTOCOL_ERROR          = 0x41,
    LLC_STATUS_PARMETERS_EXCEEDED_MAX       = 0x42,
    LLC_STATUS_INVALID_SAP_VALUE            = 0x43,
    LLC_STATUS_INVALID_ROUTING_INFO         = 0x44,
    LLC_STATUS_RESOURCES_NOT_AVAILABLE      = 0x46,   // not used in Windows/Nt
    LLC_STATUS_LINK_STATIONS_OPEN           = 0x47,
    LLC_STATUS_INCOMPATIBLE_COMMANDS        = 0x4A,
    LLC_STATUS_OUTSTANDING_COMMANDS         = 0x4C,   // not used in Windows/Nt
    LLC_STATUS_CONNECT_FAILED               = 0x4D,
    LLC_STATUS_INVALID_REMOTE_ADDRESS       = 0x4F,
    LLC_STATUS_CCB_POINTER_FIELD            = 0x50,
    LLC_STATUS_INVALID_APPLICATION_ID       = 0x52,   // not used in Windows/Nt
    LLC_STATUS_NO_SYSTEM_PROCESS            = 0x56,   // not used in Windows/Nt
    LLC_STATUS_INADEQUATE_LINKS             = 0x57,
    LLC_STATUS_INVALID_PARAMETER_1          = 0x58,
    LLC_STATUS_DIRECT_STATIONS_NOT_ASSIGNED = 0x5C,
    LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED  = 0x5d,
    LLC_STATUS_ADAPTER_NOT_INSTALLED        = 0x5e,
    LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS   = 0x5f,
    LLC_STATUS_INIT_COMMAND_STARTED         = 0x60,
    LLC_STATUS_TOO_MANY_USERS               = 0x61,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_SYSTEM_ACTION   = 0x62,
    LLC_STATUS_DIR_STATIONS_NOT_AVAILABLE   = 0x63,   // not used in Windows/Nt
    LLC_STATUS_NO_GDT_SELECTORS             = 0x65,
    LLC_STATUS_MEMORY_LOCK_FAILED           = 0x69,

    //
    // New NT DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    //

    LLC_STATUS_INVALID_BUFFER_ADDRESS       = 0x80,
    LLC_STATUS_BUFFER_ALREADY_RELEASED      = 0x81,
    LLC_STATUS_BIND_ERROR                   = 0xA0,   // not used in Windows/Nt
    LLC_STATUS_INVALID_VERSION              = 0xA1,
    LLC_STATUS_NT_ERROR_STATUS              = 0xA2,
    LLC_STATUS_PENDING                      = 0xFF
} LLC_STATUS;

#define LLC_STATUS_MAX_ERROR 0xFF

//
// ACSLAN_STATUS - status codes which are returned from AcsLan
//

typedef enum {
    ACSLAN_STATUS_COMMAND_ACCEPTED = 0,
    ACSLAN_STATUS_INVALID_CCB_POINTER = 1,
    ACSLAN_STATUS_CCB_IN_ERROR = 2,
    ACSLAN_STATUS_CHAINED_CCB_IN_ERROR = 3,
    ACSLAN_STATUS_SYSTEM_ERROR = 4,
    ACSLAN_STATUS_SYSTEM_STATUS = 5,
    ACSLAN_STATUS_INVALID_COMMAND = 6
} ACSLAN_STATUS;

//
// prototypes
//

ACSLAN_STATUS
APIENTRY
AcsLan(
    IN OUT PLLC_CCB pCcb,
    OUT PLLC_CCB* ppBadCcb
    );

LLC_STATUS
APIENTRY
GetAdapterNameFromNumber(
    IN UINT AdapterNumber,
    OUT LPTSTR pNdisName
    );

LLC_STATUS
APIENTRY
GetAdapterNumberFromName(
    IN LPTSTR pNdisName,
    OUT UINT *AdapterNumber
    );

#ifdef __cplusplus
}
#endif

#endif // _DLCAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dispatch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dispatch.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should #include oleauto.h instead of dispatch.h")
#endif /* !RC_INVOKED */

#include <oleauto.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dispex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon Nov 17 12:04:12 1997
 */
/* Compiler settings for dispex.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dispex_h__
#define __dispex_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDispatchEx_FWD_DEFINED__
#define __IDispatchEx_FWD_DEFINED__
typedef interface IDispatchEx IDispatchEx;
#endif 	/* __IDispatchEx_FWD_DEFINED__ */


#ifndef __IDispError_FWD_DEFINED__
#define __IDispError_FWD_DEFINED__
typedef interface IDispError IDispError;
#endif 	/* __IDispError_FWD_DEFINED__ */


#ifndef __IVariantChangeType_FWD_DEFINED__
#define __IVariantChangeType_FWD_DEFINED__
typedef interface IVariantChangeType IVariantChangeType;
#endif 	/* __IVariantChangeType_FWD_DEFINED__ */


#ifndef __IObjectIdentity_FWD_DEFINED__
#define __IObjectIdentity_FWD_DEFINED__
typedef interface IObjectIdentity IObjectIdentity;
#endif 	/* __IObjectIdentity_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "servprov.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dispex_0000
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// DispEx.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 - 1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IDispatchEx Interfaces.
//

#ifndef DISPEX_H_
#define DISPEX_H_





#ifndef _NO_DISPATCHEX_GUIDS

// {A6EF9860-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispatchEx, 0xa6ef9860, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9861-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispError, 0xa6ef9861, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9862-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IVariantChangeType, 0xa6ef9862, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {1F101481-BCCD-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_VariantConversion, 0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {4717CC40-BCB9-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_GetCaller, 0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {CA04B7E6-0D21-11d1-8CC5-00C04FC2B085}
DEFINE_GUID(IID_IObjectIdentity, 0xca04b7e6, 0xd21, 0x11d1, 0x8c, 0xc5, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

#define SID_GetScriptSite IID_IActiveScriptSite

#endif // _NO_DISPATCHEX_GUIDS


#ifndef _NO_DISPATCHEX_CONSTS

// Input flags for GetDispID
#define fdexNameCaseSensitive       0x00000001L
#define fdexNameEnsure              0x00000002L
#define fdexNameImplicit            0x00000004L
#define fdexNameCaseInsensitive     0x00000008L

// Output flags for GetMemberProperties
#define fdexPropCanGet              0x00000001L
#define fdexPropCannotGet           0x00000002L
#define fdexPropCanPut              0x00000004L
#define fdexPropCannotPut           0x00000008L
#define fdexPropCanPutRef           0x00000010L
#define fdexPropCannotPutRef        0x00000020L
#define fdexPropNoSideEffects       0x00000040L
#define fdexPropDynamicType         0x00000080L
#define fdexPropCanCall             0x00000100L
#define fdexPropCannotCall          0x00000200L
#define fdexPropCanConstruct        0x00000400L
#define fdexPropCannotConstruct     0x00000800L
#define fdexPropCanSourceEvents     0x00001000L
#define fdexPropCannotSourceEvents  0x00002000L

#define grfdexPropCanAll \
       (fdexPropCanGet | fdexPropCanPut | fdexPropCanPutRef | \
        fdexPropCanCall | fdexPropCanConstruct | fdexPropCanSourceEvents)
#define grfdexPropCannotAll \
       (fdexPropCannotGet | fdexPropCannotPut | fdexPropCannotPutRef | \
        fdexPropCannotCall | fdexPropCannotConstruct | fdexPropCannotSourceEvents)
#define grfdexPropExtraAll \
       (fdexPropNoSideEffects | fdexPropDynamicType)
#define grfdexPropAll \
       (grfdexPropCanAll | grfdexPropCannotAll | grfdexPropExtraAll)

// Input flags for GetNextDispID
#define fdexEnumDefault             0x00000001L
#define fdexEnumAll                 0x00000002L

// Additional flags for Invoke - when object member is
// used as a constructor.
#define DISPATCH_CONSTRUCT 0x4000

// Standard DISPIDs
#define DISPID_THIS (-613)
#define DISPID_STARTENUM DISPID_UNKNOWN

#endif //_NO_DISPATCHEX_CONSTS



extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_v0_0_s_ifspec;

#ifndef __IDispatchEx_INTERFACE_DEFINED__
#define __IDispatchEx_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispatchEx
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A6EF9860-C720-11d0-9337-00A0C90DCAA9")
    IDispatchEx : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispatchEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispatchEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDispatchEx __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeEx )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMemberByName )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMemberByDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberProperties )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberName )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNameSpaceParent )( 
            IDispatchEx __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } IDispatchExVtbl;

    interface IDispatchEx
    {
        CONST_VTBL struct IDispatchExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatchEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispatchEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispatchEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispatchEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDispatchEx_GetDispID(This,bstrName,grfdex,pid)	\
    (This)->lpVtbl -> GetDispID(This,bstrName,grfdex,pid)

#define IDispatchEx_InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)	\
    (This)->lpVtbl -> InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)

#define IDispatchEx_DeleteMemberByName(This,bstr,grfdex)	\
    (This)->lpVtbl -> DeleteMemberByName(This,bstr,grfdex)

#define IDispatchEx_DeleteMemberByDispID(This,id)	\
    (This)->lpVtbl -> DeleteMemberByDispID(This,id)

#define IDispatchEx_GetMemberProperties(This,id,grfdexFetch,pgrfdex)	\
    (This)->lpVtbl -> GetMemberProperties(This,id,grfdexFetch,pgrfdex)

#define IDispatchEx_GetMemberName(This,id,pbstrName)	\
    (This)->lpVtbl -> GetMemberName(This,id,pbstrName)

#define IDispatchEx_GetNextDispID(This,grfdex,id,pid)	\
    (This)->lpVtbl -> GetNextDispID(This,grfdex,id,pid)

#define IDispatchEx_GetNameSpaceParent(This,ppunk)	\
    (This)->lpVtbl -> GetNameSpaceParent(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispatchEx_GetDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ DWORD grfdex,
    /* [out] */ DISPID __RPC_FAR *pid);


void __RPC_STUB IDispatchEx_GetDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_RemoteInvokeEx_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ UINT __RPC_FAR *rgiRefArg,
    /* [size_is][out][in] */ VARIANT __RPC_FAR *rgvarRefArg);


void __RPC_STUB IDispatchEx_RemoteInvokeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_DeleteMemberByName_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ DWORD grfdex);


void __RPC_STUB IDispatchEx_DeleteMemberByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_DeleteMemberByDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id);


void __RPC_STUB IDispatchEx_DeleteMemberByDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetMemberProperties_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ DWORD grfdexFetch,
    /* [out] */ DWORD __RPC_FAR *pgrfdex);


void __RPC_STUB IDispatchEx_GetMemberProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetMemberName_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IDispatchEx_GetMemberName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetNextDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DWORD grfdex,
    /* [in] */ DISPID id,
    /* [out] */ DISPID __RPC_FAR *pid);


void __RPC_STUB IDispatchEx_GetNextDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetNameSpaceParent_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IDispatchEx_GetNameSpaceParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IDispError_INTERFACE_DEFINED__
#define __IDispError_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispError
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDispError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A6EF9861-C720-11d0-9337-00A0C90DCAA9")
    IDispError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryErrorInfo( 
            /* [in] */ GUID guidErrorType,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHresult( 
            /* [out] */ HRESULT __RPC_FAR *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ BSTR __RPC_FAR *pbstrSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrFileName,
            /* [out] */ DWORD __RPC_FAR *pdwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryErrorInfo )( 
            IDispError __RPC_FAR * This,
            /* [in] */ GUID guidErrorType,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IDispError __RPC_FAR * This,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHresult )( 
            IDispError __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSource )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpInfo )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrFileName,
            /* [out] */ DWORD __RPC_FAR *pdwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        END_INTERFACE
    } IDispErrorVtbl;

    interface IDispError
    {
        CONST_VTBL struct IDispErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispError_QueryErrorInfo(This,guidErrorType,ppde)	\
    (This)->lpVtbl -> QueryErrorInfo(This,guidErrorType,ppde)

#define IDispError_GetNext(This,ppde)	\
    (This)->lpVtbl -> GetNext(This,ppde)

#define IDispError_GetHresult(This,phr)	\
    (This)->lpVtbl -> GetHresult(This,phr)

#define IDispError_GetSource(This,pbstrSource)	\
    (This)->lpVtbl -> GetSource(This,pbstrSource)

#define IDispError_GetHelpInfo(This,pbstrFileName,pdwContext)	\
    (This)->lpVtbl -> GetHelpInfo(This,pbstrFileName,pdwContext)

#define IDispError_GetDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispError_QueryErrorInfo_Proxy( 
    IDispError __RPC_FAR * This,
    /* [in] */ GUID guidErrorType,
    /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);


void __RPC_STUB IDispError_QueryErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetNext_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);


void __RPC_STUB IDispError_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetHresult_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phr);


void __RPC_STUB IDispError_GetHresult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetSource_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrSource);


void __RPC_STUB IDispError_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetHelpInfo_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrFileName,
    /* [out] */ DWORD __RPC_FAR *pdwContext);


void __RPC_STUB IDispError_GetHelpInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetDescription_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IDispError_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispError_INTERFACE_DEFINED__ */


#ifndef __IVariantChangeType_INTERFACE_DEFINED__
#define __IVariantChangeType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantChangeType
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IVariantChangeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A6EF9862-C720-11d0-9337-00A0C90DCAA9")
    IVariantChangeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
            /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantChangeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantChangeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantChangeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantChangeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeType )( 
            IVariantChangeType __RPC_FAR * This,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
            /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew);
        
        END_INTERFACE
    } IVariantChangeTypeVtbl;

    interface IVariantChangeType
    {
        CONST_VTBL struct IVariantChangeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantChangeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantChangeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantChangeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantChangeType_ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)	\
    (This)->lpVtbl -> ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVariantChangeType_ChangeType_Proxy( 
    IVariantChangeType __RPC_FAR * This,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
    /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
    /* [in] */ LCID lcid,
    /* [in] */ VARTYPE vtNew);


void __RPC_STUB IVariantChangeType_ChangeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantChangeType_INTERFACE_DEFINED__ */


#ifndef __IObjectIdentity_INTERFACE_DEFINED__
#define __IObjectIdentity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectIdentity
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IObjectIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("CA04B7E6-0D21-11d1-8CC5-00C04FC2B085")
    IObjectIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEqualObject( 
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectIdentity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectIdentity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectIdentity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqualObject )( 
            IObjectIdentity __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        END_INTERFACE
    } IObjectIdentityVtbl;

    interface IObjectIdentity
    {
        CONST_VTBL struct IObjectIdentityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectIdentity_IsEqualObject(This,punk)	\
    (This)->lpVtbl -> IsEqualObject(This,punk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectIdentity_IsEqualObject_Proxy( 
    IObjectIdentity __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IObjectIdentity_IsEqualObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectIdentity_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_dispex_0144
 * at Mon Nov 17 12:04:12 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif //DISPEX_H_


extern RPC_IF_HANDLE __MIDL_itf_dispex_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0144_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ UINT __RPC_FAR *rgiRefArg,
    /* [size_is][out][in] */ VARIANT __RPC_FAR *rgvarRefArg);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dlgs.h ===
/*++

Copyright (c) 1990-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/


#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */






//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dls1.h ===
/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
                   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmo.h ===
//------------------------------------------------------------------------------
// File: DMO.h
//
// Desc: Headers needed by almost all DMOs.
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMO_H__
#define __DMO_H__


#include "mediaerr.h"

// When using ATL we get collisions on Lock so in this case rename
// IMediaObject::Lock to IMediaObject::DMOLock

#ifdef FIX_LOCK_NAME
#define Lock DMOLock
#endif
#include "mediaobj.h"
#ifdef FIX_LOCK_NAME
#undef Lock
#endif
#include "dmoreg.h"
#include "dmort.h"

#endif //__DMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef ULONGLONG    SAMPLE_TIME;
typedef ULONGLONG    SAMPLE_POSITION;	
typedef SAMPLE_TIME *LPSAMPLE_TIME;

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS 
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002

/* For DMUS_PORTCAPS dwClass
 */ 
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)   // Supports DLS downloading and DLS level 1.
#define DMUS_PC_EXTERNAL         (0x00000002)   // External MIDI module.
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)   // Software synthesizer.
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)   // Memory size is fixed.
#define DMUS_PC_GMINHARDWARE     (0x00000010)   // GM sound set is built in, no need to download.
#define DMUS_PC_GSINHARDWARE     (0x00000020)   // GS sound set is built in.
#define DMUS_PC_XGINHARDWARE     (0x00000040)   // XG sound set is built in.
#define DMUS_PC_DIRECTSOUND      (0x00000080)   // Connects to DirectSound via a DSound buffer.
#define DMUS_PC_SHAREABLE        (0x00000100)   // Synth can be actively shared by multiple apps at once.
#define DMUS_PC_DLS2             (0x00000200)   // Supports DLS2 instruments.
#define DMUS_PC_AUDIOPATH        (0x00000400)   // Multiple outputs can be connected to DirectSound for audiopaths.
#define DMUS_PC_WAVE             (0x00000800)   // Supports streaming and one shot waves.

#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)   // Sample memory is system memory.


typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;    
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef DMUS_PORTCAPS *LPDMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying 
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040
#define DMUS_PORTPARAMS_FEATURES         0x00000080     /* DirectX 8.0 and above */

typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS7;

typedef struct _DMUS_PORTPARAMS8
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
    DWORD   dwFeatures;
} DMUS_PORTPARAMS8;

#define DMUS_PORT_FEATURE_AUDIOPATH     0x00000001	/* Supports audiopath connection to DSound buffers. */
#define DMUS_PORT_FEATURE_STREAMING     0x00000002	/* Supports streaming waves through the synth. */


typedef DMUS_PORTPARAMS8 DMUS_PORTPARAMS;
typedef DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS8 *LPDMUS_SYNTHSTATS8;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

typedef struct _DMUS_SYNTHSTATS8
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
	DWORD   dwSynthMemUse;		/* Memory used by synth wave data */ 
} DMUS_SYNTHSTATS8;

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays 
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time. 
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time) 
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

#define DMUS_CLOCKF_GLOBAL              0x00000001

typedef struct _DMUS_CLOCKINFO7 *LPDMUS_CLOCKINFO7;
typedef struct _DMUS_CLOCKINFO7
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO7;

typedef struct _DMUS_CLOCKINFO8 *LPDMUS_CLOCKINFO8;
typedef struct _DMUS_CLOCKINFO8
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
    DWORD           dwFlags;           
} DMUS_CLOCKINFO8;

typedef DMUS_CLOCKINFO8 DMUS_CLOCKINFO;
typedef DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;

/* Default bus identifiers
 *
 * The first 17 are direct mappings to the destinations defined in both
 * the MMA DLS Level 2 specification and the Microsoft Multi-Channel audio
 * specification.
 */
#define DSBUSID_FIRST_SPKR_LOC              0
#define DSBUSID_FRONT_LEFT                  0
#define DSBUSID_LEFT                        0   /* Front left is also just left */
#define DSBUSID_FRONT_RIGHT                 1
#define DSBUSID_RIGHT                       1   /* Ditto front right */ 
#define DSBUSID_FRONT_CENTER                2
#define DSBUSID_LOW_FREQUENCY               3
#define DSBUSID_BACK_LEFT                   4
#define DSBUSID_BACK_RIGHT                  5
#define DSBUSID_FRONT_LEFT_OF_CENTER        6 
#define DSBUSID_FRONT_RIGHT_OF_CENTER       7
#define DSBUSID_BACK_CENTER                 8
#define DSBUSID_SIDE_LEFT                   9
#define DSBUSID_SIDE_RIGHT                 10
#define DSBUSID_TOP_CENTER                 11
#define DSBUSID_TOP_FRONT_LEFT             12
#define DSBUSID_TOP_FRONT_CENTER           13
#define DSBUSID_TOP_FRONT_RIGHT            14
#define DSBUSID_TOP_BACK_LEFT              15
#define DSBUSID_TOP_BACK_CENTER            16
#define DSBUSID_TOP_BACK_RIGHT             17
#define DSBUSID_LAST_SPKR_LOC              17

#define DSBUSID_IS_SPKR_LOC(id) ( ((id) >= DSBUSID_FIRST_SPKR_LOC) && ((id) <= DSBUSID_LAST_SPKR_LOC) )

/* These bus identifiers are for the standard DLS effect sends 
 */
#define DSBUSID_REVERB_SEND                64
#define DSBUSID_CHORUS_SEND                65

/* Dynamic bus identifiers start here. See the documentation for how
 * synthesizers map the output of voices to static and dynamic
 * bus identifiers.
 */ 
#define DSBUSID_DYNAMIC_0                 512 

/* Null bus, used to identify busses that have no function mapping. 
*/
#define DSBUSID_NULL			   0xFFFFFFFF

interface IDirectMusic;
interface IDirectMusic8;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus 

typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusic8 IDirectMusic8;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;

#endif  /* C++ */

typedef IDirectMusic *LPDIRECTMUSIC;
typedef IDirectMusic8 *LPDIRECTMUSIC8;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusic8
DECLARE_INTERFACE_(IDirectMusic8, IDirectMusic)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    /*  IDirectMusic8 */
    STDMETHOD(SetExternalMasterClock)
                                    (THIS_ IReferenceClock *pClock) PURE;                                          
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

typedef IDirectMusicBuffer IDirectMusicBuffer8;
typedef IDirectMusicBuffer8 *LPDIRECTMUSICBUFFER8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

typedef IDirectMusicInstrument IDirectMusicInstrument8;
typedef IDirectMusicInstrument8 *LPDIRECTMUSICINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

typedef IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument8;
typedef IDirectMusicDownloadedInstrument8 *LPDIRECTMUSICDOWNLOADEDINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, 
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex, 
                                               DWORD* pdwPatch, 
                                               LPWSTR pwszName, 
                                               DWORD dwNameLen) PURE;
};

typedef IDirectMusicCollection IDirectMusicCollection8;
typedef IDirectMusicCollection8 *LPDIRECTMUSICCOLLECTION8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer, 
                                           DWORD* pdwSize) PURE;
};

typedef IDirectMusicDownload IDirectMusicDownload8;
typedef IDirectMusicDownload8 *LPDIRECTMUSICDOWNLOAD8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId, 
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

typedef IDirectMusicPortDownload IDirectMusicPortDownload8;
typedef IDirectMusicPortDownload8 *LPDIRECTMUSICPORTDOWNLOAD8;

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument, 
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode, 
                                           LPVOID lpInBuffer, 
                                           DWORD nInBufferSize, 
                                           LPVOID lpOutBuffer, 
                                           DWORD nOutBufferSize, 
                                           LPDWORD lpBytesReturned, 
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

typedef IDirectMusicPort IDirectMusicPort8;
typedef IDirectMusicPort8 *LPDIRECTMUSICPORT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    /* IDirectMusicThru 
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup, 
                                           DWORD dwSourceChannel, 
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

typedef IDirectMusicThru IDirectMusicThru8;
typedef IDirectMusicThru8 *LPDIRECTMUSICTHRU8;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

DEFINE_GUID(IID_IDirectMusic8,0x2d3629f7,0x813d,0x4939,0x85,0x08,0xf0,0x5c,0x6b,0x75,0xfd,0x97);

#define IID_IDirectMusicThru8 IID_IDirectMusicThru
#define IID_IDirectMusicPortDownload8 IID_IDirectMusicPortDownload
#define IID_IDirectMusicDownload8 IID_IDirectMusicDownload
#define IID_IDirectMusicCollection8 IID_IDirectMusicCollection
#define IID_IDirectMusicInstrument8 IID_IDirectMusicInstrument
#define IID_IDirectMusicDownloadedInstrument8 IID_IDirectMusicDownloadedInstrument
#define IID_IDirectMusicPort8 IID_IDirectMusicPort


/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags. 
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE 
 * DMUS_EFFECT_REVERB 
 * DMUS_EFFECT_CHORUS 
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmoimpl.h ===
//------------------------------------------------------------------------------
// File: DMOImpl.h
//
// Desc: Classes to implement a DMO.
//
// Copyright (c) 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _dmoimpl_h_
#define _dmoimpl_h_

#ifdef _DEBUG
#include <crtdbg.h>
#endif

//  Class to implement a DMO
//
//
//       Assumes the number of input and output streams is fixed
//       (these are template parameters)
//
//       Provides following services:
//
//          Basic parameter checking and locking
//          Fully implements :
//                 GetStreamCount
//                 SetInputType
//                 SetOutputType
//                 GetCurrentInputType
//                 GetCurrentOutputType
//
//          Checks if all types are set before streaming
//          Automatically calls AllocateStreamingResources before streaming
//              if it's not been called already
//          Prevents streaming until the types on all non-optional streams
//              have been set
//
//
//  Derived class implements the following methods :
//
/*
   HRESULT InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalCheckOutputType(DWORD dwOutputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize,
                            DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
   HRESULT InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize,
                             DWORD *pcbAlignment);
   HRESULT InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency);
   HRESULT InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency);
   HRESULT InternalFlush();
   HRESULT InternalDiscontinuity(DWORD dwInputStreamIndex);
   HRESULT InternalAllocateStreamingResources();
   HRESULT InternalFreeStreamingResources();
   HRESULT InternalProcessInput(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer,
                               DWORD dwFlags, REFERENCE_TIME rtTimestamp,
                               REFERENCE_TIME rtTimelength);
   HRESULT InternalProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                               DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                           DWORD *pdwStatus);
   HRESULT InternalAcceptingInput(DWORD dwInputStreamIndex);
   void Lock();
   void Unlock();

   Notes:
       The derived class is meant to do most work to initialize streaming
       in AllocateStreamingResources rather than when types are set.

       This centralizes the work to one
       clear place based on the types set for all streams.

       The derived class implements locking.

       The derived class implements the IUnknown methods

   Usage example (1 input and 1 output) :
   class CMyDMO : public IMediaObjectImpl<CMyDmo, 1, 1>,
                  ...
*/


#define INTERNAL_CALL(_T_, _X_) \
    static_cast<_T_ *>(this)->Internal##_X_

template <class _DERIVED_, int NUMBEROFINPUTS, int NUMBEROFOUTPUTS>
class IMediaObjectImpl : public IMediaObject
{
private:
    // Member variables
    struct {
        DWORD   fTypeSet:1;
        DWORD   fIncomplete:1;
        DMO_MEDIA_TYPE CurrentMediaType;
    } m_InputInfo[NUMBEROFINPUTS], m_OutputInfo[NUMBEROFOUTPUTS];

    bool m_fTypesSet;
    bool m_fFlushed;
    bool m_fResourcesAllocated;

protected:

    //  Helpers
    bool InputTypeSet(DWORD ulInputStreamIndex) const
    {
        _ASSERTE(ulInputStreamIndex < NUMBEROFINPUTS);
        return 0 != m_InputInfo[ulInputStreamIndex].fTypeSet;
    }

    bool OutputTypeSet(DWORD ulOutputStreamIndex) const
    {
        _ASSERTE(ulOutputStreamIndex < NUMBEROFOUTPUTS);
        return 0 != m_OutputInfo[ulOutputStreamIndex].fTypeSet;
    }
    const DMO_MEDIA_TYPE *InputType(DWORD ulInputStreamIndex)
    {
        if (!InputTypeSet(ulInputStreamIndex)) {
            return NULL;
        }
        return &m_InputInfo[ulInputStreamIndex].CurrentMediaType;
    }
    const DMO_MEDIA_TYPE *OutputType(DWORD ulOutputStreamIndex)
    {
        if (!OutputTypeSet(ulOutputStreamIndex)) {
            return NULL;
        }
        return &m_OutputInfo[ulOutputStreamIndex].CurrentMediaType;
    }


    class LockIt
    {
    public:
        LockIt(_DERIVED_ *p) : m_p(p)
        {
            static_cast<_DERIVED_ *>(m_p)->Lock();
        }
        ~LockIt()
        {
            static_cast<_DERIVED_ *>(m_p)->Unlock();
        }
        _DERIVED_ *const m_p;
    };

    bool CheckTypesSet()
    {
        m_fTypesSet = false;
        DWORD dw;
        for (dw = 0; dw < NUMBEROFINPUTS; dw++) {
            if (!InputTypeSet(dw)) {
                return false;
            }
        }
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (!OutputTypeSet(dw)) {
                //  Check if it's optional
                DWORD dwFlags;
#ifdef _DEBUG
                dwFlags = 0xFFFFFFFF;
#endif
                INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(dw, &dwFlags);
                _ASSERTE(0 == (dwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                         DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                         DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                         DMO_OUTPUT_STREAMF_DISCARDABLE |
                                         DMO_OUTPUT_STREAMF_OPTIONAL)));
                if (!(dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)) {
                    return false;
                }
            }
        }
        m_fTypesSet = true;
        return true;
    }


    IMediaObjectImpl() :
        m_fTypesSet(false),
        m_fFlushed(true),
        m_fResourcesAllocated(false)
    {
        ZeroMemory(&m_InputInfo, sizeof(m_InputInfo));
        ZeroMemory(&m_OutputInfo, sizeof(m_OutputInfo));
    }

    virtual ~IMediaObjectImpl() {
        DWORD dwCurrentType;

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFINPUTS; dwCurrentType++) {
            if(InputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_InputInfo[dwCurrentType].CurrentMediaType);
            }
        }

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFOUTPUTS; dwCurrentType++) {
            if(OutputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_OutputInfo[dwCurrentType].CurrentMediaType);
            }
        }
    }


    // IMediaObject methods


    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams  = NUMBEROFINPUTS;
        *pulNumberOfOutputStreams = NUMBEROFOUTPUTS;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetInputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS)));
        return hr;
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_OUTPUT_STREAMF_DISCARDABLE |
                                   DMO_OUTPUT_STREAMF_OPTIONAL)));
        return hr;
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetInputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetOutputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (InputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_InputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (OutputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_OutputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment ||
            NULL == pcbMaxLookahead) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!InputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetInputSizeInfo)(ulStreamIndex, pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet || !OutputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetOutputSizeInfo)(ulStreamIndex, pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            m_InputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckInputType)(ulStreamIndex, pmt);
        if (FAILED(hr))
           return hr;

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (InputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_InputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_InputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }

    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            m_OutputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckOutputType)(ulStreamIndex, pmt);
        if (FAILED(hr)) {
           return hr;
        }

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (OutputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_OutputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_OutputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pdwStatus) {
            return E_POINTER;
        }
        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) == S_OK) {
           *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
        }
        return NOERROR;
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {

        if (prtLatency == NULL) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, GetInputMaxLatency)(ulStreamIndex, prtLatency);
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, SetInputMaxLatency)(ulStreamIndex, rtLatency);
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (S_OK != INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex)) {
            return DMO_E_NOTACCEPTING;
        }

        return INTERNAL_CALL(_DERIVED_, Discontinuity)(ulStreamIndex);
    }

    STDMETHODIMP Flush()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return S_OK;
        }
        if (m_fFlushed) {
            return S_OK;
        }
        HRESULT hr =  INTERNAL_CALL(_DERIVED_, Flush)();
        m_fFlushed = true;
        return hr;
    }

    STDMETHODIMP AllocateStreamingResources() {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }
        if (m_fResourcesAllocated) {
            return S_OK;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, AllocateStreamingResources)();
        if (SUCCEEDED(hr)) {
            m_fResourcesAllocated = true;
        }
        return hr;
    }
    STDMETHODIMP FreeStreamingResources()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (m_fResourcesAllocated) {
            m_fResourcesAllocated = false;
            INTERNAL_CALL(_DERIVED_, Flush)();
            return INTERNAL_CALL(_DERIVED_, FreeStreamingResources)();
        }
        return S_OK;
    }

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
        if (!pBuffer) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~(DMO_INPUT_DATA_BUFFERF_SYNCPOINT |
                        DMO_INPUT_DATA_BUFFERF_TIME |
                        DMO_INPUT_DATA_BUFFERF_TIMELENGTH)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        //  Make sure all streams have media types set and resources are allocated
        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }
        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) != S_OK) {
            return DMO_E_NOTACCEPTING;
        }

        m_fFlushed = false;

        return INTERNAL_CALL(_DERIVED_, ProcessInput)(
                                    ulStreamIndex,
                                    pBuffer,
                                    dwFlags,
                                    rtTimestamp,
                                    rtTimelength);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwFlags,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
        if (pdwStatus == NULL) {
            return E_POINTER;
        }


        if (ulOutputBufferCount != NUMBEROFOUTPUTS || (dwFlags & ~DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER)) {
           return E_INVALIDARG;
        }

        if (NUMBEROFOUTPUTS != 0 && pOutputBuffers == NULL) {
            return E_POINTER;
        }

        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }

        for (DWORD dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            pOutputBuffers[dw].dwStatus = 0;
        }

        hr = INTERNAL_CALL(_DERIVED_, ProcessOutput)(
                           dwFlags,
                           ulOutputBufferCount,
                           pOutputBuffers,
                           pdwStatus);

        // remember the DMO's incomplete status
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (pOutputBuffers[dw].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                m_OutputInfo[dw].fIncomplete = TRUE;
            } else {
                m_OutputInfo[dw].fIncomplete = FALSE;
            }
        }

        return hr;
    }

    STDMETHODIMP DMOLock(LONG lLock)
    {
        if (lLock) {
            static_cast<_DERIVED_ *>(this)->Lock();
        } else {
            static_cast<_DERIVED_ *>(this)->Unlock();
        }
        return S_OK;
    }
};

#endif // _dmoimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmoreg.h ===
//------------------------------------------------------------------------------
// File: DMOReg.h
//
// Desc: 
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMOREG_H__
#define __DMOREG_H__

#include "mediaobj.h"


// 57f2db8b-e6bb-4513-9d43-dcd2a6593125
DEFINE_GUID(DMOCATEGORY_AUDIO_DECODER, 0x57f2db8b,0xe6bb,0x4513,0x9d,0x43,0xdc,0xd2,0xa6,0x59,0x31,0x25);
// 33D9A761-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_AUDIO_ENCODER, 0x33D9A761,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// 4a69b442-28be-4991-969c-b500adf5d8a8
DEFINE_GUID(DMOCATEGORY_VIDEO_DECODER, 0x4a69b442,0x28be,0x4991,0x96,0x9c,0xb5,0x00,0xad,0xf5,0xd8,0xa8);
// 33D9A760-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_VIDEO_ENCODER, 0x33D9A760,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// f3602b3f-0592-48df-a4cd-674721e7ebeb
DEFINE_GUID(DMOCATEGORY_AUDIO_EFFECT, 0xf3602b3f,0x0592,0x48df,0xa4,0xcd,0x67,0x47,0x21,0xe7,0xeb,0xeb);
// d990ee14-776c-4723-be46-3da2f56f10b9
DEFINE_GUID(DMOCATEGORY_VIDEO_EFFECT, 0xd990ee14,0x776c,0x4723,0xbe,0x46,0x3d,0xa2,0xf5,0x6f,0x10,0xb9);
// f665aaba-3e09-4920-aa5f-219811148f09
DEFINE_GUID(DMOCATEGORY_AUDIO_CAPTURE_EFFECT, 0xf665aaba,0x3e09,0x4920,0xaa,0x5f,0x21,0x98,0x11,0x14,0x8f,0x09);

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(DMOCATEGORY_ACOUSTIC_ECHO_CANCEL, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_AUDIO_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(DMOCATEGORY_AUDIO_NOISE_SUPPRESS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(DMOCATEGORY_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

typedef struct _DMO_PARTIAL_MEDIATYPE {
   GUID type;
   GUID subtype;
} DMO_PARTIAL_MEDIATYPE, *PDMO_PARTIAL_MEDIATYPE;

enum DMO_REGISTER_FLAGS {
   DMO_REGISTERF_IS_KEYED = 0x00000001
};

enum DMO_ENUM_FLAGS {
   DMO_ENUMF_INCLUDE_KEYED = 0x00000001
};

STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   //
   // Register all mediatypes supported by the object.  This carries no
   // information about which combinations of input/output types would
   // actually work.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
);

STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory // optional - GUID_NULL means unregister from all
);

STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   //
	// Enumerate only objects that support at least one of the specified input types
	// and at least one of the specified output types.  If no input types are specified,
	// enumerate objects regardless of what input types they support.  Same for
	// output types.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes, // can be NULL only of ulOutTypes = 0
   //
   // Output parameter - this receives a pointer to the DMO CLSID enumerator
   //
   IEnumDMO **ppEnum
);

STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

STDAPI DMOGetName(
   REFCLSID clsidDMO,
   WCHAR szName[80]
);
#endif //__DMOREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmodshow.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for dmodshow.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dmodshow_h__
#define __dmodshow_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDMOWrapperFilter_FWD_DEFINED__
#define __IDMOWrapperFilter_FWD_DEFINED__
typedef interface IDMOWrapperFilter IDMOWrapperFilter;
#endif 	/* __IDMOWrapperFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "mediaobj.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dmodshow_0000 */
/* [local] */ 

DEFINE_GUID(CLSID_DMOWrapperFilter, 0x94297043,0xbd82,0x4dfd,0xb0,0xde,0x81,0x77,0x73,0x9c,0x6d,0x20);
DEFINE_GUID(CLSID_DMOFilterCategory,0xbcd5796c,0xbd52,0x4d30,0xab,0x76,0x70,0xf9,0x75,0xb8,0x91,0x99);


extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_v0_0_s_ifspec;

#ifndef __IDMOWrapperFilter_INTERFACE_DEFINED__
#define __IDMOWrapperFilter_INTERFACE_DEFINED__

/* interface IDMOWrapperFilter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOWrapperFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52d6f586-9f0f-4824-8fc8-e32ca04930c2")
    IDMOWrapperFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            REFCLSID clsidDMO,
            REFCLSID catDMO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOWrapperFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOWrapperFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOWrapperFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOWrapperFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDMOWrapperFilter * This,
            REFCLSID clsidDMO,
            REFCLSID catDMO);
        
        END_INTERFACE
    } IDMOWrapperFilterVtbl;

    interface IDMOWrapperFilter
    {
        CONST_VTBL struct IDMOWrapperFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOWrapperFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDMOWrapperFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDMOWrapperFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDMOWrapperFilter_Init(This,clsidDMO,catDMO)	\
    (This)->lpVtbl -> Init(This,clsidDMO,catDMO)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDMOWrapperFilter_Init_Proxy( 
    IDMOWrapperFilter * This,
    REFCLSID clsidDMO,
    REFCLSID catDMO);


void __RPC_STUB IDMOWrapperFilter_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDMOWrapperFilter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmplugin.h ===
/************************************************************************
*                                                                       *
*   dmplugin.h -- This module contains the API for plugins for the      *
*                 DirectMusic performance layer                         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMPLUGIN_
#define _DMPLUGIN_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include <dmusici.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicTrack;
interface IDirectMusicTool;
interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicPerformance;
interface IDirectMusicPerformance8;
interface IDirectMusicSegment;
interface IDirectMusicSegment8;
interface IDirectMusicSegmentState;
interface IDirectMusicSegmentState8;
interface IDirectMusicGraph;
#ifndef __cplusplus 
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicPerformance8 IDirectMusicPerformance8;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegment8 IDirectMusicSegment8;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicSegmentState8 IDirectMusicSegmentState8;
typedef interface IDirectMusicGraph IDirectMusicGraph;
#endif

typedef struct _DMUS_PMSG DMUS_PMSG;
typedef long              MUSIC_TIME;

/* Registry location for tools */
#define DMUS_REGSTR_PATH_TOOLS  "Software\\Microsoft\\DirectMusic\\Tools"

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool8
DECLARE_INTERFACE_(IDirectMusicTool8, IDirectMusicTool)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
    /*  IDirectMusicTool8 */
    STDMETHOD(Clone)                (THIS_ IDirectMusicTool ** ppTool) PURE;
};

 
/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 0x10,   /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
    /* The following flags are DX8 only. */
    DMUS_TRACKF_NOTIFY_OFF      = 0x20,   /* tells track not to send notifications. */
    DMUS_TRACKF_PLAY_OFF        = 0x40,   /* tells track not to play anything (but can still send notifications.) */
    DMUS_TRACKF_LOOPEND         = 0x80,   /* set when the end of range is also a loop end. */
    DMUS_TRACKF_STOP            = 0x100,  /* set when the end of range is also end of playing this segment. */
    DMUS_TRACKF_RECOMPOSE       = 0x200,  /* set to indicate the track should compose. */
    DMUS_TRACKF_CLOCK           = 0x400,  /* set when time parameters are in reference (clock) time. Only valid for PlayEx(). */
} DMUS_TRACKF_FLAGS;

/* The following flags are sent in the IDirectMusicTrack8::GetParamEx() and SetParamEx() methods */
/* inside the dwFlags parameter */
#define DMUS_TRACK_PARAMF_CLOCK  0x01       /* set when the time is measured is in reference (clock) time */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack8
DECLARE_INTERFACE_(IDirectMusicTrack8, IDirectMusicTrack)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
    /* IDirectMusicTrack8 */
    STDMETHOD(PlayEx)                 (THIS_ void* pStateData, 
                                             REFERENCE_TIME rtStart, 
                                             REFERENCE_TIME rtEnd, 
                                             REFERENCE_TIME rtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE; 
    STDMETHOD(GetParamEx)             (THIS_ REFGUID rguidType,         /* Command type. */
                                             REFERENCE_TIME rtTime,     /* Time, in ref time if dwFlags == DMUS_TRACK_PARAMF_CLOCK. Otherwise, music time. */
                                             REFERENCE_TIME* prtNext,   /* Time of next parameter, relative to rtTime, in music or clock time units. */
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(SetParamEx)             (THIS_ REFGUID rguidType, 
                                             REFERENCE_TIME rtTime, 
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(Compose)                (THIS_ IUnknown* pContext,        /* Context for composition (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
    STDMETHOD(Join)                   (THIS_ IDirectMusicTrack* pNewTrack,
                                             MUSIC_TIME mtJoin,
                                             IUnknown* pContext,        /* Context for joining (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* New CLSID's for DX8 */
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* IID's */
DEFINE_GUID(IID_IDirectMusicTrack, 0xf96029a1, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Interface IDs for DX8 */
/* changed interfaces (GUID only) */
DEFINE_GUID(IID_IDirectMusicTool8, 0xe674303, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);
DEFINE_GUID(IID_IDirectMusicTrack8, 0xe674304, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMPLUGIN_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE; 

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;                                           
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_


#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK        mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK        mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK        mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK        mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK        mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    /* Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM            mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK           mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST             mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK            mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK            mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK           mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_MARKER_CHUNK          mmioFOURCC('m','r','k','r')
#define DMUS_FOURCC_RESOLUTION_CHUNK      mmioFOURCC('r','s','l','n')
#define DMUS_FOURCC_ANTICIPATION_CHUNK    mmioFOURCC('a','n','p','n')
#define DMUS_FOURCC_PATTERN_LIST          mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK         mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK          mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST          mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK         mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p','r','r','f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m','t','f','s')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  
#define DMUS_VARIATIONF_DEST_OTHER   0x40000000 /* Handles transitions to chords other than 1 . */  

/* legacy mask for variation modes */
#define DMUS_VARIATIONF_MODES        0xE0000000
/* Bits 29 and 31 of the variation flags are the Mode bits.  If both are 0, it's IMA. */  
/* If bit 29 is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES_EX     (0x20000000 | 0x80000000)
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

/* Set this if the part uses marker events */
#define DMUS_PARTF_USE_MARKERS       0x1
/* Set this if the part is allowed to switch only on chord-aligned markers */
#define DMUS_PARTF_ALIGN_CHORDS      0x2

/* These specify if the marker event signals whether to stop a variation or start a 
pattern/variation (or both), and whether new variations must align with a chord */
#define DMUS_MARKERF_START            0x1
#define DMUS_MARKERF_STOP             0x2
#define DMUS_MARKERF_CHORD_ALIGN      0x4

/* if this flag is set, variation settings in a playing pattern-based track's state data will 
persist in the track after it stops playing */
#define DMUS_PATTERNF_PERSIST_CONTROL 0x1

/* These specify possible values for DMUS_IO_PARTREF.bRandomVariation
   all but DMUS_VARIATIONT_SEQUENTIAL and DMUS_VARIATIONT_RANDOM are dx8. */
typedef enum enumDMUS_VARIATIONT_TYPES
{
    DMUS_VARIATIONT_SEQUENTIAL       = 0, /* Play sequential starting with variation 1. */
    DMUS_VARIATIONT_RANDOM           = 1, /* Play randomly. */
    DMUS_VARIATIONT_RANDOM_START     = 2, /* Play sequential starting with a random variation. */
    DMUS_VARIATIONT_NO_REPEAT        = 3, /* Play randomly, but don't play the same variation twice. */
    DMUS_VARIATIONT_RANDOM_ROW       = 4  /* Play randomly as a row: don't repeat any variation until all have played. */
} DMUS_VARIATIONT_TYPES;

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;           /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;     /* bottom of groove range */
    BYTE                bGrooveTop;        /* top of groove range */
    WORD                wEmbellishment;    /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;      /* length in measures */
    BYTE                bDestGrooveBottom; /* bottom of groove range for next pattern */
    BYTE                bDestGrooveTop;    /* top of groove range for next pattern */
    DWORD               dwFlags;           /* various flags */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
    BYTE                bPad[3];        /* for DWORD alignment */
    DWORD               dwFlags;        /* various flags */ 
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel OBSOLETE */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
    WORD    wPad;               /* not used */
    DWORD   dwPChannel;         /* replaces wLogicalPartID */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
    /* Following exists only under DX8 and on */
    BYTE        bNoteFlags;     /* values from DMUS_NOTEF_FLAGS */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
    /*  Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_STYLEMARKER
{
    MUSIC_TIME  mtGridStart;    /* when this marker occurs */
    DWORD       dwVariation;    /* variation bits */
    WORD        wMarkerFlags;   /* how the marker is used */
} DMUS_IO_STYLEMARKER;

typedef struct _DMUS_IO_STYLERESOLUTION
{
    DWORD    dwVariation;       /* variation bits */
    WORD     wMusicValue;       /* Position in scale. */
    BYTE     bInversionID;      /* Identifies inversion group to which this note belongs */
    BYTE     bPlayModeFlags;    /* Can override part */
} DMUS_IO_STYLERESOLUTION;

typedef struct _DMUS_IO_STYLE_ANTICIPATION
{
    MUSIC_TIME    mtGridStart;   /* when this anticipation occurs */
    DWORD         dwVariation;   /* variation bits */
    short         nTimeOffset;   /* offset from mtGridStart */
    BYTE          bTimeRange;    /* Range to randomize start time. */
} DMUS_IO_STYLE_ANTICIPATION;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. Or, 0, indicating loop full motif.  */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // Array of parts in the Style, used by patterns
    <pttn-list>...  // Array of patterns in the Style
    <DMBD-form>...  // Array of bands in the Style
    [<prrf-list>]...// Optional array of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<note-ck>]     // Optional chunk containing an array of notes in Part
        [<crve-ck>]     // Optional chunk containing an array of curves in Part
        [<mrkr-ck>]     // Optional chunk containing an array of markers in Part
        [<rsln-ck>]     // Optional chunk containing an array of variation resolutions in Part
        [<anpn-ck>]     // Optional chunk containing an array of resolution anticipations in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

        // <mrkr-ck>
        'mrkr'
        (
            // sizeof DMUS_IO_STYLEMARKER:DWORD
            <DMUS_IO_STYLEMARKER>...
        )

        // <rsln-ck>
        'rsln'
        (
            // sizeof DMUS_IO_STYLERESOLUTION:DWORD
            <DMUS_IO_STYLERESOLUTION>...
        )

        // <anpn-ck>
        'anpn'
        (
            // sizeof DMUS_IO_STYLE_ANTICIPATION:DWORD
            <DMUS_IO_STYLE_ANTICIPATION>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // Chunk containing an array of rhythms for chord matching
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<mtfs-ck>]     // Motif settings chunk
        [<DMBD-form>]   // Optional band to be associated with the pattern (for motifs)
        <pref-list>...  // Array of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )


        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        <DMRF-list>... // Array of Chordmap references
    )
*/

/* Pattern chunk, for use in Pattern tracks */

#define DMUS_FOURCC_PATTERN_FORM        mmioFOURCC('D','M','P','T')

/*
RIFF
(
    'DMPT'          // Pattern
    <styh-ck>       // Style header chunk
    <pttn-list>     // The pattern, in single pattern format (includes DMUS_FOURCC_PART_LIST chunks)
)
*/


/* Chord and command file formats */

/* These specify possible values for DMUS_IO_COMMAND.bRepeatMode (dx8) */
typedef enum enumDMUS_PATTERNT_TYPES
{
    DMUS_PATTERNT_RANDOM           = 0, /* Play randomly. (dx7 behavior) */
    DMUS_PATTERNT_REPEAT           = 1, /* Repeat last pattern. */
    DMUS_PATTERNT_SEQUENTIAL       = 2, /* Play sequential starting with first matching pattern. */
    DMUS_PATTERNT_RANDOM_START     = 3, /* Play sequential starting with a random pattern. */
    DMUS_PATTERNT_NO_REPEAT        = 4, /* Play randomly, but don't play the same pattern twice. */
    DMUS_PATTERNT_RANDOM_ROW       = 5  /* Play randomly as a row: don't repeat any pattern until all have played. */
} DMUS_PATTERNT_TYPES;

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bFlags;         /* Various flags */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
    BYTE        bRepeatMode;    /* Used to control selection of patterns with same groove level  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // Array of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      Tools are embedded in a graph. Theoretically, they can be saved as individual files too.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  The AudioPath file carries everything for describing a specific audio path,
    including Tool Graph and Buffer Descriptor.
    This can even be used for configuring a complete performance.
*/

#define DMUS_FOURCC_AUDIOPATH_FORM  mmioFOURCC('D','M','A','P')

/*
RIFF
(
    'DMAP'          // DirectMusic AudioPath chunk
    [<guid-ck>]     // GUID for this Audio Path configuration
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMTG-form>]   // Optional ToolGraph
    [<pcsl-list>]   // Optional list of port configurations
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
)
*/

#define DMUS_FOURCC_PORTCONFIGS_LIST    mmioFOURCC('p','c','s','l')
#define DMUS_FOURCC_PORTCONFIG_LIST     mmioFOURCC('p','c','f','l')
#define DMUS_FOURCC_PORTCONFIG_ITEM     mmioFOURCC('p','c','f','h')
#define DMUS_FOURCC_PORTPARAMS_ITEM     mmioFOURCC('p','p','r','h')
#define DMUS_FOURCC_DSBUFFER_LIST       mmioFOURCC('d','b','f','l')
#define DMUS_FOURCC_DSBUFFATTR_ITEM     mmioFOURCC('d','d','a','h')
#define DMUS_FOURCC_PCHANNELS_LIST      mmioFOURCC('p','c','h','l')
#define DMUS_FOURCC_PCHANNELS_ITEM      mmioFOURCC('p','c','h','h')

typedef struct _DMUS_IO_PORTCONFIG_HEADER
{
    GUID    guidPort;           /* GUID of requested port. */
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many channels. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_PORTCONFIG_HEADER;

#define DMUS_PORTCONFIGF_DRUMSON10  1   /* This port configured for drums on channel 10. */
#define DMUS_PORTCONFIGF_USEDEFAULT 2   /* Use the default port. */

/* Each portconfig has one or more pchannel to buffer mappings. Each buffer
   is identified by a guid. Each pchannel can map to one or more buffers.
   This is defined with one or more DMUS_IO_PCHANNELTOBUFFER_HEADER
   structures. Each defines a range of PChannels and the set of buffers
   that they connect to. 
*/

typedef struct _DMUS_IO_PCHANNELTOBUFFER_HEADER
{
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many PChannels. */
    DWORD   dwBufferCount;      /* How many buffers do these connect to. */
    DWORD   dwFlags;            /* Various flags. Currently reserved for future use. Must be 0. */
} DMUS_IO_PCHANNELTOBUFFER_HEADER;

/* Each buffer is represented by an DSBC form. This is wrapped by the 
   DMUS_IO_BUFFER_ATTRIBUTES_HEADER which identifies how to use the
   buffer. In particular, it indicates whether this gets dynamically duplicated
   or all references to this should share the same instance. 
   To resolve references, the unique GUID of the buffer is also stored
   in this structure. 
*/
   
typedef struct _DMUS_IO_BUFFER_ATTRIBUTES_HEADER
{
    GUID    guidBufferID;       /* Each buffer config has a unique ID. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_BUFFER_ATTRIBUTES_HEADER;

/* DMUS_IO_BUFFER_ATTRIBUTES_HEADER.dwFlags: */
#define DMUS_BUFFERF_SHARED     1   /* Share this with other audio paths, instead of creating unique copies. */
#define DMUS_BUFFERF_DEFINED    2   /* Use one of the standard predefined buffers (see GUID_Buffer... in dmusici.h.) */
#define DMUS_BUFFERF_MIXIN      8   /* This is a mixin buffer. */

/*

LIST
(
    'pcsl'          // Array of port configurations
    <pcfl-list>...  // One or more port configurations, each in a list chunk
)

LIST
(
    'pcfl'          // List container for one port configuration.
    <pcfh-ck>       // Portconfig header chunk.
    <pprh-ck>       // Port params, to be used to create the port.
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
    [<pchl-list>]   // Optional list of pchannel to buffer assignments

)

    // <pcfh-ck>            // Port config header chunk
    (
        'pcfh'
        <DMUS_IO_PORTCONFIG_HEADER>   // Port config header
    )

    // <pprh-ck>            // Port params header chunk
    (
        'pprh'
        <DMUS_PORTPARAMS8>   // Port params header
    )

LIST
(
    'pchl'          // List container for one or more pchannel to buffer assignments.
    <pchh-ck>...    // One or more pchannel to buffer assignment headers and data.

    // <pchh-ck>
    (
        'pchh'
        <DMUS_IO_PCHANNELTOBUFFER_HEADER>   // Description of PChannels
        <GUID>...                           // Array of GUIDs defining the buffers they all connect to.
    )
)

LIST
(
    'dbfl'          // List container for one buffer and buffer attributes header.
    <ddah-ck>       // Buffer attributes header. 
    [<DSBC-form>]   // Buffer configuration. Not required when header uses a predefined buffer type.

    // <ddah-ck>
    (
        'ddah'
        <DMUS_IO_BUFFER_ATTRIBUTES_HEADER>   // Buffer attributes.
    )
)
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')
#define DMUS_FOURCC_BANDITEM_CHUNK2 mmioFOURCC('b','d','2','h')

/* io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER2
{
    MUSIC_TIME lBandTimeLogical;   /* Position in track list. Time in the music with which band change is associated. */
    MUSIC_TIME lBandTimePhysical;  /* Precise time band change will take effect. Should be close to logical time. */
} DMUS_IO_BAND_ITEM_HEADER2;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band items
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'
        <lbnd-list>...  // Array of bands, each encapsulated in a list chunk
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck> or <bd2h-ck>  // bdih is a legacy format.  bd2h is preferred for new content.
            <DMBD-form> // Band
        )

            // <bdih-ck> or <bd2h-ck>       // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER> or <DMUS_IO_BAND_ITEM_HEADER2> // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */
#define DMUS_IO_INST_PITCHBENDRANGE (1 << 13)     /* nPitchBendRange is valid */

/* io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
    short   nPitchBendRange;    /* Number of semitones shifted by pitch bend */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // Array of instruments
        <lbin-list>...  // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/* This RIFF id and io struct have been added to allow wave files (and the wave object) to 
   differentiate between streaming and one-shot waves, and to give a prefetch for streaming
   waves  */

#define DMUS_FOURCC_WAVEHEADER_CHUNK   mmioFOURCC('w','a','v','h')

typedef struct _DMUS_IO_WAVE_HEADER
{
    REFERENCE_TIME  rtReadAhead;    /* How far ahead in the stream wave data will be read (in REFERENCE_TIME).  Ignored for one-shot waves.  */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
} DMUS_IO_WAVE_HEADER;


/*  File io for Wave track */

/* RIFF ids: */

#define DMUS_FOURCC_WAVETRACK_LIST      mmioFOURCC('w','a','v','t')
#define DMUS_FOURCC_WAVETRACK_CHUNK     mmioFOURCC('w','a','t','h')
#define DMUS_FOURCC_WAVEPART_LIST       mmioFOURCC('w','a','v','p')
#define DMUS_FOURCC_WAVEPART_CHUNK      mmioFOURCC('w','a','p','h')
#define DMUS_FOURCC_WAVEITEM_LIST       mmioFOURCC('w','a','v','i')
#define DMUS_FOURCC_WAVE_LIST           mmioFOURCC('w','a','v','e')
#define DMUS_FOURCC_WAVEITEM_CHUNK      mmioFOURCC('w','a','i','h')

/* This flag is included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, the track will get its 
   variations from a pattern track, via GetParam(GUID_Variations). */
#define DMUS_WAVETRACKF_SYNC_VAR   0x1
/* This is also included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, variation control 
   information will persist from one playback instance to the next.*/
#define DMUS_WAVETRACKF_PERSIST_CONTROL 0x2

typedef struct _DMUS_IO_WAVE_TRACK_HEADER
{
    long        lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves.  Note:  All gain values should be negative. */
    DWORD       dwFlags;        /* Flags, including whether this track syncs to a pattern track for its variations. */
} DMUS_IO_WAVE_TRACK_HEADER;

typedef struct _DMUS_IO_WAVE_PART_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves in wave part.  Note:  All gain values should be negative. */
    DWORD           dwVariations;   /* Variation mask for which of 32 variations */
    DWORD           dwPChannel;     /* PChannel */
    DWORD           dwLockToPart;   /* Part ID to lock to. */
    DWORD           dwFlags;        /* Flags, including stuff for managing how variations are chosen (in low-order nibble) */
    DWORD           dwIndex;        /* Index for distinguishing multiple parts on the same PChannel*/
} DMUS_IO_WAVE_PART_HEADER;

typedef struct _DMUS_IO_WAVE_ITEM_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB.  Note:  All gain values should be negative. */
    long            lPitch;         /* Pitch offset in 1/100th of a semitone. */
    DWORD           dwVariations;   /* Variation flags for which of 32 variations this wave belongs to. */
    REFERENCE_TIME  rtTime;         /* Start time, in REFERENCE_TIME, if clock time track, or MUSIC_TIME for music time track. */
    REFERENCE_TIME  rtStartOffset;  /* Distance into wave to start playback, in reference time units. */
    REFERENCE_TIME  rtReserved;     /* Reserved field. */
    REFERENCE_TIME  rtDuration;     /* Duration, in REFERENCE_TIME or MUSIC_TIME, depending on track timing format. */
    MUSIC_TIME      mtLogicalTime;  /* If in music track format, this indicates the musical boundary where this belongs. Otherwise, ignored. */
    DWORD           dwLoopStart;    /* Start point for a looping wave. */
    DWORD           dwLoopEnd;      /* End point for a looping wave. */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
} DMUS_IO_WAVE_ITEM_HEADER;

/*
LIST
{
    'wavt'          // Wave track chunk
    <wath-ck>       // Wave track header
    <wavp-list>...  // Array of Wave Parts
}
    // <wath-ck>
    'wath'
    {
        <DMUS_IO_WAVE_TRACK_HEADER>
    }

    //  <wavp-list>
    LIST
    {
        'wavp'
        <waph-ck>       //  Wave Part Header
        <wavi-list>     //  List of wave items
    }

        //  <waph-ck>
        'waph'
        {
            <DMUS_IO_WAVE_PART_HEADER>
        }

        //  <wavi-list>
        LIST
        {
            'wavi'
            <wave-list>...  //  Array of waves; each wave is encapsulated in a list
        }

            //  <wave-list>
            LIST
            {
                'wave'
                <waih-ck>       //  Wave item header
                <DMRF-list>     //  Reference to wave object
            }

                //  <waih-ck>
                'waih'
                {
                    <DMUS_IO_WAVE_ITEM_HEADER>
                }

*/

/*  File io for DirectMusic Container file. This embeds a set of related files. And,
    in turn, it can be embedded within a segment or script file.
*/

#define DMUS_FOURCC_CONTAINER_FORM          mmioFOURCC('D','M','C','N')
#define DMUS_FOURCC_CONTAINER_CHUNK         mmioFOURCC('c','o','n','h')
#define DMUS_FOURCC_CONTAINED_ALIAS_CHUNK   mmioFOURCC('c','o','b','a')
#define DMUS_FOURCC_CONTAINED_OBJECT_CHUNK  mmioFOURCC('c','o','b','h')
#define DMUS_FOURCC_CONTAINED_OBJECTS_LIST  mmioFOURCC('c','o','s','l')
#define DMUS_FOURCC_CONTAINED_OBJECT_LIST   mmioFOURCC('c','o','b','l')

typedef struct _DMUS_IO_CONTAINER_HEADER
{
    DWORD       dwFlags;        /* Flags. */
} DMUS_IO_CONTAINER_HEADER;

#define DMUS_CONTAINER_NOLOADS  (1 << 1)   /* Contained items are not loaded when the container is loaded.
                                              Entries will be created in the loader (via SetObject) but
                                              the actual objects will not be created until they are
                                              specifically loaded at a later time. */

typedef struct _DMUS_IO_CONTAINED_OBJECT_HEADER
{
    GUID        guidClassID;    /* Class id of object. */
    DWORD       dwFlags;        /* Flags, for example DMUS_CONTAINED_OBJF_KEEP. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
        /* Note that LIST:DMRF may be used for ckid and fccType in order to reference an
           object instead of embedding it within the container. */
} DMUS_IO_CONTAINED_OBJECT_HEADER;

#define DMUS_CONTAINED_OBJF_KEEP    1   /* Keep the object cached in the loader after the container is released. */

/*
RIFF
(
    'DMCN'          // DirectMusic Container chunk
    <conh-ck>       // Container header chunk
    [<guid-ck>]     // GUID for container
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <cosl-list>     // List of objects.
)

    // <conh-ck>        
    'conh'
    (
        <DMUS_IO_CONTAINER_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    LIST
    (
        'cosl'          // Array of embedded objects.
        <cobl-list>...  // Each object is encapsulated in a LIST chunk
    )

    // <cobl-list>      // Encapsulates one object
    LIST
    (
        'cobl'
        [<coba-ck>]         // Alias.  An alternative name by which this object is known
                            // within the container.
        <cobh-ck>           // Required header, includes CLASS ID for object.
        [<data>] or <DMRF>  // Object data of the type specified in <cobh-ck>.
                            // If DMRF, it is a reference of where to find the object.
                            // Otherwise, it could be any RIFF readable chunk in the
                            //    exact same format as a file.  The object will load
                            //    itself from this data.
    )

    // <coba-ck>
    'coba'
    (
        // Alias, stored as NULL terminated string of WCHARs
    )

    // <cobh-ck>
    'cobh'
    (
        <DMUS_IO_CONTAINED_OBJECT_HEADER>
    )
*/

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM        mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK       mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST          mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM          mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK         mmioFOURCC('t','r','k','h')
#define DMUS_FOURCC_TRACK_EXTRAS_CHUNK  mmioFOURCC('t','r','k','x')

/* io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. Or, 0, indicating loop full segment. */
    DWORD       dwResolution;   /* Default resolution. */
    /* Following added for DX8: */
    REFERENCE_TIME rtLength;    /* Length, in reference time (overrides music time length.) */
    DWORD       dwFlags;
    DWORD       dwReserved;     /* Reserved. */
} DMUS_IO_SEGMENT_HEADER;

#define DMUS_SEGIOF_REFLENGTH   1  /* Use the time in rtLength for the segment length. */

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk. */
    FOURCC      fccType;        /* list type if ckid is RIFF or LIST */ 
} DMUS_IO_TRACK_HEADER;

/*  Additional parameters for the track header chunk, introduced in DX8 and
    on, are stored in a separate chunk. */

typedef struct _DMUS_IO_TRACK_EXTRAS_HEADER
{
    DWORD       dwFlags;        /* DX8 Added flags for control tracks. */
    DWORD       dwPriority;     /* Priority for composition. */
} DMUS_IO_TRACK_EXTRAS_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede tracklist.
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
    [<DMAP-form>]   // Optional Audio Path
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // Array of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

    // <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
    RIFF
    (
        'DMTK'
        <trkh-ck>
        [<trkx-ck>]     // Optional track flags. 
        [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
        [<vers-ck>]     // Optional version info
        [<UNFO-list>]   // Optional name, author, copyright info., comments
        [<data>]        // Track data. Must be a RIFF readable chunk.
    )

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )

    // <trkx-ck>            // Track flags chunk
    (
        'trkx'
        <DMUS_IO_TRACK_EXTRAS_HEADER>  // DX8 Track flags header
    )
*/

/*  File io for DirectMusic Song object */
/*  Note: Song file format is not supported in DX8. */

/* RIFF ids: */

#define DMUS_FOURCC_SONG_FORM           mmioFOURCC('D','M','S','O') /* Entire song. */
#define DMUS_FOURCC_SONG_CHUNK          mmioFOURCC('s','n','g','h') /* Song header info. */
#define DMUS_FOURCC_SONGSEGMENTS_LIST   mmioFOURCC('s','e','g','l') /* List of embedded segments. */
#define DMUS_FOURCC_SONGSEGMENT_LIST    mmioFOURCC('s','s','g','l') /* Container for a segment or segment reference. */
#define DMUS_FOURCC_TOOLGRAPHS_LIST     mmioFOURCC('t','l','g','l') /* List of embedded tool graphs. */
#define DMUS_FOURCC_SEGREFS_LIST        mmioFOURCC('s','r','s','l') /* List of segment references. */
#define DMUS_FOURCC_SEGREF_LIST         mmioFOURCC('s','g','r','l') /* Container for a segment reference. */
#define DMUS_FOURCC_SEGREF_CHUNK        mmioFOURCC('s','g','r','h') /* Segment reference header. */
#define DMUS_FOURCC_SEGTRANS_CHUNK      mmioFOURCC('s','t','r','h') /* Set of transitions to this segment. */
#define DMUS_FOURCC_TRACKREFS_LIST      mmioFOURCC('t','r','s','l') /* Set of track references within the segment reference. */
#define DMUS_FOURCC_TRACKREF_LIST       mmioFOURCC('t','k','r','l') /* Container for a track reference. */
#define DMUS_FOURCC_TRACKREF_CHUNK      mmioFOURCC('t','k','r','h') /* Track reference header. */

/* io structures:*/

typedef struct _DMUS_IO_SONG_HEADER
{
    DWORD       dwFlags;
    DWORD       dwStartSegID;   /* Id of the segment that starts playback. */
} DMUS_IO_SONG_HEADER;

typedef struct _DMUS_IO_SEGREF_HEADER
{
    DWORD       dwID;           /* Each has a unique ID. Must be less than DMUS_SONG_MAXSEGID. */
    DWORD       dwSegmentID;    /* Optional segment to link to. */
    DWORD       dwToolGraphID;  /* Optional tool graph to use for processing. */
    DWORD       dwFlags;        /* Various control flags. Currently reserved for future use. Must be 0. */
    DWORD       dwNextPlayID;   /* ID of next segment, to chain segments into a song. */
} DMUS_IO_SEGREF_HEADER;


typedef struct _DMUS_IO_TRACKREF_HEADER
{
    DWORD       dwSegmentID;    /* Which segment to find this in. */
    DWORD       dwFlags;        /* Reference control flags. */
} DMUS_IO_TRACKREF_HEADER;

/*  Transition definition chunk defines a transition, using an optional transition template
    segment.
*/

typedef struct _DMUS_IO_TRANSITION_DEF
{
    DWORD       dwSegmentID;        /* Segment the transition goes to. */
    DWORD       dwTransitionID;     /* Template segment to use for the transition. */
    DWORD       dwPlayFlags;        /* Flags to use for transition. */
} DMUS_IO_TRANSITION_DEF;

#define DMUS_SONG_MAXSEGID      0x7FFFFFFF  /* Segment ids can not go higher than this. */
#define DMUS_SONG_ANYSEG        0x80000000  /* Special ID to indicate any segment. */
#define DMUS_SONG_NOSEG         0xFFFFFFFF  /* Special ID to indicate no segment. */
#define DMUS_SONG_NOFROMSEG     0x80000001  /* Special ID for dwSegmentID to indicate transition from nothing (or outside the song) into this segment. */

/*
RIFF
(
    'DMSO'          // DirectMusic Song chunk
    <sngh-ck>       // Song header chunk
    [<guid-ck>]     // GUID for song
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede segment list.
    <segl-list>     // List of Segments
    [<tlgl-list>]   // Optional list of ToolGraphs
    [<DMAP-form>]   // Optional Audio Path - to be shared by all segments in song.
    <srsl-list>     // List of segment references.
)

    // <sngh-ck>        
    'sngh'
    (
        <DMUS_IO_SONG_HEADER>
    )
    
    // <segl-list>
    LIST
    (
        'segl'          // Array of segments
        <ssgl-list>...  // Each segment is wrapped in this.
    )

    // <ssgl-list>
    LIST
    (
        'ssgl'          // Segment container.
        [DMSG-form]     // Each segment is either a full embedded segment RIFF form.
        [DMRF-list]     // Or a reference to an external segment.
    )

    // <tlgl-list>
    LIST
    (
        'tlgl'          // Array of toolgraphs
        <DMTG-form>...  // Each toolgraph is a full RIFF form.
    )

    // <srsl-list>
    LIST
    (
        'srsl'          // Array of segment references
        <sgrl-list>...  // Each segment reference is contained in a RIFF list.
    )

    // <sgrl-list>      // Segment reference container.
    LIST
    (
        'sgrl'
        <sgrh-ck>       // Segment reference header chunk.
        <segh-ck>       // Segment header chunk. Defines the segment. 
        <UNFO-list>     // Name, author, etc. Primarily for name, though, which is required for Song->GetSegment().
        [<strh-ck>]     // Segment transition chunk. Defines how to do transitions from other segments.
        [<trsl-list>]   // List of track references, to create a segment from tracks in multiple segments.
    )

    // <sgrh-ck>        // Segment reference header chunk
    (
        'sgrh'
        <DMUS_IO_SEGREF_HEADER>  // Segment reference header
    )

    // <strh-ck>        // Segment transition chunk. 
    (
        'strh'
        <DMUS_IO_TRANSITION_DEF>    // Default transition.
        <DMUS_IO_TRANSITION_DEF>... // Additional transitions.
    )

    // <trsl-list>      // Array of track references
    (
        'trsl'
        <tkrl-list>...  // Each track reference is multiple chunks in a tkrl list.
    )

    // <tkrl-list>      // Track reference container
    (
        'tkrl'
        <tkrh-ck>       // Track reference header chunk.
        <trkh-ck>       // Normal track header chunk.
        [<trkx-ck>]     // Optional track flags. 
    )

    // <tkrh-ck>        // Track reference header chunk
    (
        'tkrh'
        <DMUS_IO_TRACKREF_HEADER>  // Track reference header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwFlags field of DMUS_IO_CHORDMAP */
#define DMUS_CHORDMAPF_VERSION8  1   /* Chordmap is version 8 or above. */

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;           /* Various flags. Only lower 16 bits are significant. */
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/*  File io for DirectMusic Script object */

/* RIFF ids: */

#define DMUS_FOURCC_SCRIPT_FORM             mmioFOURCC('D','M','S','C')
#define DMUS_FOURCC_SCRIPT_CHUNK            mmioFOURCC('s','c','h','d')
#define DMUS_FOURCC_SCRIPTVERSION_CHUNK     mmioFOURCC('s','c','v','e')
#define DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK    mmioFOURCC('s','c','l','a')
#define DMUS_FOURCC_SCRIPTSOURCE_CHUNK      mmioFOURCC('s','c','s','r')

/* io structures:*/

typedef struct _DMUS_IO_SCRIPT_HEADER
{
    DWORD       dwFlags; /* DMUS_SCRIPTIOF_ flags */
} DMUS_IO_SCRIPT_HEADER;

#define DMUS_SCRIPTIOF_LOAD_ALL_CONTENT       (1 << 0)
    /* If set, when the script loads it will also load all the content in its container. */
#define DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS  (1 << 1)
    /* If set and LOAD_ALL_CONTENT is also set, when the script initializes it will also download all the segments in its container.
       If set and LOAD_ALL_CONTENT is not set, when the script calls segment.Load on a segment then the segment will also be downloaded.
       If not set, the script must manually download and unload by calling segment.DownloadSoundData and segment.UnloadSoundData. */

/*
RIFF
(
    'DMSC'              // DirectMusic Script chunk
    <schd-ck>           // Script header chunk
    [<guid-ck>]         // GUID for script
    [<vers-ck>]         // Optional version info
    [<UNFO-list>]       // Name, author, copyright info., comments
    <scve-ck>           // Version of DirectMusic this script was authored to run against
    <DMCN-form>         // Container of content referenced by the script.
    <scla-ck>           // ActiveX scripting language in which the script is written
    <scsr-ck> or <DMRF> // The script's source code.
                        // If scsr-ck, the source is embedding in the chunk.
                        // If DMRF, it is a reference of where to find a text file with the source.
                        //    Class id (guidClassID in DMUS_IO_REFERENCE) must be GUID_NULL because
                        //    this text file is not a DirectMusic object in its own right.
)

    // <schd-ck>
    'schd'
    (
        <DMUS_FOURCC_SCRIPT_CHUNK>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <scve-ck>
    scve
    (
        <DMUS_IO_VERSION>
    )

    'scla'
    (
        // Language name, stored as NULL terminated string of WCHARs
    )

    'scsr'
    (
        // Source code, stored as NULL terminated string of WCHARs
    )
*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        <strf-list>...  // Array of Style references
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        <pfrf-list>...  // Array of Chord map references
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo array
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
 */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence array
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve array
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        {
            <DMUS_IO_SYSEX_ITEM>
            <BYTE>...    // Array of bytes, length defined in the DMUS_IO_SYSEXITEM structure
        }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/*  DX6 time signature track
    
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

/*  DX8 Time signature track. The track has been updated from DX7 to support a list of
    RIFF chunks. This will allow the time signature track to expand in the future.
*/

#define DMUS_FOURCC_TIMESIGTRACK_LIST   mmioFOURCC('T','I','M','S')
#define DMUS_FOURCC_TIMESIG_CHUNK       DMUS_FOURCC_TIMESIGNATURE_TRACK

/*
LIST
(
    'TIMS'          // Time Signature Track list-type
    <tims-ck>       // Chunk containing an array of time signatures
)

    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
 
*/

/*  DX8 Marker track. This is used to store valid start points and other
    flow control parameters that may come later. For example, if we want
    to implement more sophisticated looping and branching constructs, they
    would live in this track.
*/

#define DMUS_FOURCC_MARKERTRACK_LIST    mmioFOURCC('M','A','R','K')
#define DMUS_FOURCC_VALIDSTART_CHUNK    mmioFOURCC('v','a','l','s')
#define DMUS_FOURCC_PLAYMARKER_CHUNK    mmioFOURCC('p','l','a','y')

/* io structures */
typedef struct _DMUS_IO_VALID_START
{
    MUSIC_TIME mtTime;      /* Time of a legal start. */
} DMUS_IO_VALID_START;

typedef struct _DMUS_IO_PLAY_MARKER
{
    MUSIC_TIME mtTime;      /* Time of a next legal play point marker. */
} DMUS_IO_PLAY_MARKER;

/*
LIST
(
    'MARK'          // Marker Track list-type
    [<vals-ck>]     // Chunk containing an array of start points
    [<play-ck>]     // Chunk containing an array of play start markers
)

    'vals'
    (
        // size of DMUS_IO_VALID_START : DWORD
        <DMUS_IO_VALID_START>...
    )

    'play'
    (
        // size of DMUS_IO_PLAY_MARKER : DWORD
        <DMUS_IO_PLAY_MARKER>...
    )
  
*/

/* segment trigger tracks */

/* RIFF ids: */
#define DMUS_FOURCC_SEGTRACK_LIST                   mmioFOURCC('s','e','g','t')
#define DMUS_FOURCC_SEGTRACK_CHUNK                  mmioFOURCC('s','g','t','h')
#define DMUS_FOURCC_SEGMENTS_LIST                   mmioFOURCC('l','s','g','l')
#define DMUS_FOURCC_SEGMENT_LIST                    mmioFOURCC('l','s','e','g')
#define DMUS_FOURCC_SEGMENTITEM_CHUNK               mmioFOURCC('s','g','i','h')
#define DMUS_FOURCC_SEGMENTITEMNAME_CHUNK           mmioFOURCC('s','n','a','m')

/* io structures */
typedef struct _DMUS_IO_SEGMENT_TRACK_HEADER
{
    DWORD dwFlags; /* Reserved leave as 0. */
} DMUS_IO_SEGMENT_TRACK_HEADER;

typedef struct _DMUS_IO_SEGMENT_ITEM_HEADER
{
    MUSIC_TIME      lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME      lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
    DWORD           dwPlayFlags;     /* Flags for PlaySegment(). */
    DWORD           dwFlags;         /* Flags. */
} DMUS_IO_SEGMENT_ITEM_HEADER;

/* values for dwflags field of DMUS_IO_SEGMENT_ITEM_HEADER */
#define DMUS_SEGMENTTRACKF_MOTIF                 1        /* interpret DMRF as link to style, and use snam as the name of a motif within the style */

/*
LIST
(
    'segt'          // DirectMusic Segment Trigger Track form-type
    [<sgth-ck>]     // Segment track header
    <lsgl-list>     // List of Segment Lists
)

    // <sgth-ck>
    'sgth'
    (
        <DMUS_IO_SEGMENT_TRACK_HEADER>
    )

    // <lsgl-list>
    LIST
    (
        'lsgl'          // Array of segments
        <lseg-list>...  // Each segment is encapsulated in a list (that way it can still be riff parsed.)
    )

        // <lseg-list>
        LIST
        (
            'lseg'
            <sgih-ck>
            <DMRF-list>    // Link to a segment or style file.
            [<snam-ck>]    // Name field.  Used with DMUS_SEGMENTTRACKF_MOTIF flag.
        )

            // <sgih-ck>            // segment item header
            (
                <DMUS_IO_SEGMENT_ITEM_HEADER>  // Segment item header
            )

            // <snam-ck>
            (
                // Name, stored as NULL terminated string of WCHARs
            )
*/      

/* Script track. */

/* RIFF ids: */
#define DMUS_FOURCC_SCRIPTTRACK_LIST                mmioFOURCC('s','c','r','t')
#define DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST          mmioFOURCC('s','c','r','l')
#define DMUS_FOURCC_SCRIPTTRACKEVENT_LIST           mmioFOURCC('s','c','r','e')
#define DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK    mmioFOURCC('s','c','r','h')
#define DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK      mmioFOURCC('s','c','r','n')

/* Flags for DMUS_IO_SCRIPTTRACK_TIMING
 */
#define DMUS_IO_SCRIPTTRACKF_PREPARE (1 << 0)        /* Fire event in advance of time stamp, at Prepare time.  This is the default because it leaves the script time to change the music happening at the target time. */
#define DMUS_IO_SCRIPTTRACKF_QUEUE   (1 << 1)        /* Fire event just before time stamp, at Queue time. */
#define DMUS_IO_SCRIPTTRACKF_ATTIME  (1 << 2)        /* Fire event right at the time stamp. */

typedef struct _DMUS_IO_SCRIPTTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* various bits (see DMUS_IO_SCRIPTTRACKF_*) */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_SCRIPTTRACK_EVENTHEADER;

/*
    // Script Track

    // <scrt-list>
    LIST
    (
        <scrl-list>       // List of script events
    )

        // <scrl-list>
        LIST
        (
            <scre-list>...    // Array of event descriptions
        )

            // <scre-list>
            LIST
            (
                <scrh-ck>         // Event header chunk
                <DMRF>
                <scrn-ck>         // Routine name
            )

                'scrh'
                (
                    <DMUS_IO_SCRIPTTRACK_EVENTHEADER>
                )

                'scrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Lyrics/Notification track. */

/* RIFF ids: */
#define DMUS_FOURCC_LYRICSTRACK_LIST                mmioFOURCC('l','y','r','t')
#define DMUS_FOURCC_LYRICSTRACKEVENTS_LIST          mmioFOURCC('l','y','r','l')
#define DMUS_FOURCC_LYRICSTRACKEVENT_LIST           mmioFOURCC('l','y','r','e')
#define DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK    mmioFOURCC('l','y','r','h')
#define DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK      mmioFOURCC('l','y','r','n')

typedef struct _DMUS_IO_LYRICSTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* Reserved leave as 0. */
    DWORD dwTimingFlags;        /* Combination DMUS_PMSGF_TOOL_* flags.  Determines the precise timing of when the notification happens. Invalid with the flag DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, or DMUS_PMSGF_LOCKTOREFTIME. */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_LYRICSTRACK_EVENTHEADER;

/*
    // Lyrics/Notification Track

    // <lyrt-list>
    LIST
    (
        <lyrl-list>       // List of notification events
    )

        // <lyrl-list>
        LIST
        (
            <lyre-list>...    // Array of event descriptions
        )

            // <lyre-list>
            LIST
            (
                <lyrh-ck>         // Event header chunk
                <lyrn-ck>         // Notification text
            )

                'lyrh'
                (
                    <DMUS_IO_LYRICSTRACK_EVENTHEADER>
                )

                'lyrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Parameter control track */

/* RIFF ids: */
#define DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST            mmioFOURCC('p','r','m','t')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST           mmioFOURCC('p','r','o','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK          mmioFOURCC('p','r','o','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST            mmioFOURCC('p','r','p','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK           mmioFOURCC('p','r','p','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK          mmioFOURCC('p','r','c','c')

typedef struct _DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    GUID guidTimeFormat;        /* Time format to set the object to.  Must be GUID_TIME_REFERNCE or GUID_TIME_MUSIC from medparam.h. */
    /* Path for finding the object. These fields correspond to the first five parameters of IDirectMusicSegmentState::GetObjectInPath. */
    DWORD dwPChannel;
    DWORD dwStage;
    DWORD dwBuffer;
    GUID guidObject;
    DWORD dwIndex;
} DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    DWORD dwIndex;              /* Index number of the parameter on the object */
} DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_CURVEINFO
{
    MUSIC_TIME  mtStartTime;
    MUSIC_TIME  mtEndTime;
    float       fltStartValue;
    float       fltEndValue;
    DWORD       dwCurveType;   /* One of the items from the MP_CURVE_TYPE enum in medparam.h */
    DWORD       dwFlags;       /* A combination of the MPF_ENVLP_* constants in medparam.h */
} DMUS_IO_PARAMCONTROLTRACK_CURVEINFO;

/*
    // <prmt-list>
    LIST
    (
        <prol-list>...   // one for each object
    )

        // <prol-list>
        LIST
        (
            <proh-ck>       // object header chunk
            <prpl-list>...  // one for each parameter
        )

            // <proh-ck>
            proh
            (
                <DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER>
            )

            // <prpl-list>
            LIST
            (
                <prph-ck>       // parameter header chunk
                <prcc-ck>       // chunk containing an array of curves
            )

                // <prph-ck>
                prph
                (
                    <DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER>
                )

                // <prcc-ck>
                prcc
                (
                    // sizeof DMUS_IO_PARAMCONTROLTRACK_CURVEINFO:DWORD
                    <DMUS_IO_PARAMCONTROLTRACK_CURVEINFO>... // curves, sorted in order of mtTime
                )
*/

/* Melody formulation track */
/* Note: Melody formulation file format is not supported in DX8. */

typedef DMUS_CONNECTION_RULE DMUS_IO_CONNECTION_RULE; /* defined in dmusici.h */

typedef DMUS_MELODY_FRAGMENT DMUS_IO_MELODY_FRAGMENT; /* defined in dmusici.h */

#define DMUS_FOURCC_MELODYFORM_TRACK_LIST     mmioFOURCC( 'm', 'f', 'r', 'm' )
#define DMUS_FOURCC_MELODYFORM_HEADER_CHUNK   mmioFOURCC( 'm', 'l', 'f', 'h' )
#define DMUS_FOURCC_MELODYFORM_BODY_CHUNK     mmioFOURCC( 'm', 'l', 'f', 'b' )

typedef struct _DMUS_IO_MELFORM
{
    DWORD        dwPlaymode;       /* NOT CURRENTLY USED - MUST BE 0 */   
} DMUS_IO_MELFORM;


/*
    // <mfrm-list>
    LIST
    (
        'mfrm'
        <mlfh-ck>       // Melody formulation header chunk
        <mlfb-ck>       // Melody formulation body chunk
    )

    // <mlfb-ck>
    'mlfb'
    (
        <DMUS_IO_MELFORM>
    )

  // <mlfb-ck>
    'mlfb'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )

*/

#if (DIRECTSOUND_VERSION >= 0x0800)

/* DirectSoundBufferConfig FX Map */

/* RIFF ids: */

#define DMUS_FOURCC_DSBC_FORM       mmioFOURCC('D','S','B','C')
#define DMUS_FOURCC_DSBD_CHUNK      mmioFOURCC('d','s','b','d')
#define DMUS_FOURCC_BSID_CHUNK      mmioFOURCC('b','s','i','d')
#define DMUS_FOURCC_DS3D_CHUNK      mmioFOURCC('d','s','3','d')
#define DMUS_FOURCC_DSBC_LIST       mmioFOURCC('f','x','l','s')
#define DMUS_FOURCC_DSFX_FORM       mmioFOURCC('D','S','F','X')
#define DMUS_FOURCC_DSFX_CHUNK      mmioFOURCC('f','x','h','r')
#define DMUS_FOURCC_DSFX_DATA       mmioFOURCC('d','a','t','a')

/* io structures */

typedef struct _DSOUND_IO_DSBUFFERDESC
{
    DWORD dwFlags;        /* DirectSound buffer creation flags */
    WORD nChannels;       /* No. of channels (rest of buffer format is determined by owning sink) */
    LONG lVolume;         /* Initial pan; only used if CTRLVOLUME is specified */
    LONG lPan;            /* Initial pan; only used if CTRLPAN is specified */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DSBUFFERDESC;

typedef struct _DSOUND_IO_DSBUSID
{
    DWORD busid[1];       /* Array size determined from chunk size */
} DSOUND_IO_DSBUSID;

typedef struct _DSOUND_IO_3D
{
    GUID guid3DAlgorithm; /* GUID identifying the 3D algorithm to use (defined in dsound.h) */
    DS3DBUFFER ds3d;      /* Initial 3D parameters */
} DSOUND_IO_3D;

typedef struct _DSOUND_IO_DXDMO_HEADER
{
    DWORD dwEffectFlags;  /* Effect creation flags - equivalent to DSEFFECTDESC::dwFlags */
    GUID guidDSFXClass;   /* GUID identifying the effect to use - corresponds to a COM CLSID */
    GUID guidReserved;    /* Reserved - must be the null GUID */
    GUID guidSendBuffer;  /* GUID identifying the buffer to send to if this is a send effect */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DXDMO_HEADER;

typedef struct _DSOUND_IO_DXDMO_DATA
{
    DWORD data[1];      /* Array size determined by the DMO involved */
} DSOUND_IO_DXDMO_DATA;

/*
RIFF
(
    'DSBC'          // DirectSoundBufferConfig chunk
    [<guid-ck>]     // GUID identifier for this DirectSoundBufferConfig
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <dsbd-ck>       // DirectSound Buffer descriptor chunk
    [<bsid-ck>]     // Optional bus id array
    [<ds3d-ck>]     // Optional 3d Parameters
    [<fxls-list>]   // Optional list of FX descriptors
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    'vers'
    (
        <DMUS_IO_VERSION>
    )

    // <dsbd-ck>
    'dsbd'
    (
        <DSOUND_IO_DSBUFFERDESC>  // Creation parameters and initial settings for the buffer
    )

    // <bsid-ck>
    'bsid'
    (
        <DSOUND_IO_DSBUSID>  // The size of DSOUND_IO_DSBUSID is determined by the chunk size 
    )

    // <ds3d-ck>
    'ds3d'
    (
        <DSOUND_IO_3D>  // Initial 3D buffer parameters: position, etc.
    )

    // <fx-list>
    LIST
    (
        'fxls'          // Array of DMO creation parameter blocks
        <DSFX-form>...  // Each DMO is encapsulated in a RIFF chunk
    )

// <DSFX-form>          // DMOs can be embedded in a buffer configuration or stored as separate files
RIFF
(
    'DSFX'
    <fxhr-ck>           // FX header chunk
    [<data-ck>]         // FX initial settings chunk
)

    // <fxhr-ck>
    'fxhr'
    (
        <DSOUND_IO_DXDMO_HEADER>
    )

    // <data-ck>
    'data'
    (
        <DSOUND_IO_DXDMO_DATA>  // Opaque data block used by the DMO to load itself.
        // For our standard included DMOs, this is simply the structure accepted by
        // the DMO's SetAllParameters() method - e.g. struct DSFXChorus for Chorus.
    )
*/

#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools. This can also happen
 * if some content is missing. For example, if a segment uses a DLS collection that
 * is not in the loader's current search directory.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * Return value from IDirectMusicBand::Download() which indicates that
 * some of the instruments safely downloaded, but others failed. This usually
 * occurs when some instruments are on PChannels not supported by the performance
 * or port.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are 
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open. 
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format. 
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors. 
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not 
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final 
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port. 
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

/* DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT
 *
 * The track does not support clock time playback or getparam.
 */
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   MAKE_DMHRESULTERROR(0x0167)
 
/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
/* misspelling in previous versions of DirectX preserved for backward compatibility */
#define DMUS_E_CONNOT_CONVERT           DMUS_E_CANNOT_CONVERT

/* DMUS_E_DESCEND_CHUNK_FAIL
 * 
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)

/* DMUS_E_NOT_LOADED
 *
 * An attempt to use this object failed because it first needs to
 * be loaded.
 */
#define DMUS_E_NOT_LOADED               MAKE_DMHRESULTERROR(0x0211)

/* DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE
 *
 * The activeX scripting engine for the script's language is not compatible with
 * DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  MAKE_DMHRESULTERROR(0x0213)

/* DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE
 *
 * A varient was used that had a type that is not supported by DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    MAKE_DMHRESULTERROR(0x0214)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_CANTLOAD_OLEAUT32
 *
 * Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages
 * require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only
 * the DirectMusicScript language, which doesn't require oleaut32.dll can be used.
 */
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      MAKE_DMHRESULTERROR(0x0216)

/* DMUS_E_SCRIPT_LOADSCRIPT_ERROR
 *
 * An error occured while parsing a script loaded using LoadScript.  The script that
 * was loaded contains an error.
 */
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       MAKE_DMHRESULTERROR(0x0217)

/* DMUS_E_SCRIPT_INVALID_FILE
 *
 * The script file is invalid.
 */
#define DMUS_E_SCRIPT_INVALID_FILE           MAKE_DMHRESULTERROR(0x0218)

/* DMUS_E_INVALID_SCRIPTTRACK
 *
 * The file contains an invalid script track.
 */
#define DMUS_E_INVALID_SCRIPTTRACK           MAKE_DMHRESULTERROR(0x0219)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

/* DMUS_E_INVALID_SEGMENTTRIGGERTRACK
 *
 * The file contains an invalid segment trigger track.
 */
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   MAKE_DMHRESULTERROR(0x0220)

/* DMUS_E_INVALID_LYRICSTRACK
 *
 * The file contains an invalid lyrics track.
 */
#define DMUS_E_INVALID_LYRICSTRACK           MAKE_DMHRESULTERROR(0x0221)

/* DMUS_E_INVALID_PARAMCONTROLTRACK
 *
 * The file contains an invalid parameter control track.
 */
#define DMUS_E_INVALID_PARAMCONTROLTRACK     MAKE_DMHRESULTERROR(0x0222)

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_AUDIOPATHS_NOT_VALID
 *
 * The Performance has set up some PChannels using the AssignPChannel command, which 
 * makes it not capable of supporting audio paths.
 */
#define DMUS_E_AUDIOPATHS_NOT_VALID     MAKE_DMHRESULTERROR(0x0226)

/* DMUS_E_AUDIOPATHS_IN_USE
 *
 * This is the inverse of the previous error. 
 * The Performance has set up some audio paths, which makes is incompatible
 * with the calls to allocate pchannels, etc. 
 */
#define DMUS_E_AUDIOPATHS_IN_USE     MAKE_DMHRESULTERROR(0x0227)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

/* DMUS_E_AUDIOPATH_INACTIVE
 *
 * An audiopath is inactive, perhaps because closedown was called.
 */
#define DMUS_E_AUDIOPATH_INACTIVE     MAKE_DMHRESULTERROR(0x0229)

/* DMUS_E_AUDIOPATH_NOBUFFER
 *
 * An audiopath failed to create because a requested buffer could not be created.
 */
#define DMUS_E_AUDIOPATH_NOBUFFER     MAKE_DMHRESULTERROR(0x022A)

/* DMUS_E_AUDIOPATH_NOPORT
 *
 * An audiopath could not be used for playback because it lacked port assignments.
 */
#define DMUS_E_AUDIOPATH_NOPORT     MAKE_DMHRESULTERROR(0x022B)

/* DMUS_E_NO_AUDIOPATH
 *
 * Attempt was made to play segment in audiopath mode and there was no audiopath.
 */
#define DMUS_E_NO_AUDIOPATH     MAKE_DMHRESULTERROR(0x022C)

/* DMUS_E_INVALIDCHUNK
 *
 * Invalid data was found in a RIFF file chunk.
 */
#define DMUS_E_INVALIDCHUNK     MAKE_DMHRESULTERROR(0x022D)

/* DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER
 *
 * Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.
 */
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     MAKE_DMHRESULTERROR(0x022E)

/* DMUS_E_INVALID_CONTAINER_OBJECT
 *
 * The file does not contain a valid container object.
 */
#define DMUS_E_INVALID_CONTAINER_OBJECT    MAKE_DMHRESULTERROR(0x022F)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmusici.h ===
/************************************************************************
*                                                                       *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include <dmusicc.h>
/* plugin (track and tool) interfaces.  This #include will eventually go away. */
#include <dmplugin.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

#define MT_MIN          0x80000000  /* Minimum music time value. */
#define MT_MAX          0x7FFFFFFF  /* Maximum music time value. */

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusicTrack;
interface IDirectMusicPerformance;
interface IDirectMusicPerformance8;
interface IDirectMusicTool;
interface IDirectMusicSegment;
interface IDirectMusicSegment8;
interface IDirectMusicSegmentState;
interface IDirectMusicSegmentState8;
interface IDirectMusicGraph;
interface IDirectMusicBuffer;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicBand;
interface IDirectMusicChordMap;
interface IDirectMusicLoader;
interface IDirectMusicLoader8;
interface IDirectMusicScript;
interface IDirectMusicObject;
interface IDirectMusicStyle8;
interface IDirectMusicPatternTrack;
interface IDirectMusicContainer;
interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicSong;
interface IDirectMusicAudioPath;
#ifndef __cplusplus 
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicPerformance8 IDirectMusicPerformance8;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegment8 IDirectMusicSegment8;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicSegmentState8 IDirectMusicSegmentState8;
typedef interface IDirectMusicGraph IDirectMusicGraph;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicChordMap IDirectMusicChordMap;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicLoader8 IDirectMusicLoader8;
typedef interface IDirectMusicScript IDirectMusicScript;
typedef interface IDirectMusicStyle8 IDirectMusicStyle8;
typedef interface IDirectMusicPatternTrack IDirectMusicPatternTrack;
typedef interface IDirectMusicContainer IDirectMusicContainer;
typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicSong IDirectMusicSong;
typedef interface IDirectMusicAudioPath IDirectMusicAudioPath;
#endif

typedef enum enumDMUS_STYLET_TYPES
{
    DMUS_STYLET_PATTERN         = 0,
    DMUS_STYLET_MOTIF           = 1,
    DMUS_STYLET_FRAGMENT        = 2,
} DMUS_STYLET_TYPES;


typedef enum enumDMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_VALID_START_BEAT  = 0x80,   /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any beat. */
    DMUS_COMPOSEF_VALID_START_GRID  = 0x100,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any grid. */
    DMUS_COMPOSEF_VALID_START_TICK  = 0x200,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur any time. */
    DMUS_COMPOSEF_SEGMENTEND        = 0x400,  /* Play the transition at the end of the current segment. */
    DMUS_COMPOSEF_MARKER            = 0x800,  /* Play the transition at the next marker in the current segment. */
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000,
    DMUS_COMPOSEF_ENTIRE_TRANSITION = 0x4000,  /* play the entire transition pattern */
    DMUS_COMPOSEF_1BAR_TRANSITION   = 0x8000,  /* play one bar of the transition pattern */
    DMUS_COMPOSEF_ENTIRE_ADDITION   = 0x10000, /* play the additional pattern in its entirety */
    DMUS_COMPOSEF_1BAR_ADDITION     = 0x20000,  /* play one bar of the additional pattern */
    DMUS_COMPOSEF_VALID_START_MEASURE = 0x40000, /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any bar. */
    DMUS_COMPOSEF_DEFAULT           = 0x80000,  /* Use segment's default boundary */
    DMUS_COMPOSEF_NOINVALIDATE      = 0x100000,  /* Play without invalidating the currently playing segment(s) */
    DMUS_COMPOSEF_USE_AUDIOPATH     = 0x200000   /* Uses the audio paths that are embedded in the segments */
}   DMUS_COMPOSEF_FLAGS;

#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSGF_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

#define DMUS_PCHANNEL_BROADCAST_PERFORMANCE	0xFFFFFFFF  /* PMsg is sent on all PChannels of the performance. */
#define DMUS_PCHANNEL_BROADCAST_AUDIOPATH   0xFFFFFFFE  /* PMsg is sent on all PChannels of the audio path. */
#define DMUS_PCHANNEL_BROADCAST_SEGMENT	    0xFFFFFFFD  /* PMsg is sent on all PChannels of the segment. */
#define DMUS_PCHANNEL_BROADCAST_GROUPS  	0xFFFFFFFC  /* A duplicate PMsg is for each Channels Groups in the performance. */

/*  The DMUS_PATH constants are used in conjunction with GetObjectInPath to find a requested
    interface at a particular stage in the audio path. 
*/
#define DMUS_PATH_SEGMENT          0x1000      /* Get the segment itself (from a segment state.) */
#define DMUS_PATH_SEGMENT_TRACK    0x1100      /* Look in Track List of Segment. */
#define DMUS_PATH_SEGMENT_GRAPH    0x1200      /* Get the segment's tool graph. */
#define DMUS_PATH_SEGMENT_TOOL     0x1300      /* Look in Tool Graph of Segment. */
#define DMUS_PATH_AUDIOPATH        0x2000      /* Get the audiopath itself (from a segment state.) */
#define DMUS_PATH_AUDIOPATH_GRAPH  0x2200      /* Get the audiopath's tool graph. */
#define DMUS_PATH_AUDIOPATH_TOOL   0x2300      /* Look in Tool Graph of Audio Path. */
#define DMUS_PATH_PERFORMANCE      0x3000      /* Access the performance. */
#define DMUS_PATH_PERFORMANCE_GRAPH 0x3200     /* Get the performance's tool graph. */
#define DMUS_PATH_PERFORMANCE_TOOL 0x3300      /* Look in Tool Graph of Performance. */
#define DMUS_PATH_PORT             0x4000      /* Access the synth. */
#define DMUS_PATH_BUFFER           0x6000      /* Look in DirectSoundBuffer. */
#define DMUS_PATH_BUFFER_DMO       0x6100      /* Access a DMO in the buffer. */
#define DMUS_PATH_MIXIN_BUFFER     0x7000      /* Look in a global mixin buffer. */ 
#define DMUS_PATH_MIXIN_BUFFER_DMO 0x7100      /* Access a DMO in a global mixin buffer. */ 
#define DMUS_PATH_PRIMARY_BUFFER   0x8000      /* Access the primary buffer. */ 

/*  To ignore PChannels when calling GetObjectInPath(), use the DMUS_PCHANNEL_ALL constant. */
#define DMUS_PCHANNEL_ALL           0xFFFFFFFB      

/*  The DMUS_APATH types are used in conjunction with CreateStandardAudioPath to
    build default path types. _SHARED_ means the same buffer is shared across multiple
    instantiations of the audiopath type. _DYNAMIC_ means a unique buffer is created
    every time. 
*/

#define DMUS_APATH_SHARED_STEREOPLUSREVERB   1       /* A standard music set up with stereo outs and reverb. */
#define DMUS_APATH_DYNAMIC_3D                6       /* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer. Does not send to env reverb. */
#define DMUS_APATH_DYNAMIC_MONO              7       /* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define DMUS_APATH_DYNAMIC_STEREO            8       /* An audio path with two dynamic buses from the synth feeding to a dynamic stereo buffer. */

typedef struct _DMUS_AUDIOPARAMS
{
    DWORD   dwSize;             /* Size of this structure. */
    BOOL    fInitNow;           /* If true, the sink and synth are created immediately and results returned in this structure. */
    DWORD 	dwValidData;        /* Flags indicating which fields below are valid. */
    DWORD   dwFeatures;         /* Required DMUS_AUDIOF features. */
    DWORD   dwVoices;           /* Required number of voices. */
    DWORD   dwSampleRate;       /* Sample rate of synths and sink. */
    CLSID   clsidDefaultSynth;  /* Class ID of default synthesizer. */
} DMUS_AUDIOPARAMS;

/* dwFeatures flags. These indicate which features are required for the audio environment. */
#define DMUS_AUDIOF_3D          0x1   /* Require 3D buffers. */
#define DMUS_AUDIOF_ENVIRON     0x2   /* Require environmental modeling. */
#define DMUS_AUDIOF_EAX         0x4   /* Require use of EAX effects. */
#define DMUS_AUDIOF_DMOS        0x8   /* Require use of additional DMOs. */
#define DMUS_AUDIOF_STREAMING   0x10  /* Require support for streaming waves. */
#define DMUS_AUDIOF_BUFFERS     0x20  /* Require support for multiple buffers (all above cases need this.) */
#define DMUS_AUDIOF_ALL         0x3F  /* Requires everything. */

/* dwValidData flags. These indicate which fields in DMUS_AUDIOPARAMS have been filled in. If fInitNow is set, these also return what was allocated. */
#define DMUS_AUDIOPARAMS_FEATURES       0x00000001
#define DMUS_AUDIOPARAMS_VOICES         0x00000002
#define DMUS_AUDIOPARAMS_SAMPLERATE     0x00000004
#define DMUS_AUDIOPARAMS_DEFAULTSYNTH   0x00000008

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 0x10,   /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 0x20,   /* if PMSG is being flushed */
    DMUS_PMSGF_LOCKTOREFTIME    = 0x40,   /* if rtTime can not be overriden by a tempo change. */
    DMUS_PMSGF_DX8              = 0x80    /* if the message has DX8 or later extensions. */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_WAVE             = 12,     /* Carries control information for playing a wave. */
    DMUS_PMSGT_LYRIC            = 13,     /* Lyric message from lyric track. */
    DMUS_PMSGT_SCRIPTLYRIC      = 14,     /* Lyric message sent by a script with the Trace function. */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 1<<6,   /* 0x40 Time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 1<<7,   /* 0x80 Secondary segment */
    DMUS_SEGF_QUEUE             = 1<<8,   /* 0x100 Queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 1<<9,   /* 0x200 Play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* 0x400 Play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* 0x800 Play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* 0x1000 Play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* 0x2000 Play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* 0x4000 Use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15,  /* 0x8000 Play without invalidating the currently playing segment(s) */
    DMUS_SEGF_ALIGN             = 1<<16,  /* 0x10000 Align segment with requested boundary, but switch at first valid point */
    DMUS_SEGF_VALID_START_BEAT  = 1<<17,  /* 0x20000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any beat. */
    DMUS_SEGF_VALID_START_GRID  = 1<<18,  /* 0x40000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any grid. */
    DMUS_SEGF_VALID_START_TICK  = 1<<19,  /* 0x80000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur any time. */
    DMUS_SEGF_AUTOTRANSITION    = 1<<20,  /* 0x100000 Compose and play a transition segment, using either the transition template or transition embedded in song. */
    DMUS_SEGF_AFTERQUEUETIME    = 1<<21,  /* 0x200000 Make sure to play after the queue time. This is default for primary segments */
    DMUS_SEGF_AFTERLATENCYTIME  = 1<<22,  /* 0x400000 Make sure to play after the latency time. This is true for all segments, so this is a nop */
    DMUS_SEGF_SEGMENTEND        = 1<<23,  /* 0x800000 Play at the next end of segment. */
    DMUS_SEGF_MARKER            = 1<<24,  /* 0x1000000 Play at next marker in the primary segment. If there are no markers, default to any other resolution requests. */
    DMUS_SEGF_TIMESIG_ALWAYS    = 1<<25,  /* 0x2000000 Even if there is no primary segment, align start time with current time signature. */
    DMUS_SEGF_USE_AUDIOPATH     = 1<<26,  /* 0x4000000 Uses the audio path that is embedded in the segment or song. */
    DMUS_SEGF_VALID_START_MEASURE = 1<<27 /* 0x8000000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any bar. */
} DMUS_SEGF_FLAGS;

#define DMUS_SEG_REPEAT_INFINITE    0xFFFFFFFF  /* For IDirectMusicSegment::SetRepeat*/
#define DMUS_SEG_ALLTRACKS          0x80000000  /* For IDirectMusicSegment::SetParam() and SetTrackConfig() - selects all tracks instead on nth index. */
#define DMUS_SEG_ANYTRACK           0x80000000  /* For IDirectMusicSegment::GetParam() - checks each track until it finds one that returns data (not DMUS_E_NOT_FOUND.) */
                                                

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = DMUS_SEGF_AFTERPREPARETIME,
    DMUS_TIME_RESOLVE_AFTERQUEUETIME    = DMUS_SEGF_AFTERQUEUETIME,
    DMUS_TIME_RESOLVE_AFTERLATENCYTIME  = DMUS_SEGF_AFTERLATENCYTIME,
    DMUS_TIME_RESOLVE_GRID              = DMUS_SEGF_GRID,
    DMUS_TIME_RESOLVE_BEAT              = DMUS_SEGF_BEAT,
    DMUS_TIME_RESOLVE_MEASURE           = DMUS_SEGF_MEASURE,
    DMUS_TIME_RESOLVE_MARKER            = DMUS_SEGF_MARKER,
    DMUS_TIME_RESOLVE_SEGMENTEND        = DMUS_SEGF_SEGMENTEND,
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent inside the DMUS_CHORD_KEY.dwFlags parameter */
typedef enum enumDMUS_CHORDKEYF_FLAGS
{
    DMUS_CHORDKEYF_SILENT            = 1,      /* is the chord silent? */
} DMUS_CHORDKEYF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
    BYTE            bFlags;             /* Miscelaneous flags */
} DMUS_CHORD_KEY;

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTEF_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,              /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
    /* DX8 flags: */
    DMUS_NOTEF_NOINVALIDATE = 2,        /* Don't invalidate this note off. */
    DMUS_NOTEF_NOINVALIDATE_INSCALE = 4,/* Don't invalidate if still within the scale. */
    DMUS_NOTEF_NOINVALIDATE_INCHORD = 8,/* Don't invalidate if still within the chord. */
    DMUS_NOTEF_REGENERATE = 0x10,       /* Regenerate the note on an invalidate. */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/* These playmodes are new for dx8. */
/* In PedalpointChord, the key root is used and the notes only track the intervals in
   the chord. The chord root and scale intervals are completely ignored. This is useful
   for chordal lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINTCHORD   (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

/* For completeness, here's a mode that tries for pedalpointchord, but if it fails
   uses scale intervals
*/
#define DMUS_PLAYMODE_PEDALPOINTALWAYS  (DMUS_PLAYMODE_PEDALPOINT | DMUS_PLAYMODE_PEDALPOINTCHORD)


/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY


/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
    /* Following exists only under DX8 and on (check dwFlags for DMUS_PMSGF_DX8) */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to allow a flush or
                                        invalidation to reset to the reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, set when a flush or invalidation
                                        occurs within mtDuration + mtResetDuration */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* Curve reset and start from current value flags. */
    /* Following exists only under DX8 and on (check dwFlags for DMUS_PMSGF_DX8) */
    WORD            wParamType;      /* RPN or NRPN parameter number. */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,            /* When set, the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If not set, the curve stays
                                        permanently stuck at the new value. */
    DMUS_CURVE_START_FROM_CURRENT = 2/* Ignore Start, start the curve at the current value. 
                                        This only works for volume, expression, and pitchbend. */
} DMUS_CURVE_FLAGS;


#define DMUS_CURVE_RESET    1        

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03   /* Pitch bend curve. */
#define DMUS_CURVET_CCCURVE      0x04   /* Control change curve. */
#define DMUS_CURVET_MATCURVE     0x05   /* Mono aftertouch curve. */
#define DMUS_CURVET_PATCURVE     0x06   /* Poly aftertouch curve. */
#define DMUS_CURVET_RPNCURVE     0x07   /* RPN curve with curve type in wParamType. */
#define DMUS_CURVET_NRPNCURVE    0x08   /* NRPN curve with curve type in wParamType. */

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;



/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART       0
#define DMUS_NOTIFICATION_SEGEND         1
#define DMUS_NOTIFICATION_SEGALMOSTEND   2
#define DMUS_NOTIFICATION_SEGLOOP        3
#define DMUS_NOTIFICATION_SEGABORT       4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED   0
#define DMUS_NOTIFICATION_MUSICSTOPPED   1
#define DMUS_NOTIFICATION_MUSICALMOSTEND 2
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT    0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD          0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE         0
#define DMUS_NOTIFICATION_EMBELLISHMENT  1
/* The following corresponds to GUID_NOTIFICATION_RECOMPOSE */
#define DMUS_NOTIFICATION_RECOMPOSE          0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* DMUS_WAVE_PMSG */
typedef struct _DMUS_WAVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    REFERENCE_TIME rtStartOffset;   /* How far into the wave to start, in reference time units only. */
    REFERENCE_TIME rtDuration;      /* Duration of the wave, in either reference time or music time. */  
    long    lOffset;                /* Offset from actual time to logical time, in music or ref time. */
    long    lVolume;		        /* Initial volume, in 100ths of a dB. */
    long    lPitch;			        /* Initial pitch, in 100ths of a semitone. */
    BYTE    bFlags;                 /* Flags, including DMUS_WAVEF_OFF... */
} DMUS_WAVE_PMSG;

#define DMUS_WAVEF_OFF           1       /* If wave is playing and this is the off message. */
#define DMUS_WAVEF_STREAMING     2       /* If wave is streaming. */
#define DMUS_WAVEF_NOINVALIDATE  4       /* Don't invalidate this wave. */

/* DMUS_LYRIC_PMSG */
typedef struct _DMUS_LYRIC_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    WCHAR    wszString[1];      /* null-terminated Unicode lyric string (structure is actually larger than size 1) */
} DMUS_LYRIC_PMSG;

#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH

typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

typedef struct _DMUS_VALID_START_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal start 
                                               point after (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_VALID_START_PARAM;

typedef struct _DMUS_PLAY_MARKER_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal segment play 
                                               marker before (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_PLAY_MARKER_PARAM;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
    IStream *      pStream;                /* Stream with data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */
#define DMUS_OBJ_STREAM         (1 << 11)    /* Object is stored in pStream. */

/*      The DMUS_SCRIPT_ERRORINFO structure describes an error that occurred in a script.
        It is returned by methods in IDirectMusicScript. */
typedef struct _DMUS_SCRIPT_ERRORINFO
{
    DWORD dwSize; /* Size of this structure. */
    HRESULT hr;
    ULONG ulLineNumber;
    LONG ichCharPosition;
    WCHAR wszSourceFile[DMUS_MAX_FILENAME];
    WCHAR wszSourceComponent[DMUS_MAX_FILENAME];
    WCHAR wszDescription[DMUS_MAX_FILENAME];
    WCHAR wszSourceLineText[DMUS_MAX_FILENAME];
} DMUS_SCRIPT_ERRORINFO;

/*  Track configuration flags, used with IDirectMusicSegment8::SetTrackConfig() */

#define DMUS_TRACKCONFIG_OVERRIDE_ALL           1	  /* This track should get parameters from this segment before controlling and primary tracks. */
#define DMUS_TRACKCONFIG_OVERRIDE_PRIMARY       2	  /* This track should get parameters from this segment before the primary segment tracks. */
#define DMUS_TRACKCONFIG_FALLBACK               4  	  /* This track should get parameters from this segment if the primary and controlling segments don't succeed. */
#define DMUS_TRACKCONFIG_CONTROL_ENABLED        8     /* GetParam() enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_ENABLED           0x10  /* Play() enabled for this track. */
#define DMUS_TRACKCONFIG_NOTIFICATION_ENABLED	0x20  /* Notifications enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_CLOCKTIME         0x40  /* This track plays in clock time, not music time. */
#define DMUS_TRACKCONFIG_PLAY_COMPOSE 	        0x80  /* This track should regenerate data each time it starts playing. */
#define DMUS_TRACKCONFIG_LOOP_COMPOSE           0x100 /* This track should regenerate data each time it repeats. */
#define DMUS_TRACKCONFIG_COMPOSING              0x200 /* This track is used to compose other tracks. */
#define DMUS_TRACKCONFIG_CONTROL_PLAY           0x10000 /* This track, when played in a controlling segment, overrides playback of primary segment tracks. */
#define DMUS_TRACKCONFIG_CONTROL_NOTIFICATION   0x20000 /* This track, when played in a controlling segment, overrides notification of primary segment tracks. */
/* Additional track config flags for composing transitions */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART    0x400  /* Get track info from start of From segment */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT  0x800  /* Get track info from current place in From segment */
#define DMUS_TRACKCONFIG_TRANS1_TOSEGSTART      0x1000 /* Get track info from start of To segment */
#define DMUS_TRACKCONFIG_DEFAULT    (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)

/* #defines for melody fragments */
/* Note: Melody formulation is not supported in DX8. */

#define DMUS_MAX_FRAGMENTLABEL 20

#define DMUS_FRAGMENTF_USE_REPEAT      0x1
#define DMUS_FRAGMENTF_REJECT_REPEAT   (0x1 << 1)
#define DMUS_FRAGMENTF_USE_LABEL       (0x1 << 2)

#define DMUS_CONNECTIONF_INTERVALS     (0x1 << 1) /* Use transition intervals */
#define DMUS_CONNECTIONF_OVERLAP       (0x1 << 2) /* Use overlapping notes for transitions */

/* Get/SetParam structs for commands */
/* PARAM structures, used by GetParam() and SetParam() */
typedef struct _DMUS_COMMAND_PARAM
{
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM;

typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM_2;

/* Get/SetParam structs for melody fragments */
/* Note: Melody formulation is not supported in DX8. */
typedef struct _DMUS_CONNECTION_RULE
{
    DWORD       dwFlags;      /* DMUS_CONNECTIONF_ flags */
    DWORD       dwIntervals;  /* Legal transition intervals (first 24 bits; two-octave range) */
} DMUS_CONNECTION_RULE;

typedef struct _DMUS_MELODY_FRAGMENT
{
    MUSIC_TIME  mtTime;
    DWORD       dwID;                   /* This fragment's ID */
    WCHAR       wszVariationLabel[DMUS_MAX_FRAGMENTLABEL]; /* Each style translates this into a set of variations (held in part ref) */
    DWORD       dwVariationFlags;       /* A set of variations */
    DWORD       dwRepeatFragmentID;     /* ID of a fragment to repeat */
    DWORD       dwFragmentFlags;        /* DMUS_FRAGMENTF_ flags */
    DWORD       dwPlayModeFlags;        /* NOT CURRENTLY USED - MUST BE 0 */
    DWORD       dwTransposeIntervals;   /* Legal transposition intervals (first 24 bits; two-octave range) */
    DMUS_COMMAND_PARAM      Command;
    DMUS_CONNECTION_RULE    ConnectionArc;
} DMUS_MELODY_FRAGMENT;

typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;

#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicBand */
#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicBand */
    STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
    STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

typedef IDirectMusicBand IDirectMusicBand8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicObject */
#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

typedef IDirectMusicObject IDirectMusicObject8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};                                  

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader8
DECLARE_INTERFACE_(IDirectMusicLoader8, IDirectMusicLoader)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;

    /* IDirectMusicLoader8 */
    STDMETHOD_(void, CollectGarbage)                (THIS) PURE;
    STDMETHOD(ReleaseObjectByUnknown)               (THIS_ IUnknown *pObject) PURE;
    STDMETHOD(LoadObjectFromFile)                   (THIS_ REFGUID rguidClassID, 
                                                           REFIID iidInterfaceID, 
                                                           WCHAR *pwzFilePath, 
                                                           void ** ppObject) PURE;
};

/*  Stream object supports IDirectMusicGetLoader interface to access loader while file parsing. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

typedef IDirectMusicGetLoader IDirectMusicGetLoader8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment8
DECLARE_INTERFACE_(IDirectMusicSegment8, IDirectMusicSegment)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
    /*  IDirectMusicSegment8 */
    STDMETHOD(SetTrackConfig)           (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
                                               DWORD dwGroupBits,           /* Group bits. */
                                               DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
                                               DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
                                               DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
    STDMETHOD(GetAudioPathConfig)       (THIS_ IUnknown ** ppAudioPathConfig) PURE;
    STDMETHOD(Compose)                  (THIS_ MUSIC_TIME mtTime,
                                               IDirectMusicSegment* pFromSegment,
                                               IDirectMusicSegment* pToSegment,
                                               IDirectMusicSegment** ppComposedSegment) PURE;
    STDMETHOD(Download)                 (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(Unload)                   (THIS_ IUnknown *pAudioPath) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState8
DECLARE_INTERFACE_(IDirectMusicSegmentState8, IDirectMusicSegmentState)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;

    /* IDirectMusicSegmentState8 */
    STDMETHOD(SetTrackConfig)       (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
                                           DWORD dwGroupBits,           /* Group bits. */
                                           DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
                                           DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
                                           DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicAudioPath */
#undef  INTERFACE
#define INTERFACE  IDirectMusicAudioPath
DECLARE_INTERFACE_(IDirectMusicAudioPath, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicAudioPath */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(Activate)             (THIS_ BOOL fActivate) PURE;/* True to activate, False to deactivate. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(ConvertPChannel)      (THIS_ DWORD dwPChannelIn,   /* Pchannel of source. */
                                           DWORD *pdwPChannelOut) PURE; /* Equivalent pchannel on performance. */
};

typedef IDirectMusicAudioPath IDirectMusicAudioPath8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;                                        
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance8
DECLARE_INTERFACE_(IDirectMusicPerformance8, IDirectMusicPerformance)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;  
    /*  IDirectMusicPerformance8 */
    STDMETHOD(InitAudio)            (THIS_ IDirectMusic** ppDirectMusic,            /* Optional DMusic pointer. */
                                           IDirectSound** ppDirectSound,            /* Optional DSound pointer. */
                                           HWND hWnd,                               /* HWND for DSound. */
                                           DWORD dwDefaultPathType,                 /* Requested default audio path type, also optional. */
                                           DWORD dwPChannelCount,                   /* Number of PChannels, if default audio path to be created. */
                                           DWORD dwFlags,                           /* DMUS_AUDIOF flags, if no pParams structure. */
                                           DMUS_AUDIOPARAMS *pParams) PURE;         /* Optional initialization structure, defining required voices, buffers, etc. */
    STDMETHOD(PlaySegmentEx)        (THIS_ IUnknown* pSource,                       /* Segment to play. Alternately, could be an IDirectMusicSong (not supported in DX8.) */
                                           WCHAR *pwzSegmentName,                   /* If song, which segment in the song (not supported in DX8.) */
                                           IUnknown* pTransition,                   /* Optional template segment to compose transition with. */
                                           DWORD dwFlags,                           /* DMUS_SEGF_ flags. */ 
                                           __int64 i64StartTime,                    /* Time to start playback. */
                                           IDirectMusicSegmentState** ppSegmentState, /* Returned Segment State. */
                                           IUnknown *pFrom,                         /* Optional segmentstate or audiopath to replace. */
                                           IUnknown *pAudioPath) PURE;              /* Optional audioPath to play on. */
    STDMETHOD(StopEx)               (THIS_ IUnknown *pObjectToStop,                 /* Segstate, AudioPath, Segment, or Song. */ 
                                           __int64 i64StopTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(ClonePMsg)            (THIS_ DMUS_PMSG* pSourcePMSG,
                                           DMUS_PMSG** ppCopyPMSG) PURE;
    STDMETHOD(CreateAudioPath)      (THIS_ IUnknown *pSourceConfig,                 /* Source configuration, from AudioPathConfig file. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */                                           
    STDMETHOD(CreateStandardAudioPath)(THIS_ DWORD dwType,                          /* Type of path to create. */
                                           DWORD dwPChannelCount,                   /* How many PChannels to allocate for it. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */
    STDMETHOD(SetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath *pAudioPath) PURE;
    STDMETHOD(GetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath **ppAudioPath) PURE;
    STDMETHOD(GetParamEx)           (THIS_ REFGUID rguidType,                       /* GetParam command ID. */
                                           DWORD dwTrackID,                         /* Virtual track ID of caller. */
                                           DWORD dwGroupBits,                       /* Group bits of caller. */
                                           DWORD dwIndex,                           /* Index to Nth parameter. */
                                           MUSIC_TIME mtTime,                       /* Time of requested parameter. */
                                           MUSIC_TIME* pmtNext,                     /* Returned delta to next parameter. */
                                           void* pParam) PURE;                      /* Data structure to fill with parameter. */
};



/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

typedef IDirectMusicGraph IDirectMusicGraph8;


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle8
DECLARE_INTERFACE_(IDirectMusicStyle8, IDirectMusicStyle)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;

    /*  IDirectMusicStyle8 */
    STDMETHOD(EnumPattern)            (THIS_ DWORD dwIndex, 
                                             DWORD dwPatternType,
                                             WCHAR* pwszName) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicChordMap */
#undef  INTERFACE
#define INTERFACE  IDirectMusicChordMap
DECLARE_INTERFACE_(IDirectMusicChordMap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicChordMap */
    STDMETHOD(GetScale)             (THIS_ DWORD* pdwScale) PURE;
};

typedef IDirectMusicChordMap IDirectMusicChordMap8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicComposer */
    STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   WORD wActivity, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(ComposeSegmentFromShape)      (THIS_ IDirectMusicStyle* pStyle, 
                                                   WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   WORD wActivity, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment ) PURE;
    STDMETHOD(ComposeTransition)            (THIS_ IDirectMusicSegment* pFromSeg, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   MUSIC_TIME mtTime, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg) PURE;
    STDMETHOD(AutoTransition)               (THIS_ IDirectMusicPerformance* pPerformance, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg, 
                                                   IDirectMusicSegmentState** ppToSegState, 
                                                   IDirectMusicSegmentState** ppTransSegState) PURE;
    STDMETHOD(ComposeTemplateFromShape)     (THIS_ WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   WORD wEndLength, 
                                                   IDirectMusicSegment** ppTemplate) PURE;
    STDMETHOD(ChangeChordMap)            (THIS_ IDirectMusicSegment* pSegment, 
                                                   BOOL fTrackScale, 
                                                   IDirectMusicChordMap* pChordMap) PURE;
};

typedef IDirectMusicComposer IDirectMusicComposer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicPatternTrack */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPatternTrack
DECLARE_INTERFACE_(IDirectMusicPatternTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicPatternTrack */
    STDMETHOD(CreateSegment)             (THIS_ IDirectMusicStyle* pStyle,
                                                IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetVariation)              (THIS_ IDirectMusicSegmentState* pSegState,
                                                DWORD dwVariationFlags,
                                                DWORD dwPart) PURE;
    STDMETHOD(SetPatternByName)          (THIS_ IDirectMusicSegmentState* pSegState,
                                                WCHAR* wszName,
                                                IDirectMusicStyle* pStyle,
                                                DWORD dwPatternType,
                                                DWORD* pdwLength) PURE;
};

typedef IDirectMusicPatternTrack IDirectMusicPatternTrack8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicScript */

#undef  INTERFACE
#define INTERFACE  IDirectMusicScript
DECLARE_INTERFACE_(IDirectMusicScript, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicScript */
    STDMETHOD(Init)                     (THIS_ IDirectMusicPerformance *pPerformance,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(CallRoutine)              (THIS_ WCHAR *pwszRoutineName,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableVariant)       (THIS_ WCHAR *pwszVariableName,
                                               VARIANT varValue,
                                               BOOL fSetRef,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableVariant)       (THIS_ WCHAR *pwszVariableName,
                                               VARIANT *pvarValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableNumber)        (THIS_ WCHAR *pwszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableNumber)        (THIS_ WCHAR *pwszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableObject)        (THIS_ WCHAR *pwszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableObject)        (THIS_ WCHAR *pwszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(EnumRoutine)              (THIS_ DWORD dwIndex, 
                                               WCHAR *pwszName) PURE;
    STDMETHOD(EnumVariable)             (THIS_ DWORD dwIndex, 
                                               WCHAR *pwszName) PURE;
};

typedef IDirectMusicScript IDirectMusicScript8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicContainer */

#undef  INTERFACE
#define INTERFACE  IDirectMusicContainer
DECLARE_INTERFACE_(IDirectMusicContainer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicContainer */
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc,
                                           WCHAR *pwszAlias) PURE;
};

typedef IDirectMusicContainer IDirectMusicContainer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSong */
/* Note: Songs are not supported in DX8. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSong
DECLARE_INTERFACE_(IDirectMusicSong, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSong */
    STDMETHOD(Compose)               (THIS) PURE;
    STDMETHOD(GetParam)              (THIS_ REFGUID rguidType, 
                                            DWORD dwGroupBits, 
                                            DWORD dwIndex, 
                                            MUSIC_TIME mtTime, 
                                            MUSIC_TIME* pmtNext, 
                                            void* pParam) PURE;
    STDMETHOD(GetSegment)            (THIS_ WCHAR *pwzName,                         /* Retrieve a specific segment by name. */
                                            IDirectMusicSegment **ppSegment) PURE;  /* Returned segment. */
    STDMETHOD(GetAudioPathConfig)    (THIS_ IUnknown ** ppAudioPathConfig) PURE;    /* Retrieve embedded audiopath configuration. */
    STDMETHOD(Download)              (THIS_ IUnknown *pAudioPath) PURE;             /* Download entire song to ports on performance or audiopath. */
    STDMETHOD(Unload)                (THIS_ IUnknown *pAudioPath) PURE;             /* Unload entire song from port on performance or audiopath. */
    STDMETHOD(EnumSegment)           (THIS_ DWORD dwIndex,                          /* Nth segment to retrieve. */
		                                    IDirectMusicSegment **ppSegment) PURE;  /* Pointer to segment. */
};

typedef IDirectMusicSong IDirectMusicSong8;

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/* New CLSID's for DX8 */
DEFINE_GUID(CLSID_DirectMusicPatternTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScript,0x810b5013, 0xe88d, 0x11d2, 0x8b, 0xc1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {810B5013-E88D-11d2-8BC1-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicContainer,0x9301e380, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(CLSID_DirectSoundWave,0x8a667154, 0xf9cb, 0x11d2, 0xad, 0x8a, 0x0, 0x60, 0xb0, 0x57, 0x5a, 0xbc);
/* Note: Songs are not supported in DX8. */
DEFINE_GUID(CLSID_DirectMusicSong, 0xaed5f0a5, 0xd972, 0x483d, 0xa3, 0x84, 0x64, 0x9d, 0xfe, 0xb9, 0xc1, 0x81);
DEFINE_GUID(CLSID_DirectMusicAudioPathConfig,0xee0b9ca0, 0xa81e, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_RECOMPOSE, 0xd348372b, 0x945b, 0x45ae, 0xa5, 0x22, 0x45, 0xf, 0x12, 0x5b, 0x84, 0xa5);

/* Track param type guids */
/* Use to get/set a DMUS_COMMAND_PARAM param in the Command track */
DEFINE_GUID(GUID_CommandParam,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_COMMAND_PARAM_2 param to be used as the command following all commands in
the Command track (this information can't be saved) */
DEFINE_GUID(GUID_CommandParamNext, 0x472afe7a, 0x281b, 0x11d3, 0x81, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get the next valid point in a segment at which it may start */
DEFINE_GUID(GUID_Valid_Start_Time,0x7f6b1760, 0x1fdb, 0x11d3, 0x82, 0x26, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Use to get the next point in the currently playing primary segment at which a new segment may start */
DEFINE_GUID(GUID_Play_Marker,0xd8761a41, 0x801a, 0x11d3, 0x9b, 0xd1, 0xda, 0xf7, 0xe1, 0xc3, 0xd8, 0x34);

/* Use to get (GetParam) or add (SetParam) bands in the Band track */
DEFINE_GUID(GUID_BandParam,0x2bb1938, 0xcb8b, 0x11d2, 0x8b, 0xb9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6);
typedef struct _DMUS_BAND_PARAM
{
    MUSIC_TIME  mtTimePhysical; /* Note: If this is a clock-time track, then this field is interpreted in the track's internal time format, which is the number of milliseconds after the beginning of playback. */
    IDirectMusicBand *pBand;
} DMUS_BAND_PARAM;

/* Obsolete -- doesn't distinguish physical and logical time.  Use GUID_BandParam instead. */
DEFINE_GUID(GUID_IDirectMusicBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicChordMap param in the ChordMap track */
DEFINE_GUID(GUID_IDirectMusicChordMap,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* These guids are used in IDirectMusicSegment::SetParam to tell the band track to perform various actions.
   Some of these guids (where noted) also apply to wave tracks.
 */
/* Download bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Unload bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Connect segment's bands to an IDirectMusicCollection */
DEFINE_GUID(GUID_ConnectToDLSCollection, 0x1db1ae6b, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);

/* Enable/disable autodownloading of bands/waves */
DEFINE_GUID(GUID_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Clear all bands */
DEFINE_GUID(GUID_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Set segment to manage all program changes, bank selects, etc. for simple playback of a standard MIDI file */
DEFINE_GUID(GUID_StandardMIDIFile, 0x6621075, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
/* For compatibility with beta releases... */
#define GUID_IgnoreBankSelectForGM 	GUID_StandardMIDIFile

/* Disable/enable param guids. Use these in SetParam calls to disable or enable sending
 * specific PMsg types.
 */
DEFINE_GUID(GUID_DisableTimeSig, 0x45fc707b, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTimeSig, 0x45fc707c, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_DisableTempo, 0x45fc707d, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTempo, 0x45fc707e, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* Used in SetParam calls for pattern-based tracks.  A nonzero value seeds the random number 
generator for variation selection; a value of zero reverts to the default behavior of 
getting the seed from the system clock.
*/
DEFINE_GUID(GUID_SeedVariations, 0x65b76fa5, 0xff37, 0x11d2, 0x81, 0x4e, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get/set melody fragments (pParam points to a DMUS_MELODY_FRAGMENT) */
/* Note: Melody formulation is not supported in DX8. */
DEFINE_GUID(GUID_MelodyFragment, 0xb291c7f2, 0xb616, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to clear all melody fragments */
/* Note: Melody formulation is not supported in DX8. */
DEFINE_GUID(GUID_Clear_All_MelodyFragments, 0x8509fee6, 0xb617, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get the variations currently in effect across PChannels */
DEFINE_GUID(GUID_Variations, 0x11f72cce, 0x26e6, 0x4ecd, 0xaf, 0x2e, 0xd6, 0x68, 0xe6, 0x67, 0x7, 0xd8);
typedef struct _DMUS_VARIATIONS_PARAM
{
    DWORD   dwPChannelsUsed; /* number of PChannels in use */
    DWORD*  padwPChannels;   /* array of PChannels in use */
    DWORD*  padwVariations;  /* array of variations in effect for each PChannel */
} DMUS_VARIATIONS_PARAM;

/* Download bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_DownloadToAudioPath,0x9f2c0341, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Unload bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_UnloadFromAudioPath,0x9f2c0342, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfAutoDownload, 0xfb09565b, 0x3631, 0x11d2, 0xbc, 0xb8, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* GUID to define default synth, placed in AudioPath configuration file. */
DEFINE_GUID(GUID_Synth_Default,0x26bb9432, 0x45fe, 0x48d3, 0xa3, 0x75, 0x24, 0x72, 0xc5, 0xe3, 0xe7, 0x86);

/* GUIDs to define default buffer configurations to place in AudioPath configuration file. */
DEFINE_GUID(GUID_Buffer_Reverb,0x186cc541, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_EnvReverb,0x186cc542, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Stereo,0x186cc545, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_3D_Dry,0x186cc546, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Mono,0x186cc547, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader, 0x2ffaaca2, 0x5dca, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicGetLoader,0x68a04844, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicObject,0xd2ac28b5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegment, 0xf96029a2, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xa3afdcc7, 0xd3ee, 0x11d1, 0xbc, 0x8d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicPerformance,0x7d43d03, 0x6523, 0x11d2, 0x87, 0x1d, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicGraph,0x2befc277, 0x5497, 0x11d2, 0xbc, 0xcb, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicStyle,0xd2ac28bd, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicChordMap,0xd2ac28be, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicComposer,0xd2ac28bf, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBand,0xd2ac28c0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface IDs, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusicPerformance2,0x6fc2cae0, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSegment2, 0xd38894d1, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Interface IDs for DX8 */
/* changed interfaces (GUID only) */
DEFINE_GUID(IID_IDirectMusicLoader8, 0x19e7c08c, 0xa44, 0x4e6a, 0xa1, 0x16, 0x59, 0x5a, 0x7c, 0xd5, 0xde, 0x8c);
DEFINE_GUID(IID_IDirectMusicPerformance8, 0x679c4137, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);
DEFINE_GUID(IID_IDirectMusicSegment8,0xc6784488, 0x41a3, 0x418f, 0xaa, 0x15, 0xb3, 0x50, 0x93, 0xba, 0x42, 0xd4);
DEFINE_GUID(IID_IDirectMusicSegmentState8, 0xa50e4730, 0xae4, 0x48a7, 0x98, 0x39, 0xbc, 0x4, 0xbf, 0xe0, 0x77, 0x72);
DEFINE_GUID(IID_IDirectMusicStyle8, 0xfd24ad8a, 0xa260, 0x453d, 0xbf, 0x50, 0x6f, 0x93, 0x84, 0xf7, 0x9, 0x85);
/* new interfaces (GUID + alias) */
DEFINE_GUID(IID_IDirectMusicPatternTrack, 0x51c22e10, 0xb49f, 0x46fc, 0xbe, 0xc2, 0xe6, 0x28, 0x8f, 0xb9, 0xed, 0xe6);
#define IID_IDirectMusicPatternTrack8 IID_IDirectMusicPatternTrack
DEFINE_GUID(IID_IDirectMusicScript, 0x2252373a, 0x5814, 0x489b, 0x82, 0x9, 0x31, 0xfe, 0xde, 0xba, 0xf1, 0x37); /* {2252373A-5814-489b-8209-31FEDEBAF137} */
#define IID_IDirectMusicScript8 IID_IDirectMusicScript
DEFINE_GUID(IID_IDirectMusicContainer, 0x9301e386, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
#define IID_IDirectMusicContainer8 IID_IDirectMusicContainer
/* Note: Songs are not supported in DX8. */
DEFINE_GUID(IID_IDirectMusicSong, 0xa862b2ec, 0x3676, 0x4982, 0x85, 0xa, 0x78, 0x42, 0x77, 0x5e, 0x1d, 0x86);
#define IID_IDirectMusicSong8 IID_IDirectMusicSong
DEFINE_GUID(IID_IDirectMusicAudioPath,0xc87631f5, 0x23be, 0x4986, 0x88, 0x36, 0x5, 0x83, 0x2f, 0xcc, 0x48, 0xf9);
#define IID_IDirectMusicAudioPath8 IID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
#define IID_IDirectMusicGetLoader8 IID_IDirectMusicGetLoader
#define IID_IDirectMusicChordMap8 IID_IDirectMusicChordMap
#define IID_IDirectMusicGraph8 IID_IDirectMusicGraph
#define IID_IDirectMusicBand8 IID_IDirectMusicBand
#define IID_IDirectMusicObject8 IID_IDirectMusicObject
#define IID_IDirectMusicComposer8 IID_IDirectMusicComposer


#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\domdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __DOMDID_H__
#define __DOMDID_H__
//;end_internal

//#define DISPID_DOM_BASE                 0x80010500

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_NODE                        (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME               (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE              (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE               (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM           (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE             (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES             (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD             (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD              (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING        (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING            (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES             (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE           (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD           (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD            (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD            (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES          (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC               (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE              (DISPID_DOM_NODE + 18)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_DOM_NODE + 0x20)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS)
#define DISPID_DOM_DOCUMENTFRAGMENT_TOP        (DISPID_DOM_DOCUMENTFRAGMENT + 2)

#define DISPID_DOM_DOCUMENT                        (DISPID_DOM_DOCUMENTFRAGMENT + 0x20)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENT + 0x20)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT_TOP                     (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT + 0x20)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_TOP                    (DISPID_DOM_DATA + 7)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA + 0x20)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_GETVALUE          (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE_TOP               (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE + 0x20)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT_TOP            (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT + 0x20)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI_TOP       (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI + 0x20)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE_TOP        (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE + 0x20)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION_TOP            (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION + 0x20)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY_TOP              (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY + 0x20)
    
#define DISPID_DOM_NODELIST            (DISPID_DOM_W3CWRAPPERS_TOP + 0x20)
#define DISPID_DOM_NODELIST_ITEM       (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH     (DISPID_DOM_NODELIST + 2)

#define DISPID_DOM_NAMEDNODEMAP                    (DISPID_DOM_NODELIST + 0x20)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM    (DISPID_DOM_NAMEDNODEMAP + 5)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_NAMEDNODEMAP + 0x20)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)

#define DISPID_DOM_TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\docobj.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Sep 24 19:23:57 1999
 */
/* Compiler settings for docobj.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __docobj_h__
#define __docobj_h__

/* Forward Declarations */ 

#ifndef __IOleDocument_FWD_DEFINED__
#define __IOleDocument_FWD_DEFINED__
typedef interface IOleDocument IOleDocument;
#endif 	/* __IOleDocument_FWD_DEFINED__ */


#ifndef __IOleDocumentSite_FWD_DEFINED__
#define __IOleDocumentSite_FWD_DEFINED__
typedef interface IOleDocumentSite IOleDocumentSite;
#endif 	/* __IOleDocumentSite_FWD_DEFINED__ */


#ifndef __IOleDocumentView_FWD_DEFINED__
#define __IOleDocumentView_FWD_DEFINED__
typedef interface IOleDocumentView IOleDocumentView;
#endif 	/* __IOleDocumentView_FWD_DEFINED__ */


#ifndef __IEnumOleDocumentViews_FWD_DEFINED__
#define __IEnumOleDocumentViews_FWD_DEFINED__
typedef interface IEnumOleDocumentViews IEnumOleDocumentViews;
#endif 	/* __IEnumOleDocumentViews_FWD_DEFINED__ */


#ifndef __IContinueCallback_FWD_DEFINED__
#define __IContinueCallback_FWD_DEFINED__
typedef interface IContinueCallback IContinueCallback;
#endif 	/* __IContinueCallback_FWD_DEFINED__ */


#ifndef __IPrint_FWD_DEFINED__
#define __IPrint_FWD_DEFINED__
typedef interface IPrint IPrint;
#endif 	/* __IPrint_FWD_DEFINED__ */


#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef interface IOleCommandTarget IOleCommandTarget;
#endif 	/* __IOleCommandTarget_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_docobj_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DocObj.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Document Object Interfaces.








////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPOLEDOCUMENT_DEFINED
#define _LPOLEDOCUMENT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_v0_0_s_ifspec;

#ifndef __IOleDocument_INTERFACE_DEFINED__
#define __IOleDocument_INTERFACE_DEFINED__

/* interface IOleDocument */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocument __RPC_FAR *LPOLEDOCUMENT;

typedef /* [public] */ 
enum __MIDL_IOleDocument_0001
    {	DOCMISC_CANCREATEMULTIPLEVIEWS	= 1,
	DOCMISC_SUPPORTCOMPLEXRECTANGLES	= 2,
	DOCMISC_CANTOPENEDIT	= 4,
	DOCMISC_NOFILESUPPORT	= 8
    }	DOCMISC;


EXTERN_C const IID IID_IOleDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc5-4e68-101b-a2bc-00aa00404770")
    IOleDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateView( 
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateView )( 
            IOleDocument __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocMiscStatus )( 
            IOleDocument __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumViews )( 
            IOleDocument __RPC_FAR * This,
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);
        
        END_INTERFACE
    } IOleDocumentVtbl;

    interface IOleDocument
    {
        CONST_VTBL struct IOleDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleDocument_CreateView(This,pIPSite,pstm,dwReserved,ppView)	\
    (This)->lpVtbl -> CreateView(This,pIPSite,pstm,dwReserved,ppView)

#define IOleDocument_GetDocMiscStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetDocMiscStatus(This,pdwStatus)

#define IOleDocument_EnumViews(This,ppEnum,ppView)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum,ppView)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocument_CreateView_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
    /* [unique][in] */ IStream __RPC_FAR *pstm,
    /* [in] */ DWORD dwReserved,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);


void __RPC_STUB IOleDocument_CreateView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocument_GetDocMiscStatus_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IOleDocument_GetDocMiscStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocument_EnumViews_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);


void __RPC_STUB IOleDocument_EnumViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleDocument_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0247 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTSITE_DEFINED
#define _LPOLEDOCUMENTSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0247_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0247_v0_0_s_ifspec;

#ifndef __IOleDocumentSite_INTERFACE_DEFINED__
#define __IOleDocumentSite_INTERFACE_DEFINED__

/* interface IOleDocumentSite */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocumentSite __RPC_FAR *LPOLEDOCUMENTSITE;


EXTERN_C const IID IID_IOleDocumentSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc7-4e68-101b-a2bc-00aa00404770")
    IOleDocumentSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ActivateMe( 
            /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocumentSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocumentSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocumentSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivateMe )( 
            IOleDocumentSite __RPC_FAR * This,
            /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate);
        
        END_INTERFACE
    } IOleDocumentSiteVtbl;

    interface IOleDocumentSite
    {
        CONST_VTBL struct IOleDocumentSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocumentSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleDocumentSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleDocumentSite_ActivateMe(This,pViewToActivate)	\
    (This)->lpVtbl -> ActivateMe(This,pViewToActivate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocumentSite_ActivateMe_Proxy( 
    IOleDocumentSite __RPC_FAR * This,
    /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate);


void __RPC_STUB IOleDocumentSite_ActivateMe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleDocumentSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0248 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTVIEW_DEFINED
#define _LPOLEDOCUMENTVIEW_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0248_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0248_v0_0_s_ifspec;

#ifndef __IOleDocumentView_INTERFACE_DEFINED__
#define __IOleDocumentView_INTERFACE_DEFINED__

/* interface IOleDocumentView */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocumentView __RPC_FAR *LPOLEDOCUMENTVIEW;


EXTERN_C const IID IID_IOleDocumentView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc6-4e68-101b-a2bc-00aa00404770")
    IOleDocumentView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite( 
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite( 
            /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ LPRECT prcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRect( 
            /* [out] */ LPRECT prcView) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRectComplex( 
            /* [unique][in] */ LPRECT prcView,
            /* [unique][in] */ LPRECT prcHScroll,
            /* [unique][in] */ LPRECT prcVScroll,
            /* [unique][in] */ LPRECT prcSizeBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ BOOL fUIActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseView( 
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( 
            /* [in] */ LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyViewState( 
            /* [in] */ LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocumentView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocumentView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInPlaceSite )( 
            IOleDocumentView __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInPlaceSite )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocument )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRect )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPRECT prcView);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRect )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ LPRECT prcView);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRectComplex )( 
            IOleDocumentView __RPC_FAR * This,
            /* [unique][in] */ LPRECT prcView,
            /* [unique][in] */ LPRECT prcHScroll,
            /* [unique][in] */ LPRECT prcVScroll,
            /* [unique][in] */ LPRECT prcSizeBox);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UIActivate )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ BOOL fUIActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IOleDocumentView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseView )( 
            IOleDocumentView __RPC_FAR * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveViewState )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyViewState )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew);
        
        END_INTERFACE
    } IOleDocumentViewVtbl;

    interface IOleDocumentView
    {
        CONST_VTBL struct IOleDocumentViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocumentView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleDocumentView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleDocumentView_SetInPlaceSite(This,pIPSite)	\
    (This)->lpVtbl -> SetInPlaceSite(This,pIPSite)

#define IOleDocumentView_GetInPlaceSite(This,ppIPSite)	\
    (This)->lpVtbl -> GetInPlaceSite(This,ppIPSite)

#define IOleDocumentView_GetDocument(This,ppunk)	\
    (This)->lpVtbl -> GetDocument(This,ppunk)

#define IOleDocumentView_SetRect(This,prcView)	\
    (This)->lpVtbl -> SetRect(This,prcView)

#define IOleDocumentView_GetRect(This,prcView)	\
    (This)->lpVtbl -> GetRect(This,prcView)

#define IOleDocumentView_SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)	\
    (This)->lpVtbl -> SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)

#define IOleDocumentView_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define IOleDocumentView_UIActivate(This,fUIActivate)	\
    (This)->lpVtbl -> UIActivate(This,fUIActivate)

#define IOleDocumentView_Open(This)	\
    (This)->lpVtbl -> Open(This)

#define IOleDocumentView_CloseView(This,dwReserved)	\
    (This)->lpVtbl -> CloseView(This,dwReserved)

#define IOleDocumentView_SaveViewState(This,pstm)	\
    (This)->lpVtbl -> SaveViewState(This,pstm)

#define IOleDocumentView_ApplyViewState(This,pstm)	\
    (This)->lpVtbl -> ApplyViewState(This,pstm)

#define IOleDocumentView_Clone(This,pIPSiteNew,ppViewNew)	\
    (This)->lpVtbl -> Clone(This,pIPSiteNew,ppViewNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocumentView_SetInPlaceSite_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite);


void __RPC_STUB IOleDocumentView_SetInPlaceSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetInPlaceSite_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite);


void __RPC_STUB IOleDocumentView_GetInPlaceSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetDocument_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IOleDocumentView_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleDocumentView_SetRect_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPRECT prcView);


void __RPC_STUB IOleDocumentView_SetRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetRect_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ LPRECT prcView);


void __RPC_STUB IOleDocumentView_GetRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleDocumentView_SetRectComplex_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [unique][in] */ LPRECT prcView,
    /* [unique][in] */ LPRECT prcHScroll,
    /* [unique][in] */ LPRECT prcVScroll,
    /* [unique][in] */ LPRECT prcSizeBox);


void __RPC_STUB IOleDocumentView_SetRectComplex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Show_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB IOleDocumentView_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_UIActivate_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ BOOL fUIActivate);


void __RPC_STUB IOleDocumentView_UIActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Open_Proxy( 
    IOleDocumentView __RPC_FAR * This);


void __RPC_STUB IOleDocumentView_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_CloseView_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    DWORD dwReserved);


void __RPC_STUB IOleDocumentView_CloseView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_SaveViewState_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPSTREAM pstm);


void __RPC_STUB IOleDocumentView_SaveViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_ApplyViewState_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPSTREAM pstm);


void __RPC_STUB IOleDocumentView_ApplyViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Clone_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew);


void __RPC_STUB IOleDocumentView_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleDocumentView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0249 */
/* [local] */ 

#endif
#ifndef _LPENUMOLEDOCUMENTVIEWS_DEFINED
#define _LPENUMOLEDOCUMENTVIEWS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0249_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0249_v0_0_s_ifspec;

#ifndef __IEnumOleDocumentViews_INTERFACE_DEFINED__
#define __IEnumOleDocumentViews_INTERFACE_DEFINED__

/* interface IEnumOleDocumentViews */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumOleDocumentViews __RPC_FAR *LPENUMOLEDOCUMENTVIEWS;


EXTERN_C const IID IID_IEnumOleDocumentViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc8-4e68-101b-a2bc-00aa00404770")
    IEnumOleDocumentViews : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cViews) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOleDocumentViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ ULONG cViews);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumOleDocumentViewsVtbl;

    interface IEnumOleDocumentViews
    {
        CONST_VTBL struct IEnumOleDocumentViewsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleDocumentViews_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumOleDocumentViews_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumOleDocumentViews_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumOleDocumentViews_Next(This,cViews,rgpView,pcFetched)	\
    (This)->lpVtbl -> Next(This,cViews,rgpView,pcFetched)

#define IEnumOleDocumentViews_Skip(This,cViews)	\
    (This)->lpVtbl -> Skip(This,cViews)

#define IEnumOleDocumentViews_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumOleDocumentViews_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_RemoteNext_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumOleDocumentViews_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Skip_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews);


void __RPC_STUB IEnumOleDocumentViews_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Reset_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This);


void __RPC_STUB IEnumOleDocumentViews_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Clone_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumOleDocumentViews_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumOleDocumentViews_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0250 */
/* [local] */ 

#endif
#ifndef _LPCONTINUECALLBACK_DEFINED
#define _LPCONTINUECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0250_v0_0_s_ifspec;

#ifndef __IContinueCallback_INTERFACE_DEFINED__
#define __IContinueCallback_INTERFACE_DEFINED__

/* interface IContinueCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IContinueCallback __RPC_FAR *LPCONTINUECALLBACK;


EXTERN_C const IID IID_IContinueCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcca-4e68-101b-a2bc-00aa00404770")
    IContinueCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FContinue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FContinuePrinting( 
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContinueCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContinueCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContinueCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContinueCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FContinue )( 
            IContinueCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FContinuePrinting )( 
            IContinueCallback __RPC_FAR * This,
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus);
        
        END_INTERFACE
    } IContinueCallbackVtbl;

    interface IContinueCallback
    {
        CONST_VTBL struct IContinueCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContinueCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContinueCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContinueCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContinueCallback_FContinue(This)	\
    (This)->lpVtbl -> FContinue(This)

#define IContinueCallback_FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)	\
    (This)->lpVtbl -> FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContinueCallback_FContinue_Proxy( 
    IContinueCallback __RPC_FAR * This);


void __RPC_STUB IContinueCallback_FContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContinueCallback_FContinuePrinting_Proxy( 
    IContinueCallback __RPC_FAR * This,
    /* [in] */ LONG nCntPrinted,
    /* [in] */ LONG nCurPage,
    /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus);


void __RPC_STUB IContinueCallback_FContinuePrinting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContinueCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0251 */
/* [local] */ 

#endif
#ifndef _LPPRINT_DEFINED
#define _LPPRINT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0251_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0251_v0_0_s_ifspec;

#ifndef __IPrint_INTERFACE_DEFINED__
#define __IPrint_INTERFACE_DEFINED__

/* interface IPrint */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPrint __RPC_FAR *LPPRINT;

typedef /* [public] */ 
enum __MIDL_IPrint_0001
    {	PRINTFLAG_MAYBOTHERUSER	= 1,
	PRINTFLAG_PROMPTUSER	= 2,
	PRINTFLAG_USERMAYCHANGEPRINTER	= 4,
	PRINTFLAG_RECOMPOSETODEVICE	= 8,
	PRINTFLAG_DONTACTUALLYPRINT	= 16,
	PRINTFLAG_FORCEPROPERTIES	= 32,
	PRINTFLAG_PRINTTOFILE	= 64
    }	PRINTFLAG;

typedef struct tagPAGERANGE
    {
    LONG nFromPage;
    LONG nToPage;
    }	PAGERANGE;

typedef struct tagPAGESET
    {
    ULONG cbStruct;
    BOOL fOddPages;
    BOOL fEvenPages;
    ULONG cPageRange;
    /* [size_is] */ PAGERANGE rgPages[ 1 ];
    }	PAGESET;

#define PAGESET_TOLASTPAGE   ((WORD)(-1L))

EXTERN_C const IID IID_IPrint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc9-4e68-101b-a2bc-00aa00404770")
    IPrint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialPageNum( 
            /* [in] */ LONG nFirstPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageInfo( 
            /* [out] */ LONG __RPC_FAR *pnFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPages) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Print( 
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
            /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
            /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
            /* [in] */ IContinueCallback __RPC_FAR *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
            /* [out] */ LONG __RPC_FAR *pnLastPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPrint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPrint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPrint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInitialPageNum )( 
            IPrint __RPC_FAR * This,
            /* [in] */ LONG nFirstPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageInfo )( 
            IPrint __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPages);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Print )( 
            IPrint __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
            /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
            /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
            /* [in] */ IContinueCallback __RPC_FAR *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
            /* [out] */ LONG __RPC_FAR *pnLastPage);
        
        END_INTERFACE
    } IPrintVtbl;

    interface IPrint
    {
        CONST_VTBL struct IPrintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrint_SetInitialPageNum(This,nFirstPage)	\
    (This)->lpVtbl -> SetInitialPageNum(This,nFirstPage)

#define IPrint_GetPageInfo(This,pnFirstPage,pcPages)	\
    (This)->lpVtbl -> GetPageInfo(This,pnFirstPage,pcPages)

#define IPrint_Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)	\
    (This)->lpVtbl -> Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrint_SetInitialPageNum_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ LONG nFirstPage);


void __RPC_STUB IPrint_SetInitialPageNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrint_GetPageInfo_Proxy( 
    IPrint __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pnFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPages);


void __RPC_STUB IPrint_GetPageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IPrint_RemotePrint_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *pppageset,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);


void __RPC_STUB IPrint_RemotePrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0252 */
/* [local] */ 

#endif
#ifndef _LPOLECOMMANDTARGET_DEFINED
#define _LPOLECOMMANDTARGET_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0252_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0252_v0_0_s_ifspec;

#ifndef __IOleCommandTarget_INTERFACE_DEFINED__
#define __IOleCommandTarget_INTERFACE_DEFINED__

/* interface IOleCommandTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleCommandTarget __RPC_FAR *LPOLECOMMANDTARGET;

typedef 
enum OLECMDF
    {	OLECMDF_SUPPORTED	= 0x1,
	OLECMDF_ENABLED	= 0x2,
	OLECMDF_LATCHED	= 0x4,
	OLECMDF_NINCHED	= 0x8,
	OLECMDF_INVISIBLE	= 0x10,
	OLECMDF_DEFHIDEONCTXTMENU	= 0x20
    }	OLECMDF;

typedef struct _tagOLECMD
    {
    ULONG cmdID;
    DWORD cmdf;
    }	OLECMD;

typedef struct _tagOLECMDTEXT
    {
    DWORD cmdtextf;
    ULONG cwActual;
    ULONG cwBuf;
    /* [size_is] */ wchar_t rgwz[ 1 ];
    }	OLECMDTEXT;

typedef 
enum OLECMDTEXTF
    {	OLECMDTEXTF_NONE	= 0,
	OLECMDTEXTF_NAME	= 1,
	OLECMDTEXTF_STATUS	= 2
    }	OLECMDTEXTF;

typedef 
enum OLECMDEXECOPT
    {	OLECMDEXECOPT_DODEFAULT	= 0,
	OLECMDEXECOPT_PROMPTUSER	= 1,
	OLECMDEXECOPT_DONTPROMPTUSER	= 2,
	OLECMDEXECOPT_SHOWHELP	= 3
    }	OLECMDEXECOPT;

/* OLECMDID_STOPDOWNLOAD and OLECMDID_ALLOWUILESSSAVEAS are supported for QueryStatus Only */
typedef 
enum OLECMDID
    {	OLECMDID_OPEN	= 1,
	OLECMDID_NEW	= 2,
	OLECMDID_SAVE	= 3,
	OLECMDID_SAVEAS	= 4,
	OLECMDID_SAVECOPYAS	= 5,
	OLECMDID_PRINT	= 6,
	OLECMDID_PRINTPREVIEW	= 7,
	OLECMDID_PAGESETUP	= 8,
	OLECMDID_SPELL	= 9,
	OLECMDID_PROPERTIES	= 10,
	OLECMDID_CUT	= 11,
	OLECMDID_COPY	= 12,
	OLECMDID_PASTE	= 13,
	OLECMDID_PASTESPECIAL	= 14,
	OLECMDID_UNDO	= 15,
	OLECMDID_REDO	= 16,
	OLECMDID_SELECTALL	= 17,
	OLECMDID_CLEARSELECTION	= 18,
	OLECMDID_ZOOM	= 19,
	OLECMDID_GETZOOMRANGE	= 20,
	OLECMDID_UPDATECOMMANDS	= 21,
	OLECMDID_REFRESH	= 22,
	OLECMDID_STOP	= 23,
	OLECMDID_HIDETOOLBARS	= 24,
	OLECMDID_SETPROGRESSMAX	= 25,
	OLECMDID_SETPROGRESSPOS	= 26,
	OLECMDID_SETPROGRESSTEXT	= 27,
	OLECMDID_SETTITLE	= 28,
	OLECMDID_SETDOWNLOADSTATE	= 29,
	OLECMDID_STOPDOWNLOAD	= 30,
	OLECMDID_ONTOOLBARACTIVATED	= 31,
	OLECMDID_FIND	= 32,
	OLECMDID_DELETE	= 33,
	OLECMDID_HTTPEQUIV	= 34,
	OLECMDID_HTTPEQUIV_DONE	= 35,
	OLECMDID_ENABLE_INTERACTION	= 36,
	OLECMDID_ONUNLOAD	= 37,
	OLECMDID_PROPERTYBAG2	= 38,
	OLECMDID_PREREFRESH	= 39,
	OLECMDID_SHOWSCRIPTERROR	= 40,
	OLECMDID_SHOWMESSAGE	= 41,
	OLECMDID_SHOWFIND	= 42,
	OLECMDID_SHOWPAGESETUP	= 43,
	OLECMDID_SHOWPRINT	= 44,
	OLECMDID_CLOSE	= 45,
	OLECMDID_ALLOWUILESSSAVEAS	= 46,
	OLECMDID_DONTDOWNLOADCSS	= 47
    }	OLECMDID;

#define OLECMDERR_E_FIRST            (OLE_E_LAST+1)
#define OLECMDERR_E_NOTSUPPORTED (OLECMDERR_E_FIRST)
#define OLECMDERR_E_DISABLED         (OLECMDERR_E_FIRST+1)
#define OLECMDERR_E_NOHELP           (OLECMDERR_E_FIRST+2)
#define OLECMDERR_E_CANCELED         (OLECMDERR_E_FIRST+3)
#define OLECMDERR_E_UNKNOWNGROUP     (OLECMDERR_E_FIRST+4)
#define MSOCMDERR_E_FIRST OLECMDERR_E_FIRST
#define MSOCMDERR_E_NOTSUPPORTED OLECMDERR_E_NOTSUPPORTED
#define MSOCMDERR_E_DISABLED OLECMDERR_E_DISABLED
#define MSOCMDERR_E_NOHELP OLECMDERR_E_NOHELP
#define MSOCMDERR_E_CANCELED OLECMDERR_E_CANCELED
#define MSOCMDERR_E_UNKNOWNGROUP OLECMDERR_E_UNKNOWNGROUP

EXTERN_C const IID IID_IOleCommandTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bccb-4e68-101b-a2bc-00aa00404770")
    IOleCommandTarget : public IUnknown
    {
    public:
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
            /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCommandTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleCommandTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleCommandTarget __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
            /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exec )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut);
        
        END_INTERFACE
    } IOleCommandTargetVtbl;

    interface IOleCommandTarget
    {
        CONST_VTBL struct IOleCommandTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCommandTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleCommandTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleCommandTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleCommandTarget_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)	\
    (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)

#define IOleCommandTarget_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)	\
    (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleCommandTarget_QueryStatus_Proxy( 
    IOleCommandTarget __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
    /* [in] */ ULONG cCmds,
    /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
    /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText);


void __RPC_STUB IOleCommandTarget_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleCommandTarget_Exec_Proxy( 
    IOleCommandTarget __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [in] */ DWORD nCmdexecopt,
    /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut);


void __RPC_STUB IOleCommandTarget_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleCommandTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0253 */
/* [local] */ 

#endif
typedef enum
{
      OLECMDIDF_REFRESH_NORMAL          = 0,
      OLECMDIDF_REFRESH_IFEXPIRED       = 1,
      OLECMDIDF_REFRESH_CONTINUE        = 2,
      OLECMDIDF_REFRESH_COMPLETELY      = 3,
      OLECMDIDF_REFRESH_NO_CACHE        = 4,
      OLECMDIDF_REFRESH_RELOAD          = 5,
      OLECMDIDF_REFRESH_LEVELMASK       = 0x00FF,
      OLECMDIDF_REFRESH_CLEARUSERINPUT  = 0x1000,
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000
} OLECMDID_REFRESHFLAG;

////////////////////////////////////////////////////////////////////////////
//  Aliases to original office-compatible names
#define IMsoDocument             IOleDocument
#define IMsoDocumentSite         IOleDocumentSite
#define IMsoView                 IOleDocumentView
#define IEnumMsoView             IEnumOleDocumentViews
#define IMsoCommandTarget        IOleCommandTarget
#define LPMSODOCUMENT            LPOLEDOCUMENT
#define LPMSODOCUMENTSITE        LPOLEDOCUMENTSITE
#define LPMSOVIEW                LPOLEDOCUMENTVIEW
#define LPENUMMSOVIEW            LPENUMOLEDOCUMENTVIEWS
#define LPMSOCOMMANDTARGET       LPOLECOMMANDTARGET
#define MSOCMD                   OLECMD
#define MSOCMDTEXT               OLECMDTEXT
#define IID_IMsoDocument         IID_IOleDocument
#define IID_IMsoDocumentSite     IID_IOleDocumentSite
#define IID_IMsoView             IID_IOleDocumentView
#define IID_IEnumMsoView         IID_IEnumOleDocumentViews
#define IID_IMsoCommandTarget    IID_IOleCommandTarget
#define MSOCMDF_SUPPORTED OLECMDF_SUPPORTED
#define MSOCMDF_ENABLED OLECMDF_ENABLED
#define MSOCMDF_LATCHED OLECMDF_LATCHED
#define MSOCMDF_NINCHED OLECMDF_NINCHED
#define MSOCMDTEXTF_NONE OLECMDTEXTF_NONE
#define MSOCMDTEXTF_NAME OLECMDTEXTF_NAME
#define MSOCMDTEXTF_STATUS OLECMDTEXTF_STATUS
#define MSOCMDEXECOPT_DODEFAULT OLECMDEXECOPT_DODEFAULT
#define MSOCMDEXECOPT_PROMPTUSER OLECMDEXECOPT_PROMPTUSER
#define MSOCMDEXECOPT_DONTPROMPTUSER OLECMDEXECOPT_DONTPROMPTUSER
#define MSOCMDEXECOPT_SHOWHELP OLECMDEXECOPT_SHOWHELP
#define MSOCMDID_OPEN OLECMDID_OPEN
#define MSOCMDID_NEW OLECMDID_NEW
#define MSOCMDID_SAVE OLECMDID_SAVE
#define MSOCMDID_SAVEAS OLECMDID_SAVEAS
#define MSOCMDID_SAVECOPYAS OLECMDID_SAVECOPYAS
#define MSOCMDID_PRINT OLECMDID_PRINT
#define MSOCMDID_PRINTPREVIEW OLECMDID_PRINTPREVIEW
#define MSOCMDID_PAGESETUP OLECMDID_PAGESETUP
#define MSOCMDID_SPELL OLECMDID_SPELL
#define MSOCMDID_PROPERTIES OLECMDID_PROPERTIES
#define MSOCMDID_CUT OLECMDID_CUT
#define MSOCMDID_COPY OLECMDID_COPY
#define MSOCMDID_PASTE OLECMDID_PASTE
#define MSOCMDID_PASTESPECIAL OLECMDID_PASTESPECIAL
#define MSOCMDID_UNDO OLECMDID_UNDO
#define MSOCMDID_REDO OLECMDID_REDO
#define MSOCMDID_SELECTALL OLECMDID_SELECTALL
#define MSOCMDID_CLEARSELECTION OLECMDID_CLEARSELECTION
#define MSOCMDID_ZOOM OLECMDID_ZOOM
#define MSOCMDID_GETZOOMRANGE OLECMDID_GETZOOMRANGE
EXTERN_C const GUID SID_SContainerDispatch;


extern RPC_IF_HANDLE __MIDL_itf_docobj_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0253_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);

/* [local] */ HRESULT __stdcall IPrint_Print_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *pppageset,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__

#include <ole2.h>       // for DECLARE_INTERFACE and HRESULT

/* avoid warnings in MSVC at Level4 */
#pragma warning(disable:4201)


/*
 * Some types
 */

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

typedef LPVOID (*LPRGLPVOID)[];
typedef LPRGLPVOID PRGPVOID, LPRGPVOID, PRGLPVOID, PAPVOID, LPAPVOID, PALPVOID, LPALPVOID;

#define VOL volatile
typedef VOID *VOL LPVOIDV;


#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectPlay objects
 */
DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {D1EB6D20-8923-11d0-9D97-00A0C90A43CB}
DEFINE_GUID(CLSID_DirectPlay,0xd1eb6d20, 0x8923, 0x11d0, 0x9d, 0x97, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * GUIDS used by Service Providers shipped with DirectPlay
 * Use these to identify Service Provider returned by EnumConnections
 */

// GUID for IPX service provider
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(DPSPGUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// GUID for TCP/IP service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(DPSPGUID_TCPIP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// GUID for Serial service provider
// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_SERIAL,						
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// GUID for Modem service provider
// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_MODEM,
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 ****************************************************************************/

#ifndef IDIRECTPLAY2_OR_GREATER
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else
typedef struct IUnknown           FAR *LPDIRECTPLAY;
#endif

typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2;
typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2A;
typedef struct IDirectPlay2       IDirectPlay2A;

typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3;
typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3A;
typedef struct IDirectPlay3       IDirectPlay3A;

typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4;
typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4A;
typedef struct IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID, FAR *LPDPID;

/*
 * DPID that system messages come from
 */
#define DPID_SYSMSG         0

/*
 * DPID representing all players in the session
 */
#define DPID_ALLPLAYERS     0

/*
 * DPID representing the server player
 */
#define DPID_SERVERPLAYER	1


/*
 * DPID representing the maxiumum ID in the range of DPID's reserved for
 * use by DirectPlay.
 */
#define DPID_RESERVEDRANGE     100

/*
 * The player ID is unknown (used with e.g. DPSESSION_NOMESSAGEID)
 */
#define DPID_UNKNOWN		0xFFFFFFFF

/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct
{
    DWORD dwSize;               // Size of structure, in bytes
    DWORD dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS, FAR *LPDPCAPS;

/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

/*
 * This DirectPlay player was created on this machine
 */
#define DPPLAYERCAPS_LOCAL			0x00000800

/*
 * Current Open settings supports all forms of Cancel
 */
#define DPCAPS_ASYNCCANCELSUPPORTED    0x00001000

/*
 * Current Open settings supports CancelAll, but not Cancel
 */
#define DPCAPS_ASYNCCANCELALLSUPPORTED 0x00002000

/*
 *  Current Open settings supports Send Timeouts for sends
 */
#define DPCAPS_SENDTIMEOUTSUPPORTED   0x00004000

/*
 *  Current Open settings supports send priority
 */
#define DPCAPS_SENDPRIORITYSUPPORTED   0x00008000

/*
 *  Current Open settings supports DPSEND_ASYNC flag
 */
#define DPCAPS_ASYNCSUPPORTED 		   0x00010000


/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
    union
    {                           // Name of the session
        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
    };
    union
    {                           // Password of the session (optional)
        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
    };
    DWORD_PTR   dwReserved1;        // Reserved for future MS use.
    DWORD_PTR   dwReserved2;
    DWORD_PTR   dwUser1;            // For use by the application
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC2, FAR *LPDPSESSIONDESC2;

typedef DPSESSIONDESC2 * VOL LPDPSESSIONDESC2_V;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef const DPSESSIONDESC2 FAR *LPCDPSESSIONDESC2;
 
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008


/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000


/*
 * This flag tells DirectPlay to optimize communication for latency
 */
#define DPSESSION_OPTIMIZELATENCY		0x00008000

/*
 * This flag allows lobby launched games that aren't voice enabled
 * to get voice capabilities.
 */
#define DPSESSION_ALLOWVOICERETRO		0x00010000

/*
 * This flag supresses transmission of session desc changes.
 * DPSESSION_NODATAMESSAGES was supposed to do that, but SetSessionDesc
 * was ignoring the flag and some apps depended on the broken behavior, this
 * flag allows applications to get the right behaviour without breaking apps depending
 * on old broken behavior.
 */
#define DPSESSION_NOSESSIONDESCMESSAGES		0x00020000
 
/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct 
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
    union
    {                           // The short or friendly name
        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
    };
    union
    {                           // The long or formal name
        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
    };

} DPNAME, FAR *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef const DPNAME FAR *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct 
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
    union
    {                           // User name of the account
        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
    };    
    union
    {                           // Password of the account
        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
    };    
    union
    {                           // Domain name of the account
        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
    };    
} DPCREDENTIALS, FAR *LPDPCREDENTIALS;

typedef const DPCREDENTIALS FAR *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // SSPI provider name
        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
    };
    union
    {                               // CAPI provider name
        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC, FAR *LPDPSECURITYDESC;

typedef const DPSECURITYDESC FAR *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // Account identifier
        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
    };
} DPACCOUNTDESC, FAR *LPDPACCOUNTDESC;

typedef const DPACCOUNTDESC FAR *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef const GUID FAR *LPCGUID;

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    DWORD               dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION, FAR *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef const DPLCONNECTION FAR *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct
{
    DWORD               dwSize;
    DWORD               dwFlags;
    union
    {                          // Message string
        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
    };    
} DPCHAT, FAR * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct 
{
	UINT         len;       // length of buffer data
	PUCHAR	     pData;		// pointer to buffer data
} SGBUFFER, *PSGBUFFER, FAR *LPSGBUFFER;


/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

/*
 * Callback for IDirectPlay2::EnumSessions
 */
typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK2)(
    LPCDPSESSIONDESC2   lpThisSD,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags,
    LPVOID              lpContext );

/*
 * This flag is set on the EnumSessions callback dwFlags parameter when
 * the time out has occurred. There will be no session data for this 
 * callback. If *lpdwTimeOut is set to a non-zero value and the 
 * EnumSessionsCallback function returns TRUE then EnumSessions will 
 * continue waiting until the next timeout occurs. Timeouts are in 
 * milliseconds.
 */
#define DPESC_TIMEDOUT          0x00000001


/*
 * Callback for IDirectPlay2::EnumPlayers
 *              IDirectPlay2::EnumGroups
 *              IDirectPlay2::EnumGroupPlayers
 */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK2)(
    DPID            dpId,
    DWORD           dwPlayerType,
    LPCDPNAME       lpName,
    DWORD           dwFlags,
    LPVOID          lpContext );


/*
 * Unicode callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for Unicode strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID      lpguidSP,
    LPWSTR      lpSPName,
    DWORD       dwMajorVersion,
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * ANSI callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for ANSI strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACKA)(
    LPGUID      lpguidSP,
    LPSTR       lpSPName,
    DWORD       dwMajorVersion,     
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * Callback for IDirectPlay3(A)::EnumConnections
 */
typedef BOOL (FAR PASCAL * LPDPENUMCONNECTIONSCALLBACK)(
    LPCGUID     lpguidSP,
	LPVOID		lpConnection,
	DWORD		dwConnectionSize,
    LPCDPNAME   lpName,
	DWORD 		dwFlags,
	LPVOID 		lpContext);


/*
 * API's
 */

#ifdef UNICODE
#define DirectPlayEnumerate     DirectPlayEnumerateW
#else
#define DirectPlayEnumerate     DirectPlayEnumerateA
#endif // UNICODE

extern HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA, LPVOID );
extern HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK, LPVOID );
extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay2
DECLARE_INTERFACE_( IDirectPlay2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay2 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay2_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay2_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay2_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay2_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)

#else /* C++ */

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay2_AddRef(p)                      (p)->AddRef()
#define IDirectPlay2_Release(p)                     (p)->Release()
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay2_Close(p)                       (p)->Close()
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay2_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay3
DECLARE_INTERFACE_( IDirectPlay3, IDirectPlay2 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
	STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
	STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
	STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
	STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
	STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
	STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
	STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay3 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay3_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay3_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay3_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay3_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)

#else /* C++ */

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay3_AddRef(p)                      (p)->AddRef()
#define IDirectPlay3_Release(p)                     (p)->Release()
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay3_Close(p)                       (p)->Close()
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay3_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay4 (and IDirectPlay4A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay4
DECLARE_INTERFACE_( IDirectPlay4, IDirectPlay3 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
    STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
    STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
    STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
    STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
    STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    /*** IDirectPlay4 methods ***/
    STDMETHOD(GetGroupOwner)        (THIS_ DPID, LPDPID) PURE;
    STDMETHOD(SetGroupOwner)        (THIS_ DPID, DPID) PURE;
    STDMETHOD(SendEx)               (THIS_ DPID, DPID, DWORD, LPVOID, DWORD, DWORD, DWORD, LPVOID, DWORD_PTR *) PURE;
    STDMETHOD(GetMessageQueue)      (THIS_ DPID, DPID, DWORD, LPDWORD, LPDWORD) PURE;
    STDMETHOD(CancelMessage)        (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(CancelPriority)       (THIS_ DWORD, DWORD, DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayX interface macros (for IDirectPlay4 and beyond)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayX_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayX_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->lpVtbl->CancelMessage(p,a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->lpVtbl->CancelPriority(p,a,b,c)
#define IDirectPlayX_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->lpVtbl->GetMessageQueue(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlayX_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->lpVtbl->SendEx(p,a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->lpVtbl->GetGroupOwner(p,a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->lpVtbl->SetGroupOwner(p,a,b)

#else /* C++ */

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayX_AddRef(p)                      (p)->AddRef()
#define IDirectPlayX_Release(p)                     (p)->Release()
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->CancelMessage(a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->CancelPriority(a,b,c)
#define IDirectPlayX_Close(p)                       (p)->Close()
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->GetMessageQueue(a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlayX_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->SendEx(a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->GetGroupOwner(a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->SetGroupOwner(a,b)

#endif

/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/

/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002


/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/

/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL


/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800

/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000


/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           DPENUMPLAYERS_SERVERPLAYER

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              DPENUMPLAYERS_SPECTATOR

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  DPENUMPLAYERS_LOCAL

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   DPENUMPLAYERS_OWNER

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/


/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             DPENUMGROUPS_STAGINGAREA

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   DPENUMGROUPS_LOCAL

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   DPENUMGROUPS_HIDDEN


/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002


/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/

/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001


/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
 #define DPOPEN_RETURNSTATUS		DPENUMSESSIONS_RETURNSTATUS


/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION					DPOPEN_CREATE

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION					DPOPEN_JOIN

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/

/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008


/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001


/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080


/*
 * Send message asynchronously, must check caps
 * before using this flag.  It is always provided
 * if the protocol flag is set.
 */
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400


/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRI              0x0000FFFF
#define DPSEND_MAX_PRIORITY         DPSEND_MAX_PRI


/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/

/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002


/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

 
/*
 * Start an asynchronous connect which returns status codes
 */
#define DPCONNECT_RETURNSTATUS      (DPENUMSESSIONS_RETURNSTATUS)


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d


/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct
{
    DWORD       dwType;         // Message type
} DPMSG_GENERIC, FAR *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP, FAR *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP, FAR *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP, FAR *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     FAR *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP, FAR *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     FAR *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA, FAR *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME, FAR *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC, FAR *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          FAR *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   FAR *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct 
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE, FAR *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION, FAR *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT, FAR *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER, FAR *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	HRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE, *LPDPMSG_SENDCOMPLETE;

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           S_OK
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL
#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_INVALIDGROUP             	MAKE_DPHRESULT( 155 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_PENDING					E_PENDING
#define DPERR_SENDTOOBIG				MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 
#define DPERR_NOINTERFACE               E_NOINTERFACE
#define DPERR_CANNOTCREATESERVER        MAKE_DPHRESULT( 290 )
#define DPERR_PLAYERLOST                MAKE_DPHRESULT( 300 )
#define DPERR_SESSIONLOST               MAKE_DPHRESULT( 310 )
#define DPERR_UNINITIALIZED             MAKE_DPHRESULT( 320 )
#define DPERR_NONEWPLAYERS              MAKE_DPHRESULT( 330 )
#define DPERR_INVALIDPASSWORD           MAKE_DPHRESULT( 340 )
#define DPERR_CONNECTING                MAKE_DPHRESULT( 350 )
#define DPERR_CONNECTIONLOST            MAKE_DPHRESULT( 360 )
#define DPERR_UNKNOWNMESSAGE            MAKE_DPHRESULT( 370 )
#define DPERR_CANCELFAILED              MAKE_DPHRESULT( 380 )
#define DPERR_INVALIDPRIORITY           MAKE_DPHRESULT( 390 )
#define DPERR_NOTHANDLED                MAKE_DPHRESULT( 400 )
#define DPERR_CANCELLED                 MAKE_DPHRESULT( 410 )
#define DPERR_ABORTED                   MAKE_DPHRESULT( 420 )


#define DPERR_BUFFERTOOLARGE            MAKE_DPHRESULT( 1000 )
#define DPERR_CANTCREATEPROCESS         MAKE_DPHRESULT( 1010 )
#define DPERR_APPNOTSTARTED             MAKE_DPHRESULT( 1020 )
#define DPERR_INVALIDINTERFACE          MAKE_DPHRESULT( 1030 )
#define DPERR_NOSERVICEPROVIDER         MAKE_DPHRESULT( 1040 )
#define DPERR_UNKNOWNAPPLICATION        MAKE_DPHRESULT( 1050 )
#define DPERR_NOTLOBBIED                MAKE_DPHRESULT( 1070 )
#define DPERR_SERVICEPROVIDERLOADED		MAKE_DPHRESULT( 1080 )
#define DPERR_ALREADYREGISTERED			MAKE_DPHRESULT( 1090 )
#define DPERR_NOTREGISTERED				MAKE_DPHRESULT( 1100 )

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      MAKE_DPHRESULT(  2000 )
#define DPERR_CANTLOADSSPI              MAKE_DPHRESULT(  2010 )
#define DPERR_ENCRYPTIONFAILED          MAKE_DPHRESULT(  2020 )
#define DPERR_SIGNFAILED                MAKE_DPHRESULT(  2030 )
#define DPERR_CANTLOADSECURITYPACKAGE   MAKE_DPHRESULT(  2040 )
#define DPERR_ENCRYPTIONNOTSUPPORTED    MAKE_DPHRESULT(  2050 )
#define DPERR_CANTLOADCAPI              MAKE_DPHRESULT(  2060 )
#define DPERR_NOTLOGGEDIN               MAKE_DPHRESULT(  2070 )
#define DPERR_LOGONDENIED               MAKE_DPHRESULT(  2080 )


/****************************************************************************
 *
 * 	dplay 1.0 obsolete structures + interfaces
 *	Included for compatibility only. New apps should
 *	use IDirectPlay2
 *
 ****************************************************************************/

// define this to ignore obsolete interfaces and constants
#ifndef IDIRECTPLAY2_OR_GREATER

#define DPOPEN_OPENSESSION          DPOPEN_JOIN
#define DPOPEN_CREATESESSION        DPOPEN_CREATE

#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_PREVIOUS      0x00000004

#define DPSEND_GUARANTEE            DPSEND_GUARANTEED
#define DPSEND_TRYONCE              0x00000004

#define DPCAPS_NAMESERVICE          0x00000001
#define DPCAPS_NAMESERVER           DPCAPS_ISHOST
#define DPCAPS_GUARANTEED           0x00000004

#define DPLONGNAMELEN               52
#define DPSHORTNAMELEN              20
#define DPSESSIONNAMELEN            32
#define DPPASSWORDLEN               16
#define DPUSERRESERVED              16

#define DPSYS_ADDPLAYER             0x0003
#define DPSYS_DELETEPLAYER          0x0005

#define DPSYS_DELETEGROUP           0x0020
#define DPSYS_DELETEPLAYERFROMGRP   0x0021
#define DPSYS_CONNECT               0x484b

typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef BOOL (PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  
    DWORD_PTR dwSession;                    
    DWORD   dwMaxPlayers;                 
    DWORD   dwCurrentPlayers;             
    DWORD   dwFlags;                      
    char    szSessionName[DPSESSIONNAMELEN];
    char    szUserField[DPUSERRESERVED];
    DWORD_PTR   dwReserved1;                  
    char    szPassword[DPPASSWORDLEN];    
    DWORD_PTR   dwReserved2;                  
    DWORD_PTR   dwUser1;
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC,*LPDPSESSIONDESC;

typedef BOOL (PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC lpDPSessionDesc,
    LPVOID      lpContext,
    LPDWORD     lpdwTimeOut,
    DWORD       dwFlags);

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};

/****************************************************************************
 *
 * IDirectPlay interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay_Close(p)                        (p)->lpVtbl->Close(p)
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->lpVtbl->CreateGroup(p,a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->lpVtbl->CreatePlayer(p,a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->lpVtbl->EnableNewPlayers(p,a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->lpVtbl->GetPlayerCaps(p,a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->lpVtbl->GetPlayerName(p,a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay_Open(p,a)                       (p)->lpVtbl->Open(p,a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->lpVtbl->SaveSession(p,a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->lpVtbl->SetPlayerName(p,a,b,c)

#else /* C++ */

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->AddPlayerToGroup(a,b)
#define IDirectPlay_Close(p)                        (p)->Close()
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->CreateGroup(a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->CreatePlayer(a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->DestroyGroup(a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->DestroyPlayer(a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->EnableNewPlayers(a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->EnumGroupPlayers(a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->EnumGroups(a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->GetMessageCount(a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->GetPlayerCaps(a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->GetPlayerName(a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->Initialize(a)
#define IDirectPlay_Open(p,a)                       (p)->Open(a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->Receive(a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->SaveSession(a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->Send(a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->SetPlayerName(a,b,c)

#endif

DEFINE_GUID(IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);

#endif // IDIRECTPLAY2_OR_GREATER

/****************************************************************************
 *
 * IDirectPlay macros (included regardless of IDIRECTPLAY2_OR_GREATER flag)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectPlay_Release(p)                      (p)->lpVtbl->Release(p)

#else

#define IDirectPlay_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectPlay_AddRef(p)                       (p)->AddRef()
#define IDirectPlay_Release(p)                      (p)->Release()

#endif // IDirectPlay interface macros 

#ifdef __cplusplus
};
#endif

#pragma warning(default:4201)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dmort.h ===
//------------------------------------------------------------------------------
// File: DMORt.h
//
// Desc: Miscellaneous runtime support for DirectShow Media Objects
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMORT_H__
#define __DMORT_H__

//
// Mediatype helpers.  MoInitMediaType() goes with MoFreeMediaType(),
// MoCreateMediaType() goes with MoDeleteMediaType() - don't mix !
//



//
// Takes a pointer to an already allocated DMO_MEDIA_TYPE structure, allocates
// a format block of cbFormat bytes, and sets appropriate members of
// DMO_MEDIA_TYPE to point to the newly allocated format block.  Also
// initializes the IUnknown pointer inside DMO_MEDIA_TYPE to NULL.
//
// The format block allocated by MoInitMediaType must be freed by calling
// MoFreeMediaType().
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, DWORD cbFormat);

//
// Frees the format block and releases any IUnknown, but does not free the
// DMO_MEDIA_TYPE structure itself.  Input parameter must point to an
// DMO_MEDIA_TYPE structure previously initialized by MoInitMediaType().
//
STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt);

//
// Copies the DMO_MEDIA_TYPE members.  Also duplicates the format block and
// the IUnknown pointer.  Both parameters must point to valid DMO_MEDIA_TYPE
// structures.  Target structure must be later freed using MoFreeMediaType().
//
STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, const DMO_MEDIA_TYPE *pmtSrc);



//
// Allocates a new DMO_MEDIA_TYPE structure and initializes it just like
// MoInitMediaType.  I.e., this function allocates both the format block
// and the DMO_MEDIA_TYPE structure itself.  Pointer to DMO_MEDIA_TYPE is
// returned as *ppmt.
//
// DMO_MEDIA_TYPE structures allocated by MoCreateMediaType() must be freed
// by calling MoDeleteMediaType().
//
STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, DWORD cbFormat);

//
// Frees any format block, releases any IUnknown, and deletes the
// DMO_MEDIA_TYPE structure itself.  The input parameter must point to an
// DMO_MEDIA_TYPE structure previously allocated by MoCreateMediaType().
//
STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt);

//
// Allocates a new DMO_MEDIA_TYPE structure and copies pmtSrc into it like
// MoCopyMediaType.  I.e., this function allocates a new DMO_MEDIA_TYPE struct
// as well as a new format block for the target mediatype.  Trager mediatype
// must later be freed using MoDeleteMediaType().
//
STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, const DMO_MEDIA_TYPE *pmtSrc);



#endif //__DMORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dpaddr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpaddr.h
 *  Content:   DirectPlayAddress include file
 ***************************************************************************/

#ifndef __DIRECTPLAYADDRESS__
#define __DIRECTPLAYADDRESS__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT

#ifdef __cplusplus
extern "C" {
#endif

#include "dplay8.h"

/****************************************************************************
 *
 * DirectPlay8Address CLSIDs
 *
 ****************************************************************************/

// {934A9523-A3CA-4bc5-ADA0-D6D95D979421}
DEFINE_GUID(CLSID_DirectPlay8Address,
0x934a9523, 0xa3ca, 0x4bc5, 0xad, 0xa0, 0xd6, 0xd9, 0x5d, 0x97, 0x94, 0x21);

/****************************************************************************
 *
 * DirectPlay8Address Interface IIDs
 *
 ****************************************************************************/


// {83783300-4063-4c8a-9DB3-82830A7FEB31}
DEFINE_GUID(IID_IDirectPlay8Address,
0x83783300, 0x4063, 0x4c8a, 0x9d, 0xb3, 0x82, 0x83, 0xa, 0x7f, 0xeb, 0x31);

// {E5A0E990-2BAD-430b-87DA-A142CF75DE58}
DEFINE_GUID(IID_IDirectPlay8AddressIP,
0xe5a0e990, 0x2bad, 0x430b, 0x87, 0xda, 0xa1, 0x42, 0xcf, 0x75, 0xde, 0x58);


/****************************************************************************
 *
 * DirectPlay8Address Interface Pointer definitions
 *
 ****************************************************************************/


typedef struct IDirectPlay8Address			*PDIRECTPLAY8ADDRESS, *LPDIRECTPLAY8ADDRESS;
typedef struct IDirectPlay8AddressIP		*PDIRECTPLAY8ADDRESSIP, *LPDIRECTPLAY8ADDRESSIP;

/****************************************************************************
 *
 * DirectPlay8Address Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct sockaddr SOCKADDR;

/****************************************************************************
 *
 * DirectPlay8Address Constants
 *
 ****************************************************************************/
//
// Asynchronous operation flags
//
#define DPNA_DATATYPE_STRING				0x00000001
#define DPNA_DATATYPE_DWORD					0x00000002
#define DPNA_DATATYPE_GUID					0x00000003
#define DPNA_DATATYPE_BINARY				0x00000004
#define DPNA_DATATYPE_STRING_ANSI           0x00000005

#define DPNA_DPNSVR_PORT					6073

#define DPNA_INDEX_INVALID					0xFFFFFFFF

/****************************************************************************
 *
 * DirectPlay8Address Address Elements
 *
 ****************************************************************************/

#define DPNA_SEPARATOR_KEYVALUE				L'='
#define DPNA_SEPARATOR_USERDATA				L'#'
#define DPNA_SEPARATOR_COMPONENT			L';'
#define DPNA_ESCAPECHAR						L'%'

// Header
#define DPNA_HEADER		                    L"x-directplay:/"

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE		L"applicationinstance"
#define DPNA_KEY_BAUD						L"baud"
#define DPNA_KEY_DEVICE						L"device"
#define DPNA_KEY_FLOWCONTROL				L"flowcontrol"
#define DPNA_KEY_HOSTNAME					L"hostname"
#define DPNA_KEY_PARITY						L"parity"
#define DPNA_KEY_PHONENUMBER				L"phonenumber"
#define DPNA_KEY_PORT						L"port"
#define DPNA_KEY_PROGRAM					L"program"
#define DPNA_KEY_PROVIDER					L"provider"
#define DPNA_KEY_STOPBITS					L"stopbits"

// values for baud rate
#define DPNA_BAUD_RATE_9600					9600
#define DPNA_BAUD_RATE_14400				14400
#define DPNA_BAUD_RATE_19200				19200
#define DPNA_BAUD_RATE_38400				38400
#define DPNA_BAUD_RATE_56000				56000
#define DPNA_BAUD_RATE_57600				57600
#define DPNA_BAUD_RATE_115200				115200

// values for stop bits
#define DPNA_STOP_BITS_ONE					L"1"
#define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
#define DPNA_STOP_BITS_TWO					L"2"

// values for parity
#define DPNA_PARITY_NONE					L"NONE"
#define DPNA_PARITY_EVEN					L"EVEN"
#define DPNA_PARITY_ODD						L"ODD"
#define DPNA_PARITY_MARK					L"MARK"
#define DPNA_PARITY_SPACE					L"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE				L"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS				L"RTS"
#define DPNA_FLOW_CONTROL_DTR				L"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER            L"IP"
#define DPNA_VALUE_IPXPROVIDER              L"IPX"
#define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
#define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"


//// ANSI DEFINITIONS

// Header
#define DPNA_HEADER_A						"x-directplay:/"
#define DPNA_SEPARATOR_KEYVALUE_A			'='
#define DPNA_SEPARATOR_USERDATA_A			'#'
#define DPNA_SEPARATOR_COMPONENT_A			';'
#define DPNA_ESCAPECHAR_A					'%'

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
#define DPNA_KEY_BAUD_A						"baud"
#define DPNA_KEY_DEVICE_A					"device"
#define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
#define DPNA_KEY_HOSTNAME_A					"hostname"
#define DPNA_KEY_PARITY_A					"parity"
#define DPNA_KEY_PHONENUMBER_A				"phonenumber"
#define DPNA_KEY_PORT_A						"port"
#define DPNA_KEY_PROGRAM_A					"program"
#define DPNA_KEY_PROVIDER_A					"provider"
#define DPNA_KEY_STOPBITS_A					"stopbits"

// values for stop bits
#define DPNA_STOP_BITS_ONE_A				"1"
#define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
#define DPNA_STOP_BITS_TWO_A				"2"

// values for parity
#define DPNA_PARITY_NONE_A					"NONE"
#define DPNA_PARITY_EVEN_A					"EVEN"
#define DPNA_PARITY_ODD_A					"ODD"
#define DPNA_PARITY_MARK_A					"MARK"
#define DPNA_PARITY_SPACE_A					"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE_A			"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS_A				"RTS"
#define DPNA_FLOW_CONTROL_DTR_A				"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
#define DPNA_VALUE_IPXPROVIDER_A            "IPX"
#define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
#define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"

/****************************************************************************
 *
 * DirectPlay8Address Functions
 *
 ****************************************************************************/

HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);

/****************************************************************************
 *
 * DirectPlay8Address Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for IDirectPlay8Address Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Address
DECLARE_INTERFACE_(IDirectPlay8Address,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    /*** IDirectPlay8Address methods ***/

    STDMETHOD(BuildFromURLW)(THIS_ WCHAR *pwszSourceURL ) PURE;
    STDMETHOD(BuildFromURLA)(THIS_ CHAR *pszSourceURL ) PURE;
    STDMETHOD(Duplicate)(THIS_ PDIRECTPLAY8ADDRESS *ppdpaNewAddress ) PURE;
    STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
	STDMETHOD(IsEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
    STDMETHOD(Clear)(THIS ) PURE;
    STDMETHOD(GetURLW)(THIS_ WCHAR *pwszURL, PDWORD pdwNumChars ) PURE;
    STDMETHOD(GetURLA)(THIS_ CHAR *pszURL, PDWORD pdwNumChars) PURE;
    STDMETHOD(GetSP)(THIS_ GUID *pguidSP ) PURE;
    STDMETHOD(GetUserData)(THIS_ void *pvUserData, PDWORD pdwBufferSize) PURE;
    STDMETHOD(SetSP)(THIS_ const GUID * const pguidSP ) PURE;
    STDMETHOD(SetUserData)(THIS_ const void * const pvUserData, const DWORD dwDataSize) PURE;
    STDMETHOD(GetNumComponents)(THIS_ PDWORD pdwNumComponents ) PURE;
    STDMETHOD(GetComponentByName)(THIS_ const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
    STDMETHOD(GetComponentByIndex)(THIS_ const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
    STDMETHOD(AddComponent)(THIS_ const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType ) PURE;	
    STDMETHOD(GetDevice)(THIS_  GUID * ) PURE;
    STDMETHOD(SetDevice)(THIS_  const GUID * const) PURE;
    STDMETHOD(BuildFromDPADDRESS)( THIS_ LPVOID pvAddress, DWORD dwDataSize ) PURE;
};

//
// COM definition for IDirectPlay8AddressIP Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8AddressIP
DECLARE_INTERFACE_(IDirectPlay8AddressIP,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID, PVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;

	/*** IDirectPlay8AddressIP methods ***/

	// Constructs a IDirectPlay8 TCP Address from a SOCKADDR structure
	STDMETHOD(BuildFromSockAddr)(THIS_ const SOCKADDR * const ) PURE;

	// Constructs a TCP Address from a string (hostname) and port
	STDMETHOD(BuildAddress)(THIS_ const WCHAR * const wszAddress, const USHORT usPort ) PURE;

	// Builds a local TCP Address
	STDMETHOD(BuildLocalAddress)(THIS_ const GUID * const pguidAdapter, const USHORT usPort ) PURE;

	// Gets the address from the structure in SOCKADR format
	STDMETHOD(GetSockAddress)(THIS_ SOCKADDR *, PDWORD ) PURE;

	// Gets the local afddress
	STDMETHOD(GetLocalAddress)(THIS_ GUID *pguidAdapter, USHORT *pusPort ) PURE;

	// Gets the remote address
	STDMETHOD(GetAddress)(THIS_ WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort ) PURE;

};



/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8Address_QueryInterface(p,a,b)		    (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Address_AddRef(p)          			    (p)->lpVtbl->AddRef(p)
#define IDirectPlay8Address_Release(p)         			    (p)->lpVtbl->Release(p)
#define IDirectPlay8Address_BuildFromURLW(p,a)			    (p)->lpVtbl->BuildFromURLW(p,a)
#define IDirectPlay8Address_BuildFromURLA(p,a)			    (p)->lpVtbl->BuildFromURLA(p,a)
#define IDirectPlay8Address_Duplicate(p,a)				    (p)->lpVtbl->Duplicate(p,a)
#define IDirectPlay8Address_SetEqual(p,a)                   (p)->lpVtbl->SetEqual(p,a)
#define IDirectPlay8Address_IsEqual(p,a)			        (p)->lpVtbl->IsEqual(p,a)
#define IDirectPlay8Address_Clear(p)					    (p)->lpVtbl->Clear(p)
#define IDirectPlay8Address_GetURLW(p,a,b)				    (p)->lpVtbl->GetURLW(p,a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)				    (p)->lpVtbl->GetURLA(p,a,b)
#define IDirectPlay8Address_GetSP(p,a)					    (p)->lpVtbl->GetSP(p,a)
#define IDirectPlay8Address_GetUserData(p,a,b)			    (p)->lpVtbl->GetUserData(p,a,b)
#define IDirectPlay8Address_SetSP(p,a)					    (p)->lpVtbl->SetSP(p,a)
#define IDirectPlay8Address_SetUserData(p,a,b)			    (p)->lpVtbl->SetUserData(p,a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)		    (p)->lpVtbl->GetNumComponents(p,a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)	(p)->lpVtbl->GetComponentByName(p,a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->lpVtbl->GetComponentByIndex(p,a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)		    (p)->lpVtbl->AddComponent(p,a,b,c,d)
#define IDirectPlay8Address_SetDevice(p,a)				    (p)->lpVtbl->SetDevice(p,a)
#define IDirectPlay8Address_GetDevice(p,a)				    (p)->lpVtbl->GetDevice(p,a)
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)		    (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8AddressIP_AddRef(p)          		    (p)->lpVtbl->AddRef(p)
#define IDirectPlay8AddressIP_Release(p)         		    (p)->lpVtbl->Release(p)
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)	    (p)->lpVtbl->BuildFromSockAddr(p,a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)		    (p)->lpVtbl->BuildAddress(p,a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)	    (p)->lpVtbl->BuildLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)		    (p)->lpVtbl->GetSockAddress(p,a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)	    (p)->lpVtbl->GetLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)		    (p)->lpVtbl->GetAddress(p,a,b,c)


#else /* C++ */

#define IDirectPlay8Address_QueryInterface(p,a,b)		    (p)->QueryInterface(a,b)
#define IDirectPlay8Address_AddRef(p)          			    (p)->AddRef()
#define IDirectPlay8Address_Release(p)         			    (p)->Release()
#define IDirectPlay8Address_BuildFromURLW(p,a)			    (p)->BuildFromURLW(a)
#define IDirectPlay8Address_BuildFromURLA(p,a)			    (p)->BuildFromURLA(a)
#define IDirectPlay8Address_Duplicate(p,a)				    (p)->Duplicate(a)
#define IDirectPlay8Address_SetEqual(p,a)                   (p)->SetEqual(a)
#define IDirectPlay8Address_IsEqual(p,a)			        (p)->IsEqual(a)
#define IDirectPlay8Address_Clear(p)					    (p)->Clear()
#define IDirectPlay8Address_GetURLW(p,a,b)				    (p)->GetURLW(a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)				    (p)->GetURLA(a,b)
#define IDirectPlay8Address_GetSP(p,a)					    (p)->GetSP(a)
#define IDirectPlay8Address_GetUserData(p,a,b)			    (p)->GetUserData(a,b)
#define IDirectPlay8Address_SetSP(p,a)					    (p)->SetSP(a)
#define IDirectPlay8Address_SetUserData(p,a,b)			    (p)->SetUserData(a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)		    (p)->GetNumComponents(a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)	(p)->GetComponentByName(a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->GetComponentByIndex(a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)		    (p)->AddComponent(a,b,c,d)
#define IDirectPlay8Address_SetDevice(p,a)				    (p)->SetDevice(a)
#define IDirectPlay8Address_GetDevice(p,a)				    (p)->GetDevice(a)
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->BuildFromDirectPlay4Address(a,b)

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)		    (p)->QueryInterface(a,b)
#define IDirectPlay8AddressIP_AddRef(p)          		    (p)->AddRef()
#define IDirectPlay8AddressIP_Release(p)         		    (p)->Release()
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)	    (p)->BuildFromSockAddr(a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)		    (p)->BuildAddress(a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)	    (p)->BuildLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)		    (p)->GetSockAddress(a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)	    (p)->GetLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)		    (p)->GetAddress(a,b,c)


#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dplay8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPlay8.h
 *  Content:	DirectPlay8 include file
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8_H__
#define __DIRECTPLAY8_H__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT

#include "dpaddr.h"

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

// {743F1DC6-5ABA-429f-8BDF-C54D03253DC2}
DEFINE_GUID(CLSID_DirectPlay8Client,
0x743f1dc6, 0x5aba, 0x429f, 0x8b, 0xdf, 0xc5, 0x4d, 0x3, 0x25, 0x3d, 0xc2);

// {286F484D-375E-4458-A272-B138E2F80A6A}
DEFINE_GUID(CLSID_DirectPlay8Peer,
0x286f484d, 0x375e, 0x4458, 0xa2, 0x72, 0xb1, 0x38, 0xe2, 0xf8, 0xa, 0x6a);

// {DA825E1B-6830-43d7-835D-0B5AD82956A2}
DEFINE_GUID(CLSID_DirectPlay8Server,
0xda825e1b, 0x6830, 0x43d7, 0x83, 0x5d, 0xb, 0x5a, 0xd8, 0x29, 0x56, 0xa2);


/****************************************************************************
 *
 * DirectPlay8 Interface IIDs
 *
 ****************************************************************************/

// {5102DACD-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Client,
0x5102dacd, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {5102DACF-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Peer,
0x5102dacf, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {5102DACE-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Server,
0x5102dace, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8 Service Provider GUIDs
 *
 ****************************************************************************/

// {53934290-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {6D4A3650-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {743B5D60-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {EBFE7BA0-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_TCPIP, 0xebfe7ba0, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8 Interface Pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlay8Peer     *PDIRECTPLAY8PEER;
typedef	struct IDirectPlay8Server	*PDIRECTPLAY8SERVER;
typedef	struct IDirectPlay8Client	*PDIRECTPLAY8CLIENT;


/****************************************************************************
 *
 * DirectPlay8 Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
typedef struct IDirectPlay8Address              IDirectPlay8Address;

/****************************************************************************
 *
 * DirectPlay8 Callback Functions
 *
 ****************************************************************************/

//
// Callback Function Type Definition
//
typedef HRESULT (WINAPI *PFNDPNMESSAGEHANDLER)(PVOID,DWORD,PVOID);

/****************************************************************************
 *
 * DirectPlay8 Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

//
// Player IDs.  Used to uniquely identify a player in a session
//
typedef DWORD	DPNID,      *PDPNID;

//
// Used as identifiers for operations
//
typedef	DWORD	DPNHANDLE, *PDPNHANDLE;

/****************************************************************************
 *
 * DirectPlay8 Message Identifiers
 *
 ****************************************************************************/

#define	DPN_MSGID_OFFSET					0xFFFF0000
#define DPN_MSGID_ADD_PLAYER_TO_GROUP		( DPN_MSGID_OFFSET | 0x0001 )
#define DPN_MSGID_APPLICATION_DESC			( DPN_MSGID_OFFSET | 0x0002 )
#define DPN_MSGID_ASYNC_OP_COMPLETE			( DPN_MSGID_OFFSET | 0x0003 )
#define DPN_MSGID_CLIENT_INFO				( DPN_MSGID_OFFSET | 0x0004 )
#define DPN_MSGID_CONNECT_COMPLETE			( DPN_MSGID_OFFSET | 0x0005 )
#define DPN_MSGID_CREATE_GROUP				( DPN_MSGID_OFFSET | 0x0006 )
#define DPN_MSGID_CREATE_PLAYER				( DPN_MSGID_OFFSET | 0x0007 )
#define DPN_MSGID_DESTROY_GROUP				( DPN_MSGID_OFFSET | 0x0008 )
#define DPN_MSGID_DESTROY_PLAYER			( DPN_MSGID_OFFSET | 0x0009 )
#define DPN_MSGID_ENUM_HOSTS_QUERY			( DPN_MSGID_OFFSET | 0x000a )
#define DPN_MSGID_ENUM_HOSTS_RESPONSE		( DPN_MSGID_OFFSET | 0x000b )
#define DPN_MSGID_GROUP_INFO				( DPN_MSGID_OFFSET | 0x000c )
#define DPN_MSGID_HOST_MIGRATE				( DPN_MSGID_OFFSET | 0x000d )
#define DPN_MSGID_INDICATE_CONNECT			( DPN_MSGID_OFFSET | 0x000e )
#define DPN_MSGID_INDICATED_CONNECT_ABORTED	( DPN_MSGID_OFFSET | 0x000f )
#define DPN_MSGID_PEER_INFO					( DPN_MSGID_OFFSET | 0x0010 )
#define DPN_MSGID_RECEIVE					( DPN_MSGID_OFFSET | 0x0011 )
#define DPN_MSGID_REMOVE_PLAYER_FROM_GROUP	( DPN_MSGID_OFFSET | 0x0012 )
#define	DPN_MSGID_RETURN_BUFFER				( DPN_MSGID_OFFSET | 0x0013 )
#define DPN_MSGID_SEND_COMPLETE				( DPN_MSGID_OFFSET | 0x0014 )
#define DPN_MSGID_SERVER_INFO				( DPN_MSGID_OFFSET | 0x0015 )
#define	DPN_MSGID_TERMINATE_SESSION			( DPN_MSGID_OFFSET | 0x0016 )

/****************************************************************************
 *
 * DirectPlay8 Constants
 *
 ****************************************************************************/

#define	DPNID_ALL_PLAYERS_GROUP				0

//
// DESTROY_GROUP reasons
//
#define	DPNDESTROYGROUPREASON_NORMAL				0x0001
#define DPNDESTROYGROUPREASON_AUTODESTRUCTED		0x0002
#define	DPNDESTROYGROUPREASON_SESSIONTERMINATED		0x0003

//
// DESTROY_PLAYER reasons
//
#define DPNDESTROYPLAYERREASON_NORMAL				0x0001
#define DPNDESTROYPLAYERREASON_CONNECTIONLOST		0x0002
#define	DPNDESTROYPLAYERREASON_SESSIONTERMINATED	0x0003
#define	DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER	0x0004

/****************************************************************************
 *
 * DirectPlay8 Flags
 *
 ****************************************************************************/

//
// Asynchronous operation flags (For Async Ops)
//
#define DPNOP_SYNC							0x80000000

//
// Add player to group flags (For AddPlayerToGroup)
//
#define DPNADDPLAYERTOGROUP_SYNC			DPNOP_SYNC

//
// Cancel flags
//
#define	DPNCANCEL_CONNECT					0x0001
#define	DPNCANCEL_ENUM						0x0002
#define	DPNCANCEL_SEND						0x0004
#define	DPNCANCEL_ALL_OPERATIONS			0x8000

//
// Connect flags (For Connect)
//
#define	DPNCONNECT_SYNC						DPNOP_SYNC
#define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001

//
// Create group flags (For CreateGroup)
//
#define	DPNCREATEGROUP_SYNC					DPNOP_SYNC

//
// Destroy group flags (For DestroyGroup)
//
#define	DPNDESTROYGROUP_SYNC				DPNOP_SYNC

//
// Enumerate clients and groups flags (For EnumPlayersAndGroups)
//
#define DPNENUM_PLAYERS						0x0001
#define DPNENUM_GROUPS						0x0010

//
// Enum hosts flags (For EnumHosts)
//
#define	DPNENUMHOSTS_SYNC					DPNOP_SYNC
#define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
#define	DPNENUMHOSTS_NOBROADCASTFALLBACK	0x0002

//
// Enum service provider flags (For EnumSP)
//
#define DPNENUMSERVICEPROVIDERS_ALL			0x0001

//
// Get send queue info flags (For GetSendQueueInfo)
//
#define	DPNGETSENDQUEUEINFO_PRIORITY_NORMAL	0x0001
#define	DPNGETSENDQUEUEINFO_PRIORITY_HIGH	0x0002
#define	DPNGETSENDQUEUEINFO_PRIORITY_LOW	0x0004

//
// Group information flags (For Group Info)
//
#define DPNGROUP_AUTODESTRUCT				0x0001

//
// Host flags (For Host)
//
#define	DPNHOST_OKTOQUERYFORADDRESSING		0x0001

//
// Set info
//
#define	DPNINFO_NAME						0x0001
#define	DPNINFO_DATA						0x0002

//
// Initialize flags (For Initialize)
//
#define DPNINITIALIZE_DISABLEPARAMVAL		0x0001

//
// Register Lobby flags
//
#define	DPNLOBBY_REGISTER					0x0001
#define DPNLOBBY_UNREGISTER					0x0002

//
// Player information flags (For Player Info / Player Messages)
//
#define	DPNPLAYER_LOCAL						0x0002
#define	DPNPLAYER_HOST						0x0004

//
// Remove player from group flags (For RemovePlayerFromGroup)
//
#define	DPNREMOVEPLAYERFROMGROUP_SYNC		DPNOP_SYNC

//
// Send flags (For Send/SendTo)
//
#define DPNSEND_SYNC						DPNOP_SYNC
#define DPNSEND_NOCOPY						0x0001
#define DPNSEND_NOCOMPLETE					0x0002
#define DPNSEND_COMPLETEONPROCESS			0x0004
#define DPNSEND_GUARANTEED					0x0008
#define	DPNSEND_NONSEQUENTIAL				0x0010
#define DPNSEND_NOLOOPBACK					0x0020
#define	DPNSEND_PRIORITY_LOW				0x0040
#define	DPNSEND_PRIORITY_HIGH				0x0080

//
// Session Flags (for DPN_APPLICATION_DESC)
//
#define DPNSESSION_CLIENT_SERVER			0x0001
#define DPNSESSION_MIGRATE_HOST				0x0004
#define DPNSESSION_NODPNSVR					0x0040
#define DPNSESSION_REQUIREPASSWORD          0x0080

//
// Set client info flags (For SetClientInfo)
//
#define DPNSETCLIENTINFO_SYNC				DPNOP_SYNC

//
// Set group info flags (For SetGroupInfo)
//
#define DPNSETGROUPINFO_SYNC				DPNOP_SYNC

//
// Set peer info flags (For SetPeerInfo)
//
#define DPNSETPEERINFO_SYNC					DPNOP_SYNC

//
// Set server info flags (For SetServerInfo)
//
#define DPNSETSERVERINFO_SYNC				DPNOP_SYNC

//
// SP capabilities flags
//
#define	DPNSPCAPS_SUPPORTSDPNSRV			0x0001
#define	DPNSPCAPS_SUPPORTSBROADCAST			0x0002
#define	DPNSPCAPS_SUPPORTSALLADAPTERS		0x0004

/****************************************************************************
 *
 * DirectPlay8 Structures (Non-Message)
 *
 ****************************************************************************/

//
// Application description
//
typedef struct	_DPN_APPLICATION_DESC
{
	DWORD	dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags (DPNSESSION_...)
	GUID	guidInstance;					// Instance GUID
	GUID	guidApplication;				// Application GUID
	DWORD	dwMaxPlayers;					// Maximum # of players allowed (0=no limit)
	DWORD	dwCurrentPlayers;				// Current # of players allowed
	WCHAR	*pwszSessionName;				// Name of the session
	WCHAR	*pwszPassword;					// Password for the session
	PVOID	pvReservedData;					
	DWORD	dwReservedDataSize;
	PVOID	pvApplicationReservedData;
	DWORD	dwApplicationReservedDataSize;
} DPN_APPLICATION_DESC, *PDPN_APPLICATION_DESC;

//
// Generic Buffer Description
//
typedef struct	_BUFFERDESC
{
	DWORD	            dwBufferSize;		
	BYTE * UNALIGNED    pBufferData;		
} BUFFERDESC, DPN_BUFFER_DESC, *PDPN_BUFFER_DESC;

typedef BUFFERDESC	FAR * PBUFFERDESC;

//
// DirectPlay8 capabilities
//
typedef struct	_DPN_CAPS
{
    DWORD   dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags
    DWORD   dwConnectTimeout;				// ms before a connect request times out
    DWORD   dwConnectRetries;				// # of times to attempt the connection
    DWORD   dwTimeoutUntilKeepAlive;		// ms of inactivity before a keep alive is sent
} DPN_CAPS, *PDPN_CAPS;

// Connection Statistics information

typedef struct _DPN_CONNECTION_INFO
{
    DWORD   dwSize;
    DWORD   dwRoundTripLatencyMS;
    DWORD   dwThroughputBPS;
    DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

} DPN_CONNECTION_INFO, *PDPN_CONNECTION_INFO;

//
// Group information strucutre
//
typedef struct	_DPN_GROUP_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwGroupFlags;		// group flags (DPNGROUP_...)
} DPN_GROUP_INFO, *PDPN_GROUP_INFO;

//
// Player information structure
//
typedef struct	_DPN_PLAYER_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwPlayerFlags;		// player flags (DPNPLAYER_...)
} DPN_PLAYER_INFO, *PDPN_PLAYER_INFO;

typedef struct _DPN_SECURITY_CREDENTIALS	DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;
typedef struct _DPN_SECURITY_DESC			DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//
// Service provider & adapter enumeration structure
//
typedef struct _DPN_SERVICE_PROVIDER_INFO
{
	DWORD		dwFlags;
	GUID		guid;		// SP Guid
	WCHAR		*pwszName;	// Friendly Name
	PVOID		pvReserved;	
	DWORD		dwReserved;
} DPN_SERVICE_PROVIDER_INFO, *PDPN_SERVICE_PROVIDER_INFO;

//
// Service provider caps structure
//
typedef struct _DPN_SP_CAPS
{
	DWORD   dwSize;							// Size of this structure
	DWORD   dwFlags;						// Flags ((DPNSPCAPS_...)
	DWORD   dwNumThreads;					// # of worker threads to use
	DWORD	dwDefaultEnumCount;				// default # of enum requests
	DWORD	dwDefaultEnumRetryInterval;		// default ms between enum requests
	DWORD	dwDefaultEnumTimeout;			// default enum timeout
	DWORD	dwMaxEnumPayloadSize;			// maximum size in bytes for enum payload data
	DWORD	dwBuffersPerThread;				// number of receive buffers per thread
	DWORD	dwSystemBufferSize;				// amount of buffering to do in addition to posted receive buffers
} DPN_SP_CAPS, *PDPN_SP_CAPS;


/****************************************************************************
 *
 * IDirectPlay8 message handler call back structures
 *
 ****************************************************************************/

//
// Add player to group strucutre for message handler
// (DPN_MSGID_ADD_PLAYER_TO_GROUP)
//
typedef struct	_DPNMSG_ADD_PLAYER_TO_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of group
	PVOID	pvGroupContext;		// Group context value
	DPNID	dpnidPlayer;		// DPNID of added player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_ADD_PLAYER_TO_GROUP, *PDPNMSG_ADD_PLAYER_TO_GROUP;

//
// Async operation completion structure for message handler
// (DPN_MSGID_ASYNC_OP_COMPLETE)
//
typedef struct	_DPNMSG_ASYNC_OP_COMPLETE
{
	DWORD		dwSize;			// Size of this structure
	DPNHANDLE	hAsyncOp;		// DirectPlay8 async operation handle
	PVOID		pvUserContext;	// User context supplied
	HRESULT		hResultCode;	// HRESULT of operation
} DPNMSG_ASYNC_OP_COMPLETE, *PDPNMSG_ASYNC_OP_COMPLETE;

//
// Client info structure for message handler
// (DPN_MSGID_CLIENT_INFO)
//
typedef struct	_DPNMSG_CLIENT_INFO
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidClient;		// DPNID of client
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CLIENT_INFO, *PDPNMSG_CLIENT_INFO;

//
// Connect complete structure for message handler
// (DPN_MSGID_CONNECT_COMPLETE)
//
typedef struct	_DPNMSG_CONNECT_COMPLETE
{
	DWORD		dwSize;						// Size of this structure
	DPNHANDLE	hAsyncOp;					// DirectPlay8 Async operation handle
	PVOID		pvUserContext;				// User context supplied at Connect
	HRESULT		hResultCode;				// HRESULT of connection attempt
	PVOID		pvApplicationReplyData;		// Connection reply data from Host/Server
	DWORD		dwApplicationReplyDataSize;	// Size (in bytes) of pvApplicationReplyData
} DPNMSG_CONNECT_COMPLETE, *PDPNMSG_CONNECT_COMPLETE;

//
// Create group structure for message handler
// (DPN_MSGID_CREATE_GROUP)
//
typedef struct	_DPNMSG_CREATE_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of new group
	DPNID	dpnidOwner;			// Owner of newgroup
	PVOID	pvGroupContext;		// Group context value
} DPNMSG_CREATE_GROUP, *PDPNMSG_CREATE_GROUP;

//
// Create player structure for message handler
// (DPN_MSGID_CREATE_PLAYER)
//
typedef struct	_DPNMSG_CREATE_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of new player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CREATE_PLAYER, *PDPNMSG_CREATE_PLAYER;

//
// Destroy group structure for message handler
// (DPN_MSGID_DESTROY_GROUP)
//
typedef struct	_DPNMSG_DESTROY_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of destroyed group
	PVOID	pvGroupContext;		// Group context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_GROUP, *PDPNMSG_DESTROY_GROUP;

//
// Destroy player structure for message handler
// (DPN_MSGID_DESTROY_PLAYER)
//
typedef struct	_DPNMSG_DESTROY_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of leaving player
	PVOID	pvPlayerContext;	// Player context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER;

//
// Enumeration request received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_QUERY)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_QUERY
{
	DWORD				dwSize;                 // Size of this structure.
	IDirectPlay8Address *pAddressSender;        // Address of client who sent the request
	IDirectPlay8Address	*pAddressDevice;        // Address of device request was received on
	PVOID				pvReceivedData;         // Request data (set on client)
	DWORD				dwReceivedDataSize;     // Request data size (set on client)
	DWORD				dwMaxResponseDataSize;	// Max allowable size of enum response
	PVOID				pvResponseData;		    // Optional query repsonse (user set)
	DWORD				dwResponseDataSize;	    // Optional query response size (user set)
	PVOID				pvResponseContext;	    // Optional query response context (user set)
} DPNMSG_ENUM_HOSTS_QUERY, *PDPNMSG_ENUM_HOSTS_QUERY;

//
// Enumeration response received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_RESPONSE)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_RESPONSE
{
	DWORD						dwSize;                     // Size of this structure
	IDirectPlay8Address			*pAddressSender;            // Address of host who responded
	IDirectPlay8Address			*pAddressDevice;            // Device response was received on
	const DPN_APPLICATION_DESC	*pApplicationDescription;   // Application description for the session
	PVOID						pvResponseData;             // Optional response data (set on host)
	DWORD						dwResponseDataSize;         // Optional response data size (set on host)
	PVOID						pvUserContext;              // Context value supplied for enumeration
    DWORD						dwRoundTripLatencyMS;       // Round trip latency in MS
} DPNMSG_ENUM_HOSTS_RESPONSE, *PDPNMSG_ENUM_HOSTS_RESPONSE;

//
// Group info structure for message handler
// (DPN_MSGID_GROUP_INFO)
//
typedef struct	_DPNMSG_GROUP_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidGroup;			    // DPNID of group
	PVOID	pvGroupContext;		    // Group context value
} DPNMSG_GROUP_INFO, *PDPNMSG_GROUP_INFO;

//
// Migrate host structure for message handler
// (DPN_MSGID_HOST_MIGRATE)
//
typedef struct	_DPNMSG_HOST_MIGRATE
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidNewHost;		    // DPNID of new Host player
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_HOST_MIGRATE, *PDPNMSG_HOST_MIGRATE;

//
// Indicate connect structure for message handler
// (DPN_MSGID_INDICATE_CONNECT)
//
typedef struct	_DPNMSG_INDICATE_CONNECT
{
	DWORD		dwSize;					// Size of this structure
	PVOID		pvUserConnectData;		// Connecting player data
	DWORD		dwUserConnectDataSize;	// Size (in bytes) of pvUserConnectData
	PVOID		pvReplyData;			// Connection reply data
	DWORD		dwReplyDataSize;		// Size (in bytes) of pvReplyData
	PVOID		pvReplyContext;			// Buffer context for pvReplyData
	PVOID		pvPlayerContext;		// Player context preset
	IDirectPlay8Address	*pAddressPlayer;// Address of connecting player
	IDirectPlay8Address	*pAddressDevice;// Address of device receiving connect attempt
} DPNMSG_INDICATE_CONNECT, *PDPNMSG_INDICATE_CONNECT;

//
// Indicated connect aborted structure for message handler
// (DPN_MSGID_INDICATED_CONNECT_ABORTED)
//
typedef struct	_DPNMSG_INDICATED_CONNECT_ABORTED
{
	DWORD		dwSize;				// Size of this structure
	PVOID		pvPlayerContext;	// Player context preset from DPNMSG_INDICATE_CONNECT
} DPNMSG_INDICATED_CONNECT_ABORTED, *PDPNMSG_INDICATED_CONNECT_ABORTED;

//
// Peer info structure for message handler
// (DPN_MSGID_PEER_INFO)
//
typedef struct	_DPNMSG_PEER_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidPeer;			    // DPNID of peer
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_PEER_INFO, *PDPNMSG_PEER_INFO;

//
// Receive structure for message handler
// (DPN_MSGID_RECEIVE)
//
typedef struct	_DPNMSG_RECEIVE
{
	DWORD		dwSize;				// Size of this structure
	DPNID		dpnidSender;		// DPNID of sending player
	PVOID		pvPlayerContext;	// Player context value of sending player
	PBYTE		pReceiveData;		// Received data
	DWORD		dwReceiveDataSize;	// Size (in bytes) of pReceiveData
	DPNHANDLE	hBufferHandle;		// Buffer handle for pReceiveData
} DPNMSG_RECEIVE, *PDPNMSG_RECEIVE;

//
// Remove player from group structure for message handler
// (DPN_MSGID_REMOVE_PLAYER_FROM_GROUP)
//
typedef struct	_DPNMSG_REMOVE_PLAYER_FROM_GROUP
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidGroup;			    // DPNID of group
	PVOID	pvGroupContext;		    // Group context value
	DPNID	dpnidPlayer;		    // DPNID of deleted player
	PVOID	pvPlayerContext;    	// Player context value
} DPNMSG_REMOVE_PLAYER_FROM_GROUP, *PDPNMSG_REMOVE_PLAYER_FROM_GROUP;

//
// Returned buffer structure for message handler
// (DPN_MSGID_RETURN_BUFFER)
//
typedef struct	_DPNMSG_RETURN_BUFFER
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Return value of operation
	PVOID		pvBuffer;			// Buffer being returned
	PVOID		pvUserContext;		// Context associated with buffer
} DPNMSG_RETURN_BUFFER, *PDPNMSG_RETURN_BUFFER;

//
// Send complete structure for message handler
// (DPN_MSGID_SEND_COMPLETE)
//
typedef struct	_DPNMSG_SEND_COMPLETE
{
	DWORD		dwSize;				// Size of this structure
	DPNHANDLE	hAsyncOp;			// DirectPlay8 Async operation handle
	PVOID		pvUserContext;		// User context supplied at Send/SendTo
	HRESULT		hResultCode;		// HRESULT of send
	DWORD		dwSendTime;			// Send time in ms
} DPNMSG_SEND_COMPLETE, *PDPNMSG_SEND_COMPLETE;

//
// Server info structure for message handler
// (DPN_MSGID_SERVER_INFO)
//
typedef struct	_DPNMSG_SERVER_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidServer;		    // DPNID of server
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_SERVER_INFO, *PDPNMSG_SERVER_INFO;

//
// Terminated session structure for message handler
// (DPN_MSGID_TERMINATE_SESSION)
//
typedef struct	_DPNMSG_TERMINATE_SESSION
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Reason
	PVOID		pvTerminateData;	// Data passed from Host/Server
	DWORD		dwTerminateDataSize;// Size (in bytes) of pvTerminateData
} DPNMSG_TERMINATE_SESSION, *PDPNMSG_TERMINATE_SESSION;


/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for DirectPlay8 Client interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Client
DECLARE_INTERFACE_(IDirectPlay8Client,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Client methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetClientInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetServerInfo)			(THIS_ DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetServerAddress)			(THIS_ IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
};

//
// COM definition for DirectPlay8 Server interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Server
DECLARE_INTERFACE_(IDirectPlay8Server,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Server methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetServerInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetClientInfo)			(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetClientAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(DestroyClient)			(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
};

//
// COM definition for DirectPlay8 Peer interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Peer
DECLARE_INTERFACE_(IDirectPlay8Peer,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Peer methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(SetPeerInfo)				(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerInfo)				(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyPeer)				(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
	STDMETHOD(TerminateSession)			(THIS_ void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags) PURE;
};


/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define	IDirectPlay8Client_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Client_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Client_Release(p)							(p)->lpVtbl->Release(p)
#define	IDirectPlay8Client_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Client_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)		(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j)
#define	IDirectPlay8Client_Send(p,a,b,c,d,e,f)					(p)->lpVtbl->Send(p,a,b,c,d,e,f)
#define	IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c)
#define	IDirectPlay8Client_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Client_SetClientInfo(p,a,b,c,d)				(p)->lpVtbl->SetClientInfo(p,a,b,c,d)
#define	IDirectPlay8Client_GetServerInfo(p,a,b,c)				(p)->lpVtbl->GetServerInfo(p,a,b,c)
#define	IDirectPlay8Client_GetServerAddress(p,a,b)				(p)->lpVtbl->GetServerAddress(p,a,b)
#define	IDirectPlay8Client_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Client_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Client_GetCaps(p,a,b)						(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Client_SetCaps(p,a,b)						(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Client_SetSPCaps(p,a,b,c)					(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Client_GetSPCaps(p,a,b,c)					(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Client_GetConnectionInfo(p,a,b)				(p)->lpVtbl->GetConnectionInfo(p,a,b)
#define	IDirectPlay8Client_RegisterLobby(p,a,b,c)				(p)->lpVtbl->RegisterLobby(p,a,b,c)

#define	IDirectPlay8Server_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Server_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Server_Release(p)							(p)->lpVtbl->Release(p)
#define	IDirectPlay8Server_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Server_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Server_SetServerInfo(p,a,b,c,d)				(p)->lpVtbl->SetServerInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetClientInfo(p,a,b,c,d)				(p)->lpVtbl->GetClientInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetClientAddress(p,a,b,c)			(p)->lpVtbl->GetClientAddress(p,a,b,c)
#define	IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)		(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define	IDirectPlay8Server_SetApplicationDesc(p,a,b)			(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define	IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)				(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)				(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)				(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_DestroyGroup(p,a,b,c,d)				(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define	IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)		(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)	(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)			(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define	IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)				(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define	IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)		(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define	IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)			(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define	IDirectPlay8Server_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Server_DestroyClient(p,a,b,c,d)				(p)->lpVtbl->DestroyClient(p,a,b,c,d)
#define	IDirectPlay8Server_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Server_GetPlayerContext(p,a,b,c)			(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define	IDirectPlay8Server_GetGroupContext(p,a,b,c)				(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define	IDirectPlay8Server_GetCaps(p,a,b)						(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Server_SetCaps(p,a,b)						(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Server_SetSPCaps(p,a,b,c)					(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Server_GetSPCaps(p,a,b,c)					(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Server_GetConnectionInfo(p,a,b,c)			(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define	IDirectPlay8Server_RegisterLobby(p,a,b,c)				(p)->lpVtbl->RegisterLobby(p,a,b,c)

#define	IDirectPlay8Peer_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Peer_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Peer_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlay8Peer_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)

#define	IDirectPlay8Peer_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)				(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)					(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Peer_SetApplicationDesc(p,a,b)				(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define	IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)				(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)				(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define	IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)			(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)				(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define	IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)				(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)			(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define	IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)			(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define	IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)					(p)->lpVtbl->SetPeerInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)					(p)->lpVtbl->GetPeerInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_GetPeerAddress(p,a,b,c)				(p)->lpVtbl->GetPeerAddress(p,a,b,c)
#define	IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)			(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define	IDirectPlay8Peer_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	    (p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)					(p)->lpVtbl->DestroyPeer(p,a,b,c,d)
#define	IDirectPlay8Peer_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Peer_GetPlayerContext(p,a,b,c)				(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define	IDirectPlay8Peer_GetGroupContext(p,a,b,c)				(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define	IDirectPlay8Peer_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Peer_SetCaps(p,a,b)							(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Peer_SetSPCaps(p,a,b,c)						(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Peer_GetSPCaps(p,a,b,c)						(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)				(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define	IDirectPlay8Peer_RegisterLobby(p,a,b,c)				    (p)->lpVtbl->RegisterLobby(p,a,b,c)
#define	IDirectPlay8Peer_TerminateSession(p,a,b,c)				(p)->lpVtbl->TerminateSession(p,a,b,c)

#else /* C++ */

#define	IDirectPlay8Client_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define	IDirectPlay8Client_AddRef(p)							(p)->AddRef()
#define	IDirectPlay8Client_Release(p)							(p)->Release()
#define	IDirectPlay8Client_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Client_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)		(p)->Connect(a,b,c,d,e,f,g,h,i,j)
#define	IDirectPlay8Client_Send(p,a,b,c,d,e,f)					(p)->Send(a,b,c,d,e,f)
#define	IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)			(p)->GetSendQueueInfo(a,b,c)
#define	IDirectPlay8Client_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Client_SetClientInfo(p,a,b,c,d)				(p)->SetClientInfo(a,b,c,d)
#define	IDirectPlay8Client_GetServerInfo(p,a,b,c)				(p)->GetServerInfo(a,b,c)
#define	IDirectPlay8Client_GetServerAddress(p,a,b)				(p)->GetServerAddress(a,b)
#define	IDirectPlay8Client_Close(p,a)							(p)->Close(a)
#define	IDirectPlay8Client_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Client_GetCaps(p,a,b)						(p)->GetCaps(a,b)
#define	IDirectPlay8Client_SetCaps(p,a,b)						(p)->SetCaps(a,b)
#define	IDirectPlay8Client_SetSPCaps(p,a,b,c)					(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Client_GetSPCaps(p,a,b,c)					(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Client_GetConnectionInfo(p,a,b)				(p)->GetConnectionInfo(a,b)
#define	IDirectPlay8Client_RegisterLobby(p,a,b,c)				(p)->RegisterLobby(a,b,c)

#define	IDirectPlay8Server_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define	IDirectPlay8Server_AddRef(p)							(p)->AddRef()
#define	IDirectPlay8Server_Release(p)							(p)->Release()
#define	IDirectPlay8Server_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Server_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)			(p)->GetSendQueueInfo(a,b,c,d)
#define	IDirectPlay8Server_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Server_SetServerInfo(p,a,b,c,d)				(p)->SetServerInfo(a,b,c,d)
#define	IDirectPlay8Server_GetClientInfo(p,a,b,c,d)				(p)->GetClientInfo(a,b,c,d)
#define	IDirectPlay8Server_GetClientAddress(p,a,b,c)			(p)->GetClientAddress(a,b,c)
#define	IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)		(p)->GetLocalHostAddresses(a,b,c)
#define	IDirectPlay8Server_SetApplicationDesc(p,a,b)			(p)->SetApplicationDesc(a,b)
#define	IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)				(p)->Host(a,b,c,d,e,f,g)
#define	IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)				(p)->SendTo(a,b,c,d,e,f,g)
#define	IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)				(p)->CreateGroup(a,b,c,d,e)
#define	IDirectPlay8Server_DestroyGroup(p,a,b,c,d)				(p)->DestroyGroup(a,b,c,d)
#define	IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)		(p)->AddPlayerToGroup(a,b,c,d,e)
#define	IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)	(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define	IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)			(p)->SetGroupInfo(a,b,c,d,e)
#define	IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)				(p)->GetGroupInfo(a,b,c,d)
#define	IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)		(p)->EnumPlayersAndGroups(a,b,c)
#define	IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)			(p)->EnumGroupMembers(a,b,c,d)
#define	IDirectPlay8Server_Close(p,a)							(p)->Close(a)
#define	IDirectPlay8Server_DestroyClient(p,a,b,c,d)				(p)->DestroyClient(a,b,c,d)
#define	IDirectPlay8Server_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Server_GetPlayerContext(p,a,b,c)			(p)->GetPlayerContext(a,b,c)
#define	IDirectPlay8Server_GetGroupContext(p,a,b,c)				(p)->GetGroupContext(a,b,c)
#define	IDirectPlay8Server_GetCaps(p,a,b)						(p)->GetCaps(a,b)
#define	IDirectPlay8Server_SetCaps(p,a,b)						(p)->SetCaps(a,b)
#define	IDirectPlay8Server_SetSPCaps(p,a,b,c)					(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Server_GetSPCaps(p,a,b,c)					(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Server_GetConnectionInfo(p,a,b,c)			(p)->GetConnectionInfo(a,b,c)
#define	IDirectPlay8Server_RegisterLobby(p,a,b,c)				(p)->RegisterLobby(a,b,c)

#define	IDirectPlay8Peer_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlay8Peer_AddRef(p)								(p)->AddRef()
#define	IDirectPlay8Peer_Release(p)								(p)->Release()
#define	IDirectPlay8Peer_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->Connect(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)				(p)->SendTo(a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)			(p)->GetSendQueueInfo(a,b,c,d)
#define	IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)					(p)->Host(a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Peer_SetApplicationDesc(p,a,b)				(p)->SetApplicationDesc(a,b)
#define	IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)				(p)->CreateGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)				(p)->DestroyGroup(a,b,c,d)
#define	IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)			(p)->AddPlayerToGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)				(p)->SetGroupInfo(a,b,c,d,e)
#define	IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)				(p)->GetGroupInfo(a,b,c,d)
#define	IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)			(p)->EnumPlayersAndGroups(a,b,c)
#define	IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)			(p)->EnumGroupMembers(a,b,c,d)
#define	IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)					(p)->SetPeerInfo(a,b,c,d)
#define	IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)					(p)->GetPeerInfo(a,b,c,d)
#define	IDirectPlay8Peer_GetPeerAddress(p,a,b,c)				(p)->GetPeerAddress(a,b,c)
#define	IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)			(p)->GetLocalHostAddresses(a,b,c)
#define	IDirectPlay8Peer_Close(p,a)								(p)->Close(a)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	    (p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)					(p)->DestroyPeer(a,b,c,d)
#define	IDirectPlay8Peer_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Peer_GetPlayerContext(p,a,b,c)				(p)->GetPlayerContext(a,b,c)
#define	IDirectPlay8Peer_GetGroupContext(p,a,b,c)				(p)->GetGroupContext(a,b,c)
#define	IDirectPlay8Peer_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlay8Peer_SetCaps(p,a,b)							(p)->SetCaps(a,b)
#define	IDirectPlay8Peer_SetSPCaps(p,a,b,c)						(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Peer_GetSPCaps(p,a,b,c)						(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)				(p)->GetConnectionInfo(a,b,c)
#define	IDirectPlay8Peer_RegisterLobby(p,a,b,c)					(p)->RegisterLobby(a,b,c)
#define	IDirectPlay8Peer_TerminateSession(p,a,b,c)				(p)->TerminateSession(a,b,c)

#endif

/****************************************************************************
 *
 * DIRECTPLAY8 ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPN_FACILITY_CODE	0x015
#define _DPNHRESULT_BASE		0x8000
#define MAKE_DPNHRESULT( code )			MAKE_HRESULT( 1, _DPN_FACILITY_CODE, ( code + _DPNHRESULT_BASE ) )

#define DPN_OK							S_OK

#define DPNSUCCESS_EQUAL                MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x5 + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_NOTEQUAL             MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0A + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_PENDING				MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0e + _DPNHRESULT_BASE ) )

#define DPNERR_ABORTED					MAKE_DPNHRESULT(  0x30 )
#define DPNERR_ADDRESSING				MAKE_DPNHRESULT(  0x40 )
#define	DPNERR_ALREADYCLOSING			MAKE_DPNHRESULT(  0x50 )
#define DPNERR_ALREADYCONNECTED			MAKE_DPNHRESULT(  0x60 )
#define DPNERR_ALREADYDISCONNECTING		MAKE_DPNHRESULT(  0x70 )
#define DPNERR_ALREADYINITIALIZED		MAKE_DPNHRESULT(  0x80 )
#define DPNERR_ALREADYREGISTERED		MAKE_DPNHRESULT(  0x90 )
#define DPNERR_BUFFERTOOSMALL			MAKE_DPNHRESULT( 0x100 )
#define DPNERR_CANNOTCANCEL				MAKE_DPNHRESULT( 0x110 )
#define DPNERR_CANTCREATEGROUP			MAKE_DPNHRESULT( 0x120 )
#define DPNERR_CANTCREATEPLAYER			MAKE_DPNHRESULT( 0x130 )
#define DPNERR_CANTLAUNCHAPPLICATION	MAKE_DPNHRESULT( 0x140 )
#define DPNERR_CONNECTING				MAKE_DPNHRESULT( 0x150 )
#define DPNERR_CONNECTIONLOST			MAKE_DPNHRESULT( 0x160 )
#define DPNERR_CONVERSION				MAKE_DPNHRESULT( 0x170 )
#define	DPNERR_DATATOOLARGE				MAKE_DPNHRESULT( 0x175 )
#define DPNERR_DOESNOTEXIST				MAKE_DPNHRESULT( 0x180 )
#define DPNERR_DUPLICATECOMMAND			MAKE_DPNHRESULT( 0x190 )
#define DPNERR_ENDPOINTNOTRECEIVING		MAKE_DPNHRESULT( 0x200 )
#define	DPNERR_ENUMQUERYTOOLARGE		MAKE_DPNHRESULT( 0x210 )
#define	DPNERR_ENUMRESPONSETOOLARGE		MAKE_DPNHRESULT( 0x220 )
#define DPNERR_EXCEPTION				MAKE_DPNHRESULT( 0x230 )
#define DPNERR_GENERIC					E_FAIL
#define DPNERR_GROUPNOTEMPTY			MAKE_DPNHRESULT( 0x240 )
#define DPNERR_HOSTING                  MAKE_DPNHRESULT( 0x250 )
#define DPNERR_HOSTREJECTEDCONNECTION	MAKE_DPNHRESULT( 0x260 )
#define DPNERR_HOSTTERMINATEDSESSION	MAKE_DPNHRESULT( 0x270 )
#define DPNERR_INCOMPLETEADDRESS		MAKE_DPNHRESULT( 0x280 )
#define DPNERR_INVALIDADDRESSFORMAT		MAKE_DPNHRESULT( 0x290 )
#define DPNERR_INVALIDAPPLICATION		MAKE_DPNHRESULT( 0x300 )
#define DPNERR_INVALIDCOMMAND			MAKE_DPNHRESULT( 0x310 )
#define DPNERR_INVALIDDEVICEADDRESS		MAKE_DPNHRESULT( 0x320 )
#define DPNERR_INVALIDENDPOINT			MAKE_DPNHRESULT( 0x330 )
#define DPNERR_INVALIDFLAGS				MAKE_DPNHRESULT( 0x340 )
#define DPNERR_INVALIDGROUP			 	MAKE_DPNHRESULT( 0x350 )
#define DPNERR_INVALIDHANDLE			MAKE_DPNHRESULT( 0x360 )
#define DPNERR_INVALIDHOSTADDRESS		MAKE_DPNHRESULT( 0x370 )
#define DPNERR_INVALIDINSTANCE			MAKE_DPNHRESULT( 0x380 )
#define DPNERR_INVALIDINTERFACE			MAKE_DPNHRESULT( 0x390 )
#define DPNERR_INVALIDOBJECT			MAKE_DPNHRESULT( 0x400 )
#define DPNERR_INVALIDPARAM				E_INVALIDARG
#define DPNERR_INVALIDPASSWORD			MAKE_DPNHRESULT( 0x410 )
#define DPNERR_INVALIDPLAYER			MAKE_DPNHRESULT( 0x420 )
#define DPNERR_INVALIDPOINTER			E_POINTER
#define DPNERR_INVALIDPRIORITY			MAKE_DPNHRESULT( 0x430 )
#define DPNERR_INVALIDSTRING			MAKE_DPNHRESULT( 0x440 )
#define DPNERR_INVALIDURL				MAKE_DPNHRESULT( 0x450 )
#define	DPNERR_INVALIDVERSION			MAKE_DPNHRESULT( 0x460 )
#define DPNERR_NOCAPS					MAKE_DPNHRESULT( 0x470 )
#define DPNERR_NOCONNECTION				MAKE_DPNHRESULT( 0x480 )
#define DPNERR_NOHOSTPLAYER				MAKE_DPNHRESULT( 0x490 )
#define DPNERR_NOINTERFACE				E_NOINTERFACE
#define DPNERR_NOMOREADDRESSCOMPONENTS	MAKE_DPNHRESULT( 0x500 )
#define DPNERR_NORESPONSE				MAKE_DPNHRESULT( 0x510 )
#define DPNERR_NOTALLOWED				MAKE_DPNHRESULT( 0x520 )
#define DPNERR_NOTHOST					MAKE_DPNHRESULT( 0x530 )
#define DPNERR_NOTREADY					MAKE_DPNHRESULT( 0x540 )
#define DPNERR_NOTREGISTERED			MAKE_DPNHRESULT( 0x550 )
#define DPNERR_OUTOFMEMORY				E_OUTOFMEMORY
#define DPNERR_PENDING					DPNSUCCESS_PENDING
#define DPNERR_PLAYERALREADYINGROUP     MAKE_DPNHRESULT( 0x560 )
#define DPNERR_PLAYERLOST				MAKE_DPNHRESULT( 0x570 )
#define DPNERR_PLAYERNOTINGROUP         MAKE_DPNHRESULT( 0x580 )
#define	DPNERR_PLAYERNOTREACHABLE		MAKE_DPNHRESULT( 0x590 )
#define DPNERR_SENDTOOLARGE				MAKE_DPNHRESULT( 0x600 )
#define DPNERR_SESSIONFULL				MAKE_DPNHRESULT( 0x610 )
#define DPNERR_TABLEFULL				MAKE_DPNHRESULT( 0x620 )
#define DPNERR_TIMEDOUT					MAKE_DPNHRESULT( 0x630 )
#define DPNERR_UNINITIALIZED			MAKE_DPNHRESULT( 0x640 )
#define DPNERR_UNSUPPORTED				E_NOTIMPL
#define DPNERR_USERCANCEL				MAKE_DPNHRESULT( 0x650 )

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dprintf.h ===
//===============================================================
//  MODULE: dprintf()
//
//  HISTORY:
//  Tom McConnell   01/18/93    Created.
//  raypa           07/09/93    ifdef DEBUG.
//===============================================================

#include <string.h>
#include <stdio.h>
#include <windows.h>

#ifdef DEBUG

//===============================================================
//  dprintf()
//	
//  Handles dumping info to OutputDebugString
//
//  HISTORY:
//
//  Tom McConnell   1/18/93     Created
//===============================================================

static void dprintf(char *format, ...)
{
  va_list args;
  char    buffer[255];

  va_start(args,format);

  strcpy(buffer + vsprintf(buffer,format,args), "\r\n");

  OutputDebugString(buffer);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dplobby.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.h
 *  Content:    DirectPlayLobby include file
 ***************************************************************************/
#ifndef __DPLOBBY_INCLUDED__
#define __DPLOBBY_INCLUDED__

#include "dplay.h"

/* avoid warnings at Level 4 */
#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * GUIDS used by DirectPlay objects
 */

/* {AF465C71-9588-11cf-A020-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {26C66A70-B367-11cf-A024-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {0194C220-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {1BB4AF80-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {2DB72490-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2DB72491-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2FE8F810-B2A5-11d0-A787-0000F803ABFC} */
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);


/****************************************************************************
 *
 * IDirectPlayLobby Structures
 *
 * Various structures used to invoke DirectPlayLobby.
 *
 ****************************************************************************/

typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBY;
typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBYA;
typedef struct IDirectPlayLobby     IDirectPlayLobbyA;

typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2;
typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2A;
typedef struct IDirectPlayLobby2    IDirectPlayLobby2A;

typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3;
typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3A;
typedef struct IDirectPlayLobby3    IDirectPlayLobby3A;


/*
 * DPLAPPINFO
 * Used to hold information about a registered DirectPlay
 * application
 */
typedef struct DPLAPPINFO
{
    DWORD       dwSize;             // Size of this structure
    GUID        guidApplication;    // GUID of the Application
    union
    {
        LPSTR   lpszAppNameA;       // Pointer to the Application Name
        LPWSTR  lpszAppName;
    };

} DPLAPPINFO, FAR *LPDPLAPPINFO;

/*
 * LPCDPLAPPINFO
 * A constant pointer to DPLAPPINFO
 */
typedef const DPLAPPINFO FAR *LPCDPLAPPINFO;

/*
 * DPCOMPOUNDADDRESSELEMENT
 *
 * An array of these is passed to CreateCompoundAddresses()
 */
typedef struct DPCOMPOUNDADDRESSELEMENT
{
    GUID                guidDataType;
    DWORD               dwDataSize;
	LPVOID				lpData;
} DPCOMPOUNDADDRESSELEMENT, FAR *LPDPCOMPOUNDADDRESSELEMENT;

/*
 * LPCDPCOMPOUNDADDRESSELEMENT
 * A constant pointer to DPCOMPOUNDADDRESSELEMENT
 */
typedef const DPCOMPOUNDADDRESSELEMENT FAR *LPCDPCOMPOUNDADDRESSELEMENT;

/*
 * LPDPAPPLICATIONDESC
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
} DPAPPLICATIONDESC, *LPDPAPPLICATIONDESC;

/*
 * LPDPAPPLICATIONDESC2
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC2
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
    union
    {
    	LPSTR		lpszAppLauncherNameA;
    	LPWSTR      lpszAppLauncherName;
    };
} DPAPPLICATIONDESC2, *LPDPAPPLICATIONDESC2;


/****************************************************************************
 *
 * Enumeration Method Callback Prototypes
 *
 ****************************************************************************/

/*
 * Callback for EnumAddress()
 */
typedef BOOL (FAR PASCAL *LPDPENUMADDRESSCALLBACK)(
    REFGUID         guidDataType,
    DWORD           dwDataSize,
    LPCVOID         lpData,
    LPVOID          lpContext);

/*
 * Callback for EnumAddressTypes()
 */
typedef BOOL (FAR PASCAL *LPDPLENUMADDRESSTYPESCALLBACK)(
    REFGUID         guidDataType,
    LPVOID          lpContext,
    DWORD           dwFlags);

/*
 * Callback for EnumLocalApplications()
 */
typedef BOOL (FAR PASCAL * LPDPLENUMLOCALAPPLICATIONSCALLBACK)(
    LPCDPLAPPINFO   lpAppInfo,
    LPVOID          lpContext,
    DWORD           dwFlags);


/****************************************************************************
 *
 * DirectPlayLobby API Prototypes
 *
 ****************************************************************************/
#ifdef UNICODE
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateW
#else
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateA
#endif /* UNICODE */

extern HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID, LPDIRECTPLAYLOBBYA *, IUnknown *, LPVOID, DWORD );


/****************************************************************************
 *
 * IDirectPlayLobby (and IDirectPlayLobbyA) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby
DECLARE_INTERFACE_( IDirectPlayLobby, IUnknown )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

};

/****************************************************************************
 *
 * IDirectPlayLobby2 (and IDirectPlayLobby2A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby2
DECLARE_INTERFACE_( IDirectPlayLobby2, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby3 (and IDirectPlayLobby3A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby3
DECLARE_INTERFACE_( IDirectPlayLobby3, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;

    /*  IDirectPlayLobby3 Methods	*/
    STDMETHOD(ConnectEx)            (THIS_ DWORD, REFIID, LPVOID *, IUnknown FAR *) PURE;
    STDMETHOD(RegisterApplication)  (THIS_ DWORD, LPVOID) PURE;
    STDMETHOD(UnregisterApplication)(THIS_ DWORD, REFGUID) PURE;
    STDMETHOD(WaitForConnectionSettings)(THIS_ DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IDirectPlayLobby_Release(p)                         (p)->lpVtbl->Release(p)
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->lpVtbl->ConnectEx(p,a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->lpVtbl->CreateAddress(p,a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->lpVtbl->EnumAddressTypes(p,a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->lpVtbl->EnumLocalApplications(p,a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->lpVtbl->GetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->lpVtbl->ReceiveLobbyMessage(p,a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->lpVtbl->RegisterApplication(p,a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->lpVtbl->RunApplication(p,a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->lpVtbl->SendLobbyMessage(p,a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->lpVtbl->SetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->lpVtbl->SetLobbyMessageEvent(p,a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->lpVtbl->UnregisterApplication(p,a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->lpVtbl->WaitForConnectionSettings(p,a)

#else /* C++ */

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->QueryInterface(a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->AddRef()
#define IDirectPlayLobby_Release(p)                         (p)->Release()
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->Connect(a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->ConnectEx(a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->CreateAddress(a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->CreateCompoundAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->EnumAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->EnumAddressTypes(a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->EnumLocalApplications(a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->GetConnectionSettings(a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->ReceiveLobbyMessage(a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->RegisterApplication(a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->RunApplication(a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->SendLobbyMessage(a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->SetConnectionSettings(a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->SetLobbyMessageEvent(a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->UnregisterApplication(a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->WaitForConnectionSettings(a)

#endif

/****************************************************************************
 *
 * DirectPlayLobby Flags
 *
 ****************************************************************************/

/*
 *	This flag is used by IDirectPlayLobby->WaitForConnectionSettings to
 *	cancel a current wait that is in progress.
 */
#define DPLWAIT_CANCEL                  0x00000001


/*
 *	This is a message flag used by ReceiveLobbyMessage.  It can be
 *	returned in the dwMessageFlags parameter to indicate a message from
 *	the system.
 */
#define DPLMSG_SYSTEM					0x00000001

/*
 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
 *  It is used to indicate that the message is a standard lobby message.
 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
 *	DPLMSG_GETPROPERTYRESPONSE
 */
#define DPLMSG_STANDARD					0x00000002

/*
 *  Lobbyable Application registration flags
 */

/*
 *  Applications registered with this flag will not show up when
 *  applications are enumerated in the lobby.  This application
 *  will only be able to be launched by a lobby client that already
 *  knows about the application.
 */
#define DPLAPP_NOENUM					0x80000000

/*
 *  Applications registered with this flag want voice to automatically
 *  be enabled for their application.  All players will be launched into
 *  an 'n'-way voice conference when the application is started.  The 
 *  user will be able to enable this flag for existing non-voice 
 *  directplay applications.
 */
#define DPLAPP_AUTOVOICE				0x00000001 

/*
 * Applications that do their own voice conferencing should register with
 * this flag to avoid allowing the user to enable other voice chat 
 * capabilites during the same session.  This is to avoid users forcing
 * the DPLAPP_AUTOVOICE flag for the application.
 */
#define DPLAPP_SELFVOICE				0x00000002 

/****************************************************************************
 *
 * DirectPlayLobby messages and message data structures
 *
 * All system messages have a dwMessageFlags value of DPLMSG_SYSTEM returned
 * from a call to ReceiveLobbyMessage.
 *
 * All standard messages have a dwMessageFlags value of DPLMSG_STANDARD returned
 * from a call to ReceiveLobbyMessage.
 *
 ****************************************************************************/

/*
 * DPLMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPLMSG_GENERIC
{
    DWORD       dwType;         // Message type
} DPLMSG_GENERIC, FAR *LPDPLMSG_GENERIC;

/*
 * DPLMSG_SYSTEMMESSAGE
 * Generic message format for all system messages --
 * DPLSYS_CONNECTIONSETTINGSREAD, DPLSYS_DPLYCONNECTSUCCEEDED,
 * DPLSYS_DPLAYCONNECTFAILED, DPLSYS_APPTERMINATED, DPLSYS_NEWCONNECTIONSETTINGS
 */
typedef struct _DPLMSG_SYSTEMMESSAGE
{
    DWORD       dwType;         // Message type
    GUID        guidInstance;   // Instance GUID of the dplay session the message corresponds to
} DPLMSG_SYSTEMMESSAGE, FAR *LPDPLMSG_SYSTEMMESSAGE;

/*
 *  DPLMSG_SETPROPERTY
 *  Standard message sent by an application to a lobby to set a
 *  property
 */
typedef struct _DPLMSG_SETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID (DPL_NOCONFIRMATION if no confirmation desired)
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_SETPROPERTY, FAR *LPDPLMSG_SETPROPERTY;

#define	DPL_NOCONFIRMATION			0

/*
 *  DPLMSG_SETPROPERTYRESPONSE
 *  Standard message returned by a lobby to confirm a 
 *  DPLMSG_SETPROPERTY message.
 */
typedef struct _DPLMSG_SETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
} DPLMSG_SETPROPERTYRESPONSE, FAR *LPDPLMSG_SETPROPERTYRESPONSE;

/*
 *  DPLMSG_GETPROPERTY
 *  Standard message sent by an application to a lobby to request
 *	the current value of a property
 */
typedef struct _DPLMSG_GETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
} DPLMSG_GETPROPERTY, FAR *LPDPLMSG_GETPROPERTY;

/*
 *  DPLMSG_GETPROPERTYRESPONSE
 *  Standard message returned by a lobby in response to a
 *	DPLMSG_GETPROPERTY message.
 */
typedef struct _DPLMSG_GETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_GETPROPERTYRESPONSE, FAR *LPDPLMSG_GETPROPERTYRESPONSE;

/*
 *  DPLMSG_NEWSESSIONHOST
 *  Standard message returned by a lobby in response to a
 *	the session host migrating to a new client
 */
typedef struct _DPLMSG_NEWSESSIONHOST
{
    DWORD   dwType;             // Message type
    GUID    guidInstance;       // GUID Instance of the session
} DPLMSG_NEWSESSIONHOST, FAR *LPDPLMSG_NEWSESSIONHOST;


/******************************************
 *
 *	DirectPlay Lobby message dwType values
 *
 *****************************************/

/*
 *  The application has read the connection settings.
 *  It is now O.K. for the lobby client to release
 *  its IDirectPlayLobby interface.
 */
#define DPLSYS_CONNECTIONSETTINGSREAD   0x00000001

/*
 *  The application's call to DirectPlayConnect failed
 */
#define DPLSYS_DPLAYCONNECTFAILED       0x00000002

/*
 *  The application has created a DirectPlay session.
 */
#define DPLSYS_DPLAYCONNECTSUCCEEDED    0x00000003

/*
 *  The application has terminated.
 */
#define DPLSYS_APPTERMINATED            0x00000004

/*
 *  The message is a DPLMSG_SETPROPERTY message.
 */
#define DPLSYS_SETPROPERTY				0x00000005

/*
 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
 */
#define DPLSYS_SETPROPERTYRESPONSE		0x00000006

/*
 *  The message is a DPLMSG_GETPROPERTY message.
 */
#define DPLSYS_GETPROPERTY				0x00000007

/*
 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
 */
#define DPLSYS_GETPROPERTYRESPONSE		0x00000008

/*
 *  The message is a DPLMSG_NEWSESSIONHOST message.
 */
#define DPLSYS_NEWSESSIONHOST           0x00000009

/*
 *  New connection settings are available.
 */
#define DPLSYS_NEWCONNECTIONSETTINGS    0x0000000A

/*
 *  The Lobby Client has released the DirectPlayLobby Interface
 */
#define DPLSYS_LOBBYCLIENTRELEASE		0x0000000B

/****************************************************************************
 *
 * DirectPlay defined property GUIDs and associated data structures
 *
 ****************************************************************************/

/*
 * DPLPROPERTY_MessagesSupported
 *
 * Request whether the lobby supports standard.  Lobby with respond with either
 * TRUE or FALSE or may not respond at all.
 * 
 * Property data is a single BOOL with TRUE or FALSE
 */
// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_LobbyGuid
 *
 * Request the GUID that identifies the lobby software that the application
 * is communicating with.
 *
 * Property data is a single GUID.
 */
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_PlayerGuid
 *
 * Request the GUID that identifies the player on this machine for sending
 * property data back to the lobby.
 *
 * Property data is the DPLDATA_PLAYERDATA structure
 */
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERGUID
 *
 * Data structure to hold the GUID of the player and player creation flags
 * from the lobby.
 */
typedef struct _DPLDATA_PLAYERGUID
{
	GUID	guidPlayer;
	DWORD	dwPlayerFlags;
} DPLDATA_PLAYERGUID, FAR *LPDPLDATA_PLAYERGUID;

/*
 * DPLPROPERTY_PlayerScore
 *
 * Used to send an array of long integers to the lobby indicating the 
 * score of a player.
 *
 * Property data is the DPLDATA_PLAYERSCORE structure.
 */
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERSCORE
 *
 * Data structure to hold an array of long integers representing a player score.
 * Application must allocate enough memory to hold all the scores.
 */
typedef struct _DPLDATA_PLAYERSCORE
{
	DWORD	dwScoreCount;
	LONG	Score[1];
} DPLDATA_PLAYERSCORE, FAR *LPDPLDATA_PLAYERSCORE;

/****************************************************************************
 *
 * DirectPlay Address ID's
 *
 ****************************************************************************/

/* DirectPlay Address
 *
 * A DirectPlay address consists of multiple chunks of data, each tagged
 * with a GUID signifying the type of data in the chunk. The chunk also
 * has a length so that unknown chunk types can be skipped.
 *
 * The EnumAddress() function is used to parse these address data chunks.
 */

/*
 * DPADDRESS
 *
 * Header for block of address data elements
 */
typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS;

typedef DPADDRESS FAR *LPDPADDRESS;

/*
 * DPAID_TotalSize
 *
 * Chunk is a DWORD containing size of entire DPADDRESS structure
 */

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * DPAID_ServiceProvider
 *
 * Chunk is a GUID describing the service provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_LobbyProvider
 *
 * Chunk is a GUID describing the lobby provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

/*
 * DPAID_Phone and DPAID_PhoneW
 *
 * Chunk is a string containing a phone number (i.e. "1-800-555-1212")
 * in ANSI or UNICODE format
 */

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Modem and DPAID_ModemW
 *
 * Chunk is a string containing a modem name registered with TAPI
 * in ANSI or UNICODE format
 */

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Inet and DPAID_InetW
 *
 * Chunk is a string containing a TCP/IP host name or an IP address
 * (i.e. "dplay.microsoft.com" or "137.55.100.173") in ANSI or UNICODE format
 */

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_InetPort
 *
 * Chunk is the port number used for creating the apps TCP and UDP sockets.
 * WORD value (i.e. 47624).
 */
 
// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#ifdef BIGMESSAGEDEFENSE
#endif

/*
 * DPCOMPORTADDRESS
 *
 * Used to specify com port settings. The constants that define baud rate,
 * stop bits and parity are defined in WINBASE.H. The constants for flow
 * control are given below.
 */

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

typedef struct _DPCOMPORTADDRESS
{
    DWORD   dwComPort;                  // COM port to use (1-4)
    DWORD   dwBaudRate;                 // baud rate (100-256k)
    DWORD   dwStopBits;                 // no. stop bits (1-2)
    DWORD   dwParity;                   // parity (none, odd, even, mark)
    DWORD   dwFlowControl;              // flow control (none, xon/xoff, rts, dtr)
} DPCOMPORTADDRESS;

typedef DPCOMPORTADDRESS FAR *LPDPCOMPORTADDRESS;

/*
 * DPAID_ComPort
 *
 * Chunk contains a DPCOMPORTADDRESS structure defining the serial port.
 */

// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * 	dplobby 1.0 obsolete definitions
 *	Included for compatibility only.
 *
 ****************************************************************************/
#define DPLAD_SYSTEM          DPLMSG_SYSTEM


#ifdef __cplusplus
};
#endif /* __cplusplus */

#pragma warning(default:4201)

#endif /* __DPLOBBY_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsetup.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsetup.h
 *  Content:    DirectXSetup, error codes and flags
 ***************************************************************************/

#ifndef __DSETUP_H__
#define __DSETUP_H__

#include <windows.h>      // windows stuff

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#endif


#ifdef __cplusplus
extern "C" {
#endif

#define FOURCC_VERS mmioFOURCC('v','e','r','s')

// DSETUP Error Codes, must remain compatible with previous setup.
#define DSETUPERR_SUCCESS_RESTART        1
#define DSETUPERR_SUCCESS                0
#define DSETUPERR_BADWINDOWSVERSION     -1
#define DSETUPERR_SOURCEFILENOTFOUND    -2
#define DSETUPERR_BADSOURCESIZE         -3
#define DSETUPERR_BADSOURCETIME         -4
#define DSETUPERR_NOCOPY                -5
#define DSETUPERR_OUTOFDISKSPACE        -6
#define DSETUPERR_CANTFINDINF           -7
#define DSETUPERR_CANTFINDDIR           -8
#define DSETUPERR_INTERNAL              -9
#define DSETUPERR_NTWITHNO3D            -10  /* REM: obsolete, you'll never see this */
#define DSETUPERR_UNKNOWNOS             -11
#define DSETUPERR_USERHITCANCEL         -12
#define DSETUPERR_NOTPREINSTALLEDONNT   -13
#define DSETUPERR_NEWERVERSION          -14
#define DSETUPERR_NOTADMIN              -15
#define DSETUPERR_UNSUPPORTEDPROCESSOR  -16

// DSETUP flags. DirectX 5.0 apps should use these flags only.
#define DSETUP_DDRAWDRV         0x00000008      /* install DirectDraw Drivers           */
#define DSETUP_DSOUNDDRV        0x00000010      /* install DirectSound Drivers          */
#define DSETUP_DXCORE           0x00010000	/* install DirectX runtime              */
#define DSETUP_DIRECTX  (DSETUP_DXCORE|DSETUP_DDRAWDRV|DSETUP_DSOUNDDRV)
#define DSETUP_TESTINSTALL      0x00020000      /* just test install, don't do anything */
#define DSETUP_USEROLDERFLAG	0x02000000		/* enable return DSETUPERR_NEWERVERSION */
// Bug #22730 
	// #define DSETUP_NTINSTALL		0x00080000		/* install on Win2K platform */

// These OBSOLETE flags are here for compatibility with pre-DX5 apps only.
// They are present to allow DX3 apps to be recompiled with DX5 and still work.
// DO NOT USE THEM for DX5. They will go away in future DX releases.
#define DSETUP_DDRAW            0x00000001      /* OBSOLETE. install DirectDraw           */
#define DSETUP_DSOUND           0x00000002      /* OBSOLETE. install DirectSound          */
#define DSETUP_DPLAY            0x00000004      /* OBSOLETE. install DirectPlay           */
#define DSETUP_DPLAYSP          0x00000020      /* OBSOLETE. install DirectPlay Providers */
#define DSETUP_DVIDEO           0x00000040      /* OBSOLETE. install DirectVideo          */
#define DSETUP_D3D              0x00000200      /* OBSOLETE. install Direct3D             */
#define DSETUP_DINPUT           0x00000800      /* OBSOLETE. install DirectInput          */
#define DSETUP_DIRECTXSETUP     0x00001000      /* OBSOLETE. install DirectXSetup DLL's   */
#define DSETUP_NOUI             0x00002000      /* OBSOLETE. install DirectX with NO UI   */
#define DSETUP_PROMPTFORDRIVERS 0x10000000      /* OBSOLETE. prompt when replacing display/audio drivers */
#define DSETUP_RESTOREDRIVERS   0x20000000      /* OBSOLETE. restore display/audio drivers */



//******************************************************************
// DirectX Setup Callback mechanism
//******************************************************************

// DSETUP Message Info Codes, passed to callback as Reason parameter.
#define DSETUP_CB_MSG_NOMESSAGE                     0
#define DSETUP_CB_MSG_CANTINSTALL_UNKNOWNOS         1
#define DSETUP_CB_MSG_CANTINSTALL_NT                2
#define DSETUP_CB_MSG_CANTINSTALL_BETA              3
#define DSETUP_CB_MSG_CANTINSTALL_NOTWIN32          4
#define DSETUP_CB_MSG_CANTINSTALL_WRONGLANGUAGE     5
#define DSETUP_CB_MSG_CANTINSTALL_WRONGPLATFORM     6
#define DSETUP_CB_MSG_PREINSTALL_NT                 7
#define DSETUP_CB_MSG_NOTPREINSTALLEDONNT           8
#define DSETUP_CB_MSG_SETUP_INIT_FAILED             9
#define DSETUP_CB_MSG_INTERNAL_ERROR                10
#define DSETUP_CB_MSG_CHECK_DRIVER_UPGRADE          11
#define DSETUP_CB_MSG_OUTOFDISKSPACE                12
#define DSETUP_CB_MSG_BEGIN_INSTALL                 13
#define DSETUP_CB_MSG_BEGIN_INSTALL_RUNTIME         14
#define DSETUP_CB_MSG_BEGIN_INSTALL_DRIVERS         15
#define DSETUP_CB_MSG_BEGIN_RESTORE_DRIVERS         16
#define DSETUP_CB_MSG_FILECOPYERROR                 17


#define DSETUP_CB_UPGRADE_TYPE_MASK             0x000F
#define DSETUP_CB_UPGRADE_KEEP                  0x0001
#define DSETUP_CB_UPGRADE_SAFE                  0x0002
#define DSETUP_CB_UPGRADE_FORCE                 0x0004
#define DSETUP_CB_UPGRADE_UNKNOWN               0x0008

#define DSETUP_CB_UPGRADE_HASWARNINGS           0x0100
#define DSETUP_CB_UPGRADE_CANTBACKUP            0x0200

#define DSETUP_CB_UPGRADE_DEVICE_ACTIVE         0x0800

#define DSETUP_CB_UPGRADE_DEVICE_DISPLAY        0x1000
#define DSETUP_CB_UPGRADE_DEVICE_MEDIA          0x2000


typedef struct _DSETUP_CB_UPGRADEINFO
{
    DWORD UpgradeFlags;
} DSETUP_CB_UPGRADEINFO;

typedef struct _DSETUP_CB_FILECOPYERROR
{
    DWORD dwError;
} DSETUP_CB_FILECOPYERROR;


#ifdef _WIN32
//
// Data Structures
//
#ifndef UNICODE_ONLY

typedef struct _DIRECTXREGISTERAPPA {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPSTR    lpszApplicationName;
    LPGUID   lpGUID;
    LPSTR    lpszFilename;
    LPSTR    lpszCommandLine;
    LPSTR    lpszPath;
    LPSTR    lpszCurrentDirectory;
} DIRECTXREGISTERAPPA, *PDIRECTXREGISTERAPPA, *LPDIRECTXREGISTERAPPA;

typedef struct _DIRECTXREGISTERAPP2A {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPSTR    lpszApplicationName;
    LPGUID   lpGUID;
    LPSTR    lpszFilename;
    LPSTR    lpszCommandLine;
    LPSTR    lpszPath;
    LPSTR    lpszCurrentDirectory;
    LPSTR    lpszLauncherName;
} DIRECTXREGISTERAPP2A, *PDIRECTXREGISTERAPP2A, *LPDIRECTXREGISTERAPP2A;

#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY

typedef struct _DIRECTXREGISTERAPPW {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPWSTR   lpszApplicationName;
    LPGUID   lpGUID;
    LPWSTR   lpszFilename;
    LPWSTR   lpszCommandLine;
    LPWSTR   lpszPath;
    LPWSTR   lpszCurrentDirectory;
} DIRECTXREGISTERAPPW, *PDIRECTXREGISTERAPPW, *LPDIRECTXREGISTERAPPW;

typedef struct _DIRECTXREGISTERAPP2W {
    DWORD    dwSize;
    DWORD    dwFlags;
    LPWSTR   lpszApplicationName;
    LPGUID   lpGUID;
    LPWSTR   lpszFilename;
    LPWSTR   lpszCommandLine;
    LPWSTR   lpszPath;
    LPWSTR   lpszCurrentDirectory;
    LPWSTR  lpszLauncherName;
} DIRECTXREGISTERAPP2W, *PDIRECTXREGISTERAPP2W, *LPDIRECTXREGISTERAPP2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DIRECTXREGISTERAPPW DIRECTXREGISTERAPP;
typedef PDIRECTXREGISTERAPPW PDIRECTXREGISTERAPP;
typedef LPDIRECTXREGISTERAPPW LPDIRECTXREGISTERAPP;
typedef DIRECTXREGISTERAPP2W DIRECTXREGISTERAPP2;
typedef PDIRECTXREGISTERAPP2W PDIRECTXREGISTERAPP2;
typedef LPDIRECTXREGISTERAPP2W LPDIRECTXREGISTERAPP2;
#else
typedef DIRECTXREGISTERAPPA DIRECTXREGISTERAPP;
typedef PDIRECTXREGISTERAPPA PDIRECTXREGISTERAPP;
typedef LPDIRECTXREGISTERAPPA LPDIRECTXREGISTERAPP;
typedef DIRECTXREGISTERAPP2A DIRECTXREGISTERAPP2;
typedef PDIRECTXREGISTERAPP2A PDIRECTXREGISTERAPP2;
typedef LPDIRECTXREGISTERAPP2A LPDIRECTXREGISTERAPP2;
#endif // UNICODE


//
// API
//

#ifndef UNICODE_ONLY
INT
WINAPI
DirectXSetupA(
    HWND  hWnd,
    LPSTR lpszRootPath,
    DWORD dwFlags
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXSetupW(
    HWND   hWnd,
    LPWSTR lpszRootPath,
    DWORD  dwFlags
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXSetup  DirectXSetupW
#else
#define DirectXSetup  DirectXSetupA
#endif // !UNICODE


#ifndef UNICODE_ONLY
INT
WINAPI
DirectXDeviceDriverSetupA(
    HWND  hWnd,
    LPSTR lpszDriverClass,
    LPSTR lpszDriverPath,
    DWORD dwFlags
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXDeviceDriverSetupW(
    HWND   hWnd,
    LPWSTR lpszDriverClass,
    LPWSTR lpszDriverPath,
    DWORD  dwFlags
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXDeviceDriverSetup  DirectXDeviceDriverSetupW
#else
#define DirectXDeviceDriverSetup  DirectXDeviceDriverSetupA
#endif // !UNICODE

#ifndef UNICODE_ONLY
INT
WINAPI
DirectXRegisterApplicationA(
    HWND                  hWnd,
    LPVOID				  lpDXRegApp
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
WINAPI
DirectXRegisterApplicationW(
    HWND                  hWnd,
    LPVOID				  lpDXRegApp
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DirectXRegisterApplication  DirectXRegisterApplicationW
#else
#define DirectXRegisterApplication  DirectXRegisterApplicationA
#endif // !UNICODE

INT
WINAPI
DirectXUnRegisterApplication(
    HWND     hWnd,
    LPGUID   lpGUID
    );

//
// Function Pointers
//
#ifdef UNICODE
typedef INT (WINAPI * LPDIRECTXSETUP)(HWND, LPWSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXDEVICEDRIVERSETUP)(HWND, LPWSTR, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXREGISTERAPPLICATION)(HWND, LPVOID);
#else
typedef INT (WINAPI * LPDIRECTXSETUP)(HWND, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXDEVICEDRIVERSETUP)(HWND, LPSTR, LPSTR, DWORD);
typedef INT (WINAPI * LPDIRECTXREGISTERAPPLICATION)(HWND, LPVOID);
#endif // UNICODE

typedef DWORD (FAR PASCAL * DSETUP_CALLBACK)(DWORD Reason,
                                  DWORD MsgType,       /* Same as flags to MessageBox */
                                  LPSTR szMessage,
                                  LPSTR szName,
                                  void *pInfo);

INT WINAPI DirectXSetupSetCallback(DSETUP_CALLBACK Callback);
INT WINAPI DirectXSetupGetVersion(DWORD *lpdwVersion, DWORD *lpdwMinorVersion);

#endif // WIN32


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsadmin.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       dsadmin.h
//
//  Contents:   DS Admin Object Creation public header
//
//---------------------------------------------------------------------------


//
// CoClass for the Object creation dialog object
//
// {E301A009-F901-11d2-82B9-00C04F68928B}
DEFINE_GUID(CLSID_DsAdminCreateObj, 
    0xe301a009, 0xf901, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


//
// Interface GUIDs
//


// {53554A38-F902-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminCreateObj, 
    0x53554a38, 0xf902, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {F2573587-E6FC-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObj, 
    0xf2573587, 0xe6fc, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {BE2B487E-F904-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjPrimarySite, 
0xbe2b487e, 0xf904, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {6088EAE2-E7BF-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjExt, 
    0x6088eae2, 0xe7bf, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {E4A2B8B3-5A18-11d2-97C1-00A0C9A06D2D}
DEFINE_GUID(IID_IDsAdminNotifyHandler, 
    0xe4a2b8b3, 0x5a18, 0x11d2, 0x97, 0xc1, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d);


#ifndef _DSADMIN_H
#define _DSADMIN_H


// ----------------------------------------------------------------------------
// 
// Interface: IDsAdminCreateObj
//  
// Implemented by the object (implemented by the system) CLSID_DsAdminCreateObj
//
// Used by: any client needing to invoke the creation UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsAdminCreateObj

DECLARE_INTERFACE_(IDsAdminCreateObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminCreateObj methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName) PURE;
  STDMETHOD(CreateModal)(THIS_ /*IN*/ HWND hwndParent, 
                               /*OUT*/ IADs** ppADsObj) PURE;
};






//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObj
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (both primary and regular)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObj

DECLARE_INTERFACE_(IDsAdminNewObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminNewObj methods ***
  STDMETHOD(SetButtons)(THIS_ /*IN*/ ULONG nCurrIndex, /*IN*/ BOOL bValid) PURE; 
  STDMETHOD(GetPageCounts)(THIS_ /*OUT*/ LONG* pnTotal,
                                 /*OUT*/ LONG* pnStartIndex) PURE; 
};





//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjPrimarySite
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (primary only)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjPrimarySite

DECLARE_INTERFACE_(IDsAdminNewObjPrimarySite, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjPrimarySite methods ***
  STDMETHOD(CreateNew)(THIS_ /*IN*/ LPCWSTR pszName) PURE;
  STDMETHOD(Commit)(THIS_ ) PURE;
};



//
// struct passed to IDsAdminNewObjExt::Initialize()
//
// it contains information regarding UI look
//

typedef struct
{
    DWORD   dwSize;                     // size of struct, for versioning
    HICON   hObjClassIcon;              // class icon for the object to be created
    LPWSTR  lpszWizTitle;               // title of the wizard
    LPWSTR  lpszContDisplayName;        // container display name (canonical name)
} DSA_NEWOBJ_DISPINFO, * LPDSA_NEWOBJ_DISPINFO;




//
// context flags passed to IDsAdminNewObjExt::OnError() and to IDsAdminNewObjExt::WriteData()
//

#define DSA_NEWOBJ_CTX_PRECOMMIT      0x00000001  // before SetInfo()
#define DSA_NEWOBJ_CTX_COMMIT         0x00000002  // SetInfo(), commit phase
#define DSA_NEWOBJ_CTX_POSTCOMMIT     0x00000003  // after SetInfo()
#define DSA_NEWOBJ_CTX_CLEANUP        0x00000004  // on post commit fail



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjExt
// 
// Implemented by: creation extension in proc server (both primary and regular)
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjExt

DECLARE_INTERFACE_(IDsAdminNewObjExt, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjExt methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName,
                              /*IN*/ IDsAdminNewObj* pDsAdminNewObj,
                              /*IN*/ LPDSA_NEWOBJ_DISPINFO pDispInfo) PURE;

  STDMETHOD(AddPages)(THIS_ /*IN*/ LPFNADDPROPSHEETPAGE lpfnAddPage, 
                            /*IN*/ LPARAM lParam) PURE;

  STDMETHOD(SetObject)(THIS_ /*IN*/ IADs* pADsObj) PURE;

  STDMETHOD(WriteData)(THIS_ /*IN*/ HWND hWnd, 
                             /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(OnError)(THIS_ /*IN*/ HWND hWnd, 
                           /*IN*/ HRESULT hr,
                              /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(GetSummaryInfo)(THIS_ /*OUT*/BSTR* pBstrText) PURE;
};


//
// Notification opcodes for IDsAdminNotifyHandler
//

#define DSA_NOTIFY_DEL      0x00000001  // delete
#define DSA_NOTIFY_REN      0x00000002  // rename
#define DSA_NOTIFY_MOV      0x00000004  // move
#define DSA_NOTIFY_PROP     0x00000008  // property change

#define DSA_NOTIFY_ALL      (DSA_NOTIFY_DEL|DSA_NOTIFY_REN|DSA_NOTIFY_MOV|DSA_NOTIFY_PROP)

//
// TODO: add explaination
//
// flags to handle additional data
//

#define DSA_NOTIFY_FLAG_ADDITIONAL_DATA        0x00000002   //process additional extension data?
#define DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA  0x00000001   //operation forced



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNotifyHandler
// 
// Implemented by: notification handler in proc server
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNotifyHandler


DECLARE_INTERFACE_(IDsAdminNotifyHandler, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // IDsAdminNotifyHandler methods
  STDMETHOD(Initialize)(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                              /*OUT*/ ULONG* puEventFlags) PURE;
  STDMETHOD(Begin)(THIS_ /*IN*/ ULONG uEvent,
                         /*IN*/ IDataObject* pArg1,
                         /*IN*/ IDataObject* pArg2,
                         /*OUT*/ ULONG* puFlags,
                         /*OUT*/ BSTR* pBstr) PURE;

  STDMETHOD(Notify)(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags) PURE; 

  STDMETHOD(End)(THIS_) PURE; 
};



#endif // _DSADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _MAC
#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif
#endif /* ndef _MAC */

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

#ifndef _MAC
/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif  /* ndef _MAC */

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#ifndef _MAC
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */
#endif  /* ndef _MAC */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsclient.h ===
#ifndef __dsclient_h
#define __dsclient_h

//---------------------------------------------------------------------------//
// CLSIDs exposed for the dsclient.
//---------------------------------------------------------------------------//

// this CLSID is used to signal that the DSOBJECTNAMEs structure originated
// for the Microsoft DS.

DEFINE_GUID(CLSID_MicrosoftDS, 0xfe1290f0, 0xcfbd, 0x11cf, 0xa3, 0x30, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
#define CLSID_DsFolder CLSID_MicrosoftDS


// this is the CLSID used by clients to get the IShellExtInit, IPropSheetExt
// and IContextMenus exposed from dsuiext.dll.

DEFINE_GUID(CLSID_DsPropertyPages, 0xd45d530,  0x764b, 0x11d0, 0xa1, 0xca, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);

DEFINE_GUID(CLSID_DsDomainTreeBrowser, 0x1698790a, 0xe2b4, 0x11d0, 0xb0, 0xb1, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6);
DEFINE_GUID(IID_IDsBrowseDomainTree, 0x7cabcf1e, 0x78f5, 0x11d2, 0x96, 0xc, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

DEFINE_GUID(CLSID_DsDisplaySpecifier, 0x1ab4a8c0, 0x6a0b, 0x11d2, 0xad, 0x49, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#define IID_IDsDisplaySpecifier CLSID_DsDisplaySpecifier

DEFINE_GUID(CLSID_DsFolderProperties, 0x9e51e0d0, 0x6e0f, 0x11d2, 0x96, 0x1, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#define IID_IDsFolderProperties CLSID_DsFolderProperties

#ifndef GUID_DEFS_ONLY

#include "activeds.h"

//---------------------------------------------------------------------------//
// Clipboard formats used within DSUI
//---------------------------------------------------------------------------//

//
// CF_DSOBJECTS
// ------------
//  This clipboard format defines the seleciton for an DS IShellFolder to the
//  shell extensions.   All strings are stored as BSTR's, and an offset == 0 
//  is used to indicate that the string is not present.
// 

#define DSOBJECT_ISCONTAINER            0x00000001  // = 1 => object is a container
#define DSOBJECT_READONLYPAGES          0x80000000  // = 1 => read only pages

#define DSPROVIDER_UNUSED_0             0x00000001
#define DSPROVIDER_UNUSED_1             0x00000002
#define DSPROVIDER_UNUSED_2             0x00000004
#define DSPROVIDER_UNUSED_3             0x00000008
#define DSPROVIDER_ADVANCED             0x00000010  // = 1 => advanced mode 

#define CFSTR_DSOBJECTNAMES TEXT("DsObjectNames")

typedef struct
{
    DWORD   dwFlags;                    // item flags
    DWORD   dwProviderFlags;            // flags for item provider
    DWORD   offsetName;                 // offset to ADS path of the object
    DWORD   offsetClass;                // offset to object class name / == 0 not known
} DSOBJECT, * LPDSOBJECT;

typedef struct
{
    CLSID    clsidNamespace;            // namespace identifier (indicates which namespace selection from)
    UINT     cItems;                    // number of objects
    DSOBJECT aObjects[1];               // array of objects
} DSOBJECTNAMES, * LPDSOBJECTNAMES;


//
// CF_DSDISPLAYSPECOPTIONS
// -----------------------
//  When invoking an object referenced by a display specifier (context menu, property
//  page, etc) we call the IShellExtInit interface passing a IDataObject.  This data
//  object supports the CF_DSDISPLAYSPECOPTIONS format to give out configuration
//  informaiton about admin/shell invocation.
//
//  When interacting with dsuiext.dll the interfaces uses this clipboard format
//  to determine which display specifier attributes to address (admin/shell)
//  and pick up the values accordingly.  If no format is suppoted then
//  dsuiext.dll defaults to shell.
// 

#define CFSTR_DS_DISPLAY_SPEC_OPTIONS TEXT("DsDisplaySpecOptions")
#define CFSTR_DSDISPLAYSPECOPTIONS CFSTR_DS_DISPLAY_SPEC_OPTIONS

typedef struct _DSDISPLAYSPECOPTIONS
{
    DWORD   dwSize;                             // size of struct, for versioning
    DWORD   dwFlags;                            // invocation flags
    DWORD   offsetAttribPrefix;                 // offset to attribute prefix string.

    DWORD   offsetUserName;                     // offset to UNICODE user name
    DWORD   offsetPassword;                     // offset to UNICODE password
    DWORD   offsetServer;
    DWORD   offsetServerConfigPath;

} DSDISPLAYSPECOPTIONS, * PDSDISPLAYSPECOPTIONS, * LPDSDISPLAYSPECOPTIONS;

#define DS_PROP_SHELL_PREFIX L"shell"
#define DS_PROP_ADMIN_PREFIX L"admin"

#define DSDSOF_HASUSERANDSERVERINFO     0x00000001      // = 1 => user name/password are valid
#define DSDSOF_SIMPLEAUTHENTICATE       0x00000002      // = 1 => don't use secure authentication to DS
#define DSDSOF_DSAVAILABLE              0x40000000      // = 1 => ignore DS available checks

//
// CF_DSPROPERTYPAGEINFO
// ---------------------
//  When the property pages for an object are being displayed the parsed
//  display specifier string is passed to the page object via the IDataObject
//  in the following clipboard format.
//
//  Within the display specifier for a property page, the format for a
//  Win32 extension is "n,{clsid}[,bla...]" we take the "bla" section and
//  pass it down.
// 

#define CFSTR_DSPROPERTYPAGEINFO TEXT("DsPropPageInfo")

typedef struct
{
    DWORD offsetString;                 // offset to UNICODE string
} DSPROPERTYPAGEINFO, * LPDSPROPERTYPAGEINFO;


// 
// To sync property pages and the admin tools this message is broadcast
//

#define DSPROP_ATTRCHANGED_MSG  TEXT("DsPropAttrChanged")

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsBrowseDomainTree
// ===================
//  This interface returns a list of the domains from a given computer name
//  (or the current computer name if none is specified).
//
//  NOTES:
//    1) The structure returned by ::GetDomains should be free'd using
//       FreeDomains.
//
//    2) ::BrowseTo allocates a string on exit, this is allocated using
//       CoTaskMemAlloc, and therefore should be free'd using CoTaskMemFree.
//
//---------------------------------------------------------------------------//

#define DBDTF_RETURNFQDN          0x00000001  // if not set, pszNCName will be blank
#define DBDTF_RETURNMIXEDDOMAINS  0x00000002  // set it if you want downlevel trust domains too
#define DBDTF_RETURNEXTERNAL      0x00000004  // set it if you want external trust domains too
#define DBDTF_RETURNINBOUND       0x00000008  // set it if you want trusting domains
#define DBDTF_RETURNINOUTBOUND    0x00000010  // set it if you want both trusted and trusting domains

typedef struct _DOMAINDESC
{       
  LPWSTR pszName;                       // domain name (if no dns, use netbios)
  LPWSTR pszPath;                       // set to blank
  LPWSTR pszNCName;                     // FQDN, e.g.,DC=mydomain,DC=microsoft,DC=com
  LPWSTR pszTrustParent;                // parent domain name (if no dns, use netbios)
  LPWSTR pszObjectClass;                // Object class of the domain object referenced
  ULONG  ulFlags;                       // Flags, from DS_TRUSTED_DOMAINS.Flags
  BOOL   fDownLevel;                    // == 1 if downlevel domain
  struct _DOMAINDESC *pdChildList;      // Children of this node
  struct _DOMAINDESC *pdNextSibling;    // Siblings of this node            
} DOMAIN_DESC, DOMAINDESC, * PDOMAIN_DESC, * LPDOMAINDESC;

typedef struct
{
  DWORD dsSize;
  DWORD dwCount;
  DOMAINDESC aDomains[1];
} DOMAIN_TREE, DOMAINTREE, * PDOMAIN_TREE, * LPDOMAINTREE;

#undef  INTERFACE
#define INTERFACE  IDsBrowseDomainTree

DECLARE_INTERFACE_(IDsBrowseDomainTree, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsBrowseDomainTree methods ***
    STDMETHOD(BrowseTo)(THIS_ HWND hwndParent, LPWSTR *ppszTargetPath, DWORD dwFlags) PURE;
    STDMETHOD(GetDomains)(THIS_ PDOMAIN_TREE *ppDomainTree, DWORD dwFlags) PURE;
    STDMETHOD(FreeDomains)(THIS_ PDOMAIN_TREE *ppDomainTree) PURE;
    STDMETHOD(FlushCachedDomains)(THIS) PURE;
    STDMETHOD(SetComputer)(THIS_ LPCWSTR pszComputerName, LPCWSTR pszUserName, LPCWSTR pszPassword) PURE;
};

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsDisplaySpecifier
// ===================
//  This interface gives client UI access to the display specifiers for 
//  specific attributes.
//
//---------------------------------------------------------------------------//

//
// IDsDisplaySpecifier::SetServer flags
//
#define DSSSF_SIMPLEAUTHENTICATE        0x00000001  // = 1 => don't use secure authentication to DS
#define DSSSF_DSAVAILABLE               0x80000000  // = 1 => ignore DS available checks

//
// Flags for IDsDisplaySpecifier::GetIcon / GetIconLocation
//
#define DSGIF_ISNORMAL                  0x0000000   // = icon is in normal state (default)
#define DSGIF_ISOPEN                    0x0000001   // = icon is in open state
#define DSGIF_ISDISABLED                0x0000002   // = icon is in a disabled state
#define DSGIF_ISMASK                    0x000000f
#define DSGIF_GETDEFAULTICON            0x0000010   // = 1 => if no icon then get default (from shell32.dll)
#define DSGIF_DEFAULTISCONTAINER        0x0000020   // = 1 => if returning default icon, return it as a container

//
// Flags for IDsDisplaySpecifier::IsClassContainer
//
#define DSICCF_IGNORETREATASLEAF        0x00000001  // = 1 => igore the "treatAsLeaf" and use only schema information

//
// Callback function used for IDsDisplaySpecifier::EnumClassAttributes
//

#define DSECAF_NOTLISTED               0x00000001  // = 1 => hide from the field drop down in the query UI

typedef HRESULT (CALLBACK *LPDSENUMATTRIBUTES)(LPARAM lParam, LPCWSTR pszAttributeName, LPCWSTR pszDisplayName, DWORD dwFlags);

//
// IDsDisplaySpecifier::GetClassCreationInfo information
//

#define DSCCIF_HASWIZARDDIALOG          0x00000001  // = 1 => return the wizard dialog CLSID
#define DSCCIF_HASWIZARDPRIMARYPAGE     0x00000002  // = 1 => returning a primary wizard dlg CLSID

typedef struct
{
    DWORD dwFlags;
    CLSID clsidWizardDialog;
    CLSID clsidWizardPrimaryPage;
    DWORD cWizardExtensions;            // how many extension CLSIDs?
    CLSID aWizardExtensions[1];
} DSCLASSCREATIONINFO, * LPDSCLASSCREATIONINFO;

//
// IDsDisplaySpecifier - a COM object for interacting with display specifiers
//

#undef  INTERFACE
#define INTERFACE IDsDisplaySpecifier

DECLARE_INTERFACE_(IDsDisplaySpecifier, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsDisplaySpecifier methods ***
    STDMETHOD(SetServer)(THIS_ LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword, DWORD dwFlags) PURE;
    STDMETHOD(SetLanguageID)(THIS_ LANGID langid) PURE;
    STDMETHOD(GetDisplaySpecifier)(THIS_ LPCWSTR pszObjectClass, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetIconLocation)(THIS_ LPCWSTR pszObjectClass, DWORD dwFlags, LPWSTR pszBuffer, INT cchBuffer, INT *presid) PURE;
    STDMETHOD_(HICON, GetIcon)(THIS_ LPCWSTR pszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon) PURE;
    STDMETHOD(GetFriendlyClassName)(THIS_ LPCWSTR pszObjectClass, LPWSTR pszBuffer, INT cchBuffer) PURE;
    STDMETHOD(GetFriendlyAttributeName)(THIS_ LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, LPWSTR pszBuffer, UINT cchBuffer) PURE;
    STDMETHOD_(BOOL, IsClassContainer)(THIS_ LPCWSTR pszObjectClass, LPCWSTR pszADsPath, DWORD dwFlags) PURE;
    STDMETHOD(GetClassCreationInfo)(THIS_ LPCWSTR pszObjectClass, LPDSCLASSCREATIONINFO* ppdscci) PURE;
    STDMETHOD(EnumClassAttributes)(THIS_ LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam) PURE;
    STDMETHOD_(ADSTYPE, GetAttributeADsType)(LPCWSTR pszAttributeName) PURE;
};


//---------------------------------------------------------------------------//
//
// DsBrowseForContainer
// --------------------
//  Provides a container browser similar to the SHBrowseForFolder, except
//  targetting the DS.
//
// In:
//  pInfo -> DSBROWSEINFO structure
//
// Out:
//  == IDOK/IDCANCEL depending on buttons, -1 if error
//
//---------------------------------------------------------------------------//

typedef struct
{
    DWORD           cbStruct;       // size of structure in bytes
    HWND            hwndOwner;      // dialog owner
    LPCWSTR         pszCaption;     // dialog caption text (can be NULL)
    LPCWSTR         pszTitle;       // displayed above the tree view control (can be NULL)
    LPCWSTR         pszRoot;        // ADS path to root (NULL == root of DS namespace)
    LPWSTR          pszPath;        // [in/out] initial selection & returned path (required)
    ULONG           cchPath;        // size of pszPath buffer in characters
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;    // callback function (see SHBrowseForFolder)
    LPARAM          lParam;         // passed to pfnCallback as lpUserData
    DWORD           dwReturnFormat; // ADS_FORMAT_* (default is ADS_FORMAT_X500_NO_SERVER)
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // UNICODE string for the object class
    ULONG           cchObjectClass;
} DSBROWSEINFOW, *PDSBROWSEINFOW;

typedef struct
{
    DWORD           cbStruct;
    HWND            hwndOwner;
    LPCSTR          pszCaption;
    LPCSTR          pszTitle;
    LPCWSTR         pszRoot;        // ADS paths are always UNICODE
    LPWSTR          pszPath;        // ditto
    ULONG           cchPath;
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;
    LPARAM          lParam;
    DWORD           dwReturnFormat;
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // object class of the selected object
    ULONG           cchObjectClass;
} DSBROWSEINFOA, *PDSBROWSEINFOA;

#ifdef UNICODE
#define DSBROWSEINFO   DSBROWSEINFOW
#define PDSBROWSEINFO  PDSBROWSEINFOW
#else
#define DSBROWSEINFO   DSBROWSEINFOA
#define PDSBROWSEINFO  PDSBROWSEINFOA
#endif

// DSBROWSEINFO flags
#define DSBI_NOBUTTONS          0x00000001  // NOT TVS_HASBUTTONS
#define DSBI_NOLINES            0x00000002  // NOT TVS_HASLINES
#define DSBI_NOLINESATROOT      0x00000004  // NOT TVS_LINESATROOT
#define DSBI_CHECKBOXES         0x00000100  // TVS_CHECKBOXES
#define DSBI_NOROOT             0x00010000  // don't include pszRoot in tree (its children become top level nodes)
#define DSBI_INCLUDEHIDDEN      0x00020000  // display hidden objects
#define DSBI_EXPANDONOPEN       0x00040000  // expand to the path specified in pszPath when opening the dialog
#define DSBI_ENTIREDIRECTORY    0x00090000  // browse the entire directory (defaults to having DSBI_NOROOT set)
#define DSBI_RETURN_FORMAT      0x00100000  // dwReturnFormat field is valid
#define DSBI_HASCREDENTIALS     0x00200000  // pUserName & pPassword are valid
#define DSBI_IGNORETREATASLEAF  0x00400000  // ignore the treat as leaf flag when calling IsClassContainer
#define DSBI_SIMPLEAUTHENTICATE 0x00800000  // don't use secure authentication to DS
#define DSBI_RETURNOBJECTCLASS  0x01000000  // return object class of selected object

#define DSB_MAX_DISPLAYNAME_CHARS   64

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    WCHAR           szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    WCHAR           szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMW, *PDSBITEMW;

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    CHAR            szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    CHAR            szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMA, *PDSBITEMA;

#ifdef UNICODE
#define DSBITEM     DSBITEMW
#define PDSBITEM    PDSBITEMW
#else
#define DSBITEM     DSBITEMA
#define PDSBITEM    PDSBITEMA
#endif

// DSBITEM mask flags
#define DSBF_STATE              0x00000001
#define DSBF_ICONLOCATION       0x00000002
#define DSBF_DISPLAYNAME        0x00000004

// DSBITEM state flags
#define DSBS_CHECKED            0x00000001
#define DSBS_HIDDEN             0x00000002
#define DSBS_ROOT               0x00000004

//
// this message is sent to the callback to see if it wants to insert or modify 
// the item that is about to be inserted into the view.
//

#define DSBM_QUERYINSERTW       100 // lParam = PDSBITEMW (state, icon & name may be modified). Return TRUE if handled.
#define DSBM_QUERYINSERTA       101 // lParam = PDSBITEMA (state, icon & name may be modified). Return TRUE if handled.

#ifdef UNICODE
#define DSBM_QUERYINSERT DSBM_QUERYINSERTW
#else
#define DSBM_QUERYINSERT DSBM_QUERYINSERTA
#endif

//
// Called before we change the state of the icon (on tree collapse/expand)
//

#define DSBM_CHANGEIMAGESTATE   102 // lParam = adspath.  Return TRUE/FALSE top allow/disallow

//
// The dialog receives a WM_HELP
//

#define DSBM_HELP               103 // lParam == LPHELPINFO structure

//
// The dialog receives a WM_CONTEXTMENU, DSBID_xxx are the control ID's for this
// dialog so that you can display suitable help.
//

#define DSBM_CONTEXTMENU        104 // lParam == window handle to retrieve help for


//
// These are the control IDs for the controls in the dialog.   The callback can use
// these to modify the contents of the dialog as required.
//

#define DSBID_BANNER            256
#define DSBID_CONTAINERLIST     257

//
// API exported for browsing for containers.
//

STDAPI_(int) DsBrowseForContainerW(PDSBROWSEINFOW pInfo);
STDAPI_(int) DsBrowseForContainerA(PDSBROWSEINFOA pInfo);

#ifdef UNICODE
#define DsBrowseForContainer    DsBrowseForContainerW
#else
#define DsBrowseForContainer    DsBrowseForContainerA
#endif


//BUGBUG: these are here to keep old clients building - remove soon
STDAPI_(HICON) DsGetIcon(DWORD dwFlags, LPWSTR pszObjectClass, INT cxImage, INT cyImage);
STDAPI DsGetFriendlyClassName(LPWSTR pszObjectClass, LPWSTR pszBuffer, UINT cchBuffer);


#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dplobby8.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLobby.h
 *  Content:    DirectPlay8 Lobby Include File
 *
 ***************************************************************************/

#ifndef	__DPLOBBY_H__
#define	__DPLOBBY_H__

#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 * DirectPlay8Lobby CLSIDs
 *
 ****************************************************************************/

// {667955AD-6B3B-43ca-B949-BC69B5BAFF7F}
DEFINE_GUID(CLSID_DirectPlay8LobbiedApplication, 
0x667955ad, 0x6b3b, 0x43ca, 0xb9, 0x49, 0xbc, 0x69, 0xb5, 0xba, 0xff, 0x7f);

// {3B2B6775-70B6-45af-8DEA-A209C69559F3}
DEFINE_GUID(CLSID_DirectPlay8LobbyClient, 
0x3b2b6775, 0x70b6, 0x45af, 0x8d, 0xea, 0xa2, 0x9, 0xc6, 0x95, 0x59, 0xf3);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface IIDs
 *
 ****************************************************************************/

// {819074A3-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbiedApplication,
0x819074a3, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {819074A2-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbyClient,
0x819074a2, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface Pointer 
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDIRECTPLAY8LOBBIEDAPPLICATION;
typedef struct IDirectPlay8LobbyClient		    *PDIRECTPLAY8LOBBYCLIENT;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message IDs
 *
 ****************************************************************************/

#define	DPL_MSGID_LOBBY						0x8000
#define	DPL_MSGID_RECEIVE					(0x0001 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_CONNECT					(0x0002 | DPL_MSGID_LOBBY)
#define DPL_MSGID_DISCONNECT				(0x0003 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_SESSION_STATUS			(0x0004 | DPL_MSGID_LOBBY)
#define DPL_MSGID_CONNECTION_SETTINGS       (0x0005 | DPL_MSGID_LOBBY)

/****************************************************************************
 *
 * DirectPlay8Lobby Constants
 *
 ****************************************************************************/

//
// Specifies that operation should be performed on all open connections
//
#define DPLHANDLE_ALLCONNECTIONS			0xFFFFFFFF

// 
// The associated game session has suceeded in connecting / hosting
//
#define	DPLSESSION_CONNECTED				0x0001

// The associated game session failed connecting / hosting
//
#define	DPLSESSION_COULDNOTCONNECT			0x0002

//
// The associated game session has disconnected
//
#define	DPLSESSION_DISCONNECTED				0x0003

//
// The associated game session has terminated 
//
#define	DPLSESSION_TERMINATED				0x0004

// 
// The associated game session's host has migrated 
//
#define DPLSESSION_HOSTMIGRATED				0x0005

//
// The associated game session's host has migrated to the local client
//
#define DPLSESSION_HOSTMIGRATEDHERE			0x0006


/****************************************************************************
 *
 * DirectPlay8 Lobby Flags
 *
 ****************************************************************************/

//
// Do not automatically make the lobby app unavailable when a connection is established
//
#define DPLAVAILABLE_ALLOWMULTIPLECONNECT   0x0001

//
// Launch a new instance of the application to connect to
// 
#define	DPLCONNECT_LAUNCHNEW				0x0001

// 
// Launch a new instance of the application if one is not waiting
//
#define	DPLCONNECT_LAUNCHNOTFOUND			0x0002

//
// When starting the associated game session, start it as a host
//
#define DPLCONNECTSETTINGS_HOST             0x0001

// 
// Disable parameter validation
//
#define DPLINITIALIZE_DISABLEPARAMVAL		0x0001

/****************************************************************************
 *
 * DirectPlay8Lobby Structures (Non-Message)
 *
 ****************************************************************************/

// 
// Information on a registered game
//
typedef struct _DPL_APPLICATION_INFO {
	GUID	guidApplication;            // GUID of the application
	PWSTR	pwszApplicationName;        // Name of the application
	DWORD	dwNumRunning;               // # of instances of this application running
	DWORD	dwNumWaiting;               // # of instances of this application waiting 
	DWORD	dwFlags;                    // Flags
} DPL_APPLICATION_INFO,  *PDPL_APPLICATION_INFO;

//
// Settings to be used for connecting / hosting a game session
//
typedef struct _DPL_CONNECTION_SETTINGS {
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Connection settings flags (DPLCONNECTSETTINGS_...)
    DPN_APPLICATION_DESC    dpnAppDesc;             // Application desc for the associated DirectPlay session
    IDirectPlay8Address     *pdp8HostAddress;       // Address of host to connect to
    IDirectPlay8Address     **ppdp8DeviceAddresses; // Address of device to connect from / host on
    DWORD                   cNumDeviceAddresses;    // # of addresses specified in ppdp8DeviceAddresses
	PWSTR					pwszPlayerName;         // Name to give the player
} DPL_CONNECTION_SETTINGS, *PDPL_CONNECTION_SETTINGS;

//
// Information for performing a lobby connect
// (ConnectApplication)
//
typedef struct _DPL_CONNECT_INFO {
	DWORD	                    dwSize;             // Size of this structure
	DWORD	                    dwFlags;            // Flags (DPLCONNECT_...)
	GUID	                    guidApplication;    // GUID of application to launch
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;
                                                    // Settings application should use
	PVOID	                    pvLobbyConnectData; // User defined data block
	DWORD	                    dwLobbyConnectDataSize;
                                                    // Size of user defined data block
} DPL_CONNECT_INFO,  *PDPL_CONNECT_INFO;

//
// Information for registering an application
// (RegisterApplication)
//
typedef struct  _DPL_PROGRAM_DESC {
	DWORD	dwSize;
	DWORD	dwFlags;
	GUID	guidApplication;		                // Application GUID
	PWSTR	pwszApplicationName;	                // Unicode application name
	PWSTR	pwszCommandLine;		                // Unicode command line arguments
	PWSTR	pwszCurrentDirectory;               	// Unicode current directory
	PWSTR	pwszDescription;		                // Unicode application description
	PWSTR	pwszExecutableFilename;	                // Unicode filename of application executable
	PWSTR	pwszExecutablePath;		                // Unicode path of application executable
	PWSTR	pwszLauncherFilename;	                // Unicode filename of launcher executable
	PWSTR	pwszLauncherPath;		                // Unicode path of launcher executable
} DPL_PROGRAM_DESC, *PDPL_PROGRAM_DESC;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message Structures
 *
 ****************************************************************************/

//
// A connection was established 
// (DPL_MSGID_CONNECT)
//
typedef struct _DPL_MESSAGE_CONNECT
{
	DWORD		                dwSize;                     // Size of this structure
	DPNHANDLE	                hConnectId;                 // Handle of new connection
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;	    // Connection settings for this connection
	PVOID		                pvLobbyConnectData;         // User defined lobby data block
	DWORD		                dwLobbyConnectDataSize;     // Size of user defined lobby data block
	PVOID						pvConnectionContext;        // Context value for this connection (user set)
} DPL_MESSAGE_CONNECT, *PDPL_MESSAGE_CONNECT;

// 
// Connection settings have been updated
// (DPL_MSGID_CONNECTION_SETTINGS)
//
typedef struct _DPL_MESSAGE_CONNECTION_SETTINGS
{
    DWORD                       dwSize;                     // Size of this structure
    DPNHANDLE                   hSender;                    // Handle of the connection for these settings
    PDPL_CONNECTION_SETTINGS    pdplConnectionSettings;     // Connection settings
	PVOID					    pvConnectionContext;        // Context value for this connection
} DPL_MESSAGE_CONNECTION_SETTINGS, *PDPL_MESSAGE_CONNECTION_SETTINGS;

//
// A connection has been disconnected
// (DPL_MSGID_DISCONNECT)
//
typedef struct _DPL_MESSAGE_DISCONNECT
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hDisconnectId;                              // Handle of the connection that was terminated
	HRESULT     hrReason;                                   // Reason the connection was broken
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_DISCONNECT, *PDPL_MESSAGE_DISCONNECT;

//
// Data was received through a connection
// (DPL_MSGID_RECEIVE)
//
typedef struct _DPL_MESSAGE_RECEIVE
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that is from
	BYTE		*pBuffer;                                   // Contents of the message
	DWORD		dwBufferSize;                               // Size of the message context 
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_RECEIVE, *PDPL_MESSAGE_RECEIVE;

//
// Current status of the associated connection
// (DPL_MSGID_SESSION_STATUS)
//
typedef struct _DPL_MESSAGE_SESSION_STATUS
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that this is from
	DWORD		dwStatus;                                   // Status (DPLSESSION_...)
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_SESSION_STATUS, *PDPL_MESSAGE_SESSION_STATUS;

/****************************************************************************
 *
 * DirectPlay8Lobby Create
 *
 ****************************************************************************/

extern HRESULT WINAPI DirectPlay8LobbyCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);

/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

//
// COM definition for DirectPlayLobbyClient
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbyClient
DECLARE_INTERFACE_(IDirectPlay8LobbyClient,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbyClient methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,const DWORD dwFlags) PURE;
	STDMETHOD(EnumLocalPrograms)		(THIS_ GUID *const pGuidApplication,BYTE *const pEnumData,DWORD *const pdwEnumData,DWORD *const pdwItems, const DWORD dwFlags) PURE;
	STDMETHOD(ConnectApplication)		(THIS_ DPL_CONNECT_INFO *const pdplConnectionInfo,const PVOID pvConnectionContext,DPNHANDLE *const hApplication,const DWORD dwTimeOut,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(ReleaseApplication)		(THIS_ const DPNHANDLE hConnection, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)    				(THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;	
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


//
// COM definition for DirectPlayLobbiedApplication
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbiedApplication
DECLARE_INTERFACE_(IDirectPlay8LobbiedApplication,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid,LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbiedApplication methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,DPNHANDLE * const pdpnhConnection, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterProgram)			(THIS_ PDPL_PROGRAM_DESC pdplProgramDesc,const DWORD dwFlags) PURE;
	STDMETHOD(UnRegisterProgram)		(THIS_ GUID *pguidApplication,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(SetAppAvailable)			(THIS_ const BOOL fAvailable, const DWORD dwFlags ) PURE;
	STDMETHOD(UpdateStatus)				(THIS_ const DPNHANDLE hConnection, const DWORD dwStatus, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)				    (THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


/****************************************************************************
 *
 * DirectPlayLobby Interface Macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbyClient_Release(p)						        (p)->lpVtbl->Release(p)
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->lpVtbl->EnumLocalPrograms(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->lpVtbl->ConnectApplication(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->lpVtbl->ReleaseApplication(p,a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->lpVtbl->Release(p)
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->lpVtbl->Initialize(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->lpVtbl->RegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->lpVtbl->UnRegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->lpVtbl->SetAppAvailable(p,a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->lpVtbl->UpdateStatus(p,a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#else	/* C++ */

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->QueryInterface(a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->AddRef()
#define IDirectPlay8LobbyClient_Release(p)						        (p)->Release()
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->Initialize(a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->EnumLocalPrograms(a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->ConnectApplication(a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->Send(a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->ReleaseApplication(a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->Close(a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->SetConnectionSettings(a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->AddRef()
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->Release()
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->Initialize(a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->RegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->UnRegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->Send(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->SetAppAvailable(a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->UpdateStatus(a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->Close(a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->SetConnectionSettings(a,b,c)

#endif

#ifdef __cplusplus
}
#endif

#endif	// __DPLOBBY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsquery.h ===
#ifndef __dsquery_h
#define __dsquery_h

//
// query handler ID for dsquery.
//

DEFINE_GUID(CLSID_DsQuery, 0x8a23e65e, 0x31c2, 0x11d0, 0x89, 0x1c, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// standard forms shipped in dsquery.dll
//

DEFINE_GUID(CLSID_DsFindObjects, 0x83ee3fe1, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPeople, 0x83ee3fe2, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPrinter, 0xb577f070, 0x7ee2, 0x11d0, 0x91, 0x3f, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindComputer, 0x16006700, 0x87ad, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindVolume, 0xc1b3cbf1, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindContainer, 0xc1b3cbf2, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindAdvanced, 0x83ee3fe3, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// admin forms
//

DEFINE_GUID(CLSID_DsFindDomainController, 0x538c7b7e, 0xd25e, 0x11d0, 0x97, 0x42, 0x0, 0xa0, 0xc9, 0x6, 0xaf, 0x45);
DEFINE_GUID(CLSID_DsFindFrsMembers, 0x94ce4b18, 0xb3d3, 0x11d1, 0xb9, 0xb4, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);


#ifndef GUID_DEFS_ONLY

//
// DSQUERYINITPARAMS
// -----------------
//  This structured is used when creating a new query view.
//

#define DSQPF_NOSAVE                 0x00000001 // = 1 => remove save verb
#define DSQPF_SAVELOCATION           0x00000002 // = 1 => pSaveLocation contains directory to save queries into
#define DSQPF_SHOWHIDDENOBJECTS      0x00000004 // = 1 => show objects marked as "hidden" in results
#define DSQPF_ENABLEADMINFEATURES    0x00000008 // = 1 => show admin verbs, property pages etc
#define DSQPF_ENABLEADVANCEDFEATURES 0x00000010 // = 1 => set the advanced flag for the property pages
#define DSQPF_HASCREDENTIALS         0x00000020 // = 1 => pServer, pUserName & pPassword are valid

typedef struct
{
    DWORD  cbStruct;
    DWORD  dwFlags;
    LPWSTR pDefaultScope;           // -> Active Directory path to use as scope / == NULL for none
    LPWSTR pDefaultSaveLocation;    // -> Directory to save queries into / == NULL default location
    LPWSTR pUserName;               // -> user name to authenticate with
    LPWSTR pPassword;               // -> password for authentication
    LPWSTR pServer;                 // -> server to use for obtaining trusts etc
} DSQUERYINITPARAMS, * LPDSQUERYINITPARAMS;


//
// DSQUERYPARAMS
// -------------
//  The DS query handle takes a packed structure which contains the
//  columns and query to be issued.
//

#define CFSTR_DSQUERYPARAMS         TEXT("DsQueryParameters")

#define DSCOLUMNPROP_ADSPATH        ((LONG)(-1))
#define DSCOLUMNPROP_OBJECTCLASS    ((LONG)(-2))

typedef struct
{
    DWORD dwFlags;                  // flags for this column
    INT   fmt;                      // list view form information
    INT   cx;                       // default column width
    INT   idsName;                  // resource ID for the column dispaly name
    LONG  offsetProperty;           // offset to BSTR defining column ADs property name
    DWORD dwReserved;               // reserved field
} DSCOLUMN, * LPDSCOLUMN;

typedef struct
{
    DWORD     cbStruct;
    DWORD     dwFlags;
    HINSTANCE hInstance;            // instance handle used for string extraction
    LONG      offsetQuery;          // offset to LDAP filter string
    LONG      iColumns;             // column count
    DWORD     dwReserved;           // reserved field for this query
    DSCOLUMN  aColumns[1];          // array of column descriptions
} DSQUERYPARAMS, * LPDSQUERYPARAMS;


//
// CF_DSQUERYSCOPE
// ---------------
//  A clipboard format the puts a string version of the scope into a
//  storage medium via GlobalAlloc.
//
#define CFSTR_DSQUERYSCOPE         TEXT("DsQueryScope")


//
// DSQPM_GETCLASSLIST
// ------------------
//  This page message is sent to the form pages to retrieve the list of classes
//  that the pages are going to query from.  This is used by the feild selector
//  and the property well to build its list of display classes.
//

typedef struct
{
    DWORD   cbStruct;
    LONG    cClasses;               // number of classes in array
    DWORD   offsetClass[1];         // offset to the class names (UNICODE)
} DSQUERYCLASSLIST, * LPDSQUERYCLASSLIST;


#define DSQPM_GETCLASSLIST          (CQPM_HANDLERSPECIFIC+0) // wParam == flags, lParam = LPLPDSQUERYCLASSLIST


//
// DSQPM_HELPTOPICS
// ----------------
//  This page message is sent to the form pages to allow them to handle the
//  "Help Topics" verb.
//

#define DSQPM_HELPTOPICS            (CQPM_HANDLERSPECIFIC+1) // wParam = 0, lParam = hWnd parent



#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dshow.h ===
///////////////////////////////////////////////////////////////////////////
// Copyright (C) 2000 Microsoft Corporation.  All Right Reserved.
//
// File:		dshow.h
// Content:     DirectShow top-level include file
///////////////////////////////////////////////////////////////////////////

#ifndef __DSHOW_INCLUDED__
#define __DSHOW_INCLUDED__

///////////////////////////////////////////////////////////////////////////
// Set up constants & pragmas for the compiler
///////////////////////////////////////////////////////////////////////////
#ifdef	_MSC_VER
// disable some level-4 warnings, use #pragma warning(enable:###) to re-enable
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4511) // warning C4511: copy constructor could not be generated
#pragma warning(disable:4512) // warning C4512: assignment operator could not be generated
#pragma warning(disable:4514) // warning C4514: "unreferenced inline function has been removed"

#if _MSC_VER>=1100
#define AM_NOVTABLE __declspec(novtable)
#else
#define AM_NOVTABLE
#endif
#endif	// MSC_VER

///////////////////////////////////////////////////////////////////////////
// Include standard Windows files
///////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include <olectl.h>
#include <ddraw.h>
#include <mmsystem.h>

#ifndef NUMELMS
   #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

///////////////////////////////////////////////////////////////////////////
// Include DirectShow include files
///////////////////////////////////////////////////////////////////////////
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <amvideo.h>    // ActiveMovie video interfaces and definitions
#include <amaudio.h>    // ActiveMovie audio interfaces and definitions
#include <control.h>    // generated from control.odl
#include <evcode.h>     // event code definitions
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <errors.h>     // HRESULT status and error definitions
#include <edevdefs.h>   // External device control interface defines
#include <audevcod.h>   // audio filter device error event codes
#include <dvdevcod.h>   // DVD error event codes

///////////////////////////////////////////////////////////////////////////
// Define OLE Automation constants
///////////////////////////////////////////////////////////////////////////
#ifndef OATRUE
#define OATRUE (-1)
#endif // OATRUE
#ifndef OAFALSE
#define OAFALSE (0)
#endif // OAFALSE

///////////////////////////////////////////////////////////////////////////
// Define Win64 interfaces if not already defined
///////////////////////////////////////////////////////////////////////////

// InterlockedExchangePointer
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))
#endif 


#endif // __DSHOW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsgetdc.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    dsgetdc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the DsGetDcName API.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _DSGETDC_
#define _DSGETDC_

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_DSGETDCAPI_)
#define DSGETDCAPI DECLSPEC_IMPORT
#else
#define DSGETDCAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure definitions
//

//
// Flags to passed to DsGetDcName
//

#define DS_FORCE_REDISCOVERY            0x00000001

#define DS_DIRECTORY_SERVICE_REQUIRED   0x00000010
#define DS_DIRECTORY_SERVICE_PREFERRED  0x00000020
#define DS_GC_SERVER_REQUIRED           0x00000040
#define DS_PDC_REQUIRED                 0x00000080
#define DS_BACKGROUND_ONLY              0x00000100
#define DS_IP_REQUIRED                  0x00000200
#define DS_KDC_REQUIRED                 0x00000400
#define DS_TIMESERV_REQUIRED            0x00000800
#define DS_WRITABLE_REQUIRED            0x00001000
#define DS_GOOD_TIMESERV_PREFERRED      0x00002000
#define DS_AVOID_SELF                   0x00004000
#define DS_ONLY_LDAP_NEEDED             0x00008000


#define DS_IS_FLAT_NAME                 0x00010000
#define DS_IS_DNS_NAME                  0x00020000

#define DS_RETURN_DNS_NAME              0x40000000
#define DS_RETURN_FLAT_NAME             0x80000000

#define DSGETDC_VALID_FLAGS ( \
            DS_FORCE_REDISCOVERY | \
            DS_DIRECTORY_SERVICE_REQUIRED | \
            DS_DIRECTORY_SERVICE_PREFERRED | \
            DS_GC_SERVER_REQUIRED | \
            DS_PDC_REQUIRED | \
            DS_BACKGROUND_ONLY | \
            DS_IP_REQUIRED | \
            DS_KDC_REQUIRED | \
            DS_TIMESERV_REQUIRED | \
            DS_WRITABLE_REQUIRED | \
            DS_GOOD_TIMESERV_PREFERRED | \
            DS_AVOID_SELF | \
            DS_ONLY_LDAP_NEEDED | \
            DS_IS_FLAT_NAME | \
            DS_IS_DNS_NAME | \
            DS_RETURN_FLAT_NAME  | \
            DS_RETURN_DNS_NAME )


//
// Structure returned from DsGetDcName
//

typedef struct _DOMAIN_CONTROLLER_INFOA {
    LPSTR DomainControllerName;
    LPSTR DomainControllerAddress;
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
    LPSTR DomainName;
    LPSTR DnsForestName;
    ULONG Flags;
    LPSTR DcSiteName;
    LPSTR ClientSiteName;
} DOMAIN_CONTROLLER_INFOA, *PDOMAIN_CONTROLLER_INFOA;

typedef struct _DOMAIN_CONTROLLER_INFOW {
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerName;
#else // MIDL_PASS
    LPWSTR DomainControllerName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerAddress;
#else // MIDL_PASS
    LPWSTR DomainControllerAddress;
#endif // MIDL_PASS
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainName;
#else // MIDL_PASS
    LPWSTR DomainName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DnsForestName;
#else // MIDL_PASS
    LPWSTR DnsForestName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DcSiteName;
#else // MIDL_PASS
    LPWSTR DcSiteName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *ClientSiteName;
#else // MIDL_PASS
    LPWSTR ClientSiteName;
#endif // MIDL_PASS
} DOMAIN_CONTROLLER_INFOW, *PDOMAIN_CONTROLLER_INFOW;

#ifdef UNICODE
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOW
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOW
#else
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOA
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOA
#endif // !UNICODE

//
// Values for DomainControllerAddressType
//

#define DS_INET_ADDRESS    1
#define DS_NETBIOS_ADDRESS 2

//
// Values for returned Flags
//

#define DS_PDC_FLAG            0x00000001    // DC is PDC of Domain
#define DS_GC_FLAG             0x00000004    // DC is a GC of forest
#define DS_LDAP_FLAG           0x00000008    // Server supports an LDAP server
#define DS_DS_FLAG             0x00000010    // DC supports a DS and is a Domain Controller
#define DS_KDC_FLAG            0x00000020    // DC is running KDC service
#define DS_TIMESERV_FLAG       0x00000040    // DC is running time service
#define DS_CLOSEST_FLAG        0x00000080    // DC is in closest site to client
#define DS_WRITABLE_FLAG       0x00000100    // DC has a writable DS
#define DS_GOOD_TIMESERV_FLAG  0x00000200    // DC is running time service (and has clock hardware)
#define DS_PING_FLAGS          0x0000FFFF    // Flags returned on ping

#define DS_DNS_CONTROLLER_FLAG 0x20000000    // DomainControllerName is a DNS name
#define DS_DNS_DOMAIN_FLAG     0x40000000    // DomainName is a DNS name
#define DS_DNS_FOREST_FLAG     0x80000000    // DnsForestName is a DNS name


//
// Function Prototypes
//

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameA(
    IN LPCSTR ComputerName OPTIONAL,
    IN LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
);

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

#ifdef UNICODE
#define DsGetDcName DsGetDcNameW
#else
#define DsGetDcName DsGetDcNameA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameA(
    IN LPCSTR ComputerName OPTIONAL,
    OUT LPSTR *SiteName
);

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    OUT LPWSTR *SiteName
);

#ifdef UNICODE
#define DsGetSiteName DsGetSiteNameW
#else
#define DsGetSiteName DsGetSiteNameA
#endif // !UNICODE


DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameW(
    IN LPCWSTR SubnetName
);

DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameA(
    IN LPCSTR SubnetName
);

#ifdef UNICODE
#define DsValidateSubnetName DsValidateSubnetNameW
#else
#define DsValidateSubnetName DsValidateSubnetNameA
#endif // !UNICODE


//
// Only include if winsock2.h has been included
//
#ifdef _WINSOCK2API_
DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesA(
    IN LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsAddressToSiteNames DsAddressToSiteNamesW
#else
#define DsAddressToSiteNames DsAddressToSiteNamesA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames,
    OUT LPWSTR **SubnetNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExA(
    IN LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPSTR **SiteNames,
    OUT LPSTR **SubnetNames
    );

#ifdef UNICODE
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExW
#else
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExA
#endif // !UNICODE
#endif // _WINSOCK2API_

//
// API to enumerate trusted domains
//

typedef struct _DS_DOMAIN_TRUSTSW {

    //
    // Name of the trusted domain.
    //
#ifdef MIDL_PASS
    [string] wchar_t * NetbiosDomainName;
    [string] wchar_t * DnsDomainName;
#else // MIDL_PASS
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
#endif // MIDL_PASS


    //
    // Flags defining attributes of the trust.
    //
    ULONG Flags;
#define DS_DOMAIN_IN_FOREST           0x0001  // Domain is a member of the forest
#define DS_DOMAIN_DIRECT_OUTBOUND     0x0002  // Domain is directly trusted
#define DS_DOMAIN_TREE_ROOT           0x0004  // Domain is root of a tree in the forest
#define DS_DOMAIN_PRIMARY             0x0008  // Domain is the primary domain of queried server
#define DS_DOMAIN_NATIVE_MODE         0x0010  // Primary domain is running in native mode
#define DS_DOMAIN_DIRECT_INBOUND      0x0020  // Domain is directly trusting
#define DS_DOMAIN_VALID_FLAGS (         \
            DS_DOMAIN_IN_FOREST       | \
            DS_DOMAIN_DIRECT_OUTBOUND | \
            DS_DOMAIN_TREE_ROOT       | \
            DS_DOMAIN_PRIMARY         | \
            DS_DOMAIN_NATIVE_MODE     | \
            DS_DOMAIN_DIRECT_INBOUND )

    //
    // Index to the domain that is the parent of this domain.
    //  Only defined if NETLOGON_DOMAIN_IN_FOREST is set and
    //      NETLOGON_DOMAIN_TREE_ROOT is not set.
    //
    ULONG ParentIndex;

    //
    // The trust type and attributes of this trust.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  these value are infered.
    //
    ULONG TrustType;
    ULONG TrustAttributes;

    //
    // The SID of the trusted domain.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  this value will be NULL.
    //
#if defined(MIDL_PASS)
    PISID DomainSid;
#else
    PSID DomainSid;
#endif

    //
    // The GUID of the trusted domain.
    //

    GUID DomainGuid;

} DS_DOMAIN_TRUSTSW, *PDS_DOMAIN_TRUSTSW;

//
// ANSI version of the above struct
//
typedef struct _DS_DOMAIN_TRUSTSA {
    LPSTR NetbiosDomainName;
    LPSTR DnsDomainName;
    ULONG Flags;
    ULONG ParentIndex;
    ULONG TrustType;
    ULONG TrustAttributes;
    PSID DomainSid;
    GUID DomainGuid;
} DS_DOMAIN_TRUSTSA, *PDS_DOMAIN_TRUSTSA;

#ifdef UNICODE
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSW
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSW
#else
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSA
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsW (
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *Domains,
    OUT PULONG DomainCount
    );

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsA (
    IN LPSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSA *Domains,
    OUT PULONG DomainCount
    );

#ifdef UNICODE
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsW
#else
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN LPCWSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageA(
    IN LPCSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsGetDcSiteCoverage DsGetDcSiteCoverageW
#else
#define DsGetDcSiteCoverage DsGetDcSiteCoverageA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsW (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID   *DomainGuid OPTIONAL,
    IN GUID   *DsaGuid OPTIONAL,
    IN LPWSTR DnsHostName
    );

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsA (
    IN LPSTR ServerName OPTIONAL,
    IN LPSTR DnsDomainName OPTIONAL,
    IN GUID  *DomainGuid OPTIONAL,
    IN GUID  *DsaGuid OPTIONAL,
    IN LPSTR DnsHostName
    );

#ifdef UNICODE
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsW
#else
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif // _DSGETDC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dshowasf.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for dshowasf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dshowasf_h__
#define __dshowasf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IConfigAsfWriter_FWD_DEFINED__
#define __IConfigAsfWriter_FWD_DEFINED__
typedef interface IConfigAsfWriter IConfigAsfWriter;
#endif 	/* __IConfigAsfWriter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"
#include "wmsdkidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dshowasf_0000 */
/* [local] */ 

EXTERN_GUID( IID_IConfigAsfWriter,0x45086030,0xF7E4,0x486a,0xB5,0x04,0x82,0x6B,0xB5,0x79,0x2A,0x3B );




extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_s_ifspec;

#ifndef __IConfigAsfWriter_INTERFACE_DEFINED__
#define __IConfigAsfWriter_INTERFACE_DEFINED__

/* interface IConfigAsfWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAsfWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45086030-F7E4-486a-B504-826BB5792A3B")
    IConfigAsfWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileId( 
            /* [in] */ DWORD dwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileId( 
            /* [out] */ DWORD *pdwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileGuid( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileGuid( 
            /* [out] */ GUID *pProfileGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfile( 
            /* [in] */ IWMProfile *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfile( 
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexMode( 
            /* [in] */ BOOL bIndexFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexMode( 
            /* [out] */ BOOL *pbIndexFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAsfWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAsfWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAsfWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAsfWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileId )( 
            IConfigAsfWriter * This,
            /* [in] */ DWORD dwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileId )( 
            IConfigAsfWriter * This,
            /* [out] */ DWORD *pdwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileGuid )( 
            IConfigAsfWriter * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileGuid )( 
            IConfigAsfWriter * This,
            /* [out] */ GUID *pProfileGuid);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfile )( 
            IConfigAsfWriter * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfile )( 
            IConfigAsfWriter * This,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexMode )( 
            IConfigAsfWriter * This,
            /* [in] */ BOOL bIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexMode )( 
            IConfigAsfWriter * This,
            /* [out] */ BOOL *pbIndexFile);
        
        END_INTERFACE
    } IConfigAsfWriterVtbl;

    interface IConfigAsfWriter
    {
        CONST_VTBL struct IConfigAsfWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAsfWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConfigAsfWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConfigAsfWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConfigAsfWriter_ConfigureFilterUsingProfileId(This,dwProfileId)	\
    (This)->lpVtbl -> ConfigureFilterUsingProfileId(This,dwProfileId)

#define IConfigAsfWriter_GetCurrentProfileId(This,pdwProfileId)	\
    (This)->lpVtbl -> GetCurrentProfileId(This,pdwProfileId)

#define IConfigAsfWriter_ConfigureFilterUsingProfileGuid(This,guidProfile)	\
    (This)->lpVtbl -> ConfigureFilterUsingProfileGuid(This,guidProfile)

#define IConfigAsfWriter_GetCurrentProfileGuid(This,pProfileGuid)	\
    (This)->lpVtbl -> GetCurrentProfileGuid(This,pProfileGuid)

#define IConfigAsfWriter_ConfigureFilterUsingProfile(This,pProfile)	\
    (This)->lpVtbl -> ConfigureFilterUsingProfile(This,pProfile)

#define IConfigAsfWriter_GetCurrentProfile(This,ppProfile)	\
    (This)->lpVtbl -> GetCurrentProfile(This,ppProfile)

#define IConfigAsfWriter_SetIndexMode(This,bIndexFile)	\
    (This)->lpVtbl -> SetIndexMode(This,bIndexFile)

#define IConfigAsfWriter_GetIndexMode(This,pbIndexFile)	\
    (This)->lpVtbl -> GetIndexMode(This,pbIndexFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ DWORD dwProfileId);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ DWORD *pdwProfileId);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ GUID *pProfileGuid);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ IWMProfile *pProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_SetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ BOOL bIndexFile);


void __RPC_STUB IConfigAsfWriter_SetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ BOOL *pbIndexFile);


void __RPC_STUB IConfigAsfWriter_GetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAsfWriter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsrole.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dsrole.h

Abstract:

    This module contains the public interfaces to query the network roles of 
    workstations, servers, and DCs

--*/

#ifndef __DSROLE_H__
#define __DSROLE_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

//
// Domain information
//
typedef enum _DSROLE_MACHINE_ROLE {

    DsRole_RoleStandaloneWorkstation,
    DsRole_RoleMemberWorkstation,
    DsRole_RoleStandaloneServer,
    DsRole_RoleMemberServer,
    DsRole_RoleBackupDomainController,
    DsRole_RolePrimaryDomainController

} DSROLE_MACHINE_ROLE;

//
// Previous server state
//
typedef enum _DSROLE_SERVER_STATE {

    DsRoleServerUnknown = 0,
    DsRoleServerPrimary,
    DsRoleServerBackup

} DSROLE_SERVER_STATE, *PDSROLE_SERVER_STATE;

typedef enum _DSROLE_PRIMARY_DOMAIN_INFO_LEVEL {

    DsRolePrimaryDomainInfoBasic = 1,
    DsRoleUpgradeStatus,
    DsRoleOperationState

} DSROLE_PRIMARY_DOMAIN_INFO_LEVEL;

//
// Flags to be used with the PRIMARY_DOMAIN_INFO_LEVEL structures below
//
#define DSROLE_PRIMARY_DS_RUNNING           0x00000001
#define DSROLE_PRIMARY_DS_MIXED_MODE        0x00000002
#define DSROLE_UPGRADE_IN_PROGRESS          0x00000004
#define DSROLE_PRIMARY_DOMAIN_GUID_PRESENT  0x01000000

//
// Structure that correspond to the DSROLE_PRIMARY_DOMAIN_INFO_LEVEL
//
typedef struct _DSROLE_PRIMARY_DOMAIN_INFO_BASIC {

    DSROLE_MACHINE_ROLE MachineRole;
    ULONG Flags;
    LPWSTR DomainNameFlat;
    LPWSTR DomainNameDns;
    LPWSTR DomainForestName;
    GUID DomainGuid;

} DSROLE_PRIMARY_DOMAIN_INFO_BASIC, *PDSROLE_PRIMARY_DOMAIN_INFO_BASIC;

typedef struct _DSROLE_UPGRADE_STATUS_INFO {

    ULONG OperationState;
    DSROLE_SERVER_STATE PreviousServerState;

} DSROLE_UPGRADE_STATUS_INFO, *PDSROLE_UPGRADE_STATUS_INFO;

typedef enum _DSROLE_OPERATION_STATE {

    DsRoleOperationIdle = 0,
    DsRoleOperationActive,
    DsRoleOperationNeedReboot

} DSROLE_OPERATION_STATE;

typedef struct _DSROLE_OPERATION_STATE_INFO {

    DSROLE_OPERATION_STATE OperationState;

} DSROLE_OPERATION_STATE_INFO, *PDSROLE_OPERATION_STATE_INFO;

DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer 
    );

VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    );


#ifdef __cplusplus
}
#endif

#endif // __DSROLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dssclien.h ===
#ifndef DSSCLIENT_H
#define DSSCLIENT_H
// DSSCLIENT.H
//
// Application-level constants and data structure definitions for DSS applications
//  on the broadcast PC platform.
//
//  Copyright (c) 1996 - 1997 Microsoft Corp
//  All rights reserved.

// Upper edge events

typedef double NDCDATE;            // from WTYPES.H

// Upper edge purchase details

typedef struct BPCDetails {
    SHORT   iChannel;       // channel number.  Might not be in tunable range
    NDCDATE tStartTime;     // starting time
    NDCDATE tExpiry;        // from HPO as two fields (for offers only)
    LONG    lDuration;      // program item duration in seconds
    LONG    iItemID;        // provider-supplied item identifier
    LONG    iLocation;      // for DSS, is transponder of PIP
    LONG    lUserId;        // for DSS, is CAM ID (history use, only)
    LONG    iStorageId;     // provider-specific storage identifier
    BSTR    szTitle;        // title.
    LONG    iRating;        // event rating
    BSTR    szYear;         // item year as string for UI
    BSTR    szDescription;  // Description string
    CURRENCY ViewCost;      // event cost in units of smallest currency
    CURRENCY TapeCost;      // event cost to tape
    PURCHASEACTION iAction; // Action/Status of item (see below)
    LONG    lStatus;        // bitmask indicator of item status
    LONG    iReason;        // explanation for service denial/error
    BSTR    szReason;       // text expression of iReason
    BSTR    rgbCwpBuffer;   // storage for encrypted cwp (DSS)
#ifdef __cplusplus
    inline BPCDetails() {
        memset(this, 0, sizeof(*this));
        iRating = -1;  // make sure we know this didn't come from verifier
    }
    inline BPCDetails(const BPCDetails &det) {
        // shallow copy everything
        memcpy(this, &det, sizeof(*this));
        // deep copy the allocated structures
        if (det.szDescription) szDescription = ::SysAllocString(det.szDescription);
        if (det.szYear) szYear = ::SysAllocString(det.szYear);
        if (det.szTitle) szTitle = ::SysAllocString(det.szTitle);
        if (det.szReason) szReason = ::SysAllocString(det.szReason);
        if (det.rgbCwpBuffer) rgbCwpBuffer  = ::SysAllocString(det.rgbCwpBuffer);
    }
    inline ~BPCDetails() {
        if (szDescription) ::SysFreeString(szDescription);
        if (szYear) ::SysFreeString(szYear);
        if (szTitle) ::SysFreeString(szTitle);
        if (szReason) ::SysFreeString(szReason);
        if (rgbCwpBuffer) ::SysFreeString(rgbCwpBuffer);
#ifdef _DEBUG
        memset(this, 0, sizeof(*this));
#endif
    }
    inline BPCDetails &operator=(const BPCDetails &det) {
        if (this != &det) {
            // shallow copy everything
            memcpy(this, &det, sizeof(*this));
            // deep copy the allocated structures
            if (det.szDescription) szDescription = ::SysAllocString(det.szDescription);
            if (det.szYear) szYear = ::SysAllocString(det.szYear);
            if (det.szTitle) szTitle = ::SysAllocString(det.szTitle);
            if (det.szReason) szReason = ::SysAllocString(det.szReason);
            if (det.rgbCwpBuffer) rgbCwpBuffer  = ::SysAllocString(det.rgbCwpBuffer);
        }
        return *this;
    }
    inline bool operator==(const BPCDetails &det) const {
        return (iItemID == det.iItemID && iStorageId == det.iStorageId);
    }
    inline bool operator!=(const BPCDetails &det) const {
        return !(det == *this);
    }
    inline bool operator<(const BPCDetails &det) const {
        return (iItemID < det.iItemID || (iItemID == det.iItemID && iStorageId < det.iStorageId));
    }
    inline bool operator>(const BPCDetails &det) const {
        return (iItemID > det.iItemID || (iItemID == det.iItemID && iStorageId > det.iStorageId));
    }

#endif
} BPCDETAILS, *LPBPCDETAILS;

typedef struct ProviderMsg {
    LONG    iMsgId;                 // used for association
    BOOL    fIsRead;                // nonzero if read by user
    LONG    lUserId;                // for DSS is 4 byte CAM ID
    NDCDATE odDateTimeStamp;        // OLE DATE type
    NDCDATE odExpiry;               // OLE DATE type
    BSTR    szTitle;                // may not be null for tombstone
    BSTR    szMessageText;          // if null, is tombstone
#ifdef __cplusplus
    inline ProviderMsg() {
        memset(this, 0, sizeof(*this));
    }
    inline ProviderMsg(const ProviderMsg &msg) {
        // shallow copy everything
        memcpy(this, &msg, sizeof(*this));
        // deep copy the allocated structures
        if (msg.szTitle) szTitle = ::SysAllocString(msg.szTitle);
        if (msg.szMessageText) szMessageText = ::SysAllocString(msg.szMessageText);
    }
    inline ~ProviderMsg() {
        if (szTitle) ::SysFreeString(szTitle);
        if (szMessageText) ::SysFreeString(szMessageText);
#ifdef _DEBUG
        memset(this, 0, sizeof(*this));
#endif
    }
    inline ProviderMsg &operator=(const ProviderMsg &msg) {
        if (this != &msg) {
            // shallow copy everything
            memcpy(this, &msg, sizeof(*this));
            // deep copy the allocated structures
            if (msg.szTitle) szTitle = ::SysAllocString(msg.szTitle);
            if (msg.szMessageText) szMessageText = ::SysAllocString(msg.szMessageText);
        }
        return *this;
    }
    inline bool operator==(const ProviderMsg &msg) const {
        return (lUserId == msg.lUserId && iMsgId == msg.iMsgId);
    }
    inline bool operator!=(const ProviderMsg &msg) const {
        return !(msg == *this);
    }
    inline bool operator<(const ProviderMsg &msg) const {
        return (lUserId < msg.lUserId || (lUserId == msg.lUserId && iMsgId < msg.iMsgId));
    }
    inline bool operator>(const ProviderMsg &msg) const {
        return (lUserId > msg.lUserId || (lUserId == msg.lUserId && iMsgId > msg.iMsgId));
    }

#endif
} PROVIDERMSG,*LPPROVIDERMSG;

typedef struct ExplicitOsd {
    DWORD   dwAttributes;
    BSTR    bsString;
#ifdef __cplusplus
    inline ExplicitOsd() { memset(this, 0, sizeof(*this)); }
    inline ExplicitOsd(ExplicitOsd &osd) {
        // shallow copy everything
        memcpy(this, &osd, sizeof(*this));
        // deep copy the allocated structures
        if (osd.bsString) bsString = ::SysAllocString(osd.bsString);
    }
    inline ~ExplicitOsd() {
        if (bsString) ::SysFreeString(bsString);
#ifdef _DEBUG
        memset(this, 0, sizeof(*this));
#endif
    }
    inline ExplicitOsd &operator=(ExplicitOsd &osd) {
        if (this != &osd) {
            // shallow copy everything
            memcpy(this, &osd, sizeof(*this));
            // deep copy the allocated structures
            if (osd.bsString) bsString = ::SysAllocString(osd.bsString);
        }
        return *this;
    }
#endif
} EXPLICITOSD,*LPEXPLICITOSD;

#endif

// End of Source File

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dskquota.h ===
/**************************************************************************
*                                                                         *
*   dskquota.h --  public header for Windows 2000 disk quota interfaces.  *
*                                                                         *
*   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.         *
*                                                                         *
**************************************************************************/
#ifndef __DSKQUOTA_H
#define __DSKQUOTA_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINDOWS_
#include <windows.h>
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#endif

#ifndef _OLECTL_H_
#include <olectl.h>
#endif

#ifdef INITGUIDS
#include <initguid.h>
#endif


//
// Class IDs
//
// {7988B571-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(CLSID_DiskQuotaControl,
0x7988b571, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// Interface IDs
//
// {7988B572-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaControl,
0x7988b572, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B574-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUser,
0x7988b574, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B576-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUserBatch,
0x7988b576, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B577-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IEnumDiskQuotaUsers,
0x7988b577, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B579-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaEvents,
0x7988b579, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);


//
// Definitions for value and bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaState.
//
#define DISKQUOTA_STATE_DISABLED            0x00000000
#define DISKQUOTA_STATE_TRACK               0x00000001
#define DISKQUOTA_STATE_ENFORCE             0x00000002
#define DISKQUOTA_STATE_MASK                0x00000003
#define DISKQUOTA_FILESTATE_INCOMPLETE      0x00000100
#define DISKQUOTA_FILESTATE_REBUILDING      0x00000200
#define DISKQUOTA_FILESTATE_MASK            0x00000300

//
// Helper macros for setting and testing state value.
//
#define DISKQUOTA_SET_DISABLED(s) \
            ((s) &= ~DISKQUOTA_STATE_MASK)

#define DISKQUOTA_SET_TRACKED(s) \
            ((s) |= (DISKQUOTA_STATE_MASK & DISKQUOTA_STATE_TRACK))

#define DISKQUOTA_SET_ENFORCED(s) \
            ((s) |= (DISKQUOTA_STATE_ENFORCE & DISKQUOTA_STATE_ENFORCE))

#define DISKQUOTA_IS_DISABLED(s) \
            (DISKQUOTA_STATE_DISABLED == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_TRACKED(s) \
            (DISKQUOTA_STATE_TRACK == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_ENFORCED(s) \
            (DISKQUOTA_STATE_ENFORCE == ((s) & DISKQUOTA_STATE_MASK))
//
// These file state flags are read-only.
//
#define DISKQUOTA_FILE_INCOMPLETE(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_INCOMPLETE))

#define DISKQUOTA_FILE_REBUILDING(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_REBUILDING))


//
// Definitions for bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaLogFlags.
//
#define DISKQUOTA_LOGFLAG_USER_THRESHOLD    0x00000001
#define DISKQUOTA_LOGFLAG_USER_LIMIT        0x00000002

//
// Helper macros to interrogate a log flags DWORD.
//
#define DISKQUOTA_IS_LOGGED_USER_THRESHOLD(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_THRESHOLD))

#define DISKQUOTA_IS_LOGGED_USER_LIMIT(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_LIMIT))

//
// Helper macros to set/clear bits in a log flags DWORD.
//
#define DISKQUOTA_SET_LOG_USER_THRESHOLD(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_THRESHOLD) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_THRESHOLD : 0))

#define DISKQUOTA_SET_LOG_USER_LIMIT(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_LIMIT) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_LIMIT : 0))

//
// Per-user quota information.
//
typedef struct DiskQuotaUserInformation {
    LONGLONG QuotaUsed;
    LONGLONG QuotaThreshold;
    LONGLONG QuotaLimit;
} DISKQUOTA_USER_INFORMATION, *PDISKQUOTA_USER_INFORMATION;


//
// Values for fNameResolution argument to:
//
//      IDiskQuotaControl::AddUserSid
//      IDiskQuotaControl::AddUserName
//      IDiskQuotaControl::FindUserSid
//      IDiskQuotaControl::CreateEnumUsers
//
#define DISKQUOTA_USERNAME_RESOLVE_NONE     0
#define DISKQUOTA_USERNAME_RESOLVE_SYNC     1
#define DISKQUOTA_USERNAME_RESOLVE_ASYNC    2

//
// Values for status returned by IDiskQuotaUser::GetAccountStatus.
//
#define DISKQUOTA_USER_ACCOUNT_RESOLVED     0
#define DISKQUOTA_USER_ACCOUNT_UNAVAILABLE  1
#define DISKQUOTA_USER_ACCOUNT_DELETED      2
#define DISKQUOTA_USER_ACCOUNT_INVALID      3
#define DISKQUOTA_USER_ACCOUNT_UNKNOWN      4
#define DISKQUOTA_USER_ACCOUNT_UNRESOLVED   5


//
// IDiskQuotaUser represents a single user quota record on a particular
// NTFS volume.  Objects using this interface are instantiated 
// through several IDiskQuotaControl methods.
//
#undef  INTERFACE
#define INTERFACE IDiskQuotaUser
DECLARE_INTERFACE_(IDiskQuotaUser, IUnknown)
{
    STDMETHOD(GetID)(THIS_
        ULONG *pulID) PURE;

    STDMETHOD(GetName)(THIS_
        LPWSTR pszAccountContainer,
        DWORD cchAccountContainer,
        LPWSTR pszLogonName,
        DWORD cchLogonName,
        LPWSTR pszDisplayName,
        DWORD cchDisplayName) PURE;

    STDMETHOD(GetSidLength)(THIS_
        LPDWORD pdwLength) PURE;

    STDMETHOD(GetSid)(THIS_
        LPBYTE pbSidBuffer,
        DWORD cbSidBuffer) PURE;

    STDMETHOD(GetQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaUsed)(THIS_
        PLONGLONG pllUsed) PURE;

    STDMETHOD(GetQuotaUsedText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaInformation)(THIS_
        LPVOID pbQuotaInfo,
        DWORD cbQuotaInfo) PURE;

    STDMETHOD(SetQuotaThreshold)(THIS_
        LONGLONG llThreshold,
        BOOL fWriteThrough) PURE;

    STDMETHOD(SetQuotaLimit)(THIS_
        LONGLONG llLimit,
        BOOL fWriteThrough) PURE;

    STDMETHOD(Invalidate)(THIS) PURE;

    STDMETHOD(GetAccountStatus)(THIS_
        LPDWORD pdwStatus) PURE;
};

typedef IDiskQuotaUser DISKQUOTA_USER, *PDISKQUOTA_USER;


//
// IEnumDiskQuotaUsers represents an enumerator created by 
// IDiskQuotaControl for the purpose of enumerating individual user quota
// records on a particular volume.  Each record is represented through
// the IDiskQuotaUser interface.
//
#undef  INTERFACE
#define INTERFACE IEnumDiskQuotaUsers
DECLARE_INTERFACE_(IEnumDiskQuotaUsers, IUnknown)
{
    STDMETHOD(Next)(THIS_
        DWORD cUsers,
        PDISKQUOTA_USER *rgUsers,
        LPDWORD pcUsersFetched) PURE;

    STDMETHOD(Skip)(THIS_
        DWORD cUsers) PURE;

    STDMETHOD(Reset)(THIS) PURE;

    STDMETHOD(Clone)(THIS_
        IEnumDiskQuotaUsers **ppEnum) PURE;
};

typedef IEnumDiskQuotaUsers ENUM_DISKQUOTA_USERS, *PENUM_DISKQUOTA_USERS;


//
// IDiskQuotaUserBatch represents a collection of IDiskQuotaUser 
// pointers for the purpose of grouping updates to quota information.
// 
#undef  INTERFACE
#define INTERFACE IDiskQuotaUserBatch
DECLARE_INTERFACE_(IDiskQuotaUserBatch, IUnknown)
{
    STDMETHOD(Add)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(Remove)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(RemoveAll)(THIS) PURE;

    STDMETHOD(FlushToDisk)(THIS) PURE;
};

typedef IDiskQuotaUserBatch DISKQUOTA_USER_BATCH, *PDISKQUOTA_USER_BATCH;


//
// IDiskQuotaControl represents a disk volume, providing query and 
// control of that volume's quota information.
//
#undef INTERFACE
#define INTERFACE IDiskQuotaControl
DECLARE_INTERFACE_(IDiskQuotaControl, IConnectionPointContainer)
{
    STDMETHOD(Initialize)(THIS_
        LPCWSTR pszPath,
        BOOL bReadWrite) PURE;

    STDMETHOD(SetQuotaState)(THIS_
        DWORD dwState) PURE;

    STDMETHOD(GetQuotaState)(THIS_
        LPDWORD pdwState) PURE;

    STDMETHOD(SetQuotaLogFlags)(THIS_
        DWORD dwFlags) PURE;

    STDMETHOD(GetQuotaLogFlags)(THIS_
        LPDWORD pdwFlags) PURE;

    STDMETHOD(SetDefaultQuotaThreshold)(THIS_
        LONGLONG llThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(SetDefaultQuotaLimit)(THIS_
        LONGLONG llLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(AddUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(AddUserName)(THIS_
        LPCWSTR pszLogonName,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(DeleteUser)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(FindUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(FindUserName)(THIS_
        LPCWSTR pszLogonName,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(CreateEnumUsers)(THIS_
        PSID *rgpUserSids,
        DWORD cpSids,
        DWORD fNameResolution,
        PENUM_DISKQUOTA_USERS *ppEnum) PURE;

    STDMETHOD(CreateUserBatch)(THIS_
        PDISKQUOTA_USER_BATCH *ppBatch) PURE;

    STDMETHOD(InvalidateSidNameCache)(THIS) PURE;

    STDMETHOD(GiveUserNameResolutionPriority)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(ShutdownNameResolution)(THIS_
        VOID) PURE;
};

typedef IDiskQuotaControl DISKQUOTA_CONTROL, *PDISKQUOTA_CONTROL;



#undef  INTERFACE
#define INTERFACE IDiskQuotaEvents
DECLARE_INTERFACE_(IDiskQuotaEvents, IUnknown)
{
    STDMETHOD(OnUserNameChanged)(THIS_
        PDISKQUOTA_USER pUser) PURE;
};

typedef IDiskQuotaEvents DISKQUOTA_EVENTS, *PDISKQUOTA_EVENTS;



#endif // __DSKQUOTA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);


// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus


//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;


#if DIRECTSOUND_VERSION >= 0x0800
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0x174d3eb9, 0x6696, 0x4fac, 0xa4, 0x6c, 0xa0, 0xac, 0x7b, 0xc9, 0xe2, 0xf);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif


#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

// Dsound SYSTEM resource constants
// Matches the KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values defined 
// in ksmedia.h.
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000


//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//


// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);


// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//


// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);


#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__



#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DtsPkg.h ===
//
// DTSPackage COM Server Header file.
//

#ifndef DTSPackage_H_
#define DTSPackage_H_

#ifndef DTSPackageVersion_Major
	#define DTSPackageVersion_Major 1
	#define DTSPackageVersion_Minor 0
#endif // DTSPackageVersion_Major

#ifndef DTSPackage_VersionOnly

/////////////////////////////////////////////////////////////////////////////////////////
// Constant enumerations.
/////////////////////////////////////////////////////////////////////////////////////////
#ifndef DTSPackage_CONSTANTS_
#define DTSPackage_CONSTANTS_

#ifdef DTSPackage_ODL_
	#define DTS_ENUM_BEGIN(tdef, hstring)	[helpcontext(H_##tdef), helpstring(hstring)] enum
		// item = value, ...
	#define DTS_ENUM_END(tdef)				tdef, *LP##tdef
#else
	#define DTS_ENUM_BEGIN(tdef, hstring)	DWORD tdef, *LP##tdef; enum tag##tdef
		// item = value, ...
	#define DTS_ENUM_END(tdef)				
#endif

typedef DTS_ENUM_BEGIN(DTSPackageError, "Error ranges for DTSPackage creation and execution") {
	DTSPackage_E_NotImplemented						= 1001,
	DTSPackage_E_OrdOutOfRange						= 1002,
	DTSPackage_E_NameNotFound						= 1003,
	DTSPackage_E_NameDup							= 1004,
	DTSPackage_E_NoStepsDefined						= 1005,
	DTSPackage_E_Column_OutOfRange					= 1006,
	DTSPackage_E_ColumnNeedsNameOrOrdinal			= 1007,
	DTSPackage_E_WrongCollection					= 1008,
	DTSPackage_E_DatatypeNotFound					= 1009,
	DTSPackage_E_NeedConnectionInfo					= 1010,
	DTSPackage_E_ODBC_NeedConnectionInfo			= 1011,
	DTSPackage_E_NoStepsToExecute					= 1012,
	DTSPackage_E_DescribeNeedsQuery					= 1013,
	DTSPackage_E_ColumnsNotDescribed				= 1014,
	DTSPackage_E_Step_CyclicDependency				= 1015,
	DTSPackage_E_UsageBeforeDescribeOnly			= 1016,
	DTSPackage_E_AxScript_CantInitializeEngine		= 1017,
	DTSPackage_E_AxScript_RequiredParams			= 1018,
	DTSPackage_E_AxScript_ParseError				= 1019,
	DTSPackage_E_AxScript_BadFunctionName			= 1020,
	DTSPackage_E_AxScript_CantAddGlobals			= 1021,
	DTSPackage_E_AxScript_RunTimeError				= 1022,
	DTSPackage_E_BadStepStatusValue					= 1023,
	DTSPackage_E_BadStepResultValue					= 1024,
	DTSPackage_E_BadTaskResultValue					= 1025,
	DTSPackage_E_BadPrecedenceBasis					= 1026,
	DTSPackage_E_BadStepTask						= 1027,
	DTSPackage_E_RequireConnectionProperties		= 1028,
	DTSPackage_E_ConnectionRequiresValidTaskName	= 1029,
	DTSPackage_E_ConnectionInUse					= 1030,
	DTSPackage_E_CannotFindConnection				= 1031,
	DTSPackage_E_PumpTask_RequireXforms				= 1032,
	DTSPackage_E_PumpTask_RequireSrcAndDestColumns	= 1033,
	DTSPackage_E_PumpTask_RequireRowsetDataSrcInfo	= 1034,
	DTSPackage_E_PumpTask_RequireXformServer		= 1035,
	DTSPackage_E_BadPrecedenceStep					= 1036,
	DTSPackage_E_CreateProcTask_Timeout				= 1037,
	DTSPackage_E_BadGUIDValue						= 1038,
	DTSPackage_E_RequireNameForExecOrStg			= 1039,
	DTSPackage_E_CantFindVersionInStg				= 1040,
	DTSPackage_E_CantSetCommandProps				= 1041,
	DTSPackage_E_BadPriorityClass					= 1042,
	DTSPackage_E_BadRelativePriority				= 1043,
	DTSPackage_E_CantFindPackageInStg				= 1044,
	DTSPackage_E_EncryptStg_CantCreateOrWrite		= 1045,
	DTSPackage_E_EncryptStg_CantOpenOrRead			= 1046,
	DTSPackage_E_EncryptStg_HandsOnStg				= 1047,
	DTSPackage_E_EncryptStg_UnsupportedFlags		= 1048,
	DTSPackage_E_EncryptStg_PasswordNotMatching		= 1049,
	DTSPackage_E_EncryptStg_RequirePassword			= 1050,
	DTSPackage_E_EncryptStg_StreamTooLarge			= 1051,
	DTSPackage_E_Security_InvalidPassword			= 1052,
	DTSPackage_E_Security_RequireBothPasswords		= 1053,
	DTSPackage_E_Security_OperatorNotPriveleged		= 1054,
	DTSPackage_E_SQLTask_RequireSQL					= 1055,
	DTSPackage_E_UnknownOleDBProperty				= 1056,
	DTSPackage_E_RequireConnectionID				= 1057,
	DTSPackage_E_RequireColumnNameAndOrdinal		= 1058,
	DTSPackage_E_PropertyStringTooLong				= 1059,
	DTSPackage_E_CantChangeLoadedPkgName			= 1060,
	DTSPackage_E_NoXformDispatch					= 1061,
	DTSPackage_E_CannotPersistProperty				= 1062,
	DTSPackage_E_ExecutionCanceled					= 1063,
	DTSPackage_E_FailedOnStepError					= 1064,
	DTSPackage_E_BadForceMode						= 1065,
	DTSPackage_E_MultiPackageStgNeedsID				= 1066,
	DTSPackage_E_BadSQLServerStorageFlags			= 1067,
	DTSPackage_E_NoPackageDataFromServer			= 1068,
	DTSPackage_E_NeedDestinationColumnDefinitions	= 1069,
	DTSPackage_E_DSO_OnlyOneSession					= 1070,
	DTSPackage_E_DSO_OnlyOneRowset					= 1071,
	DTSPackage_E_DSO_ProviderStringRequired			= 1072,
	DTSPackage_E_DSO_CantRelaunchPackage			= 1073,
	DTSPackage_E_DSO_OnlyOneCommand					= 1074,
	DTSPackage_E_BadPackageDSORowsetTask			= 1075,
	DTSPackage_E_AbandonedRowQueueDest				= 1076,
	DTSPackage_E_DataDrivenQueryTask_RequireXforms	= 1077,
	DTSPackage_E_NeedDataDrivenQueries				= 1078,
	DTSPackage_E_NeedDataDrivenQueryAndColumns		= 1079,
	DTSPackage_E_HostFailedPersistence				= 1080,
	DTSPackage_E_BadLookupConnectionProvider		= 1081,
	DTSPackage_E_CreateProcessNullCommandLine		= 1082,
	DTSPackage_E_GeneralTaskFailure					= 1083,
	DTSPackage_E_XfrTask_SrcInfoIncomplete			= 1084,
	DTSPackage_E_XfrTask_DestInfoIncomplete			= 1085,
	DTSPackage_E_XfrTask_InvalidCopyDataOption		= 1086,
	DTSPackage_E_XfrTask_InvalidObjectType			= 1087,
	DTSPackage_E_XfrTask_InvalidObjectName			= 1088,
	DTSPackage_E_XfrTask_InvalidOwnerName			= 1089,
	DTSPackage_E_XfrTask_CantCreateDMOObject		= 1090,
	DTSPackage_E_XfrTask_CantConnectToSrc			= 1091,
	DTSPackage_E_XfrTask_CantGetSrcDB				= 1092,
	DTSPackage_E_XfrTask_IndexOutOfRange			= 1093,
	DTSPackage_E_BadStepScriptResultValue			= 1094,
	DTSPackage_E_AxScript_CantModifyDuringExecute	= 1095,

	DTSPackage_E_Repos_NotRegistered				= 1100,
	DTSPackage_E_Repos_CantScanCatalog				= 1101,
	DTSPackage_E_Repos_ScannedObjectNotFound		= 1102,
	DTSPackage_E_Repos_ScannedColumnNotFound		= 1103,
	DTSPackage_E_Repos_BadStorageFlags				= 1104,
	DTSPackage_E_Repos_CantParseName				= 1105,
	DTSPackage_E_Repos_ScannedSchemaNotFound		= 1106,
	DTSPackage_E_Repos_UnscannedColumnNotFound		= 1107,
 	DTSPackage_E_Repos_DuplicatePackageName			= 1108,
	DTSPackage_E_Repos_ScanRequiresSchemaRowset		= 1109,
	DTSPackage_E_Repos_GeneralError					= 1110,
	DTSPackage_E_Repos_InvalidMetadataOptions		= 1111,
	DTSPackage_E_Repos_PackageNotFound				= 1112,

	DTSPackage_E_Lineage_BadOptions					= 1120,
	DTSPackage_E_Lineage_NoRepositoryContext		= 1121,
	DTSPackage_E_Lineage_CantOpenRepository			= 1122,
	DTSPackage_E_Lineage_RepositoryError			= 1123,
	DTSPackage_E_Lineage_PackageVersionFrozen		= 1124,
	DTSPackage_E_Lineage_ErrorWritingToRepos		= 1125,

	DTSPackage_E_Trx_InvalidIsolationLevel			= 1130,
	DTSPackage_E_Trx_TaskCannotJoinTransaction		= 1131,
	DTSPackage_E_Trx_ConnCannotJoinTransaction		= 1132,
	DTSPackage_E_Trx_BeginFailed					= 1133,
	DTSPackage_E_Trx_StepCommitFailed				= 1134,
	DTSPackage_E_Trx_PackageCommitFailed			= 1135,
	DTSPackage_E_Trx_DTCNotAvailable				= 1136,
	DTSPackage_E_Trx_TrxNoLongerActive				= 1137,

	DTSPackage_E_MailTask_NoMAPIInterfaceLayer		= 1150,
	DTSPackage_E_MailTask_CantInitializeMAPI		= 1151,
	DTSPackage_E_MailTask_LogonFailure				= 1152,
	DTSPackage_E_MailTask_SendFailure				= 1153,
	DTSPackage_E_MailTask_NotInitialized			= 1154,
	DTSPackage_E_MailTask_GeneralFailure 			= 1155,

	DTSPackage_E_BulkInsertTask_RequireTableName	= 1156,
	DTSPackage_E_BulkInsertTask_RequireDataFile		= 1157,

	DTSPackage_E_InvalidFastLoadOptions				= 1170,
	DTSPackage_E_EncryptStg_CantInit				= 1171,
	DTSPackage_E_NoFastLoadWithDataLink				= 1172,
	DTSPackage_E_NoFastLoad							= 1173,
	DTSPackage_E_ProcTaskReturnCodeNotSuccess		= 1174,
	DTSPackage_E_SaveTo70OrLater					= 1175,
	DTSPackage_E_SQLServerLicenseError				= 1176,

} DTS_ENUM_END(DTSPackageError);

typedef DTS_ENUM_BEGIN(DTSStepExecStatus, "Execution status of this DTSStep") {
	DTSStepExecStat_Waiting				= 0x0001,
	DTSStepExecStat_InProgress			= 0x0002,
	DTSStepExecStat_Inactive			= 0x0003,
	DTSStepExecStat_Completed			= 0x0004,		// Or'd with completion bits below.
} DTS_ENUM_END(DTSStepExecStatus);

typedef DTS_ENUM_BEGIN(DTSStepExecResult, "Execution Result of this DTSStep") {
	DTSStepExecResult_Success			= 0x0000,
	DTSStepExecResult_Failure			= 0x0001,
} DTS_ENUM_END(DTSStepExecResult);

typedef DTS_ENUM_BEGIN(DTSStepScriptResult, "Return code from Active Script associated with a step indicating flow of control for task execution") {
	DTSStepScriptResult_ExecuteTask				= 0x0000,
	DTSStepScriptResult_DontExecuteTask			= 0x0001,
	DTSStepScriptResult_RetryLater				= 0x0002,
} DTS_ENUM_END(DTSStepScriptResult);

typedef DTS_ENUM_BEGIN(DTSTaskExecResult, "Execution Result of Task") {
	DTSTaskExecResult_Success			= 0x0000,
	DTSTaskExecResult_Failure			= 0x0001,
	DTSTaskExecResult_RetryStep			= 0x0002,
} DTS_ENUM_END(DTSTaskExecResult);

typedef DTS_ENUM_BEGIN(DTSStepPrecedenceBasis, "Step precedence is based either on Step Status or Result") {
	DTSStepPrecedenceBasis_ExecStatus			= 0x0000,
	DTSStepPrecedenceBasis_ExecResult			= 0x0001,
} DTS_ENUM_END(DTSStepPrecedenceBasis);

typedef DTS_ENUM_BEGIN(DTSStepRelativePriority, "Win32 Thread Relative Priority to be used for Step Task") {
	DTSStepRelativePriority_Lowest			= 0x0001,
	DTSStepRelativePriority_BelowNormal		= 0x0002,
	DTSStepRelativePriority_Normal			= 0x0003,
	DTSStepRelativePriority_AboveNormal		= 0x0004,
	DTSStepRelativePriority_Highest			= 0x0005,
} DTS_ENUM_END(DTSStepRelativePriority);

typedef DTS_ENUM_BEGIN(DTSPackagePriorityClass, "Win32 Process Priority Class to be used for the package.") {
	DTSPriorityClass_Low			= 0x0001,
	DTSPriorityClass_Normal			= 0x0002,
	DTSPriorityClass_High			= 0x0003,
} DTS_ENUM_END(DTSPackagePriorityClass);

typedef DTS_ENUM_BEGIN(DTSIsolationLevel, "Isolation level at which Package transaction executes (default is ReadCommitted).") {
	DTSIsoLevel_Chaos				= 0x10,
	DTSIsoLevel_ReadUncommitted		= 0x100,
	DTSIsoLevel_Browse				= 0x100,
	DTSIsoLevel_CursorStability		= 0x1000,
	DTSIsoLevel_ReadCommitted		= 0x1000,
	DTSIsoLevel_RepeatableRead		= 0x10000,
	DTSIsoLevel_Serializable		= 0x100000,
	DTSIsoLevel_Isolated			= 0x100000
} DTS_ENUM_END(DTSIsolationLevel);

typedef DTS_ENUM_BEGIN(DTSForceMode, "Overrides default handling of associated property") {
	DTSForceMode_Default				= 0x0000,
	DTSForceMode_Always					= 0x0001,
	DTSForceMode_Never					= 0x0002,
} DTS_ENUM_END(DTSForceMode);

typedef DTS_ENUM_BEGIN(DTSErrorMode, "Handling of Error conditions encountered while executing Steps in the Package") {
#ifdef DTSPackage_INTERNAL
	DTSErrorMode_Unknown			= 0x0000,		// Not yet set
#endif // DTSPackage_INTERNAL

	DTSErrorMode_Continue			= 0x0001,		// Log exceptions (if specified) and continue
	DTSErrorMode_FailStep			= 0x0002,		// Fail Step Execution
	DTSErrorMode_FailPackage		= 0x0003,		// Fail Package Execution.
} DTS_ENUM_END(DTSErrorMode);

typedef DTS_ENUM_BEGIN(DTSCustomTaskUIFlags, "Specifies flags indicating the type of UI supported by the custom task") {
	DTSCustomTaskUIFlags_Default			= 0x0000,
	DTSCustomTaskUIFlags_DoesCustomToolTip	= 0x0001,
} DTS_ENUM_END(DTSCustomTaskUIFlags);

typedef DTS_ENUM_BEGIN(DTSRepositoryStorageFlags, "Specifies Repository options when saving or loading the DTS Package") {
	DTSReposFlag_Default					= 0x0000,

	// How to connect to the repository.
	DTSReposFlag_UseTrustedConnection		= 0x0100,		// Use NT integrated security to connect to Repository (MS SQL Server-hosted Repository only)
} DTS_ENUM_END(DTSRepositoryStorageFlags);

typedef DTS_ENUM_BEGIN(DTSSQLServerStorageFlags, "Specifies Repository options when saving or loading the DTS Package") {
	DTSSQLStgFlag_Default					= 0x0000,

	// How to connect to the server.
	DTSSQLStgFlag_UseTrustedConnection		= 0x0100,		// Use NT integrated security to connect to SQL Server
} DTS_ENUM_END(DTSSQLServerStorageFlags);

typedef DTS_ENUM_BEGIN(DTSRepositoryMetadataOptions, "Specifies metadata scanning and resolution options when storing the DTS Package to a Repository") {
	DTSReposMetadata_Default					= 0x0000,		// Does no scanner resolution

	// These indicate whether to attempt any scanner resolution at all.  Note that scanning is only
	// done at the Catalog level; an inconsistency at a lower level will be an error.
	DTSReposMetadata_RequireScannedCatalog		= 0x0001,		// Requires that any database objects must have been scanned into repository
	DTSReposMetadata_UseScannedCatalogIfPresent	= 0x0002,		// Will use any scanned objects found; nonscanned references will create local objects

	// These are ignored unless one of the scanned-resolution options above is set.
	// If neither of the _Scan options is set, then no scanning will be done;
	// if _RequireAllScanned is set, the SaveToRepository will fail, otherwise
	// a local reference will be created for the object.
	DTSReposMetadata_ScanCatalogIfNotFound		= 0x0004,		// The Package will issue a scan on all catalogs that are not found already scanned
	DTSReposMetadata_ScanCatalogAlways			= 0x0008,		// The Package will scan all Catalogs referenced, re-scanning if already scanned
} DTS_ENUM_END(DTSRepositoryMetadataOptions);

typedef DTS_ENUM_BEGIN(DTSSQLObjectType, "Indicates types of objects available on Microsoft SQL Server. This is in sync with SQLDMO_OBJECT_TYPE in SQL-DMO") {
	// Database objects, value is power(2, sysobjects.sysstat & 0x0f), plus UDDTs in 0.
	// These values can be bitmasked together for object listings.
	DTSSQLObj_UserDefinedDatatype =           0x00000001,    // 1
	DTSSQLObj_SystemTable =                   0x00000002,    // 2
	DTSSQLObj_View =                          0x00000004,    // 4
	DTSSQLObj_UserTable =                     0x00000008,    // 8
	DTSSQLObj_StoredProcedure =               0x00000010,    // 16
	DTSSQLObj_Default =                       0x00000040,    // 64
	DTSSQLObj_Rule =                          0x00000080,    // 128
	DTSSQLObj_Trigger =                       0x00000100,    // 256
	DTSSQLObj_AllDatabaseUserObjects =        0x000001fd,    // All but system tables
	DTSSQLObj_AllDatabaseObjects =            0x000001ff,    // All including system tables

} DTS_ENUM_END(DTSSQLObjectType);

typedef DTS_ENUM_BEGIN(DTSTransfer_CopyDataOption, "Specifies flags indicating if data should be copied, and whether existing data should be replaced or appended to.") {
	DTSTransfer_DontCopyData = 0x0000,
	DTSTransfer_ReplaceData	= 0x0001,
	DTSTransfer_AppendData	= 0x0002,
} DTS_ENUM_END(DTSTransfer_CopyDataOption);

typedef DTS_ENUM_BEGIN(DTSTransfer_ScriptOption, "Specifies scripting option. This is in sync with SQLDMO_SCRIPT_TYPE in SQL-DMO.") {
        // What's included in the Script method output.
        DTSTransfer_Script_Default 				= 0x0004, 	// Object creation only
        DTSTransfer_Script_Drops 					= 0x0001, 	// Include object drops
        DTSTransfer_Script_ObjectPermissions 		= 0x0002, 	// Include object permissions
        DTSTransfer_Script_PrimaryObject 			= 0x0004, 	// Include object creation
        DTSTransfer_Script_ClusteredIndexes 		= 0x0008,   // Include clustered index creation (table only)
        DTSTransfer_Script_Triggers 				= 0x0010,   // Include trigger creation (table only)
        DTSTransfer_Script_DatabasePermissions	= 0x0020,   // Database (statement) permissions
        DTSTransfer_Script_Permissions 			= 0x0022,   // Both database and object permissions (for scripting users).
        DTSTransfer_Script_ToFileOnly 			= 0x0040,   // If not set, a string is returned (if file nonnull, both are done)
        DTSTransfer_Script_Bindings 				= 0x0080,   // Include rule/default bindings (table only)
        DTSTransfer_Script_AppendToFile 			= 0x0100,   // Append to output file if it already exists.
        DTSTransfer_Script_NoDRI 					= 0x0200,   // Do not include DRI (intended for use if targeting pre-6.0 server with scripts)
        DTSTransfer_Script_UDDTsToBaseType 		= 0x0400,   // Convert UserDefinedDatatypes to base type when creating columns (table only)
		// 0x0800 available.
        DTSTransfer_Script_IncludeIfNotExists 	= 0x1000,   // Include "if not exists" on object creation.
        DTSTransfer_Script_NonClusteredIndexes	= 0x2000,   // Include nonclustered index creation (table only)
        DTSTransfer_Script_Indexes 				= 0x12008,  // Include all index creation (table only)
        DTSTransfer_Script_Aliases 				= 0x4000,   // For users, script aliases
        DTSTransfer_Script_NoCommandTerm 			= 0x8000,   // Do not append "GO" to commands.
        DTSTransfer_Script_DRIIndexes 			= 0x10000,  // Script DRI-generated indexes as indexes if NoDRI is specified.
        DTSTransfer_Script_IncludeHeaders 		= 0x20000,  // Include descriptive header in individual object script output.
        DTSTransfer_Script_OwnerQualify 			= 0x40000,  // Owner-qualify DROP statements (and CREATE where possible).
        DTSTransfer_Script_TimestampToBinary 		= 0x80000,  // Convert timestamp columns to binary(8) (for replication, etc.).
        DTSTransfer_Script_SortedData 			= 0x100000, // If the index or constraint was clustered, append sorted_data
        DTSTransfer_Script_SortedDataReorg 		= 0x200000, // Same as DTSTransfer_Script_SortedData, but Reorg is used to preserve fillfactor.
        DTSTransfer_Script_TransferDefault 		= 0x800670ff,  // The default script type for Transfer. This is combination of following flags:
                                                        // DTSTransfer_Script_PrimaryObject | DTSTransfer_Script_Bindings | DTSTransfer_Script_ClusteredIndexes | DTSTransfer_Script_NonClusteredIndexes |
                                                        // DTSTransfer_Script_Triggers| DTSTransfer_Script_ToFileOnly|DTSTransfer_Script_Permissions| DTSTransfer_Script_IncludeHeaders|
                                                        // DTSTransfer_Script_Aliases|DTSTransfer_Script_IncludeIfNotExists|DTSTransfer_Script_OwnerQualify
        // DRI-restrictive flags.  These may be combined with PrimaryObject as desired.
        // These are to be used to include or exclude specific DRI components, such
        // as for multi-pass scripting.
        DTSTransfer_Script_DRI_NonClustered 		= 0x00400000,
        DTSTransfer_Script_DRI_Clustered 			= 0x00800000,
        DTSTransfer_Script_DRI_Checks				= 0x01000000,
        DTSTransfer_Script_DRI_Defaults 			= 0x02000000,
        DTSTransfer_Script_DRI_UniqueKeys 		= 0x04000000,
        DTSTransfer_Script_DRI_ForeignKeys		= 0x08000000,
        DTSTransfer_Script_DRI_PrimaryKey 		= 0x10000000,
        DTSTransfer_Script_DRI_AllKeys 			= 0x1c000000, 	// Bitmask of all key types (PK, FK, Unique).
        DTSTransfer_Script_DRI_AllConstraints 	= 0x1f000000,   // Bitmask of all constraint types (PK, FK, Unique, Check, Default).
        DTSTransfer_Script_DRI_All 				= 0x1fc00000,   // All the foregoing (specifying this and not PrimaryObject gets just DRI output).
        DTSTransfer_Script_DRIWithNoCheck 		= 0x20000000,   // Script DRI with nocheck (not included in _DRI_All).
        DTSTransfer_Script_NoIdentity 			= 0x40000000,   // Script with no IDENTITY attribute (e.g. for Replication).

        DTSTransfer_Script_UseQuotedIdentifiers = 0x80000000,   // Scripts with quoted identifiers. Also will cause Transfer to SET QUOTED_IDENTIFIER ON on the destination.
                                                          // !!! When scripting out from 7.0: StoreProcedure, View and Trigger carry their own QI and AnsiNulls setting
                                                          //     (based on the setting when the original object was created), and this flag does not affect them anymore.
                                                          //     At the end of these object scripting, they set QI to the setting according to this flag,
                                                          //     and AnsiNulls to ON (ODBC default).
} DTS_ENUM_END(DTSTransfer_ScriptOption);

typedef DTS_ENUM_BEGIN(DTSTransfer_ScriptOptionEx, "Specifies extended scripting option. This is in sync with SQLDMO_SCRIPT2_TYPE in SQL-DMO.") {
        // Optional Script parameter.
        DTSTransfer_ScriptEx_TransferDefault  = 0x1010,   // Default
	    DTSTransfer_ScriptEx_AnsiPadding      = 0x0001,   // Explicitly SET ANSI PADDING on or off before the create table
        DTSTransfer_ScriptEx_AnsiFile         = 0x0002,   // Generate ANSI output file
        DTSTransfer_ScriptEx_UnicodeFile      = 0x0004,   // Generate UNICODE output file
        DTSTransfer_ScriptEx_NonStop          = 0x0008,   // When error during script file generation, log error and continue.
                                                   // This is a special case for Convert(scptxfr70.exe), not a general purpose flag
                                                   // If client uses this flag to generate output files, they are running on their own risk
                                                   // This flag affects script out (and only the part used by Convert), it does not affect transfer in.
        DTSTransfer_ScriptEx_NoFG             = 0x0010,   // Do not generate 'ON <filegroup>'. For Replication
        DTSTransfer_ScriptEx_MarkTriggers     = 0x0020,   // Mark system triggers. For Replication single table script only.
        DTSTransfer_ScriptEx_OnlyUserTriggers = 0x0040,   // Only script user triggers. For Replication single table script only.
        DTSTransfer_ScriptEx_EncryptPWD       = 0x0080,   // Script encrypted password for logins
        DTSTransfer_ScriptEx_SeparateXPs      = 0x0100,   // Script XP to a separate file (Convert)
        DTSTransfer_ScriptEx_NoWhatIfIndexes  = 0x0200,   // Do not script What-If indexes (default: script out)
        // Following are SQLAgent related scripting flags
        DTSTransfer_ScriptEx_AgentNotify      = 0x0400,   // Script Notification for SQLAgent alert object
        DTSTransfer_ScriptEx_AgentAlertJob    = 0x0800,   // Include Job in Alert scripting
		//FT-Indexing
        DTSTransfer_ScriptEx_FullTextIndex    = 0x1000,   // Include full-text index scripting (table only)

} DTS_ENUM_END(DTSTransfer_ScriptOptionEx);


typedef DTS_ENUM_BEGIN(DTSBulkInsert_DataFileType, "Specifies the type of datafile used for BULK INSERT") {
	DTSBulkInsert_DataFileType_Char					= 0x0000,
	DTSBulkInsert_DataFileType_Native				= 0x0001,
	DTSBulkInsert_DataFileType_WideChar				= 0x0002,
	DTSBulkInsert_DataFileType_WideNative			= 0x0003,
} DTS_ENUM_END(DTSBulkInsert_DataFileType);

// These are not a bitmask; each implies all prior (lesser-numbered) ones.
typedef DTS_ENUM_BEGIN(DTSLineageOptions, "Specifies how Package Execution Lineage should be presented and recorded") {
	DTSLineage_None							= 0x0000,		// Default
	DTSLineage_AddLineageVariables			= 0x0001,
	DTSLineage_WriteToReposIfAvailable		= 0x0002,
	DTSLineage_WriteToReposRequired			= 0x0003,
} DTS_ENUM_END(DTSLineageOptions);

// This is a bitmask.
typedef DTS_ENUM_BEGIN(DTSFastLoadOptions, "Options specific to PumpTask.UseFastLoad") {
	DTSFastLoad_NoOptions					= 0x0000,
	DTSFastLoad_KeepNulls					= 0x0001,
	DTSFastLoad_CheckConstraints			= 0x0002,
	DTSFastLoad_TableLock					= 0x0004,
	DTSFastLoad_Default						= 0x0002,		// DTSFastLoad_CheckConstraints
} DTS_ENUM_END(DTSFastLoadOptions);

#endif	// DTSPackage_CONSTANTS_

/////////////////////////////////////////////////////////////////////////////////////////
// Interface definitions.
/////////////////////////////////////////////////////////////////////////////////////////
#ifndef DTSPackage_ODL_		// Skip if in .odl file.

// Optional parameter definitions.  For C explicit values will have to be specified,
// as indicated within the CPPDEFAULT() expansion.
//
// DTSPackage Parameter sequencing is as follows ("optional" in accordance with C++ usage):
// 	Nonoptional parameters
//		Nonoptional Return value if any
//		Optional additional parameters
//		Optional return value, if any
//
#ifndef CPPDEFAULT
#ifdef __cplusplus
#define CPPDEFAULT(DefaultParamValue)	DefaultParamValue
#else
#define CPPDEFAULT(DefaultParamValue)
#endif
#endif

// Define constants to document parameter usage.
#define DTS_IN
#define DTS_OUT
#define DTS_INOUT
#define DTS_RETVAL

///////////////////////////////////////////////////////////////////////////////////////
// Class definitions and typedefs
///////////////////////////////////////////////////////////////////////////////////////

#ifndef DTSPackage_INTERNAL 

// Forward-define all interfaces.
#define DTS_FWD_DEFINE_INTERFACE(itf)					\
	interface IDTS##itf;								\
	typedef interface IDTS##itf * LPDTS##itf;

DTS_FWD_DEFINE_INTERFACE(StdObject)

// Repeat the IDispatch members because C doesn't provide inheritance.
#define DTSPackage_DISPATCH_BASE(itf)														\
		STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;				\
		STDMETHOD_(ULONG,AddRef) (THIS) PURE;												\
		STDMETHOD_(ULONG,Release) (THIS) PURE;												\
		STDMETHOD(GetTypeInfoCount)(THIS_ UINT * pcTypeInfo) PURE;							\
		STDMETHOD(GetTypeInfo)(THIS_ UINT iTypeInfo, LCID lcid, ITypeInfo ** ppTI) PURE;	\
		STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, LPOLESTR * rgszNames, UINT cNames,		\
								LCID lcid, DISPID * rgdispid) PURE;							\
		STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,	\
								DISPPARAMS * pdispparams, LPVARIANT pvarResult,				\
								LPEXCEPINFO pexcepinfo, UINT * puArgErr) PURE;

// This is the base class for all DTSPackage OleAut objects.  It is never instantiated by itself.
// The members are copied into all derived classes so that C clients can reference
// them, since the DECLARE_INTERFACE_ macro doesn't provide inheritance in C.  The
// undef/def of INTERFACE is likewise required for C programmers.
#undef INTERFACE
#define INTERFACE IDTSStdObject
DECLARE_INTERFACE_(INTERFACE, IDispatch)
{
	DTSPackage_DISPATCH_BASE(IDTSStdObject)
};

#endif	// ndef DTSPackage_INTERNAL


/////////////////////////////////////////////////////////////////////////////////
// Define the DTSPackage GUIDGEN templates.
/////////////////////////////////////////////////////////////////////////////////

#define DEFINE_DTSPackage_GUID(name, lval) \
      DEFINE_GUID(name, 0x##lval, 0xEB1C, 0x11CF, 0xAE, 0x6E, 0x0, 0xAA, 0x0, 0x4A, 0x34, 0xD5);
#define DEFINE_DTSPackage_DTSCatID(name, lval) \
      DEFINE_GUID(name, 0x##lval, 0xA282, 0x11D1, 0xB7, 0xD9, 0x0, 0xC0, 0x4F, 0xB6, 0xEF, 0xD5);

/////////////////////////////////////////////////////////////////////////////////
//	SQLDTS Library UUID
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(LIBID_DTSPackageLibrary, 10010001)

/////////////////////////////////////////////////////////////////////////////////
// Internal base interfaces.
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(IID_IDTSPrivate, 10010002)
DEFINE_DTSPackage_GUID(IID_IDTSInternal, 1001003)

DEFINE_DTSPackage_GUID(IID_IDTSStdObject, 10010004)

DEFINE_DTSPackage_GUID(IID_IDTSStdCollection, 10010009)

DEFINE_DTSPackage_GUID(CLSID_DTSRunPackage, 1001000A)
DEFINE_DTSPackage_GUID(IID_IDTSRunPackage, 1001000B)

DEFINE_DTSPackage_GUID(IID_IDTSPackageDSODataSource, 10010011)
DEFINE_DTSPackage_GUID(IID_IDTSPackageDSOSession, 10010012)
DEFINE_DTSPackage_GUID(IID_IDTSPackageDSOCommand, 10010013)
DEFINE_DTSPackage_GUID(IID_IDTSPackageDSORowset, 10010014)

DEFINE_DTSPackage_GUID(IID_IDTSRowQueueDataSource, 10010021)
DEFINE_DTSPackage_GUID(IID_IDTSRowQueueSession, 10010022)
DEFINE_DTSPackage_GUID(IID_IDTSRowQueueRowset, 10010023)

/////////////////////////////////////////////////////////////////////////////////
// OLEDB rowset provider CLSIDs
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(CLSID_DTSPackageDSO, 10010031)
DEFINE_DTSPackage_GUID(CLSID_DTSRowQueue, 10010032)

/////////////////////////////////////////////////////////////////////////////////
// Automation generic-property interfaces
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(IID_IDTSProperties, 10020001)
DEFINE_DTSPackage_GUID(IID_IDTSProperty, 10020002)

/////////////////////////////////////////////////////////////////////////////////
// Repository OBJID base GUIDs and private management classes.
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(GUID_DTSSystem, 10020101)
DEFINE_DTSPackage_GUID(GUID_DTSPackageModel, 10020102)
DEFINE_DTSPackage_GUID(CLSID_DTSRepositoryManager, 10020103)
DEFINE_DTSPackage_GUID(IID_IDTSRepositoryManager, 10020104)
DEFINE_DTSPackage_GUID(IID_IDTSRepositoryPackageEnum, 10020105)
DEFINE_DTSPackage_GUID(GUID_DTSDataSourceModel, 10020106)

DEFINE_DTSPackage_GUID(IID_IDTSRepositoryPackageLineageEnum, 10020107)
DEFINE_DTSPackage_GUID(IID_IDTSRepositoryDataSourceEnum, 10020108)
DEFINE_DTSPackage_GUID(IID_IDTSRepositoryCatalogEnum, 10020109)
DEFINE_DTSPackage_GUID(IID_IDTSRepositoryStepLineageEnum, 10020110)

/////////////////////////////////////////////////////////////////////////////////
// Category id of DTS custom tasks.
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_GUID(CATID_DTSCustomTask, 10020200)	//we will use the same id as the Package clsid.

/////////////////////////////////////////////////////////////////////////////////
// DTS Category id (not COM category ID) of DTS SQL Server categories.
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSPackage_DTSCatID(DTSCATID_Local, B8C30000)
DEFINE_DTSPackage_DTSCatID(DTSCATID_Repository, B8C30001)
DEFINE_DTSPackage_DTSCatID(DTSCATID_LocalDefault, B8C30002)

/////////////////////////////////////////////////////////////////////////////////
// DTS Package interfaces
/////////////////////////////////////////////////////////////////////////////////

DEFINE_DTSPackage_GUID(CLSID_DTSPackage, 10020200)
DEFINE_DTSPackage_GUID(CLSID_DTSPropertiesProvider, 10020201)

DEFINE_DTSPackage_GUID(IID_IDTSPackage, 10020205)
DEFINE_DTSPackage_GUID(IID_IDTSPropertiesProvider, 10020206)

DEFINE_DTSPackage_GUID(IID_IDTSSteps, 10020302)
DEFINE_DTSPackage_GUID(IID_IDTSStep, 10020305)

DEFINE_DTSPackage_GUID(IID_IDTSColumns, 10020402)
DEFINE_DTSPackage_GUID(IID_IDTSColumn, 10020405)

DEFINE_DTSPackage_GUID(IID_IDTSLookups, 10020502)
DEFINE_DTSPackage_GUID(IID_IDTSLookup, 10020505)

DEFINE_DTSPackage_GUID(IID_IDTSPackageEvents, 10020605)

DEFINE_DTSPackage_GUID(IID_IDTSPackageLog, 10020705)

DEFINE_DTSPackage_GUID(IID_IDTSCustomTask, 10020904)
DEFINE_DTSPackage_GUID(IID_IDTSTasks, 10020905)
DEFINE_DTSPackage_GUID(IID_IDTSTask, 10020906)

DEFINE_DTSPackage_GUID(IID_IDTSActiveScriptTask, 10020907)
DEFINE_DTSPackage_GUID(IID_IDTSDataPumpTask, 10020908)
DEFINE_DTSPackage_GUID(IID_IDTSCreateProcessTask, 10020909)
DEFINE_DTSPackage_GUID(IID_IDTSExecPackageTask, 1002090B)
DEFINE_DTSPackage_GUID(IID_IDTSExecuteSQLTask, 1002090C)
DEFINE_DTSPackage_GUID(IID_IDTSDataDrivenQueryTask, 1002090D)
DEFINE_DTSPackage_GUID(IID_IDTSTransferObjectsTask, 1002090E)
DEFINE_DTSPackage_GUID(IID_IDTSSendMailTask, 1002090F)
DEFINE_DTSPackage_GUID(IID_IDTSBulkInsertTask, 10020910)

//Though we define these class ids these are used just to identify our internally
//implemented task objects. These cannot be cocreated.
DEFINE_DTSPackage_GUID(CLSID_DTSActiveScriptTask, 10020907)
DEFINE_DTSPackage_GUID(CLSID_DTSDataPumpTask, 10020908)
DEFINE_DTSPackage_GUID(CLSID_DTSCreateProcessTask, 10020909)
DEFINE_DTSPackage_GUID(CLSID_DTSExecPackageTask, 1002090B)
DEFINE_DTSPackage_GUID(CLSID_DTSExecuteSQLTask, 1002090C)
DEFINE_DTSPackage_GUID(CLSID_DTSDataDrivenQueryTask, 1002090D)
DEFINE_DTSPackage_GUID(CLSID_DTSTransferObjectsTask, 1002090E)
DEFINE_DTSPackage_GUID(CLSID_DTSSendMailTask, 1002090F)
DEFINE_DTSPackage_GUID(CLSID_DTSBulkInsertTask, 10020910)

DEFINE_DTSPackage_GUID(IID_IDTSGlobalVariables, 10020A05)
DEFINE_DTSPackage_GUID(IID_IDTSGlobalVariable, 10020A06)

DEFINE_DTSPackage_GUID(IID_IDTSPrecedenceConstraints, 10020B05)
DEFINE_DTSPackage_GUID(IID_IDTSPrecedenceConstraint, 10020B06)

DEFINE_DTSPackage_GUID(IID_IDTSConnections, 10020C05)
DEFINE_DTSPackage_GUID(IID_IDTSConnection, 10020C06)

DEFINE_DTSPackage_GUID(IID_IDTSTransformations, 10020D05)
DEFINE_DTSPackage_GUID(IID_IDTSTransformation, 10020D06)

DEFINE_DTSPackage_GUID(IID_IDTSOleDBProperties, 10020E05)
DEFINE_DTSPackage_GUID(IID_IDTSOleDBProperty, 10020E06)

DEFINE_DTSPackage_GUID(IID_IDTSSavedPackageInfos, 10020F05)
DEFINE_DTSPackage_GUID(IID_IDTSSavedPackageInfo, 10020F06)

DEFINE_DTSPackage_GUID(IID_IDTSPropertyBag, 10021005)
DEFINE_DTSPackage_GUID(IID_IDTSPersistPropertyBag, 10021006)

DEFINE_DTSPackage_GUID(IID_IDTSCustomTaskUI, 10022005)
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////





/* DTSPackage Automation interface definitions generated:  11/13/1998, 00:30:30 */

/* Forward definitions */

DTS_FWD_DEFINE_INTERFACE(Properties)		// LPDTSProperties
DTS_FWD_DEFINE_INTERFACE(Property)		// LPDTSProperty
DTS_FWD_DEFINE_INTERFACE(Package)		// LPDTSPackage
DTS_FWD_DEFINE_INTERFACE(PropertiesProvider)		// LPDTSPropertiesProvider
DTS_FWD_DEFINE_INTERFACE(Steps)		// LPDTSSteps
DTS_FWD_DEFINE_INTERFACE(Step)		// LPDTSStep
DTS_FWD_DEFINE_INTERFACE(Tasks)		// LPDTSTasks
DTS_FWD_DEFINE_INTERFACE(Task)		// LPDTSTask
DTS_FWD_DEFINE_INTERFACE(CustomTask)		// LPDTSCustomTask
DTS_FWD_DEFINE_INTERFACE(ActiveScriptTask)		// LPDTSActiveScriptTask
DTS_FWD_DEFINE_INTERFACE(DataPumpTask)		// LPDTSDataPumpTask
DTS_FWD_DEFINE_INTERFACE(CreateProcessTask)		// LPDTSCreateProcessTask
DTS_FWD_DEFINE_INTERFACE(ExecuteSQLTask)		// LPDTSExecuteSQLTask
DTS_FWD_DEFINE_INTERFACE(DataDrivenQueryTask)		// LPDTSDataDrivenQueryTask
DTS_FWD_DEFINE_INTERFACE(TransferObjectsTask)		// LPDTSTransferObjectsTask
DTS_FWD_DEFINE_INTERFACE(SendMailTask)		// LPDTSSendMailTask
DTS_FWD_DEFINE_INTERFACE(BulkInsertTask)		// LPDTSBulkInsertTask
DTS_FWD_DEFINE_INTERFACE(GlobalVariables)		// LPDTSGlobalVariables
DTS_FWD_DEFINE_INTERFACE(GlobalVariable)		// LPDTSGlobalVariable
DTS_FWD_DEFINE_INTERFACE(PrecedenceConstraints)		// LPDTSPrecedenceConstraints
DTS_FWD_DEFINE_INTERFACE(PrecedenceConstraint)		// LPDTSPrecedenceConstraint
DTS_FWD_DEFINE_INTERFACE(OleDBProperties)		// LPDTSOleDBProperties
DTS_FWD_DEFINE_INTERFACE(OleDBProperty)		// LPDTSOleDBProperty
DTS_FWD_DEFINE_INTERFACE(Connections)		// LPDTSConnections
DTS_FWD_DEFINE_INTERFACE(Connection)		// LPDTSConnection
DTS_FWD_DEFINE_INTERFACE(Transformations)		// LPDTSTransformations
DTS_FWD_DEFINE_INTERFACE(Transformation)		// LPDTSTransformation
DTS_FWD_DEFINE_INTERFACE(Columns)		// LPDTSColumns
DTS_FWD_DEFINE_INTERFACE(Column)		// LPDTSColumn
DTS_FWD_DEFINE_INTERFACE(Lookups)		// LPDTSLookups
DTS_FWD_DEFINE_INTERFACE(Lookup)		// LPDTSLookup
DTS_FWD_DEFINE_INTERFACE(SavedPackageInfo)		// LPDTSSavedPackageInfo
DTS_FWD_DEFINE_INTERFACE(SavedPackageInfos)		// LPDTSSavedPackageInfos
DTS_FWD_DEFINE_INTERFACE(PropertyBag)		// LPDTSPropertyBag
DTS_FWD_DEFINE_INTERFACE(PersistPropertyBag)		// LPDTSPersistPropertyBag
DTS_FWD_DEFINE_INTERFACE(PackageEvents)		// LPDTSPackageEvents
DTS_FWD_DEFINE_INTERFACE(PackageLog)		// LPDTSPackageLog
DTS_FWD_DEFINE_INTERFACE(CustomTaskUI)		// LPDTSCustomTaskUI

/* Interface definitions */

#undef INTERFACE
#define INTERFACE IDTSProperties
DECLARE_INTERFACE_(IDTSProperties, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSProperties)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSProperty **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSProperty
DECLARE_INTERFACE_(IDTSProperty, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSProperty)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetValue)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetValue)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetType)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(GetGet)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(GetSet)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPackage
DECLARE_INTERFACE_(IDTSPackage, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPackage)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSteps)(THIS_ DTS_RETVAL IDTSSteps **pRetVal) PURE;
	STDMETHOD(GetTasks)(THIS_ DTS_RETVAL IDTSTasks **pRetVal) PURE;
	STDMETHOD(GetConnections)(THIS_ DTS_RETVAL IDTSConnections **pRetVal) PURE;
	STDMETHOD(GetGlobalVariables)(THIS_ DTS_RETVAL IDTSGlobalVariables **pRetVal) PURE;
	STDMETHOD(GetPackageID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetWriteCompletionStatusToNTEventLog)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetWriteCompletionStatusToNTEventLog)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetLogFileName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetLogFileName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFailOnError)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetFailOnError)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetVersionID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetCreatorName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetCreatorComputerName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetCreationDate)(THIS_ DTS_RETVAL DATE *pRetVal) PURE;
	STDMETHOD(GetPackagePriorityClass)(THIS_ DTS_RETVAL DTSPackagePriorityClass *pRetVal) PURE;
	STDMETHOD(SetPackagePriorityClass)(THIS_ DTS_IN DTSPackagePriorityClass NewValue) PURE;
	STDMETHOD(GetMaxConcurrentSteps)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetMaxConcurrentSteps)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(Execute)(THIS) PURE;
	STDMETHOD(SaveToStorageFile)(THIS_ DTS_IN BSTR UNCFile,
		DTS_IN BSTR OwnerPassword CPPDEFAULT(= NULL),
		DTS_IN BSTR OperatorPassword CPPDEFAULT(= NULL),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL),
		DTS_IN VARIANT_BOOL bReusePasswords CPPDEFAULT(= VARIANT_TRUE)) PURE;
	STDMETHOD(SaveToRepository)(THIS_ DTS_IN BSTR RepositoryServerName,
		DTS_IN BSTR RepositoryDatabaseName,
		DTS_IN BSTR RepositoryUserName,
		DTS_IN BSTR RepositoryUserPassword,
		DTS_IN DTSRepositoryStorageFlags Flags CPPDEFAULT(= DTSReposFlag_Default),
		DTS_IN BSTR CategoryID CPPDEFAULT(= NULL),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL)) PURE;
	STDMETHOD(RemoveFromRepository)(THIS_ DTS_IN BSTR RepositoryServerName,
		DTS_IN BSTR RepositoryDatabaseName,
		DTS_IN BSTR RepositoryUserName,
		DTS_IN BSTR RepositoryUserPassword,
		DTS_IN BSTR PackageID,
		DTS_IN BSTR VersionID CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageName CPPDEFAULT(= NULL),
		DTS_IN DTSRepositoryStorageFlags Flags CPPDEFAULT(= DTSReposFlag_Default)) PURE;
	STDMETHOD(LoadFromStorageFile)(THIS_ DTS_IN BSTR UNCFile,
		DTS_IN BSTR Password,
		DTS_IN BSTR PackageID,
		DTS_IN BSTR VersionID CPPDEFAULT(= NULL),
		DTS_IN BSTR Name CPPDEFAULT(= NULL),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL)) PURE;
	STDMETHOD(LoadFromRepository)(THIS_ DTS_IN BSTR RepositoryServerName,
		DTS_IN BSTR RepositoryDatabaseName,
		DTS_IN BSTR RepositoryUserName,
		DTS_IN BSTR RepositoryUserPassword,
		DTS_IN BSTR PackageID,
		DTS_IN BSTR VersionID CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageName CPPDEFAULT(= NULL),
		DTS_IN DTSRepositoryStorageFlags Flags CPPDEFAULT(= DTSReposFlag_Default),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL)) PURE;
	STDMETHOD(GetSavedPackageInfos)(THIS_ DTS_IN BSTR UNCFile,
		DTS_RETVAL IDTSSavedPackageInfos **pRetVal) PURE;
	STDMETHOD(UnInitialize)(THIS) PURE;
	STDMETHOD(SaveToSQLServer)(THIS_ DTS_IN BSTR ServerName,
		DTS_IN BSTR ServerUserName,
		DTS_IN BSTR ServerPassword,
		DTS_IN DTSSQLServerStorageFlags Flags CPPDEFAULT(= DTSSQLStgFlag_Default),
		DTS_IN BSTR PackageOwnerPassword CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageOperatorPassword CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageCategoryID CPPDEFAULT(= NULL),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL),
		DTS_IN VARIANT_BOOL bReusePasswords CPPDEFAULT(= VARIANT_TRUE)) PURE;
	STDMETHOD(LoadFromSQLServer)(THIS_ DTS_IN BSTR ServerName,
		DTS_IN BSTR ServerUserName,
		DTS_IN BSTR ServerPassword,
		DTS_IN DTSSQLServerStorageFlags Flags CPPDEFAULT(= DTSSQLStgFlag_Default),
		DTS_IN BSTR PackagePassword CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageGuid CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageVersionGuid CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageName CPPDEFAULT(= NULL),
		DTS_IN VARIANT *pVarPersistStgOfHost CPPDEFAULT(= NULL)) PURE;
	STDMETHOD(RemoveFromSQLServer)(THIS_ DTS_IN BSTR ServerName,
		DTS_IN BSTR ServerUserName,
		DTS_IN BSTR ServerPassword,
		DTS_IN DTSSQLServerStorageFlags Flags CPPDEFAULT(= DTSSQLStgFlag_Default),
		DTS_IN BSTR PackageGuid CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageVersionGuid CPPDEFAULT(= NULL),
		DTS_IN BSTR PackageName CPPDEFAULT(= NULL)) PURE;
	STDMETHOD(SaveAs)(THIS_ DTS_IN BSTR NewName) PURE;
	STDMETHOD(GetDTSVersionInfo)(THIS_ DTS_OUT long *VersionMajor,
		DTS_OUT long *VersionMinor,
		DTS_OUT long *VersionBuild,
		DTS_OUT BSTR *VersionComments) PURE;
	STDMETHOD(GetLineageOptions)(THIS_ DTS_RETVAL DTSLineageOptions *pRetVal) PURE;
	STDMETHOD(SetLineageOptions)(THIS_ DTS_IN DTSLineageOptions NewValue) PURE;
	STDMETHOD(GetUseTransaction)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetUseTransaction)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetTransactionIsolationLevel)(THIS_ DTS_RETVAL DTSIsolationLevel *pRetVal) PURE;
	STDMETHOD(SetTransactionIsolationLevel)(THIS_ DTS_IN DTSIsolationLevel NewValue) PURE;
	STDMETHOD(GetAutoCommitTransaction)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetAutoCommitTransaction)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetRepositoryMetadataOptions)(THIS_ DTS_RETVAL DTSRepositoryMetadataOptions *pRetVal) PURE;
	STDMETHOD(SetRepositoryMetadataOptions)(THIS_ DTS_IN DTSRepositoryMetadataOptions NewValue) PURE;
	STDMETHOD(GetUseOLEDBServiceComponents)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetUseOLEDBServiceComponents)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetLastExecutionLineage)(THIS_ DTS_OUT long *LineageShort,
		DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(StartPreparationForStepsExecutingOnMainThread)(THIS) PURE;
	STDMETHOD(EndPreparationForStepsExecutingOnMainThread)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPropertiesProvider
DECLARE_INTERFACE_(IDTSPropertiesProvider, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPropertiesProvider)

	STDMETHOD(GetPropertiesForObject)(THIS_ DTS_IN IDispatch *pObject,
		DTS_RETVAL IDTSProperties **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSSteps
DECLARE_INTERFACE_(IDTSSteps, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSSteps)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSStep **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSStep *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSStep *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_RETVAL IDTSStep **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSStep
DECLARE_INTERFACE_(IDTSStep, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSStep)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetPrecedenceConstraints)(THIS_ DTS_RETVAL IDTSPrecedenceConstraints **pRetVal) PURE;
	STDMETHOD(GetExecutionStatus)(THIS_ DTS_RETVAL DTSStepExecStatus *pRetVal) PURE;
	STDMETHOD(SetExecutionStatus)(THIS_ DTS_IN DTSStepExecStatus NewValue) PURE;
	STDMETHOD(GetExecutionResult)(THIS_ DTS_RETVAL DTSStepExecResult *pRetVal) PURE;
	STDMETHOD(GetTaskName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetTaskName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetCommitSuccess)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetCommitSuccess)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetRollbackFailure)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetRollbackFailure)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetActiveXScript)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetActiveXScript)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetScriptLanguage)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetScriptLanguage)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFunctionName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetFunctionName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetAddGlobalVariables)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetAddGlobalVariables)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetRelativePriority)(THIS_ DTS_RETVAL DTSStepRelativePriority *pRetVal) PURE;
	STDMETHOD(SetRelativePriority)(THIS_ DTS_IN DTSStepRelativePriority NewValue) PURE;
	STDMETHOD(GetCloseConnection)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetCloseConnection)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetExecuteInMainThread)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetExecuteInMainThread)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetIsPackageDSORowset)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetIsPackageDSORowset)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(Execute)(THIS) PURE;
	STDMETHOD(GetExecutionErrorInfo)(THIS_ DTS_OUT long *pErrorCode,
		DTS_OUT BSTR *pbstrSource,
		DTS_OUT BSTR *pbstrDescription,
		DTS_OUT BSTR *pbstrHelpFile,
		DTS_OUT long *pHelpContext,
		DTS_OUT BSTR *pbstrIDofInterfaceWithError) PURE;
	STDMETHOD(GetJoinTransactionIfPresent)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetJoinTransactionIfPresent)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetStartTime)(THIS_ DTS_RETVAL DATE *pRetVal) PURE;
	STDMETHOD(GetFinishTime)(THIS_ DTS_RETVAL DATE *pRetVal) PURE;
	STDMETHOD(GetExecutionTime)(THIS_ DTS_RETVAL double *pRetVal) PURE;
	STDMETHOD(GetDisableStep)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetDisableStep)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSTasks
DECLARE_INTERFACE_(IDTSTasks, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSTasks)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSTask **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSTask *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSTask *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR bstrID,
		DTS_RETVAL IDTSTask **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSTask
DECLARE_INTERFACE_(IDTSTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSTask)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetCustomTask)(THIS_ DTS_RETVAL IDTSCustomTask **pRetVal) PURE;
	STDMETHOD(GetCustomTaskID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSCustomTask
DECLARE_INTERFACE_(IDTSCustomTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSCustomTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSActiveScriptTask
DECLARE_INTERFACE_(IDTSActiveScriptTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSActiveScriptTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(CheckSyntax)(THIS) PURE;
	STDMETHOD(GetActiveXScript)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetActiveXScript)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFunctionName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetFunctionName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetScriptLanguage)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetScriptLanguage)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetAddGlobalVariables)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetAddGlobalVariables)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSDataPumpTask
DECLARE_INTERFACE_(IDTSDataPumpTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSDataPumpTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetSourceConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetSourceConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSourceObjectName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceObjectName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSourceSQLStatement)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceSQLStatement)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetDestinationConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetDestinationObjectName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationObjectName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationSQLStatement)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationSQLStatement)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetProgressRowCount)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetProgressRowCount)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetMaximumErrorCount)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetMaximumErrorCount)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetExceptionFileName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFetchBufferSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetFetchBufferSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSourceCommandProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
	STDMETHOD(GetDestinationCommandProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
	STDMETHOD(GetTransformations)(THIS_ DTS_RETVAL IDTSTransformations **pRetVal) PURE;
	STDMETHOD(GetUseFastLoad)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetUseFastLoad)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetInsertCommitSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetInsertCommitSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetDestinationColumnDefinitions)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetExceptionFileColumnDelimiter)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileColumnDelimiter)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetExceptionFileRowDelimiter)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileRowDelimiter)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetLookups)(THIS_ DTS_RETVAL IDTSLookups **pRetVal) PURE;
	STDMETHOD(GetAllowIdentityInserts)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetAllowIdentityInserts)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetFirstRow)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetFirstRow)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetLastRow)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetLastRow)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetFastLoadOptions)(THIS_ DTS_RETVAL DTSFastLoadOptions *pRetVal) PURE;
	STDMETHOD(SetFastLoadOptions)(THIS_ DTS_IN DTSFastLoadOptions NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSCreateProcessTask
DECLARE_INTERFACE_(IDTSCreateProcessTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSCreateProcessTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetProcessCommandLine)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetProcessCommandLine)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSuccessReturnCode)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetSuccessReturnCode)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetTimeout)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetTimeout)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetTerminateProcessAfterTimeout)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetTerminateProcessAfterTimeout)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetFailPackageOnTimeout)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetFailPackageOnTimeout)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSExecuteSQLTask
DECLARE_INTERFACE_(IDTSExecuteSQLTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSExecuteSQLTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetSQLStatement)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSQLStatement)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetCommandTimeout)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetCommandTimeout)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetCommandProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSDataDrivenQueryTask
DECLARE_INTERFACE_(IDTSDataDrivenQueryTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSDataDrivenQueryTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetSourceConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetSourceConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSourceObjectName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceObjectName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSourceSQLStatement)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceSQLStatement)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetDestinationConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetDestinationObjectName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationObjectName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationSQLStatement)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationSQLStatement)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetProgressRowCount)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetProgressRowCount)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetMaximumErrorCount)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetMaximumErrorCount)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetExceptionFileName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFetchBufferSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetFetchBufferSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSourceCommandProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
	STDMETHOD(GetDestinationCommandProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
	STDMETHOD(GetTransformations)(THIS_ DTS_RETVAL IDTSTransformations **pRetVal) PURE;
	STDMETHOD(GetLookups)(THIS_ DTS_RETVAL IDTSLookups **pRetVal) PURE;
	STDMETHOD(GetDestinationColumnDefinitions)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetInsertQuery)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetInsertQuery)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetInsertQueryColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetUpdateQuery)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetUpdateQuery)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetUpdateQueryColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetDeleteQuery)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDeleteQuery)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDeleteQueryColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetUserQuery)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetUserQuery)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetUserQueryColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetExceptionFileColumnDelimiter)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileColumnDelimiter)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetExceptionFileRowDelimiter)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetExceptionFileRowDelimiter)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFirstRow)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetFirstRow)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetLastRow)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetLastRow)(THIS_ DTS_IN VARIANT NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSTransferObjectsTask
DECLARE_INTERFACE_(IDTSTransferObjectsTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSTransferObjectsTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(AddObjectForTransfer)(THIS_ DTS_IN BSTR ObjectName,
		DTS_IN BSTR OwnerName,
		DTS_IN DTSSQLObjectType Type) PURE;
	STDMETHOD(GetObjectForTransfer)(THIS_ DTS_IN LONG Index,
		DTS_OUT BSTR *ObjectName,
		DTS_OUT BSTR *OwnerName,
		DTS_OUT DTSSQLObjectType *Type) PURE;
	STDMETHOD(ResetObjectsList)(THIS) PURE;
	STDMETHOD(CancelExecution)(THIS) PURE;
	STDMETHOD(GetSourceServer)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceServer)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSourceLogin)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceLogin)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSourcePassword)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourcePassword)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSourceUseTrustedConnection)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetSourceUseTrustedConnection)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetSourceDatabase)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSourceDatabase)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationServer)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationServer)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationLogin)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationLogin)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationPassword)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationPassword)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDestinationUseTrustedConnection)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetDestinationUseTrustedConnection)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetDestinationDatabase)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationDatabase)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetScriptFileDirectory)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetScriptFileDirectory)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetCopyAllObjects)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetCopyAllObjects)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetIncludeDependencies)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetIncludeDependencies)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetIncludeLogins)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetIncludeLogins)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetIncludeUsers)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetIncludeUsers)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetDropDestinationObjectsFirst)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetDropDestinationObjectsFirst)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetCopySchema)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetCopySchema)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetCopyData)(THIS_ DTS_RETVAL DTSTransfer_CopyDataOption *pRetVal) PURE;
	STDMETHOD(SetCopyData)(THIS_ DTS_IN DTSTransfer_CopyDataOption NewValue) PURE;
	STDMETHOD(GetScriptOption)(THIS_ DTS_RETVAL DTSTransfer_ScriptOption *pRetVal) PURE;
	STDMETHOD(SetScriptOption)(THIS_ DTS_IN DTSTransfer_ScriptOption NewValue) PURE;
	STDMETHOD(GetScriptOptionEx)(THIS_ DTS_RETVAL DTSTransfer_ScriptOptionEx *pRetVal) PURE;
	STDMETHOD(SetScriptOptionEx)(THIS_ DTS_IN DTSTransfer_ScriptOptionEx NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSSendMailTask
DECLARE_INTERFACE_(IDTSSendMailTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSSendMailTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(InitializeMAPI)(THIS) PURE;
	STDMETHOD(UnInitializeMAPI)(THIS) PURE;
	STDMETHOD(Logon)(THIS_ DTS_RETVAL BSTR *ErrorString) PURE;
	STDMETHOD(Logoff)(THIS) PURE;
	STDMETHOD(ResolveName)(THIS_ DTS_IN BSTR Address,
		DTS_RETVAL BSTR *ErrorString) PURE;
	STDMETHOD(GetDefaultProfileName)(THIS_ DTS_RETVAL BSTR *DefaultProfile) PURE;
	STDMETHOD(ShowAddressBook)(THIS_ DTS_IN long hwndParent,
		DTS_RETVAL BSTR *Address) PURE;
	STDMETHOD(GetProfile)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetProfile)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetPassword)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetPassword)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetToLine)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetToLine)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetCCLine)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetCCLine)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetSubject)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSubject)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetMessageText)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetMessageText)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFileAttachments)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetFileAttachments)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetIsNTService)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetIsNTService)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetSaveMailInSentItemsFolder)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetSaveMailInSentItemsFolder)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSBulkInsertTask
DECLARE_INTERFACE_(IDTSBulkInsertTask, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSBulkInsertTask)

	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(Execute)(THIS_ DTS_IN IDispatch *pPackage,
		DTS_IN IDispatch *pPackageEvents,
		DTS_IN IDispatch *pPackageLog,
		DTS_OUT DTSTaskExecResult *pTaskResult) PURE;
	STDMETHOD(GetDestinationTableName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDestinationTableName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetBatchSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetBatchSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetCheckConstraints)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetCheckConstraints)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetCodepage)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetCodepage)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDataFile)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDataFile)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDataFileType)(THIS_ DTS_RETVAL DTSBulkInsert_DataFileType *pRetVal) PURE;
	STDMETHOD(SetDataFileType)(THIS_ DTS_IN DTSBulkInsert_DataFileType NewValue) PURE;
	STDMETHOD(GetFieldTerminator)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetFieldTerminator)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetRowTerminator)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetRowTerminator)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFormatFile)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetFormatFile)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetFirstRow)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetFirstRow)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetLastRow)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetLastRow)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetKeepIdentity)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetKeepIdentity)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetKeepNulls)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetKeepNulls)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetMaximumErrors)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetMaximumErrors)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSortedData)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetSortedData)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetTableLock)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetTableLock)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSGlobalVariables
DECLARE_INTERFACE_(IDTSGlobalVariables, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSGlobalVariables)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSGlobalVariable **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSGlobalVariable *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSGlobalVariable *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR Name,
		DTS_RETVAL IDTSGlobalVariable **pRetVal) PURE;
	STDMETHOD(AddGlobalVariable)(THIS_ DTS_IN BSTR Name,
		DTS_IN VARIANT Value) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSGlobalVariable
DECLARE_INTERFACE_(IDTSGlobalVariable, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSGlobalVariable)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetValue)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetValue)(THIS_ DTS_IN VARIANT NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPrecedenceConstraints
DECLARE_INTERFACE_(IDTSPrecedenceConstraints, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPrecedenceConstraints)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSPrecedenceConstraint **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSPrecedenceConstraint *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSPrecedenceConstraint *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR StepName,
		DTS_RETVAL IDTSPrecedenceConstraint **pRetVal) PURE;
	STDMETHOD(AddConstraint)(THIS_ DTS_IN BSTR StepName) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPrecedenceConstraint
DECLARE_INTERFACE_(IDTSPrecedenceConstraint, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPrecedenceConstraint)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetStepName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetStepName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetPrecedenceBasis)(THIS_ DTS_RETVAL DTSStepPrecedenceBasis *pRetVal) PURE;
	STDMETHOD(SetPrecedenceBasis)(THIS_ DTS_IN DTSStepPrecedenceBasis NewValue) PURE;
	STDMETHOD(GetValue)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetValue)(THIS_ DTS_IN VARIANT NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSOleDBProperties
DECLARE_INTERFACE_(IDTSOleDBProperties, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSOleDBProperties)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSOleDBProperty **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSOleDBProperty
DECLARE_INTERFACE_(IDTSOleDBProperty, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSOleDBProperty)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetValue)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetValue)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetPropertySet)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetPropertyID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSConnections
DECLARE_INTERFACE_(IDTSConnections, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSConnections)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSConnection **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSConnection *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSConnection *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR ProviderID,
		DTS_RETVAL IDTSConnection **pRetVal) PURE;
	STDMETHOD(BeginAcquireMultipleConnections)(THIS) PURE;
	STDMETHOD(EndAcquireMultipleConnections)(THIS) PURE;
	STDMETHOD(NewDataLink)(THIS_ DTS_IN BSTR UDLPath,
		DTS_RETVAL IDTSConnection **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSConnection
DECLARE_INTERFACE_(IDTSConnection, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSConnection)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDescription)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetReusable)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetReusable)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetConnectImmediate)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetConnectImmediate)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetConnected)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(GetInUse)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(GetConnectionProperties)(THIS_ DTS_RETVAL IDTSOleDBProperties **pRetVal) PURE;
	STDMETHOD(GetLastOwnerTaskName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetDataSource)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetDataSource)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetUserID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetUserID)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetPassword)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetPassword)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetConnectionTimeout)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetConnectionTimeout)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetProviderID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetCatalog)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetCatalog)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetUseTrustedConnection)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetUseTrustedConnection)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(AcquireConnection)(THIS_ DTS_IN BSTR TaskName,
		DTS_RETVAL LPUNKNOWN *pRetVal) PURE;
	STDMETHOD(ReleaseConnection)(THIS) PURE;
	STDMETHOD(GetInTransaction)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(GetUseDSL)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetUseDSL)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetUDLPath)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSTransformations
DECLARE_INTERFACE_(IDTSTransformations, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSTransformations)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSTransformation **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSTransformation *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSTransformation *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR bstrID,
		DTS_RETVAL IDTSTransformation **pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSTransformation
DECLARE_INTERFACE_(IDTSTransformation, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSTransformation)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetTransformServer)(THIS_ DTS_RETVAL IDispatch **pRetVal) PURE;
	STDMETHOD(GetTransformServerProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetTransformServerParameter)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetTransformServerParameter)(THIS_ DTS_IN VARIANT NewValue) PURE;
	STDMETHOD(GetTransformFlags)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetTransformFlags)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSourceColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetDestinationColumns)(THIS_ DTS_RETVAL IDTSColumns **pRetVal) PURE;
	STDMETHOD(GetForceSourceBlobsBuffered)(THIS_ DTS_RETVAL DTSForceMode *pRetVal) PURE;
	STDMETHOD(SetForceSourceBlobsBuffered)(THIS_ DTS_IN DTSForceMode NewValue) PURE;
	STDMETHOD(GetForceBlobsInMemory)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetForceBlobsInMemory)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetInMemoryBlobSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetInMemoryBlobSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetTransformServerID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSColumns
DECLARE_INTERFACE_(IDTSColumns, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSColumns)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSColumn **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSColumn *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSColumn *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR Name,
		DTS_IN long Ordinal,
		DTS_RETVAL IDTSColumn **pRetVal) PURE;
	STDMETHOD(AddColumn)(THIS_ DTS_IN BSTR Name,
		DTS_IN long Ordinal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSColumn
DECLARE_INTERFACE_(IDTSColumn, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSColumn)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetOrdinal)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetOrdinal)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetFlags)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetFlags)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetSize)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetSize)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetDataType)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetDataType)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetPrecision)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetPrecision)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetNumericScale)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetNumericScale)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetNullable)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
	STDMETHOD(SetNullable)(THIS_ DTS_IN VARIANT_BOOL NewValue) PURE;
	STDMETHOD(GetColumnID)(THIS_ DTS_RETVAL VARIANT *pRetVal) PURE;
	STDMETHOD(SetColumnID)(THIS_ DTS_IN VARIANT NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSLookups
DECLARE_INTERFACE_(IDTSLookups, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSLookups)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSLookup **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
	STDMETHOD(Add)(THIS_ DTS_IN IDTSLookup *Object) PURE;
	STDMETHOD(Remove)(THIS_ DTS_IN VARIANT Index) PURE;
	STDMETHOD(Insert)(THIS_ DTS_IN VARIANT Position,
		DTS_IN IDTSLookup *Object) PURE;
	STDMETHOD(New)(THIS_ DTS_IN BSTR Name,
		DTS_RETVAL IDTSLookup **pRetVal) PURE;
	STDMETHOD(AddLookup)(THIS_ DTS_IN BSTR Name,
		DTS_IN BSTR Query,
		DTS_IN long ConnectionID,
		DTS_IN long MaxCacheRows) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSLookup
DECLARE_INTERFACE_(IDTSLookup, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSLookup)

	STDMETHOD(GetParent)(THIS_ DTS_RETVAL IDTSStdObject **pRetVal) PURE;
	STDMETHOD(GetProperties)(THIS_ DTS_RETVAL IDTSProperties **pRetVal) PURE;
	STDMETHOD(GetName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetName)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetConnectionID)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetConnectionID)(THIS_ DTS_IN LONG NewValue) PURE;
	STDMETHOD(GetQuery)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(SetQuery)(THIS_ DTS_IN BSTR NewValue) PURE;
	STDMETHOD(GetMaxCacheRows)(THIS_ DTS_RETVAL LONG *pRetVal) PURE;
	STDMETHOD(SetMaxCacheRows)(THIS_ DTS_IN LONG NewValue) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSSavedPackageInfo
DECLARE_INTERFACE_(IDTSSavedPackageInfo, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSSavedPackageInfo)

	STDMETHOD(GetPackageName)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetDescription)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetPackageID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetVersionID)(THIS_ DTS_RETVAL BSTR *pRetVal) PURE;
	STDMETHOD(GetPackageCreationDate)(THIS_ DTS_RETVAL DATE *pRetVal) PURE;
	STDMETHOD(GetVersionSaveDate)(THIS_ DTS_RETVAL DATE *pRetVal) PURE;
	STDMETHOD(GetIsVersionEncrypted)(THIS_ DTS_RETVAL VARIANT_BOOL *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSSavedPackageInfos
DECLARE_INTERFACE_(IDTSSavedPackageInfos, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSSavedPackageInfos)

	STDMETHOD(Item)(THIS_ DTS_IN VARIANT Index,
		DTS_RETVAL IDTSSavedPackageInfo **pRetVal) PURE;
	STDMETHOD(Get_NewEnum)(THIS_ DTS_RETVAL IUnknown **ppEnum) PURE;
	STDMETHOD(GetCount)(THIS_ DTS_RETVAL long *pRetVal) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPropertyBag
DECLARE_INTERFACE_(IDTSPropertyBag, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPropertyBag)

	STDMETHOD(Read)(THIS_ DTS_IN BSTR bstrPropertyName,
		DTS_RETVAL VARIANT *pValue) PURE;
	STDMETHOD(Write)(THIS_ DTS_IN BSTR bstrPropertyName,
		DTS_IN VARIANT Value) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPersistPropertyBag
DECLARE_INTERFACE_(IDTSPersistPropertyBag, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPersistPropertyBag)

	STDMETHOD(Load)(THIS_ DTS_IN IDTSPropertyBag *IDTSPropertyBag) PURE;
	STDMETHOD(Save)(THIS_ DTS_IN IDTSPropertyBag *IDTSPropertyBag) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPackageEvents
DECLARE_INTERFACE_(IDTSPackageEvents, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPackageEvents)

	STDMETHOD(OnStart)(THIS_ DTS_IN BSTR EventSource) PURE;
	STDMETHOD(OnFinish)(THIS_ DTS_IN BSTR EventSource) PURE;
	STDMETHOD(OnError)(THIS_ DTS_IN BSTR EventSource,
		DTS_IN long ErrorCode,
		DTS_IN BSTR Source,
		DTS_IN BSTR Description,
		DTS_IN BSTR HelpFile,
		DTS_IN long HelpContext,
		DTS_IN BSTR IDofInterfaceWithError,
		DTS_OUT VARIANT_BOOL *pbCancel) PURE;
	STDMETHOD(OnProgress)(THIS_ DTS_IN BSTR EventSource,
		DTS_IN BSTR ProgressDescription,
		DTS_IN long PercentComplete,
		DTS_IN long ProgressCountLow,
		DTS_IN long ProgressCountHigh) PURE;
	STDMETHOD(OnQueryCancel)(THIS_ DTS_IN BSTR EventSource,
		DTS_OUT VARIANT_BOOL *pbCancel) PURE;
};

#undef INTERFACE
#define INTERFACE IDTSPackageLog
DECLARE_INTERFACE_(IDTSPackageLog, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSPackageLog)

};

#undef INTERFACE
#define INTERFACE IDTSCustomTaskUI
DECLARE_INTERFACE_(IDTSCustomTaskUI, IDTSStdObject)
{
	DTSPackage_DISPATCH_BASE(IDTSCustomTaskUI)

	STDMETHOD(Initialize)(THIS_ DTS_IN IDTSTask *pTask) PURE;
	STDMETHOD(GetUIInfo)(THIS_ DTS_OUT BSTR *pbstrToolTip,
		DTS_OUT BSTR *pbstrDescription,
		DTS_OUT long *plVersion,
		DTS_OUT DTSCustomTaskUIFlags *pFlags) PURE;
	STDMETHOD(New)(THIS_ DTS_IN long hwndParent) PURE;
	STDMETHOD(Edit)(THIS_ DTS_IN long hwndParent) PURE;
	STDMETHOD(Delete)(THIS_ DTS_IN long hwndParent) PURE;
	STDMETHOD(Help)(THIS_ DTS_IN long hwndParent) PURE;
	STDMETHOD(CreateCustomToolTip)(THIS_ DTS_IN long hwndParent,
		DTS_IN long x,
		DTS_IN long y,
		DTS_OUT long *plTipWindow) PURE;
};


#endif // ndef DTSPackage_ODL_

#endif // ndef DTSPackage_VersionOnly

#endif // def DTSPackage_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DtsPump.h ===
//
// DTSPump.h
//	Header file for the OLEDB DTSDataPump Service Provider.
//	Copyright 1997 - 1999 Microsoft Corporation
//
#ifndef DTSDataPump_H_
#define DTSDataPump_H_

#ifndef DTSDataPumpVersion_Major
	#define DTSDataPumpVersion_Major 1
	#define DTSDataPumpVersion_Minor 0
#endif // DTSDataPumpVersion_Major

#ifndef DTSDataPump_VersionOnly

// The default Blob size used in this version of the DataPump.
// May be overridden on a per-Transform or per-column basis.
#define DTS_DEFAULT_INMEMORY_BLOB_SIZE (1024 * 1024)

// Default number of successful InsertRows which will be Committed if supported by provider.
// Currently set to 0 which means not to do a commit until all rows have been transferred.
#define DTS_DEFAULT_InsertCommitSize	0

///////////////////////////////////////////////////////////////////////////////////////
// CPP and OleAut Enumerations and constants.
///////////////////////////////////////////////////////////////////////////////////////
#ifndef DTSDataPump_CONSTANTS_
#define DTSDataPump_CONSTANTS_

// To avoid the need to cast on bitwise operations (which defeats typesafety anyway),
// define the datatype as DWORD for C/CPP.  OleAut languages don't do typechecking
// and organize by the enum name.
#ifdef DTSDataPump_ODL_
	#define DP_ENUM_BEGIN(tdef, hstring)	[helpcontext(H_##tdef), helpstring(hstring)] enum tdef
		// item = value, ...
	#define DP_ENUM_END(tdef)				tdef, *LP##tdef
#else
	#define DP_ENUM_BEGIN(tdef, hstring)	DWORD tdef, *LP##tdef; enum tag##tdef
		// item = value, ...
	#define DP_ENUM_END(tdef)				
#endif

typedef DP_ENUM_BEGIN(DTSDataPumpError, "Error ranges for DTSDataPump execution") {
	DTSDataPump_E_NotImplemented				= 0x2000,
	DTSDataPump_E_RowsetsAlreadySet				= 0x2001,
	DTSDataPump_E_TransformsAlreadySet			= 0x2002,
	DTSDataPump_E_DestRowsetNotSupplied			= 0x2003,
	DTSDataPump_E_RowsetsNotSupplied			= 0x2004,
	DTSDataPump_E_SourceColumnsRequired			= 0x2005,
	DTSDataPump_E_ColCountButNoCols				= 0x2006,
	DTSDataPump_E_MismatchColOrdAndName			= 0x2007,
	DTSDataPump_E_ColumnNameNotFound			= 0x2008,
	DTSDataPump_E_ColumnOutOfRange				= 0x2009,
	DTSDataPump_E_DestColumnAlreadySpecified	= 0x200a,
	DTSDataPump_E_IDataConvertRequired			= 0x200b,
	DTSDataPump_E_NullVariantIUnknown			= 0x200c,
	DTSDataPump_E_NotReentrant					= 0x200d,
	DTSDataPump_E_RowsetChangeMustInsert		= 0x200e,
	DTSDataPump_E_DataPumpNotReentrant			= 0x200f,
	DTSDataPump_E_DestColumnReadOnly			= 0x2010,
	DTSDataPump_E_MustSpecifyDestOrTransform	= 0x2011,
	DTSDataPump_E_BadTransformFlag				= 0x2012,
	DTSDataPump_E_BadTransformStatusReturned	= 0x2013,
	DTSDataPump_E_TransformServerException		= 0x2014,
	DTSDataPump_E_CannotRebindColumn			= 0x2015,
	DTSDataPump_E_InvalidFetchBufferSize		= 0x2016,
	DTSDataPump_E_InvalidDTSBindMode			= 0x2017,
	DTSDataPump_E_SourceBlobBinding				= 0x2018,
	DTSDataPump_E_NonBlobStorageBind			= 0x2019,
	DTSDataPump_E_LookupDupName					= 0x201a,

	DTSDataPump_E_DestinationBlobBinding		= 0x2020,

	DTSDataPump_E_Copy_NeedSrcAndDestColumns	= 0x2024,
	DTSDataPump_E_Copy_ValidateSchemaError		= 0x2025,

	DTSDataPump_E_Convert_DestNotNull			= 0x2026,
	DTSDataPump_E_Convert_BadBindInfo			= 0x2027,
	DTSDataPump_E_Convert_DestOverflow			= 0x2028,
	DTSDataPump_E_Convert_SourceInvalidVariant	= 0x2029,
	DTSDataPump_E_Convert_SourceInvalidLength	= 0x202a,
	DTSDataPump_E_Convert_ConversionInvalid		= 0x202b,
	DTSDataPump_E_Convert_ConversionFailed		= 0x202c,
	DTSDataPump_E_Convert_ProviderOwnedTypeMismatch	= 0x202d,
	DTSDataPump_E_Convert_BlobStorageNoInterface	= 0x202e,

	DTSDataPump_E_AxScript_RequiredParams		= 0x2040,
	DTSDataPump_E_AxScript_ValidateSchemaError	= 0x2041,
	DTSDataPump_E_AxScript_ParseError			= 0x2042,
	DTSDataPump_E_AxScript_BadTransformFunction	= 0x2043,
	DTSDataPump_E_AxScript_CantChangeSrcCols	= 0x2044,
	DTSDataPump_E_AxScript_CantResetAfterInitialize	= 0x2045,
	DTSDataPump_E_AxScript_CantInitializeEngine	= 0x2046,
	DTSDataPump_E_AxScript_RunTimeError			= 0x2047,

	DTSDataPump_E_AutoBufferInterfaceNotSupported	= 0x2051,
	DTSDataPump_E_InvalidSpecifyBlobDefaults	= 0x2051,
	DTSDataPump_E_LineageVariableNotFound		= 0x2052,
	DTSDataPump_E_LastRowCantBeLessThanFirst	= 0x2053,

	DTSDataPump_E_DDQ_NeedTransformStatus		= 0x2060,
	DTSDataPump_E_DDQ_NeedInsertQuery			= 0x2061,
	DTSDataPump_E_DDQ_NeedUpdateQuery			= 0x2062,
	DTSDataPump_E_DDQ_NeedDeleteQuery			= 0x2063,
	DTSDataPump_E_DDQ_NeedUserQuery				= 0x2064,
	DTSDataPump_E_DDQ_InformationNotSet			= 0x2065,
	DTSDataPump_E_DDQ_BadTransformStatusContext	= 0x2065,
	DTSDataPump_E_DDQ_DestColumnNotTransformed	= 0x2066,
	DTSDataPump_E_DDQ_DestColumnNeedsLength		= 0x2067,
	DTSDataPump_E_DDQ_DestDoesNotSupportSQL		= 0x2068,

} DP_ENUM_END(DTSDataPumpError);

// These allow definition of how the transform will proceed.
typedef DP_ENUM_BEGIN(DTSTransformFlags, "Flags (int or long) controlling Transform") {
	// No flags are specified; essentially, the conversion must be between exact types.
	// Note that this allows string <--> nonstring conversions, because every nonstring datatype
	// has a meaningful string representation.  This may be overridden by RequireExactType,
	// which is even stricter.
	DTSTransformFlag_Strict						= 0x00000000,

	// This flag means that IDTSDataPumpTransform::ValidateSchema should allow the transfer to proceed 
	// even if there are potential overflows, under the assumption that the consumer is aware of this but
	// knows the source values are all (or mostly) within the destination columns range.  Any overflows during
	// transformation will cause the row to be exceptioned.  This flag is generally of interest only to 
	// the IID_IDTSDataPumpTransformCopy implementation, as this is a direct copy, whereas other
	// implementations would probably convert the values or determine validity on a specific case-by-case basis.
	// This value is also used for date/time conversions which result in loss, such as DATE -> DBTIME,
	// where a subset of the source value is still meaningful.
	DTSTransformFlag_AllowDemotion 				= 0x00000001,

	// This flag means that IDTSDataPumpTransform::ValidateSchema should allow the transfer to proceed 
	// when there is promotion in the data range when moving from the source to the destination types,
	// such as I2->I4 or I4->float/double.  Note that in some cases, such as I4->R4, the data range
	// increases but at the loss of some digits of precision.
	// If AllowLossless is specified, this is allowed by the Transform.
	DTSTransformFlag_AllowPromotion 			= 0x00000002,

	// This flag allows column (w)char or byte data to be truncated silently, such as when moving data
	// from a char(60) to a char(40) column.  AllowDemotion is implied but overflow will be
	// silently truncated instead of causing an error.
	DTSTransformFlag_AllowStringTruncation 		= 0x00000004,

	// This flag means that IDTSDataPumpTransform::ValidateSchema should allow the transfer to proceed 
	// even in the event that the source is a floating-point or numeric/decimal type and the destination
	// is an integral type.  This is a numeric flavour of AllowDemotion and will not cause an error 
	// (integer overflow will still be an error; i.e. left-of-decimal digits are significant).
	DTSTransformFlag_AllowNumericTruncation		= 0x00000008,

	// This flag means that IDTSDataPumpTransform::ValidateSchema should allow the transfer to proceed 
	// even if the source column allows NULL values and the destination column does not.  As with
	// AllowDemotion, errors may be encountered during a transform.
	// If AllowLossless is specified, this is allowed by the Transform if going from nonNULLable to NULLable.
	DTSTransformFlag_AllowNullChange			= 0x00000010,

	// This flag means that IDTSDataPumpTransform::ValidateSchema should allow the transfer to proceed 
	// even in the event that the source and destination have a signed vs. unsigned mismatch.  As with
	// AllowDemotion, errors may be encountered during a transform.
	// If AllowLossless is specified, this is allowed by the Transform when going from unsigned to signed
	// with promotion (e.g. UI2 -> I4).
	DTSTransformFlag_AllowSignChange			= 0x00000020,

	// Require that the destination column's datatype be exactly the same as the source column's
	// (including length or precision/scale, fixed vs. variable length, sign, and nullability).
	// This overrides any other flags specified for column conversion validation.
	// Cannot be specified with ForceConvert.
	DTSTransformFlag_RequireExactType			= 0x00000040,

	// Allow the conversion to proceed at all times, even when the source and destination types are
	// fundamentally different.  Currently this applies to:
	//		<nonchar> <--> bytes:		Does a bitwise copy; caveats apply for endian, machine representations.
	//		int/real <--> date:			DATE is a double so this just converts between int and double.
	//		real <--> date:				DATE is a double so this just copies.
	// Cannot be specified with RequireExactType.
	DTSTransformFlag_ForceConvert				= 0x00000080,

	// Causes the TransformServer to not ClearBindingData() the destination-row storage
	// for the columns in this Transform during OnRowComplete().  This allows the
	// destination row's values to be reused by the next transform.
	DTSTransformFlag_PreserveDestRows			= 0x00000100,

	// Causes the TransformServer to allow all conversions for which a lossless conversion is
	// possible - e.g. Promotion, nonNULLable -> NULLable, unsigned -> promoted signed.
	DTSTransformFlag_AllowLosslessConversion	= 0x00000200,

	// No flags are specified; essentially, the conversion must be between exact types.
	// Note that this allows string <--> nonstring conversions, because every nonstring datatype
	// has a meaningful string representation.  This may be overridden by RequireExactType.
	DTSTransformFlag_Default					= (DTSTransformFlag_AllowDemotion | DTSTransformFlag_AllowPromotion | DTSTransformFlag_AllowStringTruncation | DTSTransformFlag_AllowNumericTruncation | DTSTransformFlag_AllowNullChange | DTSTransformFlag_AllowSignChange)

} DP_ENUM_END(DTSTransformFlags);

// Status returned from a Transform operation.
// All "normal" errors from DTSDataPumpTransform::Execute should be returned as
// one of these flags, with a SUCCEEDED HRESULT (possibly with the addition of
// OLEDB Error Records via the IDTSErrorRecords interface passed to 
// IDTSDataPumpTransform::AddVariable).  A FAILED HRESULT returned from
// DTSDataPumpTransform::Execute indicates an unrecoverable error and aborts
// the DataPump.
typedef DP_ENUM_BEGIN(DTSTransformStatus, "Return value (int or long) from ActiveX Scripting Transform") {
	// Default; conversions (if any) succeeded; write the row to destination if
	// specified, without calling any error handlers.  Default is to do Insert;
	// this may be overridden for data-driven queries by other flags to do Insert,
	// Update, Delete, or UserQuery for a user-defined ad-hoc query.
	DTSTransformStat_OK							= 0x00000001,

	// Success with additional info, which the app may want to process further
	// by reading its pvTransformUserData (if it shares that knowledge with the
	// transform server) or thru OLEDB Error Records; therefore, the Pump will 
	// call the ErrorSink if one was specified, but does not increment the error
	// row count.  The DTSTransformStatus result of the operation is passed to
	// the ErrorSink, so the app can switch on this bit.
	DTSTransformStat_Info						= 0x00001000,

	// Write row if destination specified; also call ErrorSink with Info.
	DTSTransformStat_OKInfo						= 0x00001001,

	// Abort further processing of this row, for non-error reasons.
	DTSTransformStat_SkipRow					= 0x00000002,

	// Abort further processing of this row, and calls ErrorSink with Info.
	DTSTransformStat_SkipRowInfo				= 0x00001002,

	// Do not fetch the next row; re-execute all transforms against the current
	// source and destination rows.  No initialization is done to the destination
	// row, so this could be used to generate multiple output rows from a single
	// input row.  Subsequent transforms are still executed unless a SkipRow* flag
	// is also present.
	DTSTransformStat_SkipFetch					= 0x00000004,

	// Do not write the current row to destination.  Usually used to fetch the next
	// source row to generate a simple aggregate.  Subsequent transforms are still
	// executed unless a SkipRow* flag is also present.  DTSTransformStat_SkipInsert
	// forces DTSTransformFlag_PreserveDestRows behaviour for the row for which it
	// is specified.
	DTSTransformStat_SkipInsert					= 0x00000008,

	// The following 4 flags are not compatible together.  They execute the
	// similarly-named statement passed to SetRowsetAndQueries on the Destination,
	// with values from the currently transformed Destination Row.
	DTSTransformStat_InsertQuery				= 0x00000010,
	DTSTransformStat_UpdateQuery				= 0x00000020,
	DTSTransformStat_DeleteQuery				= 0x00000040,
	DTSTransformStat_UserQuery					= 0x00000080,

	// May be bit-OR'd into the following error returns.
	DTSTransformStat_Error						= 0x00002000,

	// Abort further processing of this row due to error and call the error sink,
	// but do not write to exception file.  Should be handled by the ErrorSink.
	DTSTransformStat_ErrorSkipRow				= 0x00002002,

	// Abort further processing of this row as an exception and call the error sink,
	// and write this row to exception file.  Should be handled by the ErrorSink.
	// Note this bit does not map to any non-error bits.
	DTSTransformStat_ExceptionRow				= 0x00002100,

	// Ord with prior bits to abort processing any further rows and return
	// DTSTransformExec_AbortPump from IDTSDataPump::Execute().  
	// This does not include the Error bit so &'ing with it will only return
	// TRUE for this bit.
	DTSTransformStat_AbortPump					= 0x00004000,

	// Transform determined that this row is the last one to be operated on,
	// so allows the pump to be aborted "normally" (without signifying an error).
	// May be or'd with other bits to skip the current row; otherwise it will go
	// to the next transforms and then write it to destination (in accordance with
	// how the following transforms specify).
	DTSTransformStat_NoMoreRows					= 0x00008000,

} DP_ENUM_END(DTSTransformStatus);

// Status returned from an IDataPump::Execute operation.
typedef DP_ENUM_BEGIN(DTSExecuteStatus, "Return value (int or long) from DataPump Execution") {
	// All rows copied (or skipped) without error.
	DTSTransformExec_OK							= 0x00000000,

	// Bit-ORd into the following error returns.
	DTSTransformExec_Error						= 0x00001000,	// Bit-ord into following

	// Pump continued to completion but errors were encountered
	DTSTransformExec_OKErrors					= 0x00001001,

	// Pump aborted because too many rows had errors.
	DTSTransformExec_ErrorCountExceeded			= 0x00001002,

	// Pump aborted due to Transform request or ErrorSink return.
	DTSTransformExec_AbortPump					= 0x00001004,
} DP_ENUM_END(DTSExecuteStatus);

#endif	// DTSDataPump_CONSTANTS_

////////////////////////////////////////////
// CPP-only definitions
////////////////////////////////////////////

#ifndef DTSDataPump_ODL_

// Define parameter usage.
#define DP_IN
#define DP_OUT
#define DP_INOUT

#ifdef NONAMELESSUNION
#define DP_UNION_NAME(u)	u
#else
#define DP_UNION_NAME(u)
#endif

// For safety, struct initialization values are set in ctors for C++ clients.
#if !defined(__cplusplus) && !defined(DP_NO_AUTOCTOR)
#define DP_NO_AUTOCTOR
#endif

// These are the conversion flags indicating what may happen during an individual column
// Convert() call, and accounts for the column lengths, nullability, sign, etc.
// See DTSTransformFlags for a more detailed discussion of the similarly-named TransformFlag
// which will allow conversion to proceed when these conditions are present.
//	Keys:
//		<T> - TransformFlag is available to explicitly allow this.
//		<E>	- Error may be encountered during Convert()
//		<F> - Fatal; Convert() will error as unsupported or with overflow.
//
typedef DP_ENUM_BEGIN(DTSConvertFlags, "DTSConvertFlags") {
	// The conversion is between columns of identical type, length or precision/scale,
	// and nullability, or is between text and another type, with the text being of
	// sufficient length for a representation of that datatype.  Errors should not be
	// encountered during Convert() unless a text conversion contains invalid data.
	DTSConvertFlag_ExactType					= 0x00000000,

	// The conversion will promote the range of data from source to destination
	// (e.g. I4 -> I2, [var]char -> longer [var]char, numeric(x, y) -> numeric(x+1, y+1)).
	// <T>
	DTSConvertFlag_Promotion					= 0x00000001,
	
	// Conversion will demote (e.g. I4 -> I2); overflow error possible.
	// <T, E> 
	DTSConvertFlag_Demotion						= 0x00000002,
	
	// Conversion may do string or byte truncation; truncation error possible if
	// this flag is not specified on Convert().
	// <T, E>
	DTSConvertFlag_StringTruncation				= 0x00000004,
	
	// Conversion may do integral rounding from float or numeric, or move a larger
	// scale into a smaller scale (both cases resulting in truncation of digits to
	// the right of the decimal point).  This is also flagged when moving from integral
	// or numeric to float/double when source precision is greater than FLT/DBL_DIG.
	// <T> 
	DTSConvertFlag_NumericTruncation			= 0x00000008,
	
	// Conversion may try to put NULL source data into a NonNULL destination column,
	// which will error, or vice-versa, which will be safe.
	// <T, E>
	DTSConvertFlag_NullChange					= 0x00000010,
	
	// Conversion may try to put a signed value int/float into an unsigned destination, 
	// or vice-versa.  This may error if the source value is negative and destination
	// is unsigned, or if the source is unsigned and its value is larger than the
	// signed destination's maximum signed value (overflow).
	// <T, E>
	DTSConvertFlag_SignChange					= 0x00000020,
	
	// Destination column size is too short for a meaningful conversion from source
	// column type.
	// <F>
	DTSConvertFlag_DestTooShort					= 0x00000040,
	
	// Source column size is too short for a meaningful conversion to destination
	// column type.
	// <F>
	DTSConvertFlag_SourceTooShort				= 0x00000080,
	
	// Source and destination datatypes are not really compatible, but conversion can be forced.
	// <T>
	DTSConvertFlag_ForceConvert					= 0x00000100,
	
	// Conversion fails because of bad or incompatible column types.
	// <F>
	DTSConvertFlag_Unsupported					= 0x00001000,

} DP_ENUM_END(DTSConvertFlags);

// Binding modes for column data; returned from IDTSDataPumpTransform::ValidateSchema
// via DTSTransformColumnInfo.  Normally the DataPump default handling does not need to
// be changed, but for Blob ((DBCOLUMNFLAGS_ISLONG) columns, custom Transforms are able
// to adjust bindings to maximize performance.
//
typedef DP_ENUM_BEGIN(DTSBindMode, "DTSBindMode") {
	// Indicates data should be bound "in-memory, out of line".  Currently this is only supported
	// by the OLEDB specification for variable-length types: DBTYPE_((W)STR|BYTES); therefore,
	// the DataPump will error if it is specified for other types.  DTSBindMode_(Client|Provider)Owned
	// must be specified with DTSBindMode_Byref.
	// 
	// For source, the returned data will be a direct pointer to the provider's data if
	// DTSBindMode_ProviderOwned is specified (in which case it must not be free'd or written to),
	// or a CoTaskMemAlloc()'d pointer if DTSBindMode_ClientOwned is specified (in which case it
	// is the client's property and must be freed).
	//
	// For destination, the transformation server must place the data pointer in
	// pDestColumnInfo->pvRowData.  If DTSBindMode_ClientOwned is specified, then the data
	// is assumed to require freeing after the InsertRow operation completes.  The DataPump
	// will never perform a non-Byref, in-memory destination binding for a Blob, so this flag
	// must be specified unless a Storage Object is used.
	//
	DTSBindMode_Byref							= 0x00000001,

	// Default "in-memory, inline" binding mode; space for the source and destination data, including
	// the full length of a DBTYPE_((W)STR|BYTES) column, is allocated in rgColumnData[ii].pvData and
	// passed to IDTSDataPumpTransform::Execute.
	//
	// For a BLOB (DBCOLUMNFLAGS_ISLONG) column, IDTSDataPumpTransform::ValidateSchema returns
	// the length to use for this binding in ppDTSColBinding[ii].cbInMemoryBlobSize.  This will
	// result in a separate allocation for that Blob column (i.e. multiple Blobs are not
	// allocated within a single contiguous row).
	//
	// On fetch from Source, the DBSTATUS in the binding will indicate whether the data was
	// truncated; it is up to the Transform server how (or if) this is handled.
	//
	// For performance reasons, this flag should not be specified for non-Blob (W)STR|BYTES
	// source columns; DTSBindMode_Byref_ProviderOwned is the default, to use a pointer to the
	// provider's data cache and avoid an unnecessary copy.
	//
	// For DBTYPE_BSTR and DBTYPE_VARIANT, this specifies that the binding is DBMEMOWNER_CLIENTOWNED
	// (without BYREF), and the client is responsible for freeing it (e.g. IDTSDataConvert::ClearBindingData).
	//
	DTSBindMode_ClientOwned						= 0x00000002,

	// For Source DBTYPE_((W)STR|BYTES), this flag causes the OLEDB binding to be done as DBTYPE_BYREF
	// with DBMEMOWNER_CLIENTOWNED, resulting in a CoTaskMemAlloc which the client is
	// responsible for freeing (e.g. via IDTSDataConvert::ClearBindingData).  For a BLOB
	// column, the length to use for this binding is returned from ValidateSchema() in 
	// ppDTSColBinding[ii].cbInMemoryBlobSize.  On fetch from Source, the DBSTATUS in the binding
	// will indicate whether the data was truncated; it is up to the Transform server how (or if)
	// this is handled.
	//
	// This flag causes each row to have a separate CoTaskMemAlloc for the source column.  This is
	// somewhat less efficient than the other in-memory options, and thus should only be used by
	// a Transform which wants to assume ownership of that allocation.  The Transform is responsible
	// for tracking and freeing the allocation (and for ensuring that OnRowComplete does not free
	// it if it is to be used in subsequent Transforms).
	//
	// For destination columns, this is the "safest" way to pass an in-memory pointer, as some providers
	// may not allow ProviderOwned on a destination (such as with Blob columns).  The Transform must
	// ensure that it does not double-free a pointer.
	//
	DTSBindMode_Byref_ClientOwned				= 0x00000003,

	// By itself, ProviderOwned is seldom used by itself except for BSTR, which does not always
	// support Byref.  It is primarily for DBTYPE_((W)STR|BYTES) with Byref, to reduce allocations
	// and/or copies, as described below.  It may not be supported by providers for other datatypes.
	//
	DTSBindMode_ProviderOwned					= 0x00000004,

	// This flag causes source columns to be bound to return a pointer into the provider's memory
	// space for DBTYPE_((W)STR|BYTES).  This pointer is read-only and must not be freed.
	//
	// For Blob columns, the Source Provider may not support (Byref_)ProviderOwned Blobs; this
	// would require that the entire Blob be buffered contiguously.  Therefore, unless you have
	// specific knowledge of the provider, this flag is discouraged.
	//
	// For DBTYPE_BSTR, the BYREF specification may not be supported, and may require DBMEMOWNER_PROVIDEROWNED
	// (without BYREF).  The client must not free the data.
	//
	// For other types, including DBTYPE_VARIANT, OLEDB raises an error for this specification
	// when creating an accessor.
	//
	// For the destination, specifying ProviderOwned requires that the data be shallow-copied into
	// the destination binding to avoid memory leaks (this is automatically done by IDTSDataConvert::
	// ConvertToBinding).
	//
	DTSBindMode_Byref_ProviderOwned				= 0x00000005,

	// This indicates whether the Pump should buffer Source Blob Storage Objects.  For most cases,
	// this should be left _BufferDefault; for performance reasons, the DataPump will only buffer
	// where it is necessary to avoid data loss.  This is in the following cases:
	//	DTSBindMode_Blob_BufferAlways
	//	DTSBindMode_Blob_BufferDefault, provider doesn't allow multiple SO's, and any of following:
	//		The column is referenced in a subsequent transform.
	//		The column is not the rightmost column of all transforms up to and including it.
	//
	// The DataPump can buffer from a source provider's ISequentialStream or ILockBytes, and
	// exposes both these interfaces on its own object.  Because it is a buffer, the object's data
	// can be edited via Write(At) to reduce memory requirements in the TransformServer (allowing the
	// source object to be placed in the destination row, if the destination supports Storage Objects).
	//
	// DTSBindMode_Blob_* is ignored for in-memory binding, which is an implicit buffering.
	DTSBindMode_Blob_BufferDefault				= 0x00000010,
	DTSBindMode_Blob_BufferAlways				= 0x00000020,
	DTSBindMode_Blob_BufferNever				= 0x00000040,

	// This indicates whether to use a Structured Storage object for binding a BLOB column.  The Transform
	// Server should indicate which interface it wants in DTSBindInfo::fStorageObject, on return from
	// ValidateSchema().  The DataPump supports the following behaviour:
	//    Custom Transformations:
	//       For Source, if the DataPump does not buffer, only the provider-supported Storage Object interfaces
	//			are available.  Generally this will always include ISequentialStream.  See comments regarding
	//			DTSBindMode_Blob_Buffer*; if the DataPump buffers the Blob data, it supports only ISequentialStream
	//			and ILockBytes.
	//          If the source does not support storage objects, then the Transform Server must not request a
	//			Storage Object, and must bind the source data as in-memory, specifying DTSBindInfo::cbInMemoryBlobSize.
	//       For Destination, the Transform Server supplies the Storage object placed into the row, and must
	//			specify one interface from fProviderStorageObjects for the DataPump to bind the destination.
	//          If the destination does not support storage objects, then the TransformServer must not request
	//			a Storage Object, and must bind the destination data as in-memory, ClientOwned or ProviderOwned,
	//			specifying DTSBindInfo::cbInMemoryBlobSize.
	//    Default (DataPump-supplied) TransformCopy:
	//       If either Source or Destination do not support ISequentialStream, then the DataPump will bind both
	//          as ClientOwned in-memory, using the source column's DTSBindInfo::cbInMemoryBlobSize.
	//			Otherwise, the DataPump will bind to the providers as ISequentialStream, with default buffering.
	//			See also comments regarding DTSBindMode_Blob_Buffer*; this can be specified to override the
	//			Pump's default handling even in the TransformCopy case.
	//
	// DTSBindMode_Blob_StorageObject cannot be specified with non-DTSBindMode_Blob_* flags.
	DTSBindMode_Blob_StorageObject				= 0x00000100,
} DP_ENUM_END(DTSBindMode);

// Indicates which of the DataPump defaults are to be overridden on a single AddTransform().
typedef DP_ENUM_BEGIN(DTSSpecifyBlobDefaults, "Specify overrides of DataPump Blob-handling defaults") {
	DTSBlobDefault_DataPumpDefaults		= 0x0000,	// None (initialization)
	DTSBlobDefault_BufferSource			= 0x0001,	// Override DTSBindMode_Blob_BufferDefault for source Blob Storage Objects
	DTSBlobDefault_InMemorySize			= 0x0002,	// Override DTS_DEFAULT_INMEMORY_BLOB_SIZE.
	DTSBlobDefault_ForceInMemory 		= 0x0004,	// Force Blobs to be InMemory (no Storage Objects) for this Transform.
													// Forces DTSTransformColumnInfo.fProviderStorageObjects
													// sent to the Transformer to be 0.
	DTSBlobDefault_ForceMultipleStorageObjects	= 0x0008,	// Forces DTSTransformColumnInfo.dtsProviderFlags sent to the
													// Transformer to include DTSProviderFlag_Blob_MultipleStorageObjects.
													// This could be an optimization if the Source provider supports multiple
													// storage objects and the destination is known to support them only
													// multiple blobs for insert, since the OLEDB spec does not distinguish
													// between multiple-StorageObject support for GetData vs. SetData/Insert.
} DP_ENUM_END(DTSSpecifyBlobDefaults);

// Flags indicating known Provider Blob capabilities; their absence indicates
// corresponding Provider restrictions or requirements.
typedef DP_ENUM_BEGIN(DTSProviderFlags, "Provider behaviour characteristics") {
	DTSProviderFlag_None					= 0x00000000,	// None

	DTSProviderFlag_ProviderOwned			= 0x00000001,	// Provider supports Byref binding (some may not).

	DTSProviderFlag_Blob_InsertNoLength		= 0x00000100,	// Blob Inserts do not require length to be prespecified
	DTSProviderFlag_Blob_Revisitable		= 0x00000200,	// Provider guarantees that Blob data is not skipped when succeeding columns fetched
	DTSProviderFlag_Blob_Rewindable			= 0x00000400,	// Provider guarantees Blob data supports random access
	DTSProviderFlag_Blob_ProviderOwned		= 0x00000800,	// Provider allows the PROVIDEROWNED flag for use with Blobs
	DTSProviderFlag_Blob_MultipleStorageObjects = 0x00001000,		// Provider supports multiple storage objects per row.
	DTSProviderFlag_Blob_NonBlockingStorageObjects = 0x00002000,	// Provider supports multiple nonblocking storage objects per row.
} DP_ENUM_END(DTSProviderFlags);

// The actual structure passed to AddTransform to specify overriding Blob defaults.
// This is most useful for the default TransformCopy case, but can also be used by
// a client who predetermines (e.g. via a query) the maximum Blob size in the coming
// result set, for the most efficient memory allocations.
#ifndef DP_NO_AUTOCTOR
	struct DTSTransformBlobDefaults {
#else   // DP_NO_AUTOCTOR
	typedef struct {
#endif  // DP_NO_AUTOCTOR
		DTSSpecifyBlobDefaults dtsSpecifyMask;		// Which of the following items to override.
		BOOL bBufferSource;							// If dtsSpecifyMask & DTSBlobDefault_BufferSource;
													// TRUE or FALSE forces Pump to buffer source Blobs or not.
		ULONG cbInMemorySize;						// If dtsSpecifyMask & DTSBlobDefault_InMemorySize;
													// overrides DTS_DEFAULT_INMEMORY_BLOB_SIZE.  Size in bytes.
#ifndef DP_NO_AUTOCTOR
		DTSTransformBlobDefaults()
				: dtsSpecifyMask(DTSBlobDefault_DataPumpDefaults)
			{	}
	};
#else   // DP_NO_AUTOCTOR
	} DTSTransformBlobDefaults;
#endif  // DP_NO_AUTOCTOR
typedef DTSTransformBlobDefaults *LPDTSTransformBlobDefaults;
typedef const DTSTransformBlobDefaults *LPCDTSTransformBlobDefaults;

// Specifies an individual column passed to AddTransform.  The column may be specified by
// name, or if the name is NULL, by an ordinal (this makes unnamed columns easier for the
// consumer to specify).
typedef struct {
	LPOLESTR pwzColumnName;						// Name of column
	ULONG ulColumnOrdinal;						// Ordinal of column if name is NULL; 1-based for OLEDB consistency.
} DTSTransformColumnSpecification, *LPDTSTransformColumnSpecification;
typedef const DTSTransformColumnSpecification *LPCDTSTransformColumnSpecification;

// Specifies a list of columns passed to AddTransform.
#ifndef DP_NO_AUTOCTOR
	struct DTSTransformColumnsSpecification {
#else   // DP_NO_AUTOCTOR
	typedef struct {
#endif  // DP_NO_AUTOCTOR

		ULONG cSourceColumns;						// Specify source columns
		LPCDTSTransformColumnSpecification pSourceColumns;
		ULONG cDestinationColumns;					// Specify destination columns
		LPCDTSTransformColumnSpecification pDestinationColumns;
		DTSTransformBlobDefaults BlobDefaults;		// Blob default overrides if specified

#ifndef DP_NO_AUTOCTOR
		DTSTransformColumnsSpecification() 
				: cSourceColumns(0)
				, pSourceColumns(NULL)
				, cDestinationColumns(0)
				, pDestinationColumns(NULL)
			{	}
	};
#else   // DP_NO_AUTOCTOR
	} DTSTransformColumnsSpecification;
#endif   // DP_NO_AUTOCTOR
typedef DTSTransformColumnsSpecification *LPDTSTransformColumnsSpecification;
typedef const DTSTransformColumnsSpecification *LPCDTSTransformColumnsSpecification;

// Specifies a query and list of columns for IDTSDataDrivenQuery.
#ifndef DP_NO_AUTOCTOR
	struct DTSTransformQuerySpecification {
#else   // DP_NO_AUTOCTOR
	typedef struct {
#endif  // DP_NO_AUTOCTOR

		LPCOLESTR wzQuery;								// The Parameterized Query
		ULONG cColumns;									// Specify count of columns
		LPCDTSTransformColumnSpecification pColumns;	// Specify column mapping to parameters, in order found in query.

#ifndef DP_NO_AUTOCTOR
		DTSTransformQuerySpecification() 
				: wzQuery(NULL)
				, cColumns(0)
				, pColumns(NULL)
			{	}
	};
#else   // DP_NO_AUTOCTOR
	} DTSTransformQuerySpecification;
#endif   // DP_NO_AUTOCTOR
typedef DTSTransformQuerySpecification *LPDTSTransformQuerySpecification;
typedef const DTSTransformQuerySpecification *LPCDTSTransformQuerySpecification;

// Transform-server specifiable binding information.  An array of these structures is passed to
// ValidateSchema() with default values (possibly derived from DTSTransformBlobDefaults overrides),
// and the Transform Server can set the values.  Because source columns can appear multiple times
// in the same or different transactions, the last specification wins; therefore, a TransformServer's
// Execute() method should gracefully handle a source binding different from what it specified in
// ValidateSchema().
typedef struct {
	DTSBindMode eBindMode;						// Per above.  For Blobs, specifying a Buffering mode overrides
												// the DataPump and any DTSTransformBlobDefaults default.
	DWORD fStorageObject;						// For DTSBindMode_Blob_StorageObject; one of DBPROPVAL_SS_*.  If
												// specified, eBindMode must be DTSBindMode_Blob_StorageObject.
	ULONG cbInMemoryBlobSize;					// For DTSBindMode of inmemory Blobs.  Setting this value overrides
												// the DataPump and any DTSTransformBlobDefaults default.  Size in bytes.
} DTSBindInfo;

// This is a single column definition, binding, and data item for DTSTransformColumnInfo.
typedef struct {
	const DBCOLUMNINFO *pDBColumnInfo;			// Pointer to source or destination DBCOLUMNINFO for this column.
	const DBBINDING *pDBBinding;				// Pointer to source or destination DBBINDING for this column.
												// wType == DBTYPE_EMPTY if this column is not referenced in any transform.
	DTSBindInfo *pDTSBindInfo;					// Pointer to source or destination DTSBindInfo for this column.
	LPBYTE pvData;								// Data space for this column, indexed by pDBBinding offsets.
												// NULL if this column was not referenced in any Transform.
} DTSColumnData;

// The DBCOLUMNFLAGS and pwszName are in DBCOLUMNINFO and not DBBINDING;
// therefore pass both structures to transform code.  The COM Transform server uses the
// binding info to access the pvRowData.  This structure is passed to ITransformExecute::
// Execute to expose the source and destination columns specified by the Transform.
typedef struct {
	DWORD fProviderStorageObjects;				// DBPROPVAL_SS_*; Blob Storage Object interfaces supported
												// by source or destination provider.  Will be 0 if none supported,
												// or if DTSTransformBlobDefaults::bForceBlobsInMemory is specified.
	DTSProviderFlags dtsProviderFlags;			// Provider characterstics, e.g Blob Flags.
	ULONG cColumns;								// Count of columns in rgColumns
	DTSColumnData *rgColumnData;				// Column schema and binding information
	ULONG cPriorBlobStorageObjects;				// Number of Blobs bound as Storage Objects in prior transforms.
												// Can be used with DTSProviderFlag_Blob_MultipleStorageObjects
												// to determine if the current Transform can use a storage object.
} DTSTransformColumnInfo, *LPDTSTransformColumnInfo;
typedef const DTSTransformColumnInfo *LPCDTSTransformColumnInfo;

typedef enum {
	DTSGuid_Variant,
	DTSGuid_Guid,
	DTSGuid_OleStr
} DTSGuidType;

typedef struct {
	DTSGuidType eType;							// Indexes union.
	union {
		GUID Guid;								// GUID form
		VARIANT Variant;						// BSTR == progid or clsid (differentiated by looking for . in name)
												// BYTE/LONG == guid encoding (e.g. Repository))
												// UNKNOWN == pointer to IID_IDTSDataPumpTransform
		LPOLESTR OleStr;						// Progid or clsid (differentiated by looking for . in name)
	} DP_UNION_NAME(u);
} DTSGuid;

#define DTS_DEFAULT_LookupCacheSize		100

// Specifies a query and list of columns for IDTSDataDrivenQuery.
#ifndef DP_NO_AUTOCTOR
	struct DTSTransformLookupSpecification {
#else   // DP_NO_AUTOCTOR
	typedef struct {
#endif  // DP_NO_AUTOCTOR

		LPCOLESTR wzName;								// Name of the Lookup (for disambiguation)
		LPCOLESTR wzQuery;								// The Parameterized Query
		IUnknown *pIUnkSession;							// Session to use for the Lookup
		ULONG cMaxCacheRows;							// Number of rows to cache

#ifndef DP_NO_AUTOCTOR
		DTSTransformLookupSpecification() 
				: wzName(NULL)
				, wzQuery(NULL)
				, pIUnkSession(NULL)
				, cMaxCacheRows(DTS_DEFAULT_LookupCacheSize)
			{	}
	};
#else   // DP_NO_AUTOCTOR
	} DTSTransformLookupSpecification;
#endif   // DP_NO_AUTOCTOR
typedef DTSTransformLookupSpecification *LPDTSTransformLookupSpecification;
typedef const DTSTransformLookupSpecification *LPCDTSTransformLookupSpecification;

///////////////////////////////////////////////////////////////////////////////////////
// Class and IID definitions
///////////////////////////////////////////////////////////////////////////////////////

// Forward-define all interfaces.
#define DP_FWD_DEFINE_INTERFACE(itf)					\
	interface itf;										\
	typedef interface itf * LP##itf;

// Repeat the IUnknown and IDispatch members because C doesn't provide inheritance.
#ifndef DTSDataPump_Unknown_Base
#define DTSDataPump_Unknown_Base()															\
		STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;				\
		STDMETHOD_(ULONG,AddRef) (THIS) PURE;												\
		STDMETHOD_(ULONG,Release) (THIS) PURE;
#endif
#ifndef DTSDataPump_Dispatch_Base
#define DTSDataPump_Dispatch_Base(itf)														\
		DTSDataPump_Unknown_Base()															\
		STDMETHOD(GetTypeInfoCount)(UINT FAR* pcTypeInfo) PURE;								\
		STDMETHOD(GetTypeInfo)(UINT iTypeInfo, LCID lcid, ITypeInfo FAR* FAR* ppTI) PURE;	\
		STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR FAR* rgszNames, UINT cNames,			\
								LCID lcid, DISPID FAR* rgdispid) PURE;						\
		STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,			\
								DISPPARAMS FAR* pdispparams, LPVARIANT pvarResult,			\
								LPEXCEPINFO pexcepinfo, UINT FAR* puArgErr) PURE;
#endif
#ifndef DTSDataPump_IDispatch
#define DTSDataPump_IDispatch IDispatch
#endif

// Include <initguid.h> to define ownership of these GUIDs.
// {xxxxxxxx-740b-11d0-ae7b-00aa004a34d5}
#define DEFINE_DTSDataPumpGUID(name, lval) \
      DEFINE_GUID(name, 0x##lval, 0x740b, 0x11d0, 0xae, 0x7b, 0x0, 0xaa, 0x0, 0x4a, 0x34, 0xd5);

// DTSPump-supplied classes and interfaces.
DP_FWD_DEFINE_INTERFACE(IDTSDataPump)
#define Progid_DTSDataPump			OLESTR("DTS.DataPump")
DEFINE_DTSDataPumpGUID(CLSID_DTSDataPump, 10010100)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPump, 10010101)

#define Progid_DTSErrorLookup		OLESTR("DTS.ErrorLookup")
DEFINE_DTSDataPumpGUID(CLSID_DTSErrorLookup, 10010102)

DP_FWD_DEFINE_INTERFACE(IDTSDataConvert)
#define Progid_DTSDataConvert		OLESTR("DTS.DataConvert")
DEFINE_DTSDataPumpGUID(CLSID_DTSDataConvert, 10010103)
DEFINE_DTSDataPumpGUID(IID_IDTSDataConvert, 10010104)
DEFINE_DTSDataPumpGUID(IID_IDTSDataDrivenQuery, 10010105)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpSpecifyLookups, 10010106)

// DTS Typelib IID's.
DEFINE_DTSDataPumpGUID(LIBID_DataPump, 10010200)
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpColumns)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpColumns, 10010201)
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpColumn)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpColumn, 10010202)
DEFINE_DTSDataPumpGUID(IID_IDTSErrorRecords, 10010203)
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpLookups)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpLookups, 10010204)
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpLookup)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpLookup, 10010205)
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpLookupVariant)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpLookupVariant, 10010206)

// Repository Storage IIDs.
DEFINE_DTSDataPumpGUID(IID_IDTSRepositoryProvider, 100202F1)
DEFINE_DTSDataPumpGUID(IID_IDTSRepositoryStorage, 100202F2)

/////////////////////////////////////////////////////////////////////////////////
// Category id of DTS custom transforms.
/////////////////////////////////////////////////////////////////////////////////
DEFINE_DTSDataPumpGUID(CATID_DTSCustomXform, 10010100)	//we will use the same id as the pump clsid.

// Consumer-supplied classes and interfaces.
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpTransform)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpTransform, 10010300)

DP_FWD_DEFINE_INTERFACE(IDTSDataPumpErrorSink)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpErrorSink, 10010301)

DP_FWD_DEFINE_INTERFACE(IDTSDataPumpProgressSink)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpProgressSink, 10010302)

DP_FWD_DEFINE_INTERFACE(IDTSDataDrivenQuerySink)
DEFINE_DTSDataPumpGUID(IID_IDTSDataDrivenQuerySink, 10010303)

// DTSDataPump-supplied COM Transform Servers
// A "Transformation Server" coclass consists of:
//		coclass TTransformServer {
//			required IDTSDataPumpTransform;
//
//			// The following are optional if the TransformServer has no custom
//			// properties requiring editing.  If it has, these are required.
//			optional <Custom OleAut properties interface>;
//			optional ISpecifyPropertyPages;
//				optional IPropertyPage;
//			optional IPersistPropertyBag;
//		}

#define Progid_DTSDataPumpTransformCopy		OLESTR("DTS.DataPumpTransformCopy")
DEFINE_DTSDataPumpGUID(CLSID_DTSDataPumpTransformCopy, 10010400)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpTransformCopy, 10010401)
// No custom properties, therefore no custom interface or IID.

#define Progid_DTSDataPumpTransformScript	OLESTR("DTS.DataPumpTransformScript")
DEFINE_DTSDataPumpGUID(CLSID_DTSDataPumpTransformScript, 10010501);
DP_FWD_DEFINE_INTERFACE(IDTSDataPumpTransformScriptProperties)
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpTransformScriptProperties, 10010502);
DEFINE_DTSDataPumpGUID(IID_IDTSDataPumpTransformScript, 10010503);

//optional interface to be implemented by custom transform providers - used by DTS UI to configure the transforms
DEFINE_DTSDataPumpGUID(IID_IDTSCustomTransformUI, 10010601);


////////////////////////////////////////////////////////////////////////////////////////
//
//	DataPump-supplied Transform variables.
//
// These are passed to IDTSDataPumpTransform::AddVariable.  They are all of type
// VT_VARIANT.  IDTSErrorRecords (interface defined below) allows any transform
// to append OLEDB Error Records to IErrorInfo for the current thread.  The name
// "DTSErrorRecords" is what is passed to IDTSDataPumpTransform::AddVariable; the
// VT_DISPATCH ma be QI'd (or cast) to IDTSErrorRecords.  This object is also
// inserted into ActiveX Scripting namespaces invoked by the Pump.  All DTS-generated
// variables are inserted into ActiveX scripting namespaces as non-global variables
// (i.e. their methods must be qualified with the object name).
//
//		Name					Type
//		----					----
//		DTSError				DTS.Error
#define wzDTSErrorRecords	OLESTR("DTSErrorRecords")

//
// These are inserted by name into the global namespace of an ActiveX scripting transform.
// View the type library to see the type definitions.  Note that the return value from the
// method (FunctionEntry) must be an integral type.
//
//		Name					Type
//		----					----
//		DTSSource				DTS.Columns
//		DTSDestination			DTS.Columns
//		(return value)			adInt or adSmallInt (DTSTransformStatus)
//

//
// These are inserted by name into the global namespace of an ActiveX scripting transform,
// as well as being passed to IDTSDataPumpTransform::AddVariable.
//
//		Name					Type
//		----					----
//		DTSLookups				DTS.Lookups
#define wzDTSLookups		OLESTR("DTSLookups")

// These are the DTS-Package-supplied global variables, if the Pump is being run from
// the Package.
#define wzDTSGlobalVariables		OLESTR("DTSGlobalVariables")

// These are special pseudo-columnnames corresponding to Lineage.  They are also
// the names of the corresponding GlobalVariables; TransformCopy will automatically
// map them over to the specified destination column.  These names must not be used
// by source column names.
#define wzDTSLineage_FullString		OLESTR("DTSLineage_Full")
#define wzDTSLineage_IntegerCRC		OLESTR("DTSLineage_Short")

////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//
//	DataPump-supplied interface definitions.
//
////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// IDTSDataPump - Primary interface to specify source and destination rowsets,
// add Transforms, and Execute() the transfer.  AddTransform will error if
// SetRowsets has not been called, and SetRowsets will error if any transforms
// have been added (because ValidateSchema has been done on them already).
// InitNew() reinitializes the IDTSDataPump object.  Execute returns E_FAIL if aborted,
// DB_E_ERRORSOCCURRED if max error count exceeded; DB_S_ERRORSOCCURRED if errors
// less than the max allowed occurred, possible provider-specific errors, or NOERROR
// if completed with no errors.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPump
DECLARE_INTERFACE_(IDTSDataPump, IUnknown)
{
	DTSDataPump_Unknown_Base()

	STDMETHOD(InitNew)(THIS) PURE;
	STDMETHOD(GetRowsets)(THIS_ 
			DP_OUT IRowset **ppSrcRowset,
			DP_OUT IRowsetChange **ppDestRowsetChange
		) PURE;
	STDMETHOD(SetRowsets)(THIS_ 
			DP_IN IRowset *pSrcRowset,							// Must be able to retrieve these rows
			DP_IN IRowsetChange *pDestRowsetChange				// Must have DBPROP_UPDATABILITY: DPBROP_UP_INSERT
		) PURE;
	STDMETHOD(SetProgressRowCount)(THIS_
			DP_IN ULONG cIn										// Interval for IDTSDataPumpProgressSink::OnIntervalComplete; default == 1000
		) PURE;
	STDMETHOD(SetMaximumErrorRowCount)(THIS_
			DP_IN ULONG cIn										// Maximum allowable error rows; default = 0 (abort on first error row).
		) PURE;
	STDMETHOD(SetFetchBufferSize)(THIS_
			DP_IN ULONG cIn										// Size of the GetNextRows HROW buffer (default = 1)
		) PURE;
	STDMETHOD(SetInsertCommitSize)(THIS_
			DP_IN ULONG cIn										// Number of successful InsertRows between "Commits", if supported by provider (default == 0; all rows in one batch).
		) PURE;
	STDMETHOD(AddTransform)(THIS_ 
			DP_IN LPCOLESTR pwzName,							// Transform name
			DP_IN LPBYTE pvUserData,							// Will be passed to Sink if event occurs on Transform.
			DP_IN LPCDTSTransformColumnsSpecification pColumns,	// Source and destination columns
			DP_IN DTSGuid ServerClsid,							// COM server ProgID or CLSID or IUnknown
			DP_IN VARIANT ServerParameters,						// Parameters to server for this transform
			DP_IN DTSTransformFlags dwFlags,					// Transformation column-validation flags
			DP_IN IStorage *pIStorage							// Pointer to persistent storage of Transform properties
		) PURE;
	STDMETHOD(AddTransformVariable)(THIS_ 
			DP_IN LPCOLESTR pwzName,							// Variable name
			DP_IN BOOL bGlobal,									// For ActiveX scripts, indicates whether this variable's
																// methods must be qualified by the object name.
			DP_IN VARIANT Variable								// Variable value; passed to and updatable by Transform
		) PURE;
	STDMETHOD(Execute)(THIS_ 
			DP_IN LPBYTE pvUserData,							// User data passed back to Sinks.
			DP_OUT ULARGE_INTEGER *puliRowsComplete,			// Total number of source rows processed (including those skipped).
			DP_OUT ULONG *pulErrorRows,							// Total number of error rows encountered.
			DP_OUT LPDTSExecuteStatus pExecStatus				// Pump return status.
		) PURE;
	STDMETHOD(SetFirstRow)(THIS_
			DP_IN ULARGE_INTEGER cIn							// First source row to copy. Default is 1 (first row).
		) PURE;
	STDMETHOD(SetLastRow)(THIS_
			DP_IN ULARGE_INTEGER cIn							// Last source row to copy. Default is 0 (copy all rows).
		) PURE;
};

///////////////////////////////////////
// IDTSDataDrivenQuery - Allows specification of individual queries instead
// of simple Insert at the Destination.  QI'd from IDTSDataPump.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataDrivenQuery
DECLARE_INTERFACE_(IDTSDataDrivenQuery, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// The following four pairs of properties and methods should be called in the
	// order listed.

	// Specify and retrieve the source rowset from which data will be read.
	STDMETHOD(SetSourceRowset)(THIS_ 
			DP_IN IRowset *pSrcRowset
		) PURE;
	STDMETHOD(GetSourceRowset)(THIS_ 
			DP_OUT IRowset **ppSrcRowset
		) PURE;

	// Specify and retrieve the destination session and column schema; this defines how the
	// parameters to the queries will be bound.  Specifying the schema is done in one of two ways:
	//	- If cColumnDescs is 0, then rgColumnDescs is ignored and pDestConnection must
	//	  be a Rowset.  Rowset information will be retrieved, but the Rowset itself will not
	//	  be retained.  The Session will be retrieved from the Rowset and retained.
	//	- If cColumnDescs is not 0, then rgColumnDescs must not be NULL and pDestConnection
	//	  must be a Session.  The destination column definitions are created from the DBCOLUMNDESCs.
	//
	STDMETHOD(SetDestinationInfo)(THIS_
			DP_IN IUnknown *pDestConnection,
			DP_IN ULONG cColumnDescs,
			DP_IN DBCOLUMNDESC rgColumnDescs[]
		) PURE;
	// pcColumns, prgInfo, and ppStringsBuffer are allocated as in IColumnsInfo::GetColumnInfo.
	STDMETHOD(GetDestinationInfo)(THIS_
			DP_IN REFIID riidSession, 
			DP_OUT IUnknown **ppIUnkSession,
			DP_OUT ULONG *pcColumns,
			DP_OUT DBCOLUMNINFO **prgInfo,
			DP_OUT OLECHAR **ppStringsBuffer
		) PURE;

	// Specify and retrieve the destination queries and their column mappings to parameters.
	// Unused queries may be NULL, in which case a Transform return status of DTSTransformStat_*Query
	// indicating an unset query will result in an error.
	STDMETHOD(SetDestinationQueries)(THIS_ 
			DP_IN LPCDTSTransformQuerySpecification pInsertQuerySpec,
			DP_IN LPCDTSTransformQuerySpecification pUpdateQuerySpec,
			DP_IN LPCDTSTransformQuerySpecification pDeleteQuerySpec,
			DP_IN LPCDTSTransformQuerySpecification pUserQuerySpec
		) PURE;
	// Each pointer is a single CoTaskMemAlloc containing space for the base QuerySpecification structure,
	// the array of column info, and the string buffer.  Internal pointers are based (with alignment)
	// according to this allocated space.
	STDMETHOD(GetDestinationQueries)(THIS_ 
			DP_OUT LPDTSTransformQuerySpecification *ppInsertQuerySpec,
			DP_OUT LPDTSTransformQuerySpecification *ppUpdateQuerySpec,
			DP_OUT LPDTSTransformQuerySpecification *ppDeleteQuerySpec,
			DP_OUT LPDTSTransformQuerySpecification *ppUserQuerySpec
		) PURE;
};

///////////////////////////////////////
// IDTSDataPumpLookups - Allows specification of Lookups for TransformServer use.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpSpecifyLookups
DECLARE_INTERFACE_(IDTSDataPumpSpecifyLookups, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// Specify and retrieve the lookup specifications for this DataPump instance.
	STDMETHOD(SetLookups)(THIS_ 
			DP_IN ULONG cLookups,
			DP_IN LPCDTSTransformLookupSpecification pLookups
		) PURE;
	// The pointer is a single CoTaskMemAlloc containing space for the base LookupSpecification structure
	// and the string buffer.  Internal pointers are based (with alignment) according to this allocated space.
	// pIUnkSession is AddRef'd and must be released.
	STDMETHOD(GetLookups)(THIS_ 
			DP_IN ULONG *pcLookups,
			DP_IN LPDTSTransformLookupSpecification *ppLookups
		) PURE;
};

///////////////////////////////////////
// IDTSDataConvert - The DTS data-conversion interface.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataConvert
DECLARE_INTERFACE_(IDTSDataConvert, IDataConvert)
{
	DTSDataPump_Unknown_Base()

	//////////////////////////////////////////////////////
	// IDataConvert interface members (msdadc.h required).
	//////////////////////////////////////////////////////

	// Copies or converts data from one DBTYPE to another.  If wDstType includes DBTYPE_BYREF,
	// it must be a variable-length type (DBTYPE_((W)STR|BYTES)) or this method will error.
	// Otherwise, for all DBTYPE_BYREF destination conversions, this method CoTaskMemAlloc(s)
	// the destination data pointer, and it is the caller's responsibility to CoTaskMemFree it.
	// This method should not be used to place data into the DataPump's destination binding;
	// instead, use the ConvertToBinding method.
	STDMETHOD(DataConvert)( 
			DP_IN DBTYPE wSrcType,
			DP_IN DBTYPE wDstType,
			DP_IN ULONG cbSrcLength,
			DP_INOUT ULONG *pcbDstLength,
			DP_IN void *pSrc,
			DP_OUT void *pDst,
			DP_IN ULONG cbDstMaxLength,
			DP_IN DBSTATUS dbsSrcStatus,
			DP_OUT DBSTATUS *pdbsStatus,
			DP_IN BYTE bPrecision,
			DP_IN BYTE bScale,
			DP_IN DBDATACONVERT dwFlags
		) PURE;

	// Determines if two types are potentially compatible.  See GetConvertFlags
	// for more detailed information about what the conversion may encounter.
	STDMETHOD(CanConvert)( 
			DP_IN DBTYPE wSrcType,
			DP_IN DBTYPE wDstType
		) PURE;

	// Returns the required conversion size in bytes.  May base this on pcbSrcLength
	// and/or pSrc, if supplied, to get per-data-item information.
	//
	// DBTYPE_BSTR is considered a fixed type; its binding length is sizeof(BSTR).
	// To determine the length necessary to pre-allocate a BSTR, pass in DBTYPE_STR
	// for the destination type - for this type, character count == byte count.
	// Alternatively, use WSTR and divide the return by sizeof(WCHAR).
	//
	STDMETHOD(GetConversionSize)( 
			DP_IN DBTYPE wSrcType,
			DP_IN DBTYPE wDstType,
			DP_IN ULONG *pcbSrcLength,
			DP_OUT ULONG *pcbDstLength,
			DP_IN void *pSrc
		) PURE;

	//////////////////////////////////////////////////////
	// DTS extensions.
	//////////////////////////////////////////////////////

	// This method first calls CanConvert() to determine if the conversion can succeed at all
	// given the source and destination datatypes, and if so, returns extended information about
	// how (or if) the conversion can proceed after that.
	// It uses the following fields for source and destination (S and D):
	//	DBCOLUMNINFO - validates all conversion info between columns.
	//		dwFlags					S,D
	//		ulColumnSize			S,D
	//		wType					S,D
	//		bPrecision				S,D
	//		bScale					S,D
	//	Fields other than dwFlags and wType can be zero'd and the output ConvertFlags
	//	tested for the Unsupported bit if length validation is not required.
	// Note that this does not set a flag for nontext <-> text if the text length is
	// sufficient to accommodate it; this is because all such conversions should be valid
	// If this level of exactness is required, simply compare the datatypes for equality.
	STDMETHOD(GetConvertFlags)(
			DP_IN const DBCOLUMNINFO *pSrcColumnInfo,		// Source column metadata
			DP_IN const DBCOLUMNINFO *pDestColumnInfo,		// Destination column metadata
			DP_OUT DTSConvertFlags *pConvertFlags			// Output conversion flags
		) PURE;

	// This method allows the Transform Server to convert source data (which may come from
	// the source binding directly, as in the comment examples, or from ad-hoc source data).
	// It uses the following fields in the destination binding (S is fields that are used
	// from a source binding if that is how the source data is stored):
	//	DBBINDING:
	//		obValue					S,D		-- must be bound
	//		obLength				S,D		-- must be bound
	//		obStatus				S,D		-- must be bound
	//		dwPart					S,D		-- must include length, value, status
	//		cbMaxLen				D
	//		wType					S,D
	//		bPrecision				D
	//		bScale					D
	//
	// The destination data is set according to eTransformFlags and pDestBind->dwMemOwner, which
	// is handled as follows:
	//
	// DBMEMOWNER_CLIENTOWNED: normal conversion is done; data is copied from source to destination,
	//		converted as needed, and allocations are done as needed.  Specifically:
	//			BSTR data is deep-copied
	//			BYREF destination data is copied into a CoTaskMemAlloc()'d pointer.
	//			IUnknown and IDispatch pointers are AddRef()'d.
	//		The destination binding data must always be free'd.  The foregoing lists what is freed
	//		(or Release()'d) by IDTSDataConvert::ClearBindingData.
	//
	// DBMEMOWNER_PROVIDEROWNED:  Conversion will attempt to shallow-copy data, avoiding allocations.
	//		This requires that the source and destination datatypes be identical (except for DBTYPE_BYREF).
	//		This is intended as a performance enhancement and requires that the source data remain stable
	//		for the lifetime of the Destination binding (such as while being inserted via the DataPump).
	//		It handles only the following cases:
	//			If the destination type includes DBTYPE_BYREF	// it must therefore be ((W)STR|BYTES)
	//				*pvDestData = pvSrcData (or *pvSrcData if source type is BYREF)
	//				StringTruncation is performed by adjusting destination datalength
	//			else if destination type is BSTR
	//				*pvDestData = *pvSrcData (or **pvSrcData if source type is BYREF)
	//				StringTruncation is NOT checked here as this is a fixed-length datatype
	//			else 
	//				Normal conversion is done, including:
	//					AddRefs of IDispatch/IUnknown pointers
	//					VariantCopy (OLEDB behaviour does not allow PROVIDEROWNED Variant binding).
	// DBMEMOWNER_PROVIDEROWNED binding data will not be freed by IDTSDataConvert::ClearBindingData.
	// If a custom allocator is used for BYREF destination data, then it must be freed by a corresponding
	// custom deallocator, rather than by ClearBindingData.  Therefore, it should be bound ProviderOwned;
	// the pointer will be shallow-copied into the binding by IDTSDataConvert::ConvertToBinding.
	//
	STDMETHOD(ConvertToBinding)(
			DP_IN DBTYPE wSrcType,							// Source datatype:  e.g. pSrcBind->wType
			DP_IN ULONG cbSrcLength,						// Source data length:  e.g. *(reinterpret_cast<ULONG *>(pSrcColumnInfo->pvRowData + pSrcBind->obLength));
			DP_IN DBSTATUS dbsSrcStatus,					// Source data status:  e.g. *(reinterpret_cast<DBSTATUS *>(pSrcColumnInfo->pvRowData + pSrcBind->obStatus));
			DP_IN const BYTE *pvSrcColData,					// Source column data: e.g. pSrcColumnInfo->pvRowData + pSrcBind->obValue;
			DP_IN const DBBINDING *pDestBind,				// Dest binding info
			DP_IN BYTE *pvDestRowData,						// Dest row data; NOT obValue-offset as the Binding will reference it 3 ways (obLength, obValue, obStatus)
			DP_IN DBCOLUMNFLAGS dwDestColumnFlags,			// Dest flags such as nullability
			DP_IN ULONG ulDestColumnSize,					// If nonzero and Dest is BYREF, tested for String Truncation
			DP_IN DTSTransformFlags eTransformFlags			// Transformation flags.  Currently considered:
															//		DTSTransformFlag_AllowStringTruncation
															//		DTSTransformFlag_ForceConvert as it applies to foregoing
		) PURE;

	// This method frees any CLIENTOWNED allocations in the Binding, as discussed in ConvertToBinding.
	// This method always sets length to 0 and status to DBSTATUS_S_ISNULL, and can zeroinit if specified.
	STDMETHOD(ClearBindingData)(
			DP_IN const DBBINDING *pDestBind,				// Dest binding info
			DP_IN BYTE *pvDestRowData,						// Dest row data; NOT obValue-offset as the Binding will reference it 3 ways (obLength, obValue, obStatus)
			DP_IN BOOL bZeroInit							// If TRUE, zero's the data value
		) PURE;
};

///////////////////////////////////////
// IDTSErrorRecords - Allows the caller to append OLEDB Error Records to the current
// thread's IErrorInfo.  The Error Lookup Service is CLSID_DTSErrorLookup.
// This interface is derived from IDispatch and may be used in ActiveX Scripts as
// well as from C/C++.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSErrorRecords
DECLARE_INTERFACE_(IDTSErrorRecords, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSErrorRecords)

    STDMETHOD(Clear)(THIS) PURE;
	STDMETHOD(Add)(THIS_ DP_IN long Number,
				DP_IN long NativeError,
				DP_IN BSTR Description,
				DP_IN BSTR Source,
				DP_IN BSTR Helpfile,
				DP_IN long Helpid
			) PURE;
};

///////////////////////////////////////
// IDTSDataPumpColumns - Columns collection as exposed to AxScript.
// We expose DTSSource and DTSDestination collections.
// This interface is derived from IDispatch and may be used in ActiveX Scripts as
// well as from C/C++.  This is identical to the ADO.Field interface.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpColumns
DECLARE_INTERFACE_(IDTSDataPumpColumns, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSDataPumpColumns)

	STDMETHOD(Item)(THIS_ DP_IN VARIANT Index, DP_OUT IDTSDataPumpColumn **pRetVal) PURE;
    STDMETHOD(get__NewEnum)(THIS_ DP_OUT IUnknown **ppEnum) PURE;
    STDMETHOD(get_Count)(THIS_ DP_OUT long *pRetVal) PURE;
};

///////////////////////////////////////
// IDTSDataPumpColumn - Column object as exposed to AxScript.
// These objects make up the DTSSource and DTSDestination collections.
// They provide access to the column value and its metadata
// This interface is derived from IDispatch and may be used in ActiveX Scripts as
// well as from C/C++.  This is identical to the ADO.Field interface.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpColumn
DECLARE_INTERFACE_(IDTSDataPumpColumn, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSDataPumpColumn)

    STDMETHOD(get_Value)(THIS_ DP_OUT VARIANT *pRetVal) PURE;
    STDMETHOD(put_Value)(THIS_ DP_IN VARIANT NewValue) PURE;
    STDMETHOD(get_ActualSize)(THIS_ DP_OUT long  *pl) PURE;
    STDMETHOD(get_Attributes)(THIS_ DP_OUT long  *pl) PURE;
    STDMETHOD(get_DefinedSize)(THIS_ DP_OUT long  *pl) PURE;
    STDMETHOD(get_Name)(THIS_ DP_OUT BSTR  *pbstr) PURE;
    STDMETHOD(get_Type)(THIS_ DP_OUT long  *pDataType) PURE;
    STDMETHOD(get_Precision)(THIS_ DP_OUT BYTE  *pbPrecision) PURE;
    STDMETHOD(get_NumericScale)(THIS_ DP_OUT BYTE  *pbNumericScale) PURE;
    STDMETHOD(get_OriginalValue)(THIS_ DP_OUT VARIANT  *pvar) PURE;
    STDMETHOD(get_UnderlyingValue)(THIS_ DP_OUT VARIANT  *pvar) PURE;
    STDMETHOD(AppendChunk)(THIS_ DP_IN VARIANT Data) PURE;
    STDMETHOD(GetChunk)(THIS_ DP_IN long Length, DP_OUT VARIANT  *pvar) PURE;
};

///////////////////////////////////////
// IDTSDataPumpLookups - Lookups collection as exposed to AxScript.
// We expose DTSLookups as a collection.
// This interface is derived from IDispatch and may be used in ActiveX Scripts as
// well as from C/C++.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpLookups
DECLARE_INTERFACE_(IDTSDataPumpLookups, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSDataPumpLookups)

	STDMETHOD(Item)(THIS_ DP_IN VARIANT Index, DP_OUT IDTSDataPumpLookup **pRetVal) PURE;
    STDMETHOD(Get_NewEnum)(THIS_ DP_OUT IUnknown **ppEnum) PURE;
    STDMETHOD(GetCount)(THIS_ DP_OUT long *pRetVal) PURE;
};

///////////////////////////////////////
// IDTSDataPumpLookup - Lookup object as exposed to AxScript.
// These objects make up the DTSLookups collection.
// This interface is derived from IDispatch and may be used in ActiveX Scripts as
// well as from C/C++.  The KeyValues input parameter to the methods is a SafeArray
// of Variant, using the vararg attribute on the methods, for best use in ActiveX
// scripts.  The return value is a variant (if single-valued) or an array of variants
// (if multi-valued) corresponding to the sequence of columns in the single output
// row resulting from execution of the query.  If multiple rows are returned, only
// the first is returned in the output variant.  LastRowCount is used in case an
// app wants to assert that only one row was returned.
///////////////////////////////////////

// This form is understood by scripting languages to take a variable number of
// arguments in the key values specification.  It can be used from C++ as well.
#undef INTERFACE
#define INTERFACE IDTSDataPumpLookup
DECLARE_INTERFACE_(IDTSDataPumpLookup, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSDataPumpLookup)

    STDMETHOD(get_Name)(THIS_ DP_OUT BSTR  *pbstr) PURE;
	STDMETHOD(get_LastRowCount)(THIS_ LONG *pRetVal) PURE;
    STDMETHOD(Execute)(THIS_ DP_IN SAFEARRAY * KeyValues, DP_OUT VARIANT *pRetVal) PURE;
    STDMETHOD(AddToCache)(THIS_ DP_IN VARIANT DataValues, DP_IN SAFEARRAY * KeyValues) PURE;
    STDMETHOD(RemoveFromCache)(THIS_ DP_IN SAFEARRAY * KeyValues) PURE;
};

// This is a form of the interface which takes a single Variant, more convenient
// for C++ programs which know they'll only have a single key column.  The variant
// may be a single value or may itself contain a safearray.
#undef INTERFACE
#define INTERFACE IDTSDataPumpLookupVariant
DECLARE_INTERFACE_(IDTSDataPumpLookupVariant, IUnknown)
{
    STDMETHOD(Execute)(THIS_ DP_IN VARIANT KeyValues, DP_OUT VARIANT *pRetVal) PURE;
    STDMETHOD(AddToCache)(THIS_ DP_IN VARIANT DataValues, DP_IN VARIANT KeyValues) PURE;
    STDMETHOD(RemoveFromCache)(THIS_ DP_IN VARIANT KeyValues) PURE;
};

////////////////////////////////////////////////////////////////////////////////////////
//
//	Pump-supplied Transform custom-property interfaces.
//
////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// IDTSDataPumpTransformScriptProperties - Sets custom properties for the
// ActiveX scripting transformation server.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpTransformScriptProperties
DECLARE_INTERFACE_(IDTSDataPumpTransformScriptProperties, DTSDataPump_IDispatch)
{
	DTSDataPump_Dispatch_Base(IDTSDataPumpTransformScriptProperties)

	STDMETHOD(GetText)(THIS_ BSTR DP_OUT *pRetVal) PURE;
	STDMETHOD(SetText)(THIS_ BSTR DP_IN NewValue) PURE;
	STDMETHOD(GetLanguage)(THIS_ BSTR DP_OUT *pRetVal) PURE;
	STDMETHOD(SetLanguage)(THIS_ BSTR DP_IN NewValue) PURE;
	STDMETHOD(GetFunctionEntry)(THIS_ BSTR DP_OUT *pRetVal) PURE;
	STDMETHOD(SetFunctionEntry)(THIS_ BSTR DP_IN NewValue) PURE;
};

////////////////////////////////////////////////////////////////////////////////////////
//
//	Consumer-supplied interface definitions.
//
////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// IDTSDataPumpTransform - Required interface of the "COM Server" instantiated by ServerClsid
// passed to IDTSDataPump::AddTransform.  This interface is retrieved and its methods called
// by the Pump to perform individual transforms. 
//
// ServerParameters allows the DataPump Consumer to instantiate a single instance of an
// IDTSDataPumpTransform implementation and pass it to multiple IDTSDataPump::AddTransform calls.
// This is only useful for custom Transform Servers (the DTS-supplied ones ignore this), and may be
// helpful for internal summations etc.  If this is done, the TransformServer should track this in its
// pvTransformServerData to optimize operations such as AddVariable, On(Row|Transform)Complete, etc.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpTransform
DECLARE_INTERFACE_(IDTSDataPumpTransform, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// Allows the TransformServer to initialize its state for the current Transform.  The output
	// LPBYTE is passed to all subsequent methods, so a single TransformServer instance may be
	// used to implement multiple separate transforms.
	STDMETHOD(Initialize)(THIS_
			DP_IN LPCOLESTR pwzName,							// Transform name
			DP_IN VARIANT ServerParameters,						// Parameters to server for this transform
			DP_OUT LPBYTE *ppvTransformServerData				// Transform server state data.
		) PURE;

	// Validates the schema that will be transformed.  Allows the TransformServer to specify
	// certain modifications to the default binding modes, such as for BLOBs.  The default 
	// p(Src|Dest)ColumnInfo->ppDTSColBinding[ii].eBindModes intialized by the DataPump are:
	//
	// All BLOBs must be ClientOwned by OLEDB spec, so Source and Destination BLOBs are always
	// DTSBindMode_Byref_ClientOwned.
	// 
	// Source:  For efficiency, nonBLOB ((W)STR|BYTES) binding defaults to _Byref_ProviderOwned
	// to avoid unnecessary copying.  BSTR defaults to ProviderOwned.  All other types must be
	// non-Byref ClientOwned by OLEDB spec and behaviour.
	//
	// Destination:  Because the destination data is likely to be the result of a transformation,
	// destination binding always defaults to ClientOwned for all datatypes.  All nonBLOB types are
	// allocated Inline; this includes ((W)STR|BYTES), to minimize per-row (re)allocation overhead.
	//
	// A Transformation which simply passes-thru nonBLOB ((W)STR|BYTES)s or BSTRs from the Source
	// IRowset to the destination (and doesn't use the TransformCopy server, which is supplied for
	// this purpose) should override this to ProviderOwned to avoid unnecessary (re)allocations.
	//
	STDMETHOD(ValidateSchema)(THIS_
			DP_IN LPBYTE pvTransformServerData,					// Transform server state data.
			DP_INOUT LPCDTSTransformColumnInfo pSrcColumnInfo, 	// Source columns and rowdata
			DP_INOUT LPCDTSTransformColumnInfo pDestColumnInfo, // Dest columns and rowdata
			DP_IN IDTSDataConvert *pIDTSDataConvert,			// Pointer to the data conversion interface
			DP_IN DTSTransformFlags eTransformFlags				// Input Flags for Transformation validation and execution
		) PURE;

	// Adds a variable to the TransformServer's execution context.  This is always called once before
	// ValidateSchema, in order to add the IDTSErrorRecords object.
	STDMETHOD(AddVariable)(THIS_ 
			DP_IN LPBYTE pvTransformServerData,					// Transform server state data.
			DP_IN LPCOLESTR pwzName,							// Variable name
			DP_IN BOOL bGlobal,									// For ActiveX scripts, indicates whether this variable's
																// methods must be qualified by the object name.
			DP_IN VARIANT Variable								// Variable value; passed to and updatable by Transform
		) PURE;

	// Executes the transformation for a single row.  This method should return a SUCCEED
	// hr except in catastrophic failure; a FAILED hr here will abort the Pump.  "Normal"
	// errors such as data violations should be handled as a returned pTransformStatus,
	// which will cause IDTSDataPumpErrorSink::OnTransformError to be called.
	//
	// Because some providers may have restrictions on the number of Storage Objects which
	// may be open, Execute() should release any Blob Storage Objects in the source upon
	// completion, rather than waiting for OnRowComplete.  The DataPump handles refcounting
	// for multiple transforms of its buffered Source objects.  If the Blob column is
	// buffered by the DataPump or the Transform has knowledge of the Source Provider, it
	// can defer Release()ing the Source Storage Object until OnRowComplete.  Note that
	// returning DTSTransformStat_SkipFetch (and therefore not releasing the Source Storage
	// Object) may require buffering of the source Blob data.
	STDMETHOD(Execute)(THIS_
			DP_IN LPBYTE pvTransformServerData,					// Transform server state data.
			DP_IN LPCDTSTransformColumnInfo pSrcColumnInfo, 	// Source columns and rowdata
			DP_INOUT LPDTSTransformColumnInfo pDestColumnInfo, 	// Dest columns and rowdata
			DP_IN IDTSDataConvert *pIDTSDataConvert,			// Pointer to the data conversion interface
			DP_OUT LPDTSTransformStatus peTransformStatus		// Result of transform
		) PURE;

	// After a successful Fetch, the pump calls Execute and then attempts to insert the row into the
	// destination IRowsetChange (if one is specified).  OnRowComplete is called for every successful
	// Fetch (whether the Execute() and InsertRow succeeded or failed); this allows the TransformServer
	// to free per-row allocations and CLIENTOWNED data in both source and destination rows (such as
	// by calling pIDTSDataConvert->ClearBindingData).  A FAILED return from OnRowComplete aborts the Pump.
	// hrInsert indicates whether the IRowsetChange::InsertRow() succeeded; eTransformStatus indicates
	// if errors occurred such that InsertRow was not called.
	//
	// Note that OLEDB specifies that IRowsetChange::InsertRow() Releases any contained Storage Objects
	// in the row (but not other types of "allocations"), so the Transform server must be careful not to 
	// call pIDTSDataConvert->ClearBindingData on an already final-released Storage Object (in the event
	// that InsertRow is not called due to a Transform returning an error, the DataPump will release any
	// Storage Objects in the dest row for any Transforms for which Execute was called prior to the erroring
	// Transform, to present a consistent refcounting interface to TransformServers:  If Execute() returned
	// a non-NULL Storage Object in the row, it will be released once before OnRowComplete is called).
	//
	STDMETHOD(OnRowComplete)(THIS_
			DP_IN LPBYTE pvTransformServerData,					// Transform server state data.
			DP_INOUT LPDTSTransformColumnInfo pSrcColumnInfo,	// Source columns and rowdata
			DP_INOUT LPDTSTransformColumnInfo pDestColumnInfo, 	// Dest columns and rowdata
			DP_IN IDTSDataConvert *pIDTSDataConvert,			// Pointer to the data conversion interface
			DP_IN DTSTransformStatus eTransformStatus,			// Result of Execute()
			DP_IN HRESULT hrInsert								// Result of IRowsetChange::InsertRow()
		) PURE;

	// After all rows have been transformed (or the pump has been shutdown due to errors),
	// OnTransformComplete is called to give the TransformServer a chance to clean up all
	// allocations made for the Transform.  OnTransformComplete is called only if ValidateSchema
	// returned successfully.
	STDMETHOD(OnTransformComplete)(THIS_
			DP_IN LPBYTE pvTransformServerData,					// Transform server state data.
			DP_INOUT LPDTSTransformColumnInfo pSrcColumnInfo,	// Source columns and rowdata
			DP_INOUT LPDTSTransformColumnInfo pDestColumnInfo, 	// Dest columns and rowdata
			DP_IN IDTSDataConvert *pIDTSDataConvert				// Pointer to the data conversion interface
		) PURE;
};


///////////////////////////////////////
// IDTSDataPumpErrorSink - Specifies pump error handler sink.  Only one method will
// be called for any row, and the method called indicates where the error was encountered:
// reading from source, transforming, or writing to destination.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpErrorSink
DECLARE_INTERFACE_(IDTSDataPumpErrorSink, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// An error occurred on Binding in CreateAccessor.  This is only useful for designing custom Transform
	// Servers, primarily for diagnosing Blob difficulties.
	STDMETHOD(OnBindingError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN HRESULT hrError,						// The errorcode from CreateAccessor; for Destination if pDestinationRow, else for Source.
			DP_IN LPCDTSTransformColumnInfo pSourceRow,	// Pointer to the source row and binding info.
			DP_IN const DBBINDSTATUS *pSourceDBBindStatus,		// Pointer to source binding status returns.
			DP_IN LPCDTSTransformColumnInfo pDestinationRow,	// Pointer to the destination row and binding info; NULL if from Source Binding error.
			DP_IN const DBBINDSTATUS *pDestinationDBBindStatus	// Pointer to destination binding status returns; NULL if from Source Binding error.
		) PURE;

	// An error occurred during GetNextRows or GetData.
	STDMETHOD(OnSourceError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN LPDTSTransformColumnInfo pSourceRow,	// Pointer to the source row and binding info; NULL if GetNextRows or GetData failed.
			DP_IN HRESULT hrError,						// The errorcode from the OLEDB or system call.
			DP_IN ULARGE_INTEGER uliRow,				// Number of the row failing.
			DP_IN ULONG cErrors,						// Number of error rows encountered so far (including this one).
			DP_OUT BOOL *pbAbort						// Set TRUE by Sink if this error should abort IDTSDataPump::Execute.
														// Otherwise, Execute() continues until MaximumErrorRowCount is exceeded.
		) PURE;

	// An error occurred on one or more Transforms.
	STDMETHOD(OnTransformError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN LPCOLESTR pwzName,					// Transform name
			DP_IN LPBYTE pvTransformUserData,			// User data pointer passed to IDTSDataPump::AddTransform
														// in LPCDTSTransformColumnsSpecification parameter.
			DP_IN IDTSDataPumpTransform *pTransformServer,	// The transform server raising the error; can be QI'd to custom interface for more info.
			DP_IN LPDTSTransformColumnInfo pSourceRow,	// Pointer to the source row and binding info.
			DP_IN DTSTransformStatus TransformStatus,	// Returned status code from the transformation.
			DP_IN HRESULT hrTransform,					// The HRESULT returned from DTSDataPumpTransform::Execute.
			DP_IN ULARGE_INTEGER uliRow,				// Number of the row failing.
			DP_IN ULONG cErrors,						// Number of error rows encountered so far (including this one).
			DP_OUT BOOL *pbAbort						// Set TRUE by Sink if this error should abort IDTSDataPump::Execute.
														// Otherwise, Execute() continues until MaximumErrorRowCount is exceeded.
		) PURE;

	// An error occurred during InsertRow.
	STDMETHOD(OnDestinationError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN LPDTSTransformColumnInfo pSourceRow,	// Pointer to the source row.
			DP_IN LPDTSTransformColumnInfo pDestinationRow,	// Pointer to the destination row and binding info; NULL if prior to transform execution.
			DP_IN HRESULT hrError,						// The errorcode from the OLEDB or system call.
			DP_IN ULARGE_INTEGER uliRow,				// Number of the row failing.
			DP_IN ULONG cErrors,						// Number of error rows encountered so far (including this one).
			DP_OUT BOOL *pbAbort						// Set TRUE by Sink if this error should abort IDTSDataPump::Execute.
														// Otherwise, Execute() continues until MaximumErrorRowCount is exceeded.
		) PURE;
};

///////////////////////////////////////
// IDTSDataDrivenQuerySink - Specifies event sink for Data Driven Queries.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataDrivenQuerySink
DECLARE_INTERFACE_(IDTSDataDrivenQuerySink, IUnknown)
{
	DTSDataPump_Unknown_Base()

	STDMETHOD(OnDDQBindingError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN DTSTransformStatus fQueryType,		// Insert, Update, Delete, or User Query.
			DP_IN HRESULT hrError,						// The errorcode from CreateAccessor for Command parameters
			DP_IN LPCDTSTransformColumnInfo pDestinationRow,	// Pointer to the destination row and transform binding info
			DP_IN ULONG cParameterColumns,				// Number of parameter columns
			DP_IN const DBBINDING *pParameterDBBinding,	// Pointer to destination parameter bindings
			DP_IN const DBBINDSTATUS *pParameterDBBindStatus	// Pointer to destination parameter binding status returns
		) PURE;

	STDMETHOD(OnDDQCommandError)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN DTSTransformStatus fQueryType,		// Insert, Update, Delete, or User Query.
			DP_IN LPDTSTransformColumnInfo pSourceRow,	// Pointer to the source row.
			DP_IN LPDTSTransformColumnInfo pDestinationRow,	// Pointer to the destination row and binding info.
			DP_IN HRESULT hrError,						// The errorcode from the OLEDB or system call.
			DP_IN ULARGE_INTEGER uliRow,				// Number of the row failing.
			DP_IN ULONG cErrors,						// Number of error rows encountered so far (including this one).
			DP_OUT BOOL *pbAbort						// Set TRUE by Sink if this error should abort IDTSDataPump::Execute.
														// Otherwise, Execute() continues until MaximumErrorRowCount is exceeded.
		) PURE;

	STDMETHOD(OnDDQCommandComplete)(THIS_ 
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN DTSTransformStatus fQueryType,		// Insert, Update, Delete, or User Query.
			DP_IN LPDTSTransformColumnInfo pSourceRow,	// Pointer to the source row.
			DP_IN LPDTSTransformColumnInfo pDestinationRow,	// Pointer to the destination row and binding info.
			DP_IN LONG cDestinationRowsAffected,		// Rows affected by Command; -1 if provider unable to determine.
			DP_IN ULARGE_INTEGER uliRow					// Number of the source row for which the Query was Execute()d.
		) PURE;
};

///////////////////////////////////////
// IDTSCustomTransformUI - 
// optional interface to be implemented by custom transform providers - used by DTS UI to configure the transforms
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSCustomTransformUI
DECLARE_INTERFACE_(IDTSCustomTransformUI, IUnknown)
{
	DTSDataPump_Unknown_Base()

	STDMETHOD(Initialize)(THIS_ DP_IN LPUNKNOWN pDTSPkgTransformObject) PURE;
	STDMETHOD(New)(THIS_ DP_IN long hwndParent) PURE;
	STDMETHOD(Edit)(THIS_ DP_IN long hwndParent) PURE;
	STDMETHOD(Delete)(THIS_ DP_IN long hwndParent) PURE;
	STDMETHOD(Help)(THIS_ DP_IN long hwndParent) PURE;
};

///////////////////////////////////////
// IDTSDataPumpProgressSink - Progress indicator event sink.
///////////////////////////////////////

#undef INTERFACE
#define INTERFACE IDTSDataPumpProgressSink
DECLARE_INTERFACE_(IDTSDataPumpProgressSink, IUnknown)
{
	DTSDataPump_Unknown_Base()

	STDMETHOD(OnIntervalComplete)(THIS_
			DP_IN LPBYTE pvExecUserData,				// User data pointer passed to IDTSDataPump::Execute
			DP_IN ULARGE_INTEGER uliRowsComplete,		// Total Source Rows processed at this interval (includes those skipped)
			DP_OUT BOOL *pbAbort						// Set TRUE by Sink to abort IDTSDataPump::Execute.
		) PURE;
};

/////////////////////////////////////////////////////////////////////////////////
// DTS Repository-support interfaces.
/////////////////////////////////////////////////////////////////////////////////

// Repository interfaces and definitions are shared between DTSDataPump and DTSPackage.

#ifdef OBJID_DtsTransformationTask

// A covering utility interface around a Repository object, provided by the DTS Package
// when requesting repository storage from a custom Task or Transformation.  This interface
// is passed to IDTSRepositoryStorage methods during DTSPackage.SaveToRepository.
#undef INTERFACE
#define INTERFACE IDTSRepositoryProvider
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// Return a reference to the Repository object.
	STDMETHOD(GetRepository)(THIS_
			DP_OUT IRepository **ppIRepository				// The repository object.
		) PURE;

	// Creates an object and sets its name.
	STDMETHOD(CreateObject)(THIS_
			DP_IN LPCOLESTR wzObjidClass					// Repository class to create
			, DP_IN LPCOLESTR wzObjidInstance				// class instance (object) id, or NULL
			, DP_IN LPCOLESTR wzInstanceName				// class instance (object) name, or NULL
			, DP_OUT IRepositoryObject **ppRepositoryObject	// created object
		) PURE;

	// Finds an IDbmConnection object for a DTS connection in the associated DTS Package.
	STDMETHOD(FindConnection)(THIS_
			DP_IN LPCOLESTR wzName							// DTSConnection.Name
			, DP_IN long lID								// DTSConnection.ID
			, DP_OUT IRepositoryDispatch **ppIDbmConnection	// output object
		) PURE;

	// When a custom Task or Transformation references a table or view, it should create a
	// relationship to that table or view if the appropriate datasource and catalog's metadata
	// has been scanned (by dbscanner) into the Repository.  To do so, the IDTSRepositoryStorage
	// implementation should call FindScannedObject, passing the name of the table or view
	// to be referenced.  Note that this name should be qualified as necessary to resolve
	// ambiguity, if multi-part names are supported by the connection provider.  This qualification
	// must be done according to DBPROP_CATALOGUSAGE and DBPROP_SCHEMAUSAGE, and the following
	// DBLITERALs:
	//		DBLITERAL_QUOTE_PREFIX
	//		DBLITERAL_QUOTE_SUFFIX
	//		DBLITERAL_CATALOG_SEPARATOR
	//		DBLITERAL_SCHEMA_SEPARATOR
	//
	// DTSPackage.SaveToRepository will search for a scanned catalog contained within any
	// IDbmDataSource with IsPublic TRUE.  A table or view resides in the repository as follows:
	//		Root(IUmlPackage).Elements
	//			... possibly some intervening level of package or system...
	//			IDbmDataSource(IUmlPackage).Elements
	//				IDbmDeployedCatalog(IUmlPackage).Elements
	//					IDbmSchema(IUmlPackage).Elements
	//						IDbmDeployedTable, IDbmDeployedView
	// The catalog in which wzObjectName is resolved is determined by the first name found in
	// the following order:
	//		A catalog name parsed from wzObjectName
	//		DBPROP_CURRENTCATALOG after IDTSConnection.OpenConnection; this may be set by either of:
	//			IDTSConnection.DefaultCatalog
	//			IDTSConnection.ConnectionProperties(DBPROP_INIT_CATALOG)
	//		If DBPROP_CURRENTCATALOG is not supported, a placeholder catalog is 
	//			created by the scanner; this catalog is used to resolve scanned object references.
	//		
	// The schema in which wzObjectName is resolved is determined by the first name found in
	// the following order:
	//		A schema name parsed from wzObjectName
	//		IDTSConnection.UserID
	//		IDTSConnection.ConnectionProperties(DBPROP_AUTH_USERID)
	//
	// Because the connection's UserID may be simply a login id and different from the actual
	// object owner, wzObjectName should be qualified.  Only one schema will be searched for the
	// object; that schema is determined by:
	//		If a Schema-qualified wzObjectName is passed, that Schema is searched.
	//		Else if only one Schema is specified, it is searched.
	//		Else if a UserID is specified, it is used.
	//		Else EREP_OBJ_NOTFOUND.
	//
	// FindScannedObject returns the following, in order:
	//		If the call to DTSPackage.SaveToRepository specified that no scanner resolution be done,
	//		FindScannedObject returns NULL and S_FALSE.  In this case, AddUnscannedObject should be
	//		called, to create an DTSPackage-level object for AddTransformationUses to relate to.
	//
	//		If the provider does not support SchemaRowsets (necessary for scan), FindScannedObject
	//		returns NULL and S_FALSE.
	//
	//		If the catalog has not been scanned, or if the call to DTSPackage.SaveToRepository
	//		specified to rescan, then the catalog is scanned.  Any error from the dbscanner (such as
	//		the catalog not being found) is returned.
	//
	//		If wzObjectName is not found, EREP_OBJ_NOTFOUND is returned.
	//
	//		If wzObjectName is not found uniquely, such as an unqualified name appearing in more than
	//		one schema, EREP_OBJ_NOTFOUND is returned.
	//
	//		If wzObjectName is found uniquely, the IDbmDeployedTable or IDbmDeployedView is placed in
	//		ppIScannedObject and S_OK is returned.
	//
	// Note that FindScannedObject should not be called for an IDbmQuery object, as these are not
	// scanned into the repository as part of a Catalog; they are owned by the connection consumer.
	// IDbmQuery objects should be added via AddUnscannedObject.
	//
	// Generally a custom Task or Transformation will do the following (with most error handling omitted
	// for brevity):
	//	pIRepositoryProvider->CreateObject(OBJID_MyCustomTaskOrTransform
	//			, NULL
	//			, wzObjectName
	//			, &pICustomTaskOrTransform);
	//	if (referencing a table or view) {
	//		if FAILED(pIRepositoryProvider->FindScannedObject(<name>
	//			, IID_IRepositoryObject
	//			, pIDbmConnection
	//			, &pINewObject))
	//			return error;
	//	}
	//	if (NULL == pUnk) {
	//		pIRepositoryProvider->CreateObject(<parameters for the table, view, query, or other object>,
	//			, &pINewObject);
	//		pIRepositoryProvider->AddUnscannedObject(pIDbmConnection
	//			, pINewObject);
	//	}
	//	pIRepositoryProvider->AddTransformationUses(L"Source Table"
	//			, pICustomTaskOrTransform
	//			, pINewObject);
	//
	STDMETHOD(FindScannedObject)(THIS_
			DP_IN LPCOLESTR wzObjectName					// Name of the object (may be qualified by catalog.schema.name)
			, DP_IN REFIID iidToGet							// an IID the object must support; ignored if IID_NULL
			, DP_IN IRepositoryDispatch *pIDbmConnection	// Connection object (e.g. from FindConnection)
			, DP_OUT IRepositoryObject **ppIScannedObject	// returns scanned object or NULL on error.
		) PURE;

	// This method adds an object to the repository as a way for AddTransformationUses to form a
	// relationship.  This object is not visible outside the scope of the saved DTSPackage.  pINewObject
	// is created (e.g. by CreateObject) and may be a table or view, or query, or a specialization (derived
	// class) of one, according to the following mapping:
	//		Object type		Must support		Added to
	//		-----------		------------		---------
	//		Query			ITfmQuery			ITfmTransformation(IUmlType).Members
	//											ITfmTransformationTask(IUmlType).Members
	//		Table			IDbmDeployedTable	Package-local DataSource/Catalog/Schema
	//		View			IDbmDeployedView	Package-local DataSource/Catalog/Schema
	//		other			IUmlMember			ITfmTransformation(IUmlType).Members
	//											ITfmTransformationTask(IUmlType).Members
	//
	STDMETHOD(AddUnscannedObject)(THIS_
			DP_IN IRepositoryDispatch *pIDbmConnection		// Connection object (e.g. from FindConnection)
			, DP_IN IRepositoryObject *pINewObject			// Task/Transform-created object.
		) PURE;

	// This method creates a relationship between an ITfmTransformation or ITfmTransformationTask
	// and an IDbmColumnSet specialization (such as an IDbmDeployedTable, IDbmDeployedView, or ITfmQuery)
	// via the ITfmTransformationUses specialization of IUmlDependency, where
	//		ITfmTransformationUses(IUmlDependency).SourceElement = pITaskOrTransform
	//		ITfmTransformationUses(IUmlDependency).TargetElement = pINewObject
	//
	// Any dependencies added in this manner can be retrieved during LoadFromRepository by:
	//		pITaskOrTransform(IID_IUmlElement).TargetDependencies
	//
	STDMETHOD(AddTransformationUses)(THIS_
			DP_IN LPCOLESTR wzDependencyType				// A string describing the dependency; e.g., L"Source Table".
			, DP_IN IRepositoryObject *pITaskOrTransform	// Task/Transform-created object.
			, DP_IN IRepositoryObject *pINewObject			// Task/Transform-created object.
		) PURE;

	// Creates a datatype object which maps the passed DBTYPE and other information to
	// its Repository equivalent, and creates and returns a matching object.
	STDMETHOD(CreateMappedDatatypeObject)(THIS_
			DP_IN DBTYPE dbType								// The OLEDB datatype
			, DP_IN LONG lSize								// Column size in characters (ignored if a fixed-length datatype)
			, DP_IN LONG lPrecision							// Column precision if DECIMAL or NUMERIC
			, DP_IN LONG lScale								// Column scale if DECIMAL or NUMERIC
			, DP_OUT IRepositoryObject **ppRepositoryObject	// output object
		) PURE;

	// Gets information from a datatype object created by CreateMappedDataTypeObject.
	STDMETHOD(GetMappedDatatypeInfo)(THIS_
			DP_IN IRepositoryObject *pRepositoryObject		// input object
			, DP_OUT DBTYPE *pdbType						// The OLEDB datatype
			, DP_OUT LONG *plSize							// Column size in characters (ignored if a fixed-length datatype)
			, DP_OUT LONG *plPrecision						// Column precision if DECIMAL or NUMERIC
			, DP_OUT LONG *plScale							// Column scale if DECIMAL or NUMERIC
		) PURE;
};

// If a custom task or custom transform server wants to manage its Repository persistence itself,
// it must implement IDTSRepositoryStorage.  Otherwise, the Package will simply enumerate the
// OleAutomation properties of the custom task/transform IDispatch and store all those which
// can be Set() as (Variant)TaggedValues of an IDtsCustomTask repository object.
#undef INTERFACE
#define INTERFACE IDTSRepositoryStorage
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	DTSDataPump_Unknown_Base()

	// The implementation must create its own Repository object via pIRepositoryProvider->CreateObject,
	// and the returned ppIRepositoryObject must be fully populated and must support IDtsCustomTask
	// (if a custom DTSPackage Task) or IDts(Blob)Transformation (if a custom DTSPump Transform server).
	// After this method returns, the DTSPackage will set properties for Task Name via INamedObject::Name
	// and ServerID (the ProgID or string form of CLSID by which the custom task/transformation server is
	// CoCreateInstance()'d) and any other base-class values needed.  Custom objects should not set tagged
	// values in the base object classes, to avoid possible name conflicts.
	STDMETHOD(SaveToRepository)(THIS_
			DP_IN IDTSRepositoryProvider *pIRepositoryProvider
			, DP_OUT IRepositoryObject **ppIRepositoryObject
		) PURE;

	// The implementation loads its own properties from this object.  If access to the IRepository
	// object is necessary, use pIRepositoryObject->get_Repository().
	STDMETHOD(LoadFromRepository)(THIS_
			DP_IN IDTSRepositoryProvider *pIRepositoryProvider
			, DP_IN IRepositoryObject *pIRepositoryObject
		) PURE;
};

#endif // def OBJID_DtsTransformationTask

#endif // ndef DTSDataPump_VersionOnly

#endif // ndef DTSDataPump_ODL_

#endif // DTSDataPump_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DtBase.Cpp ===
/*******************************************************************************
* DTBase.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseNTo1 transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DTBase.h"
#include "new.h"

//--- Initialize static member of debug scope class
#ifdef _DEBUG
CDXTDbgFlags CDXTDbgScope::m_DebugFlags;
#endif

//--- This should only be used locally in this file. We duplicated this GUID
//    value to avoid having to include DDraw.
static const IID IID_IDXDupDirectDraw =
    { 0x6C14DB80,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDDrawSurface =
    { 0x6C14DB81,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDirect3DRM =
    {0x2bc49361, 0x8327, 0x11cf, {0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1 } };

static const IID IID_IDXDupDirect3DRM3 =
    {0x4516ec83, 0x8f20, 0x11d0, {0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3 } };

static const IID IID_IDXDupDirect3DRMMeshBuilder3 =
    { 0x4516ec82, 0x8f20, 0x11d0, { 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3} };

HRESULT CDXDataPtr::Assign(BOOL bMesh, IUnknown * pObject, IDXSurfaceFactory *pSurfaceFactory)
{
    HRESULT hr = S_OK;
    if (pObject)
    {
        IUnknown *pNative = NULL;
        if (!bMesh)
        {
            //--- Try to get a DX surface
            hr = pObject->QueryInterface( IID_IDXSurface, (void **)&pNative );
            if( FAILED( hr ) )
            {
                IDirectDrawSurface *pSurf;
                //--- Try to get a DDraw surface
                hr = pObject->QueryInterface( IID_IDXDupDDrawSurface, (void **)&pSurf );
                if( SUCCEEDED( hr ) )
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = pSurfaceFactory->CreateFromDDSurface(
                                pSurf, NULL, 0, NULL, IID_IDXSurface,
                                (void **)&pNative );
                    pSurf->Release();
                }
            }
        }
        else // Must be a mesh builder
        {
            hr = pObject->QueryInterface(IID_IDXDupDirect3DRMMeshBuilder3, (void **)&pNative);
        }
        if (SUCCEEDED(hr))
        {
            Release();
            m_pNativeInterface = pNative;
            pObject->AddRef();
            m_pUnkOriginalObject = pObject;
            if (SUCCEEDED(pNative->QueryInterface(IID_IDXBaseObject, (void **)&m_pBaseObj)))
            {
                m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
                m_dwLastDirtyGenId--;
            }
            if (!bMesh)
            {   
                ((IDXSurface *)pNative)->GetPixelFormat(NULL, &m_SampleFormat);
            }
        }
        else
        {
            if (hr == E_NOINTERFACE)
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else 
    {
        Release();
    }
    return hr;
} /* CDXDataPtr::Assign */

bool CDXDataPtr::IsDirty(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastDirtyGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
        return dwOldId != m_dwLastDirtyGenId;
    }
    else
    {
        return false;
    }

}

DWORD CDXDataPtr::GenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwGenId;
        m_pBaseObj->GetGenerationId(&dwGenId);
        return dwGenId;
    }
    else
    {
        return 0;
    }
}


bool CDXDataPtr::UpdateGenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastUpdGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastUpdGenId);
        return dwOldId != m_dwLastUpdGenId;
    }
    else
    {
        return false;
    }
} /* CDXDataPtr::UpdateGenerationId */

ULONG CDXDataPtr::ObjectSize(void)
{
    ULONG ulSize = 0;
    if (m_pBaseObj)
    {
        m_pBaseObj->GetObjectSize(&ulSize);
    }
    return ulSize;    
}

/*****************************************************************************
* CDXBaseNTo1::CDXBaseNTo1 *
*--------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::CDXBaseNTo1() :
    m_aInputs(NULL),
    m_ulNumInputs(0),
    m_ulNumProcessors(1),   // Default to one until task manager is set
    m_dwGenerationId(1),
    m_dwCleanGenId(0),
    m_Duration(1.0f),
    m_StepResolution(0.0f),
    m_Progress(0.0f),
    m_dwBltFlags(0),
    m_bPickDoneByBase(false),
    m_bInMultiThreadWorkProc(FALSE),
    m_fQuality(0.5f),   // Default to normal quality.
    //  Wait forever before timing out on a lock by default
    m_ulLockTimeOut(INFINITE),
    //
    //  Override these flags if your object does not support one or more of these options.
    //  Typically, 3-D effects should set this member to 0.
    //
    m_dwMiscFlags(DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT |
                  DXTMF_BLEND_SUPPORTED | DXTMF_DITHER_SUPPORTED | DXTMF_BOUNDS_SUPPORTED | DXTMF_PLACEMENT_SUPPORTED),
    //
    //  If your object has a different number of objects or a different number of
    //  required objects than 1, simply set these members in the body of your
    //  constructor or in FinalConstruct().  For every input that is > the number
    //  required, that input will be reported as optional.
    //
    //  If your transform takes 2 required inputs, set both to 2.
    //  If your transform takes 2 optional inputs, set MaxInputs = 2, NumInRequired = 0
    //  If your transform takes 1 required and 2 optional inputs,
    //      set MaxInputs = 2, NumInRequired = 1
    //
    //  For more complex combinations of optinal/required, you will need to override
    //  the OnSetup method of this base class, and override the methods
    //      GetInOutInfo
    //
    m_ulMaxInputs(1),
    m_ulNumInRequired(1),
    //
    //  If the intputs or output types are not surfaces then set appropriate object type
    //
    m_dwOptionFlags(0),     // Inputs and output are surfaces, don't have to be the same size
    m_ulMaxImageBands(DXB_MAX_IMAGE_BANDS),
    m_fIsSetup(false)
{
    DXTDBG_FUNC( "CDXBaseNTo1::CDXBaseNTo1" );
    //
    //  Set event handles to NULL.
    //
    memset(m_aEvent, 0, sizeof(m_aEvent));
} /* CDXBaseNTo1::CDXBaseNTo1 */

/*****************************************************************************
* CDXBaseNTo1::~CDXBaseNTo1 *
*---------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::~CDXBaseNTo1()
{
    DXTDBG_FUNC( "CDXBaseNTo1::~CDXBaseNTo1" );
    _ReleaseReferences();
    delete[] m_aInputs;

    //--- Release event objects
    for(ULONG i = 0; i < DXB_MAX_IMAGE_BANDS; ++i )
    {
        if( m_aEvent[i] ) ::CloseHandle( m_aEvent[i] );
    }
} /* CDXBaseNTo1::~CDXBaseNTo1 */


/*****************************************************************************
* CDXBaseNTo1::_ReleaseRefernces *
*--------------------------------*
*   Description:
*       Releases all references to input and output objects
*-----------------------------------------------------------------------------
*   Created By: RAL
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::_ReleaseReferences()
{
    //--- Release data objects
    if( m_aInputs )
    {
        for( ULONG i = 0; i < m_ulNumInputs; ++i )
        {
            m_aInputs[i].Release();
        }
    }

    m_Output.Release();

    m_fIsSetup = false;
} /* CDXBaseNTo1::_ReleaseRefernces */



STDMETHODIMP CDXBaseNTo1::GetGenerationId(ULONG *pGenerationId)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetGenerationId" );
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseNTo1::IncrementGenerationId(BOOL bRefresh)
{
    DXTDBG_FUNC( "CDXBaseNTo1::IncrementGenerationId" );
    HRESULT hr = S_OK;
    Lock();
    m_dwGenerationId++;
    if (bRefresh)
    {
        //
        //  If we have any inputs or outputs, call Setup again to refresh all internal
        //  knowledge about the surfaces (formats, height or width could change, etc.)
        //
        //  Note that we need to AddRef the objects prior to calling Setup becuase the
        //  DXTransform may be the only object holding a referec
        //
        ULONG cInputs = m_ulNumInputs;
        ULONG cOutputs = 0;
        IUnknown *pOutput = m_Output.m_pUnkOriginalObject;
        if (pOutput)
        {
            cOutputs = 1;
            pOutput->AddRef();
        }
        IUnknown ** ppInputs = NULL;
        if (cInputs)
        {
            ppInputs = (IUnknown **)_alloca(m_ulNumInputs * sizeof(IUnknown *));
            for (ULONG i = 0; i < cInputs; i++)
            {
                ppInputs[i] = m_aInputs[i].m_pUnkOriginalObject;
                if (ppInputs[i]) ppInputs[i]->AddRef();
            }
        }
        if (cInputs || cOutputs)    // If we're not setup, skip this step.
        {
            hr = Setup(ppInputs, cInputs, &pOutput, cOutputs, 0);
            if (pOutput) pOutput->Release();
            for (ULONG i = 0; i < cInputs; i++)
            {
                if (ppInputs[i]) ppInputs[i]->Release();
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetObjectSize(ULONG *pcbSize)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetObjectSize" );
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}


void CDXBaseNTo1::_ReleaseServices(void)
{
    m_cpTransFact.Release();
    m_cpSurfFact.Release();
    m_cpTaskMgr.Release();
    m_cpDirectDraw.Release();
    m_cpDirect3DRM.Release();
}

//
//  The documentation for SetSite indicates that it is invaid to return
//  an error from this function, even if the site does not support the
//  functionality we want.  So, even if there is no service provider, or
//  the required services are not available, we will return S_OK.
//
STDMETHODIMP CDXBaseNTo1::SetSite(IUnknown * pUnkSite)
{
    DXTDBG_FUNC( "CDXBaseNTo1::SetSite" );
    HRESULT hr = S_OK;
    Lock();
    m_cpUnkSite = pUnkSite;
    _ReleaseServices();
    if (pUnkSite)
    {
        if (DXIsBadInterfacePtr(pUnkSite))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            HRESULT hr2;
            hr2 = pUnkSite->QueryInterface(IID_IDXTransformFactory, (void **)&m_cpTransFact);
	    if (SUCCEEDED(hr2))
	    {
                //
                //  Allocate memory for inputs if necessary
                //
                if (m_aInputs == NULL && m_ulMaxInputs)
                {
                    m_aInputs  = new CDXDataPtr[m_ulMaxInputs];
                    if (!m_aInputs)
                    {
                        _ASSERT(TRUE);
                        hr2 = E_OUTOFMEMORY;
                    }
                }
                hr2 = m_cpTransFact->QueryService( SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, (void **)&m_cpSurfFact);
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService( SID_SDXTaskManager, IID_IDXTaskManager, (void **)&m_cpTaskMgr);
                }
                if (SUCCEEDED(hr2))
                {
                    m_cpTaskMgr->QueryNumProcessors(&m_ulNumProcessors);
                    if (m_ulMaxImageBands && (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)) == 0)
                    {
                        for (ULONG i = 0; SUCCEEDED(hr2) && i < m_ulMaxImageBands; i++)
                        {
                            //
                            // In theory we could get back here after failing to create an event, or
                            // by getting a new site, so make sure it's non-null before creating one.
                            //
                            if (m_aEvent[i] == NULL)
                            {
                                m_aEvent[i] = ::CreateEvent(NULL, true, false, NULL);
                                if (m_aEvent[i] == NULL)
                                {
                                    hr2 = E_OUTOFMEMORY;
                                }
                            }

                        }
                    }
                }
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirectDraw, IID_IDXDupDirectDraw, (void**)&m_cpDirectDraw);
                }
                if (SUCCEEDED(hr2) && 
                    (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirect3DRM, IID_IDXDupDirect3DRM3, (void **)&m_cpDirect3DRM);
                }
                if (FAILED(hr2))
                {
                    _ASSERT(TRUE);
                    _ReleaseServices();
                }
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetSite(REFIID riid, void **ppv)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetSite" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(ppv, sizeof(*ppv)) )
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        if (m_cpUnkSite)
        {
            hr = m_cpUnkSite->QueryInterface(riid, ppv);
        }
        else
        {
            *ppv = NULL;
            hr = E_FAIL;    // This is the proper documented return code
                            // for this interface if no service provider.
        }
        Unlock();
    }
    return hr;
} 


void CDXBaseNTo1::_UpdateBltFlags(void)
{
    m_dwBltFlags = 0;
    if ((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0)
    {
        if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) 
        {
            if ((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) || m_ulNumInputs == 0)
            {
                m_dwBltFlags |= DXBOF_DO_OVER;
            }
            else
            {
                for(ULONG i = 0; i < m_ulNumInputs; ++i )
                {
                    if (InputSampleFormat(i) & DXPF_TRANSPARENCY)
                    {
                        m_dwBltFlags |= DXBOF_DO_OVER;
                        break;
                    }
                }
            }
        }
        //
        //  Set the dither flag to true only if output error is > at least one input
        //
        if (m_dwMiscFlags & DXTMF_DITHER_OUTPUT)
        {
            ULONG OutputErr = (OutputSampleFormat() & DXPF_ERRORMASK);
            if (OutputErr)
            {
                if (m_ulNumInputs)
                {
                    for(ULONG i = 0; i < m_ulNumInputs; ++i )
                    {
                        if (InputSurface(i) && (ULONG)(InputSampleFormat(i) & DXPF_ERRORMASK) < OutputErr)
                        {
                            m_dwBltFlags |= DXBOF_DITHER;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // If output has no error then don't set dither in blt flags
                    //  
                    if (OutputErr)
                    {
                        m_dwBltFlags |= DXBOF_DITHER; 
                    }
                }
            }
        }
    }
}



/*****************************************************************************
* CDXBaseNTo1::Setup *
*--------------------*
*   Description:
*       The Setup method is used to perform any required one-time setup
*   before the Execute method is called. Single surfaces or SurfaceSets may
*   be used as arguments in any combination. 
*   If punkOutputs is NULL, Execute will allocate an output result of the
*   appropriate size and return it.
*   if punkInputs and punkOutputs are NULL and it is a quick setup, the current
*   input and output objects are released.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::Setup( IUnknown * const * punkInputs, ULONG ulNumInputs,
                                 IUnknown * const * punkOutputs, ULONG ulNumOutputs, DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Setup" );
    //--- Lock object so state cannot change during setup
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    ULONG i;

    //
    //  Early out for null setup.  Forget about all other param validation, just do it.
    //  
    if (ulNumInputs == 0 && ulNumOutputs == 0)
    {
        _ReleaseReferences();
        OnReleaseObjects();
        return hr;
    }

    //--- Validate Params
    //--- Make sure we have a reference to the transform factory
    if( !m_cpTransFact )
    {
        hr = DXTERR_UNINITIALIZED;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
    }
    else
    {
        //
        //  We know that if we have a transform factory that we must also have
        //  allocated m_aInputs since this is done on SetSite to avoid work during
        //  each setup.
        //
        _ASSERT(m_aInputs || m_ulMaxInputs == 0);
        if( dwFlags ||              // No flags are valid
            ulNumOutputs != 1 ||
            ulNumInputs < m_ulNumInRequired ||
            ulNumInputs > m_ulMaxInputs ||
            (ulNumInputs && DXIsBadReadPtr( punkInputs , sizeof( *punkInputs ) * ulNumInputs )) ||
            DXIsBadReadPtr(punkOutputs, sizeof(*punkOutputs)) ||
            DXIsBadInterfacePtr(punkOutputs[0]))
        {
            hr = E_INVALIDARG;
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
        }
        else
        {
            for( i = 0; i < ulNumInputs; ++i )
            {
                if((punkInputs[i] && DXIsBadInterfacePtr(punkInputs[i])) ||
                    (punkInputs[i] == NULL && i < m_ulNumInRequired))
                {
                    hr = E_INVALIDARG;
                    DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
                    break;
                }
            }        
        }
    }

    //--- Allocate slots for input data object pointers
    if( SUCCEEDED( hr ) )
    {
        //--- Release data objects
        _ReleaseReferences();
        m_ulNumInputs = ulNumInputs;
    }

    //
    //  Assign 
    //
    for( i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
    {
        hr = m_aInputs[i].Assign((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER), punkInputs[i], m_cpSurfFact);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_Output.Assign((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER), punkOutputs[0], m_cpSurfFact);
    }   

    if (SUCCEEDED(hr) && (m_dwOptionFlags & DXBOF_SAME_SIZE_INPUTS))
    {
        hr = _MakeInputsSameSize();
    }

    if (SUCCEEDED(hr))
    {
        _UpdateBltFlags();      // Do this before calling OnSetup...
        hr = OnSetup(dwFlags);
    }
    
    if (FAILED(hr))
    {
        _ReleaseReferences();
        OnReleaseObjects();
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup failed" );
    }
    else
    {
        m_fIsSetup = true;
    }

    return hr;
} /* CDXBaseNTo1::Setup */


/*****************************************************************************
* CDXBaseNTo1::_MakeInputsSameSize *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 03/31/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

HRESULT CDXBaseNTo1::_MakeInputsSameSize(void)
{
    _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);

    HRESULT hr = S_OK;
    if (m_ulNumInputs > 1)      // No need to do this for just one input!
    {
        CDXDBnds SurfBnds(false);
        CDXDBnds Union(true);
        for (ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                Union |= SurfBnds;
            }
        }
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                if (SUCCEEDED(hr) && SurfBnds != Union)
                {
                    IDXSurfaceModifier *pSurfMod;
                    hr = ::CoCreateInstance(CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                            IID_IDXSurfaceModifier, (void **)&pSurfMod);
                    if (SUCCEEDED(hr))
                    {
                        POINT p;
                        p.x = p.y = 0;
                        if (m_dwOptionFlags & DXBOF_CENTER_INPUTS)
                        {
                            p.x = (Union.Width() - SurfBnds.Width()) / 2;
                            p.y = (Union.Height() - SurfBnds.Height()) / 2;
                        }
                        pSurfMod->SetForeground(InputSurface(i), FALSE, &p);
                        pSurfMod->SetBounds(&Union);
                        InputSurface(i)->Release();
                        pSurfMod->QueryInterface(IID_IDXSurface, (void **)&(m_aInputs[i].m_pNativeInterface));
                        ((IDXSurface *)m_aInputs[i].m_pNativeInterface)->GetPixelFormat(NULL, &m_aInputs[i].m_SampleFormat);
                        pSurfMod->Release();
                    }
                }
            }
        }
    }
    return hr;
}


/*****************************************************************************
* CDXBaseNTo1::Execute *
*----------------------*
*   Description:
*       The Execute method is used to walk the inputs/outputs and break up the
*   work into suitably sized pieces to spread symetrically accross the available
*   processors in the system.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    Execute( const GUID* pRequestID, const DXBNDS *pClipBnds, const DXVEC *pPlacement )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Execute" );
    //--- Lock object so state cannot change during execution
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;

    //--- Check args
    if( !HaveOutput() )
    {
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
        return DXTERR_UNINITIALIZED;
    }

    if (m_ulMaxImageBands == 0 ||
        (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
    {
        if ((pClipBnds && (m_dwMiscFlags & DXTMF_BOUNDS_SUPPORTED) == 0) ||
            (pPlacement && (m_dwMiscFlags & DXTMF_PLACEMENT_SUPPORTED) == 0) )
        {
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
            return E_INVALIDARG;
        }
        return OnExecute( pRequestID, pClipBnds, pPlacement );
    }

    //--- Banded image working variables
    CDXTWorkInfoNTo1 WI;

    if ((pClipBnds && pClipBnds->eType != DXBT_DISCRETE) ||
        (pPlacement && pPlacement->eType != DXBT_DISCRETE))
    {
        hr = E_INVALIDARG;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
    }
    else
    {
        hr = MapBoundsIn2Out( NULL, 0, 0, &WI.DoBnds );
        if( hr == S_OK )
        {
            hr = WI.OutputBnds.SetToSurfaceBounds(OutputSurface());
            if (hr == S_OK)
            {
                hr = DXClipToOutputWithPlacement(WI.DoBnds, (CDXDBnds *)pClipBnds, WI.OutputBnds, (CDXDVec *)pPlacement);
            }
        }
    }

    //--- Check for clipping early exit
    if( hr != S_OK )
    {
        return hr;
    }

    //=== Process ====================================================
    _ASSERT(m_ulMaxImageBands <= DXB_MAX_IMAGE_BANDS);
    ULONG ulNumBandsToDo = m_ulNumProcessors;
    if( ulNumBandsToDo > 1 )
    {
        ulNumBandsToDo = 1 + ((WI.OutputBnds.Width() * WI.OutputBnds.Height()) / 0x1000);
        if (ulNumBandsToDo > m_ulMaxImageBands)
        {
            ulNumBandsToDo = m_ulMaxImageBands;
        }
        if (ulNumBandsToDo > m_ulNumProcessors)
        {
            ulNumBandsToDo = m_ulNumProcessors;
        }
    }
    hr = OnInitInstData(WI, ulNumBandsToDo);
    if( SUCCEEDED( hr ) )
    {
        if (ulNumBandsToDo == 1 && pRequestID == NULL)
        {
            static BOOL bContinue = TRUE;
            hr = WorkProc(WI, &bContinue);
        }
        else
        {
            _ASSERT( ulNumBandsToDo <= DXB_MAX_IMAGE_BANDS );
            _ASSERT( m_aEvent[ulNumBandsToDo-1] );

            long lStartAtRow = WI.DoBnds[DXB_Y].Min;
            ULONG ulRowCount = WI.DoBnds[DXB_Y].Max - lStartAtRow;
            _ASSERT( ( ulRowCount / ulNumBandsToDo ) != 0 );

            //--- Init the work info structures
            ULONG ulBand, RowsPerBand = ulRowCount / ulNumBandsToDo;
            CDXTWorkInfoNTo1 *WIArray = (CDXTWorkInfoNTo1*)alloca( sizeof(CDXTWorkInfoNTo1) *
                                                         ulNumBandsToDo );
            DWORD *TaskIDs = (DWORD*)alloca( sizeof(DWORD) * ulNumBandsToDo );
            DXTMTASKINFO* TaskInfo = (DXTMTASKINFO*)alloca( sizeof( DXTMTASKINFO ) *
                                                            ulNumBandsToDo );

            //--- Build task info list
            WI.hr       = S_OK;
            WI.pvThis   =  this;
            long Start  = lStartAtRow;
            ULONG Count = RowsPerBand;
            long OutputYDelta = WI.OutputBnds[DXB_Y].Min - WI.DoBnds[DXB_Y].Min;

            for (ulBand = 0; ulBand < ulNumBandsToDo; ++ulBand)
            {
                memcpy(&WIArray[ulBand], &WI, sizeof(WI));

                WIArray[ulBand].DoBnds[DXB_Y].Min       = Start;
                WIArray[ulBand].OutputBnds[DXB_Y].Min   = Start + OutputYDelta;

                // If this is the last band, make sure it includes the last row.

                if (ulBand == ulNumBandsToDo - 1)
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = WI.DoBnds[DXB_Y].Max;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = WI.OutputBnds[DXB_Y].Max;
                }
                else // Not the last band.
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = Start + Count;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = Start + Count 
                                                              + OutputYDelta;
                }

                TaskInfo[ulBand].pfnTaskProc      = _TaskProc;
                TaskInfo[ulBand].pTaskData        = &WIArray[ulBand];
                TaskInfo[ulBand].pfnCompletionAPC = NULL;
                TaskInfo[ulBand].dwCompletionData = 0;
                TaskInfo[ulBand].pRequestID       = pRequestID;

                // Advance.

                Start += Count;
            }

            //
            //  Procedural surfaces (and perhaps some transforms) need to "know" that
            //  they are in a multi-threaded work procedure to avoid deadlocks.  Procedural
            //  surfaces need to allow LockSurface to work WITHOUT taking the object
            //  critical section.  Other transforms may also want to know this information
            //  to avoid deadlocks.
            //
            m_bInMultiThreadWorkProc = TRUE;

            //--- Schedule the work and wait for it to complete
            hr = m_cpTaskMgr->ScheduleTasks( TaskInfo, m_aEvent,
                                             TaskIDs, ulNumBandsToDo, m_ulLockTimeOut );

            m_bInMultiThreadWorkProc = FALSE;

            //--- Check return codes from work info structures
            //    return the first bad hr if any
            for( ulBand = 0; SUCCEEDED( hr ) && ( ulBand < ulNumBandsToDo ); ++ulBand )
            {
                hr = WIArray[ulBand].hr;
                if( hr != S_OK ) break;
            }
        }
        OnFreeInstData( WI );
    }

#ifdef _DEBUG
    if( FAILED( hr ) ) DXTDBG_MSG1( _CRT_ERROR, "\nExecute failed. HR = %X", hr );
#endif

    return hr;
} /* CDXBaseNTo1::Execute */

/*****************************************************************************
* CDXBaseNTo1::_ImageMapIn2Out *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_ImageMapIn2Out( CDXDBnds & bnds, ULONG ulNumInBnds,
                                      const CDXDBnds * pInBounds )
{
    HRESULT hr = S_OK;
    if(ulNumInBnds)
    {
        for(ULONG i = 0; i < ulNumInBnds; ++i )
        {
            bnds |= pInBounds[i];
        }
    }
    else
    {
        for( ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
        {
            if (InputSurface(i))
            {
                CDXDBnds SurfBnds(InputSurface(i), hr);
                bnds |= SurfBnds;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_ImageMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::_MeshMapIn2Out *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds)
{
    HRESULT hr = S_OK;
    if (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER)
    {
        if(ulNumInBnds)
        {
            for(ULONG i = 0; i < ulNumInBnds; ++i )
            {
                bnds |= pInBounds[i];
            }
        }
        else
        {
            for(ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
            {
                if (InputMeshBuilder(i))
                {
                    CDXCBnds MeshBnds(InputMeshBuilder(i), hr);
                    bnds |= MeshBnds;
                }
            }

        }
    }
    else
    {
        //  Already done -> bnds[DXB_T].Min = 0.0f;
        bnds[DXB_X].Min = bnds[DXB_Y].Min = bnds[DXB_Z].Min = -1.0f;
        bnds[DXB_X].Max = bnds[DXB_Y].Max = bnds[DXB_Z].Max = bnds[DXB_T].Max = 1.0f;
    }

    //
    //  Call the derived class to get the scale values.
    //
    if (SUCCEEDED(hr))
    {
	// Increase the size just a bit so we won't have rounding errors
	// result in bounds that don't actually contain the result.
	const float fBndsIncrease = 0.0001F;
	float fTemp = bnds.Width() * fBndsIncrease;

	bnds[DXB_X].Min -= fTemp;
	bnds[DXB_X].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Height();
	bnds[DXB_Y].Min -= fTemp;
	bnds[DXB_Y].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Depth();
	bnds[DXB_Z].Min -= fTemp;
	bnds[DXB_Z].Max += fTemp;

        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_MeshMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsIn2Out *
*------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                           ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsIn2Out" );
    if((ulNumInBnds && DXIsBadReadPtr( pInBounds, ulNumInBnds * sizeof( *pInBounds ) )) ||
        ulOutIndex)
    {
        return E_INVALIDARG;
    }

    if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        return E_POINTER;
    }
    //
    //  Set the bounds to empty and the appropriate type.
    //
    memset(pOutBounds, 0, sizeof(*pOutBounds));
    _ASSERT(DXBT_DISCRETE == 0);
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        pOutBounds->eType = DXBT_CONTINUOUS;
    }

    //
    //  Make sure all input bounds are of the correct type.
    //
    if( ulNumInBnds )
    {
        DXBNDTYPE eType = (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) ? DXBT_CONTINUOUS : DXBT_DISCRETE;
        for (ULONG i = 0; i < ulNumInBnds; i++)
        {
            if (pInBounds[i].eType != eType)
            {
                return E_INVALIDARG;
            }
        }
    }

    //
    //  Now do the appropriate mapping
    //
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        //
        //  NOTE:  In the case of non-mesh inputs, the inputs are discrete, but they will
        //         be completely ignored by the function so it's OK to cast them to CDXCBnds
        //
        return _MeshMapIn2Out(*((CDXCBnds *)pOutBounds), ulNumInBnds, (CDXCBnds *)pInBounds);
    }
    else 
    {
        return _ImageMapIn2Out(*(CDXDBnds *)pOutBounds, ulNumInBnds, (CDXDBnds *)pInBounds);
    }
} /* CDXBaseNTo1::MapBoundsIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsOut2In *
*------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        hr = E_NOTIMPL;     // This is pointless for meshes.
    }
    else if(ulInIndex >= m_ulMaxInputs || ulOutIndex || DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;
    }
    return hr;
} /* CDXBaseNTo1::MapBoundsOut2In */

/*****************************************************************************
* CDXBaseNTo1::SetMiscFlags *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30.97
*-----------------------------------------------------------------------------
*   Parameters:
*       bMiscFlags - New value to set 
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetMiscFlags( DWORD dwMiscFlags )
{ 
    DXTDBG_FUNC( "CDXBaseNTo1::SetMiscFlags" );
    HRESULT hr = S_OK;
    Lock();
    WORD wOpts = (WORD)dwMiscFlags;     // Ignore high word.  Only set low word.
    if (((WORD)m_dwMiscFlags) != wOpts)
    {
        if ((wOpts & (~DXTMF_VALID_OPTIONS)) ||
            ((wOpts & DXTMF_BLEND_WITH_OUTPUT) && (m_dwMiscFlags & DXTMF_BLEND_SUPPORTED) == 0) ||
            ((wOpts & DXTMF_DITHER_OUTPUT) && (m_dwMiscFlags & DXTMF_DITHER_SUPPORTED) == 0))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_dwMiscFlags &= 0xFFFF0000;
            m_dwMiscFlags |= wOpts;
            _UpdateBltFlags();
            m_dwGenerationId++;
        }
    }
    Unlock();  
    return hr;
} /* CDXBaseNTo1::SetMiscFlags */

/*****************************************************************************
* CDXBaseNTo1::GetMiscFlags *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetMiscFlags( DWORD* pdwMiscFlags )
{
    if( DXIsBadWritePtr( pdwMiscFlags, sizeof( *pdwMiscFlags ) ) )
    {
        return E_POINTER;
    }
    *pdwMiscFlags = m_dwMiscFlags;
    return S_OK;
} /* CDXBaseNTo1::GetMiscFlags */


/*****************************************************************************
* CDXBaseNTo1::SetQuality *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetQuality(float fQuality)
{
    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        return E_NOTIMPL;
    }

    if (fQuality < 0.0f || fQuality > 1.0f)
    {
        return E_INVALIDARG;
    }

    Lock();
    if (m_fQuality != fQuality)
    {
        m_fQuality = fQuality;
        m_dwGenerationId++;
    }
    Unlock();

    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::GetQuality *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

STDMETHODIMP CDXBaseNTo1::GetQuality(float *pfQuality)
{
    HRESULT hr = S_OK;

    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        hr = E_NOTIMPL;
    }
    else 
    {
        if( DXIsBadWritePtr( pfQuality, sizeof( *pfQuality ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            *pfQuality = m_fQuality;
        }
    }
    return hr;
}



/*****************************************************************************
* GetInOutInfo
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags,
                                        GUID * pIDs, ULONG *pcIDs, IUnknown **ppUnkCurObj )
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetInOutInfo" );
    HRESULT hr = S_FALSE;
    DWORD dwFlags = 0;
    BOOL bImage;
    if( bOutput )
    {
        bImage = !(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        if (ulIndex == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        bImage = !(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        if (ulIndex < m_ulMaxInputs)
        {
            hr = S_OK;
            if (ulIndex >= m_ulNumInRequired)
            {
                dwFlags = DXINOUTF_OPTIONAL;
            }
        }
    }
    if( hr == S_OK )
    {
        if( pdwFlags && !DXIsBadWritePtr( pdwFlags, sizeof( *pdwFlags ) ) )
        {
            *pdwFlags = dwFlags;
        }

        if( pIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) ||
                DXIsBadWritePtr( pIDs, *pcIDs * sizeof( *pIDs ) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if (bImage)
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXSurface;
                    }
                    if (*pcIDs > 1)
                    {
                        pIDs[1] = IID_IDXDupDDrawSurface;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 2;
                }
                else
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXDupDirect3DRMMeshBuilder3;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 1;
                }
            }
        }
        else if( pcIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) )
            {
                hr = E_POINTER;
            }
            else
            {
                *pcIDs = bImage ? 2 : 1;
            }
        }
        if (hr == S_OK && ppUnkCurObj)
        {
            if (DXIsBadWritePtr(ppUnkCurObj, sizeof(*ppUnkCurObj)))
            {
                hr = E_POINTER;
            }
            else
            {
                if (bOutput)
                {
                    *ppUnkCurObj = m_Output.m_pNativeInterface;
                }
                else
                {
                    *ppUnkCurObj = NULL;
                    if (ulIndex < GetNumInputs())
                    {
                        *ppUnkCurObj = m_aInputs[ulIndex].m_pUnkOriginalObject;
                    }
                }
                if (*ppUnkCurObj)
                {
                    (*ppUnkCurObj)->AddRef();
                }
            }
        }
    }
    return hr;
} /* CDXBaseNTo1::GetInOutInfo */

/*****************************************************************************
* CDXBaseNTo1::OnUpdateGenerationId *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::OnUpdateGenerationId(void)
{
    DXTDBG_FUNC( "CDXBaseNTo1::OnUpdateGenerationId" );
    if( (m_dwMiscFlags & DXTMF_INPLACE_OPERATION) &&
        m_Output.UpdateGenerationId())
    {
        m_dwGenerationId++;
    }
    for (ULONG i = 0; i < m_ulNumInputs; i++)
    {
        if (m_aInputs[i].UpdateGenerationId())
        {
            m_dwGenerationId++;
        }
    }
} /* CDXBaseNTo1::OnUpdateGenerationId */

/*****************************************************************************
* CDXBaseNTo1::OnGetObjectSize *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
ULONG CDXBaseNTo1::OnGetObjectSize(void)
{
    return sizeof(*this);
}

//
//  Effect interface
//

/*****************************************************************************
* CDXBaseNTo1::get_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Progress(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Progress" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Progress;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::put_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Progress(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Progress" );
    HRESULT hr = S_OK;
    if (newVal < 0.0 || newVal > 1.0f)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();
        m_Progress = newVal;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_dwGenerationId++;     
        Unlock();
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_StepResolution *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_StepResolution(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_StepResolution" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_StepResolution;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Duration(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Duration" );
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_Duration;
    }
    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::put_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Duration(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Duration" );
    if (newVal <= 0.)
    {
        return E_INVALIDARG;
    }
    if(newVal != m_Duration)
    {
	Lock();
	m_dwGenerationId++;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_Duration = newVal;
    	Unlock();
    }
    return S_OK;
}


/*****************************************************************************
* CDXBaseNTo1::PointPick *
*------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 5/5/98
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::PointPick(const DXVEC *pPoint,
                                    ULONG * pulInputSurfaceIndex,
                                    DXVEC *pInputPoint)
{
    HRESULT hr          = S_OK;
    BOOL    bFoundIt    = FALSE;

    // If we haven't been set up yet, we will just act as if we're transparent.

    if (!m_fIsSetup)
    {
        hr = S_FALSE;

        goto done;
    }

    if (DXIsBadReadPtr(pPoint, sizeof(*pPoint)) || pPoint->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        if (DXIsBadWritePtr(pulInputSurfaceIndex, sizeof(*pulInputSurfaceIndex)) ||
            DXIsBadWritePtr(pInputPoint, sizeof(*pInputPoint)))
        {
            hr = E_POINTER;
        }
        else 
        {
            HRESULT     hr2         = S_OK;
            CDXDBnds    bndsOutput;
            CDXDBnds    OutBndsPoint(*((CDXDVec *)pPoint));
            CDXDVec &   InVec       = *(new(pInputPoint) CDXDVec(*((CDXDVec *)pPoint)));

            // Get the output size of the DXTransform.  If this point is not on
            // the output at all, we can return S_FALSE right now.

            hr = MapBoundsIn2Out(NULL, 0, 0, &bndsOutput);

            if (FAILED(hr))
            {
                goto done;
            }

            if (!bndsOutput.TestIntersect(OutBndsPoint))
            {
                hr = S_FALSE;

                goto done;
            }

            hr2 = OnSurfacePick(OutBndsPoint, *pulInputSurfaceIndex, InVec);

            if (hr2 != E_NOTIMPL)
            {
                hr = hr2;
            }
            else
            {
                //--- The derived class does not implement so we will do
                //    the hit test against the input for them.
                ULONG * aulInIndex = (ULONG *)_alloca(sizeof(ULONG) * m_ulMaxInputs);
                BYTE * aWeights = (BYTE *)_alloca(sizeof(BYTE) * m_ulMaxInputs);
                ULONG ulNumToTest;
                OnGetSurfacePickOrder(OutBndsPoint, ulNumToTest, aulInIndex, aWeights);

                if( m_bPickDoneByBase && ( m_ulNumInputs > 1 ) )
                {
                    //--- We don't know how to do multi-input picking from the base.
                    hr = E_NOTIMPL;
                }

                for (ULONG i = 0; SUCCEEDED(hr) && i < ulNumToTest; i++)
                {
                    ULONG ulInput = aulInIndex[i];
                    if (HaveInput(ulInput) && aWeights[i])
                    {
                        CDXDBnds Out2InBnds(false);
                        hr = MapBoundsOut2In(0, &OutBndsPoint, ulInput, &Out2InBnds);
                        if (SUCCEEDED(hr))
                        {
                            CDXDBnds InSurfBnds(InputSurface(ulInput), hr);
                            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
                            {
                                IDXARGBReadPtr * pPtr;
                                hr = InputSurface(ulInput)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                                if( SUCCEEDED(hr) )
                                {
                                    DXPMSAMPLE val;
                                    pPtr->UnpackPremult(&val, 1, FALSE);
                                    pPtr->Release();
                                    if (val.Alpha * aWeights[i] / 255)
                                    {
                                        InSurfBnds.GetMinVector(InVec);
                                        bFoundIt = TRUE;
                                        *pulInputSurfaceIndex = ulInput;
                                        break;
                                    }
                                }
                            }   
                        }
                    }
                }
                if (SUCCEEDED(hr) & (!bFoundIt))
                {
                    hr = S_FALSE;
                }
            }
        }
    }

done:

    return hr;
} /* CDXBaseNTo1::PointPick */

/*****************************************************************************
* RegisterTansform (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseNTo1::
RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                  ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    DXTDBG_FUNC( "CDXBaseNTo1::RegisterTransform" );
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}

//
//  BUGBUG -- try/except around this !
//  
void CDXBaseNTo1::_TaskProc(void* pTaskInfo, BOOL* pbContinue )
{ 
    _ASSERT( pTaskInfo );
    CDXTWorkInfoNTo1& WI = *((CDXTWorkInfoNTo1 *)pTaskInfo);
    CDXBaseNTo1& This = *((CDXBaseNTo1 *)WI.pvThis);
    WI.hr = This.WorkProc(WI, pbContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DtsFFile.h ===
//
// DTSFFile.h
//	Header file for the OLEDB DTSFlatFile Service Provider.
//	Copyright 1997 - 1999 Microsoft Corporation
//
#ifndef DTSFlatFile_H_
#define DTSFlatFile_H_

#ifndef UNICODE_BOM
	#define UNICODE_BOM  0xFEFF
#endif

#ifndef DTSFlatFileVersion_Major
	#define DTSFlatFileVersion_Major 1
	#define DTSFlatFileVersion_Minor 0
#endif // DTSFlatFileVersion_Major

///////////////////////////////////////////////////////////////////////////////////////
// CPP Enumerations, constants, and data structures.
///////////////////////////////////////////////////////////////////////////////////////

#define FF_ENUM_BEGIN(tdef, hstring)	DWORD tdef, *LP##tdef; enum tag##tdef
	// item = value, ...
#define FF_ENUM_END(tdef)				

typedef FF_ENUM_BEGIN(DTSFlatFileError, "Error ranges for DTSFlatFile execution") {
	DTSFlatFile_E_InvalidColumnFlags			= 0x3000,
	DTSFlatFile_E_DuplicateColumnName			= 0x3001,
	DTSFlatFile_E_LinkFileColumnNoSelfRef		= 0x3002,
	DTSFlatFile_E_LinkFileColumnNotFound		= 0x3003,
	DTSFlatFile_E_OnlyOneSession				= 0x3004,
	DTSFlatFile_E_OnlyOneRowset					= 0x3005,
	DTSFlatFile_E_ColumnOutOfRange				= 0x3006,
	DTSFlatFile_E_NoBindPart					= 0x3007,
	DTSFlatFile_E_CantConvert					= 0x3008,
	DTSFlatFile_E_ByrefNotOnFixedDatatypes		= 0x3009,
	DTSFlatFile_E_RowDelimiterNotFound			= 0x300a,
	DTSFlatFile_E_NoUpdatability				= 0x300b,
	DTSFlatFile_E_RowRefCountNotZero			= 0x300c,
	DTSFlatFile_E_FileInfoIncomplete			= 0x300d,
	DTSFlatFile_E_NumberOfColumnConflict		= 0x300e,
	DTSFlatFile_E_ZeroColumnLength				= 0x300f,
	DTSFlatFile_E_GetConvSizeFail				= 0x3010,
	DTSFlatFile_E_ColumnDelimiterNotFound		= 0x3011,
	DTSFlatFile_E_TextQualifierNotFound			= 0x3012,
	DTSFlatFile_E_TooManyColumnFound			= 0x3013,
	DTSFlatFile_E_NoColDelimTextQualAllowed		= 0x3014,
	DTSFlatFile_E_InvalidDelimitedData			= 0x3015,
	DTSFlatFile_E_InvalidBracketing				= 0x3016,
	DTSFlatFile_E_EmptyDataFile					= 0x3017,

} FF_ENUM_END(DTSFlatFileError);

typedef FF_ENUM_BEGIN(DTSFlatFileColumnFlags, "Flags for DTSFlatFile column metadata") {
	DTSFlatFileColumn_None						= 0x0000,

	// Column data flags.
	DTSFlatFileColumn_Nullable					= 0x0001,
	DTSFlatFileColumn_IsLong					= 0x0002,

	// Column behaviour flags.
	DTSFlatFileColumn_SkipOnRead				= 0x1001,
	DTSFlatFileColumn_AppendToFile				= 0x1002,

} FF_ENUM_END(DTSFlatFileColumnFlags);

#define DBPROP_DTS_ROWDELIMITER					0x10000001
#define DBPROP_DTS_FILEFORMAT					0x10000002
#define DBPROP_DTS_FIXEDFIELD_LENGTHS			0x10000003	
#define DBPROP_DTS_COLUMNDELIMITER				0x10000004
#define DBPROP_DTS_COLUMNMETADATA				0x10000005
#define DBPROP_DTS_FILETYPE						0x10000006
#define DBPROP_DTS_NUMBEROFCOLUMNS				0x10000007
#define DBPROP_DTS_TEXTQUALIFIER				0x10000008
#define DBPROP_DTS_SKIPROWS						0x10000009
#define DBPROP_DTS_FIRSTROWCOLUMNNAME			0x1000000a
#define DBPROP_DTS_COLUMNNAMES					0x1000000b
#define DBPROP_DTS_TEXTQUALIFIER_COLMASK		0x1000000c
#define DBPROP_DTS_XML_ROOT_ELEMENT				0x1000000d
#define DBPROP_DTS_XML_ROW_ELEMENT				0x1000000e
#define DBPROP_DTS_MAX_DELIM_COLWIDTH			0x1000000f
#define DBPROP_DTS_BLOB_COLMASK					0x10000010

#define DBPROPVAL_DTS_FILEFORMAT_NONE			0x0000
#define DBPROPVAL_DTS_FILEFORMAT_DELIMITED		0x0001
#define DBPROPVAL_DTS_FILEFORMAT_FIXEDLENGTH	0x0002
#define DBPROPVAL_DTS_FILEFORMAT_PREFIXLENGTH	0x0003
#define DBPROPVAL_DTS_FILEFORMAT_XML			0x0004

#define DBPROPVAL_DTS_FILETYPE_ASCII			0x0001
#define DBPROPVAL_DTS_FILETYPE_UNICODE			0x0002
#define DBPROPVAL_DTS_FILETYPE_AUTODETECT		0x0003
#define DBPROPVAL_DTS_FILETYPE_OEM				0x0004

#define FILE_ATTRIBUTE_READ						0x0000
#define FILE_ATTRIBUTE_WRITE					0x0001
#define FILE_ATTRIBUTE_APPEND					0x0002
#define FILE_ATTRIBUTE_WRITEABLE				0x0003

#ifdef NONAMELESSUNION
#define FF_UNION_NAME(u)	u
#else
#define FF_UNION_NAME(u)
#endif

// Metadata structure.  Metafile representation is keyed on field name and text value.
typedef struct {
	LPCOLESTR wzName;					// Name of the field (column).
	DBTYPE dbType;						// Field datatype
	union {
		ULONG ulLength;					// Field data length (byte length, or char length
										// for [W]STR).  Ignored for fixed-length types.
		struct {
			BYTE bPrecision;			// Numeric precision
			BYTE bScale;				// Numeric scale
		} FF_UNION_NAME(p);
	} FF_UNION_NAME(u);
	LPOLESTR wzDelimiter;				// Delimiter for [W]STR column.
	LPOLESTR wzTextQualifier;			// Text Qualifer
	DBTYPE dbLengthPrefixType;			// DBTYPE_I[124] dynamic length prefix for [W]STR|BYTES column;
										// ignored otherwise or if DBTYPE_EMPTY
	LPCOLESTR wzLinkFileColumnName;		// Name of column (field) containing file name to read from or
										// write to for [W]STR|BYTES column; ignored otherwise or if NULL.
	DTSFlatFileColumnFlags dtsFlags;	// Column flags from enum
	LPCOLESTR wzNullValue;				// Char representation of NULL value (e.g. NULL, "-0-",
										// 0xFFFFFF7F, etc.).  Converted to column datatype.
} DTSFlatFileColumnMetadata, *LPDTSFlatFileColumnMetadata;
typedef DTSFlatFileColumnMetadata const * LPCDTSFlatFileColumnMetadata;
										
// DTSFlatFileMetadata.wzDatafileName allows applications to SetMetafile and then GetMetadata 
// to retrieve the datafile name.  This is useful if the metafile is specific to a single 
// datafile; otherwise, it can function as metadata for multiple datafiles.  In any case, 
// an application must set the DBPROP_INIT_DATASOURCE property to the datafile name, which must 
// match wzDatafileName if wzDatafileName is non-NULL.

typedef struct {
	BOOL	 bUnicode;					// Unicode or OEM File 
	BOOL	 bFirstRowColumnName;		// First Row contains column name
	LPOLESTR wzRowDelimiter;			// Row Delimiter.
	LPOLESTR wzDefaultColDelimiter;		// Default Column Delimiter.
	LPOLESTR wzDefaultTextQualifier;	// Default Text Qualifer.
	LPOLESTR wzDataFileName;			// UNC or fully-qualified filename.
	LPOLESTR wzRootElementName;			// XML root element name.
	LPOLESTR wzRowElementName;			// XML element collection object name.
	ULONG cColumns;
	ULONG cSkipRows;
	LPDTSFlatFileColumnMetadata pColumnMetadata;
} DTSFlatFileMetadata, *LPDTSFlatFileMetadata;
typedef DTSFlatFileMetadata const * LPCDTSFlatFileMetadata;


///////////////////////////////////////////////////////////////////////////////////////
// Class and IID definitions
///////////////////////////////////////////////////////////////////////////////////////

// Include <initguid.h> to define ownership of these GUIDs.
// {xxxxxxxx-0224-11d1-B7B8-00C04FB6EFD5}
#define DEFINE_DTSFlatFileGUID(name, lval) \
	DEFINE_GUID(name, 0x##lval, 0x224, 0x11d1, 0xb7, 0xb8, 0x0, 0xc0, 0x4f, 0xb6, 0xef, 0xd5);

// DTSFlatFile DataSourceObject CLSID.
#define Progid_DTSFlatFile			OLESTR("DTSFlatFile")
DEFINE_DTSFlatFileGUID(CLSID_DTSFlatFile, 10010100)

// DTSFlatFile metadata interface IID.
DEFINE_DTSFlatFileGUID(IID_IDTSFlatFileMetadata, 10010200)

///////////////////////////////////////////////////////////////////////////////////////
// Interface definitions
///////////////////////////////////////////////////////////////////////////////////////

// Repeat the IUnknown members because C doesn't provide inheritance.
#ifndef DTSFlatFile_Unknown_Base
#define DTSFlatFile_Unknown_Base()															\
		STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;				\
		STDMETHOD_(ULONG,AddRef) (THIS) PURE;												\
		STDMETHOD_(ULONG,Release) (THIS) PURE;
#endif

#undef INTERFACE
#define INTERFACE IDTSFlatFileMetadata
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	DTSFlatFile_Unknown_Base()

	STDMETHOD(GetMetadata)(THIS_
            /* [size_is][size_is][out] */ DTSFlatFileMetadata __RPC_FAR * __RPC_FAR *ppMetadata
		) PURE;
	STDMETHOD(UninitializeMetadata)(THIS_ 
		) PURE;
	STDMETHOD(SetMetadata)(THIS_
            /* [size_is][in] */ const DTSFlatFileMetadata __RPC_FAR *pMetadata
		) PURE;
	STDMETHOD(SetMetafile)(THIS_
			/* [string][in] */ const OLECHAR __RPC_FAR *wzFileName
		) PURE;
};

#endif // DTSFlatFile_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dssenum.h ===
//
// Copyright (C) Microsoft Corporation, 1997.  All rights reserved.
//

#ifndef DSSENUM_H
#define DSSENUM_H
// DSSENUM.H

// STOCKBPCEVENT enumeration has been removed.  The allowable values
//  of events fired to the CA Server are those defined as constants
//  in the "CAEvent Interface" section of CAODL.H.

// Upper edge purchase actions

    typedef enum PURCHASEACTION {
        PAGETDETAILS,
        PAPURCHASETOVIEW,
        PAPURCHASETOTAPE,
        PACANCELVIEW,
        PACANCELTAPE,
        PAPREVIEW
    } PURCHASEACTION;

// note that the bit mapping used here allows, for DSS, the direct conversion
// of lower edge status into upper edge status.
    typedef enum PURCHASESTATUS {
        PSVIEWTAKEN = 0,
        PSVIEWCANCELLED,
        PSVIEWREPORTED,
        PSPREVIEWTAKEN,

        PSVIEWAUTHORIZED,
        PSVIEWPURCHASED,
        PSTAPEPURCHASED,
        PSTAPEAUTHORIZED,

        PSTAPETAKEN,
        PSTAPECANCELLED,
        PSTAPEREPORTED,
        PSVIEWAVAILABLE,

        PSTAPEAVAILABLE,
        PSREVIEWAVAILABLE
    } PURCHASESTATUS;

// Reason values returned in BPCDetails when purchase actions are
//  attempted.
    typedef enum PURCHASEREASON {
        PRSUCCESS = 0,
        PRNOCALLBACK,
        PRNOSUBSCRIBER,
        PRRATING,
        PRSPENDING,
        PRCREDIT,
        PRWRONGCARD,
        PRCARDFULL,
        PRBLOCKED,
        PRBLACKOUT,
        PRTOOLATE,
        PRREDUNDANT,
        PRPPVFAILURE,
        PRBADDATA,
        PRCONTENTION
    } PURCHASEREASON;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dv.h ===
//------------------------------------------------------------------------------
// File: DV.h
//
// Desc: DV typedefs and defines.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _DV_H_
#define _DV_H_

#define DV_DVSD_NTSC_FRAMESIZE	120000L
#define DV_DVSD_PAL_FRAMESIZE	144000L

#define DV_SMCHN	0x0000e000
#define DV_AUDIOMODE    0x00000f00
#define DV_AUDIOSMP	0x38000000

#define DV_AUDIOQU	0x07000000
#define DV_NTSCPAL	0x00200000
#define DV_STYPE	0x001f0000


//There are NTSC or PAL DV camcorders  
#define DV_NTSC		    0
#define DV_PAL		    1
//DV camcorder can output sd/hd/sl  
#define DV_SD		    0x00
#define DV_HD		    0x01
#define DV_SL		    0x02
//user can choice 12 bits or 16 bits audio from DV camcorder
#define DV_CAP_AUD16Bits    0x00
#define DV_CAP_AUD12Bits    0x01

#define SIZE_DVINFO	    0x20    

typedef struct Tag_DVAudInfo
{
	BYTE    bAudStyle[2];           
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//                 0x05: mon, audio in 2nd 5 DIF sequence
	//                 0x15: stereo, audio only in 2nd 5 DIF sequence
	//                 0x10: stereo, audio only in 1st 5/6 DIF sequence
	//                 0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//                 0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE    bAudQu[2];                      //qbits, only support 12, 16,           
		
	BYTE    bNumAudPin;                     //how many pin(language)
	WORD    wAvgSamplesPerPinPerFrm[2];     //samples size for one audio pin in one frame(which has 10 or 12 DIF sequence) 
	WORD    wBlkMode;                       //45 for NTSC, 54 for PAL
	WORD    wDIFMode;                       //5  for NTSC, 6 for PAL
	WORD    wBlkDiv;                        //15  for NTSC, 18 for PAL
} DVAudInfo;
	  
#endif // _DV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dtchelp.h ===
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1996	Microsoft Corporation.	All Rights Reserved

@doc

@module		DTCHelp.h	|

			contains helper API for loading the DTCHelper DLL

-------------------------------------------------------------------------------
@rev 	0 	| 8th -Sep-1995	|	GaganC		| Created
----------------------------------------------------------------------------- */
#ifndef __DTCHELP_H__
#define __DTCHELP_H__


//---------------------------------------------------------
//		ALL INCLUDE FILES GO HERE
//---------------------------------------------------------
#include <windows.h>


//---------------------------------------------------------
// typedefs
//---------------------------------------------------------
typedef HRESULT  (STDAPIVCALLTYPE * DTC_GET_TRANSACTION_MANAGER)(LPTSTR  pszHost,
									LPTSTR	pszTmName,
									/* in */ REFIID rid,
									/* in */ DWORD	dwReserved1,
									/* in */ WORD	wcbReserved2,
									/* in */ void FAR * pvReserved2,
									/*out */ void** ppvObject )	;

//---------------------------------------------------------
//			Function Prototypes
//---------------------------------------------------------
EXTERN_C
{
	DTC_GET_TRANSACTION_MANAGER	__cdecl LoadDtcHelper (void);
	HMODULE __cdecl GetDtcLocaleResourceHandle(void);
}


//---------------------------------------------------------
//			ALL ERRORS GO HERE
//---------------------------------------------------------


#endif __DTCHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DtBase.h ===
/*******************************************************************************
* DTBase.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseNTo1 implementation. It is
*   used as a base class to implement discrete transform objects that support
*   DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DTBase_h
#define DTBase_h

//--- Additional includes
#ifndef DXHelper_h
#include <DXHelper.h>
#endif

#ifndef DXTmpl_h
#include <DXTmpl.h>
#endif

#ifndef dxatlpb_h
#include <dxatlpb.h>
#endif

#ifndef _ASSERT
#include <crtdbg.h>
#endif

#ifndef DXTDbg_h
#include <DXTDbg.h>
#endif

//=== Constants ====================================================
#define DXBOF_INPUTS_MESHBUILDER    0x00000001
#define DXBOF_OUTPUT_MESHBUILDER    0x00000002
#define DXBOF_SAME_SIZE_INPUTS      0x00000004
#define DXBOF_CENTER_INPUTS         0x00000008

#define DXB_MAX_IMAGE_BANDS         4           // Maximum of 4 image bands

//=== Class, Enum, Struct and Union Declarations ===================
class CDXBaseNTo1;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXDataPtr
*
*/
class CDXDataPtr
{
    friend CDXBaseNTo1;
public:
    IUnknown           *m_pUnkOriginalObject;
    IUnknown           *m_pNativeInterface;
    IDXBaseObject      *m_pBaseObj;
    DWORD               m_dwLastDirtyGenId;
    DXSAMPLEFORMATENUM  m_SampleFormat;

    CDXDataPtr() : 
        m_pUnkOriginalObject(NULL),
        m_pNativeInterface(NULL), 
        m_pBaseObj(NULL),
        m_dwLastUpdGenId(0),
        m_dwLastDirtyGenId(0),
        m_SampleFormat(DXPF_NONSTANDARD)
        {};
    ~CDXDataPtr() { Release(); }
    void Release()
    {
        if (m_pNativeInterface)
        {
            m_pNativeInterface->Release();
            m_pNativeInterface = NULL;
        }
        if (m_pBaseObj)
        {
            m_pBaseObj->Release();
            m_pBaseObj = NULL;
        }
        if (m_pUnkOriginalObject)
        {
            m_pUnkOriginalObject->Release();
            m_pUnkOriginalObject = NULL;
        }
    }
    HRESULT Assign(BOOL bMeshBuilder, IUnknown * pObject, IDXSurfaceFactory *pSurfFact);
    bool IsDirty(void);
    DWORD GenerationId(void);
    ULONG ObjectSize(void);
private:    // This should only be called by base class
    DWORD           m_dwLastUpdGenId;
    bool UpdateGenerationId(void);
};

/*--- CDXTWorkInfoNTo1
*   This structure is used to hold the arguments needed by the
*   image processing function defined by the derived class
*/
class CDXTWorkInfoNTo1
{
public:
    CDXTWorkInfoNTo1()
    { pvThis = NULL; pUserInstData = NULL; hr = S_OK; }
    void *   pvThis;          // The owning class object (must be cast to the right type)
    CDXDBnds DoBnds;          // The portion of the output space to render
    CDXDBnds OutputBnds;      // The portion of the output SURFACE to render
    void*    pUserInstData;   // User field for instance data
    HRESULT  hr;              // Error return code from work procedure
};

/*** CDXBaseNTo1
*   This is a base class used for implementing 1 in 1 out discrete transforms.
*/
class ATL_NO_VTABLE CDXBaseNTo1 : 
    public CComObjectRootEx<CComMultiThreadModel>,
#if(_ATL_VER < 0x0300)
    public IObjectSafetyImpl<CDXBaseNTo1>,
#else
    public IObjectSafetyImpl<CDXBaseNTo1,INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
#endif
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CDXBaseNTo1)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
#else
        COM_INTERFACE_ENTRY(IObjectSafety)
#endif
        COM_INTERFACE_ENTRY_FUNC(IID_IDXSurfacePick, 0, QI2DPick)
    END_COM_MAP()

    //
    //  Only return the 2D pick inteface for surface to surface transforms
    //
    static HRESULT WINAPI QI2DPick(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
    {
        CDXBaseNTo1 * pThis = (CDXBaseNTo1 *)pv;
        if (pThis->m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER))
        {
            return S_FALSE; // Continue processing COM map
        }
        *ppv = (IDXSurfacePick *)pThis;
        ((IDXSurfacePick *)pThis)->AddRef();
        return S_OK;
    }

    CComPtr<IOleClientSite> m_cpOleClientSite;

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>            m_cpUnkSite;
    CComPtr<IDXTransformFactory> m_cpTransFact;   
    CComPtr<IDXSurfaceFactory>   m_cpSurfFact;
    CComPtr<IDXTaskManager>      m_cpTaskMgr;
    CComPtr<IDirectDraw>         m_cpDirectDraw;
    CComPtr<IDirect3DRM3>        m_cpDirect3DRM;
    DWORD        m_dwMiscFlags;
    HANDLE       m_aEvent[DXB_MAX_IMAGE_BANDS];
    ULONG        m_ulNumProcessors;
    DWORD        m_dwGenerationId;
    DWORD        m_dwCleanGenId;
    BOOL         m_bPickDoneByBase;
    float        m_Duration;
    float        m_StepResolution;
    float        m_fQuality;        // Set DXTMF_QUALITY_SUPPORTED in m_dwMiscFlags if you use this property.    
    ULONG        m_ulNumInputs;
    DWORD        m_dwBltFlags;      // Ser prior to OnSetup and any Execute for classes with surface outputs
    BOOL         m_bInMultiThreadWorkProc;  // Base class sets to TRUE when scheduling tasks on multiple threads

    //
    //  Derived classes should set these values in their constructor or in FinalConstruct()
    //
    DWORD        m_dwOptionFlags;
    ULONG        m_ulLockTimeOut;     // The amount of time used for blocking
    ULONG        m_ulMaxInputs;
    ULONG        m_ulNumInRequired;
    ULONG        m_ulMaxImageBands;   // Only used for surface->Surface transforms
    float        m_Progress;

private:
    CDXDataPtr* m_aInputs;
    CDXDataPtr  m_Output;

    // m_fIsSetup   This is true when the DXTransform has been properly set up.

    unsigned    m_fIsSetup : 1;

  /*=== Methods =======*/
  public:
    //--- Constructors
    CDXBaseNTo1();
    ~CDXBaseNTo1();

    //--- Support virtuals for derived classes
    virtual HRESULT OnInitInstData( CDXTWorkInfoNTo1& /*WorkInfo*/, ULONG& /*ulNumBandsToDo*/) { return S_OK; }
    virtual HRESULT OnFreeInstData( CDXTWorkInfoNTo1& /*WorkInfo*/ ) { return S_OK; }
    virtual HRESULT OnSetup( DWORD /* dwFlags */) { return S_OK; }    // Override to be notified of a new non-null setup
    virtual void OnReleaseObjects() {}  // Override to be notified of NULL setup
    virtual HRESULT OnExecute(const GUID* /* pRequestID */, const DXBNDS * /*pClipBnds */,
                              const DXVEC * /*pPlacement */ ) { return E_FAIL; }
    virtual void OnUpdateGenerationId(void);
    virtual ULONG OnGetObjectSize(void);
    virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, BOOL* pbContinueProcessing) { return E_FAIL; }   // Override to do work
    virtual HRESULT DetermineBnds(CDXCBnds & Bnds) { return S_OK; } // Override for mesh output transforms
    virtual HRESULT DetermineBnds(CDXDBnds & Bnds) { return S_OK; } // Override for surface output transforms
    //
    //  Only override this function if you need to do a customized point pick implementation.  Otherwise simply
    //  override GetPointPickOrder() and return appropriate information.
    //
    virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec) { return E_NOTIMPL; }
    virtual void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, ULONG aInIndex[], BYTE aWeight[])
    {
        m_bPickDoneByBase = true;
        ulInToTest  = 1;
        aInIndex[0] = 0;
        aWeight[0]  = 255;
    }

    //--- Private helpers
 private:
    static DXTASKPROC _TaskProc;
    void _ReleaseReferences();
    void _ReleaseServices();
    void _UpdateBltFlags(void);
    HRESULT _MakeInputsSameSize(void);
    HRESULT _ImageMapIn2Out(CDXDBnds & bnds, ULONG ulNumBnds, const CDXDBnds * pInBounds);
    HRESULT _MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds);


    //
    //--- Public helpers
    //
 public:
    float GetEffectProgress(void) { return m_Progress; }
    ULONG GetNumInputs(void) { return m_ulNumInputs; }

    //
    //  Use these inline functions to access input and output objects
    //
    BOOL HaveInput(ULONG i = 0) { return (m_ulNumInputs > i && m_aInputs[i].m_pNativeInterface); }

    IDirect3DRMMeshBuilder3 * OutputMeshBuilder()
    {
        _ASSERT(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_Output.m_pNativeInterface;
    }

    IDXSurface * OutputSurface()
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return (IDXSurface *)m_Output.m_pNativeInterface;
    }

    IDirect3DRMMeshBuilder3 * InputMeshBuilder(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_aInputs[i].m_pNativeInterface;
    }

    IDXSurface * InputSurface(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return (IDXSurface *)m_aInputs[i].m_pNativeInterface;
    }

    DXSAMPLEFORMATENUM OutputSampleFormat(void)
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return m_Output.m_SampleFormat;
    }

    DXSAMPLEFORMATENUM InputSampleFormat(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return m_aInputs[i].m_SampleFormat;
    }

    BOOL HaveOutput(void) { return m_Output.m_pNativeInterface != NULL; }

    bool IsInputDirty(ULONG i = 0)
    {   
        _ASSERT(i < m_ulNumInputs);
        return m_aInputs[i].IsDirty();
    }

    bool IsOutputDirty()
    {   
        _ASSERT(HaveOutput());
        return m_Output.IsDirty();
    }

    //--- Public helpers.  Should be called with critical seciton claimed.
    inline BOOL DoOver(void) const
    { 
        return m_dwBltFlags & DXBOF_DO_OVER;
    }

    inline BOOL DoDither(void) const
    {
        return m_dwBltFlags & DXBOF_DITHER;
    }

    BOOL NeedSrcPMBuff(ULONG i = 0)
    {
        return ((m_dwBltFlags & DXBOF_DITHER) || InputSampleFormat(i) != DXPF_PMARGB32);
    }

    BOOL NeedDestPMBuff(void)
    {
        return OutputSampleFormat() != DXPF_PMARGB32;
    }

    void SetDirty() { m_dwGenerationId++; }
    void ClearDirty() { OnUpdateGenerationId(); m_dwCleanGenId = m_dwGenerationId; }
    BOOL IsTransformDirty() { OnUpdateGenerationId(); return m_dwCleanGenId != m_dwGenerationId; }

    
  public:
    //=== IObjectWithSite =======================================
    STDMETHOD( SetSite )( IUnknown *pUnkSite );
    STDMETHOD( GetSite )( REFIID riid, void ** ppvSite );

    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

  
      //=== IDXTransform ===============================================
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn,
                        IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID,
                          const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                  ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    STDMETHOD (PointPick) (const DXVEC *pPoint,
                           ULONG * pulInputSurfaceIndex,
                           DXVEC *pInputPoint);

    //
    //  Effect interface
    //
    //  NOTE:  Derived classes MUST implement get_Capabilities.  Use macros below.
    //
    STDMETHODIMP get_Capabilities(long *pVal) { _ASSERT(true); return E_NOTIMPL; }
    //
    //  All other methods are implemented in the base.
    //
    STDMETHODIMP get_Progress(float *pVal);
    STDMETHODIMP put_Progress(float newVal);
    STDMETHODIMP get_StepResolution(float *pVal);
    STDMETHODIMP get_Duration(float *pVal);
    STDMETHODIMP put_Duration(float newVal);

    //
    //  Helper functions derived classes can use
    //

    //
    //  Static function for registering in one or more component categories
    //
    static HRESULT RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                     ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);

};

//=== Inline Function Definitions ==================================

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_TRANSFORM(id, catid)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 1, &(catid), 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_TRANS_CATS(id, countimpl, pcatidsimpl, countreq, pcatidsreq)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), (count), (pcatids), (countreq), (pcatidsreq), bRegister); \
        } 

#define DECLARE_REGISTER_DX_IMAGE_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DXImageTransform)

#define DECLARE_REGISTER_DX_3D_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DX3DTransform)

#define DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DXImageTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_3D_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DX3DTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

//
//  Effect interface
//
#define DECLARE_GET_CAPABILITIES(Caps)\
STDMETHODIMP get_Capabilities(long *pVal) { if (DXIsBadWritePtr(pVal, sizeof(*pVal))) return E_POINTER; *pVal = Caps; return S_OK; }

#define DECLARE_GET_PROGRESS()\
        STDMETHODIMP get_Progress(float *pVal) { return CDXBaseNTo1::get_Progress(pVal); }

#define DECLARE_PUT_PROGRESS()\
        STDMETHODIMP put_Progress(float newVal) { return CDXBaseNTo1::put_Progress(newVal); }

#define DECLARE_GET_STEPRESOLUTION()\
        STDMETHODIMP get_StepResolution(float *pVal) { return CDXBaseNTo1::get_StepResolution(pVal); }
        
#define DECLARE_GET_DURATION()\
        STDMETHODIMP get_Duration(float *pVal) { return CDXBaseNTo1::get_Duration(pVal); }

#define DECLARE_PUT_DURATION()\
        STDMETHODIMP put_Duration(float newVal) { return CDXBaseNTo1::put_Duration(newVal); }
        
#define DECLARE_IDXEFFECT_METHODS(Caps)\
        DECLARE_GET_CAPABILITIES(Caps)\
        DECLARE_GET_PROGRESS()\
        DECLARE_PUT_PROGRESS()\
        DECLARE_GET_STEPRESOLUTION()\
        DECLARE_GET_DURATION()\
        DECLARE_PUT_DURATION()

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dvobj.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should include ole2.h instead of dvobj.h")
#endif /* !RC_INVOKED */

#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dvp.h
 *  Content:	DirectDrawVideoPort include file
 *
 ***************************************************************************/

#ifndef __DVP_INCLUDED__
#define __DVP_INCLUDED__

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && (!defined( _NO_COM ) || defined( DEFINE_GUID ))
DEFINE_GUID( IID_IDDVideoPortContainer,		0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawVideoPort,		0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );

DEFINE_GUID( DDVPTYPE_E_HREFH_VREFH, 0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFH_VREFL, 0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFH, 0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_E_HREFL_VREFL, 0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_CCIR656,	     0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID( DDVPTYPE_PHILIPS,	     0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
#endif

#ifndef GUID_DEFS_ONLY

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#endif //MAXULONG_PTR

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoPortContainer		FAR *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort		FAR *LPDIRECTDRAWVIDEOPORT;

typedef struct _DDVIDEOPORTCONNECT	FAR *LPDDVIDEOPORTCONNECT;
typedef struct _DDVIDEOPORTCAPS		FAR *LPDDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTDESC		FAR *LPDDVIDEOPORTDESC;
typedef struct _DDVIDEOPORTINFO		FAR *LPDDVIDEOPORTINFO;
typedef struct _DDVIDEOPORTBANDWIDTH	FAR *LPDDVIDEOPORTBANDWIDTH;
typedef struct _DDVIDEOPORTSTATUS	FAR *LPDDVIDEOPORTSTATUS;

typedef struct IDDVideoPortContainerVtbl DDVIDEOPORTCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoPortVtbl  DIRECTDRAWVIDEOPORTCALLBACKS;


/*
 * API's
 */
typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);


/*
 * INTERACES FOLLOW:
 *	IDirectDrawVideoPort
 *	IVideoPort
 */

/*
 * IDirectDrawVideoPortContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT FAR *, IUnknown FAR *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID,LPDDENUMVIDEOCALLBACK ) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT ) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IVideoPortContainer_Release(p)                      (p)->lpVtbl->Release(p)
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->lpVtbl->CreateVideoPort(p, a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->lpVtbl->EnumVideoPorts(p, a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->lpVtbl->GetVideoPortConnectInfo(p, a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->lpVtbl->QueryVideoPortStatus(p, a, b)
#else
#define IVideoPortContainer_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IVideoPortContainer_AddRef(p)                       (p)->AddRef()
#define IVideoPortContainer_Release(p)                      (p)->Release()
#define IVideoPortContainer_CreateVideoPort(p, a, b, c, d)  (p)->CreateVideoPort(a, b, c, d)
#define IVideoPortContainer_EnumVideoPorts(p, a, b, c, d)   (p)->EnumVideoPorts(a, b, c, d)
#define IVideoPortContainer_GetVideoPortConnectInfo(p, a, b, c) (p)->GetVideoPortConnectInfo(a, b, c)
#define IVideoPortContainer_QueryVideoPortStatus(p, a, b)   (p)->QueryVideoPortStatus(a, b)
#endif

#endif


/*
 * IDirectDrawVideoPort
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoPort_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoPort_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IVideoPort_Release(p)                   (p)->lpVtbl->Release(p)
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->lpVtbl->SetTargetSurface(p,a,b)
#define IVideoPort_Flip(p,a,b)			(p)->lpVtbl->Flip(p,a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->lpVtbl->GetBandwidthInfo(p,a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->lpVtbl->GetColorControls(p,a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->lpVtbl->GetInputFormats(p,a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->lpVtbl->GetOutputFormats(p,a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->lpVtbl->GetFieldPolarity(p,a)
#define IVideoPort_GetVideoLine(p,a)		(p)->lpVtbl->GetVideoLine(p,a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->lpVtbl->GetVideoSignalStatus(p,a)
#define IVideoPort_SetColorControls(p,a)	(p)->lpVtbl->SetColorControls(p,a)
#define IVideoPort_StartVideo(p,a)		(p)->lpVtbl->StartVideo(p,a)
#define IVideoPort_StopVideo(p)			(p)->lpVtbl->StopVideo(p)
#define IVideoPort_UpdateVideo(p,a)		(p)->lpVtbl->UpdateVideo(p,a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->lpVtbl->WaitForSync(p,a,b,c)
#else
#define IVideoPort_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IVideoPort_AddRef(p)                    (p)->AddRef()
#define IVideoPort_Release(p)                   (p)->Release()
#define IVideoPort_SetTargetSurface(p,a,b)	(p)->SetTargetSurface(a,b)
#define IVideoPort_Flip(p,a,b)			(p)->Flip(a,b)
#define IVideoPort_GetBandwidthInfo(p,a,b,c,d,e) (p)->GetBandwidthInfo(a,b,c,d,e)
#define IVideoPort_GetColorControls(p,a) 	(p)->GetColorControls(a)
#define IVideoPort_GetInputFormats(p,a,b,c)	(p)->GetInputFormats(a,b,c)
#define IVideoPort_GetOutputFormats(p,a,b,c,d)	(p)->GetOutputFormats(a,b,c,d)
#define IVideoPort_GetFieldPolarity(p,a)	(p)->GetFieldPolarity(a)
#define IVideoPort_GetVideoLine(p,a)		(p)->GetVideoLine(a)
#define IVideoPort_GetVideoSignalStatus(p,a)	(p)->GetVideoSignalStatus(a)
#define IVideoPort_SetColorControls(p,a)	(p)->SetColorControls(a)
#define IVideoPort_StartVideo(p,a)		(p)->StartVideo(a)
#define IVideoPort_StopVideo(p)			(p)->StopVideo()
#define IVideoPort_UpdateVideo(p,a)		(p)->UpdateVideo(a)
#define IVideoPort_WaitForSync(p,a,b,c)		(p)->WaitForSync(a,b,c)
#endif

#endif


/*
 * DDVIDEOPORTCONNECT
 */
typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT;


/*
 * DDVIDEOPORTCAPS
 */
typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;			// size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;			// indicates which fields contain data
    DWORD dwMaxWidth;			// max width of the video port field
    DWORD dwMaxVBIWidth;		// max width of the VBI data
    DWORD dwMaxHeight; 			// max height of the video port field
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;			// Video port capabilities
    DWORD dwFX;				// More video port capabilities
    DWORD dwNumAutoFlipSurfaces;	// Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;	// Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;// Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;	// Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;	// Byte restriction of cropping width
    DWORD dwPreshrinkXStep;		// Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;		// Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;	// Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;	// Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;              // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;              // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)
} DDVIDEOPORTCAPS;

/*
 * The dwMaxWidth and dwMaxVBIWidth members are valid
 */
#define DDVPD_WIDTH		0x00000001l

/*
 * The dwMaxHeight member is valid
 */
#define DDVPD_HEIGHT		0x00000002l

/*
 * The dwVideoPortID member is valid
 */
#define DDVPD_ID		0x00000004l

/*
 * The dwCaps member is valid
 */
#define DDVPD_CAPS		0x00000008l

/*
 * The dwFX member is valid
 */
#define DDVPD_FX		0x00000010l

/*
 * The dwNumAutoFlipSurfaces member is valid
 */
#define DDVPD_AUTOFLIP		0x00000020l

/*
 * All of the alignment members are valid
 */
#define DDVPD_ALIGN		0x00000040l

/*
 * The dwNumPreferredAutoflip member is valid
 */
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l

/*
 * The wNumFilterTapsX and wNumFilterTapsY fields are valid
 */
#define DDVPD_FILTERQUALITY     0x00000100l

/*
 * DDVIDEOPORTDESC
 */
typedef struct _DDVIDEOPORTDESC
{
    DWORD dwSize;			// size of the DDVIDEOPORTDESC structure
    DWORD dwFieldWidth;			// width of the video port field
    DWORD dwVBIWidth;			// width of the VBI data
    DWORD dwFieldHeight;		// height of the video port field
    DWORD dwMicrosecondsPerField;	// Microseconds per video field
    DWORD dwMaxPixelsPerSecond;		// Maximum pixel rate per second
    DWORD dwVideoPortID;		// Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwReserved1;			// Reserved for future use - set to zero (struct padding)
    DDVIDEOPORTCONNECT VideoPortType; 	// Description of video port connection
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved3;		// Reserved for future use - set to zero
} DDVIDEOPORTDESC;


/*
 * DDVIDEOPORTINFO
 */
typedef struct _DDVIDEOPORTINFO
{
    DWORD dwSize;			// Size of the structure
    DWORD dwOriginX;			// Placement of the video data within the surface.
    DWORD dwOriginY;			// Placement of the video data within the surface.
    DWORD dwVPFlags;			// Video port options
    RECT rCrop;				// Cropping rectangle (optional).
    DWORD dwPrescaleWidth;		// Determines pre-scaling/zooming in the X direction (optional).
    DWORD dwPrescaleHeight;		// Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;	// Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat; // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;// Output format of the data
    DWORD dwVBIHeight;			// Specifies the number of lines of data within the vertical blanking interval.
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTINFO;


/*
 * DDVIDEOPORTBANDWIDTH
 */
typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;			// Size of the structure
    DWORD dwCaps;
    DWORD dwOverlay;           		// Zoom factor at which overlay is supported
    DWORD dwColorkey;			// Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;		// Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey;		// Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported
    ULONG_PTR dwReserved1;		// Reserved for future use - set to zero
    ULONG_PTR dwReserved2;		// Reserved for future use - set to zero
} DDVIDEOPORTBANDWIDTH;


/*
 * DDVIDEOPORTSTATUS
 */
typedef struct _DDVIDEOPORTSTATUS
{
    DWORD dwSize;			// Size of the structure
    BOOL  bInUse;			// TRUE if video port is currently being used
    DWORD dwFlags;           		// Currently not used
    DWORD dwReserved1;			// Reserved for future use
    DDVIDEOPORTCONNECT VideoPortType;	// Information about the connection
    ULONG_PTR dwReserved2;		// Reserved for future use
    ULONG_PTR dwReserved3;		// Reserved for future use
} DDVIDEOPORTSTATUS;

/*============================================================================
 *
 * Video Port Flags
 *
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTCONNECT FLAGS
 *
 ****************************************************************************/

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of double clocking the data.
 * When this is set by the client, this indicates that the video port
 * should enable double clocking.  This flag is only valid with external
 * syncs.
 */
#define DDVPCONNECT_DOUBLECLOCK			0x00000001l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of using an external VACT
 * signal. When this is set by the client, this indicates that the
 * video port should use the external VACT signal.
 */
#define DDVPCONNECT_VACT			0x00000002l

/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l

/*
 * Indicates that any data written to the video port during the VREF
 * period will not be written into the frame buffer. This flag is read only.
 */
#define DDVPCONNECT_DISCARDSVREFDATA		0x00000008l

/*
 * When this is set be the driver and passed to the client, this
 * indicates that the device will write half lines into the frame buffer
 * if half lines are provided by the decoder.  If this is set by the client,
 * this indicates that the decoder will be supplying half lines.
 */
#define DDVPCONNECT_HALFLINE			0x00000010l

/*
 * Indicates that the signal is interlaced. This flag is only
 * set by the client.
 */
#define DDVPCONNECT_INTERLACED			0x00000020l

/*
 * Indicates that video port is shareable and that this video port
 * will use the even fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREEVEN			0x00000040l

/*
 * Indicates that video port is shareable and that this video port
 * will use the odd fields.  This flag is only set by the client.
 */
#define DDVPCONNECT_SHAREODD			0x00000080l

/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC CAPS
 *
 ****************************************************************************/

/*
 * Flip can be performed automatically to avoid tearing.
 */
#define DDVPCAPS_AUTOFLIP			0x00000001l

/*
 * Supports interlaced video
 */
#define DDVPCAPS_INTERLACED			0x00000002l

/*
 * Supports non-interlaced video
 */
#define DDVPCAPS_NONINTERLACED			0x00000004l

/*
 * Indicates that the device can return whether the current field
 * of an interlaced signal is even or odd.
 */
#define DDVPCAPS_READBACKFIELD			0x00000008l

/*
 * Indicates that the device can return the current line of video
 * being written into the frame buffer.
 */
#define DDVPCAPS_READBACKLINE			0x00000010l

/*
 * Allows two gen-locked video streams to share a single video port,
 * where one stream uses the even fields and the other uses the odd
 * fields. Separate parameters (including address, scaling,
 * cropping, etc.) are maintained for both fields.)
 */
#define DDVPCAPS_SHAREABLE			0x00000020l

/*
 * Even fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPEVENFIELDS			0x00000040l

/*
 * Odd fields of video can be automatically discarded.
 */
#define DDVPCAPS_SKIPODDFIELDS			0x00000080l

/*
 * Indicates that the device is capable of driving the graphics
 * VSYNC with the video port VSYNC.
 */
#define DDVPCAPS_SYNCMASTER			0x00000100l

/*
 * Indicates that data within the vertical blanking interval can
 * be written to a different surface.
 */
#define DDVPCAPS_VBISURFACE			0x00000200l

/*
 * Indicates that the video port can perform color operations
 * on the incoming data before it is written to the frame buffer.
 */
#define DDVPCAPS_COLORCONTROL			0x00000400l

/*
 * Indicates that the video port can accept VBI data in a different
 * width or format than the regular video data.
 */
#define DDVPCAPS_OVERSAMPLEDVBI			0x00000800l

/*
 * Indicates that the video port can write data directly to system memory
 */
#define DDVPCAPS_SYSTEMMEMORY			0x00001000l

/*
 * Indicates that the VBI and video portions of the video stream can
 * be controlled by an independent processes.
 */
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l

/*
 * Indicates that the video port contains high quality hardware
 * de-interlacing hardware that should be used instead of the
 * bob/weave algorithms.
 */
#define DDVPCAPS_HARDWAREDEINTERLACE		0x00004000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTDESC FX
 *
 ****************************************************************************/

/*
 * Limited cropping is available to crop out the vertical interval data.
 */
#define DDVPFX_CROPTOPDATA			0x00000001l

/*
 * Incoming data can be cropped in the X direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPX				0x00000002l

/*
 * Incoming data can be cropped in the Y direction before it is written
 * to the surface.
 */
#define DDVPFX_CROPY				0x00000004l

/*
 * Supports interleaving interlaced fields in memory.
 */
#define DDVPFX_INTERLEAVE			0x00000008l

/*
 * Supports mirroring left to right as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORLEFTRIGHT			0x00000010l

/*
 * Supports mirroring top to bottom as the video data is written
 * into the frame buffer.
 */
#define DDVPFX_MIRRORUPDOWN			0x00000020l

/*
 * Data can be arbitrarily shrunk in the X direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKX			0x00000040l

/*
 * Data can be arbitrarily shrunk in the Y direction before it
 * is written to the surface.
 */
#define DDVPFX_PRESHRINKY			0x00000080l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the X
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXB			0x00000100l

/*
 * Data can be binary shrunk (1/2, 1/4, 1/8, etc.) in the Y
 * direction before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYB			0x00000200l

/*
 * Data can be shrunk in increments of 1/x in the X direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKXS			0x00000400l

/*
 * Data can be shrunk in increments of 1/x in the Y direction
 * (where X is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep)
 * before it is written to the surface.
 */
#define DDVPFX_PRESHRINKYS			0x00000800l

/*
 * Data can be arbitrarily stretched in the X direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHX			0x00001000l

/*
 * Data can be arbitrarily stretched in the Y direction before
 * it is written to the surface.
 */
#define DDVPFX_PRESTRETCHY			0x00002000l

/*
 * Data can be integer stretched in the X direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHXN			0x00004000l

/*
 * Data can be integer stretched in the Y direction before it is
 * written to the surface.
 */
#define DDVPFX_PRESTRETCHYN			0x00008000l

/*
 * Indicates that data within the vertical blanking interval can
 * be converted independently of the remaining video data.
 */
#define DDVPFX_VBICONVERT			0x00010000l

/*
 * Indicates that scaling can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOSCALE			0x00020000l

/*
 * Indicates that the video data can ignore the left and right
 * cropping coordinates when cropping oversampled VBI data.
 */
#define DDVPFX_IGNOREVBIXCROP			0x00040000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVPFX_VBINOINTERLEAVE			0x00080000l


/****************************************************************************
 *
 * VIDEOPORT DDVIDEOPORTINFO FLAGS
 *
 ****************************************************************************/

/*
 * Perform automatic flipping.   Auto-flipping is performed between
 * the overlay surface that was attached to the video port using
 * IDirectDrawVideoPort::AttachSurface and the overlay surfaces that
 * are attached to the surface via the IDirectDrawSurface::AttachSurface
 * method.  The flip order is the order in which the overlay surfaces
 * were. attached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif	// GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvec.h ===
/**
*** INTEL CONFIDENTIAL
***
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
*** static char sccs_id[] = "@(#)dvec.h	1.3 02/11/99 11:11:55";
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *	File name : dvec.h  class definitions 
 *
 *	Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility. 
 *	Facilitates an easy transition to compiler intrinsics
 *	or assembly language. 
 *
 */

#ifndef DVEC_H_INCLUDED
#define DVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <iostream.h>
#include <fvec.h>

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */


/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized") 
   #endif
#endif

/* EMM Functionality Intrinsics */

class I8vec16;			/* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;			/* 16 elements, each element a signed char data type */
class Iu8vec16;			/* 16 elements, each element an unsigned char data type */	
class I16vec8;			/* 8 elements, each element a signed or unsigned short */
class Is16vec8;			/* 8 elements, each element a signed short */
class Iu16vec8;			/* 8 elements, each element an unsigned short */
class I32vec4;			/* 4 elements, each element a signed or unsigned long */
class Is32vec4;			/* 4 elements, each element a signed long */
class Iu32vec4;			/* 4 elements, each element a unsigned long */
class I64vec2;			/* 2 element, each a __m64 data type */
class I128vec1;			/* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

inline const __m128i get_mask128()
{
	static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
	return mask128;
}


/* M128 Class:
 * 1 element, a __m128i data type  
 * Contructors & Logical Operations 
 */

class M128  
{
protected:
		__m128i vec;

public:
	M128()									{ } 
	M128(__m128i mm)						{ vec = mm; }

	operator __m128i() const					{ return vec; }

	/* Logical Operations */
	M128& operator&=(const M128 &a)					{ return *this = (M128) _mm_and_si128(vec,a); }
	M128& operator|=(const M128 &a)					{ return *this = (M128) _mm_or_si128(vec,a); }
	M128& operator^=(const M128 &a)					{ return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)	{ return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)	{ return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)	{ return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)	{ return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type  
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128  
{
public:
	I128vec1()								{ }
	I128vec1(__m128i mm) : M128(mm)				{ }

	I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
	I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
	I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
	I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class: 
 * 2 elements, each element signed or unsigned 64-bit integer 
 */
class I64vec2 : public M128  
{
public:
	I64vec2() { }
	I64vec2(__m128i mm) : M128(mm) { }

	I64vec2(__m64 q1, __m64 q0)
	{ 
		_MM_2QW(0,vec) = *(__int64*)&q0;
		_MM_2QW(1,vec) = *(__int64*)&q1;
	}

	/* Assignment Operator */
	I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

	/* Logical Assignment Operators */
	I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
	I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
	I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I64vec2& operator +=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_add_epi64(vec,a); }
	I64vec2& operator -=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sub_epi64(vec,a); }   

	/* Shift Logical Operators */
	I64vec2 operator<<(const I64vec2 &a) 			{ return _mm_sll_epi64(vec,a); }
	I64vec2 operator<<(int count) 					{ return _mm_slli_epi64(vec,count); }
	I64vec2& operator<<=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sll_epi64(vec,a); }
	I64vec2& operator<<=(int count) 				{ return *this = (I64vec2) _mm_slli_epi64(vec,count); }
	I64vec2 operator>>(const I64vec2 &a) 			{ return _mm_srl_epi64(vec,a); }
	I64vec2 operator>>(int count) 					{ return _mm_srli_epi64(vec,count); }
	I64vec2& operator>>=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_srl_epi64(vec,a); }
	I64vec2& operator>>=(int count) 				{ return *this = (I64vec2) _mm_srli_epi64(vec,count); }

	/* Element Access for Debug, No data modified */
	const __int64& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	__int64& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	} 


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class: 
 * 4 elements, each element either a signed or unsigned int 
 */
class I32vec4 : public M128  
{
public:
	I32vec4() { }
	I32vec4(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I32vec4& operator= (const M128 &a)				{ return *this = (I32vec4) a; }

	/* Logicals Operators */
	I32vec4& operator&=(const M128 &a)				{ return *this = (I32vec4) _mm_and_si128(vec,a); }
	I32vec4& operator|=(const M128 &a)				{ return *this = (I32vec4) _mm_or_si128(vec,a); }
	I32vec4& operator^=(const M128 &a)				{ return *this = (I32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec4& operator +=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_add_epi32(vec,a); }
	I32vec4& operator -=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sub_epi32(vec,a); }   

	/* Shift Logical Operators */
	I32vec4 operator<<(const I32vec4 &a) 			{ return _mm_sll_epi32(vec,a); }
	I32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	I32vec4& operator<<=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sll_epi32(vec,a); }
	I32vec4& operator<<=(int count) 				{ return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class: 
 * 4 elements, each element signed integer 
 */
class Is32vec4 : public I32vec4  
{
public:
	Is32vec4() { }
	Is32vec4(__m128i mm) : I32vec4(mm) { }
	Is32vec4(int i3, int i2, int i1, int i0)
	{ 
		_MM_4DW(0,vec) = i0;
		_MM_4DW(1,vec) = i1;
		_MM_4DW(2,vec) = i2;
		_MM_4DW(3,vec) = i3;
	}	

	/* Assignment Operator */
	Is32vec4& operator= (const M128 &a)		{ return *this = (Is32vec4) a; }

	/* Logical Operators */
	Is32vec4& operator&=(const M128 &a)		{ return *this = (Is32vec4) _mm_and_si128(vec,a); }
	Is32vec4& operator|=(const M128 &a)		{ return *this = (Is32vec4) _mm_or_si128(vec,a); }
	Is32vec4& operator^=(const M128 &a)		{ return *this = (Is32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec4& operator +=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_add_epi32(vec,a); }
	Is32vec4& operator -=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_sub_epi32(vec,a); }   

	/* Shift Logical Operators */
	Is32vec4 operator<<(const M128 &a) 		{ return _mm_sll_epi32(vec,a); }
	Is32vec4 operator<<(int count) 			{ return _mm_slli_epi32(vec,count); }
	Is32vec4& operator<<=(const M128 &a)	{ return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
	Is32vec4& operator<<=(int count) 		{ return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec4 operator>>(const M128 &a) 		{ return _mm_sra_epi32(vec,a); } 
	Is32vec4 operator>>(int count) 			{ return _mm_srai_epi32(vec,count); }
	Is32vec4& operator>>=(const M128 &a)	{ return *this = (Is32vec4) _mm_sra_epi32(vec,a); } 
	Is32vec4& operator>>=(int count) 		{ return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Is32vec4 &a)
	{
		os << "[3]:" << _MM_4DW(3,a) 
			<< " [2]:" << _MM_4DW(2,a) 
			<< " [1]:" << _MM_4DW(1,a) 
			<< " [0]:" << _MM_4DW(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	} 

	/* Element Access for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	} 
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b) 	    	{ return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)			{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b) 		{ return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)		{ return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class: 
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4  
{
public:
	Iu32vec4() { }
	Iu32vec4(__m128i mm) : I32vec4(mm) { }
	Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
	{ 
		_MM_4UDW(0,vec) = ui0;
		_MM_4UDW(1,vec) = ui1;
		_MM_4UDW(2,vec) = ui2;
		_MM_4UDW(3,vec) = ui3;
	}

	/* Assignment Operator */
	Iu32vec4& operator= (const M128 &a)		{ return *this = (Iu32vec4) a; }

	/* Logical Assignment Operators */
	Iu32vec4& operator&=(const M128 &a)		{ return *this = (Iu32vec4) _mm_and_si128(vec,a); }
	Iu32vec4& operator|=(const M128 &a)		{ return *this = (Iu32vec4) _mm_or_si128(vec,a); }
	Iu32vec4& operator^=(const M128 &a)		{ return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec4& operator +=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
	Iu32vec4& operator -=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }   

	/* Shift Logical Operators */
	Iu32vec4 operator<<(const M128 &a) 				{ return _mm_sll_epi32(vec,a); }
	Iu32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	Iu32vec4& operator<<=(const M128 &a)			{ return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
	Iu32vec4& operator<<=(int count) 				{ return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
	Iu32vec4 operator>>(const M128 &a) 				{ return _mm_srl_epi32(vec,a); }
	Iu32vec4 operator>>(int count) 					{ return _mm_srli_epi32(vec,count); }
	Iu32vec4& operator>>=(const M128 &a)			{ return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
	Iu32vec4& operator>>=(int count) 				{ return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Iu32vec4 &a)
	{
		os << "[3]:" << _MM_4UDW(3,a) 
			<< " [2]:" << _MM_4UDW(2,a) 
			<< " [1]:" << _MM_4UDW(1,a) 
			<< " [0]:" << _MM_4UDW(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	} 
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)	{ return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class: 
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128  
{
public:
	I16vec8() { }
	I16vec8(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I16vec8& operator= (const M128 &a)		{ return *this = (I16vec8) a; }

	/* Logical Assignment Operators */
	I16vec8& operator&=(const M128 &a)		{ return *this = (I16vec8) _mm_and_si128(vec,a); }
	I16vec8& operator|=(const M128 &a)		{ return *this = (I16vec8) _mm_or_si128(vec,a); }
	I16vec8& operator^=(const M128 &a)		{ return *this = (I16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec8& operator +=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_add_epi16(vec,a); }
	I16vec8& operator -=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_sub_epi16(vec,a); }   
	I16vec8& operator *=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_mullo_epi16(vec,a); }   

	/* Shift Logical Operators */
	I16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	I16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	I16vec8& operator<<=(const M128 &a)				{ return *this = (I16vec8)_mm_sll_epi16(vec,a); }
	I16vec8& operator<<=(int count) 				{ return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)	{ return _mm_mullo_epi16(a,b); }   

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class: 
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8  
{
public:
	Is16vec8() { }
	Is16vec8(__m128i mm) : I16vec8(mm) { }
	Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
	 { 
		_MM_8W(0,vec) = s0;
		_MM_8W(1,vec) = s1;
		_MM_8W(2,vec) = s2;
		_MM_8W(3,vec) = s3;
		_MM_8W(4,vec) = s4;
		_MM_8W(5,vec) = s5;
		_MM_8W(6,vec) = s6;
		_MM_8W(7,vec) = s7;
	}

	/* Assignment Operator */
	Is16vec8& operator= (const M128 &a)		{ return *this = (Is16vec8) a; }

	/* Logical Assignment Operators */
	Is16vec8& operator&=(const M128 &a)		{ return *this = (Is16vec8) _mm_and_si128(vec,a); }
	Is16vec8& operator|=(const M128 &a)		{ return *this = (Is16vec8) _mm_or_si128(vec,a); }
	Is16vec8& operator^=(const M128 &a)		{ return *this = (Is16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec8& operator +=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_add_epi16(vec,a); }
	Is16vec8& operator -=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_sub_epi16(vec,a); }   
	Is16vec8& operator *=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }   

	/* Shift Logical Operators */
	Is16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Is16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	Is16vec8& operator<<=(const M128 &a)			{ return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
	Is16vec8& operator<<=(int count) 				{ return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
	/* Shift Arithmetic Operators */
	Is16vec8 operator>>(const M128 &a) 				{ return _mm_sra_epi16(vec,a); }
	Is16vec8 operator>>(int count) 				{ return _mm_srai_epi16(vec,count); }
	Is16vec8& operator>>=(const M128 &a)			{ return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
	Is16vec8& operator>>=(int count) 				{ return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

	/* Output for Debug */
	friend ostream& operator<< (ostream &os, const Is16vec8 &a)
	{
		os << "[7]:" << _MM_8W(7,a) 
			<< " [6]:" << _MM_8W(6,a) 
			<< " [5]:" << _MM_8W(5,a) 
			<< " [4]:" << _MM_8W(4,a) 
			<< " [3]:" << _MM_8W(3,a) 
			<< " [2]:" << _MM_8W(2,a) 
			<< " [1]:" << _MM_8W(1,a) 
			<< " [0]:" << _MM_8W(0,a);
		return os;
	}

	/* Element Access for Debug, No data modified */
	const signed short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	} 

	/* Element Access and Assignment for Debug */
	signed short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	} 
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mullo_epi16(a,b); }   


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_min_epi16(a,b); }


/* Iu16vec8 Class: 
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8  
{
public:
	Iu16vec8() { }
	Iu16vec8(__m128i mm) : I16vec8(mm) { }
	Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
	{ 
		_MM_8UW(0,vec) = s0;
		_MM_8UW(1,vec) = s1;
		_MM_8UW(2,vec) = s2;
		_MM_8UW(3,vec) = s3;
		_MM_8UW(4,vec) = s4;
		_MM_8UW(5,vec) = s5;
		_MM_8UW(6,vec) = s6;
		_MM_8UW(7,vec) = s7;
	}

	/* Assignment Operator */
	Iu16vec8& operator= (const M128 &a)		{ return *this = (Iu16vec8) a; }
	/* Logical Assignment Operators */
	Iu16vec8& operator&=(const M128 &a)		{ return *this = (Iu16vec8) _mm_and_si128(vec,a); }
	Iu16vec8& operator|=(const M128 &a)		{ return *this = (Iu16vec8) _mm_or_si128(vec,a); }
	Iu16vec8& operator^=(const M128 &a)		{ return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu16vec8& operator +=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
	Iu16vec8& operator -=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }   
	Iu16vec8& operator *=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }   

	/* Shift Logical Operators */
	Iu16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Iu16vec8 operator<<(int count) 					{ return _mm_slli_epi16(vec,count); }
	Iu16vec8& operator<<=(const M128 &a)			{ return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
	Iu16vec8& operator<<=(int count) 				{ return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
	Iu16vec8 operator>>(const M128 &a) 				{ return _mm_srl_epi16(vec,a); }
	Iu16vec8 operator>>(int count) 					{ return _mm_srli_epi16(vec,count); }
	Iu16vec8& operator>>=(const M128 &a)			{ return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
	Iu16vec8& operator>>=(int count) 				{ return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


	/* Output for Debug */
	friend ostream& operator << (ostream &os, const Iu16vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UW(7,a)) 
			<< " [6]:" << unsigned short(_MM_8UW(6,a)) 
			<< " [5]:" << unsigned short(_MM_8UW(5,a)) 
			<< " [4]:" << unsigned short(_MM_8UW(4,a)) 
			<< " [3]:" << unsigned short(_MM_8UW(3,a)) 
			<< " [2]:" << unsigned short(_MM_8UW(2,a)) 
			<< " [1]:" << unsigned short(_MM_8UW(1,a)) 
			<< " [0]:" << unsigned short(_MM_8UW(0,a));
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	} 

	/* Element Access for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	} 
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mullo_epi16(a,b); }   

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class: 
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128  
{
public:
	I8vec16() { }
	I8vec16(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I8vec16& operator= (const M128 &a)		{ return *this = (I8vec16) a; }

	/* Logical Assignment Operators */
	I8vec16& operator&=(const M128 &a)		{ return *this = (I8vec16) _mm_and_si128(vec,a); }
	I8vec16& operator|=(const M128 &a)		{ return *this = (I8vec16) _mm_or_si128(vec,a); }
	I8vec16& operator^=(const M128 &a)		{ return *this = (I8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec16& operator +=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_add_epi8(vec,a); }
	I8vec16& operator -=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_sub_epi8(vec,a); }   

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)	{ return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class: 
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16  
{
public:
	Is8vec16() { }
	Is8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Is8vec16& operator= (const M128 &a)		{ return *this = (Is8vec16) a; }

	/* Logical Assignment Operators */
	Is8vec16& operator&=(const M128 &a)		{ return *this = (Is8vec16) _mm_and_si128(vec,a); }
	Is8vec16& operator|=(const M128 &a)		{ return *this = (Is8vec16) _mm_or_si128(vec,a); }
	Is8vec16& operator^=(const M128 &a)		{ return *this = (Is8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec16& operator +=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_add_epi8(vec,a); }
	Is8vec16& operator -=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_sub_epi8(vec,a); }   

	/* Output for Debug */
	friend ostream& operator << (ostream &os, const Is8vec16 &a)
	{
		 os << "[15]:"  << short(_MM_16B(15,a)) 
			<< " [14]:" << short(_MM_16B(14,a)) 
			<< " [13]:" << short(_MM_16B(13,a)) 
			<< " [12]:" << short(_MM_16B(12,a)) 
			<< " [11]:" << short(_MM_16B(11,a)) 
			<< " [10]:" << short(_MM_16B(10,a)) 
			<< " [9]:" << short(_MM_16B(9,a)) 
			<< " [8]:" << short(_MM_16B(8,a))
		      << " [7]:" << short(_MM_16B(7,a)) 
			<< " [6]:" << short(_MM_16B(6,a)) 
			<< " [5]:" << short(_MM_16B(5,a)) 
			<< " [4]:" << short(_MM_16B(4,a)) 
			<< " [3]:" << short(_MM_16B(3,a)) 
			<< " [2]:" << short(_MM_16B(2,a)) 
			<< " [1]:" << short(_MM_16B(1,a)) 
			<< " [0]:" << short(_MM_16B(0,a));
		return os;
	}

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	} 

	/* Element Access for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	} 

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class: 
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16  
{
public:
	Iu8vec16() { }
	Iu8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Iu8vec16& operator= (const M128 &a)		{ return *this = (Iu8vec16) a; }

	/* Logical Assignment Operators */
	Iu8vec16& operator&=(const M128 &a)		{ return *this = (Iu8vec16) _mm_and_si128(vec,a); }
	Iu8vec16& operator|=(const M128 &a)		{ return *this = (Iu8vec16) _mm_or_si128(vec,a); }
	Iu8vec16& operator^=(const M128 &a)		{ return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu8vec16& operator +=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
	Iu8vec16& operator -=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }   

	/* Output for Debug */
	friend ostream& operator << (ostream &os, const Iu8vec16 &a)
	{
		 os << "[15]:"  << unsigned short(_MM_16UB(15,a)) 
			<< " [14]:" << unsigned short(_MM_16UB(14,a)) 
			<< " [13]:" << unsigned short(_MM_16UB(13,a)) 
			<< " [12]:" << unsigned short(_MM_16UB(12,a)) 
			<< " [11]:" << unsigned short(_MM_16UB(11,a)) 
			<< " [10]:" << unsigned short(_MM_16UB(10,a)) 
			<< " [9]:" << unsigned short(_MM_16UB(9,a)) 
			<< " [8]:" << unsigned short(_MM_16UB(8,a))
		      << " [7]:" << unsigned short(_MM_16UB(7,a)) 
			<< " [6]:" << unsigned short(_MM_16UB(6,a)) 
			<< " [5]:" << unsigned short(_MM_16UB(5,a)) 
			<< " [4]:" << unsigned short(_MM_16UB(4,a)) 
			<< " [3]:" << unsigned short(_MM_16UB(3,a)) 
			<< " [2]:" << unsigned short(_MM_16UB(2,a)) 
			<< " [1]:" << unsigned short(_MM_16UB(1,a)) 
			<< " [0]:" << unsigned short(_MM_16UB(0,a));
		return os;
	}

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	} 

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	} 

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b) 	{ return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); } 

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( (mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 ))));	\
}												
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)
		
	
#undef IVEC128_SELECT


class F64vec2
{
protected:
   	 __m128d vec;
public:
	
	/* Constructors: __m128d, 2 doubles */
	F64vec2() {}
	
	/* initialize 2 DP FP with __m128d data type */	
	F64vec2(__m128d m)					{ vec = m;}

	/* initialize 2 DP FPs with 2 doubles */	
	F64vec2(double d1, double d0)		                { vec= _mm_set_pd(d1,d0); }

	/* Explicitly initialize each of 2 DP FPs with same double */	
	EXPLICIT F64vec2(double d)	{ vec = _mm_set1_pd(d); }	

	/* Conversion functions */
	operator  __m128d() const	{ return vec; }		/* Convert to __m128d */

 	/* Logical Operators */
	friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
	friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
	friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

	/* Arithmetic Operators */
	friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
	friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); } 
	friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); } 
	friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

	F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
	F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }   
	F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); } 
	F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
	F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
	F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
	F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

	/* Horizontal Add */
	friend double add_horizontal(F64vec2 &a) 
	{ 
		F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
		return ftemp[0];
	}

	/* And Not */
	friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

	/* Square Root */
	friend F64vec2 sqrt(const F64vec2 &a)		{ return _mm_sqrt_pd(a); }	 

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example: 
			friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b) 
			{ return _mm_cmpeq_ps(a,b);} */
	#define F64vec2_COMP(op) \
	friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
		F64vec2_COMP(eq)					// expanded to cmpeq(a,b)
		F64vec2_COMP(lt)					// expanded to cmplt(a,b)
		F64vec2_COMP(le)					// expanded to cmple(a,b)	
		F64vec2_COMP(gt)					// expanded to cmpgt(a,b)
		F64vec2_COMP(ge)					// expanded to cmpge(a,b)
		F64vec2_COMP(ngt)					// expanded to cmpngt(a,b)
		F64vec2_COMP(nge)					// expanded to cmpnge(a,b)
		F64vec2_COMP(neq)					// expanded to cmpneq(a,b)
		F64vec2_COMP(nlt)					// expanded to cmpnlt(a,b)
		F64vec2_COMP(nle)					// expanded to cmpnle(a,b)
	#undef F64vec2_COMP

	/* Min and Max */
	friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
	friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
	#define F64vec2_COMI(op) \
	friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
		F64vec2_COMI(eq)					// expanded to comieq(a,b)
		F64vec2_COMI(lt)					// expanded to comilt(a,b)
		F64vec2_COMI(le)					// expanded to comile(a,b)	
		F64vec2_COMI(gt)					// expanded to comigt(a,b)
		F64vec2_COMI(ge)					// expanded to comige(a,b)
		F64vec2_COMI(neq)					// expanded to comineq(a,b)
	#undef F64vec2_COMI

        /* Compare lower DP FP values */
	#define F64vec2_UCOMI(op) \
	friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
		F64vec2_UCOMI(eq)					// expanded to ucomieq(a,b)
		F64vec2_UCOMI(lt)					// expanded to ucomilt(a,b)
		F64vec2_UCOMI(le)					// expanded to ucomile(a,b)	
		F64vec2_UCOMI(gt)					// expanded to ucomigt(a,b)
		F64vec2_UCOMI(ge)					// expanded to ucomige(a,b)
		F64vec2_UCOMI(neq)					// expanded to ucomineq(a,b)
	#undef F64vec2_UCOMI

	/* Debug Features */
	/* Output */
	friend ostream & operator<<(ostream & os, const F64vec2 &a)	
	{
	/* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */ 
	  double *dp = (double*)&a;
		cout <<	" [1]:" << *(dp+1) 
			<< " [0]:" << *dp;
		return os;
	}
	/* Element Access Only, no modifications to elements*/
	const double& operator[](int i) const				
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
	/* Element Access and Modification*/
	double& operator[](int i)				
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
};

						/* Miscellaneous */
		
/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b) 	
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b) 	
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)	
{ return _mm_movemask_pd(a);}					

						/* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)	
{ a = _mm_loadu_pd(p); }									

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)	
{ _mm_storeu_pd(p, a); }							

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a) 
{ _mm_stream_pd(p,a);}					

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d) 	   \
{																\
	F64vec2 mask = _mm_cmp##op##_pd(a,b);						\
	return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d))));	\
}												
F64vec2_SELECT(eq)		// generates select_eq(a,b)
F64vec2_SELECT(lt)		// generates select_lt(a,b)
F64vec2_SELECT(le)		// generates select_le(a,b)	
F64vec2_SELECT(gt)		// generates select_gt(a,b)
F64vec2_SELECT(ge)		// generates select_ge(a,b)
F64vec2_SELECT(neq)		// generates select_neq(a,b)
F64vec2_SELECT(nlt)		// generates select_nlt(a,b)
F64vec2_SELECT(nle)		// generates select_nle(a,b)
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{ 

	return _mm_cvttsd_si32(a);
 
}  

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{ 
	return _mm_cvtps_pd(a);
}  

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{ 
	return _mm_cvtpd_ps(a);
}  

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{ 
	return _mm_cvtsi32_sd(a,b);
}  

#pragma pack(pop) /* 16-B aligned */
#endif // DVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dx7todx8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dx7todx8.h
 *  Content:    DX7 to DX8 Direct3D aliases to aid porting DX7 apps to DX8
 *
 ***************************************************************************/

#ifndef _DX7TODX8_H_

///////////////////////////////////////////////////////////////////////////////
//
// d3d8types.h
//
///////////////////////////////////////////////////////////////////////////////

#define D3DTRANSFORMSTATE_WORLD                 D3DTS_WORLD
#define D3DTRANSFORMSTATE_VIEW                  D3DTS_VIEW
#define D3DTRANSFORMSTATE_PROJECTION            D3DTS_PROJECTION
#define D3DTRANSFORMSTATE_WORLD1                D3DTS_WORLD1
#define D3DTRANSFORMSTATE_WORLD2                D3DTS_WORLD2
#define D3DTRANSFORMSTATE_WORLD3                D3DTS_WORLD3
#define D3DTRANSFORMSTATE_TEXTURE0              D3DTS_TEXTURE0
#define D3DTRANSFORMSTATE_TEXTURE1              D3DTS_TEXTURE1
#define D3DTRANSFORMSTATE_TEXTURE2              D3DTS_TEXTURE2
#define D3DTRANSFORMSTATE_TEXTURE3              D3DTS_TEXTURE3
#define D3DTRANSFORMSTATE_TEXTURE4              D3DTS_TEXTURE4
#define D3DTRANSFORMSTATE_TEXTURE5              D3DTS_TEXTURE5
#define D3DTRANSFORMSTATE_TEXTURE6              D3DTS_TEXTURE6
#define D3DTRANSFORMSTATE_TEXTURE7              D3DTS_TEXTURE7
#define D3DTRANSFORMSTATE_FORCE_DWORD           D3DTS_FORCE_DWORD

#define D3DRENDERSTATE_ZENABLE                  D3DRS_ZENABLE
#define D3DRENDERSTATE_FILLMODE                 D3DRS_FILLMODE
#define D3DRENDERSTATE_SHADEMODE                D3DRS_SHADEMODE
#define D3DRENDERSTATE_LINEPATTERN              D3DRS_LINEPATTERN
#define D3DRENDERSTATE_ZWRITEENABLE             D3DRS_ZWRITEENABLE
#define D3DRENDERSTATE_ALPHATESTENABLE          D3DRS_ALPHATESTENABLE
#define D3DRENDERSTATE_LASTPIXEL                D3DRS_LASTPIXEL
#define D3DRENDERSTATE_SRCBLEND                 D3DRS_SRCBLEND
#define D3DRENDERSTATE_DESTBLEND                D3DRS_DESTBLEND
#define D3DRENDERSTATE_CULLMODE                 D3DRS_CULLMODE
#define D3DRENDERSTATE_ZFUNC                    D3DRS_ZFUNC
#define D3DRENDERSTATE_ALPHAREF                 D3DRS_ALPHAREF
#define D3DRENDERSTATE_ALPHAFUNC                D3DRS_ALPHAFUNC
#define D3DRENDERSTATE_DITHERENABLE             D3DRS_DITHERENABLE
#define D3DRENDERSTATE_ALPHABLENDENABLE         D3DRS_ALPHABLENDENABLE
#define D3DRENDERSTATE_FOGENABLE                D3DRS_FOGENABLE
#define D3DRENDERSTATE_SPECULARENABLE           D3DRS_SPECULARENABLE
#define D3DRENDERSTATE_ZVISIBLE                 D3DRS_ZVISIBLE
#define D3DRENDERSTATE_FOGCOLOR                 D3DRS_FOGCOLOR
#define D3DRENDERSTATE_FOGTABLEMODE             D3DRS_FOGTABLEMODE
#define D3DRENDERSTATE_FOGSTART                 D3DRS_FOGSTART
#define D3DRENDERSTATE_FOGEND                   D3DRS_FOGEND
#define D3DRENDERSTATE_FOGDENSITY               D3DRS_FOGDENSITY
#define D3DRENDERSTATE_EDGEANTIALIAS            D3DRS_EDGEANTIALIAS
#define D3DRENDERSTATE_ZBIAS                    D3DRS_ZBIAS
#define D3DRENDERSTATE_RANGEFOGENABLE           D3DRS_RANGEFOGENABLE
#define D3DRENDERSTATE_STENCILENABLE            D3DRS_STENCILENABLE
#define D3DRENDERSTATE_STENCILFAIL              D3DRS_STENCILFAIL
#define D3DRENDERSTATE_STENCILZFAIL             D3DRS_STENCILZFAIL
#define D3DRENDERSTATE_STENCILPASS              D3DRS_STENCILPASS
#define D3DRENDERSTATE_STENCILFUNC              D3DRS_STENCILFUNC
#define D3DRENDERSTATE_STENCILREF               D3DRS_STENCILREF
#define D3DRENDERSTATE_STENCILMASK              D3DRS_STENCILMASK
#define D3DRENDERSTATE_STENCILWRITEMASK         D3DRS_STENCILWRITEMASK
#define D3DRENDERSTATE_TEXTUREFACTOR            D3DRS_TEXTUREFACTOR
#define D3DRENDERSTATE_WRAP0                    D3DRS_WRAP0
#define D3DRENDERSTATE_WRAP1                    D3DRS_WRAP1
#define D3DRENDERSTATE_WRAP2                    D3DRS_WRAP2
#define D3DRENDERSTATE_WRAP3                    D3DRS_WRAP3
#define D3DRENDERSTATE_WRAP4                    D3DRS_WRAP4
#define D3DRENDERSTATE_WRAP5                    D3DRS_WRAP5
#define D3DRENDERSTATE_WRAP6                    D3DRS_WRAP6
#define D3DRENDERSTATE_WRAP7                    D3DRS_WRAP7
#define D3DRENDERSTATE_CLIPPING                 D3DRS_CLIPPING
#define D3DRENDERSTATE_LIGHTING                 D3DRS_LIGHTING
#define D3DRENDERSTATE_EXTENTS                  D3DRS_EXTENTS
#define D3DRENDERSTATE_AMBIENT                  D3DRS_AMBIENT
#define D3DRENDERSTATE_FOGVERTEXMODE            D3DRS_FOGVERTEXMODE
#define D3DRENDERSTATE_COLORVERTEX              D3DRS_COLORVERTEX
#define D3DRENDERSTATE_LOCALVIEWER              D3DRS_LOCALVIEWER
#define D3DRENDERSTATE_NORMALIZENORMALS         D3DRS_NORMALIZENORMALS
#define D3DRENDERSTATE_DIFFUSEMATERIALSOURCE    D3DRS_DIFFUSEMATERIALSOURCE
#define D3DRENDERSTATE_SPECULARMATERIALSOURCE   D3DRS_SPECULARMATERIALSOURCE
#define D3DRENDERSTATE_AMBIENTMATERIALSOURCE    D3DRS_AMBIENTMATERIALSOURCE
#define D3DRENDERSTATE_EMISSIVEMATERIALSOURCE   D3DRS_EMISSIVEMATERIALSOURCE
#define D3DRENDERSTATE_VERTEXBLEND              D3DRS_VERTEXBLEND
#define D3DRENDERSTATE_CLIPPLANEENABLE          D3DRS_CLIPPLANEENABLE

#define RGBA_MAKE                               D3DCOLOR_RGBA
#define RGB_MAKE                                D3DCOLOR_XRGB
#define D3DRGBA                                 D3DCOLOR_COLORVALUE
#define D3DRGB(_r,_g,_b)                        D3DCOLOR_COLORVALUE(_r,_g,_b,1.f)

#define _DX7TODX8_H_
#endif //_DX7TODX8_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxatlpb.h ===
#ifndef dxatlpb_h
#define dxatlpb_h

#include <atlctl.h>

#ifndef DXTDbg_h
#include <dxtdbg.h>
#endif

#define COM_INTERFACE_ENTRY_DXIMPL(x)\
	COM_INTERFACE_ENTRY_IID(IID_##x, x##DXImpl<_ComMapClass>)

/*** IOleObjectDXImpl
*   This is a simplified version used to allow a transform
*   to be hosted by IE
*/
template <class T>
class ATL_NO_VTABLE IOleObjectDXImpl
{
  public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        STDMETHOD_(ULONG,AddRef)() = 0;
        STDMETHOD_(ULONG,Release)() = 0;

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetClientSite" );
        HRESULT hr = S_OK;
        if( pClientSite && DXIsBadInterfacePtr( pClientSite ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            pT->m_cpOleClientSite = pClientSite;
        }
        return hr;
	}

	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClientSite" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( ppClientSite, sizeof( *ppClientSite )) )
        {
            hr = E_POINTER;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            *ppClientSite = pT->m_cpOleClientSite;
        }
        return hr;
	}

	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetHostNames" );
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Close" );
		return S_OK;
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::InitFromData" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClipboardData" );
        return E_NOTIMPL;
	}

	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return S_OK;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return OLEOBJ_E_NOVERBS;
	}
	STDMETHOD(Update)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Update" );
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::IsUpToDate" );
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserClassID" );
		_ASSERTE(pClsid);
		if( DXIsBadWritePtr( pClsid, sizeof( *pClsid ) ) )
        {
			return E_POINTER;
        }
        else
        {
		    *pClsid = T::GetObjectCLSID();
		    return S_OK;
        }
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserType" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetExtent" );
        return S_OK;
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetExtent" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( psizel, sizeof( *psizel ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            psizel->cx = 0;
            psizel->cy = 0;
        }
		return hr;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Advise" );
        return S_OK;
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Unadvise" );
        return S_OK;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::EnumAdvise" );
        return E_FAIL;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMiscStatus" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetColorScheme" );
        return E_NOTIMPL;
	}
};

/*** CComPropBase
*
*/
class ATL_NO_VTABLE CComPropBase
{
public:
    HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
	    LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
    {
	    USES_CONVERSION;
	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		    if (FAILED(hr))
		    {
			    if (hr == E_INVALIDARG)
			    {
				    ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
			    }
			    else
			    {
				    // Many containers return different ERROR values for Member not found
				    ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
			    }
			    continue;
		    }

		    if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }
	    }
	    return S_OK;

    }

    HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	    BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap)
    {
	    if (pPropBag == NULL)
	    {
		    ATLTRACE(_T("PropBag pointer passed in was invalid\n"));
		    return E_POINTER;
	    }

	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		    {
			    if (var.punkVal == NULL)
			    {
				    ATLTRACE(_T("Warning skipping empty IUnknown in Save\n"));
				    continue;
			    }
		    }

		    HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		    if (FAILED(hr))
			    return hr;
	    }
	    m_bRequiresSave = FALSE;
	    return S_OK;
    }

    HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
	    ATL_PROPMAP_ENTRY* pMap)
    {
	    _ASSERTE(pMap != NULL);
	    int nCnt = 0;
	    // Get count of unique pages
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
			    nCnt++;
	    }
	    pPages->pElems = NULL;
	    pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
	    if (pPages->pElems == NULL)
		    return E_OUTOFMEMORY;
	    nCnt = 0;
	    for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
		    {
			    BOOL bMatch = FALSE;
			    for (int j=0;j<nCnt;j++)
			    {
				    if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
				    {
					    bMatch = TRUE;
					    break;
				    }
			    }
			    if (!bMatch)
				    pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
		    }
	    }
	    pPages->cElems = nCnt;
	    return S_OK;
    }
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv) = 0;
    BOOL m_bRequiresSave;
};


template <class T>
class ATL_NO_VTABLE CComPropertySupport :  public CComPropBase
{
public:
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv)
    {
        T* pT = static_cast<T*>(this);
	return pT->_InternalQueryInterface(iid, ppv);
    }
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T> 
class ATL_NO_VTABLE IObjectSafetyImpl2
{
public:
        DWORD m_dwSafety[4];
        const IID *m_pIID[4];

        IObjectSafetyImpl2()
	{
            m_pIID[0] = &IID_IDispatch;
            m_pIID[1] = &IID_IPersistPropertyBag;
            m_pIID[2] = &IID_IPersistStorage;
            m_pIID[3] = &IID_IPersistStream;
            for (int i = 0; i < 4; i++)
            {
		m_dwSafety[i] = 0;
            }
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl2)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety[i] & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
                        return S_OK;
                    }
		}
            	*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		return E_NOINTERFACE;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			m_dwSafety[i] = dwEnabledOptions & dwOptionSetMask;
                        return S_OK;
                    }
		}
		return E_NOINTERFACE;
	}

};

#endif // This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxfile.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxfile.h
 *
 *  Content:    DirectX File public header file
 *
 ***************************************************************************/

#ifndef __DXFILE_H__
#define __DXFILE_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD DXFILEFORMAT;

#define DXFILEFORMAT_BINARY     0
#define DXFILEFORMAT_TEXT       1
#define DXFILEFORMAT_COMPRESSED 2

typedef DWORD DXFILELOADOPTIONS;

#define DXFILELOAD_FROMFILE  0x00L
#define DXFILELOAD_FROMRESOURCE 0x01L
#define DXFILELOAD_FROMMEMORY 0x02L
#define DXFILELOAD_FROMSTREAM 0x04L
#define DXFILELOAD_FROMURL 0x08L

typedef struct _DXFILELOADRESOURCE {
    HMODULE hModule;
    LPCTSTR lpName;
    LPCTSTR lpType;
}DXFILELOADRESOURCE, *LPDXFILELOADRESOURCE;

typedef struct _DXFILELOADMEMORY {
    LPVOID lpMemory;
    DWORD dSize;
}DXFILELOADMEMORY, *LPDXFILELOADMEMORY;

/*
 * DirectX File object types.
 */

#ifndef WIN_TYPES
#define WIN_TYPES(itype, ptype) typedef interface itype *LP##ptype, **LPLP##ptype
#endif

WIN_TYPES(IDirectXFile,                 DIRECTXFILE);
WIN_TYPES(IDirectXFileEnumObject,       DIRECTXFILEENUMOBJECT);
WIN_TYPES(IDirectXFileSaveObject,       DIRECTXFILESAVEOBJECT);
WIN_TYPES(IDirectXFileObject,           DIRECTXFILEOBJECT);
WIN_TYPES(IDirectXFileData,             DIRECTXFILEDATA);
WIN_TYPES(IDirectXFileDataReference,    DIRECTXFILEDATAREFERENCE);
WIN_TYPES(IDirectXFileBinary,           DIRECTXFILEBINARY);

/*
 * API for creating IDirectXFile interface.
 */

STDAPI DirectXFileCreate(LPDIRECTXFILE *lplpDirectXFile);

/*
 * The methods for IUnknown
 */

#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)       (THIS) kind; \
    STDMETHOD_(ULONG, Release)      (THIS) kind

/*
 * The methods for IDirectXFileObject
 */

#define IDIRECTXFILEOBJECT_METHODS(kind) \
    STDMETHOD(GetName) (THIS_ LPSTR, LPDWORD) kind; \
    STDMETHOD(GetId) (THIS_ LPGUID) kind

/*
 * DirectX File interfaces.
 */

#undef INTERFACE
#define INTERFACE IDirectXFile

DECLARE_INTERFACE_(IDirectXFile, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(CreateEnumObject) (THIS_ LPVOID, DXFILELOADOPTIONS,
                                 LPDIRECTXFILEENUMOBJECT *) PURE;
    STDMETHOD(CreateSaveObject) (THIS_ LPCSTR, DXFILEFORMAT,
                                 LPDIRECTXFILESAVEOBJECT *) PURE;
    STDMETHOD(RegisterTemplates) (THIS_ LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileEnumObject

DECLARE_INTERFACE_(IDirectXFileEnumObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(GetNextDataObject)    (THIS_ LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectById)    (THIS_ REFGUID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectByName)  (THIS_ LPCSTR, LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileSaveObject

DECLARE_INTERFACE_(IDirectXFileSaveObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(SaveTemplates) (THIS_ DWORD, const GUID **) PURE;
    STDMETHOD(CreateDataObject) (THIS_ REFGUID, LPCSTR, const GUID *,
                                 DWORD, LPVOID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(SaveData) (THIS_ LPDIRECTXFILEDATA) PURE;
};


#undef INTERFACE
#define INTERFACE IDirectXFileObject

DECLARE_INTERFACE_(IDirectXFileObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirectXFileData

DECLARE_INTERFACE_(IDirectXFileData, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetData)          (THIS_ LPCSTR, DWORD *, void **) PURE;
    STDMETHOD(GetType)          (THIS_ const GUID **) PURE;
    STDMETHOD(GetNextObject)    (THIS_ LPDIRECTXFILEOBJECT *) PURE;
    STDMETHOD(AddDataObject)    (THIS_ LPDIRECTXFILEDATA) PURE;
    STDMETHOD(AddDataReference) (THIS_ LPCSTR, const GUID *) PURE;
    STDMETHOD(AddBinaryObject)  (THIS_ LPCSTR, const GUID *, LPCSTR, LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileDataReference

DECLARE_INTERFACE_(IDirectXFileDataReference, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(Resolve) (THIS_ LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileBinary

DECLARE_INTERFACE_(IDirectXFileBinary, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetSize)      (THIS_ DWORD *) PURE;
    STDMETHOD(GetMimeType)  (THIS_ LPCSTR *) PURE;
    STDMETHOD(Read)         (THIS_ LPVOID, DWORD, LPDWORD) PURE;
};

/*
 * DirectXFile Object Class Id (for CoCreateInstance())
 */

DEFINE_GUID(CLSID_CDirectXFile, 0x4516ec43, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

/*
 * DirectX File Interface GUIDs.
 */

DEFINE_GUID(IID_IDirectXFile,               0x3d82ab40, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileEnumObject,     0x3d82ab41, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileSaveObject,     0x3d82ab42, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileObject,         0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileData,           0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileDataReference,  0x3d82ab45, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileBinary,         0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/*
 * DirectX File Header template's GUID.
 */

DEFINE_GUID(TID_DXFILEHeader,   0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);


/*
 * DirectX File errors.
 */

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#define DXFILE_OK   0

#define DXFILEERR_BADOBJECT                 MAKE_DDHRESULT(850)
#define DXFILEERR_BADVALUE                  MAKE_DDHRESULT(851)
#define DXFILEERR_BADTYPE                   MAKE_DDHRESULT(852)
#define DXFILEERR_BADSTREAMHANDLE           MAKE_DDHRESULT(853)
#define DXFILEERR_BADALLOC                  MAKE_DDHRESULT(854)
#define DXFILEERR_NOTFOUND                  MAKE_DDHRESULT(855)
#define DXFILEERR_NOTDONEYET                MAKE_DDHRESULT(856)
#define DXFILEERR_FILENOTFOUND              MAKE_DDHRESULT(857)
#define DXFILEERR_RESOURCENOTFOUND          MAKE_DDHRESULT(858)
#define DXFILEERR_URLNOTFOUND               MAKE_DDHRESULT(859)
#define DXFILEERR_BADRESOURCE               MAKE_DDHRESULT(860)
#define DXFILEERR_BADFILETYPE               MAKE_DDHRESULT(861)
#define DXFILEERR_BADFILEVERSION            MAKE_DDHRESULT(862)
#define DXFILEERR_BADFILEFLOATSIZE          MAKE_DDHRESULT(863)
#define DXFILEERR_BADFILECOMPRESSIONTYPE    MAKE_DDHRESULT(864)
#define DXFILEERR_BADFILE                   MAKE_DDHRESULT(865)
#define DXFILEERR_PARSEERROR                MAKE_DDHRESULT(866)
#define DXFILEERR_NOTEMPLATE                MAKE_DDHRESULT(867)
#define DXFILEERR_BADARRAYSIZE              MAKE_DDHRESULT(868)
#define DXFILEERR_BADDATAREFERENCE          MAKE_DDHRESULT(869)
#define DXFILEERR_INTERNALERROR             MAKE_DDHRESULT(870)
#define DXFILEERR_NOMOREOBJECTS             MAKE_DDHRESULT(871)
#define DXFILEERR_BADINTRINSICS             MAKE_DDHRESULT(872)
#define DXFILEERR_NOMORESTREAMHANDLES       MAKE_DDHRESULT(873)
#define DXFILEERR_NOMOREDATA                MAKE_DDHRESULT(874)
#define DXFILEERR_BADCACHEFILE              MAKE_DDHRESULT(875)
#define DXFILEERR_NOINTERNET                MAKE_DDHRESULT(876)


#ifdef __cplusplus
};
#endif

#endif /* _DXFILE_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvoice.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
 ***************************************************************************/

#ifndef __DVOICE__
#define __DVOICE__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsound.h"

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 * DirectPlayVoice CLSIDs
 *
 ****************************************************************************/


// {B9F3EB85-B781-4ac1-8D90-93A05EE37D7D}
DEFINE_GUID(CLSID_DirectPlayVoiceClient, 
0xb9f3eb85, 0xb781, 0x4ac1, 0x8d, 0x90, 0x93, 0xa0, 0x5e, 0xe3, 0x7d, 0x7d);

// {D3F5B8E6-9B78-4a4c-94EA-CA2397B663D3}
DEFINE_GUID(CLSID_DirectPlayVoiceServer, 
0xd3f5b8e6, 0x9b78, 0x4a4c, 0x94, 0xea, 0xca, 0x23, 0x97, 0xb6, 0x63, 0xd3);

// {0F0F094B-B01C-4091-A14D-DD0CD807711A}
DEFINE_GUID(CLSID_DirectPlayVoiceTest, 
0xf0f094b, 0xb01c, 0x4091, 0xa1, 0x4d, 0xdd, 0xc, 0xd8, 0x7, 0x71, 0x1a);

/****************************************************************************
 *
 * DirectPlayVoice Interface IIDs
 *
 ****************************************************************************/


// {1DFDC8EA-BCF7-41d6-B295-AB64B3B23306}
DEFINE_GUID(IID_IDirectPlayVoiceClient, 
0x1dfdc8ea, 0xbcf7, 0x41d6, 0xb2, 0x95, 0xab, 0x64, 0xb3, 0xb2, 0x33, 0x6);

// {FAA1C173-0468-43b6-8A2A-EA8A4F2076C9}
DEFINE_GUID(IID_IDirectPlayVoiceServer, 
0xfaa1c173, 0x468, 0x43b6, 0x8a, 0x2a, 0xea, 0x8a, 0x4f, 0x20, 0x76, 0xc9);

// {D26AF734-208B-41da-8224-E0CE79810BE1}
DEFINE_GUID(IID_IDirectPlayVoiceTest,
0xd26af734, 0x208b, 0x41da, 0x82, 0x24, 0xe0, 0xce, 0x79, 0x81, 0xb, 0xe1);

/****************************************************************************
 *
 * DirectPlayVoice Compression Type GUIDs
 *
 ****************************************************************************/

// MS-ADPCM 32.8 kbit/s
//
// {699B52C1-A885-46a8-A308-97172419ADC7}
DEFINE_GUID(DPVCTGUID_ADPCM,
0x699b52c1, 0xa885, 0x46a8, 0xa3, 0x8, 0x97, 0x17, 0x24, 0x19, 0xad, 0xc7);

// Microsoft GSM 6.10 13 kbit/s
//
// {24768C60-5A0D-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_GSM,
0x24768c60, 0x5a0d, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// MS-PCM 64 kbit/s
// 
// {8DE12FD4-7CB3-48ce-A7E8-9C47A22E8AC5}
DEFINE_GUID(DPVCTGUID_NONE,
0x8de12fd4, 0x7cb3, 0x48ce, 0xa7, 0xe8, 0x9c, 0x47, 0xa2, 0x2e, 0x8a, 0xc5);

// Voxware SC03 3.2kbit/s
//
// {7D82A29B-2242-4f82-8F39-5D1153DF3E41}
DEFINE_GUID(DPVCTGUID_SC03,
0x7d82a29b, 0x2242, 0x4f82, 0x8f, 0x39, 0x5d, 0x11, 0x53, 0xdf, 0x3e, 0x41);

// Voxware SC06 6.4kbit/s
//
// {53DEF900-7168-4633-B47F-D143916A13C7}
DEFINE_GUID(DPVCTGUID_SC06,
0x53def900, 0x7168, 0x4633, 0xb4, 0x7f, 0xd1, 0x43, 0x91, 0x6a, 0x13, 0xc7);

// TrueSpeech(TM) 8.6 kbit/s
//
// {D7954361-5A0B-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_TRUESPEECH,
0xd7954361, 0x5a0b, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// Voxware VR12 1.4kbit/s
//
// {FE44A9FE-8ED4-48bf-9D66-1B1ADFF9FF6D}
DEFINE_GUID(DPVCTGUID_VR12,
0xfe44a9fe, 0x8ed4, 0x48bf, 0x9d, 0x66, 0x1b, 0x1a, 0xdf, 0xf9, 0xff, 0x6d);

// Define the default compression type
#define DPVCTGUID_DEFAULT	DPVCTGUID_SC03

/****************************************************************************
 *
 * DirectPlayVoice Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlayVoiceClient FAR *LPDIRECTPLAYVOICECLIENT, *PDIRECTPLAYVOICECLIENT;
typedef struct IDirectPlayVoiceServer FAR *LPDIRECTPLAYVOICESERVER, *PDIRECTPLAYVOICESERVER;
typedef struct IDirectPlayVoiceTest FAR *LPDIRECTPLAYVOICETEST, *PDIRECTPLAYVOICETEST;

/****************************************************************************
 *
 * DirectPlayVoice Callback Functions
 *
 ****************************************************************************/
typedef HRESULT (FAR PASCAL *PDVMESSAGEHANDLER)(
    PVOID   pvUserContext,
    DWORD   dwMessageType,
    LPVOID  lpMessage
);

typedef PDVMESSAGEHANDLER LPDVMESSAGEHANDLER;

/****************************************************************************
 *
 * DirectPlayVoice Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

typedef DWORD DVID, *LPDVID, *PDVID;

/****************************************************************************
 *
 * DirectPlayVoice Message Types
 *
 ****************************************************************************/

#define DVMSGID_BASE                        0x0000

#define DVMSGID_MINBASE                     (DVMSGID_CREATEVOICEPLAYER)
#define DVMSGID_CREATEVOICEPLAYER           (DVMSGID_BASE+0x0001)
#define DVMSGID_DELETEVOICEPLAYER           (DVMSGID_BASE+0x0002)
#define DVMSGID_SESSIONLOST                 (DVMSGID_BASE+0x0003)
#define DVMSGID_PLAYERVOICESTART            (DVMSGID_BASE+0x0004)
#define DVMSGID_PLAYERVOICESTOP             (DVMSGID_BASE+0x0005)
#define DVMSGID_RECORDSTART                 (DVMSGID_BASE+0x0006)
#define DVMSGID_RECORDSTOP                  (DVMSGID_BASE+0x0007)
#define DVMSGID_CONNECTRESULT               (DVMSGID_BASE+0x0008)
#define DVMSGID_DISCONNECTRESULT            (DVMSGID_BASE+0x0009)
#define DVMSGID_INPUTLEVEL                  (DVMSGID_BASE+0x000A)
#define DVMSGID_OUTPUTLEVEL                 (DVMSGID_BASE+0x000B)
#define DVMSGID_HOSTMIGRATED                (DVMSGID_BASE+0x000C)
#define DVMSGID_SETTARGETS                  (DVMSGID_BASE+0x000D)
#define DVMSGID_PLAYEROUTPUTLEVEL           (DVMSGID_BASE+0x000E)
#define DVMSGID_LOSTFOCUS                   (DVMSGID_BASE+0x0010)
#define DVMSGID_GAINFOCUS                   (DVMSGID_BASE+0x0011)
#define DVMSGID_LOCALHOSTSETUP				(DVMSGID_BASE+0x0012)
#define DVMSGID_MAXBASE                     (DVMSGID_LOCALHOSTSETUP)

/****************************************************************************
 *
 * DirectPlayVoice Constants
 *
 ****************************************************************************/

//
// Buffer Aggresiveness Value Ranges
//
#define DVBUFFERAGGRESSIVENESS_MIN          0x00000001
#define DVBUFFERAGGRESSIVENESS_MAX          0x00000064
#define DVBUFFERAGGRESSIVENESS_DEFAULT      0x00000000

// 
// Buffer Quality Value Ranges
//
#define DVBUFFERQUALITY_MIN                 0x00000001
#define DVBUFFERQUALITY_MAX                 0x00000064
#define DVBUFFERQUALITY_DEFAULT             0x00000000

#define DVID_SYS                0

//
// Used to identify the session host in client/server
//
#define DVID_SERVERPLAYER       1

//
// Used to target all players
//
#define DVID_ALLPLAYERS         0

//
// Used to identify the main buffer
//
#define DVID_REMAINING          0xFFFFFFFF

// 
// Input level range
//
#define DVINPUTLEVEL_MIN                    0x00000000
#define DVINPUTLEVEL_MAX                    0x00000063	// 99 decimal

#define DVNOTIFYPERIOD_MINPERIOD            20


#define DVPLAYBACKVOLUME_DEFAULT            DSBVOLUME_MAX

#define DVRECORDVOLUME_LAST                 0x00000001


//
// Use the default value
//
#define DVTHRESHOLD_DEFAULT               0xFFFFFFFF

//
// Threshold Ranges
//
#define DVTHRESHOLD_MIN                   0x00000000
#define DVTHRESHOLD_MAX                   0x00000063	// 99 decimal

//
// Threshold field is not used 
//
#define DVTHRESHOLD_UNUSED                0xFFFFFFFE

//
// Session Types
//
#define DVSESSIONTYPE_PEER                  0x00000001
#define DVSESSIONTYPE_MIXING                0x00000002
#define DVSESSIONTYPE_FORWARDING            0x00000003
#define DVSESSIONTYPE_ECHO                  0x00000004

/****************************************************************************
 *
 * DirectPlayVoice Flags
 *
 ****************************************************************************/


// 
// Enable automatic adjustment of the recording volume
//
#define DVCLIENTCONFIG_AUTORECORDVOLUME     0x00000008

//
// Enable automatic voice activation
//
#define DVCLIENTCONFIG_AUTOVOICEACTIVATED   0x00000020

// 
// Enable echo suppression
//
#define DVCLIENTCONFIG_ECHOSUPPRESSION      0x08000000

// 
// Voice Activation manual mode
//
#define DVCLIENTCONFIG_MANUALVOICEACTIVATED 0x00000004

// 
// Only playback voices that have buffers created for them
//
#define DVCLIENTCONFIG_MUTEGLOBAL           0x00000010

// 
// Mute the playback
//
#define DVCLIENTCONFIG_PLAYBACKMUTE         0x00000002

//
// Mute the recording 
//
#define DVCLIENTCONFIG_RECORDMUTE           0x00000001

// 
// Complete the operation before returning
//
#define DVFLAGS_SYNC                        0x00000001

// 
// Just check to see if wizard has been run, and if so what it's results were
//
#define DVFLAGS_QUERYONLY                   0x00000002

//
// Shutdown the voice session without migrating the host
//
#define DVFLAGS_NOHOSTMIGRATE               0x00000008

// 
// Allow the back button to be enabled in the wizard
//
#define DVFLAGS_ALLOWBACK                   0x00000010

//
// Disable host migration in the voice session
//
#define DVSESSION_NOHOSTMIGRATION           0x00000001

// 
// Server controlled targetting
//
#define DVSESSION_SERVERCONTROLTARGET       0x00000002

//
// Use DirectSound Normal Mode instead of priority 
//
#define DVSOUNDCONFIG_NORMALMODE            0x00000001

//
// Automatically select the microphone
//
#define DVSOUNDCONFIG_AUTOSELECT            0x00000002

// 
// Run in half duplex mode
//
#define DVSOUNDCONFIG_HALFDUPLEX            0x00000004

// 
// No volume controls are available for the recording device
//
#define DVSOUNDCONFIG_NORECVOLAVAILABLE     0x00000010

// 
// Disable capture sharing
//
#define DVSOUNDCONFIG_NOFOCUS               0x20000000

// 
// Set system conversion quality to high
//
#define DVSOUNDCONFIG_SETCONVERSIONQUALITY	0x00000008

//
// Enable strict focus mode
// 
#define DVSOUNDCONFIG_STRICTFOCUS           0x40000000

//
// Player is in half duplex mode
//
#define DVPLAYERCAPS_HALFDUPLEX             0x00000001

// 
// Specifies that player is the local player
//
#define DVPLAYERCAPS_LOCAL                  0x00000002


/****************************************************************************
 *
 * DirectPlayVoice Structures (Non-Message)
 *
 ****************************************************************************/


//
// DirectPlayVoice Caps
// (GetCaps / SetCaps)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Caps flags
} DVCAPS, *LPDVCAPS, *PDVCAPS;

//
// DirectPlayVoice Client Configuration
// (Connect / GetClientConfig)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Flags for client config (DVCLIENTCONFIG_...)
    LONG    lRecordVolume;          // Recording volume 
    LONG    lPlaybackVolume;        // Playback volume
    DWORD   dwThreshold;          // Voice Activation Threshold
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggressiveness
    DWORD   dwNotifyPeriod;         // Period of notification messages (ms)
} DVCLIENTCONFIG, *LPDVCLIENTCONFIG, *PDVCLIENTCONFIG;

//
// DirectPlayVoice Compression Type Information
// (GetCompressionTypes)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    GUID    guidType;               // GUID that identifies this compression type
    LPWSTR  lpszName;               // String name of this compression type
    LPWSTR  lpszDescription;        // Description for this compression type
    DWORD   dwFlags;                // Flags for this compression type
    DWORD   dwMaxBitsPerSecond;		// Maximum # of bit/s this compression type uses
} DVCOMPRESSIONINFO, *LPDVCOMPRESSIONINFO, *PDVCOMPRESSIONINFO;

//
// DirectPlayVoice Session Description
// (Host / GetSessionDesc)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Session flags (DVSESSION_...)
    DWORD   dwSessionType;          // Session type (DVSESSIONTYPE_...)
    GUID    guidCT;                 // Compression Type to use
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggresiveness
} DVSESSIONDESC, *LPDVSESSIONDESC, *PDVSESSIONDESC;

// 
// DirectPlayVoice Client Sound Device Configuration
// (Connect / GetSoundDeviceConfig)
//
typedef struct
{
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Flags for sound config (DVSOUNDCONFIG_...)
    GUID                    guidPlaybackDevice;     // GUID of the playback device to use
    LPDIRECTSOUND           lpdsPlaybackDevice;     // DirectSound Object to use (optional)
    GUID                    guidCaptureDevice;      // GUID of the capture device to use
    LPDIRECTSOUNDCAPTURE    lpdsCaptureDevice;      // DirectSoundCapture Object to use (optional)
    HWND                    hwndAppWindow;          // HWND of your application's top-level window
    LPDIRECTSOUNDBUFFER     lpdsMainBuffer;         // DirectSoundBuffer to use for playback (optional)
    DWORD                   dwMainBufferFlags;      // Flags to pass to Play() on the main buffer
    DWORD                   dwMainBufferPriority;   // Priority to set when calling Play() on the main buffer
} DVSOUNDDEVICECONFIG, *LPDVSOUNDDEVICECONFIG, *PDVSOUNDDEVICECONFIG;

/****************************************************************************
 *
 * DirectPlayVoice message handler call back structures
 *
 ****************************************************************************/

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Connect() call
} DVMSG_CONNECTRESULT, *LPDVMSG_CONNECTRESULT, *PDVMSG_CONNECTRESULT;

//
// A new player has entered the voice session
// (DVMSGID_CREATEVOICEPLAYER)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who joined
    DWORD   dwFlags;                        // Player flags (DVPLAYERCAPS_...)
    PVOID	pvPlayerContext;                // Context value for this player (user set)
} DVMSG_CREATEVOICEPLAYER, *LPDVMSG_CREATEVOICEPLAYER, *PDVMSG_CREATEVOICEPLAYER;

//
// A player has left the voice session
// (DVMSGID_DELETEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who left
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_DELETEVOICEPLAYER, *LPDVMSG_DELETEVOICEPLAYER, *PDVMSG_DELETEVOICEPLAYER;

//
// Result of the Disconnect() call.  (If it wasn't called Async)
// (DVMSGID_DISCONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Disconnect() call
} DVMSG_DISCONNECTRESULT, *LPDVMSG_DISCONNECTRESULT, *PDVMSG_DISCONNECTRESULT;

// 
// The voice session host has migrated.
// (DVMSGID_HOSTMIGRATED) 
//
typedef struct
{
    DWORD                   dwSize;         // Size of this structure
    DVID                    dvidNewHostID;  // DVID of the player who is now the host
    LPDIRECTPLAYVOICESERVER pdvServerInterface;
                                            // Pointer to the new host object (if local player is now host)
} DVMSG_HOSTMIGRATED, *LPDVMSG_HOSTMIGRATED, *PDVMSG_HOSTMIGRATED;

//
// The current input level / recording volume on the local machine
// (DVMSGID_INPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the audio
    LONG    lRecordVolume;                  // Current recording volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_INPUTLEVEL, *LPDVMSG_INPUTLEVEL, *PDVMSG_INPUTLEVEL;

//
// The local client is about to become the new host
// (DVMSGID_LOCALHOSTSETUP)
//
typedef struct
{
	DWORD				dwSize;             // Size of this structure
	PVOID				pvContext;			// Context value to be passed to Initialize() of new host object
	PDVMESSAGEHANDLER	pMessageHandler;	// Message handler to be used by new host object
} DVMSG_LOCALHOSTSETUP, *LPDVMSG_LOCALHOSTSETUP, *PDVMSG_LOCALHOSTSETUP;

//
// The current output level for the combined output of all incoming streams.
// (DVMSGID_OUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the output
    LONG    lOutputVolume;                  // Current playback volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_OUTPUTLEVEL, *LPDVMSG_OUTPUTLEVEL, *PDVMSG_OUTPUTLEVEL;

//
// The current peak level of an individual player's incoming audio stream as it is
// being played back.
// (DVMSGID_PLAYEROUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;                   // DVID of the player
    DWORD   dwPeakLevel;                    // Peak level of the player's stream
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_PLAYEROUTPUTLEVEL, *LPDVMSG_PLAYEROUTPUTLEVEL, *PDVMSG_PLAYEROUTPUTLEVEL;

// 
// An audio stream from the specified player has started playing back on the local client.
// (DVMSGID_PLAYERVOICESTART).
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the Player 
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTART, *LPDVMSG_PLAYERVOICESTART, *PDVMSG_PLAYERVOICESTART;

//
// The audio stream from the specified player has stopped playing back on the local client.
// (DVMSGID_PLAYERVOICESTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the player
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTOP, *LPDVMSG_PLAYERVOICESTOP, *PDVMSG_PLAYERVOICESTOP;

// 
// Transmission has started on the local machine
// (DVMSGID_RECORDSTART)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to start
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTART, *LPDVMSG_RECORDSTART, *PDVMSG_RECORDSTART;

// 
// Transmission has stopped on the local machine
// (DVMSGID_RECORDSTOP)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to stop
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTOP, *LPDVMSG_RECORDSTOP, *PDVMSG_RECORDSTOP;

// 
// The voice session has been lost
// (DVMSGID_SESSIONLOST)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;	                    // Reason the session was disconnected
} DVMSG_SESSIONLOST, *LPDVMSG_SESSIONLOST, *PDVMSG_SESSIONLOST;

//
// The target list has been updated for the local client
// (DVMSGID_SETTARGETS)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwNumTargets;                   // # of targets 
    PDVID   pdvidTargets;                   // An array of DVIDs specifying the current targets
} DVMSG_SETTARGETS, *LPDVMSG_SETTARGETS, *PDVMSG_SETTARGETS;


/****************************************************************************
 *
 * DirectPlayVoice Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DirectPlayVoiceCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown); 

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceClient
DECLARE_INTERFACE_( IDirectPlayVoiceClient, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    /*** IDirectPlayVoiceClient methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Connect)      (THIS_ PDVSOUNDDEVICECONFIG, PDVCLIENTCONFIG, DWORD ) PURE;
    STDMETHOD_(HRESULT, Disconnect)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, SetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Create3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUNDBUFFER, DWORD, DWORD, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, Delete3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSoundDeviceConfig)( THIS_ PDVSOUNDDEVICECONFIG, PDWORD ) PURE;
};


#undef INTERFACE
#define INTERFACE IDirectPlayVoiceServer
DECLARE_INTERFACE_( IDirectPlayVoiceServer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceServer methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, LPDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, StartSession)  (THIS_ PDVSESSIONDESC, DWORD ) PURE;
    STDMETHOD_(HRESULT, StopSession)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, SetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ DVID, PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ DVID, PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceTest
DECLARE_INTERFACE_( IDirectPlayVoiceTest, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceTest methods ***/
    STDMETHOD_(HRESULT, CheckAudioSetup) (THIS_ const GUID *,  const GUID * , HWND, DWORD ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceClient_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->lpVtbl->Disconnect(p,a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->lpVtbl->GetClientConfig(p,a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->lpVtbl->SetClientConfig(p,a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->lpVtbl->SetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->lpVtbl->GetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->lpVtbl->Create3DSoundBuffer(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->lpVtbl->Delete3DSoundBuffer(p,a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)  (p)->lpVtbl->GetSoundDeviceConfig(p,a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceServer_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->lpVtbl->StopSession(p,a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)          (p)->lpVtbl->SetSessionDesc(p,a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->SetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->GetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceTest_Release(p)                	    (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->lpVtbl->CheckAudioSetup(p,a,b,c,d)


#else /* C++ */

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceClient_Release(p)               	(p)->Release()

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->Connect(a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->Disconnect(a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->GetSessionDesc(a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->GetClientConfig(a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->SetClientConfig(a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->SetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->GetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->Create3DSoundBuffer(a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->Delete3DSoundBuffer(a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)    (p)->GetSoundDeviceConfig(a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceServer_Release(p)                   (p)->Release()

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->StartSession(a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->StopSession(a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)            (p)->GetSessionDesc(a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)            (p)->SetSessionDesc(a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d) (p)->SetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d) (p)->GetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)

#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->AddRef()
#define IDirectPlayVoiceTest_Release(p)                     (p)->Release()
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->CheckAudioSetup(a,b,c,d)


#endif


/****************************************************************************
 *
 * DIRECTPLAYVOICE ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )          MAKE_HRESULT( 1, _FACDPV, code )

#define DV_OK                           S_OK
#define DV_FULLDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x0005 )
#define DV_HALFDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x000A )
#define DV_PENDING						MAKE_HRESULT( 0, _FACDPV,  0x0010 )

#define DVERR_BUFFERTOOSMALL            MAKE_DVHRESULT(  0x001E )
#define DVERR_EXCEPTION                 MAKE_DVHRESULT(  0x004A )
#define DVERR_GENERIC                   E_FAIL
#define DVERR_INVALIDFLAGS              MAKE_DVHRESULT( 0x0078 )
#define DVERR_INVALIDOBJECT             MAKE_DVHRESULT( 0x0082 )
#define DVERR_INVALIDPARAM              E_INVALIDARG
#define DVERR_INVALIDPLAYER             MAKE_DVHRESULT( 0x0087 )
#define DVERR_INVALIDGROUP              MAKE_DVHRESULT( 0x0091 )
#define DVERR_INVALIDHANDLE             MAKE_DVHRESULT( 0x0096 )
#define DVERR_OUTOFMEMORY               E_OUTOFMEMORY
#define DVERR_PENDING                   DV_PENDING
#define DVERR_NOTSUPPORTED              E_NOTIMPL
#define DVERR_NOINTERFACE               E_NOINTERFACE
#define DVERR_SESSIONLOST               MAKE_DVHRESULT( 0x012C )
#define DVERR_NOVOICESESSION            MAKE_DVHRESULT( 0x012E )
#define DVERR_CONNECTIONLOST            MAKE_DVHRESULT( 0x0168 )
#define DVERR_NOTINITIALIZED            MAKE_DVHRESULT( 0x0169 )
#define DVERR_CONNECTED                 MAKE_DVHRESULT( 0x016A )
#define DVERR_NOTCONNECTED              MAKE_DVHRESULT( 0x016B )
#define DVERR_CONNECTABORTING           MAKE_DVHRESULT( 0x016E )
#define DVERR_NOTALLOWED                MAKE_DVHRESULT( 0x016F )
#define DVERR_INVALIDTARGET             MAKE_DVHRESULT( 0x0170 )
#define DVERR_TRANSPORTNOTHOST          MAKE_DVHRESULT( 0x0171 )
#define DVERR_COMPRESSIONNOTSUPPORTED   MAKE_DVHRESULT( 0x0172 )
#define DVERR_ALREADYPENDING            MAKE_DVHRESULT( 0x0173 )
#define DVERR_SOUNDINITFAILURE          MAKE_DVHRESULT( 0x0174 )
#define DVERR_TIMEOUT                   MAKE_DVHRESULT( 0x0175 )
#define DVERR_CONNECTABORTED            MAKE_DVHRESULT( 0x0176 )
#define DVERR_NO3DSOUND                 MAKE_DVHRESULT( 0x0177 )
#define DVERR_ALREADYBUFFERED	        MAKE_DVHRESULT( 0x0178 )
#define DVERR_NOTBUFFERED               MAKE_DVHRESULT( 0x0179 )
#define DVERR_HOSTING                   MAKE_DVHRESULT( 0x017A )
#define DVERR_NOTHOSTING                MAKE_DVHRESULT( 0x017B )
#define DVERR_INVALIDDEVICE             MAKE_DVHRESULT( 0x017C )
#define DVERR_RECORDSYSTEMERROR         MAKE_DVHRESULT( 0x017D )
#define DVERR_PLAYBACKSYSTEMERROR       MAKE_DVHRESULT( 0x017E )
#define DVERR_SENDERROR                 MAKE_DVHRESULT( 0x017F )
#define DVERR_USERCANCEL                MAKE_DVHRESULT( 0x0180 )
#define DVERR_RUNSETUP                  MAKE_DVHRESULT( 0x0183 )
#define DVERR_INCOMPATIBLEVERSION       MAKE_DVHRESULT( 0x0184 )
#define DVERR_INITIALIZED               MAKE_DVHRESULT( 0x0187 )
#define DVERR_INVALIDPOINTER            E_POINTER
#define DVERR_NOTRANSPORT               MAKE_DVHRESULT( 0x0188 )
#define DVERR_NOCALLBACK                MAKE_DVHRESULT( 0x0189 )
#define DVERR_TRANSPORTNOTINIT          MAKE_DVHRESULT( 0x018A )
#define DVERR_TRANSPORTNOSESSION        MAKE_DVHRESULT( 0x018B )
#define DVERR_TRANSPORTNOPLAYER         MAKE_DVHRESULT( 0x018C )
#define DVERR_USERBACK                  MAKE_DVHRESULT( 0x018D )
#define DVERR_NORECVOLAVAILABLE         MAKE_DVHRESULT( 0x018E )
#define DVERR_INVALIDBUFFER				MAKE_DVHRESULT( 0x018F )
#define DVERR_LOCKEDBUFFER				MAKE_DVHRESULT( 0x0190 )

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvdmedia.h ===
//------------------------------------------------------------------------------
// File: DVDMedia.h
//
// Desc: Contains typedefs and defines necessary for user mode (ring 3) DVD
//       filters and applications.
//
//       This should be included in the DirectShow SDK for user mode filters.
//       The types defined here should be kept in synch with ksmedia.h WDM 
//       DDK for kernel mode filters.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DVDMEDIA_H__
#define __DVDMEDIA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// -----------------------------------------------------------------------
// AC-3 definition for the AM_KSPROPSETID_AC3 property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1,
    AM_PROPERTY_AC3_ALTERNATE_AUDIO = 2,
    AM_PROPERTY_AC3_DOWNMIX = 3,
    AM_PROPERTY_AC3_BIT_STREAM_MODE = 4,
    AM_PROPERTY_AC3_DIALOGUE_LEVEL = 5,
    AM_PROPERTY_AC3_LANGUAGE_CODE = 6,
    AM_PROPERTY_AC3_ROOM_TYPE = 7
} AM_PROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} AM_AC3_ERROR_CONCEALMENT, *PAM_AC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} AM_AC3_ALTERNATE_AUDIO, *PAM_AC3_ALTERNATE_AUDIO;

#define AM_AC3_ALTERNATE_AUDIO_1     1
#define AM_AC3_ALTERNATE_AUDIO_2     2
#define AM_AC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} AM_AC3_DOWNMIX, *PAM_AC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} AM_AC3_BIT_STREAM_MODE, *PAM_AC3_BIT_STREAM_MODE;

#define AM_AC3_SERVICE_MAIN_AUDIO            0
#define AM_AC3_SERVICE_NO_DIALOG             1
#define AM_AC3_SERVICE_VISUALLY_IMPAIRED     2
#define AM_AC3_SERVICE_HEARING_IMPAIRED      3
#define AM_AC3_SERVICE_DIALOG_ONLY           4
#define AM_AC3_SERVICE_COMMENTARY            5
#define AM_AC3_SERVICE_EMERGENCY_FLASH       6
#define AM_AC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} AM_AC3_DIALOGUE_LEVEL, *PAM_AC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} AM_AC3_ROOM_TYPE, *PAM_AC3_ROOM_TYPE;


// -----------------------------------------------------------------------
// subpicture definition for the AM_KSPROPSETID_DvdSubPic property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_DVDSUBPIC_PALETTE = 0,
    AM_PROPERTY_DVDSUBPIC_HLI = 1,
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 2  // TRUE for subpicture is displayed
} AM_PROPERTY_DVDSUBPIC;

typedef struct _AM_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   U;
    UCHAR   V;
} AM_DVD_YUV, *PAM_DVD_YUV;

typedef struct _AM_PROPERTY_SPPAL {
    AM_DVD_YUV sppal[16];
} AM_PROPERTY_SPPAL, *PAM_PROPERTY_SPPAL;

typedef struct _AM_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} AM_COLCON, *PAM_COLCON;

typedef struct _AM_PROPERTY_SPHLI {
    USHORT     HLISS;      //
    USHORT     Reserved;
    ULONG      StartPTM;   // start presentation time in x/90000
    ULONG      EndPTM;     // end PTM in x/90000
    USHORT     StartX;
    USHORT     StartY;
    USHORT     StopX;
    USHORT     StopY;
    AM_COLCON  ColCon;     // color contrast description (4 bytes as given in HLI)
} AM_PROPERTY_SPHLI, *PAM_PROPERTY_SPHLI;

typedef BOOL AM_PROPERTY_COMPOSIT_ON, *PAM_PROPERTY_COMPOSIT_ON;



// -----------------------------------------------------------------------
// copy protection definitions
// -----------------------------------------------------------------------

// AM_UseNewCSSKey for the dwTypeSpecificFlags in IMediaSample2 to indicate
// the exact point in a stream after which to start applying a new CSS key.
// This is typically sent on an empty media sample just before attempting 
// to renegotiate a CSS key.
#define AM_UseNewCSSKey    0x1

//
// AM_KSPROPSETID_CopyProt property set definitions
//
typedef enum {
    AM_PROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    AM_PROPERTY_DVDCOPY_DVD_KEY1 = 0x02,
    AM_PROPERTY_DVDCOPY_DEC_KEY2 = 0x03,
    AM_PROPERTY_DVDCOPY_TITLE_KEY = 0x04,
    AM_PROPERTY_COPY_MACROVISION = 0x05,
    AM_PROPERTY_DVDCOPY_REGION = 0x06,
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE = 0x07,
    AM_PROPERTY_DVDCOPY_DISC_KEY = 0x80
} AM_PROPERTY_DVDCOPYPROT;

typedef struct _AM_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} AM_DVDCOPY_CHLGKEY, *PAM_DVDCOPY_CHLGKEY;

typedef struct _AM_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} AM_DVDCOPY_BUSKEY, *PAM_DVDCOPY_BUSKEY;

typedef struct _AM_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} AM_DVDCOPY_DISCKEY, *PAM_DVDCOPY_DISCKEY;

typedef struct AM_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG Reserved1[2];
    UCHAR TitleKey[6];
    UCHAR Reserved2[2];
} AM_DVDCOPY_TITLEKEY, *PAM_DVDCOPY_TITLEKEY;

typedef struct _AM_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} AM_COPY_MACROVISION, *PAM_COPY_MACROVISION;

typedef struct AM_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} AM_DVDCOPY_SET_COPY_STATE, *PAM_DVDCOPY_SET_COPY_STATE;

typedef enum {
    AM_DVDCOPYSTATE_INITIALIZE = 0,
    AM_DVDCOPYSTATE_INITIALIZE_TITLE = 1,   // indicates we are starting a title
                                        // key copy protection sequence
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 2,
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = 3,
    AM_DVDCOPYSTATE_DONE = 4
} AM_DVDCOPYSTATE;

typedef enum {
    AM_MACROVISION_DISABLED = 0,
    AM_MACROVISION_LEVEL1 = 1,
    AM_MACROVISION_LEVEL2 = 2,
    AM_MACROVISION_LEVEL3 = 3
} AM_COPY_MACROVISION_LEVEL, *PAM_COPY_MACROVISION_LEVEL;


// CSS region stucture
typedef struct _DVD_REGION {
    UCHAR CopySystem;
    UCHAR RegionData;
    UCHAR SystemRegion;
    UCHAR Reserved;
} DVD_REGION, *PDVD_REGION; 

//
// CGMS Copy Protection Flags
//

#define AM_DVD_CGMS_RESERVED_MASK      0x00000078

#define AM_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define AM_DVD_CGMS_COPY_PERMITTED     0x00000000
#define AM_DVD_CGMS_COPY_ONCE          0x00000010
#define AM_DVD_CGMS_NO_COPY            0x00000018

#define AM_DVD_COPYRIGHT_MASK          0x00000040
#define AM_DVD_NOT_COPYRIGHTED         0x00000000
#define AM_DVD_COPYRIGHTED             0x00000040

#define AM_DVD_SECTOR_PROTECT_MASK     0x00000020
#define AM_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define AM_DVD_SECTOR_PROTECTED        0x00000020


// -----------------------------------------------------------------------
// video format blocks
// -----------------------------------------------------------------------

enum AM_MPEG2Level {
    AM_MPEG2Level_Low = 1,
    AM_MPEG2Level_Main = 2,
    AM_MPEG2Level_High1440 = 3,
    AM_MPEG2Level_High = 4
};

enum AM_MPEG2Profile {
    AM_MPEG2Profile_Simple = 1,
    AM_MPEG2Profile_Main = 2,
    AM_MPEG2Profile_SNRScalable = 3,
    AM_MPEG2Profile_SpatiallyScalable = 4,
    AM_MPEG2Profile_High = 5
};

#define AMINTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define AMINTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define AMINTERLACE_UNUSED                  0x00000008  //
#define AMINTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define AMINTERLACE_FieldPatField1Only      0x00000000  // stream never contains a Field2
#define AMINTERLACE_FieldPatField2Only      0x00000010  // stream never contains a Field1
#define AMINTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define AMINTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define AMINTERLACE_DisplayModeMask         0x000000c0
#define AMINTERLACE_DisplayModeBobOnly      0x00000000
#define AMINTERLACE_DisplayModeWeaveOnly    0x00000040
#define AMINTERLACE_DisplayModeBobOrWeave   0x00000080

#define AMCOPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define AMMPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image 
                        //  based on pan-scan vectors in picture_display_extension 
                        //  and change the picture aspect ratio accordingly.
#define AMMPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output 
                        //  pin for DVD style closed caption data found in GOP layer of field 1
#define AMMPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output 
                        //  pin for DVD style closed caption data found in GOP layer of field 2
#define AMMPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top 
                        //  and bottom of the video.
#define AMMPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                        //  indicates that "camera mode" was used.
#define AMMPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should 
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.


typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display 
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;

typedef struct tagMPEG2VIDEOINFO {
    VIDEOINFOHEADER2    hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile   
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwSequenceHeader[1];    // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension 
                                                //   should also be included
} MPEG2VIDEOINFO;

#define SIZE_MPEG2VIDEOINFO(pv) (FIELD_OFFSET(MPEG2VIDEOINFO, dwSequenceHeader[0]) + (pv)->cbSequenceHeader)

// do not use
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

// use this macro instead, the previous only works for MPEG1VIDEOINFO structures
#define MPEG2_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->dwSequenceHeader)


//===================================================================================
// flags for dwTypeSpecificFlags in AM_SAMPLE2_PROPERTIES which define type specific
// data in IMediaSample2
//===================================================================================

#define AM_VIDEO_FLAG_FIELD_MASK        0x0003L // use this mask to check whether the sample is field1 or field2 or frame
#define AM_VIDEO_FLAG_INTERLEAVED_FRAME     0x0000L     // the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1            0x0001L // the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD2            0x0002L // the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1FIRST       0x0004L // if set means display field1 first, else display field2 first.
                            // this bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_WEAVE             0x0008L // if set use bob display mode else weave
#define AM_VIDEO_FLAG_IPB_MASK          0x0030L // use this mask to check whether the sample is I, P or B
#define AM_VIDEO_FLAG_I_SAMPLE          0x0000L     // I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_P_SAMPLE          0x0010L // P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_B_SAMPLE          0x0020L // B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_REPEAT_FIELD      0x0040L // if set means display the field which has been displayed first again after displaying 
                            // both fields first. This bit is irrelavant for 1FieldPerSample mode

// -----------------------------------------------------------------------
// AM_KSPROPSETID_DvdKaraoke property set definitions
// -----------------------------------------------------------------------

typedef struct tagAM_DvdKaraokeData
{
    DWORD   dwDownmix;              // bitwise OR of AM_DvdKaraoke_Downmix flags
    DWORD   dwSpeakerAssignment;    // AM_DvdKaraoke_SpeakerAssignment
} AM_DvdKaraokeData;

typedef enum {
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0,  // BOOL
    AM_PROPERTY_DVDKARAOKE_DATA = 1,
} AM_PROPERTY_DVDKARAOKE;

// -----------------------------------------------------------------------
// AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------

typedef enum {
    AM_RATE_SimpleRateChange = 1,    // rw, use AM_SimpleRateChange
    AM_RATE_ExactRateChange  = 2,	 // rw, use AM_ExactRateChange
    AM_RATE_MaxFullDataRate  = 3,	 // r,  use AM_MaxFullDataRate
    AM_RATE_Step             = 4     // w,  use AM_Step
} AM_PROPERTY_TS_RATE_CHANGE;

// -------------------------------------------------------------------
// AM_KSPROPSETID_DVD_RateChange property set definitions for new DVD
// rate change scheme.
// -------------------------------------------------------------------

typedef enum {
    AM_RATE_ChangeRate       = 1,    // w,  use AM_DVD_ChangeRate
    AM_RATE_FullDataRateMax  = 2,	 // r,  use AM_MaxFullDataRate
    AM_RATE_ReverseDecode    = 3,    // r,  use LONG
    AM_RATE_DecoderPosition  = 4,    // r,  use AM_DVD_DecoderPosition
    AM_RATE_DecoderVersion   = 5     // r,  use LONG
} AM_PROPERTY_DVD_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).  
    REFERENCE_TIME	StartTime;  //stream time at which to start this rate
    LONG		Rate;       //new rate * 10000 (decimal)
} AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_ExactRateChange;

typedef LONG AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD AM_Step; // number of frame to step

// New rate change property set, structs. enums etc.
typedef struct {
    REFERENCE_TIME	StartInTime;   // stream time (input) at which to start decoding at this rate
    REFERENCE_TIME	StartOutTime;  // reference time (output) at which to start showing at this rate
    LONG		    Rate;          // new rate * 10000 (decimal)
} AM_DVD_ChangeRate ;

typedef LONGLONG  AM_DVD_DecoderPosition ;

typedef enum {
    DVD_DIR_FORWARD  = 0,
    DVD_DIR_BACKWARD = 1
} DVD_PLAY_DIRECTION ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __DVDMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dvdevcod.h ===
//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by 
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user subpicture stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (void, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG ) 
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved ) 
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxHelper.h ===
/*******************************************************************************
* DXHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/11/95
*  Copyright (C) 1995 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXHelper_h
#define DXHelper_h

#include <DXTError.h>
#include <DXBounds.h>
#include <DXTrans.h>

#include <limits.h>
#include <crtdbg.h>
#include <malloc.h>
#include <math.h>

//=== Constants ==============================================================

#define DX_MMX_COUNT_CUTOFF 16

//=== Class, Enum, Struct and Union Declarations =============================

/*** DXLIMAPINFO
*   This structure is used by the array linear interpolation and image
*   filtering routines.
*/
typedef struct DXLIMAPINFO
{
    float   IndexFrac;
    USHORT  Index;
    BYTE    Weight;
} DXLIMAPINFO;

//
//  Declare this class as a global to use for determining when to call MMX optimized
//  code.  You can use MinMMXOverCount to determine if MMX instructions are present.
//  Typically, you would only want to use MMX instructions when you have a reasonably
//  large number of pixels to work on.  In this case your code can always be coded like
//  this:
//
//  if (CountOfPixelsToDo >= g_MMXInfo.MinMMXOverCount())
//  {
//      Do MMX Stuff
//  } else {
//      Do integer / float based stuff
//  }    
//  
//  If you code your MMX sequences like this, you will not have to use a special test
//  for the presence of MMX since the MinMMXOverCount will be set to 0xFFFFFFFF if there
//  is no MMX present on the processor.
//
//  You do not need to use this unless your module needs to conditionally execute MMX vs
//  non-MMX code.  If you only call the helper functions provided by DXTrans.Dll, such as
//  DXOverArrayMMX, you do NOT need this test.  You can always call these functions and they
//  will use the MMX code path only when MMX instructions are present.
//
class CDXMMXInfo
{
    ULONG m_MinMMXOver;
public:
    CDXMMXInfo()
    {
#ifndef _X86_
        m_MinMMXOver = 0xFFFFFFFF;
#else
        m_MinMMXOver = DX_MMX_COUNT_CUTOFF;
        __try
        {
            __asm
            {
                //--- Try the MMX exit multi-media state instruction
                EMMS;
            }
        }
        __except( GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION )
        {
            //--- MMX instructions not available
            m_MinMMXOver = 0xFFFFFFFF;
        }
#endif
    }
    inline ULONG MinMMXOverCount() { return m_MinMMXOver; }
};



//=== Function Prototypes ==========================================
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, DXLIMAPINFO* pMapInfo,
                              DXBASESAMPLE* pResults, DWORD dwResultCount );
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, PUSHORT pIndexes,
                              PBYTE pWeights, DXBASESAMPLE* pResults,
                              DWORD dwResultCount );

//
//  DXOverArray
//
//  Composits an array of source samples over the samples in the pDest buffer.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXOverArrayMMX
//
//  Identical to DXOverArray except that the MMX instruction set will be used for
//  large arrays of samples.  If the CPU does not support MMX, you may still call
//  this function, which will perform the same operation without the use of the MMX
//  unit.
//
//  Note that it is LESS EFFICIENT to use this function if the majority of the pixels
//  in the pSrc buffer are either clear (alpha 0) or opaque (alpha 0xFF).  This is 
//  because the MMX code must process every pixel and can not special case clear or
//  opaque pixels.  If there are a large number of translucent pixels then this function
//  is much more efficent than DXOverArray.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArrayMMX(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the color (val)
//            over the pDest samples.
//  val     - The premultiplied color value to composit over the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the samples
//            in the buffer over the color (val).
//  val     - The premultiplied color value to composit under the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstUnderArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//===================================================================================
//
//  Dithering Helpers
//
//  Image transforms are sometimes asked to dither their output.  This helper function
//  should be used by all image transforms to enusure a consistant dither pattern.
//
//  DXDitherArray is used to dither pixels prior to writing them to a DXSurface.
//  The caller must fill in the DXDITHERDESC structure, setting X and Y to the
//  output surface X,Y coordinates that the pixels will be placed in.  The samples
//  will be modified in place.
//
//  Once the samples have been dithered, they should be written to or composited with
//  the destination surface.
//
#define DX_DITHER_HEIGHT    4       // The dither pattern is 4x4 pixels
#define DX_DITHER_WIDTH     4

typedef struct DXDITHERDESC
{
    DXBASESAMPLE *      pSamples;       // Pointer to the 32-bit samples to dither
    ULONG               cSamples;       // Count of number of samples in pSamples buffer
    ULONG               x;              // X coordinate of the output surface
    ULONG               y;              // Y coordinate of the output surface
    DXSAMPLEFORMATENUM  DestSurfaceFmt; // Pixel format of the output surface
} DXDITHERDESC;

_DXTRANS_IMPL_EXT void WINAPI
    DXDitherArray(const DXDITHERDESC *pDitherDesc);

//=== Enumerated Set Definitions =============================================


//=== Function Type Definitions ==============================================


//=== Class, Struct and Union Definitions ====================================


//=== Inline Functions =======================================================

//===================================================================================
//
//  Memory allocation helpers.
//
//  These macros are used to allocate arrays of samples from the stack (using _alloca)
//  and cast them to the appropriate type.  The ulNumSamples parameter is the count
//  of samples required.
//
#define DXBASESAMPLE_Alloca( ulNumSamples ) \
    (DXBASESAMPLE *)_alloca( (ulNumSamples) * sizeof( DXBASESAMPLE ) )

#define DXSAMPLE_Alloca( ulNumSamples ) \
    (DXSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXSAMPLE ) )

#define DXPMSAMPLE_Alloca( ulNumSamples ) \
    (DXPMSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXPMSAMPLE ) )

//===================================================================================
//
//  Critical section helpers.
//
//  These C++ classes, CDXAutoObjectLock and CDXAutoCritSecLock are used within functions
//  to automatically claim critical sections upon constuction, and the critical section
//  will be released when the object is destroyed (goes out of scope).
//
//  The macros DXAUTO_OBJ_LOCK and DX_AUTO_SEC_LOCK(s) are normally used at the beginning
//  of a function that requires a critical section.  Any exit from the scope in which the
//  auto-lock was taken will automatically release the lock.
//

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used
class CDXAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CDXAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CDXAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define DXAUTO_OBJ_LOCK CDXAutoObjectLock lck(this);
#define DXAUTO_OBJ_LOCK_( t ) CDXAutoObjectLock lck(t);

class CDXAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CDXAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CDXAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define DXAUTO_SEC_LOCK( s ) CDXAutoCritSecLock lck(s);
#endif  // __ATLCOM_H__

//--- This function is used to compute the coefficient for a gaussian filter coordinate
inline float DXGaussCoeff( double x, double y, double Sigma )
{
    double TwoSigmaSq = 2 * ( Sigma * Sigma );
    return (float)(exp( ( -(x*x + y*y) / TwoSigmaSq  ) ) /
                        ( 3.1415927 * TwoSigmaSq ));
}

//--- This function is used to initialize a gaussian convolution filter
inline void DXInitGaussianFilter( float* pFilter, ULONG Width, ULONG Height, double Sigma )
{
    int i, NumCoeff = Width * Height;
    float  val, CoeffAdjust, FilterSum = 0.;
    double x, y;
    double LeftX   = -(double)(Width / 2);
    double RightX  =   Width - LeftX;
    double TopY    = -(double)(Height / 2);
    double BottomY =   Height - TopY;

    for( y = -TopY; y <= BottomY; y += 1. )
    {
        for( x = -LeftX; x <= RightX; x += 1. )
        {
            val = DXGaussCoeff( x, y, Sigma );
            pFilter[i++] = val;
        }
    }

    //--- Normalize filter (make it sum to 1.0)
    for( i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];

    if( FilterSum < 1. )
    {
        CoeffAdjust = 1.f / FilterSum;
        for( i = 0; i < NumCoeff; ++i )
        {
            pFilter[i] *= CoeffAdjust;
        }
    }

} /* DXInitGaussianFilter*/

//
//  DXConvertToGray
//
//  Translates a color sample to a gray scale sample
//
//  Sample  - The sample to convert to gray scale.
//  Return value is the gray scale sample.
//
inline DXBASESAMPLE DXConvertToGray( DXBASESAMPLE Sample )
{
    DWORD v = Sample;
    DWORD r = (BYTE)(v >> 16);
    DWORD g = (BYTE)(v >> 8);
    DWORD b = (BYTE)(v);
    DWORD sat = (r*306 + g*601 + b*117) / 1024;
    v &= 0xFF000000;
    v |= (sat << 16) | (sat << 8) | sat;
    return v;
} /* DXConvertToGray */

//--- This returns into the destination the value of the source
//  sample scaled by its own alpha (producing a premultiplied alpha sample)
//
inline DXPMSAMPLE DXPreMultSample(const DXSAMPLE & Src)
{
    if(Src.Alpha == 255 )
    {
        return (DWORD)Src;
    }
    else if(Src.Alpha == 0 )
    {
        return 0;
    }
    else
    {
        unsigned t1, t2;
        t1 = (Src & 0x00ff00ff) * Src.Alpha + 0x00800080;
        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

        t2 = (((Src >> 8) & 0x000000ff) | 0x01000000) * Src.Alpha + 0x00800080;
        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        return (t1 | t2);
    }
} /* DXPreMultSample */

inline DXPMSAMPLE * DXPreMultArray(DXSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF)
        {
            if (SrcAlpha == 0)
            {
                pBuffer[i] = 0;
            }
            else
            {
                DWORD S = pBuffer[i];
                DWORD t1 = (S & 0x00ff00ff) * SrcAlpha + 0x00800080;
                t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                DWORD t2 = (((S >> 8) & 0x000000ff) | 0x01000000) * SrcAlpha + 0x00800080;
                t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

                pBuffer[i] = (t1 | t2);
            }
        }
    }
    return (DXPMSAMPLE *)pBuffer;
}


inline DXSAMPLE DXUnPreMultSample(const DXPMSAMPLE & Src)
{
    if(Src.Alpha == 255 || Src.Alpha == 0)
    {
        return (DWORD)Src;
    }
    else
    {
        DXSAMPLE Dst;
        Dst.Blue  = (BYTE)((Src.Blue  * 255) / Src.Alpha);
        Dst.Green = (BYTE)((Src.Green * 255) / Src.Alpha);
        Dst.Red   = (BYTE)((Src.Red   * 255) / Src.Alpha);
        Dst.Alpha = Src.Alpha;
        return Dst;
    }
} /* DXUnPreMultSample */

inline DXSAMPLE * DXUnPreMultArray(DXPMSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF && SrcAlpha != 0)
        {
            pBuffer[i].Blue  = (BYTE)((pBuffer[i].Blue  * 255) / SrcAlpha);
            pBuffer[i].Green = (BYTE)((pBuffer[i].Green * 255) / SrcAlpha);
            pBuffer[i].Red   = (BYTE)((pBuffer[i].Red   * 255) / SrcAlpha);
        }
    }
    return (DXSAMPLE *)pBuffer;
}


//
//  This returns the result of 255-Alpha which is computed by doing a NOT
//
inline BYTE DXInvertAlpha( BYTE Alpha ) { return (BYTE)~Alpha; }

inline DWORD DXScaleSample( DWORD Src, ULONG beta )
{
    ULONG t1, t2;

    t1 = (Src & 0x00ff00ff) * beta + 0x00800080;
    t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2 = ((Src >> 8) & 0x00ff00ff) * beta + 0x00800080;
    t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (DWORD)(t1 | t2);
}


inline DWORD DXScaleSamplePercent( DWORD Src, float Percent )
{
    if (Percent > (254.0f / 255.0f)) {
        return Src;
    }
    else
    {
        return DXScaleSample(Src, (BYTE)(Percent * 255));
    }
}

inline void DXCompositeOver(DXPMSAMPLE & Dst, const DXPMSAMPLE & Src)
{
    if (Src.Alpha)
    {
        ULONG Beta = DXInvertAlpha(Src.Alpha);
        if (Beta)
        {
            Dst = Src + DXScaleSample(Dst, Beta);
        }
        else
        {
            Dst = Src;
        }
    }
}


inline DXPMSAMPLE DXCompositeUnder(DXPMSAMPLE Dst, DXPMSAMPLE Src )
{
    return Dst + DXScaleSample(Src, DXInvertAlpha(Dst.Alpha));
}


inline DXBASESAMPLE DXApplyLookupTable(const DXBASESAMPLE Src, const BYTE * pTable)
{
    DXBASESAMPLE Dest;
    Dest.Blue   = pTable[Src.Blue];
    Dest.Green  = pTable[Src.Green];
    Dest.Red    = pTable[Src.Red];
    Dest.Alpha  = pTable[Src.Alpha];
    return Dest;
}

inline DXBASESAMPLE * DXApplyLookupTableArray(DXBASESAMPLE *pBuffer, ULONG cSamples, const BYTE * pTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        DWORD v = pBuffer[i];
        DWORD a = pTable[v >> 24];
        DWORD r = pTable[(BYTE)(v >> 16)];
        DWORD g = pTable[(BYTE)(v >> 8)];
        DWORD b = pTable[(BYTE)v];
        pBuffer[i] = (a << 24) | (r << 16) | (g << 8) | b;
    }
    return pBuffer;
}

inline DXBASESAMPLE * DXApplyColorChannelLookupArray(DXBASESAMPLE *pBuffer,
                                                     ULONG cSamples,
                                                     const BYTE * pAlphaTable,
                                                     const BYTE * pRedTable,
                                                     const BYTE * pGreenTable,
                                                     const BYTE * pBlueTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        pBuffer[i].Blue   = pBlueTable[pBuffer[i].Blue];
        pBuffer[i].Green  = pGreenTable[pBuffer[i].Green];
        pBuffer[i].Red    = pRedTable[pBuffer[i].Red];
        pBuffer[i].Alpha  = pAlphaTable[pBuffer[i].Alpha];
    }
    return pBuffer;
}


//
//  CDXScale helper class
//
//  This class uses a pre-computed lookup table to scale samples.  For scaling large
//  arrays of samples to a constant scale, this is much faster than using even MMX
//  instructions.  This class is usually declared as a member of another class and
//  is most often used to apply a global opacity to a set of samples.
//
//  When using this class, you must always check for the two special cases of clear
//  and opaque before calling any of the scaling member functions.  Do this by using
//  the ScaleType() inline function.  Your code should look somthing like this:
//
//  if (ScaleType() == DXRUNTYPE_CLEAR)
//      Do whatever you do for a 0 alpha set of samples -- usually just ignore them
//  else if (ScaleType() == DXRUNTYPE_OPAQUE)
//      Do whatever you would do for a non-scaled set of samples
//  else
//      Scale the samples by using ScaleSample or one of the ScaleArray members
//
//  If you call any of the scaling members when the ScaleType() is either clear or
//  opaque, you will GP fault becuase the lookup table will not be allocated.
//
//  The scale can be set using either a floating point number between 0 and 1 using:
//      CDXScale::SetScale / CDXScale::GetScale
//  or you can use a byte integer value by using:
//      CDXScale::SetScaleAlphaValue / CDXScale::GetScaleAlphaValue
//
class CDXScale
{
private:
    float       m_Scale;
    BYTE        m_AlphaScale;
    BYTE        *m_pTable;

HRESULT InternalSetScale(BYTE Scale)
{
    if (m_AlphaScale == Scale) return S_OK;
    if (Scale == 0 || Scale == 255) 
    {
        delete m_pTable;
        m_pTable = NULL;
    }
    else
    {
        if(!m_pTable)
        {
            m_pTable = new BYTE[256];
            if(!m_pTable )
            {
                return E_OUTOFMEMORY;
            }
        }
        for (int i = 0; i < 256; ++i )
        {
            m_pTable[i] = (BYTE)((i * Scale) / 255);
        }
    }
    m_AlphaScale = Scale;
    return S_OK;
}
public:
    CDXScale() : 
      m_Scale(1.0f),
      m_AlphaScale(0xFF),
      m_pTable(NULL)
      {}
    ~CDXScale()
    {
        delete m_pTable;
    }
    DXRUNTYPE ScaleType() 
    {
        if (m_AlphaScale == 0) return DXRUNTYPE_CLEAR;
        if (m_AlphaScale == 0xFF) return DXRUNTYPE_OPAQUE;
        return DXRUNTYPE_TRANS;
    }
    HRESULT SetScaleAlphaValue(BYTE Alpha)
    {
        HRESULT hr = InternalSetScale(Alpha);
        if (SUCCEEDED(hr))
        {
            m_Scale = ((float)Alpha) / 255.0f;
        }
        return hr;
    }
    BYTE GetScaleAlphaValue(void)
    {
        return m_AlphaScale;
    }
    HRESULT SetScale(float Scale)
    {
        HRESULT hr = S_OK;
        if(( Scale < 0.0f ) || ( Scale > 1.0f ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ULONG IntScale = (ULONG)(Scale * 256.0f);     // Round up alpha (.9999 = 255 = Solid)
            if (IntScale > 255) 
            {
                IntScale = 255;
            }
            hr = SetScaleAlphaValue((BYTE)IntScale);
            if (SUCCEEDED(hr))
            {
                m_Scale = Scale;
            }
        }
        return hr;
    }
    float GetScale() const
    {
        return m_Scale;
    }
    DXRUNTYPE ScaleType() const
    {
        return (m_pTable ? DXRUNTYPE_TRANS : (m_AlphaScale ? DXRUNTYPE_OPAQUE : DXRUNTYPE_CLEAR));
    }
    DWORD ScaleSample(const DWORD s) const
    {
        return DXApplyLookupTable((DXBASESAMPLE)s, m_pTable);
    }
    DXBASESAMPLE * ScaleBaseArray(DXBASESAMPLE * pBuffer, ULONG cSamples) const
    {
        return DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXPMSAMPLE * ScalePremultArray(DXPMSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXPMSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArray(DXSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArrayAlphaOnly(DXSAMPLE *pBuffer, ULONG cSamples) const
    {
        const BYTE *pTable = m_pTable;
        for (ULONG i = 0; i < cSamples; i++)
        {
            pBuffer[i].Alpha  = pTable[pBuffer[i].Alpha];
        }
        return pBuffer;
    }
};

inline DWORD DXWeightedAverage( DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG Wgt )
{
    _ASSERT( Wgt < 256 );
    ULONG t1, t2;
    ULONG InvWgt = Wgt ^ 0xFF;

    t1  = (((S1 & 0x00ff00ff) * Wgt) + ((S2 & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t1  = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2  = ((((S1 >> 8) & 0x00ff00ff) * Wgt) + (((S2 >> 8) & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t2  = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (t1 | t2);
} /* DXWeightedAverage */

inline void DXWeightedAverageArray( DXBASESAMPLE* pS1, DXBASESAMPLE* pS2, ULONG Wgt,
                                    DXBASESAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    for( DWORD i = 0; i < dwCount; ++i )
    {
        pResults[i] = DXWeightedAverage( pS1[i], pS2[i], Wgt );
    }
} /* DXWeightedAverageArray */

inline void DXWeightedAverageArrayOver( DXPMSAMPLE* pS1, DXPMSAMPLE* pS2, ULONG Wgt,
                                        DXPMSAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    DWORD i;

    if( Wgt == 255 )
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXCompositeOver( pResults[i], pS1[i] );
        }
    }
    else
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXPMSAMPLE Avg = DXWeightedAverage( (DXBASESAMPLE)pS1[i],
                                                (DXBASESAMPLE)pS2[i], Wgt );
            DXCompositeOver( pResults[i], Avg );
        }
    }

} /* DXWeightedAverageArrayOver */

inline void DXScalePremultArray(DXPMSAMPLE *pBuffer, ULONG cSamples, BYTE Weight)
{
    for (DXPMSAMPLE *pBuffLimit = pBuffer + cSamples; pBuffer < pBuffLimit; pBuffer++)
    {
        *pBuffer = DXScaleSample(*pBuffer, Weight);
    }
}



//
//
inline HRESULT DXClipToOutputWithPlacement(CDXDBnds & LogicalOutBnds, const CDXDBnds * pClipBnds, CDXDBnds & PhysicalOutBnds, const CDXDVec *pPlacement)
{
    if(pClipBnds && (!LogicalOutBnds.IntersectBounds(*pClipBnds)))
    {
        return S_FALSE;    // no intersect, we're done
    }
    else
    {
        CDXDVec vClipPos(false);
        LogicalOutBnds.GetMinVector( vClipPos );
        if (pPlacement)
        {
            vClipPos -= *pPlacement;
        }
        PhysicalOutBnds += vClipPos;
        if (!LogicalOutBnds.IntersectBounds(PhysicalOutBnds))
        {
            return S_FALSE;
        }
        PhysicalOutBnds = LogicalOutBnds;
        PhysicalOutBnds -= vClipPos;
    }
    return S_OK;
}



//
//  Helper for converting a color ref to a DXSAMPLE
//
inline DWORD DXSampleFromColorRef(COLORREF cr)
{
    DXSAMPLE Samp(0xFF, GetRValue(cr), GetGValue(cr), GetBValue(cr));
    return Samp;
}

//
//  Fill an entire surface with a color
//
inline HRESULT DXFillSurface( IDXSurface *pSurface, DXPMSAMPLE Color,
                              BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( NULL, ulTimeOut, DXLOCKF_READWRITE, 
                                        IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurface */

//
//  Fill a specified sub-rectangle of a surface with a color.
//
inline HRESULT DXFillSurfaceRect( IDXSurface *pSurface, RECT & rect, DXPMSAMPLE Color,
                                  BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    CDXDBnds bnds(rect);
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( &bnds, ulTimeOut, DXLOCKF_READWRITE, 
                                         IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurfaceRect */



//
//  The DestBnds height and width must be greater than or equal to the source bounds.
//
//  The dwFlags parameter uses the flags defined by IDXSurfaceFactory::BitBlt:
// 
//    DXBOF_DO_OVER
//    DXBOF_DITHER
//
inline HRESULT DXBitBlt(IDXSurface * pDest, const CDXDBnds & DestBnds, 
                        IDXSurface * pSrc, const CDXDBnds & SrcBnds, 
                        DWORD dwFlags, ULONG ulTimeout)
{
    IDXARGBReadPtr * pIn;
    HRESULT hr;
    hr = pSrc->LockSurface( &SrcBnds, INFINITE,
                            (dwFlags & DXBOF_DO_OVER) ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                            IID_IDXARGBReadPtr, (void**)&pIn, NULL);
    if(SUCCEEDED(hr))
    {
        IDXARGBReadWritePtr * pOut;
        hr = pDest->LockSurface( &DestBnds, INFINITE, DXLOCKF_READWRITE,
                                 IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
        if (SUCCEEDED(hr))
        {
            DXSAMPLEFORMATENUM InNativeType = pIn->GetNativeType(NULL);
            DXSAMPLEFORMATENUM OutNativeType = pOut->GetNativeType(NULL);
            BOOL bSrcIsOpaque = !(InNativeType & (DXPF_TRANSLUCENCY | DXPF_TRANSPARENCY));
            const ULONG Width = SrcBnds.Width();
            DXPMSAMPLE *pSrcBuff = NULL;
            if( InNativeType != DXPF_PMARGB32 )
            {
                pSrcBuff = DXPMSAMPLE_Alloca(Width);
            }
            //
            //  Don't dither unless the dest has a greater error term than the source.
            //
            if ((dwFlags & DXBOF_DITHER) && 
                ((OutNativeType & DXPF_ERRORMASK) <= (InNativeType & DXPF_ERRORMASK)))
            {
                dwFlags &= (~DXBOF_DITHER);
            }
            if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                //--- Allocate a working output buffer if necessary
                DXPMSAMPLE *pDestBuff = NULL;
                if( OutNativeType != DXPF_PMARGB32 )
                {
                    pDestBuff = DXPMSAMPLE_Alloca(Width);
                }
                //--- Process each output row
                //    Note: Output coordinates are relative to the lock region
                const ULONG Height = SrcBnds.Height();
                if (dwFlags & DXBOF_DITHER)
                {
                    DXPMSAMPLE * pSrcDitherBuff = pSrcBuff;
                    if (pSrcDitherBuff == NULL)
                    {
                        pSrcDitherBuff = DXPMSAMPLE_Alloca(Width);
                    }
                    const BOOL bCopy = ((dwFlags & DXBOF_DO_OVER) == 0);
                    //
                    //  Set up the dither descriptor (some things are constant)
                    //
                    DXDITHERDESC dd;
                    dd.pSamples = pSrcDitherBuff;
                    dd.DestSurfaceFmt = OutNativeType;
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        dd.x = DestBnds.Left();
                        dd.y = DestBnds.Top() + Y;
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            if (pRunInfo->Type == DXRUNTYPE_CLEAR)
                            {
                                pIn->Move(ulRunLen);
                                if (bCopy)
                                {
                                    //
                                    //  The only way to avoid calling a constructor function to create
                                    //  a pmsample from 0 is to declare a variable and then assign it!
                                    //
                                    DXPMSAMPLE NullColor;
                                    NullColor = 0;
                                    pOut->FillAndMove(pSrcDitherBuff, NullColor, ulRunLen, FALSE);
                                }
                                else
                                {
                                    pOut->Move(ulRunLen);
                                }
                                dd.x += ulRunLen;
                            }
                            else
                            {
                                pIn->UnpackPremult(pSrcDitherBuff, ulRunLen, TRUE);
                                dd.cSamples = ulRunLen;
                                DXDitherArray(&dd);
                                dd.x += ulRunLen;
                                if (bCopy || pRunInfo->Type == DXRUNTYPE_OPAQUE)
                                {
                                    pOut->PackPremultAndMove(pSrcDitherBuff, ulRunLen);
                                }
                                else
                                {
                                    pOut->OverArrayAndMove(pDestBuff, pSrcDitherBuff, ulRunLen);
                                }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
                else
                {
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            switch (pRunInfo->Type)
                            {
                              case DXRUNTYPE_CLEAR:
                                pIn->Move(ulRunLen);
                                pOut->Move(ulRunLen);
                                break;
                              case DXRUNTYPE_OPAQUE:
                                pOut->CopyAndMoveBoth(pDestBuff, pIn, ulRunLen, TRUE);
                                break;
                              case DXRUNTYPE_TRANS:
                              {
                                DXPMSAMPLE *pSrc = pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE);
                                DXPMSAMPLE *pDest = pOut->UnpackPremult(pDestBuff, ulRunLen, FALSE);                 
                                DXOverArrayMMX(pDest, pSrc, ulRunLen);
                                pOut->PackPremultAndMove(pDestBuff, ulRunLen);
                                break;
                              }

                              case DXRUNTYPE_UNKNOWN:
                              {
                                pOut->OverArrayAndMove(pDestBuff,
                                                       pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE),
                                                       ulRunLen);
                                break;
                              }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
            }
            else // if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                // This code is run if:
                //
                // !(dwFlags & DXBOF_DITHER) 
                // && !((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque == 0)
                //
                // In English:
                //
                // This code is run if 1) dithering is not required
                // and 2) blending with output is not required because it was
                // not requested or because it's not needed because the source
                // pixels are all opaque.

                // hrDD is initialized to failure so that in the event that the
                // pixel formats don't match or the pixel format supports
                // transparency, the CopyRect will still run.

                HRESULT             hrDD        = E_FAIL;
                DXSAMPLEFORMATENUM  formatIn    = pIn->GetNativeType(NULL);

                // If the pixel formats match and do not support transparency
                // (because it's not supported by ddraw yet) try to use a 
                // ddraw blit instead of CopyRect.

                if ((formatIn == pOut->GetNativeType(NULL))
                    && !(formatIn & DXPF_TRANSPARENCY))
                {
                    CComPtr<IDirectDrawSurface> cpDDSrc;

                    // Get source ddraw surface pointer.

                    hrDD = pSrc->QueryInterface(IID_IDirectDrawSurface, 
                                                (void **)&cpDDSrc);

                    if (SUCCEEDED(hrDD))
                    {
                        CComPtr<IDirectDrawSurface> cpDDDest;

                        // Get destination ddraw surface pointer.

                        hrDD = pDest->QueryInterface(IID_IDirectDrawSurface, 
                                                     (void **)&cpDDDest);

                        if (SUCCEEDED(hrDD))
                        {
                            RECT rcSrc;
                            RECT rcDest;

                            SrcBnds.GetXYRect(rcSrc);
                            DestBnds.GetXYRect(rcDest);

                            // Attempt the ddraw blit.

                            hrDD = cpDDDest->Blt(&rcDest, cpDDSrc, &rcSrc, 
                                                 0, NULL);
                        }
                    }
                }

                // If hrDD has failed at this point, it means a direct draw blit
                // was not possible and a CopyRect is needed to perform the 
                // copy.

                if (FAILED(hrDD))
                {
                    pOut->CopyRect(pSrcBuff, NULL, pIn, NULL, bSrcIsOpaque);
                }
            }
            pOut->Release();
        }
        pIn->Release();
    }
    return hr;
}

inline HRESULT DXSrcCopy(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, 
                         IDXSurface *pSrcSurface, int nXSrc, int nYSrc)
{
    IDXDCLock *pDCLock;
    HRESULT hr = pSrcSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READ, &pDCLock);
    if (SUCCEEDED(hr))
    {
        ::BitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, pDCLock->GetDC(), nXSrc, nYSrc, SRCCOPY);
        pDCLock->Release();
    }
    return hr;
}
//
//=== Pointer validation functions
//
inline BOOL DXIsBadReadPtr( const void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadReadPtr( pMem, Size );
#endif
}

inline BOOL DXIsBadWritePtr( void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadWritePtr( pMem, Size );
#endif
}


inline BOOL DXIsBadInterfacePtr( const IUnknown* pUnknown )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
             ::IsBadCodePtr( (FARPROC)((void **)pUnknown)[0] ))?
            (true):(false);
#endif
}

#define DX_IS_BAD_OPTIONAL_WRITE_PTR(p) ((p) && DXIsBadWritePtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_READ_PTR(p) ((p) && DXIsBadReadPtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && DXIsBadInterfacePtr(p))


#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxHelp3.h ===
// DXHELP3.cpp : Contains definitions of routines shared by multiple effects

#ifndef __DXHELP3_H_
#define __DXHELP3_H_

#include <d3d.h>
#include <d3drm.h>
#include <math.h>


#ifndef PI
#define PI 3.1415926538
#endif

/*******************
This class is used to rotate a set of points about an axis.  An example of
how this is used is in Explode.cpp.  Basically you set up the axis and the
angle with the Set() function. The angle is in radians, and the Axis given
MUST be normalized.  That is the magnitude of the vector must be one. Then
you call RotatePoint() for each point.
*******************/
class Rotate
{
public:
    Rotate(){ D3DVECTOR v; v.x = 1; v.y = 0; v.z = 0; Set(v, PI); }
    Rotate(D3DVECTOR NormalAxis, double Angle) { Set(NormalAxis, Angle); }

    D3DVECTOR RotatePoint(D3DVECTOR Org)
    {
	D3DVECTOR Result;

	Result.x = Org.x * m_d3dvctrXComponent.x + 
		   Org.y * m_d3dvctrXComponent.y + 
		   Org.z * m_d3dvctrXComponent.z;

	Result.y = Org.x * m_d3dvctrYComponent.x + 
		   Org.y * m_d3dvctrYComponent.y + 
		   Org.z * m_d3dvctrYComponent.z;

	Result.z = Org.x * m_d3dvctrZComponent.x + 
		   Org.y * m_d3dvctrZComponent.y + 
		   Org.z * m_d3dvctrZComponent.z;

	return Result;
    }

    void Set(D3DVECTOR d3dvtcrAxis, double dAngle);

private:
    D3DVECTOR m_d3dvctrXComponent, m_d3dvctrYComponent, m_d3dvctrZComponent;
};

/******************
Copy the input MeshBuilder to the Output MeshBuilder.  
But, create independent vertices for each face in the output
mesh.  That is no two faces share a single vertice.
******************/
HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/******************
For each MeshBuilder in lpMeshBuilderIn find the corresponding 
MeshBuilder in lpMeshBuilderOut and call (*lpCallBack)(lpThis, lpmbOutX, lpmbInX).
If there is no corresponding output mesh for the input mesh, create it.
*******************/
HRESULT TraverseSubMeshes(HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			  void *lpThis, 
			  IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			  IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/***********************
Given three points, return the normal to the plane defined by these three points.
For a Right Handed system points A, B, and C should be in a CW order on the plane.
From CRC Standard Mathematical Tables 22nd Edition, page 380.  
Direction Numbers and Direction Cosines.
***********************/
inline D3DVECTOR ComputeNormal(D3DVECTOR d3dptA, D3DVECTOR d3dptB, D3DVECTOR d3dptC)
{
    const D3DVECTOR d3dptOne = d3dptB - d3dptA;
    const D3DVECTOR d3dptTwo = d3dptC - d3dptB;

    D3DVECTOR d3dptRetValue;
    d3dptRetValue.x = d3dptOne.y * d3dptTwo.z - d3dptOne.z * d3dptTwo.y;
    d3dptRetValue.y = d3dptOne.z * d3dptTwo.x - d3dptOne.x * d3dptTwo.z;
    d3dptRetValue.z = d3dptOne.x * d3dptTwo.y - d3dptOne.y * d3dptTwo.x;

    float Magnitude = (float)sqrt(d3dptRetValue.x * d3dptRetValue.x + 
                                  d3dptRetValue.y * d3dptRetValue.y + 
                                  d3dptRetValue.z * d3dptRetValue.z);

    // There's no good answer for how to get around this problem. The magnitude
    // here can be zero if the points given are not unique or are collinear. In
    // that case, there is no single normal, but rather there is a whole range of
    // them (either there are two unique points describing a line, or there is
    // only one describing a point).  We choose simply to return the un-normalized
    // vector, which is probably almost a zero vector.
    if (fabs(Magnitude) < 1.0e-5)
        return d3dptRetValue;
    else
        return d3dptRetValue/Magnitude;
}

float GetDlgItemFloat(HWND hDlg, int id);
BOOL SetDlgItemFloat( HWND hDlg, int id, float f );
double GetDlgItemDouble(HWND hDlg, int id);
BOOL SetDlgItemDouble( HWND hDlg, int id, double d );

#endif // __DXHELP3_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxmrtp.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    dxmrtp.h

Abstract:

    Master include file for Windows DirectX Media Based RTP implementation.

--*/

#ifndef __DXMRTP_INCLUDED__
#define __DXMRTP_INCLUDED__

/* Include all of the filter header files */
#include <amrtpnet.h>
#include <cxq_cust.h>
#include <amrtpdmx.h>
#include <amrtpss.h>
#include <irtprph.h>
#include <irtpsph.h>

#endif /* #ifndef __DXMRTP_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxbounds.h ===
/*******************************************************************************
* DXBounds.h *
*------------*
*   Description:
*       This is the header file for the bounds helper class implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/22/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXBounds_h
#define DXBounds_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_FLOAT
#include <float.h>
#endif

#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif

#ifndef DXVector_h
#include <DXVector.h>
#endif

//=== Constants ====================================================

#ifdef _ASSERT
#define CHKTYPE() _ASSERT( eType == eBndType )
#else
#define CHKTYPE()
#endif

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXBnds
*
*/
#define CDXB_C CDXBnds<TYPE, USTYPE, STTYPE, eBndType>
#define CDXB_T ((STTYPE*)u.D)
#define CDXB_O( OtherBnd ) ((STTYPE*)(OtherBnd).u.D)

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
class CDXBnds : public DXBNDS
{
  public:
  /*--- Constructors ---*/
    CDXBnds() { eType = eBndType; SetEmpty(); }
    CDXBnds( BOOL bInit ) { eType = eBndType; if (bInit) SetEmpty(); }
    CDXBnds( const DXBNDS& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const CDXB_C& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const RECT & Rect )    { eType = eBndType; SetXYRect( Rect ); }
    CDXBnds( TYPE Width, TYPE Height ) { eType = eBndType; SetXYSize( Width, Height ); }
    CDXBnds( IDXSurface *pSurface, HRESULT & hr) { _ASSERT(eBndType == DXBT_DISCRETE); eType = eBndType; hr = pSurface->GetBounds(this); }
    CDXBnds( IDirect3DRMMeshBuilder3 *pMesh, HRESULT & hr) { _ASSERT(eBndType == DXBT_CONTINUOUS); eType = eBndType; hr = SetToMeshBounds(pMesh); }
    CDXBnds( const CDXV_C& VecPoint ) { eType = eBndType; *this = VecPoint; }

    HRESULT InitFromSafeArray( SAFEARRAY *psa);
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void SetEmpty();
    void Copy( const DXBNDS& Other );
    void Copy( const CDXB_C& Other );

    /*--- Type casts ---*/
    operator STTYPE *   () { CHKTYPE(); return CDXB_T; }
    operator DXDBNDS&   () { CHKTYPE(); return u.D;  }
    operator DXDBNDS64& () { CHKTYPE(); return u.LD; }
    operator DXCBNDS&   () { CHKTYPE(); return u.C;  }
    operator DXCBNDS64& () { CHKTYPE(); return u.LC; }

    //--- Access methods
    USTYPE Width( DXBNDID i ) const { CHKTYPE(); return (USTYPE)(CDXB_T[i].Max - CDXB_T[i].Min); }

    USTYPE Width()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min); }
    USTYPE Height()   const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min); }
    USTYPE Depth()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min); }
    USTYPE Duration() const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min); }

    TYPE  Left()     const { CHKTYPE(); return CDXB_T[DXB_X].Min; }
    TYPE  Right()    const { CHKTYPE(); return CDXB_T[DXB_X].Max; }
    TYPE  Top()      const { CHKTYPE(); return CDXB_T[DXB_Y].Min; }
    TYPE  Bottom()   const { CHKTYPE(); return CDXB_T[DXB_Y].Max; }

    void SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                    TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax );
    void SetXYRect( const RECT& xyRect);
    void SetXYSize( const SIZE& xySize);
    void SetXYSize( TYPE width, TYPE height);
    void SetXYPoint(const POINT& xyPoint);
    void Offset( TYPE x, TYPE y, TYPE z, TYPE t );
    void Offset( const CDXV_C& v );
    void SetPlacement(const CDXV_C& v);
    void SetToSize(void);
    void GetXYRect( RECT& xyRect ) const;
    void GetXYSize( SIZE& xySize ) const;
    void GetMinVector( CDXV_C& v ) const;
    void GetMaxVector( CDXV_C& v ) const;
    void GetSize( CDXB_C& SizeBounds ) const;
    CDXB_C Size( void ) const;
 


    //--- Region Functions
    void NormalizeBounds();
    BOOL BoundsAreEmpty() const;
    BOOL BoundsAreNull() const;
    BOOL TestIntersect( const CDXB_C& Other ) const;
    BOOL IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );
    BOOL IntersectBounds( const CDXB_C& OtherBounds );
    void UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );

// Additional Operations
    STTYPE& operator[]( int index )    const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( long index )   const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( USHORT index ) const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DWORD index )  const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DXBNDID index) const { CHKTYPE(); return CDXB_T[index]; }

    void operator=(const CDXB_C& Bounds);
    void operator=(const CDXV_C& v);
    void operator+=(const POINT& point);
    void operator-=(const POINT& point);
    void operator+=(const SIZE& size);
    void operator-=(const SIZE& size);
    void operator+=(const CDXV_C& v);
    void operator-=(const CDXV_C& v);
    void operator+=(const CDXB_C& Bounds);
    void operator-=(const CDXB_C& Bounds);
    void operator&=(const CDXB_C& Bounds);
    void operator|=(const CDXB_C& Bounds);
    BOOL operator==(const CDXB_C& Bounds) const;
    BOOL operator!=(const CDXB_C& Bounds) const;

// Operators returning CDXDBnds values
    CDXB_C operator+(const POINT& point) const;
    CDXB_C operator-(const POINT& point) const;
    CDXB_C operator+(const SIZE& size) const;
    CDXB_C operator-(const SIZE& size) const;
    CDXB_C operator+(const CDXV_C& v) const;
    CDXB_C operator-(const CDXV_C& v) const;
    CDXB_C operator&(const CDXB_C& Bounds2) const;
    CDXB_C operator|(const CDXB_C& Bounds2) const;

//
// Helpers to grow bounds from their midpoints.
//
    void Scale(TYPE x, TYPE y = 1, TYPE z = 1, TYPE t = 1);
    void Scale(const CDXV_C& v);
    void Expand(TYPE x, TYPE y = 0, TYPE z = 0, TYPE t = 0);
    void Expand(const CDXV_C& v);

// Helpers for DXSurfaces  These functions only work with DISCRETE bounds
    HRESULT SetToSurfaceBounds(IDXSurface * pDXSurface);

// Helpers for D3DRM Meshes.  These functions only work with CONTINUOUS bounds.
    HRESULT SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh);
};

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetEmpty()
{
    CHKTYPE(); 
    memset(CDXB_T, 0, sizeof(STTYPE) * 4);
} /* CDXBnds::SetEmpty() */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const CDXB_C& Other )
{
    CHKTYPE();
    memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const DXBNDS& Other )
{
    CHKTYPE(); 
    if( eBndType == Other.eType )
    {
        memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
    }
    else
    {
        int i = 4;
        switch( Other.eType )
        {
          case DXBT_DISCRETE:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.D[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.D[i].Max;
            }
            break;
          case DXBT_DISCRETE64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LD[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LD[i].Max;
            }
            break;
          case DXBT_CONTINUOUS:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.C[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.C[i].Max;
            }
            break;
          case DXBT_CONTINUOUS64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LC[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LC[i].Max;
            }
            break;
          default:
            _ASSERT(0);
        }
    }
} /* CDXBnds::Copy constructor */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::InitFromSafeArray( SAFEARRAY *pSA )
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    TYPE *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(TYPE) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                CDXB_T[i].Min = pData[i];
                CDXB_T[i].Max = pData[i+4];
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }

    return hr;
} /* CDXBnds::InitFromSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::GetSafeArray( SAFEARRAY **ppSA ) const
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 8;
        static VARTYPE VTypes[4] = { VT_I4, VT_I8, VT_R4, VT_R8 };

        pSA = SafeArrayCreate( VTypes[eBndType], 1, &rgsabound );

        if( pSA == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            TYPE *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = CDXB_T[i].Min;
                    pData[i+4] = CDXB_T[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }

    return hr;
} /* CDXBnds::GetSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::NormalizeBounds()
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max < CDXB_T[i].Min )
        {
            TYPE Temp = CDXB_T[i].Min;
            CDXB_T[i].Min = CDXB_T[i].Max;
            CDXB_T[i].Max = Temp;
        }
    }
} /* CDXBnds::NormalizeBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;

    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = min( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );

        if( CDXB_T[i].Max <= CDXB_T[i].Min )
        {
            //--- no intersection
            SetEmpty();
            bDoesIntersect = FALSE;
        }
    }
    return bDoesIntersect;
} /* CDXBnds::IntersectBounds */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::TestIntersect( const CDXB_C& Other ) const
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;
    TYPE BndMin, BndMax;
    for( int i = 0; i < 4; ++i )
    {
        BndMin = max( CDXB_T[i].Min, CDXB_O( Other )[i].Min );
        BndMax = min( CDXB_T[i].Max, CDXB_O( Other )[i].Max );
        if( BndMax <= BndMin ) bDoesIntersect = FALSE;
    }
    return bDoesIntersect;
} /* CDXBnds::TestIntersect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    // This assumes the bounds are already normalized.
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = max( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );
    }
} /* CDXDBnds::UnionBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& OtherBounds )
{
    CHKTYPE(); 
    return IntersectBounds( *this, OtherBounds );
} /* CDXBnds::IntersectBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreEmpty() const
{
    CHKTYPE(); 
    //--- Must exist in all dimensions
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max <= CDXB_T[i].Min ) return TRUE;
    }
    return FALSE;
} /* CDXBnds::BoundsAreEmpty */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreNull() const
{
    CHKTYPE(); 
    DWORD *pTest = (DWORD *)CDXB_T;
    DWORD *pLimit = pTest + (sizeof(STTYPE) * 4 / sizeof(*pTest));
    do
    {
        if (*pTest) return FALSE;
        pTest++;
    } while (pTest < pLimit);
    return TRUE;
} /* CDXDBnds::BoundsAreNull */

// Additional Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXB_C& srcBounds )
{
    CHKTYPE(); 
    memcpy(CDXB_T, CDXB_O(srcBounds), sizeof(STTYPE)*4);
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = v[i];
        CDXB_T[i].Max = v[i] + 1;
    }
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator==( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return false;
        }
    }
    return true;
} /* CDXB_C::operator== */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator!=( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return true;
        }
    }
    return false;
} /* CDXBnds::operator!= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator&( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.IntersectBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator& */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator|( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.UnionBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator| */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMinVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Min;
    }
} /* CDXBnds::GetMinVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMaxVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Max;
    }
} /* CDXBnds::GetMaxVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetSize( CDXB_C& SizeBounds ) const
{
    CHKTYPE(); 
    SizeBounds.SetEmpty();
    SizeBounds[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    SizeBounds[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    SizeBounds[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    SizeBounds[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
} /* CDXBnds::GetSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::Size( void ) const
{
    CHKTYPE(); 
    CDXB_C Size;
    Size[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    Size[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    Size[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    Size[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
    return Size;
} /* CDXBnds::Size */

// Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                        TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min = xmin;
    CDXB_T[DXB_X].Max = xmax;
    CDXB_T[DXB_Y].Min = ymin;
    CDXB_T[DXB_Y].Max = ymax;
    CDXB_T[DXB_Z].Min = zmin;
    CDXB_T[DXB_Z].Max = zmax;
    CDXB_T[DXB_T].Min = tmin;
    CDXB_T[DXB_T].Max = tmax;
} /* CDXBnds::SetBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYRect( const RECT& xyRect )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyRect.left;
    CDXB_T[DXB_X].Max = (TYPE)xyRect.right;
    CDXB_T[DXB_Y].Min = (TYPE)xyRect.top;
    CDXB_T[DXB_Y].Max = (TYPE)xyRect.bottom;
    CDXB_T[DXB_Z].Max = 1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYRect( RECT& xyRect ) const
{
    CHKTYPE(); 
    xyRect.left   = CDXB_T[DXB_X].Min;
    xyRect.right  = CDXB_T[DXB_X].Max;
    xyRect.top    = CDXB_T[DXB_Y].Min;
    xyRect.bottom = CDXB_T[DXB_Y].Max;
} /* CDXBnds::GetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYSize( SIZE& xySize ) const
{
    CHKTYPE(); 
    xySize.cx = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    xySize.cy = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
} /* CDXBnds::GetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( const SIZE& xySize )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)xySize.cx;
    CDXB_T[DXB_Y].Max = (TYPE)xySize.cy;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( TYPE width, TYPE height )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)width;
    CDXB_T[DXB_Y].Max = (TYPE)height;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYPoint( const POINT& xyPoint )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyPoint.x;
    CDXB_T[DXB_X].Max = (TYPE)xyPoint.x + 1;
    CDXB_T[DXB_Y].Min = (TYPE)xyPoint.y;
    CDXB_T[DXB_Y].Max = (TYPE)xyPoint.y + 1;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXDBnds::SetRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( TYPE x, TYPE y, TYPE z, TYPE t )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += x;
    CDXB_T[DXB_X].Max += x;    // BUGBUG -- What about infinite?
    CDXB_T[DXB_Y].Min += y;
    CDXB_T[DXB_Y].Max += y;
    CDXB_T[DXB_Z].Min += z;
    CDXB_T[DXB_Z].Max += z;
    CDXB_T[DXB_T].Min += t;
    CDXB_T[DXB_T].Max += t;
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetToSize(void)
{
    CHKTYPE();
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max -= CDXB_T[i].Min;
        CDXB_T[i].Min = 0;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetPlacement(const CDXV_C & v)
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max += (CDXV_O( v )[i] - CDXB_T[i].Min);
        CDXB_T[i].Min = CDXV_O( v )[i];
    }
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min += v[i];
        CDXB_T[i].Max += v[i];
    }
} /* CDXBnds::Offset */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)point.x;
    CDXB_T[DXB_X].Max += (TYPE)point.x;
    CDXB_T[DXB_Y].Min += (TYPE)point.y;
    CDXB_T[DXB_Y].Max += (TYPE)point.y;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)point.x;
    CDXB_T[DXB_X].Max -= (TYPE)point.x;
    CDXB_T[DXB_Y].Min -= (TYPE)point.y;
    CDXB_T[DXB_Y].Max -= (TYPE)point.y;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)size.cx;
    CDXB_T[DXB_X].Max += (TYPE)size.cx;
    CDXB_T[DXB_Y].Min += (TYPE)size.cy;
    CDXB_T[DXB_Y].Max += (TYPE)size.cy;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)size.cx;
    CDXB_T[DXB_X].Max -= (TYPE)size.cx;
    CDXB_T[DXB_Y].Min -= (TYPE)size.cy;
    CDXB_T[DXB_Y].Max -= (TYPE)size.cy;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max += CDXV_O( v )[DXB_T];
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max -= CDXV_O( v )[DXB_T];
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max += CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min += CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max += CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min += CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max += CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min += CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max += CDXB_O( Bounds )[DXB_T].Max;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max -= CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min -= CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max -= CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min -= CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max -= CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min -= CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max -= CDXB_O( Bounds )[DXB_T].Max;
} /* CDXB_C::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator&=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = min( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator&= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator|=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( long i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = max( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator|= */


// operators returning CDXDBnds values
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += point.x;
    CDXB_O( Result )[DXB_X].Max += point.x;
    CDXB_O( Result )[DXB_Y].Min += point.y;
    CDXB_O( Result )[DXB_Y].Max += point.y;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= point.x;
    CDXB_O( Result )[DXB_X].Max -= point.x;
    CDXB_O( Result )[DXB_Y].Min -= point.y;
    CDXB_O( Result )[DXB_Y].Max -= point.y;
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const SIZE &size) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += size.cx;
    CDXB_O( Result )[DXB_X].Max += size.cx;
    CDXB_O( Result )[DXB_Y].Min += size.cy;
    CDXB_O( Result )[DXB_Y].Max += size.cy;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-( const SIZE &size ) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= size.cx;
    CDXB_O( Result )[DXB_X].Max -= size.cx;
    CDXB_O( Result )[DXB_Y].Min -= size.cy;
    CDXB_O( Result )[DXB_Y].Max -= size.cy;
    return Result;
} /* CDXB_C::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max += CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max -= CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToSurfaceBounds(IDXSurface * pDXSurface)
{
#if (eBndType != DXBT_DISCRETE)
#error SetToSurfacBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    return pDXSurface->GetBounds( this );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh)
{
#if (eBndType != DXBT_CONTINUOUS)
#error SetToMeshBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    D3DRMBOX Box;
    HRESULT hr = pMesh->GetBox(&Box);
    u.C[DXB_X].Min = Box.min.x;
    u.C[DXB_X].Max = Box.max.x;
    u.C[DXB_Y].Min = Box.min.y;
    u.C[DXB_Y].Max = Box.max.y;
    u.C[DXB_Z].Min = Box.min.z;
    u.C[DXB_Z].Max = Box.max.z;
    u.C[DXB_T].Min = 0;
    u.C[DXB_T].Max = 1.;
    return hr;
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE mid = (CDXB_T[i].Min + CDXB_T[i].Max) / 2;
        TYPE scale = CDXV_O(v)[i] * (CDXB_T[i].Max - mid);
        CDXB_T[i].Min = mid - scale;
        CDXB_T[i].Max = mid + scale;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Scale(CDXV_C(x, y, z, t));
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE scale = CDXV_O(v)[i] / 2;
        CDXB_T[i].Min -= scale;
        CDXB_T[i].Max += scale;
    }
}

    
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Expand(CDXV_C(x, y, z, t));
}


//---
typedef CDXBnds<long, unsigned long, DXDBND, DXBT_DISCRETE> CDXDBnds;
typedef CDXBnds<LONGLONG, ULONGLONG, DXDBND64, DXBT_DISCRETE64> CDXDBnds64;
typedef CDXBnds<float, float, DXCBND, DXBT_CONTINUOUS> CDXCBnds;
typedef CDXBnds<double, double, DXCBND64, DXBT_CONTINUOUS64> CDXCBnds64;

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================


//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxclrhlp.h ===
HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor );

typedef struct _COLORVALUE_PAIR
{
    const CHAR  *szName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { ("aliceblue"),             0xfff0f8ff },
    { ("antiquewhite"),          0xfffaebd7 },
    { ("aqua"),                  0xff00ffff },
    { ("aquamarine"),            0xff7fffd4 },
    { ("azure"),                 0xfff0ffff },
    { ("beige"),                 0xfff5f5dc },
    { ("bisque"),                0xffffe4c4 },
    { ("black"),                 0xff000000 },
    { ("blanchedalmond"),        0xffffebcd },
    { ("blue"),                  0xff0000ff },
    { ("blueviolet"),            0xff8a2be2 },
    { ("brown"),                 0xffa52a2a },
    { ("burlywood"),             0xffdeb887 },
    { ("cadetblue"),             0xff5f9ea0 },
    { ("chartreuse"),            0xff7fff00 },
    { ("chocolate"),             0xffd2691e },
    { ("coral"),                 0xffff7f50 },
    { ("cornflowerblue"),        0xff6495ed },
    { ("cornsilk"),              0xfffff8dc },
    { ("crimson"),               0xffdc143c },
    { ("cyan"),                  0xff00ffff },
    { ("darkblue"),              0xff00008b },
    { ("darkcyan"),              0xff008b8b },
    { ("darkgoldenrod"),         0xffb8860b },
    { ("darkgray"),              0xffa9a9a9 },
    { ("darkgreen"),             0xff006400 },
    { ("darkkhaki"),             0xffbdb76b },
    { ("darkmagenta"),           0xff8b008b },
    { ("darkolivegreen"),        0xff556b2f },
    { ("darkorange"),            0xffff8c00 },
    { ("darkorchid"),            0xff9932cc },
    { ("darkred"),               0xff8b0000 },
    { ("darksalmon"),            0xffe9967a },
    { ("darkseagreen"),          0xff8fbc8f },
    { ("darkslateblue"),         0xff483d8b },
    { ("darkslategray"),         0xff2f4f4f },
    { ("darkturquoise"),         0xff00ced1 },
    { ("darkviolet"),            0xff9400d3 },
    { ("deeppink"),              0xffff1493 },
    { ("deepskyblue"),           0xff00bfff },
    { ("dimgray"),               0xff696969 },
    { ("dodgerblue"),            0xff1e90ff },
    { ("firebrick"),             0xffb22222 },
    { ("floralwhite"),           0xfffffaf0 },
    { ("forestgreen"),           0xff228b22 },
    { ("fuchsia"),               0xffff00ff },
    { ("gainsboro"),             0xffdcdcdc },
    { ("ghostwhite"),            0xfff8f8ff },
    { ("gold"),                  0xffffd700 },
    { ("goldenrod"),             0xffdaa520 },
    { ("gray"),                  0xff808080 },
    { ("green"),                 0xff008000 },
    { ("greenyellow"),           0xffadff2f },
    { ("honeydew"),              0xfff0fff0 },
    { ("hotpink"),               0xffff69b4 },
    { ("indianred"),             0xffcd5c5c },
    { ("indigo"),                0xff4b0082 },
    { ("ivory"),                 0xfffffff0 },
    { ("khaki"),                 0xfff0e68c },
    { ("lavender"),              0xffe6e6fa },
    { ("lavenderblush"),         0xfffff0f5 },
    { ("lawngreen"),             0xff7cfc00 },
    { ("lemonchiffon"),          0xfffffacd },
    { ("lightblue"),             0xffadd8e6 },
    { ("lightcoral"),            0xfff08080 },
    { ("lightcyan"),             0xffe0ffff },
    { ("lightgoldenrodyellow"),  0xfffafad2 },
    { ("lightgreen"),            0xff90ee90 },
    { ("lightgrey"),             0xffd3d3d3 },
    { ("lightpink"),             0xffffb6c1 },
    { ("lightsalmon"),           0xffffa07a },
    { ("lightseagreen"),         0xff20b2aa },
    { ("lightskyblue"),          0xff87cefa },
    { ("lightslategray"),        0xff778899 },
    { ("lightsteelblue"),        0xffb0c4de },
    { ("lightyellow"),           0xffffffe0 },
    { ("lime"),                  0xff00ff00 },
    { ("limegreen"),             0xff32cd32 },
    { ("linen"),                 0xfffaf0e6 },
    { ("magenta"),               0xffff00ff },
    { ("maroon"),                0xff800000 },
    { ("mediumaquamarine"),      0xff66cdaa },
    { ("mediumblue"),            0xff0000cd },
    { ("mediumorchid"),          0xffba55d3 },
    { ("mediumpurple"),          0xff9370db },
    { ("mediumseagreen"),        0xff3cb371 },
    { ("mediumslateblue"),       0xff7b68ee },
    { ("mediumspringgreen"),     0xff00fa9a },
    { ("mediumturquoise"),       0xff48d1cc },
    { ("mediumvioletred"),       0xffc71585 },
    { ("midnightblue"),          0xff191970 },
    { ("mintcream"),             0xfff5fffa },
    { ("mistyrose"),             0xffffe4e1 },
    { ("moccasin"),              0xffffe4b5 },
    { ("navajowhite"),           0xffffdead },
    { ("navy"),                  0xff000080 },
    { ("oldlace"),               0xfffdf5e6 },
    { ("olive"),                 0xff808000 },
    { ("olivedrab"),             0xff6b8e23 },
    { ("orange"),                0xffffa500 },
    { ("orangered"),             0xffff4500 },
    { ("orchid"),                0xffda70d6 },
    { ("palegoldenrod"),         0xffeee8aa },
    { ("palegreen"),             0xff98fb98 },
    { ("paleturquoise"),         0xffafeeee },
    { ("palevioletred"),         0xffdb7093 },
    { ("papayawhip"),            0xffffefd5 },
    { ("peachpuff"),             0xffffdab9 },
    { ("peru"),                  0xffcd853f },
    { ("pink"),                  0xffffc0cb },
    { ("plum"),                  0xffdda0dd },
    { ("powderblue"),            0xffb0e0e6 },
    { ("purple"),                0xff800080 },
    { ("red"),                   0xffff0000 },
    { ("rosybrown"),             0xffbc8f8f },
    { ("royalblue"),             0xff4169e1 },
    { ("saddlebrown"),           0xff8b4513 },
    { ("salmon"),                0xfffa8072 },
    { ("sandybrown"),            0xfff4a460 },
    { ("seagreen"),              0xff2e8b57 },
    { ("seashell"),              0xfffff5ee },
    { ("sienna"),                0xffa0522d },
    { ("silver"),                0xffc0c0c0 },
    { ("skyblue"),               0xff87ceeb },
    { ("slateblue"),             0xff6a5acd },
    { ("slategray"),             0xff708090 },
    { ("snow"),                  0xfffffafa },
    { ("springgreen"),           0xff00ff7f },
    { ("steelblue"),             0xff4682b4 },
    { ("tan"),                   0xffd2b48c },
    { ("teal"),                  0xff008080 },
    { ("thistle"),               0xffd8bfd8 },
    { ("tomato"),                0xffff6347 },
    { ("turquoise"),             0xff40e0d0 },
    { ("violet"),                0xffee82ee },
    { ("wheat"),                 0xfff5deb3 },
    { ("white"),                 0xffffffff },
    { ("whitesmoke"),            0xfff5f5f5 },
    { ("yellow"),                0xffffff00 },
    { ("yellowgreen"),           0xff9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

const COLORVALUE_PAIR 
rgSystemColorNames[] =
{
    { ("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { ("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { ("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { ("background"),         COLOR_BACKGROUND},      // Desktop background.
    { ("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { ("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { ("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { ("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { ("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { ("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { ("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { ("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { ("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { ("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { ("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { ("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { ("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { ("menu"),               COLOR_MENU},            // Menu background.
    { ("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { ("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { ("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { ("threedface"),         COLOR_3DFACE},
    { ("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { ("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { ("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { ("window"),             COLOR_WINDOW},          // Window background.
    { ("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { ("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
}; // rgSystemColorNames[]

#define SIZE_OF_SYSTEM_COLOR_TABLE (sizeof(rgSystemColorNames) / sizeof(COLORVALUE_PAIR))

//
// Used by DXColorFromBSTR to parse the hex string.
//

inline HRESULT _HexStrToDWORD( char * pch, DWORD * pdwColor )
{

    HRESULT hr = S_OK;
    short hexVals[8];
    int numVals;
    int i;
    DWORD dwmult;

    if( !pch || !pdwColor )
    {
        hr = E_FAIL;
    }
    else
    {
        //--- parse input string
        numVals = 0;
        while( *pch && numVals < 8 )
        {
            if( *pch >= '0' && *pch <= '9' )
            {
                hexVals[numVals++] = *pch++ - '0';
            }
            else if( *pch >= 'a' && *pch <= 'f' )
            {
                hexVals[numVals++] = *pch++ - 'a' + 10;
            }
            else if( *pch >= 'A' && *pch <= 'F' )
            {
                hexVals[numVals++] = *pch++ - 'A' + 10;
            }
            else
            {
                break;
            }
        }

        if( numVals < 6 )
        {
            hr = E_FAIL;
        }
        else
        {
            //--- if we were passed 7 hex digits, only use the first 6
            if( numVals == 7 )
            {
                numVals = 6;
            }

            //--- initialize multiplier
            dwmult = 1;
            *pdwColor = 0;

            //--- multiply hexVals by 16^i
            for( i = 0; i < numVals; i++ )
            {
                *pdwColor += (hexVals[numVals-(i+1)]*dwmult);
                dwmult <<= 4;
            }
        }
    }
   
    return hr;
}

// 
// Used by DXColorFromBSTR to convert a string to lower case
//

inline void StringToLowerCase( CHAR * pstrKey )
{
    if( pstrKey )
    {
        while( *pstrKey )
        {
            if( *pstrKey >= 'A' && *pstrKey <= 'Z' )
            {
                *pstrKey = 'a' + *pstrKey - 'A';
            }
            pstrKey++;
        }
    }
}


inline HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor )
{
    HRESULT hr = S_OK;
    // validate arguments
    int strLen = wcslen(Color);
    if( strLen < 3 || DXIsBadReadPtr( Color, strLen ) || 
        DXIsBadWritePtr( pdwColor, sizeof(*pdwColor) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- first check for #AARRGGBB and #RRGGBB strings
        if( Color[0] == L'#' )
        {
            CHAR ch[11] = "0xffffffff";
            if( strLen > 9 ) strLen = 9;
            if( strLen >= 7 )
            {
                WideCharToMultiByte( CP_ACP, NULL, &Color[1], strLen-1, &ch[11-strLen], strLen, NULL, NULL );
                hr = _HexStrToDWORD( &ch[2], pdwColor);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            //--- convert the string to lower case
            LPSTR pstrKey = (LPSTR) alloca((strLen + 1) * sizeof(CHAR));
            WideCharToMultiByte( CP_ACP, NULL, Color, strLen+1, pstrKey, strLen+1, NULL, NULL );
            StringToLowerCase( pstrKey );

            //--- search the string table using a binary search
            int nFirst = 0;
            int nLast = SIZE_OF_COLOR_TABLE - 1;
            int nCur, nCmp;
            bool bFound = false;
            while( (nFirst <= nLast) && !bFound )
            {
                nCur = (nFirst + nLast) / 2;
                nCmp = strcmp( rgColorNames[nCur].szName, pstrKey );
                if( nCmp < 0 )
                {
                    nFirst = nCur + 1;
                }
                else if( nCmp > 0 )
                {
                    nLast = nCur - 1;
                }
                else
                {
                    bFound = true;
                    *pdwColor = rgColorNames[nCur].dwValue;
                }
            }

            // String not in regular color table, try the system color table.

            if (!bFound)
            {
                nFirst  = 0;
                nLast   = SIZE_OF_SYSTEM_COLOR_TABLE - 1;

                while ((nFirst <= nLast) && !bFound)
                {
                    nCur = (nFirst + nLast) / 2;
                    nCmp = strcmp(rgSystemColorNames[nCur].szName, pstrKey);

                    if (nCmp < 0)
                    {
                        nFirst = nCur + 1;
                    }
                    else if (nCmp > 0)
                    {
                        nLast = nCur - 1;
                    }
                    else
                    {
                        bFound = true;
                        *pdwColor =  ::GetSysColor((int)rgSystemColorNames[nCur].dwValue);
                        *pdwColor |= 0xFF000000;
                    }
                }

                // String not found in regular or system color table.

                if (!bFound)
                {
                    hr = E_FAIL;
                }
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxerr8.h ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.h
 *  Content:    DirectX Error Library Include File
 *
 ****************************************************************************/

#ifndef _DXERR8_H_
#define _DXERR8_H_


//
//  DXGetErrorString8
//  
//  Desc:  Converts an DirectX HRESULT to a string 
//
//  Args:  HRESULT hr   Can be any error code from
//                      DPLAY D3D8 D3DX8 DMUSIC DSOUND
//
//  Return: Converted string 
//
const char*  __stdcall DXGetErrorString8A(HRESULT hr);
const WCHAR* __stdcall DXGetErrorString8W(HRESULT hr);

#ifdef UNICODE
    #define DXGetErrorString8 DXGetErrorString8W
#else
    #define DXGetErrorString8 DXGetErrorString8A
#endif 


//
//  DXTrace
//
//  Desc:  Outputs a formatted error message to the debug stream
//
//  Args:  CHAR* strFile   The current file, typically passed in using the 
//                         __FILE__ macro.
//         DWORD dwLine    The current line number, typically passed in using the 
//                         __LINE__ macro.
//         HRESULT hr      An HRESULT that will be traced to the debug stream.
//         CHAR* strMsg    A string that will be traced to the debug stream (may be NULL)
//         BOOL bPopMsgBox If TRUE, then a message box will popup also containing the passed info.
//
//  Return: The hr that was passed in.  
//
HRESULT __stdcall DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, char* strMsg, BOOL bPopMsgBox = FALSE );
HRESULT __stdcall DXTraceW( char* strFile, DWORD dwLine, HRESULT hr, WCHAR* strMsg, BOOL bPopMsgBox = FALSE );

#ifdef UNICODE
    #define DXTrace DXTraceW
#else
    #define DXTrace DXTraceA
#endif 


//
// Helper macros
//
#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE_MSG(str)              DXTrace( __FILE__, (DWORD)__LINE__, 0, str, FALSE )
    #define DXTRACE_ERR(str,hr)           DXTrace( __FILE__, (DWORD)__LINE__, hr, str, TRUE )
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  DXTrace( __FILE__, (DWORD)__LINE__, hr, str, FALSE )
#else
    #define DXTRACE_MSG(str)              (0L)
    #define DXTRACE_ERR(str,hr)           (hr)
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  (hr)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxHelp3.Cpp ===
// DXHELP3.cpp : Contains routines shared by multiple 3D effects
#include "dxhelp3.h"
#include <malloc.h>
#include <math.h>
#include <stdio.h>

void Rotate::Set(D3DVECTOR d3dvctrNormal, double dAngle)
{
#ifdef _DEBUG
    float NormalSum =   d3dvctrNormal.x * d3dvctrNormal.x + 
                        d3dvctrNormal.y * d3dvctrNormal.y + 
                        d3dvctrNormal.z * d3dvctrNormal.z;
    _ASSERT(NormalSum == 0.0f || (0.99f < NormalSum && NormalSum < 1.01f));
#endif

    // The following transformation matrix routines are from
    // Graphics Gems (the first one) page 466 (Converting 
    // between Matrix and Axis-Amount Representations)
    float s = (float)sin(dAngle), c = (float)cos(dAngle);
    float t = 1.0f - c;

    m_d3dvctrXComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.x + c;
    m_d3dvctrXComponent.y = t * d3dvctrNormal.x * d3dvctrNormal.y - s * d3dvctrNormal.z;
    m_d3dvctrXComponent.z = t * d3dvctrNormal.x * d3dvctrNormal.z + s * d3dvctrNormal.y;

    m_d3dvctrYComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.y + s * d3dvctrNormal.z;
    m_d3dvctrYComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.y + c;
    m_d3dvctrYComponent.z = t * d3dvctrNormal.y * d3dvctrNormal.z - s * d3dvctrNormal.x;

    m_d3dvctrZComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.z - s * d3dvctrNormal.y;
    m_d3dvctrZComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.z + s * d3dvctrNormal.x;
    m_d3dvctrZComponent.z = t * d3dvctrNormal.z * d3dvctrNormal.z + c;
}

static HRESULT DecoupleOneMeshBuilder(void *lpThis /* Ignored */, 
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderOut,
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderIn)
{
    HRESULT hr = lpMeshBuilderOut->SetAppData(lpMeshBuilderIn->GetAppData());

    if(FAILED(hr))
    {
	return hr;
    }

    const int ciOutputFaceCount = lpMeshBuilderOut->GetFaceCount();
    const int ciMaxFaceCount = lpMeshBuilderIn->GetFaceCount();
    if(!ciMaxFaceCount)
    {
	return hr;
    }
    CComPtr<IDirect3DRMFaceArray> cpD3DRMFaceArray;

    hr = lpMeshBuilderIn->GetFaces(&cpD3DRMFaceArray);
    if(hr != D3DRM_OK)
    {
	return hr;
    }

    D3DVECTOR *lpvctrPosition = NULL;
    D3DVECTOR *lpvctrFaceNormals = NULL;
    DWORD dwMaxVertexCount = 0;

    // By reserving space we speed things up by a factor of 20 or 30 X!

    DWORD dwTotalVertexCount = lpMeshBuilderIn->GetVertexCount();
    _ASSERT(dwTotalVertexCount >= 3);
    if (dwTotalVertexCount/ciMaxFaceCount < 3)
    {
	dwTotalVertexCount = ciMaxFaceCount * 3;  // There will be at least 3 vertices per face.
    }
    hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount);

    if(hr != D3DRM_OK)
    {
	return hr;
    }

    // Need to have seperate vertices for each face in the output mesh.
    int iFaceIndex = 0;
    do
    {
	CComPtr<IDirect3DRMFace> cpd3dInFaceTemp;
	CComPtr<IDirect3DRMFace2> cpd3dOutFace;

        if(FAILED(hr = cpD3DRMFaceArray->GetElement((DWORD)iFaceIndex, &cpd3dInFaceTemp)))
        {
            break;
        }
        _ASSERT(cpd3dInFaceTemp);

	CComPtr<IDirect3DRMFace2> cpd3dInFace;
	if(FAILED(hr = cpd3dInFaceTemp->QueryInterface(
		IID_IDirect3DRMFace2, (void **)&cpd3dInFace)))
	{
	    break;
	}

        DWORD dwVertexCount;

        cpd3dInFace->GetVertices(&dwVertexCount, NULL, NULL);
        _ASSERT(dwVertexCount >= 3);

        if(dwVertexCount > dwMaxVertexCount)
        {
            dwMaxVertexCount = dwVertexCount;

	    D3DVECTOR *lpTemp = lpvctrPosition;
            D3DVECTOR *lpNormalTemp = lpvctrFaceNormals;

	    lpvctrPosition = (D3DVECTOR *)realloc(lpvctrPosition, dwMaxVertexCount * sizeof (*lpvctrPosition));
	    lpvctrFaceNormals = (D3DVECTOR *)realloc(lpvctrFaceNormals, dwMaxVertexCount * sizeof (*lpvctrFaceNormals));

	    if(!lpvctrPosition || !lpvctrFaceNormals)
	    {
		free(lpTemp);
		free(lpNormalTemp);
		hr = E_OUTOFMEMORY;
		break;
	    }

	    // We may have a problem in the amount of space reserved in the output meshbuilder.
	    if((ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount > dwTotalVertexCount)
	    {
		dwTotalVertexCount = (ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount;
		hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount - iFaceIndex);

		if(hr != D3DRM_OK)
		{
		    break;
		}
	    }
        }

        if(FAILED(hr = cpd3dInFace->GetVertices(&dwVertexCount, lpvctrPosition, lpvctrFaceNormals)) ||
	   FAILED(hr = lpMeshBuilderOut->CreateFace(&cpd3dOutFace)) ||
	   FAILED(hr = cpd3dOutFace->SetAppData(cpd3dInFace->GetAppData())))
        {
            break;
        }


	CComPtr<IDirect3DRMMaterial2> cpMaterial;
        CComPtr<IDirect3DRMTexture3> cpTexture;
        BOOL bU, bV;

        if(hr != D3DRM_OK ||
          (hr = cpd3dInFace->GetMaterial(&cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetMaterial(cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetColor(cpd3dInFace->GetColor())) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTexture(&cpTexture)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTexture(cpTexture)) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTextureTopology(&bU, &bV)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTextureTopology(bU, bV)) != D3DRM_OK)
        {
            break;
        }

        DWORD dwInFaceVertex = 0;
        do
        {
            int iVIndex = lpMeshBuilderOut->AddVertex(lpvctrPosition[dwInFaceVertex].x, 
					 lpvctrPosition[dwInFaceVertex].y, 
					 lpvctrPosition[dwInFaceVertex].z);
            int iNIndex = lpMeshBuilderOut->AddNormal(lpvctrFaceNormals[dwInFaceVertex].x, 
					 lpvctrFaceNormals[dwInFaceVertex].y, 
					 lpvctrFaceNormals[dwInFaceVertex].z);

            D3DVALUE U, V;

            if(FAILED(hr = cpd3dOutFace->AddVertexAndNormalIndexed(iVIndex, iNIndex)) ||
               FAILED(hr = cpd3dInFace->GetTextureCoordinates(dwInFaceVertex, &U, &V)) ||
               FAILED(hr = cpd3dOutFace->SetTextureCoordinates(dwInFaceVertex, U, V)))
            {
                break;
            }
        } while (++dwInFaceVertex < dwVertexCount);
	dwTotalVertexCount -= dwVertexCount;
    } while (hr == D3DRM_OK && ++iFaceIndex < ciMaxFaceCount);

    free(lpvctrPosition);
    free(lpvctrFaceNormals);

    return hr;
}

HRESULT TraverseSubMeshes(  HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			    void *lpThis, 
			    IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			    IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    HRESULT hr;

    _ASSERT(lpCallBack);
    if(FAILED(hr = (*lpCallBack)(lpThis, lpMeshBuilderOut, lpMeshBuilderIn)))
	return hr;

    DWORD dwInSubMeshCount;
    hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, NULL);

    if(FAILED(hr) || dwInSubMeshCount == 0)
	return hr;

    DWORD dwOutSubMeshCount;
    if(FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, NULL)))
    {
	return hr;
    }

    const BOOL bCreateOutMeshes = (dwOutSubMeshCount == 0);
    _ASSERT(bCreateOutMeshes || dwInSubMeshCount == dwOutSubMeshCount);

    LPUNKNOWN *lplpunkInSubMeshes =
	(LPUNKNOWN *)malloc(dwInSubMeshCount * sizeof(*lplpunkInSubMeshes));

    LPUNKNOWN *lplpunkOutSubMeshes = (bCreateOutMeshes? NULL:
	(LPUNKNOWN *)malloc(dwOutSubMeshCount * sizeof(*lplpunkOutSubMeshes)));

    if(!lplpunkInSubMeshes || !bCreateOutMeshes && !lplpunkOutSubMeshes)
    {
	return E_OUTOFMEMORY;
    }

    if(FAILED(hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, lplpunkInSubMeshes)) ||
	!bCreateOutMeshes && 
	FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, lplpunkOutSubMeshes)))
    {
	return hr;
    }

    CComPtr<IDirect3DRMMeshBuilder3> cpInSubMesh, cpOutSubMesh;

    DWORD dwSubMesh;
    for(dwSubMesh = 0; SUCCEEDED(hr) && dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	cpInSubMesh = NULL;
	cpOutSubMesh = NULL;

	// Get the current input submesh.
	hr = lplpunkInSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3, 
		(void **)&cpInSubMesh);

	if(FAILED(hr))
	    break;

	if(bCreateOutMeshes)
	{
	    // Create a new submesh in the output mesh to match the input submesh.	    
	    LPUNKNOWN lpunkSubmesh;

	    if(FAILED(hr = lpMeshBuilderOut->CreateSubMesh(&lpunkSubmesh)))
		break;

	    hr = lpunkSubmesh->QueryInterface(IID_IDirect3DRMMeshBuilder3,
							(void **)&cpOutSubMesh);
	    lpunkSubmesh->Release();
	}
	else
	{
	    // Get the current output submesh.
	    hr = lplpunkOutSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3,
		    (void **)&cpOutSubMesh);
	}
	if(FAILED(hr))
	    break;

	// Do all the children for these two MeshBuilders.
	hr = TraverseSubMeshes(lpCallBack, lpThis, cpOutSubMesh, cpInSubMesh);
    }

    for(dwSubMesh = 0; dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	lplpunkInSubMeshes[dwSubMesh]->Release();

	if(lplpunkOutSubMeshes)
	{
	    lplpunkOutSubMeshes[dwSubMesh]->Release();
	}
    }

    free(lplpunkInSubMeshes);
    free(lplpunkOutSubMeshes);

    return hr;
}

HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    DWORD dwSubMeshCount;

    HRESULT hr = lpMeshBuilderOut->GetSubMeshes(&dwSubMeshCount, NULL);

    if(FAILED(hr))
	return hr;

    if(lpMeshBuilderOut->GetFaceCount() || dwSubMeshCount)
    {
	if(FAILED(hr = lpMeshBuilderOut->Empty(0)))
	    return hr;
    }
    hr = TraverseSubMeshes(DecoupleOneMeshBuilder, NULL,
			    lpMeshBuilderOut, lpMeshBuilderIn);
    return hr;
}

float GetDlgItemFloat(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return (float)strtod(szItemText, &pEnd);
}

BOOL SetDlgItemFloat( HWND hDlg, int id, float f )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2f"), f );
    return SetDlgItemText( hDlg, id, szItem );
}

double GetDlgItemDouble(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return strtod(szItemText, &pEnd);
}

BOOL SetDlgItemDouble( HWND hDlg, int id, double d )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2d"), d );
    return SetDlgItemText( hDlg, id, szItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CDXList::CNode* pPrev, CDXList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CDXList::CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CDXMap::CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxtGuid.c ===
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
//  BUGBUG -- Should we use this service provider ID for direct draw?
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxtError.h ===
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxsdk.inc ===
!IFDEF BORLAND
cc = bcc32
rc = brc32
link = ilink32
bldlib = tlib
cflags = -c -3 -j1 -X -Vd -I$(INCLUDE)
rcflags = -r -fo
linkflags = -n -V4.0 -aa 
!IFDEF main
linkflags = $(linkflags) -ap
borobjs=c0x32.obj
!ELSE
linkflags = $(linkflags) -Tpe
borobjs=c0w32.obj
!ENDIF
linkflags = $(linkflags) -j$(LIB) -L$(LIB)
libflags=$(OBJ_DIR)\$(proj).lib
outobj = -o
commas =,
outexe=
borlib=+
deflibs = import32.lib cw32mti.lib ole2w32.lib
!IFDEF MFC
cflags =$(cflags) -VF -w-hid -w-par -w-aus -w-inl -w-inq -WM -Vd /D_NO_VCL;_RTLDLL;_AFXDLL;_X86_;_WINDOWS;_MSC_VER=1100;WIN32;
!IFDEF NODEBUG
deflibs = bfc42.lib bfcs42.lib $(deflibs)
!ELSE
deflibs = BFC42D.lib BFCS42D.lib bfcd42d.lib bfco42d.lib bfcn42d.lib $(deflibs)
!ENDIF
!ENDIF

d3dframe=..\..\lib\borland\d3dframe.lib

!IFDEF nodebug
cdebug = -Od
linkdebug = /x
cflags = $(cflags) /DNDEBUG;
!ELSE
cdebug = -Od -v -y
linkdebug = /v
cflags = $(cflags) /DDEBUG;
!ENDIF

!ELSE
!IFDEF WATCOM
cc = cl
rc = rc
link = link
bldlib = lib
deflibs = kernel32.lib gdi32.lib user32.lib advapi32.lib gdi32.lib comdlg32.lib winspool.lib shell32.lib winmm.lib comctl32.lib ole32.lib oleaut32.lib
cflags = -c /D "WIN32" /D "_WINDOWS"
!IFDEF NODEBUG
cflags =$(cflags) /D "NDEBUG"
cdebug = -Ox
linkdebug =
!IFDEF MFC
cflags =$(cflags) /MD /D "_AFXDLL"
!ELSE
cflags =$(cflags) /ML
!ENDIF
!ELSE
cflags =$(cflags) /D "DEBUG"
cdebug = -Z7 -Ox
linkdebug = -map -debug:full
!IFDEF MFC
cflags =$(cflags) /MDd /D "_AFXDLL"
!ELSE
cflags =$(cflags) /MLd
!ENDIF
!ENDIF
rcflags = -r -fo
linkflags = /INCREMENTAL:NO /NOLOGO
!IFDEF main
linkflags = $(linkflags) /SUBSYSTEM:CONSOLE
!ELSE
linkflags = $(linkflags) /SUBSYSTEM:WINDOWS
!ENDIF
libflags=/OUT:$(OBJ_DIR)\$(proj).lib
outobj = -Fo
commas=
outexe=-out:
borobjs=
borlib=
d3dframe=..\..\lib\watcom\d3dframe.lib

!ELSE
cc = cl
rc = rc
link = link
bldlib = lib
deflibs = kernel32.lib gdi32.lib user32.lib advapi32.lib gdi32.lib comdlg32.lib winspool.lib shell32.lib winmm.lib comctl32.lib ole32.lib oleaut32.lib
cflags = -c /D "WIN32" /D "_WINDOWS"
linkflags=
!IFDEF NODEBUG
cflags =$(cflags) /D "NDEBUG"
cdebug = -Ox
linkdebug = /RELEASE
!IFDEF MFC
cflags =$(cflags) /MD /D "_AFXDLL"
!ELSE
cflags =$(cflags) /ML
!ENDIF
!ELSE
cflags = $(cflags) /D "DEBUG"
cdebug = -Z7 -Ox
linkdebug = -map -debug:full -debugtype:cv
!IFDEF MFC
cflags =$(cflags) /MDd /D "_AFXDLL"
!ELSE
linkflags = $(linkflags) /NODEFAULTLIB:LIBC
cflags =$(cflags) /MLd
!ENDIF
!ENDIF
cflags =$(cflags) 
rcflags = -r -fo
linkflags = $(linkflags) /INCREMENTAL:NO /PDB:NONE /NOLOGO
!IFDEF main
linkflags = $(linkflags) /SUBSYSTEM:CONSOLE
!ELSE
linkflags = $(linkflags) /SUBSYSTEM:WINDOWS
!ENDIF
libflags=/OUT:$(OBJ_DIR)\$(proj).lib /SUBSYSTEM:WINDOWS
outobj = -Fo
commas=
outexe=-out:
borobjs=
borlib=
d3dframe=..\..\lib\d3dframe.lib

!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxtmsft.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dxtmsft.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft_h__
#define __dxtmsft_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXLUTBuilder_FWD_DEFINED__
#define __IDXLUTBuilder_FWD_DEFINED__
typedef interface IDXLUTBuilder IDXLUTBuilder;
#endif 	/* __IDXLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXDLUTBuilder_FWD_DEFINED__
#define __IDXDLUTBuilder_FWD_DEFINED__
typedef interface IDXDLUTBuilder IDXDLUTBuilder;
#endif 	/* __IDXDLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXTGradientD_FWD_DEFINED__
#define __IDXTGradientD_FWD_DEFINED__
typedef interface IDXTGradientD IDXTGradientD;
#endif 	/* __IDXTGradientD_FWD_DEFINED__ */


#ifndef __IDXTConvolution_FWD_DEFINED__
#define __IDXTConvolution_FWD_DEFINED__
typedef interface IDXTConvolution IDXTConvolution;
#endif 	/* __IDXTConvolution_FWD_DEFINED__ */


#ifndef __IDXMapper_FWD_DEFINED__
#define __IDXMapper_FWD_DEFINED__
typedef interface IDXMapper IDXMapper;
#endif 	/* __IDXMapper_FWD_DEFINED__ */


#ifndef __IDXDMapper_FWD_DEFINED__
#define __IDXDMapper_FWD_DEFINED__
typedef interface IDXDMapper IDXDMapper;
#endif 	/* __IDXDMapper_FWD_DEFINED__ */


#ifndef __IDXTComposite_FWD_DEFINED__
#define __IDXTComposite_FWD_DEFINED__
typedef interface IDXTComposite IDXTComposite;
#endif 	/* __IDXTComposite_FWD_DEFINED__ */


#ifndef __IDXTWipe_FWD_DEFINED__
#define __IDXTWipe_FWD_DEFINED__
typedef interface IDXTWipe IDXTWipe;
#endif 	/* __IDXTWipe_FWD_DEFINED__ */


#ifndef __IDXTWipe2_FWD_DEFINED__
#define __IDXTWipe2_FWD_DEFINED__
typedef interface IDXTWipe2 IDXTWipe2;
#endif 	/* __IDXTWipe2_FWD_DEFINED__ */


#ifndef __ICrBlur_FWD_DEFINED__
#define __ICrBlur_FWD_DEFINED__
typedef interface ICrBlur ICrBlur;
#endif 	/* __ICrBlur_FWD_DEFINED__ */


#ifndef __ICrEngrave_FWD_DEFINED__
#define __ICrEngrave_FWD_DEFINED__
typedef interface ICrEngrave ICrEngrave;
#endif 	/* __ICrEngrave_FWD_DEFINED__ */


#ifndef __ICrEmboss_FWD_DEFINED__
#define __ICrEmboss_FWD_DEFINED__
typedef interface ICrEmboss ICrEmboss;
#endif 	/* __ICrEmboss_FWD_DEFINED__ */


#ifndef __IDXTFade_FWD_DEFINED__
#define __IDXTFade_FWD_DEFINED__
typedef interface IDXTFade IDXTFade;
#endif 	/* __IDXTFade_FWD_DEFINED__ */


#ifndef __IDXBasicImage_FWD_DEFINED__
#define __IDXBasicImage_FWD_DEFINED__
typedef interface IDXBasicImage IDXBasicImage;
#endif 	/* __IDXBasicImage_FWD_DEFINED__ */


#ifndef __IDXPixelate_FWD_DEFINED__
#define __IDXPixelate_FWD_DEFINED__
typedef interface IDXPixelate IDXPixelate;
#endif 	/* __IDXPixelate_FWD_DEFINED__ */


#ifndef __ICrIris_FWD_DEFINED__
#define __ICrIris_FWD_DEFINED__
typedef interface ICrIris ICrIris;
#endif 	/* __ICrIris_FWD_DEFINED__ */


#ifndef __ICrIris2_FWD_DEFINED__
#define __ICrIris2_FWD_DEFINED__
typedef interface ICrIris2 ICrIris2;
#endif 	/* __ICrIris2_FWD_DEFINED__ */


#ifndef __ICrSlide_FWD_DEFINED__
#define __ICrSlide_FWD_DEFINED__
typedef interface ICrSlide ICrSlide;
#endif 	/* __ICrSlide_FWD_DEFINED__ */


#ifndef __ICrRadialWipe_FWD_DEFINED__
#define __ICrRadialWipe_FWD_DEFINED__
typedef interface ICrRadialWipe ICrRadialWipe;
#endif 	/* __ICrRadialWipe_FWD_DEFINED__ */


#ifndef __ICrBarn_FWD_DEFINED__
#define __ICrBarn_FWD_DEFINED__
typedef interface ICrBarn ICrBarn;
#endif 	/* __ICrBarn_FWD_DEFINED__ */


#ifndef __ICrBarn2_FWD_DEFINED__
#define __ICrBarn2_FWD_DEFINED__
typedef interface ICrBarn2 ICrBarn2;
#endif 	/* __ICrBarn2_FWD_DEFINED__ */


#ifndef __ICrBlinds_FWD_DEFINED__
#define __ICrBlinds_FWD_DEFINED__
typedef interface ICrBlinds ICrBlinds;
#endif 	/* __ICrBlinds_FWD_DEFINED__ */


#ifndef __ICrBlinds2_FWD_DEFINED__
#define __ICrBlinds2_FWD_DEFINED__
typedef interface ICrBlinds2 ICrBlinds2;
#endif 	/* __ICrBlinds2_FWD_DEFINED__ */


#ifndef __ICrInset_FWD_DEFINED__
#define __ICrInset_FWD_DEFINED__
typedef interface ICrInset ICrInset;
#endif 	/* __ICrInset_FWD_DEFINED__ */


#ifndef __ICrStretch_FWD_DEFINED__
#define __ICrStretch_FWD_DEFINED__
typedef interface ICrStretch ICrStretch;
#endif 	/* __ICrStretch_FWD_DEFINED__ */


#ifndef __IDXTGridSize_FWD_DEFINED__
#define __IDXTGridSize_FWD_DEFINED__
typedef interface IDXTGridSize IDXTGridSize;
#endif 	/* __IDXTGridSize_FWD_DEFINED__ */


#ifndef __ICrSpiral_FWD_DEFINED__
#define __ICrSpiral_FWD_DEFINED__
typedef interface ICrSpiral ICrSpiral;
#endif 	/* __ICrSpiral_FWD_DEFINED__ */


#ifndef __ICrZigzag_FWD_DEFINED__
#define __ICrZigzag_FWD_DEFINED__
typedef interface ICrZigzag ICrZigzag;
#endif 	/* __ICrZigzag_FWD_DEFINED__ */


#ifndef __ICrWheel_FWD_DEFINED__
#define __ICrWheel_FWD_DEFINED__
typedef interface ICrWheel ICrWheel;
#endif 	/* __ICrWheel_FWD_DEFINED__ */


#ifndef __IDXTChroma_FWD_DEFINED__
#define __IDXTChroma_FWD_DEFINED__
typedef interface IDXTChroma IDXTChroma;
#endif 	/* __IDXTChroma_FWD_DEFINED__ */


#ifndef __IDXTDropShadow_FWD_DEFINED__
#define __IDXTDropShadow_FWD_DEFINED__
typedef interface IDXTDropShadow IDXTDropShadow;
#endif 	/* __IDXTDropShadow_FWD_DEFINED__ */


#ifndef __IDXTCheckerBoard_FWD_DEFINED__
#define __IDXTCheckerBoard_FWD_DEFINED__
typedef interface IDXTCheckerBoard IDXTCheckerBoard;
#endif 	/* __IDXTCheckerBoard_FWD_DEFINED__ */


#ifndef __IDXTRevealTrans_FWD_DEFINED__
#define __IDXTRevealTrans_FWD_DEFINED__
typedef interface IDXTRevealTrans IDXTRevealTrans;
#endif 	/* __IDXTRevealTrans_FWD_DEFINED__ */


#ifndef __IDXTMask_FWD_DEFINED__
#define __IDXTMask_FWD_DEFINED__
typedef interface IDXTMask IDXTMask;
#endif 	/* __IDXTMask_FWD_DEFINED__ */


#ifndef __IDXTRedirect_FWD_DEFINED__
#define __IDXTRedirect_FWD_DEFINED__
typedef interface IDXTRedirect IDXTRedirect;
#endif 	/* __IDXTRedirect_FWD_DEFINED__ */


#ifndef __IDXTAlphaImageLoader_FWD_DEFINED__
#define __IDXTAlphaImageLoader_FWD_DEFINED__
typedef interface IDXTAlphaImageLoader IDXTAlphaImageLoader;
#endif 	/* __IDXTAlphaImageLoader_FWD_DEFINED__ */


#ifndef __IDXTRandomBars_FWD_DEFINED__
#define __IDXTRandomBars_FWD_DEFINED__
typedef interface IDXTRandomBars IDXTRandomBars;
#endif 	/* __IDXTRandomBars_FWD_DEFINED__ */


#ifndef __IDXTStrips_FWD_DEFINED__
#define __IDXTStrips_FWD_DEFINED__
typedef interface IDXTStrips IDXTStrips;
#endif 	/* __IDXTStrips_FWD_DEFINED__ */


#ifndef __IDXTMetaRoll_FWD_DEFINED__
#define __IDXTMetaRoll_FWD_DEFINED__
typedef interface IDXTMetaRoll IDXTMetaRoll;
#endif 	/* __IDXTMetaRoll_FWD_DEFINED__ */


#ifndef __IDXTMetaRipple_FWD_DEFINED__
#define __IDXTMetaRipple_FWD_DEFINED__
typedef interface IDXTMetaRipple IDXTMetaRipple;
#endif 	/* __IDXTMetaRipple_FWD_DEFINED__ */


#ifndef __IDXTMetaPageTurn_FWD_DEFINED__
#define __IDXTMetaPageTurn_FWD_DEFINED__
typedef interface IDXTMetaPageTurn IDXTMetaPageTurn;
#endif 	/* __IDXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __IDXTMetaLiquid_FWD_DEFINED__
#define __IDXTMetaLiquid_FWD_DEFINED__
typedef interface IDXTMetaLiquid IDXTMetaLiquid;
#endif 	/* __IDXTMetaLiquid_FWD_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_FWD_DEFINED__
#define __IDXTMetaCenterPeel_FWD_DEFINED__
typedef interface IDXTMetaCenterPeel IDXTMetaCenterPeel;
#endif 	/* __IDXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_FWD_DEFINED__
#define __IDXTMetaPeelSmall_FWD_DEFINED__
typedef interface IDXTMetaPeelSmall IDXTMetaPeelSmall;
#endif 	/* __IDXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_FWD_DEFINED__
#define __IDXTMetaPeelPiece_FWD_DEFINED__
typedef interface IDXTMetaPeelPiece IDXTMetaPeelPiece;
#endif 	/* __IDXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_FWD_DEFINED__
#define __IDXTMetaPeelSplit_FWD_DEFINED__
typedef interface IDXTMetaPeelSplit IDXTMetaPeelSplit;
#endif 	/* __IDXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __IDXTMetaWater_FWD_DEFINED__
#define __IDXTMetaWater_FWD_DEFINED__
typedef interface IDXTMetaWater IDXTMetaWater;
#endif 	/* __IDXTMetaWater_FWD_DEFINED__ */


#ifndef __IDXTMetaLightWipe_FWD_DEFINED__
#define __IDXTMetaLightWipe_FWD_DEFINED__
typedef interface IDXTMetaLightWipe IDXTMetaLightWipe;
#endif 	/* __IDXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_FWD_DEFINED__
#define __IDXTMetaRadialScaleWipe_FWD_DEFINED__
typedef interface IDXTMetaRadialScaleWipe IDXTMetaRadialScaleWipe;
#endif 	/* __IDXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_FWD_DEFINED__
#define __IDXTMetaWhiteOut_FWD_DEFINED__
typedef interface IDXTMetaWhiteOut IDXTMetaWhiteOut;
#endif 	/* __IDXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __IDXTMetaTwister_FWD_DEFINED__
#define __IDXTMetaTwister_FWD_DEFINED__
typedef interface IDXTMetaTwister IDXTMetaTwister;
#endif 	/* __IDXTMetaTwister_FWD_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_FWD_DEFINED__
#define __IDXTMetaBurnFilm_FWD_DEFINED__
typedef interface IDXTMetaBurnFilm IDXTMetaBurnFilm;
#endif 	/* __IDXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __IDXTMetaJaws_FWD_DEFINED__
#define __IDXTMetaJaws_FWD_DEFINED__
typedef interface IDXTMetaJaws IDXTMetaJaws;
#endif 	/* __IDXTMetaJaws_FWD_DEFINED__ */


#ifndef __IDXTMetaColorFade_FWD_DEFINED__
#define __IDXTMetaColorFade_FWD_DEFINED__
typedef interface IDXTMetaColorFade IDXTMetaColorFade;
#endif 	/* __IDXTMetaColorFade_FWD_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_FWD_DEFINED__
#define __IDXTMetaFlowMotion_FWD_DEFINED__
typedef interface IDXTMetaFlowMotion IDXTMetaFlowMotion;
#endif 	/* __IDXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __IDXTMetaVacuum_FWD_DEFINED__
#define __IDXTMetaVacuum_FWD_DEFINED__
typedef interface IDXTMetaVacuum IDXTMetaVacuum;
#endif 	/* __IDXTMetaVacuum_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler_FWD_DEFINED__
#define __IDXTMetaGriddler_FWD_DEFINED__
typedef interface IDXTMetaGriddler IDXTMetaGriddler;
#endif 	/* __IDXTMetaGriddler_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler2_FWD_DEFINED__
#define __IDXTMetaGriddler2_FWD_DEFINED__
typedef interface IDXTMetaGriddler2 IDXTMetaGriddler2;
#endif 	/* __IDXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __IDXTMetaThreshold_FWD_DEFINED__
#define __IDXTMetaThreshold_FWD_DEFINED__
typedef interface IDXTMetaThreshold IDXTMetaThreshold;
#endif 	/* __IDXTMetaThreshold_FWD_DEFINED__ */


#ifndef __IDXTMetaWormHole_FWD_DEFINED__
#define __IDXTMetaWormHole_FWD_DEFINED__
typedef interface IDXTMetaWormHole IDXTMetaWormHole;
#endif 	/* __IDXTMetaWormHole_FWD_DEFINED__ */


#ifndef __IDXTAlpha_FWD_DEFINED__
#define __IDXTAlpha_FWD_DEFINED__
typedef interface IDXTAlpha IDXTAlpha;
#endif 	/* __IDXTAlpha_FWD_DEFINED__ */


#ifndef __IDXTGlow_FWD_DEFINED__
#define __IDXTGlow_FWD_DEFINED__
typedef interface IDXTGlow IDXTGlow;
#endif 	/* __IDXTGlow_FWD_DEFINED__ */


#ifndef __IDXTShadow_FWD_DEFINED__
#define __IDXTShadow_FWD_DEFINED__
typedef interface IDXTShadow IDXTShadow;
#endif 	/* __IDXTShadow_FWD_DEFINED__ */


#ifndef __IDXTWave_FWD_DEFINED__
#define __IDXTWave_FWD_DEFINED__
typedef interface IDXTWave IDXTWave;
#endif 	/* __IDXTWave_FWD_DEFINED__ */


#ifndef __IDXTLight_FWD_DEFINED__
#define __IDXTLight_FWD_DEFINED__
typedef interface IDXTLight IDXTLight;
#endif 	/* __IDXTLight_FWD_DEFINED__ */


#ifndef __IDXTMotionBlur_FWD_DEFINED__
#define __IDXTMotionBlur_FWD_DEFINED__
typedef interface IDXTMotionBlur IDXTMotionBlur;
#endif 	/* __IDXTMotionBlur_FWD_DEFINED__ */


#ifndef __IDXTMatrix_FWD_DEFINED__
#define __IDXTMatrix_FWD_DEFINED__
typedef interface IDXTMatrix IDXTMatrix;
#endif 	/* __IDXTMatrix_FWD_DEFINED__ */


#ifndef __IDXTICMFilter_FWD_DEFINED__
#define __IDXTICMFilter_FWD_DEFINED__
typedef interface IDXTICMFilter IDXTICMFilter;
#endif 	/* __IDXTICMFilter_FWD_DEFINED__ */


#ifndef __DXTComposite_FWD_DEFINED__
#define __DXTComposite_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTComposite DXTComposite;
#else
typedef struct DXTComposite DXTComposite;
#endif /* __cplusplus */

#endif 	/* __DXTComposite_FWD_DEFINED__ */


#ifndef __DXLUTBuilder_FWD_DEFINED__
#define __DXLUTBuilder_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXLUTBuilder DXLUTBuilder;
#else
typedef struct DXLUTBuilder DXLUTBuilder;
#endif /* __cplusplus */

#endif 	/* __DXLUTBuilder_FWD_DEFINED__ */


#ifndef __DXTGradientD_FWD_DEFINED__
#define __DXTGradientD_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientD DXTGradientD;
#else
typedef struct DXTGradientD DXTGradientD;
#endif /* __cplusplus */

#endif 	/* __DXTGradientD_FWD_DEFINED__ */


#ifndef __DXTWipe_FWD_DEFINED__
#define __DXTWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipe DXTWipe;
#else
typedef struct DXTWipe DXTWipe;
#endif /* __cplusplus */

#endif 	/* __DXTWipe_FWD_DEFINED__ */


#ifndef __DXTGradientWipe_FWD_DEFINED__
#define __DXTGradientWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientWipe DXTGradientWipe;
#else
typedef struct DXTGradientWipe DXTGradientWipe;
#endif /* __cplusplus */

#endif 	/* __DXTGradientWipe_FWD_DEFINED__ */


#ifndef __DXTWipePP_FWD_DEFINED__
#define __DXTWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipePP DXTWipePP;
#else
typedef struct DXTWipePP DXTWipePP;
#endif /* __cplusplus */

#endif 	/* __DXTWipePP_FWD_DEFINED__ */


#ifndef __DXTConvolution_FWD_DEFINED__
#define __DXTConvolution_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTConvolution DXTConvolution;
#else
typedef struct DXTConvolution DXTConvolution;
#endif /* __cplusplus */

#endif 	/* __DXTConvolution_FWD_DEFINED__ */


#ifndef __CrBlur_FWD_DEFINED__
#define __CrBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlur CrBlur;
#else
typedef struct CrBlur CrBlur;
#endif /* __cplusplus */

#endif 	/* __CrBlur_FWD_DEFINED__ */


#ifndef __CrEmboss_FWD_DEFINED__
#define __CrEmboss_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEmboss CrEmboss;
#else
typedef struct CrEmboss CrEmboss;
#endif /* __cplusplus */

#endif 	/* __CrEmboss_FWD_DEFINED__ */


#ifndef __CrEngrave_FWD_DEFINED__
#define __CrEngrave_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEngrave CrEngrave;
#else
typedef struct CrEngrave CrEngrave;
#endif /* __cplusplus */

#endif 	/* __CrEngrave_FWD_DEFINED__ */


#ifndef __DXFade_FWD_DEFINED__
#define __DXFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXFade DXFade;
#else
typedef struct DXFade DXFade;
#endif /* __cplusplus */

#endif 	/* __DXFade_FWD_DEFINED__ */


#ifndef __FadePP_FWD_DEFINED__
#define __FadePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class FadePP FadePP;
#else
typedef struct FadePP FadePP;
#endif /* __cplusplus */

#endif 	/* __FadePP_FWD_DEFINED__ */


#ifndef __BasicImageEffects_FWD_DEFINED__
#define __BasicImageEffects_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffects BasicImageEffects;
#else
typedef struct BasicImageEffects BasicImageEffects;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffects_FWD_DEFINED__ */


#ifndef __BasicImageEffectsPP_FWD_DEFINED__
#define __BasicImageEffectsPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffectsPP BasicImageEffectsPP;
#else
typedef struct BasicImageEffectsPP BasicImageEffectsPP;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffectsPP_FWD_DEFINED__ */


#ifndef __Pixelate_FWD_DEFINED__
#define __Pixelate_FWD_DEFINED__

#ifdef __cplusplus
typedef class Pixelate Pixelate;
#else
typedef struct Pixelate Pixelate;
#endif /* __cplusplus */

#endif 	/* __Pixelate_FWD_DEFINED__ */


#ifndef __PixelatePP_FWD_DEFINED__
#define __PixelatePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class PixelatePP PixelatePP;
#else
typedef struct PixelatePP PixelatePP;
#endif /* __cplusplus */

#endif 	/* __PixelatePP_FWD_DEFINED__ */


#ifndef __CrBlurPP_FWD_DEFINED__
#define __CrBlurPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlurPP CrBlurPP;
#else
typedef struct CrBlurPP CrBlurPP;
#endif /* __cplusplus */

#endif 	/* __CrBlurPP_FWD_DEFINED__ */


#ifndef __GradientPP_FWD_DEFINED__
#define __GradientPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class GradientPP GradientPP;
#else
typedef struct GradientPP GradientPP;
#endif /* __cplusplus */

#endif 	/* __GradientPP_FWD_DEFINED__ */


#ifndef __CompositePP_FWD_DEFINED__
#define __CompositePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompositePP CompositePP;
#else
typedef struct CompositePP CompositePP;
#endif /* __cplusplus */

#endif 	/* __CompositePP_FWD_DEFINED__ */


#ifndef __ConvolvePP_FWD_DEFINED__
#define __ConvolvePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConvolvePP ConvolvePP;
#else
typedef struct ConvolvePP ConvolvePP;
#endif /* __cplusplus */

#endif 	/* __ConvolvePP_FWD_DEFINED__ */


#ifndef __LUTBuilderPP_FWD_DEFINED__
#define __LUTBuilderPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class LUTBuilderPP LUTBuilderPP;
#else
typedef struct LUTBuilderPP LUTBuilderPP;
#endif /* __cplusplus */

#endif 	/* __LUTBuilderPP_FWD_DEFINED__ */


#ifndef __CrIris_FWD_DEFINED__
#define __CrIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIris CrIris;
#else
typedef struct CrIris CrIris;
#endif /* __cplusplus */

#endif 	/* __CrIris_FWD_DEFINED__ */


#ifndef __DXTIris_FWD_DEFINED__
#define __DXTIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTIris DXTIris;
#else
typedef struct DXTIris DXTIris;
#endif /* __cplusplus */

#endif 	/* __DXTIris_FWD_DEFINED__ */


#ifndef __CrIrisPP_FWD_DEFINED__
#define __CrIrisPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIrisPP CrIrisPP;
#else
typedef struct CrIrisPP CrIrisPP;
#endif /* __cplusplus */

#endif 	/* __CrIrisPP_FWD_DEFINED__ */


#ifndef __CrSlide_FWD_DEFINED__
#define __CrSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlide CrSlide;
#else
typedef struct CrSlide CrSlide;
#endif /* __cplusplus */

#endif 	/* __CrSlide_FWD_DEFINED__ */


#ifndef __DXTSlide_FWD_DEFINED__
#define __DXTSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSlide DXTSlide;
#else
typedef struct DXTSlide DXTSlide;
#endif /* __cplusplus */

#endif 	/* __DXTSlide_FWD_DEFINED__ */


#ifndef __CrSlidePP_FWD_DEFINED__
#define __CrSlidePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlidePP CrSlidePP;
#else
typedef struct CrSlidePP CrSlidePP;
#endif /* __cplusplus */

#endif 	/* __CrSlidePP_FWD_DEFINED__ */


#ifndef __CrRadialWipe_FWD_DEFINED__
#define __CrRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipe CrRadialWipe;
#else
typedef struct CrRadialWipe CrRadialWipe;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipe_FWD_DEFINED__ */


#ifndef __DXTRadialWipe_FWD_DEFINED__
#define __DXTRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRadialWipe DXTRadialWipe;
#else
typedef struct DXTRadialWipe DXTRadialWipe;
#endif /* __cplusplus */

#endif 	/* __DXTRadialWipe_FWD_DEFINED__ */


#ifndef __CrRadialWipePP_FWD_DEFINED__
#define __CrRadialWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipePP CrRadialWipePP;
#else
typedef struct CrRadialWipePP CrRadialWipePP;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipePP_FWD_DEFINED__ */


#ifndef __CrBarn_FWD_DEFINED__
#define __CrBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBarn CrBarn;
#else
typedef struct CrBarn CrBarn;
#endif /* __cplusplus */

#endif 	/* __CrBarn_FWD_DEFINED__ */


#ifndef __DXTBarn_FWD_DEFINED__
#define __DXTBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBarn DXTBarn;
#else
typedef struct DXTBarn DXTBarn;
#endif /* __cplusplus */

#endif 	/* __DXTBarn_FWD_DEFINED__ */


#ifndef __CrBarnPP_FWD_DEFINED__
#define __CrBarnPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBarnPP CrBarnPP;
#else
typedef struct CrBarnPP CrBarnPP;
#endif /* __cplusplus */

#endif 	/* __CrBarnPP_FWD_DEFINED__ */


#ifndef __CrBlinds_FWD_DEFINED__
#define __CrBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlinds CrBlinds;
#else
typedef struct CrBlinds CrBlinds;
#endif /* __cplusplus */

#endif 	/* __CrBlinds_FWD_DEFINED__ */


#ifndef __DXTBlinds_FWD_DEFINED__
#define __DXTBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlinds DXTBlinds;
#else
typedef struct DXTBlinds DXTBlinds;
#endif /* __cplusplus */

#endif 	/* __DXTBlinds_FWD_DEFINED__ */


#ifndef __CrBlindPP_FWD_DEFINED__
#define __CrBlindPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlindPP CrBlindPP;
#else
typedef struct CrBlindPP CrBlindPP;
#endif /* __cplusplus */

#endif 	/* __CrBlindPP_FWD_DEFINED__ */


#ifndef __CrStretch_FWD_DEFINED__
#define __CrStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretch CrStretch;
#else
typedef struct CrStretch CrStretch;
#endif /* __cplusplus */

#endif 	/* __CrStretch_FWD_DEFINED__ */


#ifndef __DXTStretch_FWD_DEFINED__
#define __DXTStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTStretch DXTStretch;
#else
typedef struct DXTStretch DXTStretch;
#endif /* __cplusplus */

#endif 	/* __DXTStretch_FWD_DEFINED__ */


#ifndef __CrStretchPP_FWD_DEFINED__
#define __CrStretchPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretchPP CrStretchPP;
#else
typedef struct CrStretchPP CrStretchPP;
#endif /* __cplusplus */

#endif 	/* __CrStretchPP_FWD_DEFINED__ */


#ifndef __CrInset_FWD_DEFINED__
#define __CrInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrInset CrInset;
#else
typedef struct CrInset CrInset;
#endif /* __cplusplus */

#endif 	/* __CrInset_FWD_DEFINED__ */


#ifndef __DXTInset_FWD_DEFINED__
#define __DXTInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTInset DXTInset;
#else
typedef struct DXTInset DXTInset;
#endif /* __cplusplus */

#endif 	/* __DXTInset_FWD_DEFINED__ */


#ifndef __CrSpiral_FWD_DEFINED__
#define __CrSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiral CrSpiral;
#else
typedef struct CrSpiral CrSpiral;
#endif /* __cplusplus */

#endif 	/* __CrSpiral_FWD_DEFINED__ */


#ifndef __DXTSpiral_FWD_DEFINED__
#define __DXTSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpiral DXTSpiral;
#else
typedef struct DXTSpiral DXTSpiral;
#endif /* __cplusplus */

#endif 	/* __DXTSpiral_FWD_DEFINED__ */


#ifndef __CrSpiralPP_FWD_DEFINED__
#define __CrSpiralPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiralPP CrSpiralPP;
#else
typedef struct CrSpiralPP CrSpiralPP;
#endif /* __cplusplus */

#endif 	/* __CrSpiralPP_FWD_DEFINED__ */


#ifndef __CrZigzag_FWD_DEFINED__
#define __CrZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzag CrZigzag;
#else
typedef struct CrZigzag CrZigzag;
#endif /* __cplusplus */

#endif 	/* __CrZigzag_FWD_DEFINED__ */


#ifndef __DXTZigzag_FWD_DEFINED__
#define __DXTZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTZigzag DXTZigzag;
#else
typedef struct DXTZigzag DXTZigzag;
#endif /* __cplusplus */

#endif 	/* __DXTZigzag_FWD_DEFINED__ */


#ifndef __CrZigzagPP_FWD_DEFINED__
#define __CrZigzagPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzagPP CrZigzagPP;
#else
typedef struct CrZigzagPP CrZigzagPP;
#endif /* __cplusplus */

#endif 	/* __CrZigzagPP_FWD_DEFINED__ */


#ifndef __CrWheel_FWD_DEFINED__
#define __CrWheel_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheel CrWheel;
#else
typedef struct CrWheel CrWheel;
#endif /* __cplusplus */

#endif 	/* __CrWheel_FWD_DEFINED__ */


#ifndef __CrWheelPP_FWD_DEFINED__
#define __CrWheelPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheelPP CrWheelPP;
#else
typedef struct CrWheelPP CrWheelPP;
#endif /* __cplusplus */

#endif 	/* __CrWheelPP_FWD_DEFINED__ */


#ifndef __DXTChroma_FWD_DEFINED__
#define __DXTChroma_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChroma DXTChroma;
#else
typedef struct DXTChroma DXTChroma;
#endif /* __cplusplus */

#endif 	/* __DXTChroma_FWD_DEFINED__ */


#ifndef __DXTChromaPP_FWD_DEFINED__
#define __DXTChromaPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChromaPP DXTChromaPP;
#else
typedef struct DXTChromaPP DXTChromaPP;
#endif /* __cplusplus */

#endif 	/* __DXTChromaPP_FWD_DEFINED__ */


#ifndef __DXTDropShadow_FWD_DEFINED__
#define __DXTDropShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadow DXTDropShadow;
#else
typedef struct DXTDropShadow DXTDropShadow;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadow_FWD_DEFINED__ */


#ifndef __DXTDropShadowPP_FWD_DEFINED__
#define __DXTDropShadowPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadowPP DXTDropShadowPP;
#else
typedef struct DXTDropShadowPP DXTDropShadowPP;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadowPP_FWD_DEFINED__ */


#ifndef __DXTCheckerBoard_FWD_DEFINED__
#define __DXTCheckerBoard_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTCheckerBoard DXTCheckerBoard;
#else
typedef struct DXTCheckerBoard DXTCheckerBoard;
#endif /* __cplusplus */

#endif 	/* __DXTCheckerBoard_FWD_DEFINED__ */


#ifndef __DXTCheckerBoardPP_FWD_DEFINED__
#define __DXTCheckerBoardPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTCheckerBoardPP DXTCheckerBoardPP;
#else
typedef struct DXTCheckerBoardPP DXTCheckerBoardPP;
#endif /* __cplusplus */

#endif 	/* __DXTCheckerBoardPP_FWD_DEFINED__ */


#ifndef __DXTRevealTrans_FWD_DEFINED__
#define __DXTRevealTrans_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRevealTrans DXTRevealTrans;
#else
typedef struct DXTRevealTrans DXTRevealTrans;
#endif /* __cplusplus */

#endif 	/* __DXTRevealTrans_FWD_DEFINED__ */


#ifndef __DXTMaskFilter_FWD_DEFINED__
#define __DXTMaskFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMaskFilter DXTMaskFilter;
#else
typedef struct DXTMaskFilter DXTMaskFilter;
#endif /* __cplusplus */

#endif 	/* __DXTMaskFilter_FWD_DEFINED__ */


#ifndef __DXTRedirect_FWD_DEFINED__
#define __DXTRedirect_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRedirect DXTRedirect;
#else
typedef struct DXTRedirect DXTRedirect;
#endif /* __cplusplus */

#endif 	/* __DXTRedirect_FWD_DEFINED__ */


#ifndef __DXTAlphaImageLoader_FWD_DEFINED__
#define __DXTAlphaImageLoader_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlphaImageLoader DXTAlphaImageLoader;
#else
typedef struct DXTAlphaImageLoader DXTAlphaImageLoader;
#endif /* __cplusplus */

#endif 	/* __DXTAlphaImageLoader_FWD_DEFINED__ */


#ifndef __DXTAlphaImageLoaderPP_FWD_DEFINED__
#define __DXTAlphaImageLoaderPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlphaImageLoaderPP DXTAlphaImageLoaderPP;
#else
typedef struct DXTAlphaImageLoaderPP DXTAlphaImageLoaderPP;
#endif /* __cplusplus */

#endif 	/* __DXTAlphaImageLoaderPP_FWD_DEFINED__ */


#ifndef __DXTRandomDissolve_FWD_DEFINED__
#define __DXTRandomDissolve_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRandomDissolve DXTRandomDissolve;
#else
typedef struct DXTRandomDissolve DXTRandomDissolve;
#endif /* __cplusplus */

#endif 	/* __DXTRandomDissolve_FWD_DEFINED__ */


#ifndef __DXTRandomBars_FWD_DEFINED__
#define __DXTRandomBars_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRandomBars DXTRandomBars;
#else
typedef struct DXTRandomBars DXTRandomBars;
#endif /* __cplusplus */

#endif 	/* __DXTRandomBars_FWD_DEFINED__ */


#ifndef __DXTRandomBarsPP_FWD_DEFINED__
#define __DXTRandomBarsPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRandomBarsPP DXTRandomBarsPP;
#else
typedef struct DXTRandomBarsPP DXTRandomBarsPP;
#endif /* __cplusplus */

#endif 	/* __DXTRandomBarsPP_FWD_DEFINED__ */


#ifndef __DXTStrips_FWD_DEFINED__
#define __DXTStrips_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTStrips DXTStrips;
#else
typedef struct DXTStrips DXTStrips;
#endif /* __cplusplus */

#endif 	/* __DXTStrips_FWD_DEFINED__ */


#ifndef __DXTStripsPP_FWD_DEFINED__
#define __DXTStripsPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTStripsPP DXTStripsPP;
#else
typedef struct DXTStripsPP DXTStripsPP;
#endif /* __cplusplus */

#endif 	/* __DXTStripsPP_FWD_DEFINED__ */


#ifndef __DXTMetaRoll_FWD_DEFINED__
#define __DXTMetaRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRoll DXTMetaRoll;
#else
typedef struct DXTMetaRoll DXTMetaRoll;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRoll_FWD_DEFINED__ */


#ifndef __DXTMetaRipple_FWD_DEFINED__
#define __DXTMetaRipple_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRipple DXTMetaRipple;
#else
typedef struct DXTMetaRipple DXTMetaRipple;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRipple_FWD_DEFINED__ */


#ifndef __DXTMetaPageTurn_FWD_DEFINED__
#define __DXTMetaPageTurn_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPageTurn DXTMetaPageTurn;
#else
typedef struct DXTMetaPageTurn DXTMetaPageTurn;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __DXTMetaLiquid_FWD_DEFINED__
#define __DXTMetaLiquid_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLiquid DXTMetaLiquid;
#else
typedef struct DXTMetaLiquid DXTMetaLiquid;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLiquid_FWD_DEFINED__ */


#ifndef __DXTMetaCenterPeel_FWD_DEFINED__
#define __DXTMetaCenterPeel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaCenterPeel DXTMetaCenterPeel;
#else
typedef struct DXTMetaCenterPeel DXTMetaCenterPeel;
#endif /* __cplusplus */

#endif 	/* __DXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSmall_FWD_DEFINED__
#define __DXTMetaPeelSmall_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSmall DXTMetaPeelSmall;
#else
typedef struct DXTMetaPeelSmall DXTMetaPeelSmall;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __DXTMetaPeelPiece_FWD_DEFINED__
#define __DXTMetaPeelPiece_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelPiece DXTMetaPeelPiece;
#else
typedef struct DXTMetaPeelPiece DXTMetaPeelPiece;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSplit_FWD_DEFINED__
#define __DXTMetaPeelSplit_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSplit DXTMetaPeelSplit;
#else
typedef struct DXTMetaPeelSplit DXTMetaPeelSplit;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __DXTMetaWater_FWD_DEFINED__
#define __DXTMetaWater_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWater DXTMetaWater;
#else
typedef struct DXTMetaWater DXTMetaWater;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWater_FWD_DEFINED__ */


#ifndef __DXTMetaLightWipe_FWD_DEFINED__
#define __DXTMetaLightWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLightWipe DXTMetaLightWipe;
#else
typedef struct DXTMetaLightWipe DXTMetaLightWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __DXTMetaRadialScaleWipe_FWD_DEFINED__
#define __DXTMetaRadialScaleWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#else
typedef struct DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __DXTMetaWhiteOut_FWD_DEFINED__
#define __DXTMetaWhiteOut_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWhiteOut DXTMetaWhiteOut;
#else
typedef struct DXTMetaWhiteOut DXTMetaWhiteOut;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __DXTMetaTwister_FWD_DEFINED__
#define __DXTMetaTwister_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaTwister DXTMetaTwister;
#else
typedef struct DXTMetaTwister DXTMetaTwister;
#endif /* __cplusplus */

#endif 	/* __DXTMetaTwister_FWD_DEFINED__ */


#ifndef __DXTMetaBurnFilm_FWD_DEFINED__
#define __DXTMetaBurnFilm_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaBurnFilm DXTMetaBurnFilm;
#else
typedef struct DXTMetaBurnFilm DXTMetaBurnFilm;
#endif /* __cplusplus */

#endif 	/* __DXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __DXTMetaJaws_FWD_DEFINED__
#define __DXTMetaJaws_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaJaws DXTMetaJaws;
#else
typedef struct DXTMetaJaws DXTMetaJaws;
#endif /* __cplusplus */

#endif 	/* __DXTMetaJaws_FWD_DEFINED__ */


#ifndef __DXTMetaColorFade_FWD_DEFINED__
#define __DXTMetaColorFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaColorFade DXTMetaColorFade;
#else
typedef struct DXTMetaColorFade DXTMetaColorFade;
#endif /* __cplusplus */

#endif 	/* __DXTMetaColorFade_FWD_DEFINED__ */


#ifndef __DXTMetaFlowMotion_FWD_DEFINED__
#define __DXTMetaFlowMotion_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaFlowMotion DXTMetaFlowMotion;
#else
typedef struct DXTMetaFlowMotion DXTMetaFlowMotion;
#endif /* __cplusplus */

#endif 	/* __DXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __DXTMetaVacuum_FWD_DEFINED__
#define __DXTMetaVacuum_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaVacuum DXTMetaVacuum;
#else
typedef struct DXTMetaVacuum DXTMetaVacuum;
#endif /* __cplusplus */

#endif 	/* __DXTMetaVacuum_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler_FWD_DEFINED__
#define __DXTMetaGriddler_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler DXTMetaGriddler;
#else
typedef struct DXTMetaGriddler DXTMetaGriddler;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler2_FWD_DEFINED__
#define __DXTMetaGriddler2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler2 DXTMetaGriddler2;
#else
typedef struct DXTMetaGriddler2 DXTMetaGriddler2;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __DXTMetaThreshold_FWD_DEFINED__
#define __DXTMetaThreshold_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaThreshold DXTMetaThreshold;
#else
typedef struct DXTMetaThreshold DXTMetaThreshold;
#endif /* __cplusplus */

#endif 	/* __DXTMetaThreshold_FWD_DEFINED__ */


#ifndef __DXTMetaWormHole_FWD_DEFINED__
#define __DXTMetaWormHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWormHole DXTMetaWormHole;
#else
typedef struct DXTMetaWormHole DXTMetaWormHole;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWormHole_FWD_DEFINED__ */


#ifndef __DXTGlow_FWD_DEFINED__
#define __DXTGlow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGlow DXTGlow;
#else
typedef struct DXTGlow DXTGlow;
#endif /* __cplusplus */

#endif 	/* __DXTGlow_FWD_DEFINED__ */


#ifndef __DXTShadow_FWD_DEFINED__
#define __DXTShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShadow DXTShadow;
#else
typedef struct DXTShadow DXTShadow;
#endif /* __cplusplus */

#endif 	/* __DXTShadow_FWD_DEFINED__ */


#ifndef __DXTAlpha_FWD_DEFINED__
#define __DXTAlpha_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlpha DXTAlpha;
#else
typedef struct DXTAlpha DXTAlpha;
#endif /* __cplusplus */

#endif 	/* __DXTAlpha_FWD_DEFINED__ */


#ifndef __DXTWave_FWD_DEFINED__
#define __DXTWave_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWave DXTWave;
#else
typedef struct DXTWave DXTWave;
#endif /* __cplusplus */

#endif 	/* __DXTWave_FWD_DEFINED__ */


#ifndef __DXTLight_FWD_DEFINED__
#define __DXTLight_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLight DXTLight;
#else
typedef struct DXTLight DXTLight;
#endif /* __cplusplus */

#endif 	/* __DXTLight_FWD_DEFINED__ */


#ifndef __DXTAlphaPP_FWD_DEFINED__
#define __DXTAlphaPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlphaPP DXTAlphaPP;
#else
typedef struct DXTAlphaPP DXTAlphaPP;
#endif /* __cplusplus */

#endif 	/* __DXTAlphaPP_FWD_DEFINED__ */


#ifndef __DXTGlowPP_FWD_DEFINED__
#define __DXTGlowPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGlowPP DXTGlowPP;
#else
typedef struct DXTGlowPP DXTGlowPP;
#endif /* __cplusplus */

#endif 	/* __DXTGlowPP_FWD_DEFINED__ */


#ifndef __DXTShadowPP_FWD_DEFINED__
#define __DXTShadowPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShadowPP DXTShadowPP;
#else
typedef struct DXTShadowPP DXTShadowPP;
#endif /* __cplusplus */

#endif 	/* __DXTShadowPP_FWD_DEFINED__ */


#ifndef __DXTWavePP_FWD_DEFINED__
#define __DXTWavePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWavePP DXTWavePP;
#else
typedef struct DXTWavePP DXTWavePP;
#endif /* __cplusplus */

#endif 	/* __DXTWavePP_FWD_DEFINED__ */


#ifndef __DXTLightPP_FWD_DEFINED__
#define __DXTLightPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLightPP DXTLightPP;
#else
typedef struct DXTLightPP DXTLightPP;
#endif /* __cplusplus */

#endif 	/* __DXTLightPP_FWD_DEFINED__ */


#ifndef __DXTMotionBlur_FWD_DEFINED__
#define __DXTMotionBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMotionBlur DXTMotionBlur;
#else
typedef struct DXTMotionBlur DXTMotionBlur;
#endif /* __cplusplus */

#endif 	/* __DXTMotionBlur_FWD_DEFINED__ */


#ifndef __DXTMotionBlurPP_FWD_DEFINED__
#define __DXTMotionBlurPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMotionBlurPP DXTMotionBlurPP;
#else
typedef struct DXTMotionBlurPP DXTMotionBlurPP;
#endif /* __cplusplus */

#endif 	/* __DXTMotionBlurPP_FWD_DEFINED__ */


#ifndef __DXTMatrix_FWD_DEFINED__
#define __DXTMatrix_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMatrix DXTMatrix;
#else
typedef struct DXTMatrix DXTMatrix;
#endif /* __cplusplus */

#endif 	/* __DXTMatrix_FWD_DEFINED__ */


#ifndef __DXTMatrixPP_FWD_DEFINED__
#define __DXTMatrixPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMatrixPP DXTMatrixPP;
#else
typedef struct DXTMatrixPP DXTMatrixPP;
#endif /* __cplusplus */

#endif 	/* __DXTMatrixPP_FWD_DEFINED__ */


#ifndef __DXTICMFilter_FWD_DEFINED__
#define __DXTICMFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTICMFilter DXTICMFilter;
#else
typedef struct DXTICMFilter DXTICMFilter;
#endif /* __cplusplus */

#endif 	/* __DXTICMFilter_FWD_DEFINED__ */


#ifndef __DXTICMFilterPP_FWD_DEFINED__
#define __DXTICMFilterPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTICMFilterPP DXTICMFilterPP;
#else
typedef struct DXTICMFilterPP DXTICMFilterPP;
#endif /* __cplusplus */

#endif 	/* __DXTICMFilterPP_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dxtmsft_0000 */
/* [local] */ 

#include <dxtmsft3.h>






typedef 
enum OPIDDXLUTBUILDER
    {	OPID_DXLUTBUILDER_Gamma	= 0,
	OPID_DXLUTBUILDER_Opacity	= OPID_DXLUTBUILDER_Gamma + 1,
	OPID_DXLUTBUILDER_Brightness	= OPID_DXLUTBUILDER_Opacity + 1,
	OPID_DXLUTBUILDER_Contrast	= OPID_DXLUTBUILDER_Brightness + 1,
	OPID_DXLUTBUILDER_ColorBalance	= OPID_DXLUTBUILDER_Contrast + 1,
	OPID_DXLUTBUILDER_Posterize	= OPID_DXLUTBUILDER_ColorBalance + 1,
	OPID_DXLUTBUILDER_Invert	= OPID_DXLUTBUILDER_Posterize + 1,
	OPID_DXLUTBUILDER_Threshold	= OPID_DXLUTBUILDER_Invert + 1,
	OPID_DXLUTBUILDER_NUM_OPS	= OPID_DXLUTBUILDER_Threshold + 1
    } 	OPIDDXLUTBUILDER;

typedef 
enum DXLUTCOLOR
    {	DXLUTCOLOR_RED	= 0,
	DXLUTCOLOR_GREEN	= DXLUTCOLOR_RED + 1,
	DXLUTCOLOR_BLUE	= DXLUTCOLOR_GREEN + 1
    } 	DXLUTCOLOR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_s_ifspec;

#ifndef __IDXLUTBuilder_INTERFACE_DEFINED__
#define __IDXLUTBuilder_INTERFACE_DEFINED__

/* interface IDXLUTBuilder */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4370FC1-CADB-11D0-B52C-00A0C9054373")
    IDXLUTBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumBuildSteps( 
            /* [out] */ ULONG *pulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuildOrder( 
            /* [size_is][out] */ OPIDDXLUTBUILDER OpOrder[  ],
            /* [in] */ ULONG ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBuildOrder( 
            /* [size_is][in] */ const OPIDDXLUTBUILDER OpOrder[  ],
            /* [in] */ ULONG ulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGamma( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGamma( 
            /* [out] */ float *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrightness( 
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrightness( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContrast( 
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContrast( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevelsPerChannel( 
            /* [out] */ ULONG *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLevelsPerChannel( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInvert( 
            /* [out] */ float *pThreshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInvert( 
            /* [in] */ float Threshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreshold( 
            /* [out] */ float *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXLUTBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXLUTBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXLUTBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumBuildSteps )( 
            IDXLUTBuilder * This,
            /* [out] */ ULONG *pulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuildOrder )( 
            IDXLUTBuilder * This,
            /* [size_is][out] */ OPIDDXLUTBUILDER OpOrder[  ],
            /* [in] */ ULONG ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetBuildOrder )( 
            IDXLUTBuilder * This,
            /* [size_is][in] */ const OPIDDXLUTBUILDER OpOrder[  ],
            /* [in] */ ULONG ulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE *SetGamma )( 
            IDXLUTBuilder * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGamma )( 
            IDXLUTBuilder * This,
            /* [out] */ float *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            IDXLUTBuilder * This,
            /* [out] */ float *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            IDXLUTBuilder * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrightness )( 
            IDXLUTBuilder * This,
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrightness )( 
            IDXLUTBuilder * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetContrast )( 
            IDXLUTBuilder * This,
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetContrast )( 
            IDXLUTBuilder * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorBalance )( 
            IDXLUTBuilder * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG *pulCount,
            /* [size_is][out] */ float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorBalance )( 
            IDXLUTBuilder * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevelsPerChannel )( 
            IDXLUTBuilder * This,
            /* [out] */ ULONG *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetLevelsPerChannel )( 
            IDXLUTBuilder * This,
            /* [in] */ ULONG newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetInvert )( 
            IDXLUTBuilder * This,
            /* [out] */ float *pThreshold);
        
        HRESULT ( STDMETHODCALLTYPE *SetInvert )( 
            IDXLUTBuilder * This,
            /* [in] */ float Threshold);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreshold )( 
            IDXLUTBuilder * This,
            /* [out] */ float *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreshold )( 
            IDXLUTBuilder * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXLUTBuilderVtbl;

    interface IDXLUTBuilder
    {
        CONST_VTBL struct IDXLUTBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLUTBuilder_GetNumBuildSteps(This,pulNumSteps)	\
    (This)->lpVtbl -> GetNumBuildSteps(This,pulNumSteps)

#define IDXLUTBuilder_GetBuildOrder(This,OpOrder,ulSize)	\
    (This)->lpVtbl -> GetBuildOrder(This,OpOrder,ulSize)

#define IDXLUTBuilder_SetBuildOrder(This,OpOrder,ulNumSteps)	\
    (This)->lpVtbl -> SetBuildOrder(This,OpOrder,ulNumSteps)

#define IDXLUTBuilder_SetGamma(This,newVal)	\
    (This)->lpVtbl -> SetGamma(This,newVal)

#define IDXLUTBuilder_GetGamma(This,pVal)	\
    (This)->lpVtbl -> GetGamma(This,pVal)

#define IDXLUTBuilder_GetOpacity(This,pVal)	\
    (This)->lpVtbl -> GetOpacity(This,pVal)

#define IDXLUTBuilder_SetOpacity(This,newVal)	\
    (This)->lpVtbl -> SetOpacity(This,newVal)

#define IDXLUTBuilder_GetBrightness(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetBrightness(This,pulCount,Weights)

#define IDXLUTBuilder_SetBrightness(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetBrightness(This,ulCount,Weights)

#define IDXLUTBuilder_GetContrast(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetContrast(This,pulCount,Weights)

#define IDXLUTBuilder_SetContrast(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetContrast(This,ulCount,Weights)

#define IDXLUTBuilder_GetColorBalance(This,Color,pulCount,Weights)	\
    (This)->lpVtbl -> GetColorBalance(This,Color,pulCount,Weights)

#define IDXLUTBuilder_SetColorBalance(This,Color,ulCount,Weights)	\
    (This)->lpVtbl -> SetColorBalance(This,Color,ulCount,Weights)

#define IDXLUTBuilder_GetLevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> GetLevelsPerChannel(This,pVal)

#define IDXLUTBuilder_SetLevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> SetLevelsPerChannel(This,newVal)

#define IDXLUTBuilder_GetInvert(This,pThreshold)	\
    (This)->lpVtbl -> GetInvert(This,pThreshold)

#define IDXLUTBuilder_SetInvert(This,Threshold)	\
    (This)->lpVtbl -> SetInvert(This,Threshold)

#define IDXLUTBuilder_GetThreshold(This,pVal)	\
    (This)->lpVtbl -> GetThreshold(This,pVal)

#define IDXLUTBuilder_SetThreshold(This,newVal)	\
    (This)->lpVtbl -> SetThreshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetNumBuildSteps_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ ULONG *pulNumSteps);


void __RPC_STUB IDXLUTBuilder_GetNumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBuildOrder_Proxy( 
    IDXLUTBuilder * This,
    /* [size_is][out] */ OPIDDXLUTBUILDER OpOrder[  ],
    /* [in] */ ULONG ulSize);


void __RPC_STUB IDXLUTBuilder_GetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBuildOrder_Proxy( 
    IDXLUTBuilder * This,
    /* [size_is][in] */ const OPIDDXLUTBUILDER OpOrder[  ],
    /* [in] */ ULONG ulNumSteps);


void __RPC_STUB IDXLUTBuilder_SetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetGamma_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetGamma_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ float *pVal);


void __RPC_STUB IDXLUTBuilder_GetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetOpacity_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ float *pVal);


void __RPC_STUB IDXLUTBuilder_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetOpacity_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBrightness_Proxy( 
    IDXLUTBuilder * This,
    /* [out][in] */ ULONG *pulCount,
    /* [size_is][out] */ float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBrightness_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetContrast_Proxy( 
    IDXLUTBuilder * This,
    /* [out][in] */ ULONG *pulCount,
    /* [size_is][out] */ float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetContrast_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetColorBalance_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [out][in] */ ULONG *pulCount,
    /* [size_is][out] */ float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetColorBalance_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetLevelsPerChannel_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ ULONG *pVal);


void __RPC_STUB IDXLUTBuilder_GetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetLevelsPerChannel_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IDXLUTBuilder_SetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetInvert_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ float *pThreshold);


void __RPC_STUB IDXLUTBuilder_GetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetInvert_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXLUTBuilder_SetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetThreshold_Proxy( 
    IDXLUTBuilder * This,
    /* [out] */ float *pVal);


void __RPC_STUB IDXLUTBuilder_GetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetThreshold_Proxy( 
    IDXLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLUTBuilder_INTERFACE_DEFINED__ */


#ifndef __IDXDLUTBuilder_INTERFACE_DEFINED__
#define __IDXDLUTBuilder_INTERFACE_DEFINED__

/* interface IDXDLUTBuilder */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73068231-35EE-11d1-81A1-0000F87557DB")
    IDXDLUTBuilder : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumBuildSteps( 
            /* [retval][out] */ long *pNumSteps) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BuildOrder( 
            /* [retval][out] */ VARIANT *pOpOrder) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BuildOrder( 
            /* [in] */ VARIANT *pOpOrder) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Gamma( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Gamma( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Brightness( 
            /* [retval][out] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Brightness( 
            /* [in] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Contrast( 
            /* [retval][out] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Contrast( 
            /* [in] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LevelsPerChannel( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LevelsPerChannel( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ float *pThreshold) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ float Threshold) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Threshold( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Threshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXDLUTBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXDLUTBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXDLUTBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXDLUTBuilder * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXDLUTBuilder * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXDLUTBuilder * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXDLUTBuilder * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumBuildSteps )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ long *pNumSteps);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BuildOrder )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ VARIANT *pOpOrder);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BuildOrder )( 
            IDXDLUTBuilder * This,
            /* [in] */ VARIANT *pOpOrder);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Gamma )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Gamma )( 
            IDXDLUTBuilder * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Opacity )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Opacity )( 
            IDXDLUTBuilder * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Brightness )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ VARIANT *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Brightness )( 
            IDXDLUTBuilder * This,
            /* [in] */ VARIANT *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Contrast )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ VARIANT *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Contrast )( 
            IDXDLUTBuilder * This,
            /* [in] */ VARIANT *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorBalance )( 
            IDXDLUTBuilder * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorBalance )( 
            IDXDLUTBuilder * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LevelsPerChannel )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LevelsPerChannel )( 
            IDXDLUTBuilder * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invert )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ float *pThreshold);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Invert )( 
            IDXDLUTBuilder * This,
            /* [in] */ float Threshold);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Threshold )( 
            IDXDLUTBuilder * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Threshold )( 
            IDXDLUTBuilder * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXDLUTBuilderVtbl;

    interface IDXDLUTBuilder
    {
        CONST_VTBL struct IDXDLUTBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDLUTBuilder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDLUTBuilder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDLUTBuilder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDLUTBuilder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDLUTBuilder_get_NumBuildSteps(This,pNumSteps)	\
    (This)->lpVtbl -> get_NumBuildSteps(This,pNumSteps)

#define IDXDLUTBuilder_get_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> get_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_put_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> put_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_get_Gamma(This,pVal)	\
    (This)->lpVtbl -> get_Gamma(This,pVal)

#define IDXDLUTBuilder_put_Gamma(This,newVal)	\
    (This)->lpVtbl -> put_Gamma(This,newVal)

#define IDXDLUTBuilder_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXDLUTBuilder_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXDLUTBuilder_get_Brightness(This,pWeights)	\
    (This)->lpVtbl -> get_Brightness(This,pWeights)

#define IDXDLUTBuilder_put_Brightness(This,pWeights)	\
    (This)->lpVtbl -> put_Brightness(This,pWeights)

#define IDXDLUTBuilder_get_Contrast(This,pWeights)	\
    (This)->lpVtbl -> get_Contrast(This,pWeights)

#define IDXDLUTBuilder_put_Contrast(This,pWeights)	\
    (This)->lpVtbl -> put_Contrast(This,pWeights)

#define IDXDLUTBuilder_get_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> get_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_put_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> put_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_get_LevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> get_LevelsPerChannel(This,pVal)

#define IDXDLUTBuilder_put_LevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> put_LevelsPerChannel(This,newVal)

#define IDXDLUTBuilder_get_Invert(This,pThreshold)	\
    (This)->lpVtbl -> get_Invert(This,pThreshold)

#define IDXDLUTBuilder_put_Invert(This,Threshold)	\
    (This)->lpVtbl -> put_Invert(This,Threshold)

#define IDXDLUTBuilder_get_Threshold(This,pVal)	\
    (This)->lpVtbl -> get_Threshold(This,pVal)

#define IDXDLUTBuilder_put_Threshold(This,newVal)	\
    (This)->lpVtbl -> put_Threshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_NumBuildSteps_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ long *pNumSteps);


void __RPC_STUB IDXDLUTBuilder_get_NumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_BuildOrder_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ VARIANT *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_get_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_BuildOrder_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ VARIANT *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_put_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Gamma_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Gamma_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Opacity_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Opacity_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Brightness_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Brightness_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Contrast_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Contrast_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_ColorBalance_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [retval][out] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_ColorBalance_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ VARIANT *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXDLUTBuilder_get_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXDLUTBuilder_put_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Invert_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ float *pThreshold);


void __RPC_STUB IDXDLUTBuilder_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Invert_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXDLUTBuilder_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Threshold_Proxy( 
    IDXDLUTBuilder * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Threshold_Proxy( 
    IDXDLUTBuilder * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDLUTBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0278 */
/* [local] */ 

typedef 
enum DXGRADIENTTYPE
    {	DXGRADIENT_VERTICAL	= 0,
	DXGRADIENT_HORIZONTAL	= DXGRADIENT_VERTICAL + 1,
	DXGRADIENT_NUM_GRADIENTS	= DXGRADIENT_HORIZONTAL + 1
    } 	DXGRADIENTTYPE;

typedef 
enum DXGRADDISPID
    {	DISPID_GradientType	= 1,
	DISPID_StartColor	= DISPID_GradientType + 1,
	DISPID_EndColor	= DISPID_StartColor + 1,
	DISPID_GradientWidth	= DISPID_EndColor + 1,
	DISPID_GradientHeight	= DISPID_GradientWidth + 1,
	DISPID_GradientAspect	= DISPID_GradientHeight + 1,
	DISPID_StartColorStr	= DISPID_GradientAspect + 1,
	DISPID_EndColorStr	= DISPID_StartColorStr + 1
    } 	DXGRADDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0278_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0278_v0_0_s_ifspec;

#ifndef __IDXTGradientD_INTERFACE_DEFINED__
#define __IDXTGradientD_INTERFACE_DEFINED__

/* interface IDXTGradientD */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGradientD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("623E2881-FC0E-11d1-9A77-0000F8756A10")
    IDXTGradientD : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientType( 
            /* [in] */ DXGRADIENTTYPE eType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientType( 
            /* [retval][out] */ DXGRADIENTTYPE *peType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColor( 
            /* [retval][out] */ OLE_COLOR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColor( 
            /* [retval][out] */ OLE_COLOR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientWidth( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientHeight( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientHeight( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColorStr( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColorStr( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGradientDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTGradientD * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTGradientD * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTGradientD * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTGradientD * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTGradientD * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTGradientD * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTGradientD * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GradientType )( 
            IDXTGradientD * This,
            /* [in] */ DXGRADIENTTYPE eType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GradientType )( 
            IDXTGradientD * This,
            /* [retval][out] */ DXGRADIENTTYPE *peType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartColor )( 
            IDXTGradientD * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartColor )( 
            IDXTGradientD * This,
            /* [retval][out] */ OLE_COLOR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndColor )( 
            IDXTGradientD * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndColor )( 
            IDXTGradientD * This,
            /* [retval][out] */ OLE_COLOR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GradientWidth )( 
            IDXTGradientD * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GradientWidth )( 
            IDXTGradientD * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GradientHeight )( 
            IDXTGradientD * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GradientHeight )( 
            IDXTGradientD * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeepAspectRatio )( 
            IDXTGradientD * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeepAspectRatio )( 
            IDXTGradientD * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartColorStr )( 
            IDXTGradientD * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartColorStr )( 
            IDXTGradientD * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndColorStr )( 
            IDXTGradientD * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndColorStr )( 
            IDXTGradientD * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IDXTGradientDVtbl;

    interface IDXTGradientD
    {
        CONST_VTBL struct IDXTGradientDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGradientD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGradientD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGradientD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGradientD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGradientD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGradientD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGradientD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGradientD_put_GradientType(This,eType)	\
    (This)->lpVtbl -> put_GradientType(This,eType)

#define IDXTGradientD_get_GradientType(This,peType)	\
    (This)->lpVtbl -> get_GradientType(This,peType)

#define IDXTGradientD_put_StartColor(This,newVal)	\
    (This)->lpVtbl -> put_StartColor(This,newVal)

#define IDXTGradientD_get_StartColor(This,pVal)	\
    (This)->lpVtbl -> get_StartColor(This,pVal)

#define IDXTGradientD_put_EndColor(This,newVal)	\
    (This)->lpVtbl -> put_EndColor(This,newVal)

#define IDXTGradientD_get_EndColor(This,pVal)	\
    (This)->lpVtbl -> get_EndColor(This,pVal)

#define IDXTGradientD_put_GradientWidth(This,newVal)	\
    (This)->lpVtbl -> put_GradientWidth(This,newVal)

#define IDXTGradientD_get_GradientWidth(This,pVal)	\
    (This)->lpVtbl -> get_GradientWidth(This,pVal)

#define IDXTGradientD_put_GradientHeight(This,newVal)	\
    (This)->lpVtbl -> put_GradientHeight(This,newVal)

#define IDXTGradientD_get_GradientHeight(This,pVal)	\
    (This)->lpVtbl -> get_GradientHeight(This,pVal)

#define IDXTGradientD_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#define IDXTGradientD_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTGradientD_put_StartColorStr(This,newVal)	\
    (This)->lpVtbl -> put_StartColorStr(This,newVal)

#define IDXTGradientD_get_StartColorStr(This,pVal)	\
    (This)->lpVtbl -> get_StartColorStr(This,pVal)

#define IDXTGradientD_put_EndColorStr(This,newVal)	\
    (This)->lpVtbl -> put_EndColorStr(This,newVal)

#define IDXTGradientD_get_EndColorStr(This,pVal)	\
    (This)->lpVtbl -> get_EndColorStr(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientType_Proxy( 
    IDXTGradientD * This,
    /* [in] */ DXGRADIENTTYPE eType);


void __RPC_STUB IDXTGradientD_put_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientType_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ DXGRADIENTTYPE *peType);


void __RPC_STUB IDXTGradientD_get_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColor_Proxy( 
    IDXTGradientD * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColor_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ OLE_COLOR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColor_Proxy( 
    IDXTGradientD * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColor_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ OLE_COLOR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientWidth_Proxy( 
    IDXTGradientD * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientWidth_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTGradientD_get_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientHeight_Proxy( 
    IDXTGradientD * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientHeight_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTGradientD_get_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_KeepAspectRatio_Proxy( 
    IDXTGradientD * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTGradientD_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_KeepAspectRatio_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IDXTGradientD_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColorStr_Proxy( 
    IDXTGradientD * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColorStr_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColorStr_Proxy( 
    IDXTGradientD * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColorStr_Proxy( 
    IDXTGradientD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGradientD_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0279 */
/* [local] */ 

typedef 
enum DXCONVFILTERTYPE
    {	DXCFILTER_SRCCOPY	= 0,
	DXCFILTER_BOX7X7	= DXCFILTER_SRCCOPY + 1,
	DXCFILTER_BLUR3X3	= DXCFILTER_BOX7X7 + 1,
	DXCFILTER_SHARPEN	= DXCFILTER_BLUR3X3 + 1,
	DXCFILTER_EMBOSS	= DXCFILTER_SHARPEN + 1,
	DXCFILTER_ENGRAVE	= DXCFILTER_EMBOSS + 1,
	DXCFILTER_NUM_FILTERS	= DXCFILTER_ENGRAVE + 1,
	DXCFILTER_CUSTOM	= DXCFILTER_NUM_FILTERS + 1
    } 	DXCONVFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0279_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0279_v0_0_s_ifspec;

#ifndef __IDXTConvolution_INTERFACE_DEFINED__
#define __IDXTConvolution_INTERFACE_DEFINED__

/* interface IDXTConvolution */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTConvolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7BA7F8AF-E5EA-11d1-81DD-0000F87557DB")
    IDXTConvolution : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXCONVFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXCONVFILTERTYPE *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomFilter( 
            /* [in] */ float *pFilter,
            /* [in] */ SIZE Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConvertToGray( 
            /* [in] */ BOOL bConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConvertToGray( 
            /* [out] */ BOOL *pbConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBias( 
            /* [in] */ float Bias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBias( 
            /* [out] */ float *pBias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExcludeAlpha( 
            /* [in] */ BOOL bExcludeAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExcludeAlpha( 
            /* [out] */ BOOL *pbExcludeAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTConvolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTConvolution * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTConvolution * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTConvolution * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterType )( 
            IDXTConvolution * This,
            /* [in] */ DXCONVFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterType )( 
            IDXTConvolution * This,
            /* [out] */ DXCONVFILTERTYPE *peType);
        
        HRESULT ( STDMETHODCALLTYPE *SetCustomFilter )( 
            IDXTConvolution * This,
            /* [in] */ float *pFilter,
            /* [in] */ SIZE Size);
        
        HRESULT ( STDMETHODCALLTYPE *SetConvertToGray )( 
            IDXTConvolution * This,
            /* [in] */ BOOL bConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE *GetConvertToGray )( 
            IDXTConvolution * This,
            /* [out] */ BOOL *pbConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE *SetBias )( 
            IDXTConvolution * This,
            /* [in] */ float Bias);
        
        HRESULT ( STDMETHODCALLTYPE *GetBias )( 
            IDXTConvolution * This,
            /* [out] */ float *pBias);
        
        HRESULT ( STDMETHODCALLTYPE *SetExcludeAlpha )( 
            IDXTConvolution * This,
            /* [in] */ BOOL bExcludeAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetExcludeAlpha )( 
            IDXTConvolution * This,
            /* [out] */ BOOL *pbExcludeAlpha);
        
        END_INTERFACE
    } IDXTConvolutionVtbl;

    interface IDXTConvolution
    {
        CONST_VTBL struct IDXTConvolutionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTConvolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTConvolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTConvolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTConvolution_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXTConvolution_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXTConvolution_SetCustomFilter(This,pFilter,Size)	\
    (This)->lpVtbl -> SetCustomFilter(This,pFilter,Size)

#define IDXTConvolution_SetConvertToGray(This,bConvertToGray)	\
    (This)->lpVtbl -> SetConvertToGray(This,bConvertToGray)

#define IDXTConvolution_GetConvertToGray(This,pbConvertToGray)	\
    (This)->lpVtbl -> GetConvertToGray(This,pbConvertToGray)

#define IDXTConvolution_SetBias(This,Bias)	\
    (This)->lpVtbl -> SetBias(This,Bias)

#define IDXTConvolution_GetBias(This,pBias)	\
    (This)->lpVtbl -> GetBias(This,pBias)

#define IDXTConvolution_SetExcludeAlpha(This,bExcludeAlpha)	\
    (This)->lpVtbl -> SetExcludeAlpha(This,bExcludeAlpha)

#define IDXTConvolution_GetExcludeAlpha(This,pbExcludeAlpha)	\
    (This)->lpVtbl -> GetExcludeAlpha(This,pbExcludeAlpha)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTConvolution_SetFilterType_Proxy( 
    IDXTConvolution * This,
    /* [in] */ DXCONVFILTERTYPE eType);


void __RPC_STUB IDXTConvolution_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetFilterType_Proxy( 
    IDXTConvolution * This,
    /* [out] */ DXCONVFILTERTYPE *peType);


void __RPC_STUB IDXTConvolution_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetCustomFilter_Proxy( 
    IDXTConvolution * This,
    /* [in] */ float *pFilter,
    /* [in] */ SIZE Size);


void __RPC_STUB IDXTConvolution_SetCustomFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetConvertToGray_Proxy( 
    IDXTConvolution * This,
    /* [in] */ BOOL bConvertToGray);


void __RPC_STUB IDXTConvolution_SetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetConvertToGray_Proxy( 
    IDXTConvolution * This,
    /* [out] */ BOOL *pbConvertToGray);


void __RPC_STUB IDXTConvolution_GetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetBias_Proxy( 
    IDXTConvolution * This,
    /* [in] */ float Bias);


void __RPC_STUB IDXTConvolution_SetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetBias_Proxy( 
    IDXTConvolution * This,
    /* [out] */ float *pBias);


void __RPC_STUB IDXTConvolution_GetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetExcludeAlpha_Proxy( 
    IDXTConvolution * This,
    /* [in] */ BOOL bExcludeAlpha);


void __RPC_STUB IDXTConvolution_SetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetExcludeAlpha_Proxy( 
    IDXTConvolution * This,
    /* [out] */ BOOL *pbExcludeAlpha);


void __RPC_STUB IDXTConvolution_GetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTConvolution_INTERFACE_DEFINED__ */


#ifndef __IDXMapper_INTERFACE_DEFINED__
#define __IDXMapper_INTERFACE_DEFINED__

/* interface IDXMapper */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("555278E5-05DB-11D1-883A-3C8B00C10000")
    IDXMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ DXVEC *pInPt,
            /* [out] */ DXVEC *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ DXVEC *pOutPt,
            /* [out] */ DXVEC *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapIn2Out )( 
            IDXMapper * This,
            /* [in] */ DXVEC *pInPt,
            /* [out] */ DXVEC *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE *MapOut2In )( 
            IDXMapper * This,
            /* [in] */ DXVEC *pOutPt,
            /* [out] */ DXVEC *pInPt);
        
        END_INTERFACE
    } IDXMapperVtbl;

    interface IDXMapper
    {
        CONST_VTBL struct IDXMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXMapper_MapIn2Out_Proxy( 
    IDXMapper * This,
    /* [in] */ DXVEC *pInPt,
    /* [out] */ DXVEC *pOutPt);


void __RPC_STUB IDXMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXMapper_MapOut2In_Proxy( 
    IDXMapper * This,
    /* [in] */ DXVEC *pOutPt,
    /* [out] */ DXVEC *pInPt);


void __RPC_STUB IDXMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXMapper_INTERFACE_DEFINED__ */


#ifndef __IDXDMapper_INTERFACE_DEFINED__
#define __IDXDMapper_INTERFACE_DEFINED__

/* interface IDXDMapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FD9088B-35ED-11d1-81A1-0000F87557DB")
    IDXDMapper : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ SAFEARRAY * *pInPt,
            /* [out] */ SAFEARRAY * *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ SAFEARRAY * *pOutPt,
            /* [out] */ SAFEARRAY * *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXDMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXDMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXDMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXDMapper * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXDMapper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXDMapper * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXDMapper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *MapIn2Out )( 
            IDXDMapper * This,
            /* [in] */ SAFEARRAY * *pInPt,
            /* [out] */ SAFEARRAY * *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE *MapOut2In )( 
            IDXDMapper * This,
            /* [in] */ SAFEARRAY * *pOutPt,
            /* [out] */ SAFEARRAY * *pInPt);
        
        END_INTERFACE
    } IDXDMapperVtbl;

    interface IDXDMapper
    {
        CONST_VTBL struct IDXDMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDMapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDMapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDMapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDMapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXDMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXDMapper_MapIn2Out_Proxy( 
    IDXDMapper * This,
    /* [in] */ SAFEARRAY * *pInPt,
    /* [out] */ SAFEARRAY * *pOutPt);


void __RPC_STUB IDXDMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXDMapper_MapOut2In_Proxy( 
    IDXDMapper * This,
    /* [in] */ SAFEARRAY * *pOutPt,
    /* [out] */ SAFEARRAY * *pInPt);


void __RPC_STUB IDXDMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0282 */
/* [local] */ 

typedef 
enum DXCOMPFUNC
    {	DXCOMPFUNC_SWAP_AB	= 0x10,
	DXCOMPFUNC_FUNCMASK	= 0xf,
	DXCOMPFUNC_CLEAR	= 0,
	DXCOMPFUNC_MIN	= DXCOMPFUNC_CLEAR + 1,
	DXCOMPFUNC_MAX	= DXCOMPFUNC_MIN + 1,
	DXCOMPFUNC_A	= DXCOMPFUNC_MAX + 1,
	DXCOMPFUNC_A_OVER_B	= DXCOMPFUNC_A + 1,
	DXCOMPFUNC_A_IN_B	= DXCOMPFUNC_A_OVER_B + 1,
	DXCOMPFUNC_A_OUT_B	= DXCOMPFUNC_A_IN_B + 1,
	DXCOMPFUNC_A_ATOP_B	= DXCOMPFUNC_A_OUT_B + 1,
	DXCOMPFUNC_A_SUBTRACT_B	= DXCOMPFUNC_A_ATOP_B + 1,
	DXCOMPFUNC_A_ADD_B	= DXCOMPFUNC_A_SUBTRACT_B + 1,
	DXCOMPFUNC_A_XOR_B	= DXCOMPFUNC_A_ADD_B + 1,
	DXCOMPFUNC_B	= DXCOMPFUNC_A | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OVER_A	= DXCOMPFUNC_A_OVER_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_IN_A	= DXCOMPFUNC_A_IN_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OUT_A	= DXCOMPFUNC_A_OUT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ATOP_A	= DXCOMPFUNC_A_ATOP_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_SUBTRACT_A	= DXCOMPFUNC_A_SUBTRACT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ADD_A	= DXCOMPFUNC_A_ADD_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_NUMFUNCS	= DXCOMPFUNC_B_ADD_A + 1
    } 	DXCOMPFUNC;

typedef 
enum DXCOMPOSITEDISPID
    {	DISPID_DXCOMPOSITE_Function	= 1
    } 	DXCOMPOSITEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_s_ifspec;

#ifndef __IDXTComposite_INTERFACE_DEFINED__
#define __IDXTComposite_INTERFACE_DEFINED__

/* interface IDXTComposite */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTComposite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A43A843-0831-11D1-817F-0000F87557DB")
    IDXTComposite : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Function( 
            /* [in] */ DXCOMPFUNC eFunc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Function( 
            /* [retval][out] */ DXCOMPFUNC *peFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCompositeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTComposite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTComposite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTComposite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTComposite * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTComposite * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTComposite * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTComposite * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Function )( 
            IDXTComposite * This,
            /* [in] */ DXCOMPFUNC eFunc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Function )( 
            IDXTComposite * This,
            /* [retval][out] */ DXCOMPFUNC *peFunc);
        
        END_INTERFACE
    } IDXTCompositeVtbl;

    interface IDXTComposite
    {
        CONST_VTBL struct IDXTCompositeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTComposite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTComposite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTComposite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTComposite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTComposite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTComposite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTComposite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTComposite_put_Function(This,eFunc)	\
    (This)->lpVtbl -> put_Function(This,eFunc)

#define IDXTComposite_get_Function(This,peFunc)	\
    (This)->lpVtbl -> get_Function(This,peFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTComposite_put_Function_Proxy( 
    IDXTComposite * This,
    /* [in] */ DXCOMPFUNC eFunc);


void __RPC_STUB IDXTComposite_put_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTComposite_get_Function_Proxy( 
    IDXTComposite * This,
    /* [retval][out] */ DXCOMPFUNC *peFunc);


void __RPC_STUB IDXTComposite_get_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTComposite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0283 */
/* [local] */ 

typedef 
enum DXWIPEDIRECTION
    {	DXWD_HORIZONTAL	= 0,
	DXWD_VERTICAL	= DXWD_HORIZONTAL + 1
    } 	DXWIPEDIRECTION;

typedef 
enum DXWIPEDISPID
    {	DISPID_DXW_GradientSize	= DISPID_DXE_NEXT_ID,
	DISPID_DXW_WipeStyle	= DISPID_DXW_GradientSize + 1,
	DISPID_DXW_Motion	= DISPID_DXW_WipeStyle + 1
    } 	DXWIPEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0283_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0283_v0_0_s_ifspec;

#ifndef __IDXTWipe_INTERFACE_DEFINED__
#define __IDXTWipe_INTERFACE_DEFINED__

/* interface IDXTWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF279B2F-86EB-11D1-81BF-0000F87557DB")
    IDXTWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientSize( 
            /* [retval][out] */ float *pPercentSize) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientSize( 
            /* [in] */ float PercentSize) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WipeStyle( 
            /* [retval][out] */ DXWIPEDIRECTION *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WipeStyle( 
            /* [in] */ DXWIPEDIRECTION newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTWipe * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTWipe * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTWipe * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTWipe * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTWipe * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTWipe * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTWipe * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTWipe * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GradientSize )( 
            IDXTWipe * This,
            /* [retval][out] */ float *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GradientSize )( 
            IDXTWipe * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WipeStyle )( 
            IDXTWipe * This,
            /* [retval][out] */ DXWIPEDIRECTION *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WipeStyle )( 
            IDXTWipe * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        END_INTERFACE
    } IDXTWipeVtbl;

    interface IDXTWipe
    {
        CONST_VTBL struct IDXTWipeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_GradientSize_Proxy( 
    IDXTWipe * This,
    /* [retval][out] */ float *pPercentSize);


void __RPC_STUB IDXTWipe_get_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_GradientSize_Proxy( 
    IDXTWipe * This,
    /* [in] */ float PercentSize);


void __RPC_STUB IDXTWipe_put_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_WipeStyle_Proxy( 
    IDXTWipe * This,
    /* [retval][out] */ DXWIPEDIRECTION *pVal);


void __RPC_STUB IDXTWipe_get_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_WipeStyle_Proxy( 
    IDXTWipe * This,
    /* [in] */ DXWIPEDIRECTION newVal);


void __RPC_STUB IDXTWipe_put_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTWipe2_INTERFACE_DEFINED__
#define __IDXTWipe2_INTERFACE_DEFINED__

/* interface IDXTWipe2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1FF8091-442B-4801-88B6-2B47B1611FD2")
    IDXTWipe2 : public IDXTWipe
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipe2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTWipe2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTWipe2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTWipe2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTWipe2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTWipe2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTWipe2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTWipe2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTWipe2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTWipe2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTWipe2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTWipe2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTWipe2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTWipe2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GradientSize )( 
            IDXTWipe2 * This,
            /* [retval][out] */ float *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GradientSize )( 
            IDXTWipe2 * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WipeStyle )( 
            IDXTWipe2 * This,
            /* [retval][out] */ DXWIPEDIRECTION *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WipeStyle )( 
            IDXTWipe2 * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Motion )( 
            IDXTWipe2 * This,
            /* [retval][out] */ BSTR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Motion )( 
            IDXTWipe2 * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } IDXTWipe2Vtbl;

    interface IDXTWipe2
    {
        CONST_VTBL struct IDXTWipe2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe2_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe2_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe2_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe2_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)


#define IDXTWipe2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define IDXTWipe2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe2_get_Motion_Proxy( 
    IDXTWipe2 * This,
    /* [retval][out] */ BSTR *pbstrMotion);


void __RPC_STUB IDXTWipe2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe2_put_Motion_Proxy( 
    IDXTWipe2 * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB IDXTWipe2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0285 */
/* [local] */ 

typedef 
enum CRBLURDISPID
    {	DISPID_CRB_MakeShadow	= 1,
	DISPID_CRB_ShadowOpacity	= DISPID_CRB_MakeShadow + 1,
	DISPID_CRB_PixelRadius	= DISPID_CRB_ShadowOpacity + 1
    } 	CRBLURDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_s_ifspec;

#ifndef __ICrBlur_INTERFACE_DEFINED__
#define __ICrBlur_INTERFACE_DEFINED__

/* interface ICrBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F7C7827-E87A-11d1-81E0-0000F87557DB")
    ICrBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MakeShadow( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MakeShadow( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShadowOpacity( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShadowOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PixelRadius( 
            /* [retval][out] */ float *pPixelRadius) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PixelRadius( 
            /* [in] */ float PixelRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrBlur * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrBlur * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrBlur * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrBlur * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrBlur * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrBlur * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrBlur * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MakeShadow )( 
            ICrBlur * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MakeShadow )( 
            ICrBlur * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShadowOpacity )( 
            ICrBlur * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShadowOpacity )( 
            ICrBlur * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PixelRadius )( 
            ICrBlur * This,
            /* [retval][out] */ float *pPixelRadius);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PixelRadius )( 
            ICrBlur * This,
            /* [in] */ float PixelRadius);
        
        END_INTERFACE
    } ICrBlurVtbl;

    interface ICrBlur
    {
        CONST_VTBL struct ICrBlurVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlur_get_MakeShadow(This,pVal)	\
    (This)->lpVtbl -> get_MakeShadow(This,pVal)

#define ICrBlur_put_MakeShadow(This,newVal)	\
    (This)->lpVtbl -> put_MakeShadow(This,newVal)

#define ICrBlur_get_ShadowOpacity(This,pVal)	\
    (This)->lpVtbl -> get_ShadowOpacity(This,pVal)

#define ICrBlur_put_ShadowOpacity(This,newVal)	\
    (This)->lpVtbl -> put_ShadowOpacity(This,newVal)

#define ICrBlur_get_PixelRadius(This,pPixelRadius)	\
    (This)->lpVtbl -> get_PixelRadius(This,pPixelRadius)

#define ICrBlur_put_PixelRadius(This,PixelRadius)	\
    (This)->lpVtbl -> put_PixelRadius(This,PixelRadius)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_MakeShadow_Proxy( 
    ICrBlur * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ICrBlur_get_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_MakeShadow_Proxy( 
    ICrBlur * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB ICrBlur_put_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_ShadowOpacity_Proxy( 
    ICrBlur * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB ICrBlur_get_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_ShadowOpacity_Proxy( 
    ICrBlur * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrBlur_put_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_PixelRadius_Proxy( 
    ICrBlur * This,
    /* [retval][out] */ float *pPixelRadius);


void __RPC_STUB ICrBlur_get_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_PixelRadius_Proxy( 
    ICrBlur * This,
    /* [in] */ float PixelRadius);


void __RPC_STUB ICrBlur_put_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0286 */
/* [local] */ 

typedef 
enum CRENGRAVEDISPID
    {	DISPID_CREN_Bias	= 1
    } 	CRENGRAVEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_s_ifspec;

#ifndef __ICrEngrave_INTERFACE_DEFINED__
#define __ICrEngrave_INTERFACE_DEFINED__

/* interface ICrEngrave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEngrave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB7F-053E-11d2-81EA-0000F87557DB")
    ICrEngrave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEngraveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrEngrave * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrEngrave * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrEngrave * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrEngrave * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrEngrave * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrEngrave * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrEngrave * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Bias )( 
            ICrEngrave * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Bias )( 
            ICrEngrave * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEngraveVtbl;

    interface ICrEngrave
    {
        CONST_VTBL struct ICrEngraveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEngrave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEngrave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEngrave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEngrave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEngrave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEngrave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEngrave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEngrave_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEngrave_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEngrave_get_Bias_Proxy( 
    ICrEngrave * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB ICrEngrave_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEngrave_put_Bias_Proxy( 
    ICrEngrave * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEngrave_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEngrave_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0287 */
/* [local] */ 

typedef 
enum CREMBOSSDISPID
    {	DISPID_CREM_Bias	= 1
    } 	CREMBOSSDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_s_ifspec;

#ifndef __ICrEmboss_INTERFACE_DEFINED__
#define __ICrEmboss_INTERFACE_DEFINED__

/* interface ICrEmboss */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEmboss;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB80-053E-11d2-81EA-0000F87557DB")
    ICrEmboss : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEmbossVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrEmboss * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrEmboss * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrEmboss * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrEmboss * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrEmboss * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrEmboss * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrEmboss * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Bias )( 
            ICrEmboss * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Bias )( 
            ICrEmboss * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEmbossVtbl;

    interface ICrEmboss
    {
        CONST_VTBL struct ICrEmbossVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEmboss_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEmboss_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEmboss_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEmboss_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEmboss_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEmboss_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEmboss_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEmboss_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEmboss_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEmboss_get_Bias_Proxy( 
    ICrEmboss * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB ICrEmboss_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEmboss_put_Bias_Proxy( 
    ICrEmboss * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEmboss_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEmboss_INTERFACE_DEFINED__ */


#ifndef __IDXTFade_INTERFACE_DEFINED__
#define __IDXTFade_INTERFACE_DEFINED__

/* interface IDXTFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C4-EE70-11D1-9066-00C04FD9189D")
    IDXTFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Overlap( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Overlap( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Center( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Center( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFade * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFade * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFade * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTFade * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTFade * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTFade * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTFade * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTFade * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTFade * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTFade * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Overlap )( 
            IDXTFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Overlap )( 
            IDXTFade * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Center )( 
            IDXTFade * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Center )( 
            IDXTFade * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IDXTFadeVtbl;

    interface IDXTFade
    {
        CONST_VTBL struct IDXTFadeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTFade_get_Overlap(This,pVal)	\
    (This)->lpVtbl -> get_Overlap(This,pVal)

#define IDXTFade_put_Overlap(This,newVal)	\
    (This)->lpVtbl -> put_Overlap(This,newVal)

#define IDXTFade_get_Center(This,pVal)	\
    (This)->lpVtbl -> get_Center(This,pVal)

#define IDXTFade_put_Center(This,newVal)	\
    (This)->lpVtbl -> put_Center(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Overlap_Proxy( 
    IDXTFade * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXTFade_get_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Overlap_Proxy( 
    IDXTFade * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTFade_put_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Center_Proxy( 
    IDXTFade * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXTFade_get_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Center_Proxy( 
    IDXTFade * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXTFade_put_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFade_INTERFACE_DEFINED__ */


#ifndef __IDXBasicImage_INTERFACE_DEFINED__
#define __IDXBasicImage_INTERFACE_DEFINED__

/* interface IDXBasicImage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXBasicImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C7-EE70-11D1-9066-00C04FD9189D")
    IDXBasicImage : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotation( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotation( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mirror( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mirror( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrayScale( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrayScale( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XRay( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XRay( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mask( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mask( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskColor( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskColor( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBasicImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXBasicImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXBasicImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXBasicImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXBasicImage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXBasicImage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXBasicImage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXBasicImage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rotation )( 
            IDXBasicImage * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rotation )( 
            IDXBasicImage * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mirror )( 
            IDXBasicImage * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Mirror )( 
            IDXBasicImage * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GrayScale )( 
            IDXBasicImage * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GrayScale )( 
            IDXBasicImage * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Opacity )( 
            IDXBasicImage * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Opacity )( 
            IDXBasicImage * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invert )( 
            IDXBasicImage * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Invert )( 
            IDXBasicImage * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XRay )( 
            IDXBasicImage * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XRay )( 
            IDXBasicImage * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mask )( 
            IDXBasicImage * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Mask )( 
            IDXBasicImage * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaskColor )( 
            IDXBasicImage * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaskColor )( 
            IDXBasicImage * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXBasicImageVtbl;

    interface IDXBasicImage
    {
        CONST_VTBL struct IDXBasicImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBasicImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBasicImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBasicImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBasicImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXBasicImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXBasicImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXBasicImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXBasicImage_get_Rotation(This,pVal)	\
    (This)->lpVtbl -> get_Rotation(This,pVal)

#define IDXBasicImage_put_Rotation(This,newVal)	\
    (This)->lpVtbl -> put_Rotation(This,newVal)

#define IDXBasicImage_get_Mirror(This,pVal)	\
    (This)->lpVtbl -> get_Mirror(This,pVal)

#define IDXBasicImage_put_Mirror(This,newVal)	\
    (This)->lpVtbl -> put_Mirror(This,newVal)

#define IDXBasicImage_get_GrayScale(This,pVal)	\
    (This)->lpVtbl -> get_GrayScale(This,pVal)

#define IDXBasicImage_put_GrayScale(This,newVal)	\
    (This)->lpVtbl -> put_GrayScale(This,newVal)

#define IDXBasicImage_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXBasicImage_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXBasicImage_get_Invert(This,pVal)	\
    (This)->lpVtbl -> get_Invert(This,pVal)

#define IDXBasicImage_put_Invert(This,newVal)	\
    (This)->lpVtbl -> put_Invert(This,newVal)

#define IDXBasicImage_get_XRay(This,pVal)	\
    (This)->lpVtbl -> get_XRay(This,pVal)

#define IDXBasicImage_put_XRay(This,newVal)	\
    (This)->lpVtbl -> put_XRay(This,newVal)

#define IDXBasicImage_get_Mask(This,pVal)	\
    (This)->lpVtbl -> get_Mask(This,pVal)

#define IDXBasicImage_put_Mask(This,newVal)	\
    (This)->lpVtbl -> put_Mask(This,newVal)

#define IDXBasicImage_get_MaskColor(This,pVal)	\
    (This)->lpVtbl -> get_MaskColor(This,pVal)

#define IDXBasicImage_put_MaskColor(This,newVal)	\
    (This)->lpVtbl -> put_MaskColor(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Rotation_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXBasicImage_get_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Rotation_Proxy( 
    IDXBasicImage * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mirror_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXBasicImage_get_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mirror_Proxy( 
    IDXBasicImage * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_GrayScale_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXBasicImage_get_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_GrayScale_Proxy( 
    IDXBasicImage * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Opacity_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXBasicImage_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Opacity_Proxy( 
    IDXBasicImage * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXBasicImage_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Invert_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXBasicImage_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Invert_Proxy( 
    IDXBasicImage * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_XRay_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXBasicImage_get_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_XRay_Proxy( 
    IDXBasicImage * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mask_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IDXBasicImage_get_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mask_Proxy( 
    IDXBasicImage * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_MaskColor_Proxy( 
    IDXBasicImage * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXBasicImage_get_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_MaskColor_Proxy( 
    IDXBasicImage * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBasicImage_INTERFACE_DEFINED__ */


#ifndef __IDXPixelate_INTERFACE_DEFINED__
#define __IDXPixelate_INTERFACE_DEFINED__

/* interface IDXPixelate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXPixelate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D33E180F-FBE9-11d1-906A-00C04FD9189D")
    IDXPixelate : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSquare( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSquare( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXPixelateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXPixelate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXPixelate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXPixelate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXPixelate * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXPixelate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXPixelate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXPixelate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXPixelate * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXPixelate * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXPixelate * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXPixelate * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXPixelate * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXPixelate * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxSquare )( 
            IDXPixelate * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxSquare )( 
            IDXPixelate * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXPixelateVtbl;

    interface IDXPixelate
    {
        CONST_VTBL struct IDXPixelateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXPixelate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXPixelate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXPixelate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXPixelate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXPixelate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXPixelate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXPixelate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXPixelate_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXPixelate_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXPixelate_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXPixelate_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXPixelate_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXPixelate_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXPixelate_get_MaxSquare(This,pVal)	\
    (This)->lpVtbl -> get_MaxSquare(This,pVal)

#define IDXPixelate_put_MaxSquare(This,newVal)	\
    (This)->lpVtbl -> put_MaxSquare(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXPixelate_get_MaxSquare_Proxy( 
    IDXPixelate * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXPixelate_get_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXPixelate_put_MaxSquare_Proxy( 
    IDXPixelate * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXPixelate_put_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXPixelate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0291 */
/* [local] */ 

typedef 
enum DISPID_CRIRIS
    {	DISPID_CRIRIS_IRISSTYLE	= 1,
	DISPID_CRIRIS_MOTION	= DISPID_CRIRIS_IRISSTYLE + 1
    } 	DISPID_CRIRIS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0291_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0291_v0_0_s_ifspec;

#ifndef __ICrIris_INTERFACE_DEFINED__
#define __ICrIris_INTERFACE_DEFINED__

/* interface ICrIris */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F69F350-0379-11D2-A484-00C04F8EFB69")
    ICrIris : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_irisStyle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_irisStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIrisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrIris * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrIris * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrIris * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrIris * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrIris * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrIris * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrIris * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrIris * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrIris * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrIris * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrIris * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrIris * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrIris * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_irisStyle )( 
            ICrIris * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_irisStyle )( 
            ICrIris * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrIrisVtbl;

    interface ICrIris
    {
        CONST_VTBL struct ICrIrisVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris_get_irisStyle_Proxy( 
    ICrIris * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICrIris_get_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris_put_irisStyle_Proxy( 
    ICrIris * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrIris_put_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris_INTERFACE_DEFINED__ */


#ifndef __ICrIris2_INTERFACE_DEFINED__
#define __ICrIris2_INTERFACE_DEFINED__

/* interface ICrIris2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7B06961-BA8C-4970-918B-1C60CB9FF180")
    ICrIris2 : public ICrIris
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIris2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrIris2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrIris2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrIris2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrIris2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrIris2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrIris2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrIris2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrIris2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrIris2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrIris2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrIris2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrIris2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrIris2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_irisStyle )( 
            ICrIris2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_irisStyle )( 
            ICrIris2 * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Motion )( 
            ICrIris2 * This,
            /* [retval][out] */ BSTR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Motion )( 
            ICrIris2 * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } ICrIris2Vtbl;

    interface ICrIris2
    {
        CONST_VTBL struct ICrIris2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris2_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris2_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)


#define ICrIris2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define ICrIris2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris2_get_Motion_Proxy( 
    ICrIris2 * This,
    /* [retval][out] */ BSTR *pbstrMotion);


void __RPC_STUB ICrIris2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris2_put_Motion_Proxy( 
    ICrIris2 * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB ICrIris2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris2_INTERFACE_DEFINED__ */


#ifndef __ICrSlide_INTERFACE_DEFINED__
#define __ICrSlide_INTERFACE_DEFINED__

/* interface ICrSlide */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSlide;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("810E402E-056B-11D2-A484-00C04F8EFB69")
    ICrSlide : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_slideStyle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_slideStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSlideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrSlide * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrSlide * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrSlide * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrSlide * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrSlide * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrSlide * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrSlide * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrSlide * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrSlide * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrSlide * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrSlide * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrSlide * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrSlide * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bands )( 
            ICrSlide * This,
            /* [retval][out] */ short *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_bands )( 
            ICrSlide * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_slideStyle )( 
            ICrSlide * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_slideStyle )( 
            ICrSlide * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrSlideVtbl;

    interface ICrSlide
    {
        CONST_VTBL struct ICrSlideVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSlide_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSlide_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSlide_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSlide_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSlide_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSlide_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSlide_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSlide_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSlide_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSlide_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSlide_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSlide_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSlide_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSlide_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrSlide_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#define ICrSlide_get_slideStyle(This,pVal)	\
    (This)->lpVtbl -> get_slideStyle(This,pVal)

#define ICrSlide_put_slideStyle(This,newVal)	\
    (This)->lpVtbl -> put_slideStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_bands_Proxy( 
    ICrSlide * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB ICrSlide_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_bands_Proxy( 
    ICrSlide * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrSlide_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_slideStyle_Proxy( 
    ICrSlide * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICrSlide_get_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_slideStyle_Proxy( 
    ICrSlide * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrSlide_put_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSlide_INTERFACE_DEFINED__ */


#ifndef __ICrRadialWipe_INTERFACE_DEFINED__
#define __ICrRadialWipe_INTERFACE_DEFINED__

/* interface ICrRadialWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrRadialWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("424B71AE-0695-11D2-A484-00C04F8EFB69")
    ICrRadialWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_wipeStyle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_wipeStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrRadialWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrRadialWipe * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrRadialWipe * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrRadialWipe * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrRadialWipe * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrRadialWipe * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrRadialWipe * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrRadialWipe * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrRadialWipe * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrRadialWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrRadialWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrRadialWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrRadialWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrRadialWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_wipeStyle )( 
            ICrRadialWipe * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_wipeStyle )( 
            ICrRadialWipe * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrRadialWipeVtbl;

    interface ICrRadialWipe
    {
        CONST_VTBL struct ICrRadialWipeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrRadialWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrRadialWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrRadialWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrRadialWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrRadialWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrRadialWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrRadialWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrRadialWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrRadialWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrRadialWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrRadialWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrRadialWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrRadialWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrRadialWipe_get_wipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_wipeStyle(This,pVal)

#define ICrRadialWipe_put_wipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_wipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_get_wipeStyle_Proxy( 
    ICrRadialWipe * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICrRadialWipe_get_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_put_wipeStyle_Proxy( 
    ICrRadialWipe * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrRadialWipe_put_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrRadialWipe_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0295 */
/* [local] */ 

typedef 
enum DISPID_CRBARN
    {	DISPID_CRBARN_MOTION	= 1,
	DISPID_CRBARN_ORIENTATION	= DISPID_CRBARN_MOTION + 1
    } 	DISPID_CRBARN;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0295_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0295_v0_0_s_ifspec;

#ifndef __ICrBarn_INTERFACE_DEFINED__
#define __ICrBarn_INTERFACE_DEFINED__

/* interface ICrBarn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("276A2EE0-0B5D-11D2-A484-00C04F8EFB69")
    ICrBarn : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrBarnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrBarn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrBarn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrBarn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrBarn * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrBarn * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrBarn * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrBarn * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrBarn * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrBarn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrBarn * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrBarn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrBarn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrBarn * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrBarnVtbl;

    interface ICrBarn
    {
        CONST_VTBL struct ICrBarnVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrBarn_INTERFACE_DEFINED__ */


#ifndef __ICrBarn2_INTERFACE_DEFINED__
#define __ICrBarn2_INTERFACE_DEFINED__

/* interface ICrBarn2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B66A7A1B-8FC6-448C-A2EB-3C55957478A1")
    ICrBarn2 : public ICrBarn
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ BSTR *pbstrOrientation) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ BSTR bstrOrientation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBarn2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrBarn2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrBarn2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrBarn2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrBarn2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrBarn2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrBarn2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrBarn2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrBarn2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrBarn2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrBarn2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrBarn2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrBarn2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrBarn2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Motion )( 
            ICrBarn2 * This,
            /* [retval][out] */ BSTR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Motion )( 
            ICrBarn2 * This,
            /* [in] */ BSTR bstrMotion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Orientation )( 
            ICrBarn2 * This,
            /* [retval][out] */ BSTR *pbstrOrientation);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Orientation )( 
            ICrBarn2 * This,
            /* [in] */ BSTR bstrOrientation);
        
        END_INTERFACE
    } ICrBarn2Vtbl;

    interface ICrBarn2
    {
        CONST_VTBL struct ICrBarn2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)



#define ICrBarn2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define ICrBarn2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#define ICrBarn2_get_Orientation(This,pbstrOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,pbstrOrientation)

#define ICrBarn2_put_Orientation(This,bstrOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,bstrOrientation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBarn2_get_Motion_Proxy( 
    ICrBarn2 * This,
    /* [retval][out] */ BSTR *pbstrMotion);


void __RPC_STUB ICrBarn2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBarn2_put_Motion_Proxy( 
    ICrBarn2 * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB ICrBarn2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBarn2_get_Orientation_Proxy( 
    ICrBarn2 * This,
    /* [retval][out] */ BSTR *pbstrOrientation);


void __RPC_STUB ICrBarn2_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBarn2_put_Orientation_Proxy( 
    ICrBarn2 * This,
    /* [in] */ BSTR bstrOrientation);


void __RPC_STUB ICrBarn2_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBarn2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0297 */
/* [local] */ 

typedef 
enum DISPID_CRBLINDS
    {	DISPID_CRBLINDS_BANDS	= 1,
	DISPID_CRBLINDS_DIRECTION	= DISPID_CRBLINDS_BANDS + 1
    } 	DISPID_CRBLINDS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0297_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0297_v0_0_s_ifspec;

#ifndef __ICrBlinds_INTERFACE_DEFINED__
#define __ICrBlinds_INTERFACE_DEFINED__

/* interface ICrBlinds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AF5C340-0BA9-11d2-A484-00C04F8EFB69")
    ICrBlinds : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlindsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrBlinds * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrBlinds * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrBlinds * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrBlinds * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrBlinds * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrBlinds * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrBlinds * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrBlinds * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrBlinds * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrBlinds * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrBlinds * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrBlinds * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrBlinds * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bands )( 
            ICrBlinds * This,
            /* [retval][out] */ short *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_bands )( 
            ICrBlinds * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrBlindsVtbl;

    interface ICrBlinds
    {
        CONST_VTBL struct ICrBlindsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds_get_bands_Proxy( 
    ICrBlinds * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB ICrBlinds_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds_put_bands_Proxy( 
    ICrBlinds * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrBlinds_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds_INTERFACE_DEFINED__ */


#ifndef __ICrBlinds2_INTERFACE_DEFINED__
#define __ICrBlinds2_INTERFACE_DEFINED__

/* interface ICrBlinds2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7059D403-599A-4264-8140-641EB8AE1F64")
    ICrBlinds2 : public ICrBlinds
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ BSTR *pbstrDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ BSTR bstrDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlinds2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrBlinds2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrBlinds2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrBlinds2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrBlinds2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrBlinds2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrBlinds2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrBlinds2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrBlinds2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrBlinds2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrBlinds2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrBlinds2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrBlinds2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrBlinds2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bands )( 
            ICrBlinds2 * This,
            /* [retval][out] */ short *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_bands )( 
            ICrBlinds2 * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            ICrBlinds2 * This,
            /* [retval][out] */ BSTR *pbstrDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            ICrBlinds2 * This,
            /* [in] */ BSTR bstrDirection);
        
        END_INTERFACE
    } ICrBlinds2Vtbl;

    interface ICrBlinds2
    {
        CONST_VTBL struct ICrBlinds2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds2_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds2_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)


#define ICrBlinds2_get_Direction(This,pbstrDirection)	\
    (This)->lpVtbl -> get_Direction(This,pbstrDirection)

#define ICrBlinds2_put_Direction(This,bstrDirection)	\
    (This)->lpVtbl -> put_Direction(This,bstrDirection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds2_get_Direction_Proxy( 
    ICrBlinds2 * This,
    /* [retval][out] */ BSTR *pbstrDirection);


void __RPC_STUB ICrBlinds2_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds2_put_Direction_Proxy( 
    ICrBlinds2 * This,
    /* [in] */ BSTR bstrDirection);


void __RPC_STUB ICrBlinds2_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds2_INTERFACE_DEFINED__ */


#ifndef __ICrInset_INTERFACE_DEFINED__
#define __ICrInset_INTERFACE_DEFINED__

/* interface ICrInset */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrInset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05C5EE20-0BA6-11d2-A484-00C04F8EFB69")
    ICrInset : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrInsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrInset * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrInset * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrInset * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrInset * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrInset * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrInset * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrInset * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrInset * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrInset * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrInset * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrInset * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrInset * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrInset * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrInsetVtbl;

    interface ICrInset
    {
        CONST_VTBL struct ICrInsetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrInset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrInset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrInset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrInset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrInset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrInset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrInset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrInset_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrInset_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrInset_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrInset_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrInset_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrInset_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrInset_INTERFACE_DEFINED__ */


#ifndef __ICrStretch_INTERFACE_DEFINED__
#define __ICrStretch_INTERFACE_DEFINED__

/* interface ICrStretch */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrStretch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6684AF00-0A87-11d2-A484-00C04F8EFB69")
    ICrStretch : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stretchStyle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_stretchStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrStretchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrStretch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrStretch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrStretch * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrStretch * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrStretch * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrStretch * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrStretch * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrStretch * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrStretch * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrStretch * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrStretch * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrStretch * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrStretch * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_stretchStyle )( 
            ICrStretch * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_stretchStyle )( 
            ICrStretch * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrStretchVtbl;

    interface ICrStretch
    {
        CONST_VTBL struct ICrStretchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrStretch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrStretch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrStretch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrStretch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrStretch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrStretch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrStretch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrStretch_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrStretch_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrStretch_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrStretch_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrStretch_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrStretch_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrStretch_get_stretchStyle(This,pVal)	\
    (This)->lpVtbl -> get_stretchStyle(This,pVal)

#define ICrStretch_put_stretchStyle(This,newVal)	\
    (This)->lpVtbl -> put_stretchStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrStretch_get_stretchStyle_Proxy( 
    ICrStretch * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICrStretch_get_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrStretch_put_stretchStyle_Proxy( 
    ICrStretch * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrStretch_put_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrStretch_INTERFACE_DEFINED__ */


#ifndef __IDXTGridSize_INTERFACE_DEFINED__
#define __IDXTGridSize_INTERFACE_DEFINED__

/* interface IDXTGridSize */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGridSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6BBE91E-FF60-11d2-8F6E-00A0C9697274")
    IDXTGridSize : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGridSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTGridSize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTGridSize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTGridSize * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTGridSize * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTGridSize * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTGridSize * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTGridSize * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTGridSize * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTGridSize * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTGridSize * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTGridSize * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTGridSize * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTGridSize * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeX )( 
            IDXTGridSize * This,
            /* [retval][out] */ short *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeX )( 
            IDXTGridSize * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeY )( 
            IDXTGridSize * This,
            /* [retval][out] */ short *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeY )( 
            IDXTGridSize * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } IDXTGridSizeVtbl;

    interface IDXTGridSize
    {
        CONST_VTBL struct IDXTGridSizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGridSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGridSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGridSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGridSize_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGridSize_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGridSize_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGridSize_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGridSize_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTGridSize_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTGridSize_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTGridSize_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTGridSize_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTGridSize_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTGridSize_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define IDXTGridSize_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define IDXTGridSize_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define IDXTGridSize_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_get_gridSizeX_Proxy( 
    IDXTGridSize * This,
    /* [retval][out] */ short *pX);


void __RPC_STUB IDXTGridSize_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_put_gridSizeX_Proxy( 
    IDXTGridSize * This,
    /* [in] */ short newX);


void __RPC_STUB IDXTGridSize_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_get_gridSizeY_Proxy( 
    IDXTGridSize * This,
    /* [retval][out] */ short *pY);


void __RPC_STUB IDXTGridSize_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_put_gridSizeY_Proxy( 
    IDXTGridSize * This,
    /* [in] */ short newY);


void __RPC_STUB IDXTGridSize_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGridSize_INTERFACE_DEFINED__ */


#ifndef __ICrSpiral_INTERFACE_DEFINED__
#define __ICrSpiral_INTERFACE_DEFINED__

/* interface ICrSpiral */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSpiral;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DE527A0-0C7E-11d2-A484-00C04F8EFB69")
    ICrSpiral : public IDXTGridSize
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrSpiralVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrSpiral * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrSpiral * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrSpiral * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrSpiral * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrSpiral * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrSpiral * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrSpiral * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrSpiral * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrSpiral * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrSpiral * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrSpiral * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrSpiral * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrSpiral * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeX )( 
            ICrSpiral * This,
            /* [retval][out] */ short *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeX )( 
            ICrSpiral * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeY )( 
            ICrSpiral * This,
            /* [retval][out] */ short *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeY )( 
            ICrSpiral * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrSpiralVtbl;

    interface ICrSpiral
    {
        CONST_VTBL struct ICrSpiralVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSpiral_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSpiral_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSpiral_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSpiral_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSpiral_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSpiral_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSpiral_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSpiral_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSpiral_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSpiral_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSpiral_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSpiral_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSpiral_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSpiral_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrSpiral_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrSpiral_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrSpiral_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrSpiral_INTERFACE_DEFINED__ */


#ifndef __ICrZigzag_INTERFACE_DEFINED__
#define __ICrZigzag_INTERFACE_DEFINED__

/* interface ICrZigzag */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrZigzag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E5A64A0-0C8B-11d2-A484-00C04F8EFB69")
    ICrZigzag : public IDXTGridSize
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrZigzagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrZigzag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrZigzag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrZigzag * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrZigzag * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrZigzag * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrZigzag * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrZigzag * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrZigzag * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrZigzag * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrZigzag * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrZigzag * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrZigzag * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrZigzag * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeX )( 
            ICrZigzag * This,
            /* [retval][out] */ short *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeX )( 
            ICrZigzag * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_gridSizeY )( 
            ICrZigzag * This,
            /* [retval][out] */ short *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_gridSizeY )( 
            ICrZigzag * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrZigzagVtbl;

    interface ICrZigzag
    {
        CONST_VTBL struct ICrZigzagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrZigzag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrZigzag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrZigzag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrZigzag_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrZigzag_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrZigzag_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrZigzag_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrZigzag_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrZigzag_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrZigzag_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrZigzag_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrZigzag_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrZigzag_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrZigzag_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrZigzag_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrZigzag_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrZigzag_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrZigzag_INTERFACE_DEFINED__ */


#ifndef __ICrWheel_INTERFACE_DEFINED__
#define __ICrWheel_INTERFACE_DEFINED__

/* interface ICrWheel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrWheel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3943DE80-1464-11d2-A484-00C04F8EFB69")
    ICrWheel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_spokes( 
            /* [retval][out] */ short *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_spokes( 
            /* [in] */ short newX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrWheelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICrWheel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICrWheel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICrWheel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICrWheel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICrWheel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICrWheel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICrWheel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            ICrWheel * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            ICrWheel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            ICrWheel * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            ICrWheel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ICrWheel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ICrWheel * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_spokes )( 
            ICrWheel * This,
            /* [retval][out] */ short *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_spokes )( 
            ICrWheel * This,
            /* [in] */ short newX);
        
        END_INTERFACE
    } ICrWheelVtbl;

    interface ICrWheel
    {
        CONST_VTBL struct ICrWheelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrWheel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrWheel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrWheel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrWheel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrWheel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrWheel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrWheel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrWheel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrWheel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrWheel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrWheel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrWheel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrWheel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrWheel_get_spokes(This,pX)	\
    (This)->lpVtbl -> get_spokes(This,pX)

#define ICrWheel_put_spokes(This,newX)	\
    (This)->lpVtbl -> put_spokes(This,newX)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrWheel_get_spokes_Proxy( 
    ICrWheel * This,
    /* [retval][out] */ short *pX);


void __RPC_STUB ICrWheel_get_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrWheel_put_spokes_Proxy( 
    ICrWheel * This,
    /* [in] */ short newX);


void __RPC_STUB ICrWheel_put_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrWheel_INTERFACE_DEFINED__ */


#ifndef __IDXTChroma_INTERFACE_DEFINED__
#define __IDXTChroma_INTERFACE_DEFINED__

/* interface IDXTChroma */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTChroma;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E2-383C-11d2-952A-00C04FA34F05")
    IDXTChroma : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTChromaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTChroma * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTChroma * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTChroma * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTChroma * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTChroma * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTChroma * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTChroma * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            IDXTChroma * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            IDXTChroma * This,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IDXTChromaVtbl;

    interface IDXTChroma
    {
        CONST_VTBL struct IDXTChromaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTChroma_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTChroma_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTChroma_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTChroma_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTChroma_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTChroma_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTChroma_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTChroma_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTChroma_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTChroma_put_Color_Proxy( 
    IDXTChroma * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTChroma_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTChroma_get_Color_Proxy( 
    IDXTChroma * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IDXTChroma_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTChroma_INTERFACE_DEFINED__ */


#ifndef __IDXTDropShadow_INTERFACE_DEFINED__
#define __IDXTDropShadow_INTERFACE_DEFINED__

/* interface IDXTDropShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTDropShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E3-383C-11d2-952A-00C04FA34F05")
    IDXTDropShadow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffX( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffX( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffY( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffY( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Positive( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Positive( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTDropShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTDropShadow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTDropShadow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTDropShadow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTDropShadow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTDropShadow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTDropShadow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTDropShadow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            IDXTDropShadow * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            IDXTDropShadow * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffX )( 
            IDXTDropShadow * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffX )( 
            IDXTDropShadow * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffY )( 
            IDXTDropShadow * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffY )( 
            IDXTDropShadow * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Positive )( 
            IDXTDropShadow * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Positive )( 
            IDXTDropShadow * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTDropShadowVtbl;

    interface IDXTDropShadow
    {
        CONST_VTBL struct IDXTDropShadowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTDropShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTDropShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTDropShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTDropShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTDropShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTDropShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTDropShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTDropShadow_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTDropShadow_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTDropShadow_get_OffX(This,pVal)	\
    (This)->lpVtbl -> get_OffX(This,pVal)

#define IDXTDropShadow_put_OffX(This,newVal)	\
    (This)->lpVtbl -> put_OffX(This,newVal)

#define IDXTDropShadow_get_OffY(This,pVal)	\
    (This)->lpVtbl -> get_OffY(This,pVal)

#define IDXTDropShadow_put_OffY(This,newVal)	\
    (This)->lpVtbl -> put_OffY(This,newVal)

#define IDXTDropShadow_get_Positive(This,pVal)	\
    (This)->lpVtbl -> get_Positive(This,pVal)

#define IDXTDropShadow_put_Positive(This,newVal)	\
    (This)->lpVtbl -> put_Positive(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Color_Proxy( 
    IDXTDropShadow * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IDXTDropShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Color_Proxy( 
    IDXTDropShadow * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTDropShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffX_Proxy( 
    IDXTDropShadow * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXTDropShadow_get_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffX_Proxy( 
    IDXTDropShadow * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffY_Proxy( 
    IDXTDropShadow * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXTDropShadow_get_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffY_Proxy( 
    IDXTDropShadow * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Positive_Proxy( 
    IDXTDropShadow * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IDXTDropShadow_get_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Positive_Proxy( 
    IDXTDropShadow * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTDropShadow_put_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTDropShadow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0307 */
/* [local] */ 

typedef 
enum DISPID_DXTCHECKERBOARD
    {	DISPID_DXTCHECKERBOARD_DIRECTION	= 1,
	DISPID_DXTCHECKERBOARD_SQUARESX	= DISPID_DXTCHECKERBOARD_DIRECTION + 1,
	DISPID_DXTCHECKERBOARD_SQUARESY	= DISPID_DXTCHECKERBOARD_SQUARESX + 1
    } 	DISPID_DXTCHECKERBOARD;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0307_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0307_v0_0_s_ifspec;

#ifndef __IDXTCheckerBoard_INTERFACE_DEFINED__
#define __IDXTCheckerBoard_INTERFACE_DEFINED__

/* interface IDXTCheckerBoard */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTCheckerBoard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD3C2576-117C-4510-84DD-B668971DCFD1")
    IDXTCheckerBoard : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ BSTR *pbstrDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ BSTR bstrDirection) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SquaresX( 
            /* [retval][out] */ int *pnSquaresX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SquaresX( 
            /* [in] */ int nSquaresX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SquaresY( 
            /* [retval][out] */ int *pnSquaresY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SquaresY( 
            /* [in] */ int nSquaresY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCheckerBoardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTCheckerBoard * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTCheckerBoard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTCheckerBoard * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTCheckerBoard * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTCheckerBoard * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTCheckerBoard * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTCheckerBoard * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTCheckerBoard * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTCheckerBoard * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ BSTR *pbstrDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            IDXTCheckerBoard * This,
            /* [in] */ BSTR bstrDirection);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SquaresX )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ int *pnSquaresX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SquaresX )( 
            IDXTCheckerBoard * This,
            /* [in] */ int nSquaresX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SquaresY )( 
            IDXTCheckerBoard * This,
            /* [retval][out] */ int *pnSquaresY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SquaresY )( 
            IDXTCheckerBoard * This,
            /* [in] */ int nSquaresY);
        
        END_INTERFACE
    } IDXTCheckerBoardVtbl;

    interface IDXTCheckerBoard
    {
        CONST_VTBL struct IDXTCheckerBoardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTCheckerBoard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTCheckerBoard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTCheckerBoard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTCheckerBoard_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTCheckerBoard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTCheckerBoard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTCheckerBoard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTCheckerBoard_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTCheckerBoard_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTCheckerBoard_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTCheckerBoard_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTCheckerBoard_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTCheckerBoard_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTCheckerBoard_get_Direction(This,pbstrDirection)	\
    (This)->lpVtbl -> get_Direction(This,pbstrDirection)

#define IDXTCheckerBoard_put_Direction(This,bstrDirection)	\
    (This)->lpVtbl -> put_Direction(This,bstrDirection)

#define IDXTCheckerBoard_get_SquaresX(This,pnSquaresX)	\
    (This)->lpVtbl -> get_SquaresX(This,pnSquaresX)

#define IDXTCheckerBoard_put_SquaresX(This,nSquaresX)	\
    (This)->lpVtbl -> put_SquaresX(This,nSquaresX)

#define IDXTCheckerBoard_get_SquaresY(This,pnSquaresY)	\
    (This)->lpVtbl -> get_SquaresY(This,pnSquaresY)

#define IDXTCheckerBoard_put_SquaresY(This,nSquaresY)	\
    (This)->lpVtbl -> put_SquaresY(This,nSquaresY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_Direction_Proxy( 
    IDXTCheckerBoard * This,
    /* [retval][out] */ BSTR *pbstrDirection);


void __RPC_STUB IDXTCheckerBoard_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_Direction_Proxy( 
    IDXTCheckerBoard * This,
    /* [in] */ BSTR bstrDirection);


void __RPC_STUB IDXTCheckerBoard_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_SquaresX_Proxy( 
    IDXTCheckerBoard * This,
    /* [retval][out] */ int *pnSquaresX);


void __RPC_STUB IDXTCheckerBoard_get_SquaresX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_SquaresX_Proxy( 
    IDXTCheckerBoard * This,
    /* [in] */ int nSquaresX);


void __RPC_STUB IDXTCheckerBoard_put_SquaresX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_SquaresY_Proxy( 
    IDXTCheckerBoard * This,
    /* [retval][out] */ int *pnSquaresY);


void __RPC_STUB IDXTCheckerBoard_get_SquaresY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_SquaresY_Proxy( 
    IDXTCheckerBoard * This,
    /* [in] */ int nSquaresY);


void __RPC_STUB IDXTCheckerBoard_put_SquaresY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTCheckerBoard_INTERFACE_DEFINED__ */


#ifndef __IDXTRevealTrans_INTERFACE_DEFINED__
#define __IDXTRevealTrans_INTERFACE_DEFINED__

/* interface IDXTRevealTrans */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRevealTrans;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8095006-A128-464B-8B2D-90580AEE2B05")
    IDXTRevealTrans : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Transition( 
            /* [retval][out] */ int *pnTransition) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Transition( 
            /* [in] */ int nTransition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRevealTransVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTRevealTrans * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTRevealTrans * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTRevealTrans * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTRevealTrans * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTRevealTrans * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTRevealTrans * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTRevealTrans * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTRevealTrans * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTRevealTrans * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTRevealTrans * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTRevealTrans * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTRevealTrans * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTRevealTrans * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Transition )( 
            IDXTRevealTrans * This,
            /* [retval][out] */ int *pnTransition);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Transition )( 
            IDXTRevealTrans * This,
            /* [in] */ int nTransition);
        
        END_INTERFACE
    } IDXTRevealTransVtbl;

    interface IDXTRevealTrans
    {
        CONST_VTBL struct IDXTRevealTransVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRevealTrans_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRevealTrans_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRevealTrans_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRevealTrans_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRevealTrans_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRevealTrans_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRevealTrans_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRevealTrans_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRevealTrans_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRevealTrans_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRevealTrans_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRevealTrans_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRevealTrans_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRevealTrans_get_Transition(This,pnTransition)	\
    (This)->lpVtbl -> get_Transition(This,pnTransition)

#define IDXTRevealTrans_put_Transition(This,nTransition)	\
    (This)->lpVtbl -> put_Transition(This,nTransition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRevealTrans_get_Transition_Proxy( 
    IDXTRevealTrans * This,
    /* [retval][out] */ int *pnTransition);


void __RPC_STUB IDXTRevealTrans_get_Transition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRevealTrans_put_Transition_Proxy( 
    IDXTRevealTrans * This,
    /* [in] */ int nTransition);


void __RPC_STUB IDXTRevealTrans_put_Transition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRevealTrans_INTERFACE_DEFINED__ */


#ifndef __IDXTMask_INTERFACE_DEFINED__
#define __IDXTMask_INTERFACE_DEFINED__

/* interface IDXTMask */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1067146-B063-47d7-A54A-2C2309E9889D")
    IDXTMask : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT *pvarColor) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT varColor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMask * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMask * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMask * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMask * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMask * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            IDXTMask * This,
            /* [retval][out] */ VARIANT *pvarColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            IDXTMask * This,
            /* [in] */ VARIANT varColor);
        
        END_INTERFACE
    } IDXTMaskVtbl;

    interface IDXTMask
    {
        CONST_VTBL struct IDXTMaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMask_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMask_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMask_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMask_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMask_get_Color(This,pvarColor)	\
    (This)->lpVtbl -> get_Color(This,pvarColor)

#define IDXTMask_put_Color(This,varColor)	\
    (This)->lpVtbl -> put_Color(This,varColor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMask_get_Color_Proxy( 
    IDXTMask * This,
    /* [retval][out] */ VARIANT *pvarColor);


void __RPC_STUB IDXTMask_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMask_put_Color_Proxy( 
    IDXTMask * This,
    /* [in] */ VARIANT varColor);


void __RPC_STUB IDXTMask_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMask_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0310 */
/* [local] */ 

typedef 
enum DISPID_DXTREDIRECT
    {	DISPID_DXTREDIRECT_ELEMENTIMAGE	= 1,
	DISPID_DXTREDIRECT_SETDAVIEWHANDLER	= DISPID_DXTREDIRECT_ELEMENTIMAGE + 1,
	DISPID_DXTREDIRECT_HASIMAGEBEENALLOCATED	= DISPID_DXTREDIRECT_SETDAVIEWHANDLER + 1,
	DISPID_DXTREDIRECT_DOREDIRECTION	= DISPID_DXTREDIRECT_HASIMAGEBEENALLOCATED + 1
    } 	DISPID_DXTREDIRECT;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0310_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0310_v0_0_s_ifspec;

#ifndef __IDXTRedirect_INTERFACE_DEFINED__
#define __IDXTRedirect_INTERFACE_DEFINED__

/* interface IDXTRedirect */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRedirect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02F5140B-626F-4019-9C9E-2DAA1E93E8FC")
    IDXTRedirect : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ElementImage( 
            /* [retval][out] */ VARIANT *pvarImage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDAViewHandler( 
            /* [in] */ IDispatch *pDispViewHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE HasImageBeenAllocated( 
            /* [retval][out] */ BOOL *pfAllocated) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DoRedirection( 
            /* [in] */ IUnknown *pInputSurface,
            /* [in] */ HDC hdcOutput,
            /* [in] */ RECT *pDrawRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRedirectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTRedirect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTRedirect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTRedirect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTRedirect * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTRedirect * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTRedirect * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTRedirect * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ElementImage )( 
            IDXTRedirect * This,
            /* [retval][out] */ VARIANT *pvarImage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetDAViewHandler )( 
            IDXTRedirect * This,
            /* [in] */ IDispatch *pDispViewHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *HasImageBeenAllocated )( 
            IDXTRedirect * This,
            /* [retval][out] */ BOOL *pfAllocated);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *DoRedirection )( 
            IDXTRedirect * This,
            /* [in] */ IUnknown *pInputSurface,
            /* [in] */ HDC hdcOutput,
            /* [in] */ RECT *pDrawRect);
        
        END_INTERFACE
    } IDXTRedirectVtbl;

    interface IDXTRedirect
    {
        CONST_VTBL struct IDXTRedirectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRedirect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRedirect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRedirect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRedirect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRedirect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRedirect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRedirect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRedirect_ElementImage(This,pvarImage)	\
    (This)->lpVtbl -> ElementImage(This,pvarImage)

#define IDXTRedirect_SetDAViewHandler(This,pDispViewHandler)	\
    (This)->lpVtbl -> SetDAViewHandler(This,pDispViewHandler)

#define IDXTRedirect_HasImageBeenAllocated(This,pfAllocated)	\
    (This)->lpVtbl -> HasImageBeenAllocated(This,pfAllocated)

#define IDXTRedirect_DoRedirection(This,pInputSurface,hdcOutput,pDrawRect)	\
    (This)->lpVtbl -> DoRedirection(This,pInputSurface,hdcOutput,pDrawRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDXTRedirect_ElementImage_Proxy( 
    IDXTRedirect * This,
    /* [retval][out] */ VARIANT *pvarImage);


void __RPC_STUB IDXTRedirect_ElementImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTRedirect_SetDAViewHandler_Proxy( 
    IDXTRedirect * This,
    /* [in] */ IDispatch *pDispViewHandler);


void __RPC_STUB IDXTRedirect_SetDAViewHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTRedirect_HasImageBeenAllocated_Proxy( 
    IDXTRedirect * This,
    /* [retval][out] */ BOOL *pfAllocated);


void __RPC_STUB IDXTRedirect_HasImageBeenAllocated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTRedirect_DoRedirection_Proxy( 
    IDXTRedirect * This,
    /* [in] */ IUnknown *pInputSurface,
    /* [in] */ HDC hdcOutput,
    /* [in] */ RECT *pDrawRect);


void __RPC_STUB IDXTRedirect_DoRedirection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRedirect_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0311 */
/* [local] */ 

typedef 
enum DISPID_DXTALPHAIMAGELOADER
    {	DISPID_DXTALPHAIMAGELOADER_SRC	= 1,
	DISPID_DXTALPHAIMAGELOADER_SIZINGMETHOD	= DISPID_DXTALPHAIMAGELOADER_SRC + 1
    } 	DISPID_DXTALPHAIMAGELOADER;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0311_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0311_v0_0_s_ifspec;

#ifndef __IDXTAlphaImageLoader_INTERFACE_DEFINED__
#define __IDXTAlphaImageLoader_INTERFACE_DEFINED__

/* interface IDXTAlphaImageLoader */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTAlphaImageLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5F2D3E8-7A7E-48E5-BC75-40790BE4A941")
    IDXTAlphaImageLoader : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Src( 
            /* [retval][out] */ BSTR *pbstrSrc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Src( 
            /* [in] */ BSTR bstrSrc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SizingMethod( 
            /* [retval][out] */ BSTR *pbstrSizingMethod) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SizingMethod( 
            /* [in] */ BSTR bstrSizingMethod) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTAlphaImageLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTAlphaImageLoader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTAlphaImageLoader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTAlphaImageLoader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Src )( 
            IDXTAlphaImageLoader * This,
            /* [retval][out] */ BSTR *pbstrSrc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Src )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ BSTR bstrSrc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizingMethod )( 
            IDXTAlphaImageLoader * This,
            /* [retval][out] */ BSTR *pbstrSizingMethod);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizingMethod )( 
            IDXTAlphaImageLoader * This,
            /* [in] */ BSTR bstrSizingMethod);
        
        END_INTERFACE
    } IDXTAlphaImageLoaderVtbl;

    interface IDXTAlphaImageLoader
    {
        CONST_VTBL struct IDXTAlphaImageLoaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTAlphaImageLoader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTAlphaImageLoader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTAlphaImageLoader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTAlphaImageLoader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTAlphaImageLoader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTAlphaImageLoader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTAlphaImageLoader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTAlphaImageLoader_get_Src(This,pbstrSrc)	\
    (This)->lpVtbl -> get_Src(This,pbstrSrc)

#define IDXTAlphaImageLoader_put_Src(This,bstrSrc)	\
    (This)->lpVtbl -> put_Src(This,bstrSrc)

#define IDXTAlphaImageLoader_get_SizingMethod(This,pbstrSizingMethod)	\
    (This)->lpVtbl -> get_SizingMethod(This,pbstrSizingMethod)

#define IDXTAlphaImageLoader_put_SizingMethod(This,bstrSizingMethod)	\
    (This)->lpVtbl -> put_SizingMethod(This,bstrSizingMethod)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_get_Src_Proxy( 
    IDXTAlphaImageLoader * This,
    /* [retval][out] */ BSTR *pbstrSrc);


void __RPC_STUB IDXTAlphaImageLoader_get_Src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_put_Src_Proxy( 
    IDXTAlphaImageLoader * This,
    /* [in] */ BSTR bstrSrc);


void __RPC_STUB IDXTAlphaImageLoader_put_Src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_get_SizingMethod_Proxy( 
    IDXTAlphaImageLoader * This,
    /* [retval][out] */ BSTR *pbstrSizingMethod);


void __RPC_STUB IDXTAlphaImageLoader_get_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_put_SizingMethod_Proxy( 
    IDXTAlphaImageLoader * This,
    /* [in] */ BSTR bstrSizingMethod);


void __RPC_STUB IDXTAlphaImageLoader_put_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTAlphaImageLoader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0312 */
/* [local] */ 

typedef 
enum DISPID_DXTRANDOMBARS
    {	DISPID_DXTRANDOMBARS_ORIENTATION	= 1
    } 	DISPID_DXTRANDOMBARS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0312_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0312_v0_0_s_ifspec;

#ifndef __IDXTRandomBars_INTERFACE_DEFINED__
#define __IDXTRandomBars_INTERFACE_DEFINED__

/* interface IDXTRandomBars */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRandomBars;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A6D2022-4A8F-4EB9-BB25-AA05201F9C84")
    IDXTRandomBars : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ BSTR *pbstrOrientation) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ BSTR bstrOrientation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRandomBarsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTRandomBars * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTRandomBars * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTRandomBars * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTRandomBars * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTRandomBars * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTRandomBars * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTRandomBars * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTRandomBars * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTRandomBars * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTRandomBars * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTRandomBars * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTRandomBars * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTRandomBars * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Orientation )( 
            IDXTRandomBars * This,
            /* [retval][out] */ BSTR *pbstrOrientation);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Orientation )( 
            IDXTRandomBars * This,
            /* [in] */ BSTR bstrOrientation);
        
        END_INTERFACE
    } IDXTRandomBarsVtbl;

    interface IDXTRandomBars
    {
        CONST_VTBL struct IDXTRandomBarsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRandomBars_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRandomBars_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRandomBars_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRandomBars_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRandomBars_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRandomBars_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRandomBars_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRandomBars_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRandomBars_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRandomBars_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRandomBars_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRandomBars_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRandomBars_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRandomBars_get_Orientation(This,pbstrOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,pbstrOrientation)

#define IDXTRandomBars_put_Orientation(This,bstrOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,bstrOrientation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRandomBars_get_Orientation_Proxy( 
    IDXTRandomBars * This,
    /* [retval][out] */ BSTR *pbstrOrientation);


void __RPC_STUB IDXTRandomBars_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRandomBars_put_Orientation_Proxy( 
    IDXTRandomBars * This,
    /* [in] */ BSTR bstrOrientation);


void __RPC_STUB IDXTRandomBars_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRandomBars_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0313 */
/* [local] */ 

typedef 
enum DISPID_DXTSTRIPS
    {	DISPID_DXTSTRIPS_MOTION	= 1
    } 	DISPID_DXTSTRIPS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0313_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0313_v0_0_s_ifspec;

#ifndef __IDXTStrips_INTERFACE_DEFINED__
#define __IDXTStrips_INTERFACE_DEFINED__

/* interface IDXTStrips */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTStrips;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A83C9B5C-FB11-4AF5-8F65-D03F151D3ED5")
    IDXTStrips : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTStripsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTStrips * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTStrips * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTStrips * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTStrips * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTStrips * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTStrips * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTStrips * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTStrips * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTStrips * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTStrips * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTStrips * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTStrips * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTStrips * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Motion )( 
            IDXTStrips * This,
            /* [retval][out] */ BSTR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Motion )( 
            IDXTStrips * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } IDXTStripsVtbl;

    interface IDXTStrips
    {
        CONST_VTBL struct IDXTStripsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTStrips_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTStrips_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTStrips_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTStrips_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTStrips_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTStrips_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTStrips_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTStrips_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTStrips_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTStrips_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTStrips_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTStrips_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTStrips_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTStrips_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define IDXTStrips_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTStrips_get_Motion_Proxy( 
    IDXTStrips * This,
    /* [retval][out] */ BSTR *pbstrMotion);


void __RPC_STUB IDXTStrips_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTStrips_put_Motion_Proxy( 
    IDXTStrips * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB IDXTStrips_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTStrips_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRoll_INTERFACE_DEFINED__
#define __IDXTMetaRoll_INTERFACE_DEFINED__

/* interface IDXTMetaRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C61F46D-0530-11D2-8F98-00C04FB92EB7")
    IDXTMetaRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaRoll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaRoll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaRoll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaRoll * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaRoll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaRoll * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaRoll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaRoll * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaRoll * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaRoll * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaRoll * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaRoll * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaRoll * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaRoll * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaRoll * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRollVtbl;

    interface IDXTMetaRoll
    {
        CONST_VTBL struct IDXTMetaRollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRoll_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRoll_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_get_Copyright_Proxy( 
    IDXTMetaRoll * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaRoll_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_put_Copyright_Proxy( 
    IDXTMetaRoll * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRoll_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRipple_INTERFACE_DEFINED__
#define __IDXTMetaRipple_INTERFACE_DEFINED__

/* interface IDXTMetaRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D02-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaRipple * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaRipple * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaRipple * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaRipple * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaRipple * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaRipple * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaRipple * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaRipple * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaRipple * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaRipple * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaRipple * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaRipple * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaRipple * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaRipple * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaRipple * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRippleVtbl;

    interface IDXTMetaRipple
    {
        CONST_VTBL struct IDXTMetaRippleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRipple_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRipple_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_get_Copyright_Proxy( 
    IDXTMetaRipple * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaRipple_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_put_Copyright_Proxy( 
    IDXTMetaRipple * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRipple_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRipple_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPageTurn_INTERFACE_DEFINED__
#define __IDXTMetaPageTurn_INTERFACE_DEFINED__

/* interface IDXTMetaPageTurn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPageTurn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D07-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPageTurn : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPageTurnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaPageTurn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaPageTurn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaPageTurn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaPageTurn * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaPageTurn * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaPageTurn * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaPageTurn * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaPageTurn * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaPageTurn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaPageTurn * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaPageTurn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaPageTurn * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaPageTurn * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaPageTurn * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaPageTurn * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPageTurnVtbl;

    interface IDXTMetaPageTurn
    {
        CONST_VTBL struct IDXTMetaPageTurnVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPageTurn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPageTurn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPageTurn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPageTurn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPageTurn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPageTurn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPageTurn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPageTurn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPageTurn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPageTurn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPageTurn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPageTurn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPageTurn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPageTurn_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPageTurn_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_get_Copyright_Proxy( 
    IDXTMetaPageTurn * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaPageTurn_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_put_Copyright_Proxy( 
    IDXTMetaPageTurn * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPageTurn_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPageTurn_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLiquid_INTERFACE_DEFINED__
#define __IDXTMetaLiquid_INTERFACE_DEFINED__

/* interface IDXTMetaLiquid */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLiquid;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D09-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaLiquid : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLiquidVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaLiquid * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaLiquid * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaLiquid * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaLiquid * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaLiquid * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaLiquid * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaLiquid * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaLiquid * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaLiquid * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaLiquid * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaLiquid * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaLiquid * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaLiquid * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaLiquid * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaLiquid * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLiquidVtbl;

    interface IDXTMetaLiquid
    {
        CONST_VTBL struct IDXTMetaLiquidVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLiquid_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLiquid_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLiquid_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLiquid_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLiquid_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLiquid_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLiquid_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLiquid_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLiquid_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLiquid_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLiquid_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLiquid_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLiquid_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLiquid_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLiquid_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_get_Copyright_Proxy( 
    IDXTMetaLiquid * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaLiquid_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_put_Copyright_Proxy( 
    IDXTMetaLiquid * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLiquid_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLiquid_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_INTERFACE_DEFINED__
#define __IDXTMetaCenterPeel_INTERFACE_DEFINED__

/* interface IDXTMetaCenterPeel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaCenterPeel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0B-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaCenterPeel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaCenterPeelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaCenterPeel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaCenterPeel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaCenterPeel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaCenterPeel * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaCenterPeel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaCenterPeel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaCenterPeel * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaCenterPeel * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaCenterPeel * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaCenterPeelVtbl;

    interface IDXTMetaCenterPeel
    {
        CONST_VTBL struct IDXTMetaCenterPeelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaCenterPeel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaCenterPeel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaCenterPeel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaCenterPeel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaCenterPeel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaCenterPeel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaCenterPeel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaCenterPeel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaCenterPeel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaCenterPeel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaCenterPeel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaCenterPeel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaCenterPeel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaCenterPeel_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaCenterPeel_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_get_Copyright_Proxy( 
    IDXTMetaCenterPeel * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaCenterPeel_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_put_Copyright_Proxy( 
    IDXTMetaCenterPeel * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaCenterPeel_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaCenterPeel_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_INTERFACE_DEFINED__
#define __IDXTMetaPeelSmall_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSmall */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSmall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0D-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSmall : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSmallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaPeelSmall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaPeelSmall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaPeelSmall * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaPeelSmall * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaPeelSmall * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaPeelSmall * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaPeelSmall * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaPeelSmall * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaPeelSmall * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSmallVtbl;

    interface IDXTMetaPeelSmall
    {
        CONST_VTBL struct IDXTMetaPeelSmallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSmall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSmall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSmall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSmall_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSmall_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSmall_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSmall_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSmall_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSmall_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSmall_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSmall_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSmall_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSmall_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSmall_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSmall_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_get_Copyright_Proxy( 
    IDXTMetaPeelSmall * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaPeelSmall_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_put_Copyright_Proxy( 
    IDXTMetaPeelSmall * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSmall_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSmall_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_INTERFACE_DEFINED__
#define __IDXTMetaPeelPiece_INTERFACE_DEFINED__

/* interface IDXTMetaPeelPiece */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelPiece;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0F-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelPiece : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelPieceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaPeelPiece * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaPeelPiece * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaPeelPiece * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaPeelPiece * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaPeelPiece * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaPeelPiece * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaPeelPiece * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaPeelPiece * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaPeelPiece * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelPieceVtbl;

    interface IDXTMetaPeelPiece
    {
        CONST_VTBL struct IDXTMetaPeelPieceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelPiece_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelPiece_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelPiece_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelPiece_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelPiece_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelPiece_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelPiece_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelPiece_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelPiece_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelPiece_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelPiece_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelPiece_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelPiece_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelPiece_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelPiece_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_get_Copyright_Proxy( 
    IDXTMetaPeelPiece * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaPeelPiece_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_put_Copyright_Proxy( 
    IDXTMetaPeelPiece * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelPiece_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelPiece_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_INTERFACE_DEFINED__
#define __IDXTMetaPeelSplit_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSplit */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSplit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D11-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSplit : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSplitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaPeelSplit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaPeelSplit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaPeelSplit * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaPeelSplit * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaPeelSplit * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaPeelSplit * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaPeelSplit * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaPeelSplit * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaPeelSplit * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSplitVtbl;

    interface IDXTMetaPeelSplit
    {
        CONST_VTBL struct IDXTMetaPeelSplitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSplit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSplit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSplit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSplit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSplit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSplit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSplit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSplit_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSplit_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSplit_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSplit_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSplit_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSplit_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSplit_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSplit_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_get_Copyright_Proxy( 
    IDXTMetaPeelSplit * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaPeelSplit_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_put_Copyright_Proxy( 
    IDXTMetaPeelSplit * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSplit_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSplit_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWater_INTERFACE_DEFINED__
#define __IDXTMetaWater_INTERFACE_DEFINED__

/* interface IDXTMetaWater */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWater;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C4-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWater : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWaterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaWater * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaWater * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaWater * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaWater * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaWater * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaWater * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaWater * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaWater * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaWater * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaWater * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaWater * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaWater * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaWater * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaWater * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaWater * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWaterVtbl;

    interface IDXTMetaWater
    {
        CONST_VTBL struct IDXTMetaWaterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWater_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWater_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWater_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWater_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWater_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWater_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWater_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWater_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWater_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWater_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWater_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWater_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWater_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWater_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWater_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_get_Copyright_Proxy( 
    IDXTMetaWater * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaWater_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_put_Copyright_Proxy( 
    IDXTMetaWater * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWater_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWater_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLightWipe_INTERFACE_DEFINED__
#define __IDXTMetaLightWipe_INTERFACE_DEFINED__

/* interface IDXTMetaLightWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLightWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C7-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaLightWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLightWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaLightWipe * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaLightWipe * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaLightWipe * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaLightWipe * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaLightWipe * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaLightWipe * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaLightWipe * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaLightWipe * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaLightWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaLightWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaLightWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaLightWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaLightWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaLightWipe * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaLightWipe * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLightWipeVtbl;

    interface IDXTMetaLightWipe
    {
        CONST_VTBL struct IDXTMetaLightWipeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLightWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLightWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLightWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLightWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLightWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLightWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLightWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLightWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLightWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLightWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLightWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLightWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLightWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLightWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLightWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_get_Copyright_Proxy( 
    IDXTMetaLightWipe * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaLightWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_put_Copyright_Proxy( 
    IDXTMetaLightWipe * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLightWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLightWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__
#define __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__

/* interface IDXTMetaRadialScaleWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRadialScaleWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C9-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaRadialScaleWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRadialScaleWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaRadialScaleWipe * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaRadialScaleWipe * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaRadialScaleWipe * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaRadialScaleWipe * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaRadialScaleWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaRadialScaleWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaRadialScaleWipe * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaRadialScaleWipe * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaRadialScaleWipe * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRadialScaleWipeVtbl;

    interface IDXTMetaRadialScaleWipe
    {
        CONST_VTBL struct IDXTMetaRadialScaleWipeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRadialScaleWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRadialScaleWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRadialScaleWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRadialScaleWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRadialScaleWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRadialScaleWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRadialScaleWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRadialScaleWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRadialScaleWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRadialScaleWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_get_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_put_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_INTERFACE_DEFINED__
#define __IDXTMetaWhiteOut_INTERFACE_DEFINED__

/* interface IDXTMetaWhiteOut */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWhiteOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CB-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWhiteOut : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWhiteOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaWhiteOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaWhiteOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaWhiteOut * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaWhiteOut * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaWhiteOut * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaWhiteOut * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaWhiteOut * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaWhiteOut * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaWhiteOut * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWhiteOutVtbl;

    interface IDXTMetaWhiteOut
    {
        CONST_VTBL struct IDXTMetaWhiteOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWhiteOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWhiteOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWhiteOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWhiteOut_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWhiteOut_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWhiteOut_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWhiteOut_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWhiteOut_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWhiteOut_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWhiteOut_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWhiteOut_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWhiteOut_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWhiteOut_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWhiteOut_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWhiteOut_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_get_Copyright_Proxy( 
    IDXTMetaWhiteOut * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaWhiteOut_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_put_Copyright_Proxy( 
    IDXTMetaWhiteOut * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWhiteOut_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWhiteOut_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaTwister_INTERFACE_DEFINED__
#define __IDXTMetaTwister_INTERFACE_DEFINED__

/* interface IDXTMetaTwister */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaTwister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CE-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaTwister : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaTwisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaTwister * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaTwister * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaTwister * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaTwister * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaTwister * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaTwister * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaTwister * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaTwister * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaTwister * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaTwister * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaTwister * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaTwister * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaTwister * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaTwister * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaTwister * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaTwisterVtbl;

    interface IDXTMetaTwister
    {
        CONST_VTBL struct IDXTMetaTwisterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaTwister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaTwister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaTwister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaTwister_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaTwister_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaTwister_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaTwister_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaTwister_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaTwister_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaTwister_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaTwister_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaTwister_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaTwister_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaTwister_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaTwister_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_get_Copyright_Proxy( 
    IDXTMetaTwister * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaTwister_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_put_Copyright_Proxy( 
    IDXTMetaTwister * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaTwister_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaTwister_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_INTERFACE_DEFINED__
#define __IDXTMetaBurnFilm_INTERFACE_DEFINED__

/* interface IDXTMetaBurnFilm */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaBurnFilm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045D0-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaBurnFilm : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaBurnFilmVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaBurnFilm * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaBurnFilm * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaBurnFilm * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaBurnFilm * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaBurnFilm * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaBurnFilm * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaBurnFilm * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaBurnFilm * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaBurnFilm * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaBurnFilmVtbl;

    interface IDXTMetaBurnFilm
    {
        CONST_VTBL struct IDXTMetaBurnFilmVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaBurnFilm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaBurnFilm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaBurnFilm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaBurnFilm_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaBurnFilm_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaBurnFilm_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaBurnFilm_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaBurnFilm_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaBurnFilm_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaBurnFilm_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaBurnFilm_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaBurnFilm_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaBurnFilm_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaBurnFilm_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaBurnFilm_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_get_Copyright_Proxy( 
    IDXTMetaBurnFilm * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaBurnFilm_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_put_Copyright_Proxy( 
    IDXTMetaBurnFilm * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaBurnFilm_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaBurnFilm_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaJaws_INTERFACE_DEFINED__
#define __IDXTMetaJaws_INTERFACE_DEFINED__

/* interface IDXTMetaJaws */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaJaws;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C903-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaJaws : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaJawsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaJaws * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaJaws * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaJaws * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaJaws * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaJaws * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaJaws * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaJaws * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaJaws * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaJaws * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaJaws * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaJaws * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaJaws * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaJaws * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaJaws * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaJaws * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaJawsVtbl;

    interface IDXTMetaJaws
    {
        CONST_VTBL struct IDXTMetaJawsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaJaws_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaJaws_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaJaws_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaJaws_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaJaws_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaJaws_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaJaws_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaJaws_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaJaws_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaJaws_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaJaws_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaJaws_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaJaws_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaJaws_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaJaws_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_get_Copyright_Proxy( 
    IDXTMetaJaws * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaJaws_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_put_Copyright_Proxy( 
    IDXTMetaJaws * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaJaws_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaJaws_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaColorFade_INTERFACE_DEFINED__
#define __IDXTMetaColorFade_INTERFACE_DEFINED__

/* interface IDXTMetaColorFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaColorFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C907-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaColorFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaColorFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaColorFade * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaColorFade * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaColorFade * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaColorFade * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaColorFade * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaColorFade * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaColorFade * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaColorFade * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaColorFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaColorFade * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaColorFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaColorFade * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaColorFade * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaColorFade * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaColorFade * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaColorFadeVtbl;

    interface IDXTMetaColorFade
    {
        CONST_VTBL struct IDXTMetaColorFadeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaColorFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaColorFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaColorFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaColorFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaColorFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaColorFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaColorFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaColorFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaColorFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaColorFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaColorFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaColorFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaColorFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaColorFade_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaColorFade_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_get_Copyright_Proxy( 
    IDXTMetaColorFade * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaColorFade_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_put_Copyright_Proxy( 
    IDXTMetaColorFade * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaColorFade_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaColorFade_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_INTERFACE_DEFINED__
#define __IDXTMetaFlowMotion_INTERFACE_DEFINED__

/* interface IDXTMetaFlowMotion */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaFlowMotion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90A-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaFlowMotion : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaFlowMotionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaFlowMotion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaFlowMotion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaFlowMotion * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaFlowMotion * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaFlowMotion * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaFlowMotion * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaFlowMotion * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaFlowMotion * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaFlowMotion * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaFlowMotionVtbl;

    interface IDXTMetaFlowMotion
    {
        CONST_VTBL struct IDXTMetaFlowMotionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaFlowMotion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaFlowMotion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaFlowMotion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaFlowMotion_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaFlowMotion_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaFlowMotion_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaFlowMotion_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaFlowMotion_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaFlowMotion_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaFlowMotion_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaFlowMotion_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaFlowMotion_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaFlowMotion_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaFlowMotion_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaFlowMotion_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_get_Copyright_Proxy( 
    IDXTMetaFlowMotion * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaFlowMotion_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_put_Copyright_Proxy( 
    IDXTMetaFlowMotion * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaFlowMotion_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaFlowMotion_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaVacuum_INTERFACE_DEFINED__
#define __IDXTMetaVacuum_INTERFACE_DEFINED__

/* interface IDXTMetaVacuum */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaVacuum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90C-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaVacuum : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaVacuumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaVacuum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaVacuum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaVacuum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaVacuum * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaVacuum * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaVacuum * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaVacuum * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaVacuum * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaVacuum * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaVacuum * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaVacuum * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaVacuum * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaVacuum * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaVacuum * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaVacuum * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaVacuumVtbl;

    interface IDXTMetaVacuum
    {
        CONST_VTBL struct IDXTMetaVacuumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaVacuum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaVacuum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaVacuum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaVacuum_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaVacuum_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaVacuum_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaVacuum_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaVacuum_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaVacuum_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaVacuum_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaVacuum_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaVacuum_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaVacuum_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaVacuum_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaVacuum_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_get_Copyright_Proxy( 
    IDXTMetaVacuum * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaVacuum_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_put_Copyright_Proxy( 
    IDXTMetaVacuum * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaVacuum_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaVacuum_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler_INTERFACE_DEFINED__
#define __IDXTMetaGriddler_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C910-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaGriddler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaGriddler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaGriddler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaGriddler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaGriddler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaGriddler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaGriddler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaGriddler * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaGriddler * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaGriddler * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaGriddler * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaGriddler * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaGriddler * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaGriddler * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaGriddler * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddlerVtbl;

    interface IDXTMetaGriddler
    {
        CONST_VTBL struct IDXTMetaGriddlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_get_Copyright_Proxy( 
    IDXTMetaGriddler * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaGriddler_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_put_Copyright_Proxy( 
    IDXTMetaGriddler * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler2_INTERFACE_DEFINED__
#define __IDXTMetaGriddler2_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C912-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler2 : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddler2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaGriddler2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaGriddler2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaGriddler2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaGriddler2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaGriddler2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaGriddler2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaGriddler2 * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaGriddler2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaGriddler2 * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddler2Vtbl;

    interface IDXTMetaGriddler2
    {
        CONST_VTBL struct IDXTMetaGriddler2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler2_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler2_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_get_Copyright_Proxy( 
    IDXTMetaGriddler2 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaGriddler2_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_put_Copyright_Proxy( 
    IDXTMetaGriddler2 * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler2_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler2_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaThreshold_INTERFACE_DEFINED__
#define __IDXTMetaThreshold_INTERFACE_DEFINED__

/* interface IDXTMetaThreshold */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaThreshold;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C914-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaThreshold : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaThresholdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaThreshold * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaThreshold * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaThreshold * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaThreshold * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaThreshold * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaThreshold * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaThreshold * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaThreshold * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaThreshold * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaThreshold * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaThreshold * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaThreshold * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaThreshold * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaThreshold * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaThreshold * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaThresholdVtbl;

    interface IDXTMetaThreshold
    {
        CONST_VTBL struct IDXTMetaThresholdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaThreshold_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaThreshold_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaThreshold_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaThreshold_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaThreshold_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaThreshold_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaThreshold_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaThreshold_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaThreshold_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaThreshold_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaThreshold_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaThreshold_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaThreshold_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaThreshold_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaThreshold_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_get_Copyright_Proxy( 
    IDXTMetaThreshold * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaThreshold_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_put_Copyright_Proxy( 
    IDXTMetaThreshold * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaThreshold_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaThreshold_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWormHole_INTERFACE_DEFINED__
#define __IDXTMetaWormHole_INTERFACE_DEFINED__

/* interface IDXTMetaWormHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWormHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E6AE021-0C83-11D2-8CD4-00104BC75D9A")
    IDXTMetaWormHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWormHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMetaWormHole * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMetaWormHole * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMetaWormHole * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMetaWormHole * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMetaWormHole * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMetaWormHole * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMetaWormHole * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXTMetaWormHole * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXTMetaWormHole * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXTMetaWormHole * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXTMetaWormHole * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXTMetaWormHole * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXTMetaWormHole * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IDXTMetaWormHole * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Copyright )( 
            IDXTMetaWormHole * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWormHoleVtbl;

    interface IDXTMetaWormHole
    {
        CONST_VTBL struct IDXTMetaWormHoleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWormHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWormHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWormHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWormHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWormHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWormHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWormHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWormHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWormHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWormHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWormHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWormHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWormHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWormHole_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWormHole_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_get_Copyright_Proxy( 
    IDXTMetaWormHole * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IDXTMetaWormHole_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_put_Copyright_Proxy( 
    IDXTMetaWormHole * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWormHole_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWormHole_INTERFACE_DEFINED__ */


#ifndef __IDXTAlpha_INTERFACE_DEFINED__
#define __IDXTAlpha_INTERFACE_DEFINED__

/* interface IDXTAlpha */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTAlpha;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E0-383C-11d2-952A-00C04FA34F05")
    IDXTAlpha : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishOpacity( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishOpacity( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartX( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartY( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishX( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishY( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishY( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTAlphaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTAlpha * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTAlpha * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTAlpha * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTAlpha * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTAlpha * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTAlpha * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTAlpha * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Opacity )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Opacity )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FinishOpacity )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FinishOpacity )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Style )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Style )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartX )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartX )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartY )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartY )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FinishX )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FinishX )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FinishY )( 
            IDXTAlpha * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FinishY )( 
            IDXTAlpha * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTAlphaVtbl;

    interface IDXTAlpha
    {
        CONST_VTBL struct IDXTAlphaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTAlpha_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTAlpha_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTAlpha_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTAlpha_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTAlpha_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTAlpha_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTAlpha_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTAlpha_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXTAlpha_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXTAlpha_get_FinishOpacity(This,pVal)	\
    (This)->lpVtbl -> get_FinishOpacity(This,pVal)

#define IDXTAlpha_put_FinishOpacity(This,newVal)	\
    (This)->lpVtbl -> put_FinishOpacity(This,newVal)

#define IDXTAlpha_get_Style(This,pVal)	\
    (This)->lpVtbl -> get_Style(This,pVal)

#define IDXTAlpha_put_Style(This,newVal)	\
    (This)->lpVtbl -> put_Style(This,newVal)

#define IDXTAlpha_get_StartX(This,pVal)	\
    (This)->lpVtbl -> get_StartX(This,pVal)

#define IDXTAlpha_put_StartX(This,newVal)	\
    (This)->lpVtbl -> put_StartX(This,newVal)

#define IDXTAlpha_get_StartY(This,pVal)	\
    (This)->lpVtbl -> get_StartY(This,pVal)

#define IDXTAlpha_put_StartY(This,newVal)	\
    (This)->lpVtbl -> put_StartY(This,newVal)

#define IDXTAlpha_get_FinishX(This,pVal)	\
    (This)->lpVtbl -> get_FinishX(This,pVal)

#define IDXTAlpha_put_FinishX(This,newVal)	\
    (This)->lpVtbl -> put_FinishX(This,newVal)

#define IDXTAlpha_get_FinishY(This,pVal)	\
    (This)->lpVtbl -> get_FinishY(This,pVal)

#define IDXTAlpha_put_FinishY(This,newVal)	\
    (This)->lpVtbl -> put_FinishY(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_Opacity_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_Opacity_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishOpacity_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_FinishOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishOpacity_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_Style_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_Style_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_StartX_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_StartX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_StartX_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_StartX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_StartY_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_StartY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_StartY_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_StartY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishX_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_FinishX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishX_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishY_Proxy( 
    IDXTAlpha * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTAlpha_get_FinishY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishY_Proxy( 
    IDXTAlpha * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTAlpha_INTERFACE_DEFINED__ */


#ifndef __IDXTGlow_INTERFACE_DEFINED__
#define __IDXTGlow_INTERFACE_DEFINED__

/* interface IDXTGlow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGlow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E4-383C-11d2-952A-00C04FA34F05")
    IDXTGlow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT *pvarColor) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT varColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGlowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTGlow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTGlow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTGlow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTGlow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTGlow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTGlow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTGlow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            IDXTGlow * This,
            /* [retval][out] */ VARIANT *pvarColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            IDXTGlow * This,
            /* [in] */ VARIANT varColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Strength )( 
            IDXTGlow * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Strength )( 
            IDXTGlow * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTGlowVtbl;

    interface IDXTGlow
    {
        CONST_VTBL struct IDXTGlowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGlow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGlow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGlow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGlow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGlow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGlow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGlow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGlow_get_Color(This,pvarColor)	\
    (This)->lpVtbl -> get_Color(This,pvarColor)

#define IDXTGlow_put_Color(This,varColor)	\
    (This)->lpVtbl -> put_Color(This,varColor)

#define IDXTGlow_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTGlow_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGlow_get_Color_Proxy( 
    IDXTGlow * This,
    /* [retval][out] */ VARIANT *pvarColor);


void __RPC_STUB IDXTGlow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGlow_put_Color_Proxy( 
    IDXTGlow * This,
    /* [in] */ VARIANT varColor);


void __RPC_STUB IDXTGlow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGlow_get_Strength_Proxy( 
    IDXTGlow * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTGlow_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGlow_put_Strength_Proxy( 
    IDXTGlow * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGlow_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGlow_INTERFACE_DEFINED__ */


#ifndef __IDXTShadow_INTERFACE_DEFINED__
#define __IDXTShadow_INTERFACE_DEFINED__

/* interface IDXTShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E6-383C-11d2-952A-00C04FA34F05")
    IDXTShadow : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ BSTR bstrColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ BSTR *pbstrColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTShadow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTShadow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTShadow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTShadow * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTShadow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTShadow * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTShadow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
      